; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPlot.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@BIOENABP@daf6f887?93614?94169?9a0e5?93ac9bd4e@ ; `string'
PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
_CIV5_DLC_04_SCENARIO_MODID DD FLAT:??_C@_0CF@BIOENABP@daf6f887?93614?94169?9a0e5?93ac9bd4e@
CONST	ENDS
;	COMDAT ??_C@_0CF@BIOENABP@daf6f887?93614?94169?9a0e5?93ac9bd4e@
CONST	SEGMENT
??_C@_0CF@BIOENABP@daf6f887?93614?94169?9a0e5?93ac9bd4e@ DB 'daf6f887-361'
	DB	'4-4169-a0e5-3ac9bd4ef82b', 00H		; `string'
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
PUBLIC	??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ	; CvPlot::getSyncArchive
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
PUBLIC	?SyncPlots@FSerialization@@YAXXZ		; FSerialization::SyncPlots
EXTRN	??1FMemoryStream@@UAE@XZ:PROC			; FMemoryStream::~FMemoryStream
EXTRN	?saveDelta@FAutoArchive@@QBEXAAVFDataStream@@AAV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@@Z:PROC ; FAutoArchive::saveDelta
EXTRN	??0FMemoryStream@@QAE@XZ:PROC			; FMemoryStream::FMemoryStream
EXTRN	?hasDeltas@FAutoArchive@@QBE_NXZ:PROC		; FAutoArchive::hasDeltas
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?isNetworkMultiPlayer@CvGame@@QBE_NXZ:PROC	; CvGame::isNetworkMultiPlayer
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?SyncPlots@FSerialization@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$4
__ehfuncinfo$?SyncPlots@FSerialization@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SyncPlots@FSerialization@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?SyncPlots@FSerialization@@YAXXZ
_TEXT	SEGMENT
tv165 = -180						; size = 4
$T229505 = -148						; size = 4
$T229501 = -144						; size = 4
$T229444 = -120						; size = 4
$T229421 = -116						; size = 4
$T229408 = -112						; size = 4
$T229399 = -108						; size = 4
$T229395 = -104						; size = 4
$T229389 = -100						; size = 4
$T229388 = -96						; size = 4
_memoryStream$221305 = -92				; size = 48
_callStacks$221607 = -44				; size = 16
_archive$221303 = -28					; size = 4
_plot$221301 = -24					; size = 4
_authoritativePlayer$221192 = -20			; size = 4
_i$221275 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SyncPlots@FSerialization@@YAXXZ PROC			; FSerialization::SyncPlots, COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SyncPlots@FSerialization@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 61   : 	if(GC.getGame().isNetworkMultiPlayer())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229395[ebp], eax
	mov	ecx, DWORD PTR $T229395[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@SyncPlots

; 62   : 	{
; 63   : 		PlayerTypes authoritativePlayer = GC.getGame().getActivePlayer();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T229399[ebp], edx
	mov	ecx, DWORD PTR $T229399[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _authoritativePlayer$221192[ebp], eax

; 64   : 		std::set<CvPlot*>::const_iterator i;

	mov	DWORD PTR _i$221275[ebp], 0

; 65   : 		for(i = plotsToCheck.begin(); i != plotsToCheck.end(); ++i)

	mov	eax, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	DWORD PTR $T229408[ebp], eax
	mov	ecx, DWORD PTR $T229408[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T229421[ebp], edx
	mov	eax, DWORD PTR $T229421[ebp]
	mov	DWORD PTR $T229388[ebp], eax
	mov	ecx, DWORD PTR $T229388[ebp]
	mov	DWORD PTR _i$221275[ebp], ecx
	jmp	SHORT $LN5@SyncPlots
$LN4@SyncPlots:
	lea	ecx, DWORD PTR _i$221275[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
$LN5@SyncPlots:
	mov	edx, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	DWORD PTR $T229444[ebp], edx
	mov	eax, DWORD PTR $T229444[ebp]
	mov	DWORD PTR $T229389[ebp], eax
	mov	ecx, DWORD PTR _i$221275[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T229389[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@SyncPlots

; 66   : 		{
; 67   : 			const CvPlot* plot = *i;

	mov	edx, DWORD PTR _i$221275[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _plot$221301[ebp], eax

; 68   : 
; 69   : 			if(plot)

	cmp	DWORD PTR _plot$221301[ebp], 0
	je	$LN2@SyncPlots

; 70   : 			{
; 71   : 				const FAutoArchive& archive = plot->getSyncArchive();

	mov	ecx, DWORD PTR _plot$221301[ebp]
	call	?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ ; CvPlot::getSyncArchive
	mov	DWORD PTR _archive$221303[ebp], eax

; 72   : 				if(archive.hasDeltas())

	mov	ecx, DWORD PTR _archive$221303[ebp]
	call	?hasDeltas@FAutoArchive@@QBE_NXZ	; FAutoArchive::hasDeltas
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@SyncPlots

; 73   : 				{
; 74   : 					FMemoryStream memoryStream;

	lea	ecx, DWORD PTR _memoryStream$221305[ebp]
	call	??0FMemoryStream@@QAE@XZ		; FMemoryStream::FMemoryStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 75   : 					std::vector<std::pair<std::string, std::string> > callStacks;

	lea	ecx, DWORD PTR _callStacks$221607[ebp]
	call	??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 76   : 					archive.saveDelta(memoryStream, callStacks);

	lea	edx, DWORD PTR _callStacks$221607[ebp]
	push	edx
	lea	eax, DWORD PTR _memoryStream$221305[ebp]
	push	eax
	mov	ecx, DWORD PTR _archive$221303[ebp]
	call	?saveDelta@FAutoArchive@@QBEXAAVFDataStream@@AAV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@@Z ; FAutoArchive::saveDelta

; 77   : #ifdef AUI_WARNING_FIXES
; 78   : 					gDLL->sendPlotSyncCheck(authoritativePlayer, short(plot->getX()), short(plot->getY()), memoryStream, callStacks);
; 79   : #else
; 80   : 					gDLL->sendPlotSyncCheck(authoritativePlayer, plot->getX(), plot->getY(), memoryStream, callStacks);

	mov	ecx, DWORD PTR $T229501[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv165[ebp], edx
	mov	eax, DWORD PTR _plot$221301[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T229505[ebp], ecx
	lea	edx, DWORD PTR _callStacks$221607[ebp]
	push	edx
	lea	eax, DWORD PTR _memoryStream$221305[ebp]
	push	eax
	movzx	ecx, WORD PTR $T229505[ebp]
	push	ecx
	mov	edx, DWORD PTR _plot$221301[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _authoritativePlayer$221192[ebp]
	push	ecx
	mov	edx, DWORD PTR tv165[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv165[ebp]
	mov	edx, DWORD PTR [eax+340]
	call	edx

; 81   : #endif
; 82   : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _callStacks$221607[ebp]
	call	?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _memoryStream$221305[ebp]
	call	??1FMemoryStream@@UAE@XZ		; FMemoryStream::~FMemoryStream
$LN2@SyncPlots:

; 83   : 			}
; 84   : 		}

	jmp	$LN4@SyncPlots
$LN7@SyncPlots:

; 85   : 	}
; 86   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$0:
	lea	ecx, DWORD PTR _memoryStream$221305[ebp]
	jmp	??1FMemoryStream@@UAE@XZ		; FMemoryStream::~FMemoryStream
__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$1:
	lea	ecx, DWORD PTR _callStacks$221607[ebp]
	jmp	??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
__unwindfunclet$?SyncPlots@FSerialization@@YAXXZ$4:
	lea	ecx, DWORD PTR _callStacks$221607[ebp]
	jmp	??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
__ehhandler$?SyncPlots@FSerialization@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SyncPlots@FSerialization@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SyncPlots@FSerialization@@YAXXZ ENDP			; FSerialization::SyncPlots
PUBLIC	?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ	; CvPlot::getSyncArchive
PUBLIC	?ClearPlotDeltas@FSerialization@@YAXXZ		; FSerialization::ClearPlotDeltas
EXTRN	?clearDelta@FAutoArchive@@QAEXXZ:PROC		; FAutoArchive::clearDelta
; Function compile flags: /Odtp
;	COMDAT ?ClearPlotDeltas@FSerialization@@YAXXZ
_TEXT	SEGMENT
$T229703 = -48						; size = 4
$T229630 = -28						; size = 4
$T229617 = -24						; size = 4
$T229603 = -20						; size = 4
$T229602 = -16						; size = 4
_archive$221626 = -12					; size = 4
_plot$221624 = -8					; size = 4
_i$ = -4						; size = 4
?ClearPlotDeltas@FSerialization@@YAXXZ PROC		; FSerialization::ClearPlotDeltas, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 91   : 	std::set<CvPlot*>::iterator i;

	mov	DWORD PTR _i$[ebp], 0

; 92   : 	for(i = plotsToCheck.begin(); i != plotsToCheck.end(); ++i)

	mov	eax, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	DWORD PTR $T229617[ebp], eax
	mov	ecx, DWORD PTR $T229617[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T229630[ebp], edx
	mov	eax, DWORD PTR $T229630[ebp]
	mov	DWORD PTR $T229602[ebp], eax
	mov	ecx, DWORD PTR $T229602[ebp]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@ClearPlotD
$LN3@ClearPlotD:
	lea	ecx, DWORD PTR _i$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
$LN4@ClearPlotD:
	mov	edx, DWORD PTR ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A+4
	mov	DWORD PTR $T229703[ebp], edx
	mov	eax, DWORD PTR $T229703[ebp]
	mov	DWORD PTR $T229603[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T229603[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@ClearPlotD

; 93   : 	{
; 94   : 		CvPlot* plot = *i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _plot$221624[ebp], eax

; 95   : 
; 96   : 		if(plot)

	cmp	DWORD PTR _plot$221624[ebp], 0
	je	SHORT $LN1@ClearPlotD

; 97   : 		{
; 98   : 			FAutoArchive& archive = plot->getSyncArchive();

	mov	ecx, DWORD PTR _plot$221624[ebp]
	call	?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ ; CvPlot::getSyncArchive
	mov	DWORD PTR _archive$221626[ebp], eax

; 99   : 			archive.clearDelta();

	mov	ecx, DWORD PTR _archive$221626[ebp]
	call	?clearDelta@FAutoArchive@@QAEXXZ	; FAutoArchive::clearDelta
$LN1@ClearPlotD:

; 100  : 		}

	jmp	SHORT $LN3@ClearPlotD
$LN5@ClearPlotD:

; 101  : 	}
; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearPlotDeltas@FSerialization@@YAXXZ ENDP		; FSerialization::ClearPlotDeltas
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z
_TEXT	SEGMENT
_uiVersion$ = -8					; size = 4
_iTemp$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z PROC ; operator>>, COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 110  : 	uint uiVersion;
; 111  : 	loadFrom >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 112  : 
; 113  : 	int iTemp;
; 114  : 	loadFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 115  : 	writeTo.m_eArtifactType = (GreatWorkArtifactClass)iTemp;

	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 116  : 	loadFrom >> writeTo.m_eEra;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _loadFrom$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>
	add	esp, 8

; 117  : 	loadFrom >> writeTo.m_ePlayer1;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 118  : 	loadFrom >> writeTo.m_ePlayer2;

	mov	edx, DWORD PTR _writeTo$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 119  : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	SHORT $LN2@operator

; 120  : 	{
; 121  : 		loadFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 122  : 		writeTo.m_eWork = (GreatWorkType)iTemp;

	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR [edx+16], eax

; 123  : 	}
; 124  : 	else

	jmp	SHORT $LN1@operator
$LN2@operator:

; 125  : 	{
; 126  : 		writeTo.m_eWork = NO_GREAT_WORK;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	DWORD PTR [ecx+16], -1
$LN1@operator:

; 127  : 	}
; 128  : 
; 129  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z
_TEXT	SEGMENT
$T229757 = -12						; size = 4
$T229752 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z PROC ; operator<<, COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 135  : 	uint uiVersion = 2;

	mov	DWORD PTR _uiVersion$[ebp], 2

; 136  : 	saveTo << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 137  : 
; 138  : 	saveTo << readFrom.m_eArtifactType;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T229752[ebp], edx
	lea	eax, DWORD PTR $T229752[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 139  : 	saveTo << readFrom.m_eEra;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _saveTo$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<
	add	esp, 8

; 140  : 	saveTo << readFrom.m_ePlayer1;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 141  : 	saveTo << readFrom.m_ePlayer2;

	mov	edx, DWORD PTR _readFrom$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 142  : 	saveTo << readFrom.m_eWork;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T229757[ebp], edx
	lea	eax, DWORD PTR $T229757[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 143  : 
; 144  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ		; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
PUBLIC	??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ ; FAutoArchiveClassContainer<CvPlot>::~FAutoArchiveClassContainer<CvPlot>
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,8,1,297,0>::~FFastSmallFixedList<IDInfo,8,1,297,0>
PUBLIC	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
PUBLIC	?reset@CvPlot@@QAEXHH_N@Z			; CvPlot::reset
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert
PUBLIC	??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z ; FAutoVariable<char,CvPlot>::FAutoVariable<char,CvPlot>
PUBLIC	??_C@_0BH@CBFDEJLB@CvPlot?3?3m_eFeatureType?$AA@ ; `string'
PUBLIC	??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@	; FAutoArchiveClassContainer<CvPlot>::`vftable'
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
PUBLIC	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
PUBLIC	??0CvPlot@@QAE@XZ				; CvPlot::CvPlot
PUBLIC	?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; FAutoArchiveClassContainer<CvPlot>::getVariableName
PUBLIC	?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FAutoArchiveClassContainer<CvPlot>::setVariableName
PUBLIC	?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; FAutoArchiveClassContainer<CvPlot>::debugDump
PUBLIC	?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; FAutoArchiveClassContainer<CvPlot>::stackTraceRemark
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0FAutoArchive@@QAE@XZ:PROC			; FAutoArchive::FAutoArchive
EXTRN	??_E?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z:PROC ; FAutoArchiveClassContainer<CvPlot>::`vector deleting destructor'
;	COMDAT ??_C@_0BH@CBFDEJLB@CvPlot?3?3m_eFeatureType?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
CONST	SEGMENT
??_C@_0BH@CBFDEJLB@CvPlot?3?3m_eFeatureType?$AA@ DB 'CvPlot::m_eFeatureTy'
	DB	'pe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@
CONST	SEGMENT
??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@ DD FLAT:??_E?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z ; FAutoArchiveClassContainer<CvPlot>::`vftable'
	DD	FLAT:?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	FLAT:?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	FLAT:?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvPlot@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvPlot@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvPlot@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$3
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvPlot@@QAE@XZ$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlot@@QAE@XZ
_TEXT	SEGMENT
_this$ = -164						; size = 4
$T229821 = -88						; size = 4
$T229817 = -84						; size = 4
$T229812 = -80						; size = 4
$T229808 = -76						; size = 4
$T229804 = -72						; size = 4
$T229800 = -68						; size = 4
$T229796 = -64						; size = 4
$T229792 = -60						; size = 4
$T229788 = -56						; size = 4
$T229763 = -52						; size = 8
$T229762 = -44						; size = 4
$T229761 = -40						; size = 28
__$EHRec$ = -12						; size = 12
??0CvPlot@@QAE@XZ PROC					; CvPlot::CvPlot, COMDAT
; _this$ = ecx

; 153  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPlot@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T229788[ebp], eax
	mov	ecx, DWORD PTR $T229788[ebp]
	call	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T229788[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jae	SHORT $LN13@CvPlot
	push	0
	mov	ecx, DWORD PTR $T229788[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN13@CvPlot:
	mov	edx, DWORD PTR $T229788[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	mov	DWORD PTR $T229792[ebp], eax
	mov	ecx, DWORD PTR $T229792[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T229792[ebp]
	mov	DWORD PTR [edx+4], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	mov	DWORD PTR $T229796[ebp], eax
	mov	ecx, DWORD PTR $T229796[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T229796[ebp]
	mov	DWORD PTR [edx+4], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 120				; 00000078H
	mov	DWORD PTR $T229800[ebp], eax
	mov	ecx, DWORD PTR $T229800[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T229800[ebp]
	mov	DWORD PTR [edx+4], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 128				; 00000080H
	mov	DWORD PTR $T229804[ebp], eax
	mov	ecx, DWORD PTR $T229804[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T229804[ebp]
	mov	DWORD PTR [edx+4], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 136				; 00000088H
	mov	DWORD PTR $T229808[ebp], eax
	mov	ecx, DWORD PTR $T229808[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T229808[ebp]
	mov	DWORD PTR [edx+4], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 188				; 000000bcH
	mov	DWORD PTR $T229812[ebp], eax
	mov	ecx, DWORD PTR $T229812[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T229812[ebp]
	mov	BYTE PTR [edx+4], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 392				; 00000188H
	mov	DWORD PTR $T229817[ebp], eax
	mov	ecx, DWORD PTR $T229817[ebp]
	call	??0FAutoArchive@@QAE@XZ			; FAutoArchive::FAutoArchive
	mov	ecx, DWORD PTR $T229817[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$FAutoArchiveClassContainer@VCvPlot@@@@6B@
	mov	edx, DWORD PTR $T229817[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET ??_C@_0BH@CBFDEJLB@CvPlot?3?3m_eFeatureType?$AA@
	lea	ecx, DWORD PTR $T229761[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	push	ecx
	lea	edx, DWORD PTR $T229761[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	call	??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z ; FAutoVariable<char,CvPlot>::FAutoVariable<char,CvPlot>
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T229761[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 464				; 000001d0H
	mov	DWORD PTR $T229821[ebp], eax
	mov	ecx, DWORD PTR $T229821[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T229821[ebp]
	mov	DWORD PTR [edx+4], -1
	mov	eax, DWORD PTR $T229821[ebp]
	mov	DWORD PTR [eax+8], -1
	mov	ecx, DWORD PTR $T229821[ebp]
	mov	DWORD PTR [ecx+12], -1
	mov	edx, DWORD PTR $T229821[ebp]
	mov	DWORD PTR [edx+16], -1

; 154  : 	FSerialization::plotsToCheck.insert(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T229762[ebp], eax
	lea	ecx, DWORD PTR $T229762[ebp]
	push	ecx
	lea	edx, DWORD PTR $T229763[ebp]
	push	edx
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	call	?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert

; 155  : 	m_paiBuildProgress = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+184], 0

; 156  : 
; 157  : 	m_szScriptData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+180], 0

; 158  : 
; 159  : 	m_cContinentType = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+459], 0

; 160  : 	m_cRiverCrossing = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+460], 0

; 161  : 
; 162  : 	reset(0, 0, true);

	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvPlot@@QAEXHH_N@Z		; CvPlot::reset

; 163  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlot@@QAE@XZ$5:
	mov	ecx, DWORD PTR $T229788[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
__unwindfunclet$??0CvPlot@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
__unwindfunclet$??0CvPlot@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 188				; 000000bcH
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$??0CvPlot@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ
__unwindfunclet$??0CvPlot@@QAE@XZ$3:
	lea	ecx, DWORD PTR $T229761[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??0CvPlot@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	jmp	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
__ehhandler$??0CvPlot@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPlot@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlot@@QAE@XZ ENDP					; CvPlot::CvPlot
; Function compile flags: /Odtp
;	COMDAT ??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,8,1,297,0>::~FFastSmallFixedList<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,8,1,297,0>::~FFastSmallFixedList<IDInfo,8,1,297,0>
_TEXT	ENDS
EXTRN	??1FAutoArchive@@UAE@XZ:PROC			; FAutoArchive::~FAutoArchive
; Function compile flags: /Odtp
;	COMDAT ??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ PROC	; FAutoArchiveClassContainer<CvPlot>::~FAutoArchiveClassContainer<CvPlot>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FAutoArchive@@UAE@XZ			; FAutoArchive::~FAutoArchive
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ ENDP	; FAutoArchiveClassContainer<CvPlot>::~FAutoArchiveClassContainer<CvPlot>
_TEXT	ENDS
PUBLIC	?uninit@CvPlot@@QAEXXZ				; CvPlot::uninit
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
PUBLIC	??1CvPlot@@QAE@XZ				; CvPlot::~CvPlot
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPlot@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPlot@@QAE@XZ$3
__ehfuncinfo$??1CvPlot@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvPlot@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlot@@QAE@XZ
_TEXT	SEGMENT
_this$ = -136						; size = 4
$T230233 = -132						; size = 4
$T230201 = -116						; size = 4
$T230191 = -112						; size = 4
$T229996 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlot@@QAE@XZ PROC					; CvPlot::~CvPlot, COMDAT
; _this$ = ecx

; 168  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPlot@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 169  : 	FSerialization::plotsToCheck.erase(this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T229996[ebp], eax
	lea	ecx, DWORD PTR $T229996[ebp]
	push	ecx
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase

; 170  : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvPlot@@QAEXXZ			; CvPlot::uninit

; 171  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	call	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 392				; 00000188H
	mov	DWORD PTR $T230191[ebp], edx
	mov	ecx, DWORD PTR $T230191[ebp]
	call	??1FAutoArchive@@UAE@XZ			; FAutoArchive::~FAutoArchive
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 188				; 000000bcH
	mov	DWORD PTR $T230201[ebp], eax
	mov	ecx, DWORD PTR $T230201[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN82@CvPlot@2
	mov	edx, DWORD PTR $T230201[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN82@CvPlot@2:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T230233[ebp], eax
	mov	ecx, DWORD PTR $T230233[ebp]
	call	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlot@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$FFastSmallFixedList@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
__unwindfunclet$??1CvPlot@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 188				; 000000bcH
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$??1CvPlot@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1?$FAutoArchiveClassContainer@VCvPlot@@@@UAE@XZ
__unwindfunclet$??1CvPlot@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	jmp	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
__ehhandler$??1CvPlot@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPlot@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlot@@QAE@XZ ENDP					; CvPlot::~CvPlot
PUBLIC	?init@CvPlot@@QAEXHH@Z				; CvPlot::init
; Function compile flags: /Odtp
;	COMDAT ?init@CvPlot@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?init@CvPlot@@QAEXHH@Z PROC				; CvPlot::init, COMDAT
; _this$ = ecx

; 175  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 176  : 	//--------------------------------
; 177  : 	// Init saved data
; 178  : 	reset(iX, iY);

	push	0
	mov	eax, DWORD PTR _iY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iX$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvPlot@@QAEXHH_N@Z		; CvPlot::reset

; 179  : 
; 180  : 	//--------------------------------
; 181  : 	// Init non-saved data
; 182  : 
; 183  : 	//--------------------------------
; 184  : 	// Init other game data
; 185  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?init@CvPlot@@QAEXHH@Z ENDP				; CvPlot::init
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ?uninit@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T230318 = -60						; size = 4
$T230271 = -20						; size = 4
$T230270 = -16						; size = 4
$T230265 = -12						; size = 4
$T230249 = -8						; size = 4
$T230248 = -4						; size = 4
?uninit@CvPlot@@QAEXXZ PROC				; CvPlot::uninit, COMDAT
; _this$ = ecx

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 	SAFE_DELETE_ARRAY(m_szScriptData);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H
	mov	DWORD PTR $T230249[ebp], eax
	mov	ecx, DWORD PTR $T230249[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230248[ebp], edx
	mov	eax, DWORD PTR $T230248[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230249[ebp]
	mov	DWORD PTR [ecx], 0

; 192  : 
; 193  : 	m_pCenterUnit = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 188				; 000000bcH
	mov	DWORD PTR $T230265[ebp], edx
	mov	eax, DWORD PTR $T230265[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@uninit
	mov	ecx, DWORD PTR $T230265[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@uninit:
	mov	edx, DWORD PTR $T230265[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T230265[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@uninit
	mov	ecx, DWORD PTR $T230265[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN7@uninit:

; 194  : 
; 195  : 	SAFE_DELETE_ARRAY(m_paiBuildProgress);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 184				; 000000b8H
	mov	DWORD PTR $T230271[ebp], edx
	mov	eax, DWORD PTR $T230271[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230270[ebp], ecx
	mov	edx, DWORD PTR $T230270[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230271[ebp]
	mov	DWORD PTR [eax], 0

; 196  : 
; 197  : 	m_units.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T230318[ebp], ecx
	mov	edx, DWORD PTR $T230318[ebp]
	cmp	DWORD PTR [edx+8], 0
	jae	SHORT $LN17@uninit
	push	0
	mov	ecx, DWORD PTR $T230318[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN17@uninit:
	mov	eax, DWORD PTR $T230318[ebp]
	mov	DWORD PTR [eax+4], 0

; 198  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?uninit@CvPlot@@QAEXXZ ENDP				; CvPlot::uninit
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Odtp
;	COMDAT ?reset@CvPlot@@QAEXHH_N@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T230380 = -100						; size = 4
_i$230372 = -96						; size = 4
$T230369 = -92						; size = 4
$T230365 = -88						; size = 4
$T230361 = -84						; size = 4
$T230357 = -80						; size = 4
$T230353 = -76						; size = 4
$T230349 = -72						; size = 4
$T230331 = -68						; size = 4
$T230348 = -64						; size = 8
$T230347 = -56						; size = 4
$T230321 = -49						; size = 1
_iJ$221778 = -48					; size = 4
_iI$221774 = -44					; size = 4
_iI$221770 = -40					; size = 4
_iI$221766 = -36					; size = 4
_iI$221762 = -32					; size = 4
_iI$221758 = -28					; size = 4
_iI$221754 = -24					; size = 4
_iI$221750 = -20					; size = 4
_iI$221746 = -16					; size = 4
_iI$221742 = -12					; size = 4
_iI$221738 = -8						; size = 4
_iI$221734 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_bConstructorCall$ = 16					; size = 1
?reset@CvPlot@@QAEXHH_N@Z PROC				; CvPlot::reset, COMDAT
; _this$ = ecx

; 204  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 205  : 	//--------------------------------
; 206  : 	// Uninit class
; 207  : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvPlot@@QAEXXZ			; CvPlot::uninit

; 208  : 
; 209  : 	m_iX = iX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _iX$[ebp]
	mov	WORD PTR [eax], cx

; 210  : 	m_iY = iY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _iY$[ebp]
	mov	WORD PTR [edx+2], ax

; 211  : 	m_iArea = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+356], -1

; 212  : 	m_iLandmass = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], -1

; 213  : 	m_iFeatureVariety = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+453], 0

; 214  : 	m_iOwnershipDuration = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+380], cx

; 215  : 	m_iImprovementDuration = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+382], ax

; 216  : 	m_iUpgradeProgress = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+384], dx

; 217  : 	m_iCulture = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+386], cx

; 218  : 	m_iNumMajorCivsRevealed = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+454], 0

; 219  : 	m_iCityRadiusCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+455], 0

; 220  : 	m_iReconCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+456], 0

; 221  : 	m_iRiverCrossingCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+457], 0

; 222  : 	m_iResourceNum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+458], 0

; 223  : 	m_cContinentType = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+459], 0

; 224  : 
; 225  : 	m_uiTradeRouteBitFlags = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 0

; 226  : 
; 227  : 	m_bStartingPlot = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 251					; 000000fbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 228  : 	m_bHills = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 247					; 000000f7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 229  : 	m_bNEOfRiver = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 239					; 000000efH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 230  : 	m_bWOfRiver = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 223					; 000000dfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 231  : 	m_bNWOfRiver = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 191					; 000000bfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 232  : 	m_bPotentialCityWork = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 127					; 0000007fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 233  : 	m_bPlotLayoutDirty = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 254					; 000000feH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 234  : 	m_bLayoutStateWorked = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 253					; 000000fdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 235  : 	m_bImprovementPillaged = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 254					; 000000feH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 236  : 	m_bRoutePillaged = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 253					; 000000fdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 237  : 	m_bBarbCampNotConverting = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 251					; 000000fbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 238  : 	m_bRoughFeature = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 247					; 000000f7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 239  : 	m_bResourceLinkedCityActive = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 239					; 000000efH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 240  : 	m_bImprovedByGiftFromMajor = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 223					; 000000dfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 241  : 	m_bIsAdjacentToLand = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 191					; 000000bfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 242  : 	m_bIsImpassable = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 127					; 0000007fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 243  : 
; 244  : 	m_eOwner = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], -1

; 245  : 	m_ePlotType = PLOT_OCEAN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+5], 3

; 246  : 	m_eTerrainType = NO_TERRAIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+6], -1

; 247  : 	m_eFeatureType = NO_FEATURE;

	mov	BYTE PTR $T230321[ebp], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	mov	DWORD PTR $T230349[ebp], ecx
	movsx	edx, BYTE PTR $T230321[ebp]
	mov	eax, DWORD PTR $T230349[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	edx, ecx
	je	SHORT $LN41@reset
	mov	edx, DWORD PTR $T230349[ebp]
	movsx	eax, BYTE PTR [edx+4]
	movsx	ecx, BYTE PTR $T230321[ebp]
	cmp	eax, ecx
	je	SHORT $LN41@reset
	mov	edx, DWORD PTR $T230349[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T230331[ebp], eax
	mov	ecx, DWORD PTR $T230349[ebp]
	mov	DWORD PTR $T230347[ebp], ecx
	lea	edx, DWORD PTR $T230347[ebp]
	push	edx
	lea	eax, DWORD PTR $T230348[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230331[ebp]
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	ecx, DWORD PTR $T230349[ebp]
	mov	dl, BYTE PTR $T230321[ebp]
	mov	BYTE PTR [ecx+4], dl
$LN41@reset:

; 248  : 	m_eResourceType = NO_RESOURCE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+440], -1

; 249  : 	m_eImprovementType = NO_IMPROVEMENT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+441], -1

; 250  : 	m_eImprovementTypeUnderConstruction = NO_IMPROVEMENT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+442], -1

; 251  : 	m_ePlayerBuiltImprovement = NO_PLAYER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+443], -1

; 252  : 	m_ePlayerResponsibleForImprovement = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+444], -1

; 253  : 	m_ePlayerResponsibleForRoute = NO_PLAYER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+445], -1

; 254  : 	m_ePlayerThatClearedBarbCampHere = NO_PLAYER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+446], -1

; 255  : 	m_eRouteType = NO_ROUTE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+447], -1

; 256  : 	m_eWorldAnchor = NO_WORLD_ANCHOR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+448], -1

; 257  : 	m_cWorldAnchorData = NO_WORLD_ANCHOR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+449], -1

; 258  : 	m_eRiverEFlowDirection = NO_FLOWDIRECTION;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+450], -1

; 259  : 	m_eRiverSEFlowDirection = NO_FLOWDIRECTION;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+451], -1

; 260  : 	m_eRiverSWFlowDirection = NO_FLOWDIRECTION;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+452], -1

; 261  : 	m_cRiverCrossing = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+460], 0

; 262  : 
; 263  : 	m_cBuilderAIScratchPadPlayer = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+368], 0

; 264  : 	m_sBuilderAIScratchPadTurn = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+370], ax

; 265  : 	m_sBuilderAIScratchPadValue = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+372], dx

; 266  : 	m_eBuilderAIScratchPadRoute = NO_ROUTE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+376], -1

; 267  : 
; 268  : 	m_plotCity.reset();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 104				; 00000068H
	mov	DWORD PTR $T230353[ebp], edx
	mov	eax, DWORD PTR $T230353[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T230353[ebp]
	mov	DWORD PTR [ecx+4], -1

; 269  : 	m_workingCity.reset();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T230357[ebp], edx
	mov	eax, DWORD PTR $T230357[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T230357[ebp]
	mov	DWORD PTR [ecx+4], -1

; 270  : 	m_workingCityOverride.reset();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 120				; 00000078H
	mov	DWORD PTR $T230361[ebp], edx
	mov	eax, DWORD PTR $T230361[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T230361[ebp]
	mov	DWORD PTR [ecx+4], -1

; 271  : 	m_ResourceLinkedCity.reset();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 128				; 00000080H
	mov	DWORD PTR $T230365[ebp], edx
	mov	eax, DWORD PTR $T230365[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T230365[ebp]
	mov	DWORD PTR [ecx+4], -1

; 272  : 	m_purchaseCity.reset();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	mov	DWORD PTR $T230369[ebp], edx
	mov	eax, DWORD PTR $T230369[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T230369[ebp]
	mov	DWORD PTR [ecx+4], -1

; 273  : 	
; 274  : 	if(!bConstructorCall)

	movzx	edx, BYTE PTR _bConstructorCall$[ebp]
	test	edx, edx
	jne	$LN37@reset

; 275  : 	{
; 276  : 		for(int iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	mov	DWORD PTR _iI$221734[ebp], 0
	jmp	SHORT $LN36@reset
$LN35@reset:
	mov	eax, DWORD PTR _iI$221734[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221734[ebp], eax
$LN36@reset:
	cmp	DWORD PTR _iI$221734[ebp], 6
	jge	SHORT $LN34@reset

; 277  : 		{
; 278  : 			m_aiYield[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+144]
	xor	eax, eax
	mov	ecx, DWORD PTR _iI$221734[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 279  : 		}

	jmp	SHORT $LN35@reset
$LN34@reset:

; 280  : 		for(int iI = 0; iI < REALLY_MAX_PLAYERS; ++iI)

	mov	DWORD PTR _iI$221738[ebp], 0
	jmp	SHORT $LN33@reset
$LN32@reset:
	mov	edx, DWORD PTR _iI$221738[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$221738[ebp], edx
$LN33@reset:
	cmp	DWORD PTR _iI$221738[ebp], 80		; 00000050H
	jge	SHORT $LN31@reset

; 281  : 		{
; 282  : 			m_aiFoundValue[iI] = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _iI$221738[ebp]
	mov	DWORD PTR [ecx+edx*4], -1

; 283  : 		}

	jmp	SHORT $LN32@reset
$LN31@reset:

; 284  : 		for(int iI = 0; iI < REALLY_MAX_PLAYERS; ++iI)

	mov	DWORD PTR _iI$221742[ebp], 0
	jmp	SHORT $LN30@reset
$LN29@reset:
	mov	eax, DWORD PTR _iI$221742[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221742[ebp], eax
$LN30@reset:
	cmp	DWORD PTR _iI$221742[ebp], 80		; 00000050H
	jge	SHORT $LN28@reset

; 285  : 		{
; 286  : 			m_aiPlayerCityRadiusCount[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	eax, DWORD PTR _iI$221742[ebp]
	mov	BYTE PTR [edx+eax], 0

; 287  : 		}

	jmp	SHORT $LN29@reset
$LN28@reset:

; 288  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$221746[ebp], 0
	jmp	SHORT $LN27@reset
$LN26@reset:
	mov	ecx, DWORD PTR _iI$221746[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221746[ebp], ecx
$LN27@reset:
	cmp	DWORD PTR _iI$221746[ebp], 80		; 00000050H
	jge	SHORT $LN25@reset

; 289  : 		{
; 290  : 			m_aiVisibilityCount[iI] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	xor	ecx, ecx
	mov	edx, DWORD PTR _iI$221746[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 291  : 		}

	jmp	SHORT $LN26@reset
$LN25@reset:

; 292  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$221750[ebp], 0
	jmp	SHORT $LN24@reset
$LN23@reset:
	mov	eax, DWORD PTR _iI$221750[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221750[ebp], eax
$LN24@reset:
	cmp	DWORD PTR _iI$221750[ebp], 80		; 00000050H
	jge	SHORT $LN22@reset

; 293  : 		{
; 294  : 			m_aiRevealedOwner[iI] = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	eax, DWORD PTR _iI$221750[ebp]
	mov	BYTE PTR [edx+eax], -1

; 295  : 		}

	jmp	SHORT $LN23@reset
$LN22@reset:

; 296  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$221754[ebp], 0
	jmp	SHORT $LN21@reset
$LN20@reset:
	mov	ecx, DWORD PTR _iI$221754[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221754[ebp], ecx
$LN21@reset:
	cmp	DWORD PTR _iI$221754[ebp], 80		; 00000050H
	jge	SHORT $LN19@reset

; 297  : 		{
; 298  : 			//m_abRevealed[iI] = false;
; 299  : 		}

	jmp	SHORT $LN20@reset
$LN19@reset:

; 300  : 		m_bfRevealed.ClearAll();

	mov	DWORD PTR _i$230372[ebp], 0
	jmp	SHORT $LN60@reset
$LN59@reset:
	mov	edx, DWORD PTR _i$230372[ebp]
	add	edx, 1
	mov	DWORD PTR _i$230372[ebp], edx
$LN60@reset:
	cmp	DWORD PTR _i$230372[ebp], 4
	jae	SHORT $LN61@reset
	mov	eax, DWORD PTR _i$230372[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+8], 0
	jmp	SHORT $LN59@reset
$LN61@reset:

; 301  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$221758[ebp], 0
	jmp	SHORT $LN18@reset
$LN17@reset:
	mov	edx, DWORD PTR _iI$221758[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$221758[ebp], edx
$LN18@reset:
	cmp	DWORD PTR _iI$221758[ebp], 80		; 00000050H
	jge	SHORT $LN16@reset

; 302  : 		{
; 303  : 			m_abResourceForceReveal[iI] = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _iI$221758[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 304  : 		}

	jmp	SHORT $LN17@reset
$LN16@reset:

; 305  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$221762[ebp], 0
	jmp	SHORT $LN15@reset
$LN14@reset:
	mov	eax, DWORD PTR _iI$221762[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221762[ebp], eax
$LN15@reset:
	cmp	DWORD PTR _iI$221762[ebp], 80		; 00000050H
	jge	SHORT $LN13@reset

; 306  : 		{
; 307  : 			m_aeRevealedImprovementType[iI] = NO_IMPROVEMENT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	or	eax, -1
	mov	ecx, DWORD PTR _iI$221762[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 308  : 		}

	jmp	SHORT $LN14@reset
$LN13@reset:

; 309  : 		for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$221766[ebp], 0
	jmp	SHORT $LN12@reset
$LN11@reset:
	mov	edx, DWORD PTR _iI$221766[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$221766[ebp], edx
$LN12@reset:
	cmp	DWORD PTR _iI$221766[ebp], 80		; 00000050H
	jge	SHORT $LN10@reset

; 310  : 		{
; 311  : 			m_aeRevealedRouteType[iI] = NO_ROUTE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	or	edx, -1
	mov	eax, DWORD PTR _iI$221766[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 312  : 		}

	jmp	SHORT $LN11@reset
$LN10@reset:

; 313  : 		for(int iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$221770[ebp], 0
	jmp	SHORT $LN9@reset
$LN8@reset:
	mov	ecx, DWORD PTR _iI$221770[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221770[ebp], ecx
$LN9@reset:
	cmp	DWORD PTR _iI$221770[ebp], 22		; 00000016H
	jge	SHORT $LN37@reset

; 314  : 		{
; 315  : 			m_abNoSettling[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	ecx, DWORD PTR _iI$221770[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 316  : 		}

	jmp	SHORT $LN8@reset
$LN37@reset:

; 317  : 	}
; 318  : 	for(int iI = 0; iI < REALLY_MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$221774[ebp], 0
	jmp	SHORT $LN6@reset
$LN5@reset:
	mov	edx, DWORD PTR _iI$221774[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$221774[ebp], edx
$LN6@reset:
	cmp	DWORD PTR _iI$221774[ebp], 80		; 00000050H
	jge	SHORT $LN4@reset

; 319  : 	{
; 320  : 		for(int iJ = 0; iJ < NUM_INVISIBLE_TYPES; ++iJ)

	mov	DWORD PTR _iJ$221778[ebp], 0
	jmp	SHORT $LN3@reset
$LN2@reset:
	mov	eax, DWORD PTR _iJ$221778[ebp]
	add	eax, 1
	mov	DWORD PTR _iJ$221778[ebp], eax
$LN3@reset:
	cmp	DWORD PTR _iJ$221778[ebp], 1
	jge	SHORT $LN1@reset

; 321  : 		{
; 322  : 			m_apaiInvisibleVisibilityCount[iI][iJ] = 0;

	mov	ecx, DWORD PTR _iI$221774[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2+196]
	xor	ecx, ecx
	mov	edx, DWORD PTR _iJ$221778[ebp]
	mov	WORD PTR [eax+edx*2], cx

; 323  : 		}

	jmp	SHORT $LN2@reset
$LN1@reset:

; 324  : 	}

	jmp	SHORT $LN5@reset
$LN4@reset:

; 325  : 
; 326  : 	m_kArchaeologyData.Reset();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 464				; 000001d0H
	mov	DWORD PTR $T230380[ebp], eax
	mov	ecx, DWORD PTR $T230380[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T230380[ebp]
	mov	DWORD PTR [edx+4], -1
	mov	eax, DWORD PTR $T230380[ebp]
	mov	DWORD PTR [eax+8], -1
	mov	ecx, DWORD PTR $T230380[ebp]
	mov	DWORD PTR [ecx+12], -1
	mov	edx, DWORD PTR $T230380[ebp]
	mov	DWORD PTR [edx+16], -1

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?reset@CvPlot@@QAEXHH_N@Z ENDP				; CvPlot::reset
_TEXT	ENDS
PUBLIC	?updateVisibility@CvPlot@@QAEXXZ		; CvPlot::updateVisibility
PUBLIC	?updateSymbols@CvPlot@@QAEXXZ			; CvPlot::updateSymbols
PUBLIC	?setupGraphical@CvPlot@@QAEXXZ			; CvPlot::setupGraphical
EXTRN	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ:PROC	; CvGlobals::IsGraphicsInitialized
; Function compile flags: /Odtp
;	COMDAT ?setupGraphical@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?setupGraphical@CvPlot@@QAEXXZ PROC			; CvPlot::setupGraphical, COMDAT
; _this$ = ecx

; 333  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 334  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@setupGraph

; 335  : 	{
; 336  : 		return;

	jmp	SHORT $LN2@setupGraph
$LN1@setupGraph:

; 337  : 	}
; 338  : 
; 339  : 	updateSymbols();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 340  : 
; 341  : 	updateVisibility();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
$LN2@setupGraph:

; 342  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?setupGraphical@CvPlot@@QAEXXZ ENDP			; CvPlot::setupGraphical
_TEXT	ENDS
PUBLIC	??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>
PUBLIC	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
PUBLIC	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver
PUBLIC	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver
PUBLIC	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver
PUBLIC	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z	; CvPlot::setFeatureType
PUBLIC	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z	; CvPlot::setRouteType
PUBLIC	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
PUBLIC	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z	; CvPlot::nextUnitNode
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,25,1,297,0>::push_back
PUBLIC	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ		; CvPlot::headUnitNode
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
PUBLIC	?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::resize
PUBLIC	??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>
PUBLIC	__$ArrayPad$
PUBLIC	?erase@CvPlot@@QAEX_N@Z				; CvPlot::erase
EXTRN	?kill@CvCity@@QAEXXZ:PROC			; CvCity::kill
EXTRN	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z:PROC	; CvUnit::kill
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?erase@CvPlot@@QAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$0
__ehfuncinfo$?erase@CvPlot@@QAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?erase@CvPlot@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?erase@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv214 = -288						; size = 4
_this$ = -284						; size = 4
$T230459 = -264						; size = 4
$T230447 = -260						; size = 4
_iIndex$230472 = -256					; size = 4
_uSize$230427 = -252					; size = 4
_pUnitNode$ = -248					; size = 4
_oldUnits$ = -244					; size = 216
__$ArrayPad$ = -24					; size = 4
_pCity$ = -20						; size = 4
_pLoopUnit$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bEraseUnits$ = 8					; size = 1
?erase@CvPlot@@QAEX_N@Z PROC				; CvPlot::erase, COMDAT
; _this$ = ecx

; 346  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@CvPlot@@QAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 	IDInfo* pUnitNode;
; 348  : 	CvCity* pCity;
; 349  : 	CvUnit* pLoopUnit;
; 350  : 	FFastSmallFixedList<IDInfo, 25, true, c_eCiv5GameplayDLL > oldUnits;

	lea	ecx, DWORD PTR _oldUnits$[ebp]
	call	??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	call	?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::resize
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 351  : 
; 352  : 	// kill units
; 353  : 	if (bEraseUnits)

	movzx	eax, BYTE PTR _bEraseUnits$[ebp]
	test	eax, eax
	je	$LN7@erase

; 354  : 	{
; 355  : 		oldUnits.clear();

	cmp	DWORD PTR _oldUnits$[ebp+8], 0
	jae	SHORT $LN23@erase
	push	0
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN23@erase:
	mov	DWORD PTR _oldUnits$[ebp+4], 0

; 356  : 
; 357  : 		pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN6@erase:

; 358  : 
; 359  : 		while (pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	SHORT $LN5@erase

; 360  : 		{
; 361  : 			oldUnits.insertAtEnd(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	call	?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,25,1,297,0>::push_back

; 362  : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 363  : 		}

	jmp	SHORT $LN6@erase
$LN5@erase:

; 364  : 
; 365  : 		pUnitNode = oldUnits.head();

	mov	eax, DWORD PTR _oldUnits$[ebp+4]
	mov	DWORD PTR _uSize$230427[ebp], eax
	cmp	DWORD PTR _uSize$230427[ebp], 0
	jbe	SHORT $LN29@erase
	xor	ecx, ecx
	shl	ecx, 3
	add	ecx, DWORD PTR _oldUnits$[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], ecx
	jmp	SHORT $LN4@erase
	jmp	SHORT $LN4@erase
$LN29@erase:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN4@erase:

; 366  : 
; 367  : 		while (pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN7@erase

; 368  : 		{
; 369  : 			pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN36@erase
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN36@erase
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv214[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv214[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv214[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN43@erase
$LN36@erase:
	mov	DWORD PTR _pLoopUnit$[ebp], 0

; 370  : 			pUnitNode = oldUnits.next(pUnitNode);

$LN43@erase:
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	add	ecx, 8
	xor	edx, edx
	shl	edx, 3
	add	edx, DWORD PTR _oldUnits$[ebp]
	sub	ecx, edx
	sar	ecx, 3
	mov	DWORD PTR _iIndex$230472[ebp], ecx
	mov	eax, DWORD PTR _oldUnits$[ebp+4]
	mov	DWORD PTR $T230447[ebp], eax
	mov	ecx, DWORD PTR _iIndex$230472[ebp]
	cmp	ecx, DWORD PTR $T230447[ebp]
	jae	SHORT $LN46@erase
	mov	edx, DWORD PTR _iIndex$230472[ebp]
	mov	eax, DWORD PTR _oldUnits$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T230459[ebp], ecx
	jmp	SHORT $LN41@erase
	jmp	SHORT $LN41@erase
$LN46@erase:
	mov	DWORD PTR $T230459[ebp], 0
$LN41@erase:
	mov	edx, DWORD PTR $T230459[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], edx

; 371  : 
; 372  : 			if (pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN2@erase

; 373  : 			{
; 374  : 				pLoopUnit->kill(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN2@erase:

; 375  : 			}
; 376  : 		}

	jmp	$LN4@erase
$LN7@erase:

; 377  : 	}
; 378  : 
; 379  : 	// kill cities
; 380  : 	pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 381  : 	if (pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN1@erase

; 382  : 	{
; 383  : 		pCity->kill();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?kill@CvCity@@QAEXXZ			; CvCity::kill
$LN1@erase:

; 384  : 	}
; 385  : 
; 386  : 	setResourceType(NO_RESOURCE, 0);

	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType

; 387  : 	setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 388  : 	setRouteType(NO_ROUTE);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType

; 389  : 	setFeatureType(NO_FEATURE);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 390  : 
; 391  : 	// disable rivers
; 392  : 	setNEOfRiver(false, NO_FLOWDIRECTION);

	push	-1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver

; 393  : 	setNWOfRiver(false, NO_FLOWDIRECTION);

	push	-1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver

; 394  : 	setWOfRiver(false, NO_FLOWDIRECTION);

	push	-1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver

; 395  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	call	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$1:
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
__unwindfunclet$?erase@CvPlot@@QAEX_N@Z$0:
	lea	ecx, DWORD PTR _oldUnits$[ebp]
	jmp	??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
__ehhandler$?erase@CvPlot@@QAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@CvPlot@@QAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@CvPlot@@QAEX_N@Z ENDP				; CvPlot::erase
; Function compile flags: /Odtp
;	COMDAT ??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FFastSmallFixedList@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FFastSmallFixedList<IDInfo,25,1,297,0>::~FFastSmallFixedList<IDInfo,25,1,297,0>
_TEXT	ENDS
PUBLIC	?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z ; CvPlot::SetWorldAnchor
PUBLIC	?verifyUnitValidPlot@CvPlot@@QAEXXZ		; CvPlot::verifyUnitValidPlot
PUBLIC	?changeImprovementDuration@CvPlot@@QAEXH@Z	; CvPlot::changeImprovementDuration
PUBLIC	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
PUBLIC	?changeOwnershipDuration@CvPlot@@QAEXH@Z	; CvPlot::changeOwnershipDuration
PUBLIC	?isOwned@CvPlot@@QBE_NXZ			; CvPlot::isOwned
PUBLIC	?doTurn@CvPlot@@QAEXXZ				; CvPlot::doTurn
; Function compile flags: /Odtp
;	COMDAT ?doTurn@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?doTurn@CvPlot@@QAEXXZ PROC				; CvPlot::doTurn, COMDAT
; _this$ = ecx

; 399  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 400  : 	if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@doTurn

; 401  : 	{
; 402  : 		changeOwnershipDuration(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeOwnershipDuration@CvPlot@@QAEXH@Z ; CvPlot::changeOwnershipDuration
$LN2@doTurn:

; 403  : 	}
; 404  : 
; 405  : 	if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN1@doTurn

; 406  : 	{
; 407  : 		changeImprovementDuration(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeImprovementDuration@CvPlot@@QAEXH@Z ; CvPlot::changeImprovementDuration
$LN1@doTurn:

; 408  : 	}
; 409  : 
; 410  : 	verifyUnitValidPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?verifyUnitValidPlot@CvPlot@@QAEXXZ	; CvPlot::verifyUnitValidPlot

; 411  : 
; 412  : 	// Clear world anchor
; 413  : 	SetWorldAnchor(NO_WORLD_ANCHOR);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z ; CvPlot::SetWorldAnchor

; 414  : 
; 415  : 	// XXX
; 416  : #ifdef _DEBUG
; 417  : 	{
; 418  : 		IDInfo* pUnitNode;
; 419  : 		CvUnit* pLoopUnit;
; 420  : 
; 421  : 		pUnitNode = headUnitNode();
; 422  : 
; 423  : 		while(pUnitNode != NULL)
; 424  : 		{
; 425  : 			pLoopUnit = GetPlayerUnit(*pUnitNode);
; 426  : 			pUnitNode = nextUnitNode(pUnitNode);
; 427  : 
; 428  : 			if(pLoopUnit)
; 429  : 			{
; 430  : 				CvAssertMsg(pLoopUnit->atPlot(*this), "pLoopUnit is expected to be at the current plot instance");
; 431  : 				if(!pLoopUnit->atPlot(*this))
; 432  : 				{
; 433  : 					removeUnit(pLoopUnit, true);
; 434  : 				}
; 435  : 			}
; 436  : 		}
; 437  : 	}
; 438  : #endif
; 439  : 	// XXX
; 440  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?doTurn@CvPlot@@QAEXXZ ENDP				; CvPlot::doTurn
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?doImprovementUpgrade@CvPlot@@IAEXXZ		; CvPlot::doImprovementUpgrade
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
PUBLIC	??_C@_0CF@EPDFDEFI@TXT_KEY_MISC_DISCOVERED_NEW_RESO@ ; `string'
PUBLIC	??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@ ; `string'
PUBLIC	??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@ ; `string'
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
PUBLIC	??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@ ; `string'
PUBLIC	??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@	; `string'
PUBLIC	??_C@_0BD@OCGDIBFA@Resource?5Discovery?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?doImprovement@CvPlot@@QAEXXZ			; CvPlot::doImprovement
EXTRN	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ:PROC	; CvCity::GetIDInfo
EXTRN	?GetTextKey@CvBaseInfo@@QBEPBDXZ:PROC		; CvBaseInfo::GetTextKey
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getNameKey@CvCity@@QBEPBDXZ:PROC		; CvCity::getNameKey
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
EXTRN	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getRandomResourceQuantity
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetImprovementResourceDiscoverRand
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getTechReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechReveal
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT ??_C@_0CF@EPDFDEFI@TXT_KEY_MISC_DISCOVERED_NEW_RESO@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CF@EPDFDEFI@TXT_KEY_MISC_DISCOVERED_NEW_RESO@ DB 'TXT_KEY_MISC_DIS'
	DB	'COVERED_NEW_RESOURCE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@
CONST	SEGMENT
??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@ DB 'TXT_KEY_MISC_DIS'
	DB	'COVERED_HIDDEN_ARTIFACTS_NEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@
CONST	SEGMENT
??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@ DB 'RESOURCE_HIDDEN_ART'
	DB	'IFACTS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@
CONST	SEGMENT
??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@ DB 'TXT_KEY_MISC_DIS'
	DB	'COVERED_ARTIFACTS_NEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@
CONST	SEGMENT
??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@ DB 'RESOURCE_ARTIFACTS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OCGDIBFA@Resource?5Discovery?$AA@
CONST	SEGMENT
??_C@_0BD@OCGDIBFA@Resource?5Discovery?$AA@ DB 'Resource Discovery', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?doImprovement@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$3
__ehfuncinfo$?doImprovement@CvPlot@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?doImprovement@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?doImprovement@CvPlot@@QAEXXZ
_TEXT	SEGMENT
tv247 = -300						; size = 4
tv364 = -296						; size = 4
tv66 = -292						; size = 4
tv211 = -288						; size = 4
tv483 = -284						; size = 4
tv478 = -278						; size = 1
tv471 = -277						; size = 1
tv467 = -276						; size = 4
tv468 = -272						; size = 4
tv286 = -268						; size = 4
tv190 = -264						; size = 4
tv454 = -260						; size = 4
tv449 = -254						; size = 1
tv442 = -253						; size = 1
tv438 = -252						; size = 4
tv439 = -248						; size = 4
_this$ = -244						; size = 4
$T230661 = -240						; size = 4
$T230657 = -236						; size = 4
$T230653 = -232						; size = 4
$T230649 = -228						; size = 4
$T230641 = -224						; size = 4
$T230633 = -220						; size = 4
$T230622 = -216						; size = 4
$T230615 = -212						; size = 4
$T230611 = -208						; size = 4
$T230607 = -204						; size = 4
$T230603 = -200						; size = 4
$T230599 = -196						; size = 4
$T230595 = -192						; size = 4
$T230591 = -188						; size = 4
$T230587 = -184						; size = 4
$T230580 = -180						; size = 4
_playerID$230577 = -176					; size = 4
$T230555 = -172						; size = 8
$T230554 = -164						; size = 28
$T230553 = -136						; size = 4
$T230552 = -132						; size = 4
$T230551 = -128						; size = 28
$T230550 = -100						; size = 28
_thisResourceInfo$221947 = -72				; size = 4
_iNumResourceInfos$221941 = -68				; size = 4
_thisImprovementInfo$221942 = -64			; size = 4
_thisTeam$ = -60					; size = 4
_strBuffer$ = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_pCity$ = -24						; size = 4
_iI$ = -20						; size = 4
_iResourceNum$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?doImprovement@CvPlot@@QAEXXZ PROC			; CvPlot::doImprovement, COMDAT
; _this$ = ecx

; 445  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?doImprovement@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 446  : 	CvCity* pCity;
; 447  : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 448  : 	int iI;
; 449  : 	int iResourceNum = 0;

	mov	DWORD PTR _iResourceNum$[ebp], 0

; 450  : 	CvTeam& thisTeam = GET_TEAM(getTeam());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$230577[ebp], ecx
	cmp	DWORD PTR _playerID$230577[ebp], -1
	je	SHORT $LN26@doImprovem
	mov	edx, DWORD PTR _playerID$230577[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T230580[ebp], eax
	jmp	SHORT $LN33@doImprovem
	jmp	SHORT $LN33@doImprovem
$LN26@doImprovem:
	mov	DWORD PTR $T230580[ebp], -1
$LN33@doImprovem:
	mov	eax, DWORD PTR $T230580[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _thisTeam$[ebp], eax

; 451  : 
; 452  : 	CvAssert(isBeingWorked() && isOwned());
; 453  : 
; 454  : 	if(m_eImprovementType != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+441]
	cmp	edx, -1
	je	$LN15@doImprovem

; 455  : 	{
; 456  : 		if(m_eResourceType == NO_RESOURCE)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	cmp	ecx, -1
	jne	$LN15@doImprovem

; 457  : 		{
; 458  : 			CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvPlot::doImprovement");
; 459  : 			int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResourceInfos$221941[ebp], eax

; 460  : 			CvImprovementEntry* thisImprovementInfo = GC.getImprovementInfo((ImprovementTypes)m_eImprovementType);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+441]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _thisImprovementInfo$221942[ebp], eax

; 461  : 			for(iI = 0; iI < iNumResourceInfos; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@doImprovem
$LN12@doImprovem:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN13@doImprovem:
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iNumResourceInfos$221941[ebp]
	jge	$LN15@doImprovem

; 462  : 			{
; 463  : 				CvResourceInfo* thisResourceInfo = GC.getResourceInfo((ResourceTypes) iI);

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _thisResourceInfo$221947[ebp], eax

; 464  : 				if (thisResourceInfo)

	cmp	DWORD PTR _thisResourceInfo$221947[ebp], 0
	je	$LN10@doImprovem

; 465  : 				{
; 466  : 					if(thisTeam.GetTeamTechs()->HasTech((TechTypes)(thisResourceInfo->getTechReveal())))

	mov	ecx, DWORD PTR _thisResourceInfo$221947[ebp]
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	push	eax
	mov	ecx, DWORD PTR _thisTeam$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@doImprovem

; 467  : 					{
; 468  : 						if(thisImprovementInfo->GetImprovementResourceDiscoverRand(iI) > 0)

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisImprovementInfo$221942[ebp]
	call	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetImprovementResourceDiscoverRand
	test	eax, eax
	jle	$LN10@doImprovem

; 469  : 						{
; 470  : 							if(GC.getGame().getJonRandNum(thisImprovementInfo->GetImprovementResourceDiscoverRand(iI), "Resource Discovery") == 0)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230587[ebp], eax
	push	OFFSET ??_C@_0BD@OCGDIBFA@Resource?5Discovery?$AA@
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _thisImprovementInfo$221942[ebp]
	call	?GetImprovementResourceDiscoverRand@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetImprovementResourceDiscoverRand
	push	eax
	mov	ecx, DWORD PTR $T230587[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	test	eax, eax
	jne	$LN10@doImprovem

; 471  : 							{
; 472  : 								iResourceNum = GC.getMap().getRandomResourceQuantity((ResourceTypes)iI);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230591[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230591[ebp]
	call	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getRandomResourceQuantity
	mov	DWORD PTR _iResourceNum$[ebp], eax

; 473  : 								setResourceType((ResourceTypes)iI, iResourceNum);

	push	0
	mov	ecx, DWORD PTR _iResourceNum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType

; 474  : 								if(getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T230595[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230599[ebp], edx
	mov	ecx, DWORD PTR $T230599[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T230595[ebp], eax
	jne	$LN6@doImprovem

; 475  : 								{
; 476  : 									pCity = GC.getMap().findCity(getX(), getY(), getOwner(), NO_TEAM, false);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T230603[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T230607[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T230611[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230615[ebp], eax
	push	0
	push	-1
	push	-1
	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR $T230603[ebp]
	push	ecx
	mov	edx, DWORD PTR $T230607[ebp]
	push	edx
	mov	eax, DWORD PTR $T230611[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230615[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	DWORD PTR _pCity$[ebp], eax

; 477  : 									if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN6@doImprovem

; 478  : 									{
; 479  : 										if(strcmp(thisResourceInfo->GetType(), "RESOURCE_ARTIFACTS") == 0)

	mov	DWORD PTR tv439[ebp], OFFSET ??_C@_0BD@DCOOKOLP@RESOURCE_ARTIFACTS?$AA@
	mov	ecx, DWORD PTR _thisResourceInfo$221947[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv438[ebp], eax
$LL81@doImprovem:
	mov	ecx, DWORD PTR tv438[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv442[ebp], dl
	mov	eax, DWORD PTR tv439[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN82@doImprovem
	cmp	BYTE PTR tv442[ebp], 0
	je	SHORT $LN83@doImprovem
	mov	ecx, DWORD PTR tv438[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv449[ebp], dl
	mov	eax, DWORD PTR tv439[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN82@doImprovem
	add	DWORD PTR tv438[ebp], 2
	add	DWORD PTR tv439[ebp], 2
	cmp	BYTE PTR tv449[ebp], 0
	jne	SHORT $LL81@doImprovem
$LN83@doImprovem:
	mov	DWORD PTR tv454[ebp], 0
	jmp	SHORT $LN84@doImprovem
$LN82@doImprovem:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv454[ebp], ecx
$LN84@doImprovem:
	mov	edx, DWORD PTR tv454[ebp]
	mov	DWORD PTR tv190[ebp], edx
	cmp	DWORD PTR tv190[ebp], 0
	jne	SHORT $LN58@doImprovem

; 480  : 										{
; 481  : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	push	OFFSET ??_C@_0CH@BOBAFPHE@TXT_KEY_MISC_DISCOVERED_ARTIFACT@
	lea	eax, DWORD PTR $T230550[ebp]
	push	eax
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR tv286[ebp]
	mov	DWORD PTR $T230622[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T230622[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T230550[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN3@doImprovem

; 482  : 										}
; 483  : 										else if(strcmp(thisResourceInfo->GetType(), "RESOURCE_HIDDEN_ARTIFACTS") == 0)

$LN58@doImprovem:
	mov	DWORD PTR tv468[ebp], OFFSET ??_C@_0BK@GEJOKJMD@RESOURCE_HIDDEN_ARTIFACTS?$AA@
	mov	ecx, DWORD PTR _thisResourceInfo$221947[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv467[ebp], eax
$LL85@doImprovem:
	mov	eax, DWORD PTR tv467[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv471[ebp], cl
	mov	edx, DWORD PTR tv468[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN86@doImprovem
	cmp	BYTE PTR tv471[ebp], 0
	je	SHORT $LN87@doImprovem
	mov	eax, DWORD PTR tv467[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv478[ebp], cl
	mov	edx, DWORD PTR tv468[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN86@doImprovem
	add	DWORD PTR tv467[ebp], 2
	add	DWORD PTR tv468[ebp], 2
	cmp	BYTE PTR tv478[ebp], 0
	jne	SHORT $LL85@doImprovem
$LN87@doImprovem:
	mov	DWORD PTR tv483[ebp], 0
	jmp	SHORT $LN88@doImprovem
$LN86@doImprovem:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv483[ebp], eax
$LN88@doImprovem:
	mov	ecx, DWORD PTR tv483[ebp]
	mov	DWORD PTR tv211[ebp], ecx
	cmp	DWORD PTR tv211[ebp], 0
	jne	SHORT $LN2@doImprovem

; 484  : 										{
; 485  : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_HIDDEN_ARTIFACTS_NEAR", pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	push	eax
	push	OFFSET ??_C@_0CO@ODOBJOOJ@TXT_KEY_MISC_DISCOVERED_HIDDEN_A@
	lea	edx, DWORD PTR $T230551[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv66[ebp], eax
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T230633[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T230633[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T230551[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 486  : 										}
; 487  : 										else

	jmp	SHORT $LN3@doImprovem
$LN2@doImprovem:

; 488  : 										{
; 489  : 											strBuffer = GetLocalizedText("TXT_KEY_MISC_DISCOVERED_NEW_RESOURCE", thisResourceInfo->GetTextKey(), pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T230552[ebp], eax
	mov	ecx, DWORD PTR _thisResourceInfo$221947[ebp]
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T230553[ebp], eax
	lea	edx, DWORD PTR $T230552[ebp]
	push	edx
	lea	eax, DWORD PTR $T230553[ebp]
	push	eax
	push	OFFSET ??_C@_0CF@EPDFDEFI@TXT_KEY_MISC_DISCOVERED_NEW_RESO@
	lea	ecx, DWORD PTR $T230554[ebp]
	push	ecx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv364[ebp], eax
	mov	edx, DWORD PTR tv364[ebp]
	mov	DWORD PTR $T230641[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR $T230641[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T230554[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@doImprovem:

; 490  : 										}
; 491  : 
; 492  : 										GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer/*, "AS2D_DISCOVERRESOURCE", MESSAGE_TYPE_MINOR_EVENT, thisResourceInfo.GetButton(), (ColorTypes)GC.getInfoTypeForString("COLOR_WHITE"), getX(), getY(), true, true*/);

	mov	ecx, DWORD PTR $T230649[ebp]
	mov	DWORD PTR tv247[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv247[ebp], edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T230653[ebp], eax
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T230657[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T230661[ebp], edx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR $T230653[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230657[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR $T230661[ebp]
	push	edx
	lea	eax, DWORD PTR $T230555[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	push	0
	mov	ecx, DWORD PTR tv247[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv247[ebp]
	mov	eax, DWORD PTR [edx+172]
	call	eax
$LN6@doImprovem:

; 493  : 									}
; 494  : 								}
; 495  : 
; 496  : 								break;

	jmp	SHORT $LN15@doImprovem
$LN10@doImprovem:

; 497  : 							}
; 498  : 						}
; 499  : 					}
; 500  : 				}
; 501  : 			}

	jmp	$LN12@doImprovem
$LN15@doImprovem:

; 502  : 		}
; 503  : 	}
; 504  : 
; 505  : 	doImprovementUpgrade();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?doImprovementUpgrade@CvPlot@@IAEXXZ	; CvPlot::doImprovementUpgrade

; 506  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$1:
	lea	ecx, DWORD PTR $T230550[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$2:
	lea	ecx, DWORD PTR $T230551[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?doImprovement@CvPlot@@QAEXXZ$3:
	lea	ecx, DWORD PTR $T230554[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?doImprovement@CvPlot@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?doImprovement@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?doImprovement@CvPlot@@QAEXXZ ENDP			; CvPlot::doImprovement
PUBLIC	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
PUBLIC	?getUpgradeProgress@CvPlot@@QBEHXZ		; CvPlot::getUpgradeProgress
PUBLIC	?changeUpgradeProgress@CvPlot@@QAEXH@Z		; CvPlot::changeUpgradeProgress
PUBLIC	?isBeingWorked@CvPlot@@QBE_NXZ			; CvPlot::isBeingWorked
EXTRN	?getImprovementUpgradeTime@CvGame@@QBEHW4ImprovementTypes@@PBVCvPlot@@@Z:PROC ; CvGame::getImprovementUpgradeTime
EXTRN	?getImprovementUpgradeRate@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getImprovementUpgradeRate
EXTRN	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsOutsideBorders
EXTRN	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetImprovementUpgrade
; Function compile flags: /Odtp
;	COMDAT ?doImprovementUpgrade@CvPlot@@IAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T230693 = -16						; size = 4
$T230689 = -12						; size = 4
$T230685 = -8						; size = 4
_eImprovementUpdrade$221990 = -4			; size = 4
?doImprovementUpgrade@CvPlot@@IAEXXZ PROC		; CvPlot::doImprovementUpgrade, COMDAT
; _this$ = ecx

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 	if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN6@doImprovem@2

; 512  : 	{
; 513  : 		ImprovementTypes eImprovementUpdrade = (ImprovementTypes)GC.getImprovementInfo(getImprovementType())->GetImprovementUpgrade();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	mov	DWORD PTR _eImprovementUpdrade$221990[ebp], eax

; 514  : 		if(eImprovementUpdrade != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovementUpdrade$221990[ebp], -1
	je	$LN6@doImprovem@2

; 515  : 		{
; 516  : 			if(isBeingWorked() || GC.getImprovementInfo(eImprovementUpdrade)->IsOutsideBorders())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@doImprovem@2
	mov	ecx, DWORD PTR _eImprovementUpdrade$221990[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOutsideBorders
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@doImprovem@2
$LN2@doImprovem@2:

; 517  : 			{
; 518  : 				changeUpgradeProgress(GET_PLAYER(getOwner()).getImprovementUpgradeRate());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T230685[ebp], ecx
	mov	edx, DWORD PTR $T230685[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230689[ebp], edx
	mov	ecx, DWORD PTR $T230689[ebp]
	call	?getImprovementUpgradeRate@CvPlayer@@QBEHXZ ; CvPlayer::getImprovementUpgradeRate
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeUpgradeProgress@CvPlot@@QAEXH@Z	; CvPlot::changeUpgradeProgress

; 519  : 
; 520  : 				if(getUpgradeProgress() >= (GC.getGame().getImprovementUpgradeTime(getImprovementType(), this)) * 100)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230693[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUpgradeProgress@CvPlot@@QBEHXZ	; CvPlot::getUpgradeProgress
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, DWORD PTR $T230693[ebp]
	call	?getImprovementUpgradeTime@CvGame@@QBEHW4ImprovementTypes@@PBVCvPlot@@@Z ; CvGame::getImprovementUpgradeTime
	imul	eax, 100				; 00000064H
	cmp	esi, eax
	jl	SHORT $LN6@doImprovem@2

; 521  : 				{
; 522  : 					setImprovementType(eImprovementUpdrade, GetPlayerThatBuiltImprovement());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
	push	eax
	mov	edx, DWORD PTR _eImprovementUpdrade$221990[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
$LN6@doImprovem@2:

; 523  : 				}
; 524  : 			}
; 525  : 		}
; 526  : 	}
; 527  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?doImprovementUpgrade@CvPlot@@IAEXXZ ENDP		; CvPlot::doImprovementUpgrade
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isRevealed
PUBLIC	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode
EXTRN	?isDebugMode@CvGame@@QBE_NXZ:PROC		; CvGame::isDebugMode
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
; Function compile flags: /Odtp
;	COMDAT ?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T230725 = -29						; size = 1
$T230712 = -28						; size = 4
_activeTeam$ = -16					; size = 4
_Game$ = -12						; size = 4
_eFOWMode$ = -8						; size = 4
_bIsDebug$ = -1						; size = 1
?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ PROC ; CvPlot::GetActiveFogOfWarMode, COMDAT
; _this$ = ecx

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 532  : 	CvGame& Game = GC.getGame();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _Game$[ebp], eax

; 533  : 	const TeamTypes activeTeam = Game.getActiveTeam();

	mov	ecx, DWORD PTR _Game$[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _activeTeam$[ebp], eax

; 534  : 	CvAssert(activeTeam != NO_TEAM);
; 535  : 
; 536  : 	FogOfWarModeTypes eFOWMode = FOGOFWARMODE_UNEXPLORED;

	mov	DWORD PTR _eFOWMode$[ebp], 1

; 537  : 
; 538  : 	bool bIsDebug = Game.isDebugMode();

	mov	ecx, DWORD PTR _Game$[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	mov	BYTE PTR _bIsDebug$[ebp], al

; 539  : 	if(bIsDebug || activeTeam != NO_TEAM)

	movzx	ecx, BYTE PTR _bIsDebug$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@GetActiveF
	cmp	DWORD PTR _activeTeam$[ebp], -1
	je	SHORT $LN3@GetActiveF
$LN2@GetActiveF:

; 540  : 	{
; 541  : 		if(isRevealed(activeTeam, bIsDebug))

	movzx	edx, BYTE PTR _bIsDebug$[ebp]
	push	edx
	mov	eax, DWORD PTR _activeTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isRevealed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@GetActiveF

; 542  : 		{
; 543  : 			eFOWMode = (isVisible(activeTeam, bIsDebug))? FOGOFWARMODE_OFF : FOGOFWARMODE_NOVIS;

	movzx	edx, BYTE PTR _bIsDebug$[ebp]
	test	edx, edx
	je	SHORT $LN17@GetActiveF
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230712[ebp], eax
	mov	ecx, DWORD PTR $T230712[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@GetActiveF
	mov	BYTE PTR $T230725[ebp], 1
	jmp	SHORT $LN18@GetActiveF
	jmp	SHORT $LN18@GetActiveF
$LN17@GetActiveF:
	cmp	DWORD PTR _activeTeam$[ebp], -1
	jne	SHORT $LN22@GetActiveF
	mov	BYTE PTR $T230725[ebp], 0
	jmp	SHORT $LN18@GetActiveF
$LN22@GetActiveF:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _activeTeam$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T230725[ebp], al
$LN18@GetActiveF:
	movzx	ecx, BYTE PTR $T230725[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 2
	mov	DWORD PTR _eFOWMode$[ebp], ecx
$LN3@GetActiveF:

; 544  : 		}
; 545  : 	}
; 546  : 
; 547  : 	return eFOWMode;

	mov	eax, DWORD PTR _eFOWMode$[ebp]

; 548  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ENDP ; CvPlot::GetActiveFogOfWarMode
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z ; FStaticVector<CvPlot *,1000,1,297,1>::push_back
PUBLIC	?updateFog@CvPlot@@QAEX_N@Z			; CvPlot::updateFog
; Function compile flags: /Odtp
;	COMDAT ?updateFog@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv79 = -76						; size = 4
_this$ = -72						; size = 4
$T230743 = -28						; size = 4
$T230736 = -24						; size = 4
$T230732 = -20						; size = 4
$T230728 = -16						; size = 4
_itr$222015 = -12					; size = 4
_plotList$222014 = -8					; size = 4
_eFOWMode$ = -4						; size = 4
_bDefer$ = 8						; size = 1
?updateFog@CvPlot@@QAEX_N@Z PROC			; CvPlot::updateFog, COMDAT
; _this$ = ecx

; 553  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 554  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@updateFog

; 555  : 	{
; 556  : 		return;

	jmp	$LN8@updateFog
$LN7@updateFog:

; 557  : 	}
; 558  : 
; 559  : 	FogOfWarModeTypes eFOWMode = GetActiveFogOfWarMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode
	mov	DWORD PTR _eFOWMode$[ebp], eax

; 560  : 
; 561  : 	if(!bDefer)

	movzx	ecx, BYTE PTR _bDefer$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@updateFog

; 562  : 	{
; 563  : 		gDLL->GameplayFOWChanged(getX(), getY(), eFOWMode, false);

	mov	edx, DWORD PTR $T230732[ebp]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T230736[ebp], edx
	push	0
	mov	eax, DWORD PTR _eFOWMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230736[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR [edx+712]
	call	eax

; 564  : 	}
; 565  : 	else

	jmp	SHORT $LN8@updateFog
$LN6@updateFog:

; 566  : 	{
; 567  : 		CvMap::DeferredPlotArray& plotList = GC.getMap().m_vDeferredFogPlots;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230743[ebp], ecx
	mov	edx, DWORD PTR $T230743[ebp]
	add	edx, 4
	mov	DWORD PTR _plotList$222014[ebp], edx

; 568  : 		for (CvMap::DeferredPlotArray::const_iterator itr = plotList.begin(); itr != plotList.end(); ++itr)

	mov	eax, DWORD PTR _plotList$222014[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _itr$222015[ebp], ecx
	jmp	SHORT $LN20@updateFog
$LN3@updateFog:
	mov	edx, DWORD PTR _itr$222015[ebp]
	add	edx, 4
	mov	DWORD PTR _itr$222015[ebp], edx
$LN20@updateFog:
	mov	eax, DWORD PTR _plotList$222014[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _plotList$222014[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR _itr$222015[ebp], ecx
	je	SHORT $LN2@updateFog

; 569  : 		{
; 570  : 			if((*itr) == this)

	mov	edx, DWORD PTR _itr$222015[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@updateFog

; 571  : 				return;	// Already in

	jmp	SHORT $LN8@updateFog
$LN1@updateFog:

; 572  : 		}

	jmp	SHORT $LN3@updateFog
$LN2@updateFog:

; 573  : 		plotList.push_back(this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T230728[ebp], ecx
	lea	edx, DWORD PTR $T230728[ebp]
	push	edx
	mov	ecx, DWORD PTR _plotList$222014[ebp]
	call	?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z ; FStaticVector<CvPlot *,1000,1,297,1>::push_back
$LN8@updateFog:

; 574  : 	}
; 575  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateFog@CvPlot@@QAEX_N@Z ENDP			; CvPlot::updateFog
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
PUBLIC	__real@3c23d70a
PUBLIC	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
PUBLIC	?setLayoutDirty@CvPlot@@QAEX_N@Z		; CvPlot::setLayoutDirty
EXTRN	??3CvDllUnit@@SAXPAX@Z:PROC			; CvDllUnit::operator delete
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z:PROC ; CvPlotManager::GetUnitsByIndex
EXTRN	?GetNumLayers@CvPlotManager@@QBEHXZ:PROC	; CvPlotManager::GetNumLayers
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
EXTRN	??0CvDllUnit@@QAE@PAVCvUnit@@@Z:PROC		; CvDllUnit::CvDllUnit
EXTRN	??2CvDllUnit@@SAPAXI@Z:PROC			; CvDllUnit::operator new
EXTRN	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ:PROC ; CvUnit::getInvisibleType
EXTRN	__fltused:DWORD
;	COMDAT __real@3c23d70a
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?updateVisibility@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$3
__ehfuncinfo$?updateVisibility@CvPlot@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?updateVisibility@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateVisibility@CvPlot@@QAEXXZ
_TEXT	SEGMENT
tv218 = -144						; size = 4
tv230 = -137						; size = 1
tv208 = -136						; size = 4
tv142 = -132						; size = 4
tv154 = -125						; size = 1
tv132 = -124						; size = 4
tv253 = -120						; size = 4
_this$ = -116						; size = 4
_inst$230883 = -112					; size = 4
$T230879 = -108						; size = 4
$T230867 = -104						; size = 4
$T230851 = -100						; size = 4
_inst$230846 = -96					; size = 4
$T230842 = -92						; size = 4
$T230830 = -88						; size = 4
$T230814 = -84						; size = 4
$T230802 = -80						; size = 4
$T230801 = -76						; size = 4
$T230796 = -72						; size = 4
$T230795 = -68						; size = 4
_pDllUnit$222116 = -64					; size = 4
_eInvisibleType$222109 = -60				; size = 4
_pLoopUnit$222107 = -56					; size = 4
_itrUnit$222103 = -52					; size = 4
_kUnits$222102 = -48					; size = 4
_iLayer$222098 = -44					; size = 4
_pDllUnit$222086 = -40					; size = 4
_eInvisibleType$222033 = -36				; size = 4
_pLoopUnit$222031 = -32					; size = 4
_kPlotManager$222096 = -28				; size = 4
_pUnitNode$222027 = -24					; size = 4
_iNumLayers$222097 = -20				; size = 4
_eActiveTeam$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?updateVisibility@CvPlot@@QAEXXZ PROC			; CvPlot::updateVisibility, COMDAT
; _this$ = ecx

; 579  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?updateVisibility@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@updateVisi

; 581  : 	{
; 582  : 		return;

	jmp	$LN15@updateVisi
$LN14@updateVisi:

; 583  : 	}
; 584  : 
; 585  : 	setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty

; 586  : 
; 587  : 	// Any unit that has visibility rules (it can become invisible to another player) needs to update itself.
; 588  : 	const TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230814[ebp], ecx
	mov	ecx, DWORD PTR $T230814[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eActiveTeam$[ebp], eax

; 589  : 	CvAssert(eActiveTeam != NO_TEAM);
; 590  : 	if (eActiveTeam != NO_TEAM)

	cmp	DWORD PTR _eActiveTeam$[ebp], -1
	je	$LN6@updateVisi

; 591  : 	{
; 592  : 		IDInfo* pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$222027[ebp], eax
$LN12@updateVisi:

; 593  : 		while (pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$222027[ebp], 0
	je	$LN11@updateVisi

; 594  : 		{
; 595  : 			CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$222027[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN31@updateVisi
	mov	eax, DWORD PTR _pUnitNode$222027[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN31@updateVisi
	mov	ecx, DWORD PTR _pUnitNode$222027[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv253[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$222027[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv253[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv253[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$222031[ebp], eax
	jmp	SHORT $LN32@updateVisi
$LN31@updateVisi:
	mov	DWORD PTR _pLoopUnit$222031[ebp], 0
$LN32@updateVisi:

; 596  : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$222027[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$222027[ebp], eax

; 597  : 
; 598  : 			if (pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$222031[ebp], 0
	je	$LN42@updateVisi

; 599  : 			{
; 600  : 				InvisibleTypes eInvisibleType = pLoopUnit->getInvisibleType();

	mov	ecx, DWORD PTR _pLoopUnit$222031[ebp]
	call	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getInvisibleType
	mov	DWORD PTR _eInvisibleType$222033[ebp], eax

; 601  : 				if (eInvisibleType != NO_INVISIBLE)

	cmp	DWORD PTR _eInvisibleType$222033[ebp], -1
	je	$LN42@updateVisi

; 602  : 				{
; 603  : 					// This unit has visibility rules, send a message that it needs to update itself.
; 604  : 					auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T230796[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T230796[ebp], 0
	je	SHORT $LN17@updateVisi
	mov	edx, DWORD PTR _pLoopUnit$222031[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230796[ebp]
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN18@updateVisi
$LN17@updateVisi:
	mov	DWORD PTR tv132[ebp], 0
$LN18@updateVisi:
	mov	eax, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T230795[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T230795[ebp]
	mov	DWORD PTR _pDllUnit$222086[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 605  : 					gDLL->GameplayUnitVisibility(pDllUnit.get(), (pLoopUnit->getTeam() == eActiveTeam)?true:isInvisibleVisible(eActiveTeam, eInvisibleType), true, 0.01f);

	mov	ecx, DWORD PTR _pLoopUnit$222031[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eActiveTeam$[ebp]
	jne	SHORT $LN19@updateVisi
	mov	BYTE PTR tv154[ebp], 1
	jmp	SHORT $LN20@updateVisi
$LN19@updateVisi:
	mov	edx, DWORD PTR _eInvisibleType$222033[ebp]
	push	edx
	mov	eax, DWORD PTR _eActiveTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
	mov	BYTE PTR tv154[ebp], al
$LN20@updateVisi:
	mov	ecx, DWORD PTR $T230830[ebp]
	mov	DWORD PTR tv142[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv142[ebp], edx
	push	ecx
	fld	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR [esp]
	push	1
	movzx	eax, BYTE PTR tv154[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDllUnit$222086[ebp]
	push	ecx
	mov	edx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [eax+640]
	call	edx

; 606  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _pDllUnit$222086[ebp]
	mov	DWORD PTR $T230842[ebp], eax
	cmp	DWORD PTR $T230842[ebp], 0
	je	SHORT $LN44@updateVisi
	mov	ecx, DWORD PTR $T230842[ebp]
	mov	DWORD PTR _inst$230846[ebp], ecx
	mov	edx, DWORD PTR _inst$230846[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$230846[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN44@updateVisi:
$LN42@updateVisi:

; 607  : 			}
; 608  : 		}

	jmp	$LN12@updateVisi
$LN11@updateVisi:

; 609  : 
; 610  : 		// Must update the other layers as well
; 611  : 		CvPlotManager& kPlotManager = GC.getMap().plotManager();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T230851[ebp], eax
	mov	ecx, DWORD PTR $T230851[ebp]
	add	ecx, 4184				; 00001058H
	mov	DWORD PTR _kPlotManager$222096[ebp], ecx

; 612  : 		int iNumLayers = kPlotManager.GetNumLayers();

	mov	ecx, DWORD PTR _kPlotManager$222096[ebp]
	call	?GetNumLayers@CvPlotManager@@QBEHXZ	; CvPlotManager::GetNumLayers
	mov	DWORD PTR _iNumLayers$222097[ebp], eax

; 613  : 		for (int iLayer = 0; iLayer < iNumLayers; ++iLayer)

	mov	DWORD PTR _iLayer$222098[ebp], 0
	jmp	SHORT $LN8@updateVisi
$LN7@updateVisi:
	mov	edx, DWORD PTR _iLayer$222098[ebp]
	add	edx, 1
	mov	DWORD PTR _iLayer$222098[ebp], edx
$LN8@updateVisi:
	mov	eax, DWORD PTR _iLayer$222098[ebp]
	cmp	eax, DWORD PTR _iNumLayers$222097[ebp]
	jge	$LN6@updateVisi

; 614  : 		{	
; 615  : 			const CvIDInfoFixedVector &kUnits = kPlotManager.GetUnitsByIndex(m_iX, m_iY, iLayer);

	mov	ecx, DWORD PTR _iLayer$222098[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _kPlotManager$222096[ebp]
	call	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ; CvPlotManager::GetUnitsByIndex
	mov	DWORD PTR _kUnits$222102[ebp], eax

; 616  : 			for (CvIDInfoFixedVector::const_iterator itrUnit = kUnits.begin(); itrUnit != kUnits.end(); ++itrUnit)

	mov	eax, DWORD PTR _kUnits$222102[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _itrUnit$222103[ebp], ecx
	jmp	SHORT $LN5@updateVisi
$LN4@updateVisi:
	mov	edx, DWORD PTR _itrUnit$222103[ebp]
	add	edx, 8
	mov	DWORD PTR _itrUnit$222103[ebp], edx
$LN5@updateVisi:
	mov	eax, DWORD PTR _kUnits$222102[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _kUnits$222102[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	cmp	DWORD PTR _itrUnit$222103[ebp], ecx
	je	$LN3@updateVisi

; 617  : 			{
; 618  : 				CvUnit* pLoopUnit = ::getUnit(*itrUnit);

	mov	edx, DWORD PTR _itrUnit$222103[ebp]
	push	edx
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4
	mov	DWORD PTR _pLoopUnit$222107[ebp], eax

; 619  : 				if (pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$222107[ebp], 0
	je	$LN61@updateVisi

; 620  : 				{
; 621  : 					InvisibleTypes eInvisibleType = pLoopUnit->getInvisibleType();

	mov	ecx, DWORD PTR _pLoopUnit$222107[ebp]
	call	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getInvisibleType
	mov	DWORD PTR _eInvisibleType$222109[ebp], eax

; 622  : 					if (eInvisibleType != NO_INVISIBLE)

	cmp	DWORD PTR _eInvisibleType$222109[ebp], -1
	je	$LN61@updateVisi

; 623  : 					{
; 624  : 						// This unit has visibility rules, send a message that it needs to update itself.
; 625  : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T230802[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T230802[ebp], 0
	je	SHORT $LN21@updateVisi
	mov	eax, DWORD PTR _pLoopUnit$222107[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230802[ebp]
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	DWORD PTR tv208[ebp], eax
	jmp	SHORT $LN22@updateVisi
$LN21@updateVisi:
	mov	DWORD PTR tv208[ebp], 0
$LN22@updateVisi:
	mov	ecx, DWORD PTR tv208[ebp]
	mov	DWORD PTR $T230801[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T230801[ebp]
	mov	DWORD PTR _pDllUnit$222116[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 626  : 						gDLL->GameplayUnitVisibility(pDllUnit.get(), (pLoopUnit->getTeam() == eActiveTeam)?true:isInvisibleVisible(eActiveTeam, eInvisibleType), true, 0.01f);

	mov	ecx, DWORD PTR _pLoopUnit$222107[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eActiveTeam$[ebp]
	jne	SHORT $LN23@updateVisi
	mov	BYTE PTR tv230[ebp], 1
	jmp	SHORT $LN24@updateVisi
$LN23@updateVisi:
	mov	eax, DWORD PTR _eInvisibleType$222109[ebp]
	push	eax
	mov	ecx, DWORD PTR _eActiveTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
	mov	BYTE PTR tv230[ebp], al
$LN24@updateVisi:
	mov	edx, DWORD PTR $T230867[ebp]
	mov	DWORD PTR tv218[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv218[ebp], eax
	push	ecx
	fld	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR [esp]
	push	1
	movzx	ecx, BYTE PTR tv230[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDllUnit$222116[ebp]
	push	edx
	mov	eax, DWORD PTR tv218[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv218[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax

; 627  : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllUnit$222116[ebp]
	mov	DWORD PTR $T230879[ebp], ecx
	cmp	DWORD PTR $T230879[ebp], 0
	je	SHORT $LN63@updateVisi
	mov	edx, DWORD PTR $T230879[ebp]
	mov	DWORD PTR _inst$230883[ebp], edx
	mov	eax, DWORD PTR _inst$230883[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$230883[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN63@updateVisi:
$LN61@updateVisi:

; 628  : 				}
; 629  : 			}

	jmp	$LN4@updateVisi
$LN3@updateVisi:

; 630  : 		}

	jmp	$LN7@updateVisi
$LN6@updateVisi:
$LN15@updateVisi:

; 631  : 	}
; 632  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$0:
	mov	eax, DWORD PTR $T230796[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$1:
	lea	ecx, DWORD PTR _pDllUnit$222086[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$2:
	mov	eax, DWORD PTR $T230802[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateVisibility@CvPlot@@QAEXXZ$3:
	lea	ecx, DWORD PTR _pDllUnit$222116[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?updateVisibility@CvPlot@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-136]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?updateVisibility@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateVisibility@CvPlot@@QAEXXZ ENDP			; CvPlot::updateVisibility
PUBLIC	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
EXTRN	??3CvDllPlot@@SAXPAX@Z:PROC			; CvDllPlot::operator delete
EXTRN	??0CvDllPlot@@QAE@PAVCvPlot@@@Z:PROC		; CvDllPlot::CvDllPlot
EXTRN	??2CvDllPlot@@SAPAXI@Z:PROC			; CvDllPlot::operator new
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?updateSymbols@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$1
__ehfuncinfo$?updateSymbols@CvPlot@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?updateSymbols@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateSymbols@CvPlot@@QAEXXZ
_TEXT	SEGMENT
tv87 = -48						; size = 4
tv77 = -44						; size = 4
_this$ = -40						; size = 4
_inst$230924 = -36					; size = 4
$T230920 = -32						; size = 4
$T230908 = -28						; size = 4
$T230897 = -24						; size = 4
$T230896 = -20						; size = 4
_pDllPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?updateSymbols@CvPlot@@QAEXXZ PROC			; CvPlot::updateSymbols, COMDAT
; _this$ = ecx

; 636  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?updateSymbols@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 637  : 	auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T230897[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T230897[ebp], 0
	je	SHORT $LN3@updateSymb
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T230897[ebp]
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN4@updateSymb
$LN3@updateSymb:
	mov	DWORD PTR tv77[ebp], 0
$LN4@updateSymb:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR $T230896[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T230896[ebp]
	mov	DWORD PTR _pDllPlot$[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 638  : 	gDLL->GameplayYieldMightHaveChanged(pDllPlot.get());

	mov	eax, DWORD PTR $T230908[ebp]
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv87[ebp], ecx
	mov	edx, DWORD PTR _pDllPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+716]
	call	eax

; 639  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllPlot$[ebp]
	mov	DWORD PTR $T230920[ebp], ecx
	cmp	DWORD PTR $T230920[ebp], 0
	je	SHORT $LN1@updateSymb
	mov	edx, DWORD PTR $T230920[ebp]
	mov	DWORD PTR _inst$230924[ebp], edx
	mov	eax, DWORD PTR _inst$230924[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$230924[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@updateSymb:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$0:
	mov	eax, DWORD PTR $T230897[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateSymbols@CvPlot@@QAEXXZ$1:
	lea	ecx, DWORD PTR _pDllPlot$[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?updateSymbols@CvPlot@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?updateSymbols@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateSymbols@CvPlot@@QAEXXZ ENDP			; CvPlot::updateSymbols
PUBLIC	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
PUBLIC	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
PUBLIC	?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ	; CvPlot::getSelectedUnit
PUBLIC	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit
PUBLIC	?isActiveVisible@CvPlot@@QBE_N_N@Z		; CvPlot::isActiveVisible
PUBLIC	?updateCenterUnit@CvPlot@@QAEXXZ		; CvPlot::updateCenterUnit
EXTRN	?IsGarrisoned@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsGarrisoned
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?updateCenterUnit@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$9
__ehfuncinfo$?updateCenterUnit@CvPlot@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?updateCenterUnit@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateCenterUnit@CvPlot@@QAEXXZ
_TEXT	SEGMENT
tv298 = -208						; size = 4
tv282 = -204						; size = 4
tv271 = -200						; size = 4
tv400 = -196						; size = 4
tv319 = -192						; size = 4
tv349 = -188						; size = 4
tv315 = -184						; size = 4
tv310 = -180						; size = 4
tv308 = -176						; size = 4
_this$ = -172						; size = 4
_inst$231112 = -168					; size = 4
$T231108 = -164						; size = 4
$T231096 = -160						; size = 4
$T231089 = -156						; size = 4
$T231064 = -152						; size = 4
$T231060 = -148						; size = 4
$T231032 = -144						; size = 4
$T231019 = -140						; size = 4
$T231009 = -136						; size = 4
$T231005 = -132						; size = 4
$T230998 = -128						; size = 4
$T230985 = -124						; size = 4
$T230981 = -120						; size = 4
$T230977 = -116						; size = 4
$T230976 = -112						; size = 4
$T230966 = -108						; size = 4
$T230944 = -104						; size = 4
$T230943 = -100						; size = 4
$T230942 = -96						; size = 8
$T230941 = -88						; size = 4
$T230940 = -84						; size = 8
$T230939 = -73						; size = 1
$T230938 = -72						; size = 4
$T230937 = -68						; size = 8
$T230936 = -57						; size = 1
$T230935 = -56						; size = 4
$T230934 = -52						; size = 4
_pDllUnit$222217 = -48					; size = 4
_pUnitNode$222199 = -44					; size = 4
_pLoopUnit$222200 = -40					; size = 4
_hBestDefender$222192 = -36				; size = 8
_eActiveTeam$ = -28					; size = 4
_pUnitNode$ = -24					; size = 4
_pLoopUnit$ = -20					; size = 4
_pCenterUnit$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?updateCenterUnit@CvPlot@@QAEXXZ PROC			; CvPlot::updateCenterUnit, COMDAT
; _this$ = ecx

; 644  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?updateCenterUnit@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 645  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@updateCent

; 646  : 	{
; 647  : 		return;

	jmp	$LN13@updateCent
$LN12@updateCent:

; 648  : 	}
; 649  : 
; 650  : 	if(!isActiveVisible(true))

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@updateCent

; 651  : 	{
; 652  : 		setCenterUnit(NULL);

	sub	esp, 8
	mov	edx, esp
	mov	DWORD PTR $T230934[ebp], esp
	mov	DWORD PTR $T230966[ebp], edx
	mov	eax, DWORD PTR $T230966[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T230966[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	edx, DWORD PTR $T230966[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN30@updateCent
	mov	eax, DWORD PTR $T230966[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN30@updateCent:
	mov	ecx, DWORD PTR $T230966[ebp]
	mov	DWORD PTR tv308[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit

; 653  : 		return;

	jmp	$LN13@updateCent
$LN11@updateCent:

; 654  : 	}
; 655  : 
; 656  : 	setCenterUnit(getSelectedUnit());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ ; CvPlot::getSelectedUnit
	mov	DWORD PTR $T230977[ebp], eax
	sub	esp, 8
	mov	edx, esp
	mov	DWORD PTR $T230935[ebp], esp
	mov	DWORD PTR $T230976[ebp], edx
	mov	eax, DWORD PTR $T230976[ebp]
	mov	ecx, DWORD PTR $T230977[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T230976[ebp]
	mov	BYTE PTR [edx+4], 0
	mov	eax, DWORD PTR $T230976[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN35@updateCent
	mov	ecx, DWORD PTR $T230976[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN35@updateCent:
	mov	edx, DWORD PTR $T230976[ebp]
	mov	DWORD PTR tv310[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit

; 657  : 
; 658  : 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230981[ebp], eax
	mov	ecx, DWORD PTR $T230981[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eActiveTeam$[ebp], eax

; 659  : 
; 660  : 	if(!getCenterUnit())

	lea	ecx, DWORD PTR $T230937[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	DWORD PTR $T230985[ebp], eax
	mov	edx, DWORD PTR $T230985[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx], 0
	sete	al
	mov	BYTE PTR $T230936[ebp], al
	cmp	DWORD PTR $T230937[ebp], 0
	je	SHORT $LN44@updateCent
	mov	ecx, DWORD PTR $T230937[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@updateCent:
	movzx	ecx, BYTE PTR $T230936[ebp]
	test	ecx, ecx
	je	$LN60@updateCent

; 661  : 	{
; 662  : 		UnitHandle hBestDefender = getBestDefender(NO_PLAYER, GC.getGame().getActivePlayer());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T230998[ebp], edx
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T230998[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	push	eax
	push	-1
	lea	eax, DWORD PTR _hBestDefender$222192[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 663  : 		if(hBestDefender && hBestDefender->getDomainType() != DOMAIN_AIR && !hBestDefender->isInvisible(eActiveTeam,false))

	xor	ecx, ecx
	cmp	DWORD PTR _hBestDefender$222192[ebp], 0
	setne	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN9@updateCent
	mov	eax, DWORD PTR _hBestDefender$222192[ebp]
	mov	DWORD PTR $T231005[ebp], eax
	mov	ecx, DWORD PTR $T231005[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN9@updateCent
	mov	ecx, DWORD PTR _hBestDefender$222192[ebp]
	mov	DWORD PTR $T231009[ebp], ecx
	push	1
	push	0
	mov	edx, DWORD PTR _eActiveTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T231009[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@updateCent

; 664  : 			setCenterUnit(hBestDefender);

	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T230938[ebp], esp
	mov	DWORD PTR $T231019[ebp], ecx
	mov	edx, DWORD PTR $T231019[ebp]
	mov	eax, DWORD PTR _hBestDefender$222192[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T231019[ebp]
	mov	dl, BYTE PTR _hBestDefender$222192[ebp+4]
	mov	BYTE PTR [ecx+4], dl
	mov	eax, DWORD PTR $T231019[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN57@updateCent
	mov	ecx, DWORD PTR $T231019[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@updateCent:
	mov	edx, DWORD PTR $T231019[ebp]
	mov	DWORD PTR tv315[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit
$LN9@updateCent:

; 665  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _hBestDefender$222192[ebp], 0
	je	SHORT $LN62@updateCent
	mov	ecx, DWORD PTR _hBestDefender$222192[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@updateCent:
$LN60@updateCent:

; 666  : 
; 667  : 	// okay, all of the other checks failed - if there is any unit here, make it the center unit
; 668  : 	if(!getCenterUnit())

	lea	eax, DWORD PTR $T230940[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	DWORD PTR $T231032[ebp], eax
	mov	ecx, DWORD PTR $T231032[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx], 0
	sete	dl
	mov	BYTE PTR $T230939[ebp], dl
	cmp	DWORD PTR $T230940[ebp], 0
	je	SHORT $LN69@updateCent
	mov	ecx, DWORD PTR $T230940[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN69@updateCent:
	movzx	eax, BYTE PTR $T230939[ebp]
	test	eax, eax
	je	$LN6@updateCent

; 669  : 	{
; 670  : 		IDInfo* pUnitNode;
; 671  : 		CvUnit* pLoopUnit;
; 672  : 
; 673  : 		pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$222199[ebp], eax

; 674  : 
; 675  : 		if(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$222199[ebp], 0
	je	$LN6@updateCent

; 676  : 		{
; 677  : 			pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$222199[ebp]
	cmp	DWORD PTR [ecx], 0
	jl	SHORT $LN71@updateCent
	mov	edx, DWORD PTR _pUnitNode$222199[ebp]
	cmp	DWORD PTR [edx], 64			; 00000040H
	jge	SHORT $LN71@updateCent
	mov	eax, DWORD PTR _pUnitNode$222199[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+ecx+4472]
	mov	DWORD PTR tv349[ebp], eax
	mov	ecx, DWORD PTR _pUnitNode$222199[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR tv349[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv349[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$222200[ebp], eax
	jmp	SHORT $LN72@updateCent
$LN71@updateCent:
	mov	DWORD PTR _pLoopUnit$222200[ebp], 0
$LN72@updateCent:

; 678  : 			if(pLoopUnit && !pLoopUnit->IsGarrisoned() && pLoopUnit->getDomainType() != DOMAIN_AIR && !pLoopUnit->isInvisible(eActiveTeam,false))

	cmp	DWORD PTR _pLoopUnit$222200[ebp], 0
	je	$LN6@updateCent
	mov	ecx, DWORD PTR _pLoopUnit$222200[ebp]
	call	?IsGarrisoned@CvUnit@@QBE_NXZ		; CvUnit::IsGarrisoned
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@updateCent
	mov	ecx, DWORD PTR _pLoopUnit$222200[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN6@updateCent
	push	1
	push	0
	mov	edx, DWORD PTR _eActiveTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$222200[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@updateCent

; 679  : 			{
; 680  : 				setCenterUnit(pLoopUnit);

	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T230941[ebp], esp
	mov	DWORD PTR $T231060[ebp], ecx
	mov	edx, DWORD PTR $T231060[ebp]
	mov	eax, DWORD PTR _pLoopUnit$222200[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T231060[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	edx, DWORD PTR $T231060[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN79@updateCent
	mov	eax, DWORD PTR $T231060[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN79@updateCent:
	mov	ecx, DWORD PTR $T231060[ebp]
	mov	DWORD PTR tv319[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ; CvPlot::setCenterUnit
$LN6@updateCent:

; 681  : 			}
; 682  : 		}
; 683  : 	}
; 684  : 
; 685  : 	IDInfo* pUnitNode;
; 686  : 	CvUnit* pLoopUnit;
; 687  : 	CvUnit* pCenterUnit = getCenterUnit().pointer();

	lea	edx, DWORD PTR $T230942[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	DWORD PTR $T231064[ebp], eax
	mov	eax, DWORD PTR $T231064[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pCenterUnit$[ebp], ecx
	cmp	DWORD PTR $T230942[ebp], 0
	je	SHORT $LN86@updateCent
	mov	ecx, DWORD PTR $T230942[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN86@updateCent:

; 688  : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN5@updateCent:

; 689  : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN4@updateCent

; 690  : 	{
; 691  : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN88@updateCent
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN88@updateCent
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv400[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv400[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv400[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN89@updateCent
$LN88@updateCent:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN89@updateCent:

; 692  : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 693  : 
; 694  : 		if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN103@updateCent

; 695  : 		{
; 696  : 			auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T230944[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T230944[ebp], 0
	je	SHORT $LN15@updateCent
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230944[ebp]
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	DWORD PTR tv271[ebp], eax
	jmp	SHORT $LN16@updateCent
$LN15@updateCent:
	mov	DWORD PTR tv271[ebp], 0
$LN16@updateCent:
	mov	eax, DWORD PTR tv271[ebp]
	mov	DWORD PTR $T230943[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T230943[ebp]
	mov	DWORD PTR _pDllUnit$222217[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 697  : 
; 698  : 			if(pCenterUnit == pLoopUnit)

	mov	edx, DWORD PTR _pCenterUnit$[ebp]
	cmp	edx, DWORD PTR _pLoopUnit$[ebp]
	jne	SHORT $LN2@updateCent

; 699  : 			{
; 700  : 				gDLL->GameplayUnitVisibility(pDllUnit.get(), true, false, 0.01f);

	mov	eax, DWORD PTR $T231089[ebp]
	mov	DWORD PTR tv282[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv282[ebp], ecx
	push	ecx
	fld	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR [esp]
	push	0
	push	1
	mov	edx, DWORD PTR _pDllUnit$222217[ebp]
	push	edx
	mov	eax, DWORD PTR tv282[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv282[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax

; 701  : 			}
; 702  : 			else

	jmp	SHORT $LN1@updateCent
$LN2@updateCent:

; 703  : 			{
; 704  : 				gDLL->GameplayUnitVisibility(pDllUnit.get(), false, false, 0.01f);

	mov	ecx, DWORD PTR $T231096[ebp]
	mov	DWORD PTR tv298[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv298[ebp], edx
	push	ecx
	fld	DWORD PTR __real@3c23d70a
	fstp	DWORD PTR [esp]
	push	0
	push	0
	mov	eax, DWORD PTR _pDllUnit$222217[ebp]
	push	eax
	mov	ecx, DWORD PTR tv298[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv298[ebp]
	mov	eax, DWORD PTR [edx+640]
	call	eax
$LN1@updateCent:

; 705  : 			}
; 706  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllUnit$222217[ebp]
	mov	DWORD PTR $T231108[ebp], ecx
	cmp	DWORD PTR $T231108[ebp], 0
	je	SHORT $LN105@updateCent
	mov	edx, DWORD PTR $T231108[ebp]
	mov	DWORD PTR _inst$231112[ebp], edx
	mov	eax, DWORD PTR _inst$231112[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$231112[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN105@updateCent:
$LN103@updateCent:

; 707  : 	}

	jmp	$LN5@updateCent
$LN4@updateCent:
$LN13@updateCent:

; 708  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$3:
	lea	ecx, DWORD PTR _hBestDefender$222192[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$8:
	mov	eax, DWORD PTR $T230944[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateCenterUnit@CvPlot@@QAEXXZ$9:
	lea	ecx, DWORD PTR _pDllUnit$222217[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?updateCenterUnit@CvPlot@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-200]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?updateCenterUnit@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateCenterUnit@CvPlot@@QAEXXZ ENDP			; CvPlot::updateCenterUnit
PUBLIC	??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>
PUBLIC	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z	; CvPlot::isVisibleEnemyUnit
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation
PUBLIC	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,50,1,297,0>::push_back
PUBLIC	??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::FStaticVector<IDInfo,50,1,297,0>
PUBLIC	__$ArrayPad$
EXTRN	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z:PROC ; CvUnit::canEnterTerritory
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ:PROC	; CvUnit::jumpToNearestValidPlot
EXTRN	?isInCombat@CvUnit@@QBE_NXZ:PROC		; CvUnit::isInCombat
EXTRN	?isCargo@CvUnit@@QBE_NXZ:PROC			; CvUnit::isCargo
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
EXTRN	?isDelayedDeath@CvUnit@@QBE_NXZ:PROC		; CvUnit::isDelayedDeath
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?verifyUnitValidPlot@CvPlot@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?verifyUnitValidPlot@CvPlot@@QAEXXZ$0
__ehfuncinfo$?verifyUnitValidPlot@CvPlot@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?verifyUnitValidPlot@CvPlot@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?verifyUnitValidPlot@CvPlot@@QAEXXZ
_TEXT	SEGMENT
tv376 = -548						; size = 4
tv311 = -544						; size = 4
_this$ = -540						; size = 4
$T231259 = -524						; size = 4
_playerID$231251 = -520					; size = 4
$T231242 = -516						; size = 4
$T231238 = -512						; size = 4
$T231234 = -508						; size = 4
_playerID$231226 = -504					; size = 4
$T231208 = -500						; size = 4
$T231204 = -496						; size = 4
_playerID$231196 = -492					; size = 4
$T231182 = -484						; size = 4
$T231178 = -480						; size = 4
$T231174 = -476						; size = 4
$T231161 = -472						; size = 4
$T231157 = -468						; size = 4
_i$231141 = -460					; size = 4
_iVectorLoop$222321 = -456				; size = 4
_bIsOwnedByMinor$222314 = -449				; size = 1
_iVectorLoop$222301 = -448				; size = 4
_oldUnitList$ = -444					; size = 416
__$ArrayPad$ = -28					; size = 4
_iUnitListSize$ = -24					; size = 4
_pUnitNode$ = -20					; size = 4
_pLoopUnit$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?verifyUnitValidPlot@CvPlot@@QAEXXZ PROC		; CvPlot::verifyUnitValidPlot, COMDAT
; _this$ = ecx

; 713  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verifyUnitValidPlot@CvPlot@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 714  : 	FStaticVector<IDInfo, 50, true, c_eCiv5GameplayDLL, 0> oldUnitList;

	lea	ecx, DWORD PTR _oldUnitList$[ebp]
	call	??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::FStaticVector<IDInfo,50,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 715  : 
; 716  : 	IDInfo* pUnitNode;
; 717  : 	CvUnit* pLoopUnit;
; 718  : 
; 719  : 	oldUnitList.clear();

	xor	eax, eax
	je	SHORT $LN45@verifyUnit
	mov	DWORD PTR _i$231141[ebp], 0
	jmp	SHORT $LN43@verifyUnit
$LN42@verifyUnit:
	mov	ecx, DWORD PTR _i$231141[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$231141[ebp], ecx
$LN43@verifyUnit:
	mov	edx, DWORD PTR _i$231141[ebp]
	cmp	edx, DWORD PTR _oldUnitList$[ebp+4]
	jae	SHORT $LN45@verifyUnit
	jmp	SHORT $LN42@verifyUnit
$LN45@verifyUnit:
	mov	DWORD PTR _oldUnitList$[ebp+4], 0

; 720  : 
; 721  : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN30@verifyUnit:

; 722  : 
; 723  : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	SHORT $LN29@verifyUnit

; 724  : 	{
; 725  : 		oldUnitList.push_back(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oldUnitList$[ebp]
	call	?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,50,1,297,0>::push_back

; 726  : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 727  : 	}

	jmp	SHORT $LN30@verifyUnit
$LN29@verifyUnit:

; 728  : 
; 729  : 	int iUnitListSize = (int) oldUnitList.size();

	mov	edx, DWORD PTR _oldUnitList$[ebp+4]
	mov	DWORD PTR $T231157[ebp], edx
	mov	eax, DWORD PTR $T231157[ebp]
	mov	DWORD PTR _iUnitListSize$[ebp], eax

; 730  : 	for(int iVectorLoop = 0; iVectorLoop < (int) iUnitListSize; ++iVectorLoop)

	mov	DWORD PTR _iVectorLoop$222301[ebp], 0
	jmp	SHORT $LN28@verifyUnit
$LN27@verifyUnit:
	mov	ecx, DWORD PTR _iVectorLoop$222301[ebp]
	add	ecx, 1
	mov	DWORD PTR _iVectorLoop$222301[ebp], ecx
$LN28@verifyUnit:
	mov	edx, DWORD PTR _iVectorLoop$222301[ebp]
	cmp	edx, DWORD PTR _iUnitListSize$[ebp]
	jge	$LN26@verifyUnit

; 731  : 	{
; 732  : 		pLoopUnit = GetPlayerUnit(oldUnitList[iVectorLoop]);

	mov	eax, DWORD PTR _iVectorLoop$222301[ebp]
	mov	ecx, DWORD PTR _oldUnitList$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T231161[ebp], edx
	mov	eax, DWORD PTR $T231161[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN58@verifyUnit
	mov	ecx, DWORD PTR $T231161[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN58@verifyUnit
	mov	edx, DWORD PTR $T231161[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv311[ebp], edx
	mov	eax, DWORD PTR $T231161[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv311[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv311[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN59@verifyUnit
$LN58@verifyUnit:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN59@verifyUnit:

; 733  : 		if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN25@verifyUnit

; 734  : 		{
; 735  : 			if(!pLoopUnit->isDelayedDeath())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	movzx	eax, al
	test	eax, eax
	jne	$LN25@verifyUnit

; 736  : 			{
; 737  : 				if(pLoopUnit->atPlot(*this))

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	movzx	edx, al
	test	edx, edx
	je	$LN25@verifyUnit

; 738  : 				{
; 739  : 					if(!(pLoopUnit->isCargo()))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	movzx	eax, al
	test	eax, eax
	jne	$LN25@verifyUnit

; 740  : 					{
; 741  : 						if(!(pLoopUnit->isInCombat()))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isInCombat@CvUnit@@QBE_NXZ		; CvUnit::isInCombat
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN25@verifyUnit

; 742  : 						{
; 743  : 							// Unit not allowed to be here
; 744  : 							if(getNumFriendlyUnitsOfType(pLoopUnit) > /*1*/ GC.getPLOT_UNIT_LIMIT())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR $T231174[ebp], edx
	push	1
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR $T231174[ebp]
	jle	SHORT $LN20@verifyUnit

; 745  : 							{
; 746  : 								if (!pLoopUnit->jumpToNearestValidPlot())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN20@verifyUnit

; 747  : 								{
; 748  : 									pLoopUnit->kill(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill

; 749  : 									pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN20@verifyUnit:

; 750  : 								}
; 751  : 							}
; 752  : 							
; 753  : 							if (pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN25@verifyUnit

; 754  : 							{
; 755  : #ifdef NQ_NEVER_PUSH_OUT_OF_MINORS_ON_PEACE
; 756  : 								bool bIsOwnedByMinor = false;

	mov	BYTE PTR _bIsOwnedByMinor$222314[ebp], 0

; 757  : 								if (isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@verifyUnit

; 758  : 								{
; 759  : 									if (GET_PLAYER(getOwner()).isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T231178[ebp], ecx
	mov	edx, DWORD PTR $T231178[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231182[ebp], edx
	mov	ecx, DWORD PTR $T231182[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@verifyUnit

; 760  : 									{
; 761  : 										bIsOwnedByMinor = true;

	mov	BYTE PTR _bIsOwnedByMinor$222314[ebp], 1
$LN17@verifyUnit:

; 762  : 									}
; 763  : 								}
; 764  : 								// may want to make an extra check here about if it's owned by minor, we can still enter territory but with ignoring right of passage
; 765  : 								if(!isValidDomainForLocation(*pLoopUnit) || (!bIsOwnedByMinor && !(pLoopUnit->canEnterTerritory(getTeam(), false /*bIgnoreRightOfPassage*/, isCity()))))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@verifyUnit
	movzx	eax, BYTE PTR _bIsOwnedByMinor$222314[ebp]
	test	eax, eax
	jne	$LN25@verifyUnit
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$231196[ebp], edx
	cmp	DWORD PTR _playerID$231196[ebp], -1
	je	SHORT $LN75@verifyUnit
	mov	eax, DWORD PTR _playerID$231196[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231204[ebp], eax
	jmp	SHORT $LN76@verifyUnit
	jmp	SHORT $LN76@verifyUnit
$LN75@verifyUnit:
	mov	DWORD PTR $T231204[ebp], -1
$LN76@verifyUnit:
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	push	ecx
	push	0
	mov	edx, DWORD PTR $T231204[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canEnterTerritory@CvUnit@@QBE_NW4TeamTypes@@_N11@Z ; CvUnit::canEnterTerritory
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@verifyUnit
$LN14@verifyUnit:

; 766  : #else
; 767  : 								if(!isValidDomainForLocation(*pLoopUnit) || !(pLoopUnit->canEnterTerritory(getTeam(), false /*bIgnoreRightOfPassage*/, isCity())))
; 768  : #endif
; 769  : 								{
; 770  : 									if (!pLoopUnit->jumpToNearestValidPlot())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@verifyUnit

; 771  : 										pLoopUnit->kill(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN25@verifyUnit:

; 772  : 								}
; 773  : 							}
; 774  : 						}
; 775  : 					}
; 776  : 				}
; 777  : 			}
; 778  : 		}
; 779  : 	}

	jmp	$LN27@verifyUnit
$LN26@verifyUnit:

; 780  : 
; 781  : 	// Unit not allowed in a plot owned by someone?
; 782  : 	if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	$LN12@verifyUnit

; 783  : 	{
; 784  : 		for(int iVectorLoop = 0; iVectorLoop < (int) iUnitListSize; ++iVectorLoop)

	mov	DWORD PTR _iVectorLoop$222321[ebp], 0
	jmp	SHORT $LN11@verifyUnit
$LN10@verifyUnit:
	mov	eax, DWORD PTR _iVectorLoop$222321[ebp]
	add	eax, 1
	mov	DWORD PTR _iVectorLoop$222321[ebp], eax
$LN11@verifyUnit:
	mov	ecx, DWORD PTR _iVectorLoop$222321[ebp]
	cmp	ecx, DWORD PTR _iUnitListSize$[ebp]
	jge	$LN12@verifyUnit

; 785  : 		{
; 786  : 			pLoopUnit = GetPlayerUnit(oldUnitList[iVectorLoop]);

	mov	edx, DWORD PTR _iVectorLoop$222321[ebp]
	mov	eax, DWORD PTR _oldUnitList$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T231208[ebp], ecx
	mov	edx, DWORD PTR $T231208[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN84@verifyUnit
	mov	eax, DWORD PTR $T231208[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN84@verifyUnit
	mov	ecx, DWORD PTR $T231208[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv376[ebp], ecx
	mov	edx, DWORD PTR $T231208[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv376[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv376[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN85@verifyUnit
$LN84@verifyUnit:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN85@verifyUnit:

; 787  : 			if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN8@verifyUnit

; 788  : 			{
; 789  : 				if(!pLoopUnit->isDelayedDeath())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isDelayedDeath@CvUnit@@QBE_NXZ		; CvUnit::isDelayedDeath
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN8@verifyUnit

; 790  : 				{
; 791  : 					if(pLoopUnit->atPlot(*this))  // it may have jumped

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	movzx	eax, al
	test	eax, eax
	je	$LN8@verifyUnit

; 792  : 					{
; 793  : 						if(!(pLoopUnit->isInCombat()))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isInCombat@CvUnit@@QBE_NXZ		; CvUnit::isInCombat
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN8@verifyUnit

; 794  : 						{
; 795  : #ifdef NQ_NEVER_PUSH_OUT_OF_MINORS_ON_PEACE
; 796  : 							if(pLoopUnit->getTeam() != getTeam() && !GET_PLAYER(getOwner()).isMinorCiv())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$231226[ebp], eax
	cmp	DWORD PTR _playerID$231226[ebp], -1
	je	SHORT $LN90@verifyUnit
	mov	ecx, DWORD PTR _playerID$231226[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231234[ebp], eax
	jmp	SHORT $LN91@verifyUnit
	jmp	SHORT $LN91@verifyUnit
$LN90@verifyUnit:
	mov	DWORD PTR $T231234[ebp], -1
$LN91@verifyUnit:
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR $T231234[ebp]
	je	$LN8@verifyUnit
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T231238[ebp], eax
	mov	ecx, DWORD PTR $T231238[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T231242[ebp], ecx
	mov	ecx, DWORD PTR $T231242[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	$LN8@verifyUnit

; 797  : #else
; 798  : 							if(pLoopUnit->getTeam() != getTeam()) // && getTeam() == NO_TEAM)// || !GET_TEAM(getTeam()).isVassal(pLoopUnit->getTeam())))
; 799  : #endif
; 800  : 							{
; 801  : 								if(isVisibleEnemyUnit(pLoopUnit))

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@verifyUnit

; 802  : 								{
; 803  : 									if(!(pLoopUnit->isInvisible(getTeam(), false)))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$231251[ebp], eax
	cmp	DWORD PTR _playerID$231251[ebp], -1
	je	SHORT $LN102@verifyUnit
	mov	ecx, DWORD PTR _playerID$231251[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T231259[ebp], eax
	jmp	SHORT $LN103@verifyUnit
	jmp	SHORT $LN103@verifyUnit
$LN102@verifyUnit:
	mov	DWORD PTR $T231259[ebp], -1
$LN103@verifyUnit:
	push	1
	push	0
	mov	edx, DWORD PTR $T231259[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@verifyUnit

; 804  : 									{
; 805  : 										if (!pLoopUnit->jumpToNearestValidPlot())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?jumpToNearestValidPlot@CvUnit@@QAE_NXZ	; CvUnit::jumpToNearestValidPlot
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@verifyUnit

; 806  : 											pLoopUnit->kill(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?kill@CvUnit@@QAEX_NW4PlayerTypes@@@Z	; CvUnit::kill
$LN8@verifyUnit:

; 807  : 									}
; 808  : 								}
; 809  : 							}
; 810  : 						}
; 811  : 					}
; 812  : 				}
; 813  : 			}
; 814  : 		}

	jmp	$LN10@verifyUnit
$LN12@verifyUnit:

; 815  : 	}
; 816  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _oldUnitList$[ebp]
	call	??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?verifyUnitValidPlot@CvPlot@@QAEXXZ$0:
	lea	ecx, DWORD PTR _oldUnitList$[ebp]
	jmp	??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>
__ehhandler$?verifyUnitValidPlot@CvPlot@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-540]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?verifyUnitValidPlot@CvPlot@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?verifyUnitValidPlot@CvPlot@@QAEXXZ ENDP		; CvPlot::verifyUnitValidPlot
PUBLIC	?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z	; CvPlot::nukeExplosion
EXTRN	?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z:PROC ; CvUnitCombat::ApplyNuclearExplosionDamage
; Function compile flags: /Odtp
;	COMDAT ?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iDamageLevel$ = 8					; size = 4
___formal$ = 12						; size = 4
?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z PROC		; CvPlot::nukeExplosion, COMDAT
; _this$ = ecx

; 821  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 822  : 	CvUnitCombat::ApplyNuclearExplosionDamage(this, iDamageLevel);

	push	0
	mov	eax, DWORD PTR _iDamageLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?ApplyNuclearExplosionDamage@CvUnitCombat@@SAIPAVCvPlot@@HPAVCvUnit@@@Z ; CvUnitCombat::ApplyNuclearExplosionDamage
	add	esp, 12					; 0000000cH

; 823  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z ENDP		; CvPlot::nukeExplosion
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?isAdjacentToArea@CvPlot@@QBE_NH@Z		; CvPlot::isAdjacentToArea
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentToArea@CvPlot@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T231515 = -108						; size = 4
$T231304 = -16						; size = 4
$T231300 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_iAreaID$ = 8						; size = 4
?isAdjacentToArea@CvPlot@@QBE_NH@Z PROC			; CvPlot::isAdjacentToArea, COMDAT
; _this$ = ecx

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 828  : 
; 829  : 	CvPlot* pAdjacentPlot;
; 830  : 	int iI;
; 831  : 
; 832  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent
$LN4@isAdjacent:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent

; 833  : 	{
; 834  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T231300[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T231304[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T231300[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231304[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 835  : 
; 836  : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent

; 837  : 		{
; 838  : 			if(pAdjacentPlot->getArea() == iAreaID)

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T231515[ebp], eax
	mov	ecx, DWORD PTR $T231515[ebp]
	cmp	ecx, DWORD PTR _iAreaID$[ebp]
	jne	SHORT $LN2@isAdjacent

; 839  : 			{
; 840  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent
$LN2@isAdjacent:

; 841  : 			}
; 842  : 		}
; 843  : 	}

	jmp	SHORT $LN4@isAdjacent
$LN3@isAdjacent:

; 844  : 
; 845  : 	return false;

	xor	al, al
$LN6@isAdjacent:

; 846  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAdjacentToArea@CvPlot@@QBE_NH@Z ENDP			; CvPlot::isAdjacentToArea
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T231722 = -80						; size = 4
$T231677 = -76						; size = 4
$T231664 = -72						; size = 4
$T231660 = -68						; size = 4
$T231646 = -64						; size = 4
$T231642 = -57						; size = 1
$T231631 = -56						; size = 4
$T231627 = -49						; size = 1
_iMapY$231721 = -48					; size = 4
_iMapX$231720 = -44					; size = 4
$T231620 = -40						; size = 4
$T231596 = -36						; size = 4
$T231559 = -32						; size = 4
$T231547 = -28						; size = 4
$T231543 = -21						; size = 1
$T231532 = -20						; size = 4
$T231528 = -13						; size = 1
_iMapY$231595 = -12					; size = 4
_iMapX$231594 = -8					; size = 4
$T231521 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231521[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T231596[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T231521[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T231528[ebp], dl
	mov	eax, DWORD PTR $T231521[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231532[ebp], ecx
	movzx	edx, BYTE PTR $T231528[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231532[ebp]
	add	edx, DWORD PTR $T231532[ebp]
	mov	DWORD PTR _iMapX$231594[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T231532[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231532[ebp]
	mov	DWORD PTR _iMapX$231594[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$231594[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T231521[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T231543[ebp], al
	mov	ecx, DWORD PTR $T231521[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231547[ebp], edx
	movzx	eax, BYTE PTR $T231543[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231547[ebp]
	add	edx, DWORD PTR $T231547[ebp]
	mov	DWORD PTR _iMapY$231595[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T231547[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231547[ebp]
	mov	DWORD PTR _iMapY$231595[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$231595[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$231595[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$231594[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231521[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T231521[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T231559[ebp], eax
	mov	ecx, DWORD PTR _iMapY$231595[ebp]
	imul	ecx, DWORD PTR $T231559[ebp]
	add	ecx, DWORD PTR _iMapX$231594[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T231521[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T231596[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T231596[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T231620[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T231722[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T231620[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T231627[ebp], dl
	mov	eax, DWORD PTR $T231620[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231631[ebp], ecx
	movzx	edx, BYTE PTR $T231627[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231631[ebp]
	add	edx, DWORD PTR $T231631[ebp]
	mov	DWORD PTR _iMapX$231720[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T231631[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T231631[ebp]
	mov	DWORD PTR _iMapX$231720[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$231720[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T231620[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T231642[ebp], al
	mov	ecx, DWORD PTR $T231620[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T231646[ebp], edx
	movzx	eax, BYTE PTR $T231642[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231646[ebp]
	add	edx, DWORD PTR $T231646[ebp]
	mov	DWORD PTR _iMapY$231721[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T231646[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T231646[ebp]
	mov	DWORD PTR _iMapY$231721[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$231721[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$231720[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T231620[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231660[ebp], ecx
	mov	edx, DWORD PTR _iMapX$231720[ebp]
	cmp	edx, DWORD PTR $T231660[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$231721[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T231620[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T231664[ebp], ecx
	mov	edx, DWORD PTR _iMapY$231721[ebp]
	cmp	edx, DWORD PTR $T231664[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T231620[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T231677[ebp], ecx
	mov	edx, DWORD PTR _iMapY$231721[ebp]
	imul	edx, DWORD PTR $T231677[ebp]
	add	edx, DWORD PTR _iMapX$231720[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T231620[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T231722[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T231722[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z	; CvPlot::isAdjacentToArea
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T231728 = -4						; size = 4
_pArea$ = 8						; size = 4
?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z PROC	; CvPlot::isAdjacentToArea, COMDAT
; _this$ = ecx

; 850  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 851  : 	return isAdjacentToArea(pArea->GetID());

	mov	eax, DWORD PTR _pArea$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T231728[ebp], ecx
	mov	edx, DWORD PTR $T231728[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAdjacentToArea@CvPlot@@QBE_NH@Z	; CvPlot::isAdjacentToArea

; 852  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z ENDP	; CvPlot::isAdjacentToArea
_TEXT	ENDS
PUBLIC	?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z		; CvPlot::shareAdjacentArea
; Function compile flags: /Odtp
;	COMDAT ?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T231738 = -24						; size = 4
$T231734 = -20						; size = 4
_iCurrArea$ = -16					; size = 4
_iLastArea$ = -12					; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_pPlot$ = 8						; size = 4
?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z PROC		; CvPlot::shareAdjacentArea, COMDAT
; _this$ = ecx

; 857  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 858  : 	int iCurrArea;
; 859  : 	int iLastArea;
; 860  : 	CvPlot* pAdjacentPlot;
; 861  : 	int iI;
; 862  : 
; 863  : 	iLastArea = FFreeList::INVALID_INDEX;

	mov	DWORD PTR _iLastArea$[ebp], -1

; 864  : 
; 865  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@shareAdjac
$LN5@shareAdjac:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@shareAdjac:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN4@shareAdjac

; 866  : 	{
; 867  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T231734[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T231738[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T231734[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231738[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 868  : 
; 869  : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN3@shareAdjac

; 870  : 		{
; 871  : 			iCurrArea = pAdjacentPlot->getArea();

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR _iCurrArea$[ebp], eax

; 872  : 
; 873  : 			if(iCurrArea != iLastArea)

	mov	ecx, DWORD PTR _iCurrArea$[ebp]
	cmp	ecx, DWORD PTR _iLastArea$[ebp]
	je	SHORT $LN3@shareAdjac

; 874  : 			{
; 875  : 				if(pPlot->isAdjacentToArea(iCurrArea))

	mov	edx, DWORD PTR _iCurrArea$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isAdjacentToArea@CvPlot@@QBE_NH@Z	; CvPlot::isAdjacentToArea
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@shareAdjac

; 876  : 				{
; 877  : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@shareAdjac
$LN1@shareAdjac:

; 878  : 				}
; 879  : 
; 880  : 				iLastArea = iCurrArea;

	mov	ecx, DWORD PTR _iCurrArea$[ebp]
	mov	DWORD PTR _iLastArea$[ebp], ecx
$LN3@shareAdjac:

; 881  : 			}
; 882  : 		}
; 883  : 	}

	jmp	SHORT $LN5@shareAdjac
$LN4@shareAdjac:

; 884  : 
; 885  : 	return false;

	xor	al, al
$LN7@shareAdjac:

; 886  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z ENDP		; CvPlot::shareAdjacentArea
_TEXT	ENDS
PUBLIC	?isAdjacent@CvPlot@@QBE_NPBV1@@Z		; CvPlot::isAdjacent
; Function compile flags: /Odtp
;	COMDAT ?isAdjacent@CvPlot@@QBE_NPBV1@@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T231958 = -16						; size = 4
$T231954 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_pPlot$ = 8						; size = 4
?isAdjacent@CvPlot@@QBE_NPBV1@@Z PROC			; CvPlot::isAdjacent, COMDAT
; _this$ = ecx

; 890  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 891  : 	if(pPlot == NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN5@isAdjacent@2

; 892  : 	{
; 893  : 		return false;

	xor	al, al
	jmp	SHORT $LN6@isAdjacent@2
$LN5@isAdjacent@2:

; 894  : 	}
; 895  : 
; 896  : 	CvPlot* pAdjacentPlot;
; 897  : 	int iI;
; 898  : 
; 899  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@isAdjacent@2
$LN3@isAdjacent@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@isAdjacent@2:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN2@isAdjacent@2

; 900  : 	{
; 901  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T231954[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T231958[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T231954[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231958[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 902  : 
; 903  : 		if(pAdjacentPlot == pPlot)

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	cmp	edx, DWORD PTR _pPlot$[ebp]
	jne	SHORT $LN1@isAdjacent@2

; 904  : 		{
; 905  : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@2
$LN1@isAdjacent@2:

; 906  : 		}
; 907  : 	}

	jmp	SHORT $LN3@isAdjacent@2
$LN2@isAdjacent@2:

; 908  : 
; 909  : 	return false;

	xor	al, al
$LN6@isAdjacent@2:

; 910  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAdjacent@CvPlot@@QBE_NPBV1@@Z ENDP			; CvPlot::isAdjacent
_TEXT	ENDS
PUBLIC	?isAdjacentToLand@CvPlot@@QBE_NXZ		; CvPlot::isAdjacentToLand
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentToLand@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T232188 = -16						; size = 4
$T232184 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?isAdjacentToLand@CvPlot@@QBE_NXZ PROC			; CvPlot::isAdjacentToLand, COMDAT
; _this$ = ecx

; 914  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 915  : 	CvPlot* pAdjacentPlot;
; 916  : 	int iI;
; 917  : 
; 918  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@3
$LN4@isAdjacent@3:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent@3:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent@3

; 919  : 	{
; 920  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T232184[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T232188[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T232184[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232188[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 921  : 
; 922  : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@3

; 923  : 		{
; 924  : 			if(!(pAdjacentPlot->isWater()))

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@isAdjacent@3

; 925  : 			{
; 926  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@3
$LN2@isAdjacent@3:

; 927  : 			}
; 928  : 		}
; 929  : 	}

	jmp	SHORT $LN4@isAdjacent@3
$LN3@isAdjacent@3:

; 930  : 
; 931  : 	return false;

	xor	al, al
$LN6@isAdjacent@3:

; 932  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isAdjacentToLand@CvPlot@@QBE_NXZ ENDP			; CvPlot::isAdjacentToLand
_TEXT	ENDS
PUBLIC	?isShallowWater@CvPlot@@QBE_NXZ			; CvPlot::isShallowWater
; Function compile flags: /Odtp
;	COMDAT ?isShallowWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eShallowWater$222397 = -4				; size = 4
?isShallowWater@CvPlot@@QBE_NXZ PROC			; CvPlot::isShallowWater, COMDAT
; _this$ = ecx

; 936  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 937  : 	if(isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@isShallowW

; 938  : 	{
; 939  : 		TerrainTypes eShallowWater = (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR _eShallowWater$222397[ebp], ecx

; 940  : 		if(getTerrainType() == eShallowWater)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	cmp	eax, DWORD PTR _eShallowWater$222397[ebp]
	jne	SHORT $LN2@isShallowW

; 941  : 		{
; 942  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isShallowW
$LN2@isShallowW:

; 943  : 		}
; 944  : 	}
; 945  : 	return false;

	xor	al, al
$LN3@isShallowW:

; 946  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isShallowWater@CvPlot@@QBE_NXZ ENDP			; CvPlot::isShallowWater
_TEXT	ENDS
PUBLIC	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToShallowWater
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentToShallowWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T232422 = -20						; size = 4
$T232418 = -16						; size = 4
_eShallowWater$ = -12					; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?isAdjacentToShallowWater@CvPlot@@QBE_NXZ PROC		; CvPlot::isAdjacentToShallowWater, COMDAT
; _this$ = ecx

; 950  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 951  : 	CvPlot* pAdjacentPlot;
; 952  : 	int iI;
; 953  : 
; 954  : 	TerrainTypes eShallowWater = (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR _eShallowWater$[ebp], eax

; 955  : 
; 956  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@4
$LN4@isAdjacent@4:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@isAdjacent@4:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent@4

; 957  : 	{
; 958  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T232418[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T232422[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232418[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232422[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 959  : 
; 960  : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@4

; 961  : 		{
; 962  : 			if(pAdjacentPlot->getTerrainType() == eShallowWater)

	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	cmp	ecx, DWORD PTR _eShallowWater$[ebp]
	jne	SHORT $LN2@isAdjacent@4

; 963  : 			{
; 964  : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@4
$LN2@isAdjacent@4:

; 965  : 			}
; 966  : 		}
; 967  : 	}

	jmp	SHORT $LN4@isAdjacent@4
$LN3@isAdjacent@4:

; 968  : 
; 969  : 	return false;

	xor	al, al
$LN6@isAdjacent@4:

; 970  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isAdjacentToShallowWater@CvPlot@@QBE_NXZ ENDP		; CvPlot::isAdjacentToShallowWater
_TEXT	ENDS
PUBLIC	?isCoastalLand@CvPlot@@QBE_NH@Z			; CvPlot::isCoastalLand
EXTRN	?getNumTiles@CvLandmass@@QBEHXZ:PROC		; CvLandmass::getNumTiles
EXTRN	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z:PROC	; CvMap::getLandmass
; Function compile flags: /Odtp
;	COMDAT ?isCoastalLand@CvPlot@@QBE_NH@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T232839 = -108						; size = 4
$T232835 = -104						; size = 4
$T232648 = -20						; size = 4
$T232644 = -16						; size = 4
_pAdjacentBodyOfWater$222428 = -12			; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_iMinWaterSize$ = 8					; size = 4
?isCoastalLand@CvPlot@@QBE_NH@Z PROC			; CvPlot::isCoastalLand, COMDAT
; _this$ = ecx

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 976  : 	CvPlot* pAdjacentPlot;
; 977  : 	int iI;
; 978  : 
; 979  : 	if(isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN9@isCoastalL

; 980  : 	{
; 981  : 		return false;

	xor	al, al
	jmp	$LN10@isCoastalL
$LN9@isCoastalL:

; 982  : 	}
; 983  : 
; 984  : 	// If -1 was passed in (default argument) use min water size for ocean define
; 985  : 	if(iMinWaterSize == -1)

	cmp	DWORD PTR _iMinWaterSize$[ebp], -1
	jne	SHORT $LN8@isCoastalL

; 986  : 	{
; 987  : 		iMinWaterSize = GC.getMIN_WATER_SIZE_FOR_OCEAN();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6876
	mov	DWORD PTR _iMinWaterSize$[ebp], ecx
$LN8@isCoastalL:

; 988  : 	}
; 989  : 
; 990  : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@isCoastalL
$LN6@isCoastalL:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN7@isCoastalL:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN5@isCoastalL

; 991  : 	{
; 992  : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T232644[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T232648[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232644[ebp]
	push	edx
	mov	eax, DWORD PTR $T232648[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 993  : 
; 994  : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN4@isCoastalL

; 995  : 		{
; 996  : 			if(pAdjacentPlot->isWater())

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@isCoastalL

; 997  : 			{
; 998  : 				if(iMinWaterSize <= 0)

	cmp	DWORD PTR _iMinWaterSize$[ebp], 0
	jg	SHORT $LN2@isCoastalL

; 999  : 				{
; 1000 : 					return true;

	mov	al, 1
	jmp	SHORT $LN10@isCoastalL
$LN2@isCoastalL:

; 1001 : 				}
; 1002 : 				CvLandmass* pAdjacentBodyOfWater = GC.getMap().getLandmass(pAdjacentPlot->getLandmass());

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	eax, DWORD PTR [edx+360]
	mov	DWORD PTR $T232835[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T232839[ebp], ecx
	mov	edx, DWORD PTR $T232835[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232839[ebp]
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	DWORD PTR _pAdjacentBodyOfWater$222428[ebp], eax

; 1003 : 				if(pAdjacentBodyOfWater && pAdjacentBodyOfWater->getNumTiles() >= iMinWaterSize)

	cmp	DWORD PTR _pAdjacentBodyOfWater$222428[ebp], 0
	je	SHORT $LN4@isCoastalL
	mov	ecx, DWORD PTR _pAdjacentBodyOfWater$222428[ebp]
	call	?getNumTiles@CvLandmass@@QBEHXZ		; CvLandmass::getNumTiles
	cmp	eax, DWORD PTR _iMinWaterSize$[ebp]
	jl	SHORT $LN4@isCoastalL

; 1004 : 				{
; 1005 : 					return true;

	mov	al, 1
	jmp	SHORT $LN10@isCoastalL
$LN4@isCoastalL:

; 1006 : 				}
; 1007 : 			}
; 1008 : 		}
; 1009 : 	}

	jmp	$LN6@isCoastalL
$LN5@isCoastalL:

; 1010 : 
; 1011 : 	return false;

	xor	al, al
$LN10@isCoastalL:

; 1012 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isCoastalLand@CvPlot@@QBE_NH@Z ENDP			; CvPlot::isCoastalLand
_TEXT	ENDS
PUBLIC	?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ	; CvPlot::GetSizeLargestAdjacentWater
; Function compile flags: /Odtp
;	COMDAT ?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T233043 = -112						; size = 4
$T233039 = -108						; size = 4
$T232852 = -24						; size = 4
$T232848 = -20						; size = 4
_pAdjacentBodyOfWater$222443 = -16			; size = 4
_iRtnValue$ = -12					; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ PROC	; CvPlot::GetSizeLargestAdjacentWater, COMDAT
; _this$ = ecx

; 1016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 1017 : 	CvPlot* pAdjacentPlot;
; 1018 : 	int iI;
; 1019 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 1020 : 
; 1021 : 	if(isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN7@GetSizeLar

; 1022 : 	{
; 1023 : 		return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
	jmp	$LN8@GetSizeLar
$LN7@GetSizeLar:

; 1024 : 	}
; 1025 : 
; 1026 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@GetSizeLar
$LN5@GetSizeLar:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN6@GetSizeLar:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN4@GetSizeLar

; 1027 : 	{
; 1028 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T232848[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T232852[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232848[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232852[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 1029 : 
; 1030 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN3@GetSizeLar

; 1031 : 		{
; 1032 : 			if(pAdjacentPlot->isWater())

	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@GetSizeLar

; 1033 : 			{
; 1034 : 				CvLandmass* pAdjacentBodyOfWater = GC.getMap().getLandmass(pAdjacentPlot->getLandmass());

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	mov	DWORD PTR $T233039[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233043[ebp], eax
	mov	ecx, DWORD PTR $T233039[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233043[ebp]
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	DWORD PTR _pAdjacentBodyOfWater$222443[ebp], eax

; 1035 : 				if (pAdjacentBodyOfWater && pAdjacentBodyOfWater->getNumTiles() >= iRtnValue)

	cmp	DWORD PTR _pAdjacentBodyOfWater$222443[ebp], 0
	je	SHORT $LN3@GetSizeLar
	mov	ecx, DWORD PTR _pAdjacentBodyOfWater$222443[ebp]
	call	?getNumTiles@CvLandmass@@QBEHXZ		; CvLandmass::getNumTiles
	cmp	eax, DWORD PTR _iRtnValue$[ebp]
	jl	SHORT $LN3@GetSizeLar

; 1036 : 				{
; 1037 : 					iRtnValue = pAdjacentBodyOfWater->getNumTiles();

	mov	ecx, DWORD PTR _pAdjacentBodyOfWater$222443[ebp]
	call	?getNumTiles@CvLandmass@@QBEHXZ		; CvLandmass::getNumTiles
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN3@GetSizeLar:

; 1038 : 				}
; 1039 : 			}
; 1040 : 		}
; 1041 : 	}

	jmp	$LN5@GetSizeLar
$LN4@GetSizeLar:

; 1042 : 
; 1043 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
$LN8@GetSizeLar:

; 1044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSizeLargestAdjacentWater@CvPlot@@QBEHXZ ENDP	; CvPlot::GetSizeLargestAdjacentWater
_TEXT	ENDS
PUBLIC	?isVisibleWorked@CvPlot@@QBE_NXZ		; CvPlot::isVisibleWorked
; Function compile flags: /Odtp
;	COMDAT ?isVisibleWorked@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T233070 = -16						; size = 4
$T233066 = -12						; size = 4
$T233062 = -8						; size = 4
_playerID$233054 = -4					; size = 4
?isVisibleWorked@CvPlot@@QBE_NXZ PROC			; CvPlot::isVisibleWorked, COMDAT
; _this$ = ecx

; 1048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1049 : 	if(isBeingWorked())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@isVisibleW

; 1050 : 	{
; 1051 : 		if((getTeam() == GC.getGame().getActiveTeam()) || GC.getGame().isDebugMode())

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$233054[ebp], edx
	cmp	DWORD PTR _playerID$233054[ebp], -1
	je	SHORT $LN7@isVisibleW
	mov	eax, DWORD PTR _playerID$233054[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T233062[ebp], eax
	jmp	SHORT $LN8@isVisibleW
	jmp	SHORT $LN8@isVisibleW
$LN7@isVisibleW:
	mov	DWORD PTR $T233062[ebp], -1
$LN8@isVisibleW:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233066[ebp], ecx
	mov	ecx, DWORD PTR $T233066[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR $T233062[ebp], eax
	je	SHORT $LN1@isVisibleW
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T233070[ebp], edx
	mov	ecx, DWORD PTR $T233070[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@isVisibleW
$LN1@isVisibleW:

; 1052 : 		{
; 1053 : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@isVisibleW
$LN3@isVisibleW:

; 1054 : 		}
; 1055 : 	}
; 1056 : 
; 1057 : 	return false;

	xor	al, al
$LN4@isVisibleW:

; 1058 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isVisibleWorked@CvPlot@@QBE_NXZ ENDP			; CvPlot::isVisibleWorked
_TEXT	ENDS
PUBLIC	?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isPlayerCityRadius
PUBLIC	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
; Function compile flags: /Odtp
;	COMDAT ?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T233089 = -16						; size = 4
$T233085 = -9						; size = 1
$T233076 = -8						; size = 4
_iI$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_eIgnorePlayer$ = 12					; size = 4
?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::isWithinTeamCityRadius, COMDAT
; _this$ = ecx

; 1063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1064 : 	int iI;
; 1065 : 
; 1066 : 	for(iI = 0; iI < MAX_PLAYERS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN8@isWithinTe
$LN7@isWithinTe:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN8@isWithinTe:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN6@isWithinTe

; 1067 : 	{
; 1068 : 		if(GET_PLAYER((PlayerTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233076[ebp], ecx
	mov	edx, DWORD PTR $T233076[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T233085[ebp], al
	movzx	ecx, BYTE PTR $T233085[ebp]
	test	ecx, ecx
	je	SHORT $LN5@isWithinTe

; 1069 : 		{
; 1070 : 			if(GET_PLAYER((PlayerTypes)iI).getTeam() == eTeam)

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T233089[ebp], edx
	mov	eax, DWORD PTR $T233089[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN5@isWithinTe

; 1071 : 			{
; 1072 : 				if((eIgnorePlayer == NO_PLAYER) || (((PlayerTypes)iI) != eIgnorePlayer))

	cmp	DWORD PTR _eIgnorePlayer$[ebp], -1
	je	SHORT $LN2@isWithinTe
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _eIgnorePlayer$[ebp]
	je	SHORT $LN5@isWithinTe
$LN2@isWithinTe:

; 1073 : 				{
; 1074 : 					if(isPlayerCityRadius((PlayerTypes)iI))

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isPlayerCityRadius
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@isWithinTe

; 1075 : 					{
; 1076 : 						return true;

	mov	al, 1
	jmp	SHORT $LN9@isWithinTe
$LN5@isWithinTe:

; 1077 : 					}
; 1078 : 				}
; 1079 : 			}
; 1080 : 		}
; 1081 : 	}

	jmp	$LN7@isWithinTe
$LN6@isWithinTe:

; 1082 : 
; 1083 : 	return false;

	xor	al, al
$LN9@isWithinTe:

; 1084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::isWithinTeamCityRadius
_TEXT	ENDS
PUBLIC	?isLake@CvPlot@@QBE_NXZ				; CvPlot::isLake
EXTRN	?isLake@CvLandmass@@QBE_NXZ:PROC		; CvLandmass::isLake
; Function compile flags: /Odtp
;	COMDAT ?isLake@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T233103 = -8						; size = 4
_pLandmass$ = -4					; size = 4
?isLake@CvPlot@@QBE_NXZ PROC				; CvPlot::isLake, COMDAT
; _this$ = ecx

; 1089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1090 : 	CvLandmass* pLandmass = GC.getMap().getLandmass(m_iLandmass);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233103[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+360]
	push	edx
	mov	ecx, DWORD PTR $T233103[ebp]
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	DWORD PTR _pLandmass$[ebp], eax

; 1091 : 
; 1092 : 	if(pLandmass != NULL)

	cmp	DWORD PTR _pLandmass$[ebp], 0
	je	SHORT $LN1@isLake

; 1093 : 	{
; 1094 : 		return pLandmass->isLake();

	mov	ecx, DWORD PTR _pLandmass$[ebp]
	call	?isLake@CvLandmass@@QBE_NXZ		; CvLandmass::isLake
	jmp	SHORT $LN2@isLake
$LN1@isLake:

; 1095 : 	}
; 1096 : 
; 1097 : 	return false;

	xor	al, al
$LN2@isLake:

; 1098 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isLake@CvPlot@@QBE_NXZ ENDP				; CvPlot::isLake
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
PUBLIC	?isFreshWater@CvPlot@@QBE_NXZ			; CvPlot::isFreshWater
EXTRN	?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isAddsFreshWater
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
; Function compile flags: /Odtp
;	COMDAT ?isFreshWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
_f$233263 = -101					; size = 1
$T233125 = -24						; size = 4
$T233121 = -20						; size = 4
_feature_type$222491 = -16				; size = 4
_iDY$ = -12						; size = 4
_iDX$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
?isFreshWater@CvPlot@@QBE_NXZ PROC			; CvPlot::isFreshWater, COMDAT
; _this$ = ecx

; 1104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 1105 : 	CvPlot* pLoopPlot;
; 1106 : 	int iDX, iDY;
; 1107 : 
; 1108 : 	if(isWater() || isImpassable() || isMountain())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN12@isFreshWat
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN12@isFreshWat
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN22@isFreshWat
$LN12@isFreshWat:

; 1109 : 		return false;

	xor	al, al
	jmp	$LN14@isFreshWat

; 1110 : 
; 1111 : 	if(isRiver())

$LN22@isFreshWat:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+457]
	xor	eax, eax
	test	edx, edx
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@isFreshWat

; 1112 : 	{
; 1113 : 		return true;

	mov	al, 1
	jmp	$LN14@isFreshWat
$LN11@isFreshWat:

; 1114 : 	}
; 1115 : 
; 1116 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1117 : 	int iMaxDX;
; 1118 : 	for (iDY = -1; iDY <= 1; iDY++)
; 1119 : 	{
; 1120 : 		iMaxDX = 1 - MAX(0, iDY);
; 1121 : 		for (iDX = -1 - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1122 : 		{
; 1123 : 			pLoopPlot = plotXY(getX(), getY(), iDX, iDY);
; 1124 : #else
; 1125 : 	for(iDX = -1; iDX <= 1; iDX++)

	mov	DWORD PTR _iDX$[ebp], -1
	jmp	SHORT $LN10@isFreshWat
$LN9@isFreshWat:
	mov	edx, DWORD PTR _iDX$[ebp]
	add	edx, 1
	mov	DWORD PTR _iDX$[ebp], edx
$LN10@isFreshWat:
	cmp	DWORD PTR _iDX$[ebp], 1
	jg	$LN8@isFreshWat

; 1126 : 	{
; 1127 : 		for(iDY = -1; iDY <= 1; iDY++)

	mov	DWORD PTR _iDY$[ebp], -1
	jmp	SHORT $LN7@isFreshWat
$LN6@isFreshWat:
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, 1
	mov	DWORD PTR _iDY$[ebp], eax
$LN7@isFreshWat:
	cmp	DWORD PTR _iDY$[ebp], 1
	jg	$LN5@isFreshWat

; 1128 : 		{
; 1129 : 			pLoopPlot	= plotXYWithRangeCheck(getX(), getY(), iDX, iDY, 1);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T233121[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T233125[ebp], ecx
	push	1
	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233121[ebp]
	push	ecx
	mov	edx, DWORD PTR $T233125[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 1130 : #endif
; 1131 : 
; 1132 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN4@isFreshWat

; 1133 : 			{
; 1134 : 				if(pLoopPlot->isLake())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN95@isFreshWat

; 1135 : 				{
; 1136 : 					return true;

	mov	al, 1
	jmp	SHORT $LN14@isFreshWat

; 1137 : 				}
; 1138 : 
; 1139 : 				FeatureTypes feature_type = pLoopPlot->getFeatureType();

$LN95@isFreshWat:
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$233263[ebp], dl
	movsx	eax, BYTE PTR _f$233263[ebp]
	mov	DWORD PTR _feature_type$222491[ebp], eax

; 1140 : 
; 1141 : 				if(feature_type != NO_FEATURE)

	cmp	DWORD PTR _feature_type$222491[ebp], -1
	je	SHORT $LN4@isFreshWat

; 1142 : 				{
; 1143 : 					if(GC.getFeatureInfo(feature_type)->isAddsFreshWater())

	mov	ecx, DWORD PTR _feature_type$222491[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isAddsFreshWater@CvFeatureInfo@@QBE_NXZ ; CvFeatureInfo::isAddsFreshWater
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@isFreshWat

; 1144 : 					{
; 1145 : 						return true;

	mov	al, 1
	jmp	SHORT $LN14@isFreshWat
$LN4@isFreshWat:

; 1146 : 					}
; 1147 : 				}
; 1148 : 			}
; 1149 : 		}

	jmp	$LN6@isFreshWat
$LN5@isFreshWat:

; 1150 : 	}

	jmp	$LN9@isFreshWat
$LN8@isFreshWat:

; 1151 : 
; 1152 : 	return false;

	xor	al, al
$LN14@isFreshWat:

; 1153 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isFreshWater@CvPlot@@QBE_NXZ ENDP			; CvPlot::isFreshWater
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216767 = -20					; size = 4
_iAbsDX$216766 = -16					; size = 4
_iAbsDY$216764 = -12					; size = 4
_iAbsDX$216763 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216763[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216764[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216763[ebp]
	add	edx, DWORD PTR _iAbsDY$216764[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216766[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216767[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216766[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216767[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216766[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216767[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T233521 = -56						; size = 4
$T233476 = -52						; size = 4
$T233463 = -48						; size = 4
$T233459 = -44						; size = 4
$T233445 = -40						; size = 4
$T233441 = -33						; size = 1
$T233430 = -32						; size = 4
$T233426 = -25						; size = 1
_iMapY$233489 = -24					; size = 4
_iMapX$233488 = -20					; size = 4
$T233419 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233419[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T233521[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T233419[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T233426[ebp], dl
	mov	eax, DWORD PTR $T233419[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233430[ebp], ecx
	movzx	edx, BYTE PTR $T233426[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T233430[ebp]
	add	edx, DWORD PTR $T233430[ebp]
	mov	DWORD PTR _iMapX$233488[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T233430[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T233430[ebp]
	mov	DWORD PTR _iMapX$233488[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$233488[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T233419[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T233441[ebp], al
	mov	ecx, DWORD PTR $T233419[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T233445[ebp], edx
	movzx	eax, BYTE PTR $T233441[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T233445[ebp]
	add	edx, DWORD PTR $T233445[ebp]
	mov	DWORD PTR _iMapY$233489[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T233445[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T233445[ebp]
	mov	DWORD PTR _iMapY$233489[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$233489[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$233488[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T233419[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233459[ebp], ecx
	mov	edx, DWORD PTR _iMapX$233488[ebp]
	cmp	edx, DWORD PTR $T233459[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$233489[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T233419[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T233463[ebp], ecx
	mov	edx, DWORD PTR _iMapY$233489[ebp]
	cmp	edx, DWORD PTR $T233463[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T233419[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233476[ebp], ecx
	mov	edx, DWORD PTR _iMapY$233489[ebp]
	imul	edx, DWORD PTR $T233476[ebp]
	add	edx, DWORD PTR _iMapX$233488[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T233419[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T233521[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T233521[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
PUBLIC	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
PUBLIC	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
PUBLIC	?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossingFlowClockwise
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv64 = -276						; size = 4
_this$ = -272						; size = 4
$T233894 = -188						; size = 4
$T233890 = -184						; size = 4
$T233706 = -100						; size = 4
$T233702 = -96						; size = 4
$T233531 = -12						; size = 4
$T233527 = -8						; size = 4
_pPlot$ = -4						; size = 4
_eDirection$ = 8					; size = 4
?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z PROC ; CvPlot::isRiverCrossingFlowClockwise, COMDAT
; _this$ = ecx

; 1160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	DWORD PTR _this$[ebp], ecx

; 1161 : 	CvPlot* pPlot;
; 1162 : 	switch(eDirection)

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	ja	$LN11@isRiverCro
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN255@isRiverCro[ecx*4]
$LN10@isRiverCro:

; 1163 : 	{
; 1164 : 	case DIRECTION_NORTHEAST:
; 1165 : 		pPlot = plotDirection(getX(), getY(), DIRECTION_NORTHEAST);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T233527[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T233531[ebp], edx
	push	0
	mov	eax, DWORD PTR $T233527[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233531[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pPlot$[ebp], eax

; 1166 : 		if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN9@isRiverCro

; 1167 : 		{
; 1168 : 			return (pPlot->getRiverSWFlowDirection() == FLOWDIRECTION_SOUTHEAST);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
	xor	edx, edx
	cmp	eax, 2
	sete	dl
	mov	al, dl
	jmp	$LN13@isRiverCro
$LN9@isRiverCro:

; 1169 : 		}
; 1170 : 		break;

	jmp	$LN11@isRiverCro
$LN8@isRiverCro:

; 1171 : 	case DIRECTION_EAST:
; 1172 : 		return (getRiverEFlowDirection() == FLOWDIRECTION_SOUTH);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	al, cl
	jmp	$LN13@isRiverCro

; 1173 : 		break;

	jmp	$LN11@isRiverCro
$LN7@isRiverCro:

; 1174 : 	case DIRECTION_SOUTHEAST:
; 1175 : 		return (getRiverSEFlowDirection() == FLOWDIRECTION_SOUTHWEST);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
	xor	edx, edx
	cmp	eax, 4
	sete	dl
	mov	al, dl
	jmp	$LN13@isRiverCro

; 1176 : 		break;

	jmp	$LN11@isRiverCro
$LN6@isRiverCro:

; 1177 : 	case DIRECTION_SOUTHWEST:
; 1178 : 		return (getRiverSWFlowDirection() == FLOWDIRECTION_NORTHWEST);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
	xor	ecx, ecx
	cmp	eax, 5
	sete	cl
	mov	al, cl
	jmp	$LN13@isRiverCro

; 1179 : 		break;

	jmp	$LN11@isRiverCro
$LN5@isRiverCro:

; 1180 : 	case DIRECTION_WEST:
; 1181 : 		pPlot = plotDirection(getX(), getY(), DIRECTION_WEST);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T233702[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T233706[ebp], edx
	push	4
	mov	eax, DWORD PTR $T233702[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233706[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pPlot$[ebp], eax

; 1182 : 		if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN4@isRiverCro

; 1183 : 		{
; 1184 : 			return (pPlot->getRiverEFlowDirection() == FLOWDIRECTION_NORTH);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
	neg	eax
	sbb	eax, eax
	add	eax, 1
	jmp	SHORT $LN13@isRiverCro
$LN4@isRiverCro:

; 1185 : 		}
; 1186 : 		break;

	jmp	SHORT $LN11@isRiverCro
$LN3@isRiverCro:

; 1187 : 	case DIRECTION_NORTHWEST:
; 1188 : 		pPlot = plotDirection(getX(), getY(), DIRECTION_NORTHWEST);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T233890[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T233894[ebp], edx
	push	5
	mov	eax, DWORD PTR $T233890[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233894[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pPlot$[ebp], eax

; 1189 : 		if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN11@isRiverCro

; 1190 : 		{
; 1191 : 			return (pPlot->getRiverSEFlowDirection() == FLOWDIRECTION_NORTHEAST);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	jmp	SHORT $LN13@isRiverCro
$LN11@isRiverCro:

; 1192 : 		}
; 1193 : 		break;
; 1194 : 	default:
; 1195 : 		CvAssert(false);
; 1196 : 		break;
; 1197 : 	}
; 1198 : 
; 1199 : 	return false;

	xor	al, al
$LN13@isRiverCro:

; 1200 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN255@isRiverCro:
	DD	$LN10@isRiverCro
	DD	$LN8@isRiverCro
	DD	$LN7@isRiverCro
	DD	$LN6@isRiverCro
	DD	$LN5@isRiverCro
	DD	$LN3@isRiverCro
?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z ENDP ; CvPlot::isRiverCrossingFlowClockwise
_TEXT	ENDS
PUBLIC	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
PUBLIC	?isRiverSide@CvPlot@@QBE_NXZ			; CvPlot::isRiverSide
; Function compile flags: /Odtp
;	COMDAT ?isRiverSide@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -172						; size = 4
$T234098 = -16						; size = 4
$T234094 = -12						; size = 4
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
?isRiverSide@CvPlot@@QBE_NXZ PROC			; CvPlot::isRiverSide, COMDAT
; _this$ = ecx

; 1205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	DWORD PTR _this$[ebp], ecx

; 1206 : 	CvPlot* pLoopPlot;
; 1207 : 	int iI;
; 1208 : 
; 1209 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isRiverSid
$LN4@isRiverSid:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isRiverSid:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isRiverSid

; 1210 : 	{
; 1211 : 		pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T234094[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T234098[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T234094[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234098[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 1212 : 
; 1213 : 		if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN2@isRiverSid

; 1214 : 		{
; 1215 : 			if(isRiverCrossing(directionXY(this, pLoopPlot)))

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@isRiverSid

; 1216 : 			{
; 1217 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isRiverSid
$LN2@isRiverSid:

; 1218 : 			}
; 1219 : 		}
; 1220 : 	}

	jmp	SHORT $LN4@isRiverSid
$LN3@isRiverSid:

; 1221 : 
; 1222 : 	return false;

	xor	al, al
$LN6@isRiverSid:

; 1223 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isRiverSide@CvPlot@@QBE_NXZ ENDP			; CvPlot::isRiverSide
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
$T234395 = -16						; size = 4
$T234391 = -12						; size = 4
$T234387 = -8						; size = 4
$T234383 = -4						; size = 4
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T234383[ebp], ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T234387[ebp], eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T234391[ebp], edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T234395[ebp], ecx
	mov	edx, DWORD PTR $T234383[ebp]
	push	edx
	mov	eax, DWORD PTR $T234387[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234391[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234395[ebp]
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
tv90 = -56						; size = 4
tv86 = -52						; size = 4
_iDestHexX$ = -16					; size = 4
_iWrappedXOffset$ = -12					; size = 4
_iSourceHexX$ = -8					; size = 4
_iWrappedYOffset$ = -4					; size = 4
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	cmp	DWORD PTR _iSourceY$[ebp], 0
	jl	SHORT $LN17@directionX
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN15@directionX
$LN17@directionX:
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN15@directionX:
	mov	ecx, DWORD PTR _iSourceX$[ebp]
	sub	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iSourceHexX$[ebp], ecx

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	cmp	DWORD PTR _iDestY$[ebp], 0
	jl	SHORT $LN21@directionX
	mov	edx, DWORD PTR _iDestY$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN19@directionX
$LN21@directionX:
	mov	eax, DWORD PTR _iDestY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv90[ebp], eax
$LN19@directionX:
	mov	eax, DWORD PTR _iDestX$[ebp]
	sub	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR _iDestHexX$[ebp], eax

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestHexX$[ebp]
	sub	ecx, DWORD PTR _iSourceHexX$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedXOffset$[ebp], eax

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	mov	edx, DWORD PTR _iDestY$[ebp]
	sub	edx, DWORD PTR _iSourceY$[ebp]
	push	edx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedYOffset$[ebp], eax

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jle	SHORT $LN12@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jl	SHORT $LN11@directionX

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;

	xor	eax, eax
	jmp	SHORT $LN13@directionX

; 276  : 		}
; 277  : 		else

	jmp	SHORT $LN10@directionX
$LN11@directionX:

; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;

	mov	eax, 5
	jmp	SHORT $LN13@directionX
$LN10@directionX:

; 280  : 		}

	jmp	SHORT $LN13@directionX
$LN12@directionX:

; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1
	jmp	SHORT $LN13@directionX
	jmp	SHORT $LN6@directionX
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jne	SHORT $LN5@directionX

; 289  : 		{
; 290  : 			return NO_DIRECTION;

	or	eax, -1
	jmp	SHORT $LN13@directionX

; 291  : 		}
; 292  : 		else

	jmp	SHORT $LN6@directionX
$LN5@directionX:

; 293  : 		{
; 294  : 			return DIRECTION_WEST;

	mov	eax, 4
	jmp	SHORT $LN13@directionX
$LN6@directionX:

; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)

	jmp	SHORT $LN13@directionX
$LN8@directionX:

; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN2@directionX

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;

	mov	eax, 2
	jmp	SHORT $LN13@directionX

; 302  : 		}
; 303  : 		else

	jmp	SHORT $LN13@directionX
$LN2@directionX:

; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;

	mov	eax, 3
$LN13@directionX:

; 306  : 		}
; 307  : 	}
; 308  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T234527 = -16						; size = 4
$T234519 = -12						; size = 4
$T234515 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T234515[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T234519[ebp], ecx
	movzx	edx, BYTE PTR $T234515[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T234519[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T234519[ebp]
	mov	DWORD PTR $T234527[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T234519[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T234519[ebp]
	mov	DWORD PTR $T234527[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T234527[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T234527[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T234548 = -16						; size = 4
$T234540 = -12						; size = 4
$T234536 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T234536[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T234540[ebp], ecx
	movzx	edx, BYTE PTR $T234536[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T234540[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T234540[ebp]
	mov	DWORD PTR $T234548[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T234540[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T234540[ebp]
	mov	DWORD PTR $T234548[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T234548[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T234548[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverConnection
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv168 = -32						; size = 4
tv156 = -28						; size = 4
tv144 = -24						; size = 4
tv132 = -20						; size = 4
tv88 = -16						; size = 4
tv76 = -12						; size = 4
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_eDirection$ = 8					; size = 4
?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z PROC ; CvPlot::isRiverConnection, COMDAT
; _this$ = ecx

; 1227 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1228 : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	SHORT $LN10@isRiverCon

; 1229 : 	{
; 1230 : 		return false;

	xor	al, al
	jmp	$LN11@isRiverCon
$LN10@isRiverCon:

; 1231 : 	}
; 1232 : 
; 1233 : 	switch(eDirection)

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 5
	ja	$LN8@isRiverCon
	mov	ecx, DWORD PTR tv65[ebp]
	jmp	DWORD PTR $LN25@isRiverCon[ecx*4]
$LN7@isRiverCon:

; 1234 : 	{
; 1235 : 
; 1236 : 	case DIRECTION_NORTHEAST:
; 1237 : 		return (isRiverCrossing(DIRECTION_NORTHWEST) || isRiverCrossing(DIRECTION_EAST));

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@isRiverCon
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@isRiverCon
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN14@isRiverCon
$LN13@isRiverCon:
	mov	DWORD PTR tv76[ebp], 1
$LN14@isRiverCon:
	mov	al, BYTE PTR tv76[ebp]
	jmp	$LN11@isRiverCon

; 1238 : 		break;

	jmp	$LN8@isRiverCon
$LN6@isRiverCon:

; 1239 : 
; 1240 : 	case DIRECTION_EAST:
; 1241 : 		return (isRiverCrossing(DIRECTION_NORTHEAST) || isRiverCrossing(DIRECTION_SOUTHEAST));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@isRiverCon
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN15@isRiverCon
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN16@isRiverCon
$LN15@isRiverCon:
	mov	DWORD PTR tv88[ebp], 1
$LN16@isRiverCon:
	mov	al, BYTE PTR tv88[ebp]
	jmp	$LN11@isRiverCon

; 1242 : 		break;

	jmp	$LN8@isRiverCon
$LN5@isRiverCon:

; 1243 : 
; 1244 : 	case DIRECTION_SOUTHEAST:
; 1245 : 		return (isRiverCrossing(DIRECTION_EAST) || isRiverCrossing(DIRECTION_SOUTHWEST));

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@isRiverCon
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN17@isRiverCon
	mov	DWORD PTR tv132[ebp], 0
	jmp	SHORT $LN18@isRiverCon
$LN17@isRiverCon:
	mov	DWORD PTR tv132[ebp], 1
$LN18@isRiverCon:
	mov	al, BYTE PTR tv132[ebp]
	jmp	$LN11@isRiverCon

; 1246 : 		break;

	jmp	$LN8@isRiverCon
$LN4@isRiverCon:

; 1247 : 
; 1248 : 	case DIRECTION_SOUTHWEST:
; 1249 : 		return (isRiverCrossing(DIRECTION_SOUTHEAST) || isRiverCrossing(DIRECTION_WEST));

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN19@isRiverCon
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN19@isRiverCon
	mov	DWORD PTR tv144[ebp], 0
	jmp	SHORT $LN20@isRiverCon
$LN19@isRiverCon:
	mov	DWORD PTR tv144[ebp], 1
$LN20@isRiverCon:
	mov	al, BYTE PTR tv144[ebp]
	jmp	SHORT $LN11@isRiverCon

; 1250 : 		break;

	jmp	SHORT $LN8@isRiverCon
$LN3@isRiverCon:

; 1251 : 
; 1252 : 	case DIRECTION_WEST:
; 1253 : 		return (isRiverCrossing(DIRECTION_NORTHWEST) || isRiverCrossing(DIRECTION_SOUTHWEST));

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN21@isRiverCon
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN21@isRiverCon
	mov	DWORD PTR tv156[ebp], 0
	jmp	SHORT $LN22@isRiverCon
$LN21@isRiverCon:
	mov	DWORD PTR tv156[ebp], 1
$LN22@isRiverCon:
	mov	al, BYTE PTR tv156[ebp]
	jmp	SHORT $LN11@isRiverCon

; 1254 : 		break;

	jmp	SHORT $LN8@isRiverCon
$LN2@isRiverCon:

; 1255 : 
; 1256 : 	case DIRECTION_NORTHWEST:
; 1257 : 		return (isRiverCrossing(DIRECTION_NORTHEAST) || isRiverCrossing(DIRECTION_WEST));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN23@isRiverCon
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN23@isRiverCon
	mov	DWORD PTR tv168[ebp], 0
	jmp	SHORT $LN24@isRiverCon
$LN23@isRiverCon:
	mov	DWORD PTR tv168[ebp], 1
$LN24@isRiverCon:
	mov	al, BYTE PTR tv168[ebp]
	jmp	SHORT $LN11@isRiverCon
$LN8@isRiverCon:

; 1258 : 		break;
; 1259 : 
; 1260 : 	default:
; 1261 : 		CvAssert(false);
; 1262 : 		break;
; 1263 : 	}
; 1264 : 
; 1265 : 	return false;

	xor	al, al
$LN11@isRiverCon:

; 1266 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN25@isRiverCon:
	DD	$LN7@isRiverCon
	DD	$LN6@isRiverCon
	DD	$LN5@isRiverCon
	DD	$LN4@isRiverCon
	DD	$LN3@isRiverCon
	DD	$LN2@isRiverCon
?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z ENDP ; CvPlot::isRiverConnection
_TEXT	ENDS
PUBLIC	?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z ; CvPlot::getNeighboringPlot
; Function compile flags: /Odtp
;	COMDAT ?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T234573 = -8						; size = 4
$T234569 = -4						; size = 4
_eDirection$ = 8					; size = 4
?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z PROC ; CvPlot::getNeighboringPlot, COMDAT
; _this$ = ecx

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 1271 : 	return plotDirection(getX(), getY(), eDirection);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T234569[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T234573[ebp], eax
	mov	ecx, DWORD PTR _eDirection$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234569[ebp]
	push	edx
	mov	eax, DWORD PTR $T234573[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 1272 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNeighboringPlot@CvPlot@@QBEPAV1@W4DirectionTypes@@@Z ENDP ; CvPlot::getNeighboringPlot
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z	; CvPlot::getNearestLandPlotInternal
; Function compile flags: /Odtp
;	COMDAT ?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z
_TEXT	SEGMENT
_this$ = -184						; size = 4
$T234932 = -100						; size = 4
$T234928 = -96						; size = 4
$T234924 = -92						; size = 4
$T234920 = -88						; size = 4
$T234819 = -36						; size = 4
$T234815 = -32						; size = 4
$T234811 = -28						; size = 4
$T234807 = -24						; size = 4
$T234803 = -20						; size = 4
$T234799 = -16						; size = 4
_pPlot$222557 = -12					; size = 4
_iDY$222553 = -8					; size = 4
_iDX$222549 = -4					; size = 4
_iDistance$ = 8						; size = 4
?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z PROC	; CvPlot::getNearestLandPlotInternal, COMDAT
; _this$ = ecx

; 1276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	DWORD PTR _this$[ebp], ecx

; 1277 : #ifdef AUI_WARNING_FIXES
; 1278 : 	if (uint(iDistance) > GC.getMap().getGridHeight() && uint(iDistance) > GC.getMap().getGridWidth())
; 1279 : #else
; 1280 : 	if(iDistance > GC.getMap().getGridHeight() && iDistance > GC.getMap().getGridWidth())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234799[ebp], eax
	mov	ecx, DWORD PTR $T234799[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T234803[ebp], edx
	mov	eax, DWORD PTR _iDistance$[ebp]
	cmp	eax, DWORD PTR $T234803[ebp]
	jle	SHORT $LN8@getNearest
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234807[ebp], ecx
	mov	edx, DWORD PTR $T234807[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T234811[ebp], eax
	mov	ecx, DWORD PTR _iDistance$[ebp]
	cmp	ecx, DWORD PTR $T234811[ebp]
	jle	SHORT $LN8@getNearest

; 1281 : #endif
; 1282 : 	{
; 1283 : 		return NULL;

	xor	eax, eax
	jmp	$LN9@getNearest
$LN8@getNearest:

; 1284 : 	}
; 1285 : 
; 1286 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1287 : 	int iDX, iMaxDX;
; 1288 : 	for (int iDY = -iDistance; iDY <= iDistance; iDY++)
; 1289 : 	{
; 1290 : 		iMaxDX = iDistance - MAX(0, iDY);
; 1291 : 		for (iDX = -iDistance - MIN(0, iDY); iDX <= iMaxDX; ((iDY == abs(iDistance) || iDX == iMaxDX) ? iDX++ : iDX = iMaxDX)) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1292 : #else
; 1293 : 	for(int iDX = -iDistance; iDX <= iDistance; iDX++)

	mov	edx, DWORD PTR _iDistance$[ebp]
	neg	edx
	mov	DWORD PTR _iDX$222549[ebp], edx
	jmp	SHORT $LN7@getNearest
$LN6@getNearest:
	mov	eax, DWORD PTR _iDX$222549[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$222549[ebp], eax
$LN7@getNearest:
	mov	ecx, DWORD PTR _iDX$222549[ebp]
	cmp	ecx, DWORD PTR _iDistance$[ebp]
	jg	$LN5@getNearest

; 1294 : 	{
; 1295 : 		for(int iDY = -iDistance; iDY <= iDistance; iDY++)

	mov	edx, DWORD PTR _iDistance$[ebp]
	neg	edx
	mov	DWORD PTR _iDY$222553[ebp], edx
	jmp	SHORT $LN4@getNearest
$LN3@getNearest:
	mov	eax, DWORD PTR _iDY$222553[ebp]
	add	eax, 1
	mov	DWORD PTR _iDY$222553[ebp], eax
$LN4@getNearest:
	mov	ecx, DWORD PTR _iDY$222553[ebp]
	cmp	ecx, DWORD PTR _iDistance$[ebp]
	jg	$LN2@getNearest

; 1296 : #endif
; 1297 : 		{
; 1298 : 			// bkw - revisit this, it works but is inefficient
; 1299 : 			CvPlot* pPlot = plotXY(getX(), getY(), iDX, iDY);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T234815[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T234819[ebp], edx
	mov	eax, DWORD PTR _iDY$222553[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$222549[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234815[ebp]
	push	edx
	mov	eax, DWORD PTR $T234819[ebp]
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pPlot$222557[ebp], eax

; 1300 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1301 : 			if (pPlot != NULL && !pPlot->isWater())
; 1302 : #else
; 1303 : 			if(pPlot != NULL && !pPlot->isWater() && plotDistance(getX(), getY(), pPlot->getX(), pPlot->getY()) == iDistance)

	cmp	DWORD PTR _pPlot$222557[ebp], 0
	je	SHORT $LN1@getNearest
	mov	ecx, DWORD PTR _pPlot$222557[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@getNearest
	mov	edx, DWORD PTR _pPlot$222557[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T234920[ebp], eax
	mov	ecx, DWORD PTR _pPlot$222557[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T234924[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T234928[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T234932[ebp], eax
	mov	ecx, DWORD PTR $T234920[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234924[ebp]
	push	edx
	mov	eax, DWORD PTR $T234928[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234932[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iDistance$[ebp]
	jne	SHORT $LN1@getNearest

; 1304 : #endif
; 1305 : 			{
; 1306 : 				return pPlot;

	mov	eax, DWORD PTR _pPlot$222557[ebp]
	jmp	SHORT $LN9@getNearest
$LN1@getNearest:

; 1307 : 			}
; 1308 : 		}

	jmp	$LN3@getNearest
$LN2@getNearest:

; 1309 : 	}

	jmp	$LN6@getNearest
$LN5@getNearest:

; 1310 : 	return getNearestLandPlotInternal(iDistance + 1);

	mov	edx, DWORD PTR _iDistance$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z ; CvPlot::getNearestLandPlotInternal
$LN9@getNearest:

; 1311 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z ENDP	; CvPlot::getNearestLandPlotInternal
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T235100 = -80						; size = 4
$T235074 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T235074[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T235074[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T235074[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T235100[ebp], edx
	mov	eax, DWORD PTR $T235100[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?getNearestLandPlot@CvPlot@@QBEPAV1@XZ		; CvPlot::getNearestLandPlot
PUBLIC	?getNearestLandArea@CvPlot@@QBEHXZ		; CvPlot::getNearestLandArea
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?getNearestLandArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
tv69 = -16						; size = 4
_this$ = -12						; size = 4
$T235111 = -8						; size = 4
_pPlot$ = -4						; size = 4
?getNearestLandArea@CvPlot@@QBEHXZ PROC			; CvPlot::getNearestLandArea, COMDAT
; _this$ = ecx

; 1316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1317 : 	CvPlot* pPlot = getNearestLandPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNearestLandPlot@CvPlot@@QBEPAV1@XZ	; CvPlot::getNearestLandPlot
	mov	DWORD PTR _pPlot$[ebp], eax

; 1318 : 	return pPlot ? pPlot->getArea() : -1;

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN3@getNearest@2
	mov	eax, DWORD PTR $T235111[ebp]
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN4@getNearest@2
$LN3@getNearest@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@getNearest@2:
	mov	eax, DWORD PTR tv69[ebp]

; 1319 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNearestLandArea@CvPlot@@QBEHXZ ENDP			; CvPlot::getNearestLandArea
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getNearestLandPlot@CvPlot@@QBEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNearestLandPlot@CvPlot@@QBEPAV1@XZ PROC		; CvPlot::getNearestLandPlot, COMDAT
; _this$ = ecx

; 1324 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 	return getNearestLandPlotInternal(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNearestLandPlotInternal@CvPlot@@QBEPAV1@H@Z ; CvPlot::getNearestLandPlotInternal

; 1326 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNearestLandPlot@CvPlot@@QBEPAV1@XZ ENDP		; CvPlot::getNearestLandPlot
_TEXT	ENDS
PUBLIC	?getReconCount@CvPlot@@QBEHXZ			; CvPlot::getReconCount
PUBLIC	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::seeFromLevel
EXTRN	?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ:PROC	; CvTeam::isExtraWaterSeeFrom
EXTRN	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getSeeFromLevel
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
; Function compile flags: /Odtp
;	COMDAT ?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T235148 = -28						; size = 4
$T235144 = -24						; size = 4
$T235137 = -20						; size = 4
$T235130 = -16						; size = 4
$T235123 = -12						; size = 4
$T235119 = -8						; size = 4
_iLevel$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z PROC		; CvPlot::seeFromLevel, COMDAT
; _this$ = ecx

; 1331 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1332 : 	int iLevel;
; 1333 : 
; 1334 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 1335 : 
; 1336 : 	// Plot recon-ed?
; 1337 : 	if(getReconCount() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getReconCount@CvPlot@@QBEHXZ		; CvPlot::getReconCount
	test	eax, eax
	jle	SHORT $LN6@seeFromLev

; 1338 : 	{
; 1339 : 		iLevel = GC.getRECON_VISIBILITY_RANGE() * 2;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6192
	mov	DWORD PTR $T235119[ebp], eax
	mov	ecx, DWORD PTR $T235119[ebp]
	shl	ecx, 1
	mov	DWORD PTR _iLevel$[ebp], ecx

; 1340 : 	}
; 1341 : 	// Normal visibility
; 1342 : 	else

	jmp	SHORT $LN13@seeFromLev
$LN6@seeFromLev:

; 1343 : 	{
; 1344 : 		iLevel = GC.getTerrainInfo(getTerrainType())->getSeeFromLevel();

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T235123[ebp], eax
	mov	ecx, DWORD PTR $T235123[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getSeeFromLevel
	mov	DWORD PTR _iLevel$[ebp], eax

; 1345 : 	}
; 1346 : 
; 1347 : 	if(isMountain())

$LN13@seeFromLev:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@seeFromLev

; 1348 : 	{
; 1349 : 		iLevel += GC.getMOUNTAIN_SEE_FROM_CHANGE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6208
	mov	DWORD PTR $T235130[ebp], edx
	mov	eax, DWORD PTR _iLevel$[ebp]
	add	eax, DWORD PTR $T235130[ebp]
	mov	DWORD PTR _iLevel$[ebp], eax

; 1350 : 	}
; 1351 : 
; 1352 : 	if(isHills())

$LN17@seeFromLev:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	sub	edx, 1
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN21@seeFromLev

; 1353 : 	{
; 1354 : 		iLevel += GC.getHILLS_SEE_FROM_CHANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6216
	mov	DWORD PTR $T235137[ebp], ecx
	mov	edx, DWORD PTR _iLevel$[ebp]
	add	edx, DWORD PTR $T235137[ebp]
	mov	DWORD PTR _iLevel$[ebp], edx

; 1355 : 	}
; 1356 : 
; 1357 : 	if(isWater())

$LN21@seeFromLev:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@seeFromLev

; 1358 : 	{
; 1359 : 		iLevel += GC.getSEAWATER_SEE_FROM_CHANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6224
	mov	DWORD PTR $T235144[ebp], ecx
	mov	edx, DWORD PTR _iLevel$[ebp]
	add	edx, DWORD PTR $T235144[ebp]
	mov	DWORD PTR _iLevel$[ebp], edx

; 1360 : 
; 1361 : 		if(GET_TEAM(eTeam).isExtraWaterSeeFrom())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235148[ebp], eax
	mov	ecx, DWORD PTR $T235148[ebp]
	call	?isExtraWaterSeeFrom@CvTeam@@QBE_NXZ	; CvTeam::isExtraWaterSeeFrom
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@seeFromLev

; 1362 : 		{
; 1363 : 			iLevel++;

	mov	edx, DWORD PTR _iLevel$[ebp]
	add	edx, 1
	mov	DWORD PTR _iLevel$[ebp], edx
$LN2@seeFromLev:

; 1364 : 		}
; 1365 : 	}
; 1366 : 
; 1367 : 	return iLevel;

	mov	eax, DWORD PTR _iLevel$[ebp]

; 1368 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ENDP		; CvPlot::seeFromLevel
_TEXT	ENDS
PUBLIC	?seeThroughLevel@CvPlot@@QBEH_N@Z		; CvPlot::seeThroughLevel
EXTRN	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getSeeThroughChange
EXTRN	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getSeeThroughLevel
; Function compile flags: /Odtp
;	COMDAT ?seeThroughLevel@CvPlot@@QBEH_N@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T235193 = -24						; size = 4
$T235186 = -20						; size = 4
$T235179 = -16						; size = 4
_f$235169 = -10						; size = 1
_f$235160 = -9						; size = 1
$T235154 = -8						; size = 4
_iLevel$ = -4						; size = 4
_bIncludeShubbery$ = 8					; size = 1
?seeThroughLevel@CvPlot@@QBEH_N@Z PROC			; CvPlot::seeThroughLevel, COMDAT
; _this$ = ecx

; 1373 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1374 : 	int iLevel;
; 1375 : 
; 1376 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 1377 : 
; 1378 : 	iLevel = GC.getTerrainInfo(getTerrainType())->getSeeThroughLevel();

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR $T235154[ebp], ecx
	mov	edx, DWORD PTR $T235154[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getSeeThroughLevel
	mov	DWORD PTR _iLevel$[ebp], eax

; 1379 : 
; 1380 : 	if(bIncludeShubbery && getFeatureType() != NO_FEATURE)

	movzx	eax, BYTE PTR _bIncludeShubbery$[ebp]
	test	eax, eax
	je	SHORT $LN17@seeThrough
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$235160[ebp], dl
	movsx	eax, BYTE PTR _f$235160[ebp]
	cmp	eax, -1
	je	SHORT $LN17@seeThrough

; 1381 : 	{
; 1382 : 		iLevel += GC.getFeatureInfo(getFeatureType())->getSeeThroughChange();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$235169[ebp], dl
	movsx	eax, BYTE PTR _f$235169[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	add	eax, DWORD PTR _iLevel$[ebp]
	mov	DWORD PTR _iLevel$[ebp], eax

; 1383 : 	}
; 1384 : 
; 1385 : 	if(isMountain())

$LN17@seeThrough:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN21@seeThrough

; 1386 : 	{
; 1387 : 		iLevel += GC.getMOUNTAIN_SEE_THROUGH_CHANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6212
	mov	DWORD PTR $T235179[ebp], ecx
	mov	edx, DWORD PTR _iLevel$[ebp]
	add	edx, DWORD PTR $T235179[ebp]
	mov	DWORD PTR _iLevel$[ebp], edx

; 1388 : 	}
; 1389 : 
; 1390 : 	if(isHills())

$LN21@seeThrough:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN25@seeThrough

; 1391 : 	{
; 1392 : 		iLevel += GC.getHILLS_SEE_THROUGH_CHANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6220
	mov	DWORD PTR $T235186[ebp], eax
	mov	ecx, DWORD PTR _iLevel$[ebp]
	add	ecx, DWORD PTR $T235186[ebp]
	mov	DWORD PTR _iLevel$[ebp], ecx

; 1393 : 	}
; 1394 : 
; 1395 : 	if(isWater())

$LN25@seeThrough:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@seeThrough

; 1396 : 	{
; 1397 : 		iLevel += GC.getSEAWATER_SEE_THROUGH_CHANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6228
	mov	DWORD PTR $T235193[ebp], eax
	mov	ecx, DWORD PTR _iLevel$[ebp]
	add	ecx, DWORD PTR $T235193[ebp]
	mov	DWORD PTR _iLevel$[ebp], ecx
$LN1@seeThrough:

; 1398 : 	}
; 1399 : 
; 1400 : 	return iLevel;

	mov	eax, DWORD PTR _iLevel$[ebp]

; 1401 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?seeThroughLevel@CvPlot@@QBEH_N@Z ENDP			; CvPlot::seeThroughLevel
_TEXT	ENDS
PUBLIC	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
PUBLIC	?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z ; CvPlot::changeSeeFromSight
; Function compile flags: /Odtp
;	COMDAT ?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T235203 = -16						; size = 4
$T235199 = -12						; size = 4
_pPlot$ = -8						; size = 4
_iThroughLevel$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_eDirection$ = 12					; size = 4
_iFromLevel$ = 16					; size = 4
_bIncrement$ = 20					; size = 1
_eSeeInvisible$ = 24					; size = 4
?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z PROC ; CvPlot::changeSeeFromSight, COMDAT
; _this$ = ecx

; 1406 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 1407 : 	CvPlot* pPlot;
; 1408 : 	int iThroughLevel;
; 1409 : 
; 1410 : 	iThroughLevel = seeThroughLevel();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	mov	DWORD PTR _iThroughLevel$[ebp], eax

; 1411 : 
; 1412 : 	if(iFromLevel >= iThroughLevel)

	mov	eax, DWORD PTR _iFromLevel$[ebp]
	cmp	eax, DWORD PTR _iThroughLevel$[ebp]
	jl	SHORT $LN5@changeSeeF

; 1413 : 	{
; 1414 : 		pPlot = plotDirection(getX(), getY(), eDirection);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235199[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T235203[ebp], ecx
	mov	edx, DWORD PTR _eDirection$[ebp]
	push	edx
	mov	eax, DWORD PTR $T235199[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235203[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pPlot$[ebp], eax

; 1415 : 
; 1416 : 		if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN5@changeSeeF

; 1417 : 		{
; 1418 : 			if((iFromLevel > iThroughLevel) || (pPlot->seeFromLevel(eTeam) > iFromLevel))

	mov	edx, DWORD PTR _iFromLevel$[ebp]
	cmp	edx, DWORD PTR _iThroughLevel$[ebp]
	jg	SHORT $LN1@changeSeeF
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel
	cmp	eax, DWORD PTR _iFromLevel$[ebp]
	jle	SHORT $LN5@changeSeeF
$LN1@changeSeeF:

; 1419 : 			{
; 1420 : 				pPlot->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, false);

	push	0
	push	1
	mov	ecx, DWORD PTR _eSeeInvisible$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bIncrement$[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, 2
	add	edx, -1
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN5@changeSeeF:

; 1421 : 			}
; 1422 : 		}
; 1423 : 	}
; 1424 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?changeSeeFromSight@CvPlot@@QAEXW4TeamTypes@@W4DirectionTypes@@H_NW4InvisibleTypes@@@Z ENDP ; CvPlot::changeSeeFromSight
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
PUBLIC	__real@3fa999999999999a
PUBLIC	__mask@@AbsDouble@
PUBLIC	__real@3fe0000000000000
PUBLIC	?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ; CvPlot::shouldProcessDisplacementPlot
PUBLIC	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
EXTRN	?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z:PROC ; CvGlobals::getTurnRightDirection
;	COMDAT __real@3fa999999999999a
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __mask@@AbsDouble@
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
CONST	ENDS
;	COMDAT ?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z
_TEXT	SEGMENT
tv537 = -1582						; size = 1
tv522 = -1581						; size = 1
tv511 = -1580						; size = 4
tv501 = -1573						; size = 1
tv490 = -1572						; size = 4
tv480 = -1565						; size = 1
tv469 = -1564						; size = 4
tv457 = -1557						; size = 1
tv446 = -1556						; size = 4
tv434 = -1549						; size = 1
tv419 = -1548						; size = 4
tv417 = -1544						; size = 4
tv415 = -1540						; size = 4
tv413 = -1536						; size = 4
tv404 = -1529						; size = 1
tv393 = -1528						; size = 4
tv382 = -1521						; size = 1
tv371 = -1520						; size = 4
tv93 = -1516						; size = 4
_this$ = -1512						; size = 4
$T237626 = -1432					; size = 4
$T237622 = -1428					; size = 4
$T237477 = -1364					; size = 4
$T237473 = -1360					; size = 4
$T237469 = -1356					; size = 4
$T237465 = -1352					; size = 4
$T237421 = -1304					; size = 4
$T237417 = -1300					; size = 4
$T237413 = -1296					; size = 4
$T237409 = -1292					; size = 4
$T237251 = -1208					; size = 4
$T237247 = -1204					; size = 4
$T237089 = -1120					; size = 4
$T237085 = -1116					; size = 4
$T236927 = -1032					; size = 4
$T236923 = -1028					; size = 4
$T236765 = -944						; size = 4
$T236761 = -940						; size = 4
$T236603 = -856						; size = 4
$T236599 = -852						; size = 4
$T236441 = -768						; size = 4
$T236437 = -764						; size = 4
$T236279 = -680						; size = 4
$T236275 = -676						; size = 4
$T236117 = -592						; size = 4
$T236113 = -588						; size = 4
$T235955 = -504						; size = 4
$T235951 = -500						; size = 4
$T235793 = -416						; size = 4
$T235789 = -412						; size = 4
$T235631 = -328						; size = 4
$T235627 = -324						; size = 4
$T235469 = -240						; size = 4
$T235465 = -236						; size = 4
_iHighestLevel$222714 = -232				; size = 4
_iHighestLevel$222709 = -228				; size = 4
_iHighestLevel$222704 = -224				; size = 4
_iHighestLevel$222699 = -220				; size = 4
_iHighestInwardLevel$222689 = -216			; size = 4
_iLowestInwardLevel$222690 = -212			; size = 4
_iHighestLevel$222691 = -208				; size = 4
_iHighestLowestLevel$222692 = -204			; size = 4
_iHighestLevel$222685 = -200				; size = 4
_iHighestLevel$222680 = -196				; size = 4
_fSecondDist$222678 = -192				; size = 8
_fSecondInwardX$222673 = -184				; size = 8
_c$222666 = -176					; size = 8
_fFirstDist$222672 = -168				; size = 8
_b$222665 = -160					; size = 8
_fFirstInwardY$222669 = -152				; size = 8
_fP0Y$222656 = -144					; size = 8
_fP1Y$222660 = -136					; size = 8
_fSecondInwardY$222675 = -128				; size = 8
_fFirstInwardX$222667 = -120				; size = 8
_a$222664 = -112					; size = 8
_fP0X$222654 = -104					; size = 8
_fP1X$222658 = -96					; size = 8
_pFirstInwardPlot$222626 = -88				; size = 4
_pSecondInwardPlot$222627 = -84				; size = 4
_bSecondHalfBlocked$222635 = -77			; size = 1
_iRingOfFirstInwardPlot$222630 = -76			; size = 4
_iFirstInwardLevel$222632 = -72				; size = 4
_iRingOfSecondInwardPlot$222631 = -68			; size = 4
_bFirstHalfBlocked$222634 = -61				; size = 1
_INVALID_RING$222628 = -60				; size = 4
_HALF_BLOCKED$222629 = -56				; size = 4
_iSecondInwardLevel$222633 = -52			; size = 4
_iThisPlotLevel$222652 = -48				; size = 4
_iNextDY$222720 = -44					; size = 4
_iNextDX$222719 = -40					; size = 4
_iDY$ = -36						; size = 4
_iDX$ = -32						; size = 4
_eDirectionOfNextTileToCheck$ = -28			; size = 4
_iCenterLevel$ = -24					; size = 4
_thisRing$ = -20					; size = 4
_iMaxPlotNumberOnThisRing$ = -16			; size = 4
_iPlotCounter$ = -12					; size = 4
_iRangeWithOneExtraRing$ = -8				; size = 4
_pPlotToCheck$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bIncrement$ = 16					; size = 1
_eSeeInvisible$ = 20					; size = 4
_eFacingDirection$ = 24					; size = 4
_bBasedOnUnit$ = 28					; size = 1
?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z PROC ; CvPlot::changeAdjacentSight, COMDAT
; _this$ = ecx

; 1429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1584				; 00000630H
	mov	DWORD PTR _this$[ebp], ecx

; 1430 : 	//check one extra outer ring
; 1431 : 	int iRangeWithOneExtraRing = iRange + 1;

	mov	eax, DWORD PTR _iRange$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRangeWithOneExtraRing$[ebp], eax

; 1432 : 
; 1433 : 	// start in the center going NE
; 1434 : 	int thisRing = 0;

	mov	DWORD PTR _thisRing$[ebp], 0

; 1435 : 	DirectionTypes eDirectionOfNextTileToCheck = DIRECTION_NORTHWEST;

	mov	DWORD PTR _eDirectionOfNextTileToCheck$[ebp], 5

; 1436 : 	CvPlot* pPlotToCheck = this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pPlotToCheck$[ebp], ecx

; 1437 : 	int iDX = 0;

	mov	DWORD PTR _iDX$[ebp], 0

; 1438 : 	int iDY = 0;

	mov	DWORD PTR _iDY$[ebp], 0

; 1439 : 	int iCenterLevel = seeFromLevel(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel
	mov	DWORD PTR _iCenterLevel$[ebp], eax

; 1440 : 	int iPlotCounter = 0;

	mov	DWORD PTR _iPlotCounter$[ebp], 0

; 1441 : 	int iMaxPlotNumberOnThisRing = 0;

	mov	DWORD PTR _iMaxPlotNumberOnThisRing$[ebp], 0
$LN59@changeAdja:

; 1442 : 
; 1443 : 	while(thisRing <= iRangeWithOneExtraRing)

	mov	eax, DWORD PTR _thisRing$[ebp]
	cmp	eax, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jg	$LN58@changeAdja

; 1444 : 	{
; 1445 : 		if(pPlotToCheck)

	cmp	DWORD PTR _pPlotToCheck$[ebp], 0
	je	$LN1028@changeAdja

; 1446 : 		{
; 1447 : 			//always reveal adjacent plots when using line of sight - but then clear it out
; 1448 : 			if(thisRing <= 1)

	cmp	DWORD PTR _thisRing$[ebp], 1
	jg	SHORT $LN55@changeAdja

; 1449 : 			{
; 1450 : 				if(eFacingDirection != NO_DIRECTION)

	cmp	DWORD PTR _eFacingDirection$[ebp], -1
	je	SHORT $LN55@changeAdja

; 1451 : 				{
; 1452 : 					pPlotToCheck->changeVisibilityCount(eTeam, 1, eSeeInvisible, false /*bInformExplorationTracking*/, false);

	push	0
	push	0
	mov	ecx, DWORD PTR _eSeeInvisible$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount

; 1453 : 					pPlotToCheck->changeVisibilityCount(eTeam, -1, eSeeInvisible, false /*bInformExplorationTracking*/, false);

	push	0
	push	0
	mov	eax, DWORD PTR _eSeeInvisible$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN55@changeAdja:

; 1454 : 				}
; 1455 : 			}
; 1456 : 
; 1457 : 			// see if this plot is in the visibility wedge
; 1458 : 			if(shouldProcessDisplacementPlot(iDX, iDY, iRange, eFacingDirection))

	mov	edx, DWORD PTR _eFacingDirection$[ebp]
	push	edx
	mov	eax, DWORD PTR _iRange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDX$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ; CvPlot::shouldProcessDisplacementPlot
	movzx	eax, al
	test	eax, eax
	je	$LN1028@changeAdja

; 1459 : 			{
; 1460 : 				if(thisRing != 0)

	cmp	DWORD PTR _thisRing$[ebp], 0
	je	$LN53@changeAdja

; 1461 : 				{
; 1462 : 					CvPlot* pFirstInwardPlot = NULL;

	mov	DWORD PTR _pFirstInwardPlot$222626[ebp], 0

; 1463 : 					CvPlot* pSecondInwardPlot = NULL;

	mov	DWORD PTR _pSecondInwardPlot$222627[ebp], 0

; 1464 : 					const int INVALID_RING = -1;

	mov	DWORD PTR _INVALID_RING$222628[ebp], -1

; 1465 : 					const int HALF_BLOCKED = 0x01000000;

	mov	DWORD PTR _HALF_BLOCKED$222629[ebp], 16777216 ; 01000000H

; 1466 : 					int iRingOfFirstInwardPlot = INVALID_RING;

	mov	DWORD PTR _iRingOfFirstInwardPlot$222630[ebp], -1

; 1467 : 					int iRingOfSecondInwardPlot = INVALID_RING;

	mov	DWORD PTR _iRingOfSecondInwardPlot$222631[ebp], -1

; 1468 : 					int iFirstInwardLevel = INVALID_RING;

	mov	DWORD PTR _iFirstInwardLevel$222632[ebp], -1

; 1469 : 					int iSecondInwardLevel = INVALID_RING;

	mov	DWORD PTR _iSecondInwardLevel$222633[ebp], -1

; 1470 : 					bool bFirstHalfBlocked = false;

	mov	BYTE PTR _bFirstHalfBlocked$222634[ebp], 0

; 1471 : 					bool bSecondHalfBlocked = false;

	mov	BYTE PTR _bSecondHalfBlocked$222635[ebp], 0

; 1472 : 
; 1473 : 					// try to look at the two plot inwards
; 1474 : 					switch(eDirectionOfNextTileToCheck)

	mov	ecx, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	cmp	DWORD PTR tv93[ebp], 5
	ja	$LN51@changeAdja
	mov	edx, DWORD PTR tv93[ebp]
	jmp	DWORD PTR $LN1125@changeAdja[edx*4]
$LN50@changeAdja:

; 1475 : 					{
; 1476 : 					case DIRECTION_NORTHEAST:
; 1477 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_EAST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235465[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235469[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T235465[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235469[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFirstInwardPlot$222626[ebp], eax

; 1478 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHEAST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235627[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235631[ebp], eax
	push	2
	mov	ecx, DWORD PTR $T235627[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235631[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSecondInwardPlot$222627[ebp], eax

; 1479 : 						break;

	jmp	$LN51@changeAdja
$LN49@changeAdja:

; 1480 : 					case DIRECTION_EAST:
; 1481 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHWEST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235789[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235793[ebp], eax
	push	3
	mov	ecx, DWORD PTR $T235789[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235793[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFirstInwardPlot$222626[ebp], eax

; 1482 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHEAST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T235951[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T235955[ebp], eax
	push	2
	mov	ecx, DWORD PTR $T235951[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235955[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSecondInwardPlot$222627[ebp], eax

; 1483 : 						break;

	jmp	$LN51@changeAdja
$LN48@changeAdja:

; 1484 : 					case DIRECTION_SOUTHEAST:
; 1485 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_SOUTHWEST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236113[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236117[ebp], eax
	push	3
	mov	ecx, DWORD PTR $T236113[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236117[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFirstInwardPlot$222626[ebp], eax

; 1486 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_WEST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236275[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236279[ebp], eax
	push	4
	mov	ecx, DWORD PTR $T236275[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236279[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSecondInwardPlot$222627[ebp], eax

; 1487 : 						break;

	jmp	$LN51@changeAdja
$LN47@changeAdja:

; 1488 : 					case DIRECTION_SOUTHWEST:
; 1489 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_WEST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236437[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236441[ebp], eax
	push	4
	mov	ecx, DWORD PTR $T236437[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236441[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFirstInwardPlot$222626[ebp], eax

; 1490 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHWEST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236599[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236603[ebp], eax
	push	5
	mov	ecx, DWORD PTR $T236599[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236603[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSecondInwardPlot$222627[ebp], eax

; 1491 : 						break;

	jmp	$LN51@changeAdja
$LN46@changeAdja:

; 1492 : 					case DIRECTION_WEST:
; 1493 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHWEST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236761[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236765[ebp], eax
	push	5
	mov	ecx, DWORD PTR $T236761[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236765[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFirstInwardPlot$222626[ebp], eax

; 1494 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHEAST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236923[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236927[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T236923[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236927[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSecondInwardPlot$222627[ebp], eax

; 1495 : 						break;

	jmp	SHORT $LN51@changeAdja
$LN45@changeAdja:

; 1496 : 					case DIRECTION_NORTHWEST:
; 1497 : 						pFirstInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_EAST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237085[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T237089[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T237085[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237089[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pFirstInwardPlot$222626[ebp], eax

; 1498 : 						pSecondInwardPlot = plotDirection(pPlotToCheck->getX(),pPlotToCheck->getY(),DIRECTION_NORTHEAST);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237247[ebp], ecx
	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T237251[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T237247[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237251[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pSecondInwardPlot$222627[ebp], eax
$LN51@changeAdja:

; 1499 : 						break;
; 1500 : 					}
; 1501 : 					if(pFirstInwardPlot)

	cmp	DWORD PTR _pFirstInwardPlot$222626[ebp], 0
	je	$LN42@changeAdja

; 1502 : 					{
; 1503 : 						iRingOfFirstInwardPlot = plotDistance(getX(),getY(),pFirstInwardPlot->getX(),pFirstInwardPlot->getY());

	mov	eax, DWORD PTR _pFirstInwardPlot$222626[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237409[ebp], ecx
	mov	edx, DWORD PTR _pFirstInwardPlot$222626[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T237413[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T237417[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T237421[ebp], ecx
	mov	edx, DWORD PTR $T237409[ebp]
	push	edx
	mov	eax, DWORD PTR $T237413[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237417[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237421[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRingOfFirstInwardPlot$222630[ebp], eax

; 1504 : 						if(iRingOfFirstInwardPlot == thisRing - 1)

	mov	eax, DWORD PTR _thisRing$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _iRingOfFirstInwardPlot$222630[ebp], eax
	jne	SHORT $LN42@changeAdja

; 1505 : 						{
; 1506 : 							iFirstInwardLevel = pFirstInwardPlot->getScratchPad();

	mov	ecx, DWORD PTR _pFirstInwardPlot$222626[ebp]
	mov	edx, DWORD PTR [ecx+364]
	mov	DWORD PTR _iFirstInwardLevel$222632[ebp], edx

; 1507 : 							if(iFirstInwardLevel >= HALF_BLOCKED)

	cmp	DWORD PTR _iFirstInwardLevel$222632[ebp], 16777216 ; 01000000H
	jl	SHORT $LN42@changeAdja

; 1508 : 							{
; 1509 : 								iFirstInwardLevel -= HALF_BLOCKED;

	mov	eax, DWORD PTR _iFirstInwardLevel$222632[ebp]
	sub	eax, 16777216				; 01000000H
	mov	DWORD PTR _iFirstInwardLevel$222632[ebp], eax

; 1510 : 								bFirstHalfBlocked = true;

	mov	BYTE PTR _bFirstHalfBlocked$222634[ebp], 1
$LN42@changeAdja:

; 1511 : 							}
; 1512 : 						}
; 1513 : 					}
; 1514 : 					if(pSecondInwardPlot)

	cmp	DWORD PTR _pSecondInwardPlot$222627[ebp], 0
	je	$LN39@changeAdja

; 1515 : 					{
; 1516 : 						iRingOfSecondInwardPlot = plotDistance(getX(),getY(),pSecondInwardPlot->getX(),pSecondInwardPlot->getY());

	mov	ecx, DWORD PTR _pSecondInwardPlot$222627[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T237465[ebp], edx
	mov	eax, DWORD PTR _pSecondInwardPlot$222627[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T237469[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T237473[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T237477[ebp], edx
	mov	eax, DWORD PTR $T237465[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237469[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237473[ebp]
	push	edx
	mov	eax, DWORD PTR $T237477[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRingOfSecondInwardPlot$222631[ebp], eax

; 1517 : 						if(iRingOfSecondInwardPlot == thisRing - 1)

	mov	ecx, DWORD PTR _thisRing$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _iRingOfSecondInwardPlot$222631[ebp], ecx
	jne	SHORT $LN39@changeAdja

; 1518 : 						{
; 1519 : 							iSecondInwardLevel = pSecondInwardPlot->getScratchPad();

	mov	edx, DWORD PTR _pSecondInwardPlot$222627[ebp]
	mov	eax, DWORD PTR [edx+364]
	mov	DWORD PTR _iSecondInwardLevel$222633[ebp], eax

; 1520 : 							if(iSecondInwardLevel >= HALF_BLOCKED)

	cmp	DWORD PTR _iSecondInwardLevel$222633[ebp], 16777216 ; 01000000H
	jl	SHORT $LN39@changeAdja

; 1521 : 							{
; 1522 : 								iSecondInwardLevel -= HALF_BLOCKED;

	mov	ecx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	sub	ecx, 16777216				; 01000000H
	mov	DWORD PTR _iSecondInwardLevel$222633[ebp], ecx

; 1523 : 								bSecondHalfBlocked = true;

	mov	BYTE PTR _bSecondHalfBlocked$222635[ebp], 1
$LN39@changeAdja:

; 1524 : 							}
; 1525 : 						}
; 1526 : 					}
; 1527 : 					int iThisPlotLevel = pPlotToCheck->seeThroughLevel(thisRing != iRangeWithOneExtraRing);

	mov	edx, DWORD PTR _thisRing$[ebp]
	cmp	edx, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	setne	al
	movzx	ecx, al
	push	ecx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?seeThroughLevel@CvPlot@@QBEH_N@Z	; CvPlot::seeThroughLevel
	mov	DWORD PTR _iThisPlotLevel$222652[ebp], eax

; 1528 : 					if(iFirstInwardLevel != INVALID_RING && iSecondInwardLevel != INVALID_RING && iFirstInwardLevel != iSecondInwardLevel && !bFirstHalfBlocked && !bSecondHalfBlocked)

	cmp	DWORD PTR _iFirstInwardLevel$222632[ebp], -1
	je	$LN38@changeAdja
	cmp	DWORD PTR _iSecondInwardLevel$222633[ebp], -1
	je	$LN38@changeAdja
	mov	edx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	edx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	je	$LN38@changeAdja
	movzx	eax, BYTE PTR _bFirstHalfBlocked$222634[ebp]
	test	eax, eax
	jne	$LN38@changeAdja
	movzx	ecx, BYTE PTR _bSecondHalfBlocked$222635[ebp]
	test	ecx, ecx
	jne	$LN38@changeAdja

; 1529 : 					{
; 1530 : 						double fP0X = (double) getX();

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	cvtsi2sd xmm0, eax
	movsd	QWORD PTR _fP0X$222654[ebp], xmm0

; 1531 : 						double fP0Y = (double) getY();

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _fP0Y$222656[ebp], xmm0

; 1532 : 						double fP1X = (double) pPlotToCheck->getX();

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax]
	cvtsi2sd xmm0, ecx
	movsd	QWORD PTR _fP1X$222658[ebp], xmm0

; 1533 : 						double fP1Y = (double) pPlotToCheck->getY();

	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	movsx	eax, WORD PTR [edx+2]
	cvtsi2sd xmm0, eax
	movsd	QWORD PTR _fP1Y$222660[ebp], xmm0

; 1534 : 						if(getY() & 1)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	and	edx, 1
	je	SHORT $LN37@changeAdja

; 1535 : 						{
; 1536 : 							fP0X += 0.5;

	movsd	xmm0, QWORD PTR _fP0X$222654[ebp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _fP0X$222654[ebp], xmm0
$LN37@changeAdja:

; 1537 : 						}
; 1538 : 						if(pPlotToCheck->getY() & 1)

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	and	ecx, 1
	je	SHORT $LN36@changeAdja

; 1539 : 						{
; 1540 : 							fP1X += 0.5;

	movsd	xmm0, QWORD PTR _fP1X$222658[ebp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _fP1X$222658[ebp], xmm0
$LN36@changeAdja:

; 1541 : 						}
; 1542 : 
; 1543 : 						double a = fP1Y - fP0Y;

	movsd	xmm0, QWORD PTR _fP1Y$222660[ebp]
	subsd	xmm0, QWORD PTR _fP0Y$222656[ebp]
	movsd	QWORD PTR _a$222664[ebp], xmm0

; 1544 : 						double b = fP0X - fP1X;

	movsd	xmm0, QWORD PTR _fP0X$222654[ebp]
	subsd	xmm0, QWORD PTR _fP1X$222658[ebp]
	movsd	QWORD PTR _b$222665[ebp], xmm0

; 1545 : 						double c = fP0Y * fP1X - fP1Y * fP0X;

	movsd	xmm0, QWORD PTR _fP0Y$222656[ebp]
	mulsd	xmm0, QWORD PTR _fP1X$222658[ebp]
	movsd	xmm1, QWORD PTR _fP1Y$222660[ebp]
	mulsd	xmm1, QWORD PTR _fP0X$222654[ebp]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _c$222666[ebp], xmm0

; 1546 : 
; 1547 : 						double fFirstInwardX = (double) pFirstInwardPlot->getX();

	mov	edx, DWORD PTR _pFirstInwardPlot$222626[ebp]
	movsx	eax, WORD PTR [edx]
	cvtsi2sd xmm0, eax
	movsd	QWORD PTR _fFirstInwardX$222667[ebp], xmm0

; 1548 : 						double fFirstInwardY = (double) pFirstInwardPlot->getY();

	mov	ecx, DWORD PTR _pFirstInwardPlot$222626[ebp]
	movsx	edx, WORD PTR [ecx+2]
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _fFirstInwardY$222669[ebp], xmm0

; 1549 : 						if(pFirstInwardPlot->getY() & 1)

	mov	eax, DWORD PTR _pFirstInwardPlot$222626[ebp]
	movsx	ecx, WORD PTR [eax+2]
	and	ecx, 1
	je	SHORT $LN35@changeAdja

; 1550 : 						{
; 1551 : 							fFirstInwardX += 0.5;

	movsd	xmm0, QWORD PTR _fFirstInwardX$222667[ebp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _fFirstInwardX$222667[ebp], xmm0
$LN35@changeAdja:

; 1552 : 						}
; 1553 : 						double fFirstDist = a * fFirstInwardX + b * fFirstInwardY + c;

	movsd	xmm0, QWORD PTR _a$222664[ebp]
	mulsd	xmm0, QWORD PTR _fFirstInwardX$222667[ebp]
	movsd	xmm1, QWORD PTR _b$222665[ebp]
	mulsd	xmm1, QWORD PTR _fFirstInwardY$222669[ebp]
	addsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR _c$222666[ebp]
	movsd	QWORD PTR _fFirstDist$222672[ebp], xmm0

; 1554 : 						fFirstDist = abs(fFirstDist);

	movsd	xmm0, QWORD PTR _fFirstDist$222672[ebp]
	andpd	xmm0, QWORD PTR __mask@@AbsDouble@
	movsd	QWORD PTR _fFirstDist$222672[ebp], xmm0

; 1555 : 						// skip the extra distance since it is the same for both equations
; 1556 : 
; 1557 : 						double fSecondInwardX = (double) pSecondInwardPlot->getX();

	mov	edx, DWORD PTR _pSecondInwardPlot$222627[ebp]
	movsx	eax, WORD PTR [edx]
	cvtsi2sd xmm0, eax
	movsd	QWORD PTR _fSecondInwardX$222673[ebp], xmm0

; 1558 : 						double fSecondInwardY = (double) pSecondInwardPlot->getY();

	mov	ecx, DWORD PTR _pSecondInwardPlot$222627[ebp]
	movsx	edx, WORD PTR [ecx+2]
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _fSecondInwardY$222675[ebp], xmm0

; 1559 : 						if(pSecondInwardPlot->getY() & 1)

	mov	eax, DWORD PTR _pSecondInwardPlot$222627[ebp]
	movsx	ecx, WORD PTR [eax+2]
	and	ecx, 1
	je	SHORT $LN34@changeAdja

; 1560 : 						{
; 1561 : 							fSecondInwardX += 0.5;

	movsd	xmm0, QWORD PTR _fSecondInwardX$222673[ebp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _fSecondInwardX$222673[ebp], xmm0
$LN34@changeAdja:

; 1562 : 						}
; 1563 : 						double fSecondDist = a * fSecondInwardX + b * fSecondInwardY + c;

	movsd	xmm0, QWORD PTR _a$222664[ebp]
	mulsd	xmm0, QWORD PTR _fSecondInwardX$222673[ebp]
	movsd	xmm1, QWORD PTR _b$222665[ebp]
	mulsd	xmm1, QWORD PTR _fSecondInwardY$222675[ebp]
	addsd	xmm0, xmm1
	addsd	xmm0, QWORD PTR _c$222666[ebp]
	movsd	QWORD PTR _fSecondDist$222678[ebp], xmm0

; 1564 : 						fSecondDist = abs(fSecondDist);

	movsd	xmm0, QWORD PTR _fSecondDist$222678[ebp]
	andpd	xmm0, QWORD PTR __mask@@AbsDouble@
	movsd	QWORD PTR _fSecondDist$222678[ebp], xmm0

; 1565 : 						// skip the extra distance since it is the same for both equations
; 1566 : 
; 1567 : 						if(fFirstDist - fSecondDist > 0.05)  // we are closer to the second point

	movsd	xmm0, QWORD PTR _fFirstDist$222672[ebp]
	subsd	xmm0, QWORD PTR _fSecondDist$222678[ebp]
	comisd	xmm0, QWORD PTR __real@3fa999999999999a
	jbe	$LN33@changeAdja

; 1568 : 						{
; 1569 : 							int iHighestLevel = (iSecondInwardLevel > iThisPlotLevel) ? iSecondInwardLevel : iThisPlotLevel;

	mov	edx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	cmp	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN62@changeAdja
	mov	eax, DWORD PTR _iSecondInwardLevel$222633[ebp]
	mov	DWORD PTR tv371[ebp], eax
	jmp	SHORT $LN63@changeAdja
$LN62@changeAdja:
	mov	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv371[ebp], ecx
$LN63@changeAdja:
	mov	edx, DWORD PTR tv371[ebp]
	mov	DWORD PTR _iHighestLevel$222680[ebp], edx

; 1570 : 							pPlotToCheck->setScratchPad(iHighestLevel);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	mov	ecx, DWORD PTR _iHighestLevel$222680[ebp]
	mov	DWORD PTR [eax+364], ecx

; 1571 : 							if(iSecondInwardLevel < iThisPlotLevel || ((iCenterLevel >= iSecondInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	mov	edx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	cmp	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jl	SHORT $LN31@changeAdja
	mov	eax, DWORD PTR _iCenterLevel$[ebp]
	cmp	eax, DWORD PTR _iSecondInwardLevel$222633[ebp]
	jl	SHORT $LN32@changeAdja
	mov	ecx, DWORD PTR _thisRing$[ebp]
	cmp	ecx, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jge	SHORT $LN32@changeAdja
$LN31@changeAdja:

; 1572 : 							{								
; 1573 : 								pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	edx, BYTE PTR _bBasedOnUnit$[ebp]
	test	edx, edx
	je	SHORT $LN64@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN64@changeAdja
	mov	BYTE PTR tv382[ebp], 1
	jmp	SHORT $LN65@changeAdja
$LN64@changeAdja:
	mov	BYTE PTR tv382[ebp], 0
$LN65@changeAdja:
	movzx	eax, BYTE PTR tv382[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _eSeeInvisible$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bIncrement$[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, 2
	add	edx, -1
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN32@changeAdja:

; 1574 : 							}
; 1575 : 						}

	jmp	$LN23@changeAdja
$LN33@changeAdja:

; 1576 : 						else if(fSecondDist - fFirstDist > 0.05)   // we are closer to the first point

	movsd	xmm0, QWORD PTR _fSecondDist$222678[ebp]
	subsd	xmm0, QWORD PTR _fFirstDist$222672[ebp]
	comisd	xmm0, QWORD PTR __real@3fa999999999999a
	jbe	$LN29@changeAdja

; 1577 : 						{
; 1578 : 							int iHighestLevel = (iFirstInwardLevel > iThisPlotLevel) ? iFirstInwardLevel : iThisPlotLevel;

	mov	ecx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN66@changeAdja
	mov	edx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	mov	DWORD PTR tv393[ebp], edx
	jmp	SHORT $LN67@changeAdja
$LN66@changeAdja:
	mov	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv393[ebp], eax
$LN67@changeAdja:
	mov	ecx, DWORD PTR tv393[ebp]
	mov	DWORD PTR _iHighestLevel$222685[ebp], ecx

; 1579 : 							pPlotToCheck->setScratchPad(iHighestLevel);

	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	mov	eax, DWORD PTR _iHighestLevel$222685[ebp]
	mov	DWORD PTR [edx+364], eax

; 1580 : 							if(iFirstInwardLevel < iThisPlotLevel || ((iCenterLevel >= iFirstInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	mov	ecx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jl	SHORT $LN27@changeAdja
	mov	edx, DWORD PTR _iCenterLevel$[ebp]
	cmp	edx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	jl	SHORT $LN28@changeAdja
	mov	eax, DWORD PTR _thisRing$[ebp]
	cmp	eax, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jge	SHORT $LN28@changeAdja
$LN27@changeAdja:

; 1581 : 							{								
; 1582 : 								pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	ecx, BYTE PTR _bBasedOnUnit$[ebp]
	test	ecx, ecx
	je	SHORT $LN68@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN68@changeAdja
	mov	BYTE PTR tv404[ebp], 1
	jmp	SHORT $LN69@changeAdja
$LN68@changeAdja:
	mov	BYTE PTR tv404[ebp], 0
$LN69@changeAdja:
	movzx	edx, BYTE PTR tv404[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _eSeeInvisible$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bIncrement$[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, 2
	add	ecx, -1
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN28@changeAdja:

; 1583 : 							}
; 1584 : 						}
; 1585 : 						else

	jmp	$LN23@changeAdja
$LN29@changeAdja:

; 1586 : 						{
; 1587 : 							int iHighestInwardLevel = (iFirstInwardLevel > iSecondInwardLevel) ? iFirstInwardLevel : iSecondInwardLevel;

	mov	eax, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	eax, DWORD PTR _iSecondInwardLevel$222633[ebp]
	jle	SHORT $LN70@changeAdja
	mov	ecx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	mov	DWORD PTR tv413[ebp], ecx
	jmp	SHORT $LN71@changeAdja
$LN70@changeAdja:
	mov	edx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	mov	DWORD PTR tv413[ebp], edx
$LN71@changeAdja:
	mov	eax, DWORD PTR tv413[ebp]
	mov	DWORD PTR _iHighestInwardLevel$222689[ebp], eax

; 1588 : 							int iLowestInwardLevel = (iFirstInwardLevel > iSecondInwardLevel) ? iSecondInwardLevel : iFirstInwardLevel;

	mov	ecx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	ecx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	jle	SHORT $LN72@changeAdja
	mov	edx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	mov	DWORD PTR tv415[ebp], edx
	jmp	SHORT $LN73@changeAdja
$LN72@changeAdja:
	mov	eax, DWORD PTR _iFirstInwardLevel$222632[ebp]
	mov	DWORD PTR tv415[ebp], eax
$LN73@changeAdja:
	mov	ecx, DWORD PTR tv415[ebp]
	mov	DWORD PTR _iLowestInwardLevel$222690[ebp], ecx

; 1589 : 							int iHighestLevel = (iHighestInwardLevel > iThisPlotLevel) ? iHighestInwardLevel : iThisPlotLevel;

	mov	edx, DWORD PTR _iHighestInwardLevel$222689[ebp]
	cmp	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN74@changeAdja
	mov	eax, DWORD PTR _iHighestInwardLevel$222689[ebp]
	mov	DWORD PTR tv417[ebp], eax
	jmp	SHORT $LN75@changeAdja
$LN74@changeAdja:
	mov	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv417[ebp], ecx
$LN75@changeAdja:
	mov	edx, DWORD PTR tv417[ebp]
	mov	DWORD PTR _iHighestLevel$222691[ebp], edx

; 1590 : 							int iHighestLowestLevel = (iLowestInwardLevel > iThisPlotLevel) ? iLowestInwardLevel : iThisPlotLevel;

	mov	eax, DWORD PTR _iLowestInwardLevel$222690[ebp]
	cmp	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN76@changeAdja
	mov	ecx, DWORD PTR _iLowestInwardLevel$222690[ebp]
	mov	DWORD PTR tv419[ebp], ecx
	jmp	SHORT $LN77@changeAdja
$LN76@changeAdja:
	mov	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv419[ebp], edx
$LN77@changeAdja:
	mov	eax, DWORD PTR tv419[ebp]
	mov	DWORD PTR _iHighestLowestLevel$222692[ebp], eax

; 1591 : 							if(iHighestInwardLevel > iThisPlotLevel)

	mov	ecx, DWORD PTR _iHighestInwardLevel$222689[ebp]
	cmp	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN25@changeAdja

; 1592 : 							{
; 1593 : 								pPlotToCheck->setScratchPad(iHighestLowestLevel + HALF_BLOCKED);

	mov	edx, DWORD PTR _iHighestLowestLevel$222692[ebp]
	add	edx, 16777216				; 01000000H
	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	mov	DWORD PTR [eax+364], edx

; 1594 : 							}
; 1595 : 							else

	jmp	SHORT $LN1016@changeAdja
$LN25@changeAdja:

; 1596 : 							{
; 1597 : 								pPlotToCheck->setScratchPad(iHighestLevel);

	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	mov	edx, DWORD PTR _iHighestLevel$222691[ebp]
	mov	DWORD PTR [ecx+364], edx
$LN1016@changeAdja:

; 1598 : 							}
; 1599 : 							if(iLowestInwardLevel < iThisPlotLevel || ((iCenterLevel >= iLowestInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	mov	eax, DWORD PTR _iLowestInwardLevel$222690[ebp]
	cmp	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	jl	SHORT $LN22@changeAdja
	mov	ecx, DWORD PTR _iCenterLevel$[ebp]
	cmp	ecx, DWORD PTR _iLowestInwardLevel$222690[ebp]
	jl	SHORT $LN23@changeAdja
	mov	edx, DWORD PTR _thisRing$[ebp]
	cmp	edx, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jge	SHORT $LN23@changeAdja
$LN22@changeAdja:

; 1600 : 							{								
; 1601 : 								pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	eax, BYTE PTR _bBasedOnUnit$[ebp]
	test	eax, eax
	je	SHORT $LN78@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN78@changeAdja
	mov	BYTE PTR tv434[ebp], 1
	jmp	SHORT $LN79@changeAdja
$LN78@changeAdja:
	mov	BYTE PTR tv434[ebp], 0
$LN79@changeAdja:
	movzx	ecx, BYTE PTR tv434[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _eSeeInvisible$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bIncrement$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN23@changeAdja:

; 1602 : 							}
; 1603 : 						}

	jmp	$LN1026@changeAdja
$LN38@changeAdja:

; 1604 : 					}
; 1605 : 					else if(iFirstInwardLevel != INVALID_RING && !bFirstHalfBlocked)

	cmp	DWORD PTR _iFirstInwardLevel$222632[ebp], -1
	je	$LN20@changeAdja
	movzx	edx, BYTE PTR _bFirstHalfBlocked$222634[ebp]
	test	edx, edx
	jne	$LN20@changeAdja

; 1606 : 					{
; 1607 : 						int iHighestLevel = (iFirstInwardLevel > iThisPlotLevel) ? iFirstInwardLevel : iThisPlotLevel;

	mov	eax, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN80@changeAdja
	mov	ecx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	mov	DWORD PTR tv446[ebp], ecx
	jmp	SHORT $LN81@changeAdja
$LN80@changeAdja:
	mov	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv446[ebp], edx
$LN81@changeAdja:
	mov	eax, DWORD PTR tv446[ebp]
	mov	DWORD PTR _iHighestLevel$222699[ebp], eax

; 1608 : 						pPlotToCheck->setScratchPad(iHighestLevel);

	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	mov	edx, DWORD PTR _iHighestLevel$222699[ebp]
	mov	DWORD PTR [ecx+364], edx

; 1609 : 						if(iFirstInwardLevel < iThisPlotLevel || ((iCenterLevel >= iFirstInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	mov	eax, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	jl	SHORT $LN18@changeAdja
	mov	ecx, DWORD PTR _iCenterLevel$[ebp]
	cmp	ecx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	jl	SHORT $LN19@changeAdja
	mov	edx, DWORD PTR _thisRing$[ebp]
	cmp	edx, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jge	SHORT $LN19@changeAdja
$LN18@changeAdja:

; 1610 : 						{							
; 1611 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	eax, BYTE PTR _bBasedOnUnit$[ebp]
	test	eax, eax
	je	SHORT $LN82@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN82@changeAdja
	mov	BYTE PTR tv457[ebp], 1
	jmp	SHORT $LN83@changeAdja
$LN82@changeAdja:
	mov	BYTE PTR tv457[ebp], 0
$LN83@changeAdja:
	movzx	ecx, BYTE PTR tv457[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _eSeeInvisible$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bIncrement$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN19@changeAdja:

; 1612 : 						}
; 1613 : 					}

	jmp	$LN1026@changeAdja
$LN20@changeAdja:

; 1614 : 					else if(iSecondInwardLevel != INVALID_RING && !bSecondHalfBlocked)

	cmp	DWORD PTR _iSecondInwardLevel$222633[ebp], -1
	je	$LN16@changeAdja
	movzx	edx, BYTE PTR _bSecondHalfBlocked$222635[ebp]
	test	edx, edx
	jne	$LN16@changeAdja

; 1615 : 					{
; 1616 : 						int iHighestLevel = (iSecondInwardLevel > iThisPlotLevel) ? iSecondInwardLevel : iThisPlotLevel;

	mov	eax, DWORD PTR _iSecondInwardLevel$222633[ebp]
	cmp	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN84@changeAdja
	mov	ecx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	mov	DWORD PTR tv469[ebp], ecx
	jmp	SHORT $LN85@changeAdja
$LN84@changeAdja:
	mov	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv469[ebp], edx
$LN85@changeAdja:
	mov	eax, DWORD PTR tv469[ebp]
	mov	DWORD PTR _iHighestLevel$222704[ebp], eax

; 1617 : 						pPlotToCheck->setScratchPad(iHighestLevel);

	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	mov	edx, DWORD PTR _iHighestLevel$222704[ebp]
	mov	DWORD PTR [ecx+364], edx

; 1618 : 						if(iSecondInwardLevel < iThisPlotLevel || ((iCenterLevel >= iSecondInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	mov	eax, DWORD PTR _iSecondInwardLevel$222633[ebp]
	cmp	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	jl	SHORT $LN14@changeAdja
	mov	ecx, DWORD PTR _iCenterLevel$[ebp]
	cmp	ecx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	jl	SHORT $LN15@changeAdja
	mov	edx, DWORD PTR _thisRing$[ebp]
	cmp	edx, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jge	SHORT $LN15@changeAdja
$LN14@changeAdja:

; 1619 : 						{							
; 1620 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	eax, BYTE PTR _bBasedOnUnit$[ebp]
	test	eax, eax
	je	SHORT $LN86@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN86@changeAdja
	mov	BYTE PTR tv480[ebp], 1
	jmp	SHORT $LN87@changeAdja
$LN86@changeAdja:
	mov	BYTE PTR tv480[ebp], 0
$LN87@changeAdja:
	movzx	ecx, BYTE PTR tv480[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _eSeeInvisible$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bIncrement$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN15@changeAdja:

; 1621 : 						}
; 1622 : 					}

	jmp	$LN1026@changeAdja
$LN16@changeAdja:

; 1623 : 					else if(iFirstInwardLevel != INVALID_RING)

	cmp	DWORD PTR _iFirstInwardLevel$222632[ebp], -1
	je	$LN12@changeAdja

; 1624 : 					{
; 1625 : 						int iHighestLevel = (iFirstInwardLevel > iThisPlotLevel) ? iFirstInwardLevel : iThisPlotLevel;

	mov	edx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN88@changeAdja
	mov	eax, DWORD PTR _iFirstInwardLevel$222632[ebp]
	mov	DWORD PTR tv490[ebp], eax
	jmp	SHORT $LN89@changeAdja
$LN88@changeAdja:
	mov	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv490[ebp], ecx
$LN89@changeAdja:
	mov	edx, DWORD PTR tv490[ebp]
	mov	DWORD PTR _iHighestLevel$222709[ebp], edx

; 1626 : 						pPlotToCheck->setScratchPad(iHighestLevel);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	mov	ecx, DWORD PTR _iHighestLevel$222709[ebp]
	mov	DWORD PTR [eax+364], ecx

; 1627 : 						if(iFirstInwardLevel < iThisPlotLevel || ((iCenterLevel >= iFirstInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	mov	edx, DWORD PTR _iFirstInwardLevel$222632[ebp]
	cmp	edx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jl	SHORT $LN10@changeAdja
	mov	eax, DWORD PTR _iCenterLevel$[ebp]
	cmp	eax, DWORD PTR _iFirstInwardLevel$222632[ebp]
	jl	SHORT $LN11@changeAdja
	mov	ecx, DWORD PTR _thisRing$[ebp]
	cmp	ecx, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jge	SHORT $LN11@changeAdja
$LN10@changeAdja:

; 1628 : 						{
; 1629 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	edx, BYTE PTR _bBasedOnUnit$[ebp]
	test	edx, edx
	je	SHORT $LN90@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN90@changeAdja
	mov	BYTE PTR tv501[ebp], 1
	jmp	SHORT $LN91@changeAdja
$LN90@changeAdja:
	mov	BYTE PTR tv501[ebp], 0
$LN91@changeAdja:
	movzx	eax, BYTE PTR tv501[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _eSeeInvisible$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bIncrement$[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, 2
	add	edx, -1
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN11@changeAdja:

; 1630 : 						}
; 1631 : 					}

	jmp	$LN1026@changeAdja
$LN12@changeAdja:

; 1632 : 					else if(iSecondInwardLevel != INVALID_RING)

	cmp	DWORD PTR _iSecondInwardLevel$222633[ebp], -1
	je	$LN8@changeAdja

; 1633 : 					{
; 1634 : 						int iHighestLevel = (iSecondInwardLevel > iThisPlotLevel) ? iSecondInwardLevel : iThisPlotLevel;

	mov	ecx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	cmp	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jle	SHORT $LN92@changeAdja
	mov	edx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	mov	DWORD PTR tv511[ebp], edx
	jmp	SHORT $LN93@changeAdja
$LN92@changeAdja:
	mov	eax, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR tv511[ebp], eax
$LN93@changeAdja:
	mov	ecx, DWORD PTR tv511[ebp]
	mov	DWORD PTR _iHighestLevel$222714[ebp], ecx

; 1635 : 						pPlotToCheck->setScratchPad(iHighestLevel);

	mov	edx, DWORD PTR _pPlotToCheck$[ebp]
	mov	eax, DWORD PTR _iHighestLevel$222714[ebp]
	mov	DWORD PTR [edx+364], eax

; 1636 : 						if(iSecondInwardLevel < iThisPlotLevel || ((iCenterLevel >= iSecondInwardLevel) && (thisRing < iRangeWithOneExtraRing)))

	mov	ecx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	cmp	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	jl	SHORT $LN6@changeAdja
	mov	edx, DWORD PTR _iCenterLevel$[ebp]
	cmp	edx, DWORD PTR _iSecondInwardLevel$222633[ebp]
	jl	SHORT $LN7@changeAdja
	mov	eax, DWORD PTR _thisRing$[ebp]
	cmp	eax, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	jge	SHORT $LN7@changeAdja
$LN6@changeAdja:

; 1637 : 						{							
; 1638 : 							pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	ecx, BYTE PTR _bBasedOnUnit$[ebp]
	test	ecx, ecx
	je	SHORT $LN94@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN94@changeAdja
	mov	BYTE PTR tv522[ebp], 1
	jmp	SHORT $LN95@changeAdja
$LN94@changeAdja:
	mov	BYTE PTR tv522[ebp], 0
$LN95@changeAdja:
	movzx	edx, BYTE PTR tv522[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _eSeeInvisible$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bIncrement$[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, 2
	add	ecx, -1
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount
$LN7@changeAdja:

; 1639 : 						}
; 1640 : 					}
; 1641 : 					else // I have no idea how this can happen, but...

	jmp	SHORT $LN1026@changeAdja
$LN8@changeAdja:

; 1642 : 					{
; 1643 : 						// set our value in the scratch pad
; 1644 : 						pPlotToCheck->setScratchPad(iThisPlotLevel);

	mov	eax, DWORD PTR _pPlotToCheck$[ebp]
	mov	ecx, DWORD PTR _iThisPlotLevel$222652[ebp]
	mov	DWORD PTR [eax+364], ecx
$LN1026@changeAdja:

; 1645 : 					}
; 1646 : 				}
; 1647 : 				else // this is the center point

	jmp	SHORT $LN1028@changeAdja
$LN53@changeAdja:

; 1648 : 				{					
; 1649 : #ifdef AUI_WARNING_FIXES
; 1650 : 					pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, bBasedOnUnit ? true : false);
; 1651 : #else
; 1652 : 					pPlotToCheck->changeVisibilityCount(eTeam, ((bIncrement) ? 1 : -1), eSeeInvisible, true, (bBasedOnUnit && thisRing < 2)?true:false);

	movzx	edx, BYTE PTR _bBasedOnUnit$[ebp]
	test	edx, edx
	je	SHORT $LN96@changeAdja
	cmp	DWORD PTR _thisRing$[ebp], 2
	jge	SHORT $LN96@changeAdja
	mov	BYTE PTR tv537[ebp], 1
	jmp	SHORT $LN97@changeAdja
$LN96@changeAdja:
	mov	BYTE PTR tv537[ebp], 0
$LN97@changeAdja:
	movzx	eax, BYTE PTR tv537[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _eSeeInvisible$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bIncrement$[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, 2
	add	edx, -1
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount

; 1653 : #endif
; 1654 : 					pPlotToCheck->setScratchPad(0);

	mov	ecx, DWORD PTR _pPlotToCheck$[ebp]
	mov	DWORD PTR [ecx+364], 0
$LN1028@changeAdja:

; 1655 : 				}
; 1656 : 			}
; 1657 : 
; 1658 : 		}
; 1659 : 
; 1660 : 		int iNextDX;
; 1661 : 		int iNextDY;
; 1662 : 		if(iPlotCounter >= iMaxPlotNumberOnThisRing)  // we have processed all of the plots in this ring

	mov	edx, DWORD PTR _iPlotCounter$[ebp]
	cmp	edx, DWORD PTR _iMaxPlotNumberOnThisRing$[ebp]
	jl	SHORT $LN3@changeAdja

; 1663 : 		{
; 1664 : 			// if that fails go out one ring in the NE direction traveling E
; 1665 : 			eDirectionOfNextTileToCheck = DIRECTION_NORTHEAST;

	mov	DWORD PTR _eDirectionOfNextTileToCheck$[ebp], 0

; 1666 : 			iNextDX = iDX + GC.getPlotDirectionX()[eDirectionOfNextTileToCheck];

	mov	eax, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	mov	ecx, DWORD PTR _iDX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iNextDX$222719[ebp], ecx

; 1667 : 			iNextDY = iDY + GC.getPlotDirectionY()[eDirectionOfNextTileToCheck];

	mov	edx, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iNextDY$222720[ebp], eax

; 1668 : 			thisRing++;

	mov	ecx, DWORD PTR _thisRing$[ebp]
	add	ecx, 1
	mov	DWORD PTR _thisRing$[ebp], ecx

; 1669 : 			iMaxPlotNumberOnThisRing += thisRing * 6;

	mov	edx, DWORD PTR _thisRing$[ebp]
	imul	edx, 6
	add	edx, DWORD PTR _iMaxPlotNumberOnThisRing$[ebp]
	mov	DWORD PTR _iMaxPlotNumberOnThisRing$[ebp], edx

; 1670 : 			eDirectionOfNextTileToCheck = DIRECTION_EAST;

	mov	DWORD PTR _eDirectionOfNextTileToCheck$[ebp], 1

; 1671 : 			// (if that is further out than the extended range, we are done)
; 1672 : 		}
; 1673 : 		else

	jmp	SHORT $LN1@changeAdja
$LN3@changeAdja:

; 1674 : 		{
; 1675 : 			iNextDX = iDX + GC.getPlotDirectionX()[eDirectionOfNextTileToCheck];

	mov	eax, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	mov	ecx, DWORD PTR _iDX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iNextDX$222719[ebp], ecx

; 1676 : 			iNextDY = iDY + GC.getPlotDirectionY()[eDirectionOfNextTileToCheck];

	mov	edx, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iNextDY$222720[ebp], eax

; 1677 : 			if(hexDistance(iNextDX,iNextDY) > thisRing)

	mov	ecx, DWORD PTR _iNextDY$222720[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNextDX$222719[ebp]
	push	edx
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	cmp	eax, DWORD PTR _thisRing$[ebp]
	jle	SHORT $LN1@changeAdja

; 1678 : 			{
; 1679 : 				// try to turn right
; 1680 : 				eDirectionOfNextTileToCheck = GC.getTurnRightDirection(eDirectionOfNextTileToCheck);

	mov	eax, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTurnRightDirection@CvGlobals@@QAE?AW4DirectionTypes@@H@Z ; CvGlobals::getTurnRightDirection
	mov	DWORD PTR _eDirectionOfNextTileToCheck$[ebp], eax

; 1681 : 				iNextDX = iDX + GC.getPlotDirectionX()[eDirectionOfNextTileToCheck];

	mov	ecx, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	mov	edx, DWORD PTR _iDX$[ebp]
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	DWORD PTR _iNextDX$222719[ebp], edx

; 1682 : 				iNextDY = iDY + GC.getPlotDirectionY()[eDirectionOfNextTileToCheck];

	mov	eax, DWORD PTR _eDirectionOfNextTileToCheck$[ebp]
	mov	ecx, DWORD PTR _iDY$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+136]
	mov	DWORD PTR _iNextDY$222720[ebp], ecx
$LN1@changeAdja:

; 1683 : 			}
; 1684 : 		}
; 1685 : 
; 1686 : 		iPlotCounter++;

	mov	edx, DWORD PTR _iPlotCounter$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotCounter$[ebp], edx

; 1687 : 
; 1688 : 		iDX = iNextDX;

	mov	eax, DWORD PTR _iNextDX$222719[ebp]
	mov	DWORD PTR _iDX$[ebp], eax

; 1689 : 		iDY = iNextDY;

	mov	ecx, DWORD PTR _iNextDY$222720[ebp]
	mov	DWORD PTR _iDY$[ebp], ecx

; 1690 : 		pPlotToCheck = plotXYWithRangeCheck(getX(),getY(),iDX,iDY,iRangeWithOneExtraRing);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T237622[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T237626[ebp], edx
	mov	eax, DWORD PTR _iRangeWithOneExtraRing$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDX$[ebp]
	push	edx
	mov	eax, DWORD PTR $T237622[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237626[ebp]
	push	ecx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pPlotToCheck$[ebp], eax

; 1691 : 	}

	jmp	$LN59@changeAdja
$LN58@changeAdja:

; 1692 : 
; 1693 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN1125@changeAdja:
	DD	$LN50@changeAdja
	DD	$LN49@changeAdja
	DD	$LN48@changeAdja
	DD	$LN47@changeAdja
	DD	$LN46@changeAdja
	DD	$LN45@changeAdja
?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ENDP ; CvPlot::changeAdjacentSight
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
tv83 = -36						; size = 4
tv81 = -32						; size = 4
tv78 = -28						; size = 4
tv74 = -24						; size = 4
tv71 = -20						; size = 4
_iAbsDY$216713 = -16					; size = 4
_iAbsDX$216712 = -12					; size = 4
_iAbsDY$216710 = -8					; size = 4
_iAbsDX$216709 = -4					; size = 4
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN5@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN6@hexDistanc
$LN5@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN6@hexDistanc:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216709[ebp], ecx

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN7@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN8@hexDistanc
$LN7@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN8@hexDistanc:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216710[ebp], ecx

; 112  : 		return iAbsDX + iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216709[ebp]
	add	eax, DWORD PTR _iAbsDY$216710[ebp]
	jmp	SHORT $LN3@hexDistanc

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN3@hexDistanc
$LN2@hexDistanc:

; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN9@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN10@hexDistanc
$LN9@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv78[ebp], eax
$LN10@hexDistanc:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216712[ebp], ecx

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN11@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN12@hexDistanc
$LN11@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv81[ebp], eax
$LN12@hexDistanc:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216713[ebp], ecx

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216712[ebp]
	cmp	edx, DWORD PTR _iAbsDY$216713[ebp]
	jl	SHORT $LN13@hexDistanc
	mov	eax, DWORD PTR _iAbsDX$216712[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@hexDistanc
$LN13@hexDistanc:
	mov	ecx, DWORD PTR _iAbsDY$216713[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN14@hexDistanc:
	mov	eax, DWORD PTR tv83[ebp]
$LN3@hexDistanc:

; 119  : 	}
; 120  : #endif
; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
EXTRN	?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z:PROC ; CvTargeting::CanSeeDisplacementPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv169 = -148						; size = 4
tv173 = -144						; size = 4
_this$ = -140						; size = 4
_dx$222742 = -36					; size = 4
_iX1$222740 = -32					; size = 4
_iX2$222741 = -28					; size = 4
_dy$222739 = -24					; size = 4
_iDistance$ = -20					; size = 4
_startX$ = -16						; size = 4
_destY$ = -12						; size = 4
_startY$ = -8						; size = 4
_destX$ = -4						; size = 4
_pPlot$ = 8						; size = 4
_eTeam$ = 12						; size = 4
_iRange$ = 16						; size = 4
_eFacingDirection$ = 20					; size = 4
?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z PROC ; CvPlot::canSeePlot, COMDAT
; _this$ = ecx

; 1697 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	DWORD PTR _this$[ebp], ecx

; 1698 : #ifndef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1699 : 	iRange++;

	mov	eax, DWORD PTR _iRange$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRange$[ebp], eax

; 1700 : #endif
; 1701 : 
; 1702 : 	if(pPlot == NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN6@canSeePlot

; 1703 : 	{
; 1704 : 		return false;

	xor	al, al
	jmp	$LN7@canSeePlot
$LN6@canSeePlot:

; 1705 : 	}
; 1706 : 
; 1707 : 	if(pPlot == this)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $LN9@canSeePlot

; 1708 : 	{
; 1709 : 		return true;

	mov	al, 1
	jmp	$LN7@canSeePlot

; 1710 : 	}
; 1711 : 
; 1712 : 	int startX = getX();

$LN9@canSeePlot:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _startX$[ebp], eax

; 1713 : 	int startY = getY();

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _startY$[ebp], edx

; 1714 : 	int destX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _destX$[ebp], ecx

; 1715 : 	int destY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _destY$[ebp], eax

; 1716 : 
; 1717 : 	int iDistance = plotDistance(startX, startY, destX,  destY);

	mov	ecx, DWORD PTR _destY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _destX$[ebp]
	push	edx
	mov	eax, DWORD PTR _startY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _startX$[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$[ebp], eax

; 1718 : 
; 1719 : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1720 : 	if (iDistance <= iRange + 1)
; 1721 : #else
; 1722 : 	if(iDistance <= iRange)

	mov	edx, DWORD PTR _iDistance$[ebp]
	cmp	edx, DWORD PTR _iRange$[ebp]
	jg	$LN4@canSeePlot

; 1723 : #endif
; 1724 : 	{
; 1725 : 		//find displacement
; 1726 : 		int dy = destY - startY;

	mov	eax, DWORD PTR _destY$[ebp]
	sub	eax, DWORD PTR _startY$[ebp]
	mov	DWORD PTR _dy$222739[ebp], eax

; 1727 : 
; 1728 : 		int iX1 = xToHexspaceX(destX,  destY);

	cmp	DWORD PTR _destY$[ebp], 0
	jl	SHORT $LN59@canSeePlot
	mov	ecx, DWORD PTR _destY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv173[ebp], ecx
	jmp	SHORT $LN57@canSeePlot
$LN59@canSeePlot:
	mov	eax, DWORD PTR _destY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv173[ebp], eax
$LN57@canSeePlot:
	mov	edx, DWORD PTR _destX$[ebp]
	sub	edx, DWORD PTR tv173[ebp]
	mov	DWORD PTR _iX1$222740[ebp], edx

; 1729 : 		int iX2 = xToHexspaceX(startX, startY);

	cmp	DWORD PTR _startY$[ebp], 0
	jl	SHORT $LN63@canSeePlot
	mov	eax, DWORD PTR _startY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $LN61@canSeePlot
$LN63@canSeePlot:
	mov	eax, DWORD PTR _startY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv169[ebp], eax
$LN61@canSeePlot:
	mov	ecx, DWORD PTR _startX$[ebp]
	sub	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR _iX2$222741[ebp], ecx

; 1730 : 		 
; 1731 : 		int dx = iX1 - iX2;

	mov	edx, DWORD PTR _iX1$222740[ebp]
	sub	edx, DWORD PTR _iX2$222741[ebp]
	mov	DWORD PTR _dx$222742[ebp], edx

; 1732 : 
; 1733 : 		dx = dxWrap(dx); //world wrap

	mov	eax, DWORD PTR _dx$222742[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _dx$222742[ebp], eax

; 1734 : 		dy = dyWrap(dy);

	mov	ecx, DWORD PTR _dy$222739[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _dy$222739[ebp], eax

; 1735 : 
; 1736 : 		//check if in facing direction
; 1737 : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1738 : 		if (shouldProcessDisplacementPlot(dx, dy, iRange, eFacingDirection))
; 1739 : #else
; 1740 : 		if(shouldProcessDisplacementPlot(dx, dy, iRange - 1, eFacingDirection))

	mov	edx, DWORD PTR _eFacingDirection$[ebp]
	push	edx
	mov	eax, DWORD PTR _iRange$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _dy$222739[ebp]
	push	ecx
	mov	edx, DWORD PTR _dx$222742[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ; CvPlot::shouldProcessDisplacementPlot
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@canSeePlot

; 1741 : #endif
; 1742 : 		{
; 1743 : 			if(iDistance == 1)

	cmp	DWORD PTR _iDistance$[ebp], 1
	jne	SHORT $LN2@canSeePlot

; 1744 : 			{
; 1745 : 				return true;

	mov	al, 1
	jmp	SHORT $LN7@canSeePlot
$LN2@canSeePlot:

; 1746 : 			}
; 1747 : 
; 1748 : 			//check if anything blocking the plot
; 1749 : 			if (CvTargeting::CanSeeDisplacementPlot(startX, startY, dx, dy, seeFromLevel(eTeam)))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel
	push	eax
	mov	edx, DWORD PTR _dy$222739[ebp]
	push	edx
	mov	eax, DWORD PTR _dx$222742[ebp]
	push	eax
	mov	ecx, DWORD PTR _startY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _startX$[ebp]
	push	edx
	call	?CanSeeDisplacementPlot@CvTargeting@@SA_NHHHHH@Z ; CvTargeting::CanSeeDisplacementPlot
	add	esp, 20					; 00000014H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@canSeePlot

; 1750 : 			{
; 1751 : 				return true;

	mov	al, 1
	jmp	SHORT $LN7@canSeePlot
$LN4@canSeePlot:

; 1752 : 			}
; 1753 : 		}
; 1754 : 	}
; 1755 : 
; 1756 : 	return false;

	xor	al, al
$LN7@canSeePlot:

; 1757 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ENDP ; CvPlot::canSeePlot
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__mask@@NegDouble@
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@3ff4f1a6c638d03f
PUBLIC	__real@bff0000000000000
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@bfebb67a00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3febb67a00000000
EXTRN	___libm_sse2_atan2:PROC
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@3ff4f1a6c638d03f
CONST	SEGMENT
__real@3ff4f1a6c638d03f DQ 03ff4f1a6c638d03fr	; 1.309
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@bfebb67a00000000
CONST	SEGMENT
__real@bfebb67a00000000 DQ 0bfebb67a00000000r	; -0.866025
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3febb67a00000000
CONST	SEGMENT
__real@3febb67a00000000 DQ 03febb67a00000000r	; 0.866025
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_spread$222763 = -152					; size = 8
_theta$222762 = -144					; size = 8
_dotProduct$222761 = -136				; size = 8
_crossProduct$222760 = -128				; size = 8
_directionY$222759 = -120				; size = 8
_directionX$222758 = -112				; size = 8
_displacements$222757 = -104				; size = 96
_this$ = -4						; size = 4
_dx$ = 8						; size = 4
_dy$ = 12						; size = 4
___formal$ = 16						; size = 4
_eFacingDirection$ = 20					; size = 4
?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z PROC ; CvPlot::shouldProcessDisplacementPlot, COMDAT
; _this$ = ecx

; 1761 : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	DWORD PTR _this$[ebp], ecx

; 1762 : 	if(eFacingDirection == NO_DIRECTION)

	cmp	DWORD PTR _eFacingDirection$[ebx], -1
	jne	SHORT $LN7@shouldProc

; 1763 : 	{
; 1764 : 		return true;

	mov	al, 1
	jmp	$LN1@shouldProc
	jmp	$LN1@shouldProc
$LN7@shouldProc:

; 1765 : 	}
; 1766 : 	else if((dx == 0) && (dy == 0)) //always process this plot

	cmp	DWORD PTR _dx$[ebx], 0
	jne	SHORT $LN5@shouldProc
	cmp	DWORD PTR _dy$[ebx], 0
	jne	SHORT $LN5@shouldProc

; 1767 : 	{
; 1768 : 		return true;

	mov	al, 1
	jmp	$LN1@shouldProc

; 1769 : 	}
; 1770 : 	else

	jmp	$LN1@shouldProc
$LN5@shouldProc:

; 1771 : 	{
; 1772 : 		//							NE					E		SE					SW					W		NW
; 1773 : 		double displacements[6][2] = { {0.5f, 0.866025f}, {1, 0}, {0.5f, -0.866025f}, {-0.5f, -0.866025f}, {-1, 0}, {-0.5f, -0.866025f}};

	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _displacements$222757[ebp], xmm0
	movsd	xmm0, QWORD PTR __real@3febb67a00000000
	movsd	QWORD PTR _displacements$222757[ebp+8], xmm0
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _displacements$222757[ebp+16], xmm0
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _displacements$222757[ebp+24], xmm0
	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _displacements$222757[ebp+32], xmm0
	movsd	xmm0, QWORD PTR __real@bfebb67a00000000
	movsd	QWORD PTR _displacements$222757[ebp+40], xmm0
	movsd	xmm0, QWORD PTR __real@bfe0000000000000
	movsd	QWORD PTR _displacements$222757[ebp+48], xmm0
	movsd	xmm0, QWORD PTR __real@bfebb67a00000000
	movsd	QWORD PTR _displacements$222757[ebp+56], xmm0
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR _displacements$222757[ebp+64], xmm0
	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _displacements$222757[ebp+72], xmm0
	movsd	xmm0, QWORD PTR __real@bfe0000000000000
	movsd	QWORD PTR _displacements$222757[ebp+80], xmm0
	movsd	xmm0, QWORD PTR __real@bfebb67a00000000
	movsd	QWORD PTR _displacements$222757[ebp+88], xmm0

; 1774 : 
; 1775 : 		double directionX = displacements[eFacingDirection][0];

	mov	eax, DWORD PTR _eFacingDirection$[ebx]
	shl	eax, 4
	movsd	xmm0, QWORD PTR _displacements$222757[ebp+eax]
	movsd	QWORD PTR _directionX$222758[ebp], xmm0

; 1776 : 		double directionY = displacements[eFacingDirection][1];

	mov	ecx, DWORD PTR _eFacingDirection$[ebx]
	shl	ecx, 4
	movsd	xmm0, QWORD PTR _displacements$222757[ebp+ecx+8]
	movsd	QWORD PTR _directionY$222759[ebp], xmm0

; 1777 : 
; 1778 : 		//compute angle off of direction
; 1779 : 		double crossProduct = directionX * dy - directionY * dx; //cross product

	cvtsi2sd xmm0, DWORD PTR _dy$[ebx]
	mulsd	xmm0, QWORD PTR _directionX$222758[ebp]
	cvtsi2sd xmm1, DWORD PTR _dx$[ebx]
	mulsd	xmm1, QWORD PTR _directionY$222759[ebp]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _crossProduct$222760[ebp], xmm0

; 1780 : 		double dotProduct = directionX * dx + directionY * dy; //dot product

	cvtsi2sd xmm0, DWORD PTR _dx$[ebx]
	mulsd	xmm0, QWORD PTR _directionX$222758[ebp]
	cvtsi2sd xmm1, DWORD PTR _dy$[ebx]
	mulsd	xmm1, QWORD PTR _directionY$222759[ebp]
	addsd	xmm0, xmm1
	movsd	QWORD PTR _dotProduct$222761[ebp], xmm0

; 1781 : 
; 1782 : #ifdef AUI_PLOT_VISIBILITY_OPTIMIZATIONS
; 1783 : 		double theta = abs(atan2(crossProduct, dotProduct));
; 1784 : 		double spread = 37.5 * M_PI / 180.0;
; 1785 : #if 0 // Enable if 8 or more directions
; 1786 : 		if ((abs(dx) <= 1) && (abs(dy) <= 1)) //close plots use wider spread
; 1787 : 		{
; 1788 : 			spread = 90 * (double)M_PI / 180;
; 1789 : 		}
; 1790 : #endif
; 1791 : 
; 1792 : 		if (theta <= spread)
; 1793 : 			return true;
; 1794 : 		else
; 1795 : 			return false;
; 1796 : #else
; 1797 : 		double theta = atan2(crossProduct, dotProduct);

	movsd	xmm0, QWORD PTR _crossProduct$222760[ebp]
	movsd	xmm1, QWORD PTR _dotProduct$222761[ebp]
	call	___libm_sse2_atan2
	movsd	QWORD PTR _theta$222762[ebp], xmm0

; 1798 : 		double spread = 75 * (double) M_PI / 180;

	movsd	xmm0, QWORD PTR __real@3ff4f1a6c638d03f
	movsd	QWORD PTR _spread$222763[ebp], xmm0

; 1799 : 		if((abs(dx) <= 1) && (abs(dy) <= 1)) //close plots use wider spread

	mov	eax, DWORD PTR _dx$[ebx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 1
	jg	SHORT $LN3@shouldProc
	mov	eax, DWORD PTR _dy$[ebx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 1
	jg	SHORT $LN3@shouldProc

; 1800 : 		{
; 1801 : 			spread = 90 * (double) M_PI / 180;

	movsd	xmm0, QWORD PTR __real@3ff921fb54442d18
	movsd	QWORD PTR _spread$222763[ebp], xmm0
$LN3@shouldProc:

; 1802 : 		}
; 1803 : 
; 1804 : 		if((theta >= -spread / 2) && (theta <= spread / 2))

	movsd	xmm0, QWORD PTR _spread$222763[ebp]
	xorpd	xmm0, QWORD PTR __mask@@NegDouble@
	divsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	xmm1, QWORD PTR _theta$222762[ebp]
	comisd	xmm1, xmm0
	jb	SHORT $LN2@shouldProc
	movsd	xmm0, QWORD PTR _spread$222763[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	comisd	xmm0, QWORD PTR _theta$222762[ebp]
	jb	SHORT $LN2@shouldProc

; 1805 : 		{
; 1806 : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@shouldProc

; 1807 : 		}
; 1808 : 		else

	jmp	SHORT $LN1@shouldProc
$LN2@shouldProc:

; 1809 : 		{
; 1810 : 			return false;

	xor	al, al
$LN1@shouldProc:

; 1811 : 		}
; 1812 : #endif
; 1813 : 	}
; 1814 : }

	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	16					; 00000010H
?shouldProcessDisplacementPlot@CvPlot@@QBE_NHHHW4DirectionTypes@@@Z ENDP ; CvPlot::shouldProcessDisplacementPlot
_TEXT	ENDS
PUBLIC	?updateSight@CvPlot@@QAEX_N@Z			; CvPlot::updateSight
EXTRN	?getReconPlot@CvUnit@@QBEPAVCvPlot@@XZ:PROC	; CvUnit::getReconPlot
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?visibilityRange@CvUnit@@QBEHXZ:PROC		; CvUnit::visibilityRange
EXTRN	?getSeeInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ:PROC ; CvUnit::getSeeInvisibleType
EXTRN	?getFacingDirection@CvUnit@@QBE?AW4DirectionTypes@@_N@Z:PROC ; CvUnit::getFacingDirection
EXTRN	?canChangeVisibility@CvUnit@@QBE_NXZ:PROC	; CvUnit::canChangeVisibility
EXTRN	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ:PROC ; CvMinorCivAI::GetAlly
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z:PROC ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
EXTRN	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ:PROC ; CvPlayer::GetEspionage
; Function compile flags: /Odtp
;	COMDAT ?updateSight@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv301 = -100						; size = 4
_this$ = -96						; size = 4
$T238022 = -92						; size = 4
$T238018 = -88						; size = 4
$T237994 = -84						; size = 4
$T237993 = -80						; size = 4
$T237989 = -76						; size = 4
$T237971 = -72						; size = 4
$T237967 = -68						; size = 4
$T237963 = -64						; size = 4
$T237959 = -60						; size = 4
_playerID$237956 = -56					; size = 4
$T237942 = -52						; size = 4
_iRange$222799 = -44					; size = 4
_thisPlayer$222790 = -40				; size = 4
_pMinorCivAI$222791 = -36				; size = 4
_ePlayer$222784 = -32					; size = 4
_ui$222780 = -28					; size = 4
_ownerID$222787 = -24					; size = 4
_pUnitNode$ = -20					; size = 4
_pCity$ = -16						; size = 4
_pLoopUnit$ = -12					; size = 4
_iI$ = -8						; size = 4
_iLoop$ = -4						; size = 4
_bIncrement$ = 8					; size = 1
?updateSight@CvPlot@@QAEX_N@Z PROC			; CvPlot::updateSight, COMDAT
; _this$ = ecx

; 1818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 1819 : 	IDInfo* pUnitNode;
; 1820 : 	CvCity* pCity;
; 1821 : 	CvUnit* pLoopUnit;
; 1822 : 	int iLoop;
; 1823 : 	int iI;
; 1824 : 
; 1825 : 	pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 1826 : 
; 1827 : 	// Owned
; 1828 : 	if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	$LN20@updateSigh

; 1829 : 	{
; 1830 : 		changeAdjacentSight(getTeam(), GC.getPLOT_VISIBILITY_RANGE(), bIncrement, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	DWORD PTR $T237942[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$237956[ebp], eax
	cmp	DWORD PTR _playerID$237956[ebp], -1
	je	SHORT $LN31@updateSigh
	mov	ecx, DWORD PTR _playerID$237956[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237959[ebp], eax
	jmp	SHORT $LN32@updateSigh
	jmp	SHORT $LN32@updateSigh
$LN31@updateSigh:
	mov	DWORD PTR $T237959[ebp], -1
$LN32@updateSigh:
	push	0
	push	-1
	push	-1
	movzx	edx, BYTE PTR _bIncrement$[ebp]
	push	edx
	mov	eax, DWORD PTR $T237942[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237959[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight

; 1831 : 
; 1832 : 		// if this tile is owned by a minor share the visibility with my ally
; 1833 : 		if(pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN48@updateSigh

; 1834 : 		{
; 1835 : 			for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$222780[ebp], 0
	jmp	SHORT $LN18@updateSigh
$LN17@updateSigh:
	mov	edx, DWORD PTR _ui$222780[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$222780[ebp], edx
$LN18@updateSigh:
	cmp	DWORD PTR _ui$222780[ebp], 22		; 00000016H
	jae	SHORT $LN48@updateSigh

; 1836 : 			{
; 1837 : 				PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	eax, DWORD PTR _ui$222780[ebp]
	mov	DWORD PTR _ePlayer$222784[ebp], eax

; 1838 : 				if(GET_PLAYER(ePlayer).GetEspionage()->HasEstablishedSurveillanceInCity(pCity))

	mov	ecx, DWORD PTR _ePlayer$222784[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237963[ebp], ecx
	mov	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T237963[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@updateSigh

; 1839 : 				{
; 1840 : 					changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), bIncrement, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	mov	DWORD PTR $T237967[ebp], ecx
	mov	edx, DWORD PTR _ePlayer$222784[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237971[ebp], edx
	push	0
	push	-1
	push	-1
	movzx	eax, BYTE PTR _bIncrement$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237967[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237971[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN15@updateSigh:

; 1841 : 				}

	jmp	$LN17@updateSigh

; 1842 : 			}
; 1843 : 		}
; 1844 : 
; 1845 : 		PlayerTypes ownerID = getOwner();

$LN48@updateSigh:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _ownerID$222787[ebp], edx

; 1846 : 		if(ownerID >= MAX_MAJOR_CIVS && ownerID != BARBARIAN_PLAYER)

	cmp	DWORD PTR _ownerID$222787[ebp], 22	; 00000016H
	jl	$LN20@updateSigh
	cmp	DWORD PTR _ownerID$222787[ebp], 63	; 0000003fH
	je	SHORT $LN20@updateSigh

; 1847 : 		{
; 1848 : 			CvPlayer& thisPlayer = GET_PLAYER(ownerID);

	mov	eax, DWORD PTR _ownerID$222787[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$222790[ebp], eax

; 1849 : 			CvMinorCivAI* pMinorCivAI = thisPlayer.GetMinorCivAI();

	mov	ecx, DWORD PTR _thisPlayer$222790[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	DWORD PTR _pMinorCivAI$222791[ebp], eax

; 1850 : 			if(pMinorCivAI && pMinorCivAI->GetAlly() != NO_PLAYER)

	cmp	DWORD PTR _pMinorCivAI$222791[ebp], 0
	je	SHORT $LN20@updateSigh
	mov	ecx, DWORD PTR _pMinorCivAI$222791[ebp]
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	je	SHORT $LN20@updateSigh

; 1851 : 			{
; 1852 : 				changeAdjacentSight(GET_PLAYER(pMinorCivAI->GetAlly()).getTeam(), GC.getPLOT_VISIBILITY_RANGE(), bIncrement, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	DWORD PTR $T237989[ebp], ecx
	mov	ecx, DWORD PTR _pMinorCivAI$222791[ebp]
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR $T237993[ebp], eax
	mov	edx, DWORD PTR $T237993[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237994[ebp], edx
	push	0
	push	-1
	push	-1
	movzx	eax, BYTE PTR _bIncrement$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237989[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237994[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN20@updateSigh:

; 1853 : 			}
; 1854 : 		}
; 1855 : 	}
; 1856 : 
; 1857 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN12@updateSigh:

; 1858 : 
; 1859 : 	// Unit
; 1860 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN11@updateSigh

; 1861 : 	{
; 1862 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 0
	jl	SHORT $LN60@updateSigh
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 64			; 00000040H
	jge	SHORT $LN60@updateSigh
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+ecx+4472]
	mov	DWORD PTR tv301[ebp], eax
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR tv301[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv301[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN61@updateSigh
$LN60@updateSigh:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN61@updateSigh:

; 1863 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 1864 : 
; 1865 : 		if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN10@updateSigh

; 1866 : 		{
; 1867 : 			if (pLoopUnit->canChangeVisibility())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canChangeVisibility@CvUnit@@QBE_NXZ	; CvUnit::canChangeVisibility
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@updateSigh

; 1868 : 				changeAdjacentSight(pLoopUnit->getTeam(), pLoopUnit->visibilityRange(), bIncrement, pLoopUnit->getSeeInvisibleType(), pLoopUnit->getFacingDirection(true));

	push	1
	push	1
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getFacingDirection@CvUnit@@QBE?AW4DirectionTypes@@_N@Z ; CvUnit::getFacingDirection
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getSeeInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getSeeInvisibleType
	push	eax
	movzx	eax, BYTE PTR _bIncrement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?visibilityRange@CvUnit@@QBEHXZ		; CvUnit::visibilityRange
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN10@updateSigh:

; 1869 : 		}
; 1870 : 	}

	jmp	$LN12@updateSigh
$LN11@updateSigh:

; 1871 : 
; 1872 : 	if(getReconCount() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getReconCount@CvPlot@@QBEHXZ		; CvPlot::getReconCount
	test	eax, eax
	jle	$LN21@updateSigh

; 1873 : 	{
; 1874 : 		int iRange = GC.getRECON_VISIBILITY_RANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6192
	mov	DWORD PTR _iRange$222799[ebp], ecx

; 1875 : 		for(iI = 0; iI < MAX_PLAYERS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@updateSigh
$LN6@updateSigh:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN7@updateSigh:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN21@updateSigh

; 1876 : 		{
; 1877 : 			for(pLoopUnit = GET_PLAYER((PlayerTypes)iI).firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER((PlayerTypes)iI).nextUnit(&iLoop))

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238018[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T238018[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN4@updateSigh
$LN3@updateSigh:
	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238022[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238022[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN4@updateSigh:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN2@updateSigh

; 1878 : 			{
; 1879 : 				if(pLoopUnit->getReconPlot() == this && pLoopUnit->canChangeVisibility())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getReconPlot@CvUnit@@QBEPAVCvPlot@@XZ	; CvUnit::getReconPlot
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN1@updateSigh
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canChangeVisibility@CvUnit@@QBE_NXZ	; CvUnit::canChangeVisibility
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@updateSigh

; 1880 : 				{
; 1881 : 					changeAdjacentSight(pLoopUnit->getTeam(), iRange, bIncrement, pLoopUnit->getSeeInvisibleType(), pLoopUnit->getFacingDirection(true));

	push	1
	push	1
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getFacingDirection@CvUnit@@QBE?AW4DirectionTypes@@_N@Z ; CvUnit::getFacingDirection
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getSeeInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getSeeInvisibleType
	push	eax
	movzx	edx, BYTE PTR _bIncrement$[ebp]
	push	edx
	mov	eax, DWORD PTR _iRange$222799[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN1@updateSigh:

; 1882 : 				}
; 1883 : 			}

	jmp	SHORT $LN3@updateSigh
$LN2@updateSigh:

; 1884 : 		}

	jmp	$LN6@updateSigh
$LN21@updateSigh:

; 1885 : 	}
; 1886 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateSight@CvPlot@@QAEX_N@Z ENDP			; CvPlot::updateSight
_TEXT	ENDS
PUBLIC	?updateSeeFromSight@CvPlot@@QAEX_N@Z		; CvPlot::updateSeeFromSight
EXTRN	?GetVisibilityChange@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetVisibilityChange
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
; Function compile flags: /Odtp
;	COMDAT ?updateSeeFromSight@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv83 = -148						; size = 4
tv139 = -144						; size = 4
_this$ = -140						; size = 4
$T238060 = -60						; size = 4
$T238056 = -56						; size = 4
$T238049 = -52						; size = 4
$T238040 = -48						; size = 4
$T238034 = -44						; size = 4
$T238030 = -40						; size = 4
$T238026 = -36						; size = 4
$T238025 = -32						; size = 4
_ePromotion$222821 = -28				; size = 4
_pkPromotionInfo$222823 = -24				; size = 4
_iPromotion$222817 = -20				; size = 4
_iDY$ = -16						; size = 4
_iDX$ = -12						; size = 4
_iRange$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_bIncrement$ = 8					; size = 1
?updateSeeFromSight@CvPlot@@QAEX_N@Z PROC		; CvPlot::updateSeeFromSight, COMDAT
; _this$ = ecx

; 1891 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	DWORD PTR _this$[ebp], ecx

; 1892 : 	CvPlot* pLoopPlot;
; 1893 : 	int iDX, iDY;
; 1894 : 
; 1895 : 	int iRange = GC.getUNIT_VISIBILITY_RANGE() + 1;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6200
	mov	DWORD PTR $T238030[ebp], eax
	mov	ecx, DWORD PTR $T238030[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRange$[ebp], ecx

; 1896 : #ifdef AUI_WARNING_FIXES
; 1897 : 	for (uint iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); ++iPromotion)
; 1898 : #else
; 1899 : 	for(int iPromotion = 0; iPromotion < GC.getNumPromotionInfos(); ++iPromotion)

	mov	DWORD PTR _iPromotion$222817[ebp], 0
	jmp	SHORT $LN11@updateSeeF
$LN10@updateSeeF:
	mov	edx, DWORD PTR _iPromotion$222817[ebp]
	add	edx, 1
	mov	DWORD PTR _iPromotion$222817[ebp], edx
$LN11@updateSeeF:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	DWORD PTR _iPromotion$222817[ebp], eax
	jge	SHORT $LN9@updateSeeF

; 1900 : #endif
; 1901 : 	{
; 1902 : 		const PromotionTypes ePromotion = static_cast<PromotionTypes>(iPromotion);

	mov	eax, DWORD PTR _iPromotion$222817[ebp]
	mov	DWORD PTR _ePromotion$222821[ebp], eax

; 1903 : 		CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(ePromotion);

	mov	ecx, DWORD PTR _ePromotion$222821[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	DWORD PTR _pkPromotionInfo$222823[ebp], eax

; 1904 : 		if(pkPromotionInfo)

	cmp	DWORD PTR _pkPromotionInfo$222823[ebp], 0
	je	SHORT $LN8@updateSeeF

; 1905 : 		{
; 1906 : 			iRange += pkPromotionInfo->GetVisibilityChange();

	mov	ecx, DWORD PTR _pkPromotionInfo$222823[ebp]
	call	?GetVisibilityChange@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetVisibilityChange
	add	eax, DWORD PTR _iRange$[ebp]
	mov	DWORD PTR _iRange$[ebp], eax
$LN8@updateSeeF:

; 1907 : 		}
; 1908 : 	}

	jmp	SHORT $LN10@updateSeeF
$LN9@updateSeeF:

; 1909 : 
; 1910 : #ifdef NQM_FAST_COMP
; 1911 : 	iRange = MAX(GC.getRECON_VISIBILITY_RANGE() + 1, iRange);
; 1912 : #ifndef AUI_PLOT_SEE_FROM_SIGHT_NO_MAXIMUM_SIGHT_RANGE
; 1913 : 	iRange = MIN(8, iRange); // I don't care, I'm not looking more than 8 out, deal
; 1914 : #endif
; 1915 : #else
; 1916 : 	iRange = std::max(GC.getRECON_VISIBILITY_RANGE() + 1, iRange);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6192
	mov	DWORD PTR $T238034[ebp], edx
	mov	eax, DWORD PTR $T238034[ebp]
	add	eax, 1
	mov	DWORD PTR $T238025[ebp], eax
	mov	ecx, DWORD PTR $T238025[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jge	SHORT $LN20@updateSeeF
	lea	edx, DWORD PTR _iRange$[ebp]
	mov	DWORD PTR tv139[ebp], edx
	jmp	SHORT $LN21@updateSeeF
$LN20@updateSeeF:
	lea	eax, DWORD PTR $T238025[ebp]
	mov	DWORD PTR tv139[ebp], eax
$LN21@updateSeeF:
	mov	ecx, DWORD PTR tv139[ebp]
	mov	DWORD PTR $T238040[ebp], ecx
	mov	edx, DWORD PTR $T238040[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iRange$[ebp], eax

; 1917 : #ifndef AUI_PLOT_SEE_FROM_SIGHT_NO_MAXIMUM_SIGHT_RANGE
; 1918 : 	iRange = std::min(8, iRange); // I don't care, I'm not looking more than 8 out, deal

	mov	DWORD PTR $T238026[ebp], 8
	mov	ecx, DWORD PTR _iRange$[ebp]
	cmp	ecx, DWORD PTR $T238026[ebp]
	jge	SHORT $LN24@updateSeeF
	lea	edx, DWORD PTR _iRange$[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN25@updateSeeF
$LN24@updateSeeF:
	lea	eax, DWORD PTR $T238026[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN25@updateSeeF:
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T238049[ebp], ecx
	mov	edx, DWORD PTR $T238049[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iRange$[ebp], eax

; 1919 : #endif
; 1920 : #endif
; 1921 : 
; 1922 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1923 : 	int iMaxDX;
; 1924 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 1925 : 	{
; 1926 : 		iMaxDX = iRange - MAX(0, iDY);
; 1927 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1928 : 		{
; 1929 : 			pLoopPlot = plotXY(getX(), getY(), iDX, iDY);
; 1930 : #else
; 1931 : 	for(iDX = -iRange; iDX <= iRange; iDX++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iDX$[ebp], ecx
	jmp	SHORT $LN7@updateSeeF
$LN6@updateSeeF:
	mov	edx, DWORD PTR _iDX$[ebp]
	add	edx, 1
	mov	DWORD PTR _iDX$[ebp], edx
$LN7@updateSeeF:
	mov	eax, DWORD PTR _iDX$[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	SHORT $LN12@updateSeeF

; 1932 : 	{
; 1933 : 		for(iDY = -iRange; iDY <= iRange; iDY++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iDY$[ebp], ecx
	jmp	SHORT $LN4@updateSeeF
$LN3@updateSeeF:
	mov	edx, DWORD PTR _iDY$[ebp]
	add	edx, 1
	mov	DWORD PTR _iDY$[ebp], edx
$LN4@updateSeeF:
	mov	eax, DWORD PTR _iDY$[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	SHORT $LN2@updateSeeF

; 1934 : 		{
; 1935 : 			pLoopPlot = plotXYWithRangeCheck(getX(), getY(), iDX, iDY, iRange);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T238056[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T238060[ebp], ecx
	mov	edx, DWORD PTR _iRange$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238056[ebp]
	push	edx
	mov	eax, DWORD PTR $T238060[ebp]
	push	eax
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 1936 : #endif
; 1937 : 
; 1938 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN1@updateSeeF

; 1939 : 			{
; 1940 : 				pLoopPlot->updateSight(bIncrement);

	movzx	ecx, BYTE PTR _bIncrement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?updateSight@CvPlot@@QAEX_N@Z		; CvPlot::updateSight
$LN1@updateSeeF:

; 1941 : 			}
; 1942 : 		}

	jmp	SHORT $LN3@updateSeeF
$LN2@updateSeeF:

; 1943 : 	}

	jmp	SHORT $LN6@updateSeeF
$LN12@updateSeeF:

; 1944 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateSeeFromSight@CvPlot@@QAEX_N@Z ENDP		; CvPlot::updateSeeFromSight
_TEXT	ENDS
PUBLIC	?isPotentialCityWork@CvPlot@@QBE_NXZ		; CvPlot::isPotentialCityWork
PUBLIC	?getLatitude@CvPlot@@QBEHXZ			; CvPlot::getLatitude
PUBLIC	?area@CvPlot@@QBEPAVCvArea@@XZ			; CvPlot::area
PUBLIC	?isFlatlands@CvPlot@@QBE_NXZ			; CvPlot::isFlatlands
PUBLIC	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
PUBLIC	?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z ; CvPlot::canHaveResource
EXTRN	?getMinLatitude@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getMinLatitude
EXTRN	?getMaxLatitude@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getMaxLatitude
EXTRN	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvResourceInfo::GetRequiredCivilization
EXTRN	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ:PROC	; CvResourceInfo::isOnlyMinorCivs
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?getMinAreaSize@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getMinAreaSize
EXTRN	?isNoRiverSide@CvResourceInfo@@QBE_NXZ:PROC	; CvResourceInfo::isNoRiverSide
EXTRN	?isFlatlands@CvResourceInfo@@QBE_NXZ:PROC	; CvResourceInfo::isFlatlands
EXTRN	?isHills@CvResourceInfo@@QBE_NXZ:PROC		; CvResourceInfo::isHills
EXTRN	?isTerrain@CvResourceInfo@@QBE_NH@Z:PROC	; CvResourceInfo::isTerrain
EXTRN	?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z:PROC	; CvResourceInfo::isFeatureTerrain
EXTRN	?isFeature@CvResourceInfo@@QBE_NH@Z:PROC	; CvResourceInfo::isFeature
; Function compile flags: /Odtp
;	COMDAT ?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T238223 = -20						; size = 4
$T238219 = -16						; size = 4
_f$238212 = -10						; size = 1
_f$238203 = -9						; size = 1
_thisResourceInfo$ = -8					; size = 4
_eShallowWater$ = -4					; size = 4
_eResource$ = 8						; size = 4
_bIgnoreLatitude$ = 12					; size = 1
?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z PROC ; CvPlot::canHaveResource, COMDAT
; _this$ = ecx

; 1949 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1950 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 1951 : 
; 1952 : 	if(eResource == NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	jne	SHORT $LN25@canHaveRes

; 1953 : 	{
; 1954 : 		return true;

	mov	al, 1
	jmp	$LN26@canHaveRes
$LN25@canHaveRes:

; 1955 : 	}
; 1956 : 
; 1957 : 	if(getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN28@canHaveRes

; 1958 : 	{
; 1959 : 		return false;

	xor	al, al
	jmp	$LN26@canHaveRes

; 1960 : 	}
; 1961 : 
; 1962 : 	if(isMountain())

$LN28@canHaveRes:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN23@canHaveRes

; 1963 : 	{
; 1964 : 		return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN23@canHaveRes:

; 1965 : 	}
; 1966 : 
; 1967 : 	CvResourceInfo& thisResourceInfo = *GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _thisResourceInfo$[ebp], eax

; 1968 : 	if(getFeatureType() != NO_FEATURE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$238203[ebp], dl
	movsx	eax, BYTE PTR _f$238203[ebp]
	cmp	eax, -1
	je	SHORT $LN22@canHaveRes

; 1969 : 	{
; 1970 : 		if(!(thisResourceInfo.isFeature(getFeatureType())))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$238212[ebp], dl
	movsx	eax, BYTE PTR _f$238212[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?isFeature@CvResourceInfo@@QBE_NH@Z	; CvResourceInfo::isFeature
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN21@canHaveRes

; 1971 : 		{
; 1972 : 			return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN21@canHaveRes:

; 1973 : 		}
; 1974 : 
; 1975 : 		if(!(thisResourceInfo.isFeatureTerrain(getTerrainType())))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T238219[ebp], eax
	mov	ecx, DWORD PTR $T238219[ebp]
	push	ecx
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?isFeatureTerrain@CvResourceInfo@@QBE_NH@Z ; CvResourceInfo::isFeatureTerrain
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@canHaveRes

; 1976 : 		{
; 1977 : 			return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN20@canHaveRes:

; 1978 : 		}
; 1979 : 	}
; 1980 : 	else

	jmp	SHORT $LN42@canHaveRes
$LN22@canHaveRes:

; 1981 : 	{
; 1982 : 		if(!(thisResourceInfo.isTerrain(getTerrainType())))

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR $T238223[ebp], ecx
	mov	edx, DWORD PTR $T238223[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?isTerrain@CvResourceInfo@@QBE_NH@Z	; CvResourceInfo::isTerrain
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN42@canHaveRes

; 1983 : 		{
; 1984 : 			return false;

	xor	al, al
	jmp	$LN26@canHaveRes

; 1985 : 		}
; 1986 : 	}
; 1987 : 
; 1988 : 	if(isHills())

$LN42@canHaveRes:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	sub	edx, 1
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN17@canHaveRes

; 1989 : 	{
; 1990 : 		if(!(thisResourceInfo.isHills()))

	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?isHills@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isHills
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN16@canHaveRes

; 1991 : 		{
; 1992 : 			return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN16@canHaveRes:

; 1993 : 		}
; 1994 : 	}

	jmp	SHORT $LN15@canHaveRes
$LN17@canHaveRes:

; 1995 : 	else if(isFlatlands())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFlatlands@CvPlot@@QBE_NXZ		; CvPlot::isFlatlands
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@canHaveRes

; 1996 : 	{
; 1997 : 		if(!(thisResourceInfo.isFlatlands()))

	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?isFlatlands@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isFlatlands
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN15@canHaveRes

; 1998 : 		{
; 1999 : 			return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN15@canHaveRes:

; 2000 : 		}
; 2001 : 	}
; 2002 : 
; 2003 : 	if(thisResourceInfo.isNoRiverSide())

	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?isNoRiverSide@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isNoRiverSide
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@canHaveRes

; 2004 : 	{
; 2005 : 		if(isRiverSide())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverSide@CvPlot@@QBE_NXZ		; CvPlot::isRiverSide
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@canHaveRes

; 2006 : 		{
; 2007 : 			return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN12@canHaveRes:

; 2008 : 		}
; 2009 : 	}
; 2010 : 
; 2011 : 	if(thisResourceInfo.getMinAreaSize() != -1)

	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?getMinAreaSize@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMinAreaSize
	cmp	eax, -1
	je	SHORT $LN10@canHaveRes

; 2012 : 	{
; 2013 : 		if(area()->getNumTiles() < thisResourceInfo.getMinAreaSize())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	esi, eax
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?getMinAreaSize@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMinAreaSize
	cmp	esi, eax
	jge	SHORT $LN10@canHaveRes

; 2014 : 		{
; 2015 : 			return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN10@canHaveRes:

; 2016 : 		}
; 2017 : 	}
; 2018 : 
; 2019 : 	if(thisResourceInfo.isOnlyMinorCivs())

	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@canHaveRes

; 2020 : 	{
; 2021 : 		return false;

	xor	al, al
	jmp	$LN26@canHaveRes
$LN8@canHaveRes:

; 2022 : 	}
; 2023 : 
; 2024 : 	if (thisResourceInfo.GetRequiredCivilization() != NO_CIVILIZATION)

	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?GetRequiredCivilization@CvResourceInfo@@QBE?AW4CivilizationTypes@@XZ ; CvResourceInfo::GetRequiredCivilization
	cmp	eax, -1
	je	SHORT $LN7@canHaveRes

; 2025 : 	{
; 2026 : 		return false;

	xor	al, al
	jmp	SHORT $LN26@canHaveRes
$LN7@canHaveRes:

; 2027 : 	}
; 2028 : 
; 2029 : 	if(!bIgnoreLatitude)

	movzx	ecx, BYTE PTR _bIgnoreLatitude$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@canHaveRes

; 2030 : 	{
; 2031 : 		if(getLatitude() > thisResourceInfo.getMaxLatitude())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLatitude@CvPlot@@QBEHXZ		; CvPlot::getLatitude
	mov	esi, eax
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?getMaxLatitude@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMaxLatitude
	cmp	esi, eax
	jle	SHORT $LN5@canHaveRes

; 2032 : 		{
; 2033 : 			return false;

	xor	al, al
	jmp	SHORT $LN26@canHaveRes
$LN5@canHaveRes:

; 2034 : 		}
; 2035 : 
; 2036 : 		if(getLatitude() < thisResourceInfo.getMinLatitude())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLatitude@CvPlot@@QBEHXZ		; CvPlot::getLatitude
	mov	esi, eax
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?getMinLatitude@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getMinLatitude
	cmp	esi, eax
	jge	SHORT $LN6@canHaveRes

; 2037 : 		{
; 2038 : 			return false;

	xor	al, al
	jmp	SHORT $LN26@canHaveRes
$LN6@canHaveRes:

; 2039 : 		}
; 2040 : 	}
; 2041 : 
; 2042 : 	if(!isPotentialCityWork())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPotentialCityWork@CvPlot@@QBE_NXZ	; CvPlot::isPotentialCityWork
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@canHaveRes

; 2043 : 	{
; 2044 : 		return false;

	xor	al, al
	jmp	SHORT $LN26@canHaveRes
$LN3@canHaveRes:

; 2045 : 	}
; 2046 : 
; 2047 : 	TerrainTypes eShallowWater = (TerrainTypes) GC.getSHALLOW_WATER_TERRAIN();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR _eShallowWater$[ebp], eax

; 2048 : 	if(getTerrainType() == eShallowWater)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	cmp	edx, DWORD PTR _eShallowWater$[ebp]
	jne	SHORT $LN2@canHaveRes

; 2049 : 	{
; 2050 : 		if(!isAdjacentToLand())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@canHaveRes

; 2051 : 		{
; 2052 : 			return false;

	xor	al, al
	jmp	SHORT $LN26@canHaveRes
$LN2@canHaveRes:

; 2053 : 		}
; 2054 : 	}
; 2055 : 
; 2056 : 
; 2057 : 	return true;

	mov	al, 1
$LN26@canHaveRes:

; 2058 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z ENDP ; CvPlot::canHaveResource
_TEXT	ENDS
PUBLIC	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
PUBLIC	?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::canHaveImprovement
EXTRN	?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetPrereqNatureYield
EXTRN	?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetRequiresXAdjacentLand
EXTRN	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetFeatureMakesValid
EXTRN	?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetImprovementMakesValid
EXTRN	?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetTerrainMakesValid
EXTRN	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRiverSideMakesValid
EXTRN	?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsFreshWaterMakesValid
EXTRN	?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsWaterAdjacencyMakesValid
EXTRN	?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsHillsMakesValid
EXTRN	?IsCoastal@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsCoastal
EXTRN	?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresImprovement
EXTRN	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresFeature
EXTRN	?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
EXTRN	?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRequiresFlatlands
EXTRN	?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsNoFreshWater
EXTRN	?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceMakesValid
EXTRN	?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsBuildableOnResources
EXTRN	?isNoImprovement@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNoImprovement
EXTRN	?IsWater@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsWater
; Function compile flags: /Odtp
;	COMDAT ?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -280						; size = 4
$T238556 = -196						; size = 4
$T238552 = -192						; size = 4
$T238312 = -52						; size = 4
$T238308 = -48						; size = 4
_f$238301 = -42						; size = 1
_f$238292 = -41						; size = 1
$T238286 = -40						; size = 4
_f$238273 = -36						; size = 1
_f$238264 = -35						; size = 1
_f$238255 = -34						; size = 1
$T238249 = -33						; size = 1
_iAdjacentLand$222924 = -28				; size = 4
_pkImprovementInfo$ = -24				; size = 4
_thisResource$ = -20					; size = 4
_bValid$ = -14						; size = 1
_bIsFreshWater$ = -13					; size = 1
_iRequiredAdjacentLand$ = -12				; size = 4
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_eImprovement$ = 8					; size = 4
_eTeam$ = 12						; size = 4
___formal$ = 16						; size = 1
?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::canHaveImprovement, COMDAT
; _this$ = ecx

; 2063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2064 : 	CvPlot* pLoopPlot;
; 2065 : 	bool bValid;
; 2066 : 	int iI;
; 2067 : 
; 2068 : 	CvAssertMsg(eImprovement != NO_IMPROVEMENT, "Improvement is not assigned a valid value");
; 2069 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 2070 : 
; 2071 : 	CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$[ebp], eax

; 2072 : 	if(pkImprovementInfo == NULL)

	cmp	DWORD PTR _pkImprovementInfo$[ebp], 0
	jne	SHORT $LN48@canHaveImp

; 2073 : 	{
; 2074 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN48@canHaveImp:

; 2075 : 	}
; 2076 : 
; 2077 : 	bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 2078 : 
; 2079 : 	if(isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN56@canHaveImp

; 2080 : 	{
; 2081 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp

; 2082 : 	}
; 2083 : 
; 2084 : 	if(isImpassable() || isMountain())

$LN56@canHaveImp:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN45@canHaveImp
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN46@canHaveImp
$LN45@canHaveImp:

; 2085 : 	{
; 2086 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN46@canHaveImp:

; 2087 : 	}
; 2088 : 
; 2089 : 	if(pkImprovementInfo->IsWater() != isWater())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR $T238249[ebp], cl
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsWater
	movzx	edx, al
	movzx	eax, BYTE PTR $T238249[ebp]
	cmp	edx, eax
	je	SHORT $LN64@canHaveImp

; 2090 : 	{
; 2091 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp

; 2092 : 	}
; 2093 : 
; 2094 : 	if(getFeatureType() != NO_FEATURE)

$LN64@canHaveImp:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$238255[ebp], dl
	movsx	eax, BYTE PTR _f$238255[ebp]
	cmp	eax, -1
	je	SHORT $LN43@canHaveImp

; 2095 : 	{
; 2096 : 		if(GC.getFeatureInfo(getFeatureType())->isNoImprovement())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$238264[ebp], dl
	movsx	eax, BYTE PTR _f$238264[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isNoImprovement@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoImprovement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN43@canHaveImp

; 2097 : 		{
; 2098 : 			return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN43@canHaveImp:

; 2099 : 		}
; 2100 : 	}
; 2101 : 
; 2102 : 	ResourceTypes thisResource = getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _thisResource$[ebp], eax

; 2103 : 	// The functionality of this line is different in Civ 4: in that game a "Valid" Resource ALLOWS an Improvement on a Tile.  In Civ 5 this makes a Resource REQUIRE a certain Improvement
; 2104 : 	if(thisResource != NO_RESOURCE &&
; 2105 : 	        !pkImprovementInfo->IsBuildableOnResources() &&	// Some improvements can be built anywhere
; 2106 : 	        !pkImprovementInfo->IsImprovementResourceMakesValid(thisResource))

	cmp	DWORD PTR _thisResource$[ebp], -1
	je	SHORT $LN41@canHaveImp
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsBuildableOnResources@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsBuildableOnResources
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN41@canHaveImp
	mov	ecx, DWORD PTR _thisResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsImprovementResourceMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceMakesValid
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN41@canHaveImp

; 2107 : 	{
; 2108 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
	jmp	SHORT $LN40@canHaveImp
$LN41@canHaveImp:

; 2109 : 	}
; 2110 : 	// If there IS a valid resource here then set validity to true (because something has to)
; 2111 : 	else if(thisResource != NO_RESOURCE)

	cmp	DWORD PTR _thisResource$[ebp], -1
	je	SHORT $LN40@canHaveImp

; 2112 : 	{
; 2113 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN40@canHaveImp:

; 2114 : 	}
; 2115 : 
; 2116 : 	const bool bIsFreshWater = isFreshWater();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater
	mov	BYTE PTR _bIsFreshWater$[ebp], al

; 2117 : 
; 2118 : 	if(pkImprovementInfo->IsNoFreshWater() && bIsFreshWater)

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsNoFreshWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsNoFreshWater
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN38@canHaveImp
	movzx	ecx, BYTE PTR _bIsFreshWater$[ebp]
	test	ecx, ecx
	je	SHORT $LN38@canHaveImp

; 2119 : 	{
; 2120 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN38@canHaveImp:

; 2121 : 	}
; 2122 : 
; 2123 : 	if(pkImprovementInfo->IsRequiresFlatlands() && !isFlatlands())

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsRequiresFlatlands@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlands
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN37@canHaveImp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFlatlands@CvPlot@@QBE_NXZ		; CvPlot::isFlatlands
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN37@canHaveImp

; 2124 : 	{
; 2125 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN37@canHaveImp:

; 2126 : 	}
; 2127 : 
; 2128 : 	if(pkImprovementInfo->IsRequiresFlatlandsOrFreshWater() && !isFlatlands() && !bIsFreshWater)

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsRequiresFlatlandsOrFreshWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFlatlandsOrFreshWater
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN36@canHaveImp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFlatlands@CvPlot@@QBE_NXZ		; CvPlot::isFlatlands
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN36@canHaveImp
	movzx	eax, BYTE PTR _bIsFreshWater$[ebp]
	test	eax, eax
	jne	SHORT $LN36@canHaveImp

; 2129 : 	{
; 2130 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN36@canHaveImp:

; 2131 : 	}
; 2132 : 
; 2133 : 	if(pkImprovementInfo->IsRequiresFeature() && (getFeatureType() == NO_FEATURE))

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFeature
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@canHaveImp
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$238273[ebp], al
	movsx	ecx, BYTE PTR _f$238273[ebp]
	cmp	ecx, -1
	jne	SHORT $LN35@canHaveImp

; 2134 : 	{
; 2135 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN35@canHaveImp:

; 2136 : 	}
; 2137 : 
; 2138 : 	if(pkImprovementInfo->IsRequiresImprovement())

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsRequiresImprovement@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresImprovement
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@canHaveImp

; 2139 : 	{
; 2140 : 		if (getImprovementType() == NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	SHORT $LN33@canHaveImp

; 2141 : 		{
; 2142 : 			return false;

	xor	al, al
	jmp	$LN49@canHaveImp

; 2143 : 		}
; 2144 : 		else

	jmp	SHORT $LN34@canHaveImp
$LN33@canHaveImp:

; 2145 : 		{
; 2146 : 			bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN34@canHaveImp:

; 2147 : 		}
; 2148 : 	}
; 2149 : 
; 2150 : 	if(pkImprovementInfo->IsCoastal() && !isCoastalLand())

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsCoastal@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsCoastal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@canHaveImp
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN31@canHaveImp

; 2151 : 	{
; 2152 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN31@canHaveImp:

; 2153 : 	}
; 2154 : 
; 2155 : 	if(pkImprovementInfo->IsHillsMakesValid() && isHills())

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsHillsMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsHillsMakesValid
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN30@canHaveImp
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN30@canHaveImp

; 2156 : 	{
; 2157 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN30@canHaveImp:

; 2158 : 	}
; 2159 : 
; 2160 : 	if(pkImprovementInfo->IsWaterAdjacencyMakesValid())

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsWaterAdjacencyMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsWaterAdjacencyMakesValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@canHaveImp

; 2161 : 	{
; 2162 : 		if (isCoastalLand() || isFreshWater() || isRiver()) 

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@canHaveImp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN27@canHaveImp
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN28@canHaveImp
$LN27@canHaveImp:

; 2163 : 		{
; 2164 : 			bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2165 : 
; 2166 : 		}
; 2167 : 		else

	jmp	SHORT $LN29@canHaveImp
$LN28@canHaveImp:

; 2168 : 		{
; 2169 : 			bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN29@canHaveImp:

; 2170 : 		}
; 2171 : 	}
; 2172 : 
; 2173 : 	if(pkImprovementInfo->IsFreshWaterMakesValid() && bIsFreshWater)

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsFreshWaterMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsFreshWaterMakesValid
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN25@canHaveImp
	movzx	edx, BYTE PTR _bIsFreshWater$[ebp]
	test	edx, edx
	je	SHORT $LN25@canHaveImp

; 2174 : 	{
; 2175 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN25@canHaveImp:

; 2176 : 	}
; 2177 : 
; 2178 : 	if(pkImprovementInfo->IsRiverSideMakesValid() && isRiverSide())

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRiverSideMakesValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@canHaveImp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverSide@CvPlot@@QBE_NXZ		; CvPlot::isRiverSide
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@canHaveImp

; 2179 : 	{
; 2180 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN24@canHaveImp:

; 2181 : 	}
; 2182 : 
; 2183 : 	if(pkImprovementInfo->GetTerrainMakesValid(getTerrainType()))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T238286[ebp], eax
	mov	ecx, DWORD PTR $T238286[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?GetTerrainMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetTerrainMakesValid
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN23@canHaveImp

; 2184 : 	{
; 2185 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN23@canHaveImp:

; 2186 : 	}
; 2187 : 
; 2188 : 	if((getImprovementType() != NO_IMPROVEMENT) && pkImprovementInfo->GetImprovementMakesValid(getImprovementType()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN82@canHaveImp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?GetImprovementMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetImprovementMakesValid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN82@canHaveImp

; 2189 : 	{
; 2190 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2191 : 	}
; 2192 : 
; 2193 : 	if((getFeatureType() != NO_FEATURE) && pkImprovementInfo->GetFeatureMakesValid(getFeatureType()))

$LN82@canHaveImp:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$238292[ebp], dl
	movsx	eax, BYTE PTR _f$238292[ebp]
	cmp	eax, -1
	je	SHORT $LN21@canHaveImp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$238301[ebp], dl
	movsx	eax, BYTE PTR _f$238301[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@canHaveImp

; 2194 : 	{
; 2195 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN21@canHaveImp:

; 2196 : 	}
; 2197 : 
; 2198 : 	if(!bValid)

	movzx	edx, BYTE PTR _bValid$[ebp]
	test	edx, edx
	jne	SHORT $LN20@canHaveImp

; 2199 : 	{
; 2200 : 		return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN20@canHaveImp:

; 2201 : 	}
; 2202 : 
; 2203 : 	if(pkImprovementInfo->IsRiverSideMakesValid())

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsRiverSideMakesValid@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRiverSideMakesValid
	movzx	eax, al
	test	eax, eax
	je	$LN19@canHaveImp

; 2204 : 	{
; 2205 : 		bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 2206 : 
; 2207 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN18@canHaveImp
$LN17@canHaveImp:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN18@canHaveImp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN16@canHaveImp

; 2208 : 		{
; 2209 : 			pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T238308[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T238312[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238308[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238312[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 2210 : 
; 2211 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN15@canHaveImp

; 2212 : 			{
; 2213 : 				if(isRiverCrossing(directionXY(this, pLoopPlot)))

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@canHaveImp

; 2214 : 				{
; 2215 : 					if(pLoopPlot->getImprovementType() != eImprovement)

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eImprovement$[ebp]
	je	SHORT $LN15@canHaveImp

; 2216 : 					{
; 2217 : 						bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2218 : 						break;

	jmp	SHORT $LN16@canHaveImp
$LN15@canHaveImp:

; 2219 : 					}
; 2220 : 				}
; 2221 : 			}
; 2222 : 		}

	jmp	SHORT $LN17@canHaveImp
$LN16@canHaveImp:

; 2223 : 
; 2224 : 		if(!bValid)

	movzx	eax, BYTE PTR _bValid$[ebp]
	test	eax, eax
	jne	SHORT $LN19@canHaveImp

; 2225 : 		{
; 2226 : 			return false;

	xor	al, al
	jmp	$LN49@canHaveImp
$LN19@canHaveImp:

; 2227 : 		}
; 2228 : 	}
; 2229 : 
; 2230 : 	int iRequiredAdjacentLand = pkImprovementInfo->GetRequiresXAdjacentLand();

	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?GetRequiresXAdjacentLand@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetRequiresXAdjacentLand
	mov	DWORD PTR _iRequiredAdjacentLand$[ebp], eax

; 2231 : 	if (iRequiredAdjacentLand > -1)

	cmp	DWORD PTR _iRequiredAdjacentLand$[ebp], -1
	jle	$LN11@canHaveImp

; 2232 : 	{
; 2233 : 		int iAdjacentLand = 0;

	mov	DWORD PTR _iAdjacentLand$222924[ebp], 0

; 2234 : 
; 2235 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN10@canHaveImp
$LN9@canHaveImp:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN10@canHaveImp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN8@canHaveImp

; 2236 : 		{
; 2237 : 			pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T238552[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T238556[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238552[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238556[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 2238 : 
; 2239 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN7@canHaveImp

; 2240 : 			{
; 2241 : 				if (!pLoopPlot->isWater())

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN7@canHaveImp

; 2242 : 				{
; 2243 : 					iAdjacentLand++;

	mov	ecx, DWORD PTR _iAdjacentLand$222924[ebp]
	add	ecx, 1
	mov	DWORD PTR _iAdjacentLand$222924[ebp], ecx
$LN7@canHaveImp:

; 2244 : 				}
; 2245 : 			}
; 2246 : 		}

	jmp	SHORT $LN9@canHaveImp
$LN8@canHaveImp:

; 2247 : 
; 2248 : 		if (iAdjacentLand < iRequiredAdjacentLand)

	mov	edx, DWORD PTR _iAdjacentLand$222924[ebp]
	cmp	edx, DWORD PTR _iRequiredAdjacentLand$[ebp]
	jge	SHORT $LN11@canHaveImp

; 2249 : 		{
; 2250 : 			return false;

	xor	al, al
	jmp	SHORT $LN49@canHaveImp
$LN11@canHaveImp:

; 2251 : 		}
; 2252 : 	}
; 2253 : 
; 2254 : 	for(iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@canHaveImp
$LN3@canHaveImp:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@canHaveImp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN2@canHaveImp

; 2255 : 	{
; 2256 : 		if(calculateNatureYield(((YieldTypes)iI), eTeam) < pkImprovementInfo->GetPrereqNatureYield(iI))

	push	0
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	esi, eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?GetPrereqNatureYield@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetPrereqNatureYield
	cmp	esi, eax
	jge	SHORT $LN1@canHaveImp

; 2257 : 		{
; 2258 : 			return false;

	xor	al, al
	jmp	SHORT $LN49@canHaveImp
$LN1@canHaveImp:

; 2259 : 		}
; 2260 : 	}

	jmp	SHORT $LN3@canHaveImp
$LN2@canHaveImp:

; 2261 : 
; 2262 : 	return true;

	mov	al, 1
$LN49@canHaveImp:

; 2263 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::canHaveImprovement
_TEXT	ENDS
PUBLIC	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isAdjacentTeam
PUBLIC	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z	; CvPlot::getBuildProgress
PUBLIC	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
PUBLIC	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ	; CvPlot::getRouteType
PUBLIC	?IsRoutePillaged@CvPlot@@QBE_NXZ		; CvPlot::IsRoutePillaged
PUBLIC	?IsImprovementPillaged@CvPlot@@QBE_NXZ		; CvPlot::IsImprovementPillaged
PUBLIC	?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ; CvPlot::canBuild
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z:PROC	; CvBuildInfo::isFeatureRemove
EXTRN	?getValue@CvRouteInfo@@QBEHXZ:PROC		; CvRouteInfo::getValue
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?IsWater@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::IsWater
EXTRN	?getRoute@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getRoute
EXTRN	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsOnlyCityStateTerritory
EXTRN	?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsInAdjacentFriendly
EXTRN	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsIgnoreOwnership
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsNoTwoAdjacent
EXTRN	?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsAdjacentLuxury
EXTRN	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z:PROC ; finalImprovementUpgrade
EXTRN	?IsPermanent@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsPermanent
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ:PROC	; CvBuildInfo::IsRemoveRoute
EXTRN	?isRepair@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::isRepair
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
; Function compile flags: /Odtp
;	COMDAT ?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z
_TEXT	SEGMENT
_this$ = -232						; size = 4
$T239096 = -228						; size = 4
_playerID$239093 = -224					; size = 4
$T239079 = -220						; size = 4
_playerID$239076 = -216					; size = 4
_f$239062 = -210					; size = 1
_f$239053 = -209					; size = 1
$T239041 = -208						; size = 4
_playerID$239038 = -204					; size = 4
$T239024 = -200						; size = 4
$T239020 = -196						; size = 4
$T239016 = -192						; size = 4
_playerID$239013 = -188					; size = 4
$T238999 = -184						; size = 4
_playerID$238996 = -180					; size = 4
$T238982 = -176						; size = 4
_playerID$238979 = -172					; size = 4
$T238785 = -88						; size = 4
$T238781 = -84						; size = 4
$T238758 = -76						; size = 4
_pkPlotRoute$223016 = -72				; size = 4
_pkBuildRoute$223017 = -68				; size = 4
_bCityStateTerritory$223006 = -61			; size = 1
_eAdjacentImprovement$222991 = -60			; size = 4
_iBuildProgress$222993 = -56				; size = 4
_pkResourceInfo$222988 = -52				; size = 4
_eResource$222986 = -48					; size = 4
_pAdjacentPlot$222982 = -44				; size = 4
_iI$222978 = -40					; size = 4
_bLuxuryRequirementMet$222977 = -34			; size = 1
_bHasLuxuryRequirement$222973 = -33			; size = 1
_pkImprovement$222972 = -32				; size = 4
_bHasNoAdjacencyRequirement$222974 = -25		; size = 1
_eFinalImprovementType$ = -24				; size = 4
_thisBuildInfo$ = -20					; size = 4
_bValid$ = -13						; size = 1
_eImprovement$ = -12					; size = 4
_eRoute$ = -8						; size = 4
_eTeam$ = -4						; size = 4
_eBuild$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
_bTestVisible$ = 16					; size = 1
_bTestPlotOwner$ = 20					; size = 1
?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z PROC ; CvPlot::canBuild, COMDAT
; _this$ = ecx

; 2268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2269 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T238758[ebp], eax
	mov	ecx, DWORD PTR $T238758[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 2270 : 
; 2271 : 	ImprovementTypes eImprovement;
; 2272 : 	ImprovementTypes eFinalImprovementType;
; 2273 : 	RouteTypes eRoute;
; 2274 : 	bool bValid;
; 2275 : 
; 2276 : 	// Can't build nothing!
; 2277 : 	if(eBuild == NO_BUILD)

	cmp	DWORD PTR _eBuild$[ebp], -1
	jne	SHORT $LN61@canBuild

; 2278 : 	{
; 2279 : 		return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN61@canBuild:

; 2280 : 	}
; 2281 : 
; 2282 : 	bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 2283 : 
; 2284 : 	// Repairing an Improvement that's been pillaged
; 2285 : 	CvBuildInfo& thisBuildInfo = *GC.getBuildInfo(eBuild);

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _thisBuildInfo$[ebp], eax

; 2286 : 	if(thisBuildInfo.isRepair())

	mov	ecx, DWORD PTR _thisBuildInfo$[ebp]
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN60@canBuild

; 2287 : 	{
; 2288 : 		if(IsImprovementPillaged() || IsRoutePillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN58@canBuild
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN59@canBuild
$LN58@canBuild:

; 2289 : 		{
; 2290 : 			bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2291 : 		}
; 2292 : 		else

	jmp	SHORT $LN60@canBuild
$LN59@canBuild:

; 2293 : 		{
; 2294 : 			return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN60@canBuild:

; 2295 : 		}
; 2296 : 	}
; 2297 : 
; 2298 : 	if(thisBuildInfo.IsRemoveRoute())

	mov	ecx, DWORD PTR _thisBuildInfo$[ebp]
	call	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ	; CvBuildInfo::IsRemoveRoute
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN56@canBuild

; 2299 : 	{
; 2300 : 		if(!getPlotCity() && getRouteType() != NO_ROUTE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	jne	SHORT $LN55@canBuild
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN55@canBuild

; 2301 : 		{
; 2302 : 			if(getOwner() == ePlayer)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN77@canBuild

; 2303 : 			{
; 2304 : 				bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
	jmp	SHORT $LN53@canBuild

; 2305 : 			}
; 2306 : 			else if(getOwner() == NO_PLAYER && GetPlayerResponsibleForRoute() == ePlayer)

$LN77@canBuild:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	jne	SHORT $LN52@canBuild
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN52@canBuild

; 2307 : 			{
; 2308 : 				bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2309 : 			}
; 2310 : 			else

	jmp	SHORT $LN53@canBuild
$LN52@canBuild:

; 2311 : 			{
; 2312 : 				return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN53@canBuild:

; 2313 : 			}
; 2314 : 		}
; 2315 : 		else

	jmp	SHORT $LN56@canBuild
$LN55@canBuild:

; 2316 : 		{
; 2317 : 			return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN56@canBuild:

; 2318 : 		}
; 2319 : 	}
; 2320 : 
; 2321 : 	eImprovement = ((ImprovementTypes)(thisBuildInfo.getImprovement()));

	mov	ecx, DWORD PTR _thisBuildInfo$[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$[ebp], eax

; 2322 : 
; 2323 : 	// Improvement
; 2324 : 	if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	$LN49@canBuild

; 2325 : 	{
; 2326 : 		// Player must be able to build this Improvement
; 2327 : 		if(!canHaveImprovement(eImprovement, eTeam, bTestVisible))

	movzx	eax, BYTE PTR _bTestVisible$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::canHaveImprovement
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN48@canBuild

; 2328 : 		{
; 2329 : 			return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN48@canBuild:

; 2330 : 		}
; 2331 : 
; 2332 : 		// Already an improvement here
; 2333 : 		if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN47@canBuild

; 2334 : 		{
; 2335 : 
; 2336 : 			if(GC.getImprovementInfo(getImprovementType())->IsPermanent())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsPermanent@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsPermanent
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN46@canBuild

; 2337 : 			{
; 2338 : 				return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN46@canBuild:

; 2339 : 			}
; 2340 : 
; 2341 : 			if(getImprovementType() == eImprovement)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eImprovement$[ebp]
	jne	SHORT $LN45@canBuild

; 2342 : 			{
; 2343 : 				return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN45@canBuild:

; 2344 : 			}
; 2345 : 
; 2346 : 			eFinalImprovementType = finalImprovementUpgrade(getImprovementType());

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	call	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ; finalImprovementUpgrade
	add	esp, 8
	mov	DWORD PTR _eFinalImprovementType$[ebp], eax

; 2347 : 
; 2348 : 			if(eFinalImprovementType != NO_IMPROVEMENT)

	cmp	DWORD PTR _eFinalImprovementType$[ebp], -1
	je	SHORT $LN47@canBuild

; 2349 : 			{
; 2350 : 				if(eFinalImprovementType == finalImprovementUpgrade(eImprovement))

	push	0
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	call	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ; finalImprovementUpgrade
	add	esp, 8
	cmp	DWORD PTR _eFinalImprovementType$[ebp], eax
	jne	SHORT $LN47@canBuild

; 2351 : 				{
; 2352 : 					if(!IsImprovementPillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN47@canBuild

; 2353 : 					{
; 2354 : 						return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN47@canBuild:

; 2355 : 					}
; 2356 : 				}
; 2357 : 			}
; 2358 : 		}
; 2359 : 
; 2360 : #ifdef AUI_WARNING_FIXES
; 2361 : 		const CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);
; 2362 : 		if (pkImprovement)
; 2363 : 		{
; 2364 : #endif
; 2365 : 
; 2366 : 		// Requirements on adjacent plots?
; 2367 : 		if (!bTestVisible)

	movzx	ecx, BYTE PTR _bTestVisible$[ebp]
	test	ecx, ecx
	jne	$LN41@canBuild

; 2368 : 		{
; 2369 : #ifdef AUI_WARNING_FIXES
; 2370 : 			bool bHasLuxuryRequirement = pkImprovement->IsAdjacentLuxury();
; 2371 : 			bool bHasNoAdjacencyRequirement = pkImprovement->IsNoTwoAdjacent();
; 2372 : 			if (bHasLuxuryRequirement || bHasNoAdjacencyRequirement)
; 2373 : #else
; 2374 : 			CvImprovementEntry *pkImprovement = GC.getImprovementInfo(eImprovement);

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovement$222972[ebp], eax

; 2375 : 			bool bHasLuxuryRequirement = pkImprovement->IsAdjacentLuxury();

	mov	ecx, DWORD PTR _pkImprovement$222972[ebp]
	call	?IsAdjacentLuxury@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsAdjacentLuxury
	mov	BYTE PTR _bHasLuxuryRequirement$222973[ebp], al

; 2376 : 			bool bHasNoAdjacencyRequirement = pkImprovement->IsNoTwoAdjacent();

	mov	ecx, DWORD PTR _pkImprovement$222972[ebp]
	call	?IsNoTwoAdjacent@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsNoTwoAdjacent
	mov	BYTE PTR _bHasNoAdjacencyRequirement$222974[ebp], al

; 2377 : 			if (pkImprovement && (bHasLuxuryRequirement || bHasNoAdjacencyRequirement))

	cmp	DWORD PTR _pkImprovement$222972[ebp], 0
	je	$LN41@canBuild
	movzx	eax, BYTE PTR _bHasLuxuryRequirement$222973[ebp]
	test	eax, eax
	jne	SHORT $LN39@canBuild
	movzx	ecx, BYTE PTR _bHasNoAdjacencyRequirement$222974[ebp]
	test	ecx, ecx
	je	$LN41@canBuild
$LN39@canBuild:

; 2378 : #endif
; 2379 : 			{
; 2380 : 				bool bLuxuryRequirementMet = !bHasLuxuryRequirement;

	movzx	edx, BYTE PTR _bHasLuxuryRequirement$222973[ebp]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	mov	BYTE PTR _bLuxuryRequirementMet$222977[ebp], dl

; 2381 : 				for (int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$222978[ebp], 0
	jmp	SHORT $LN38@canBuild
$LN37@canBuild:
	mov	eax, DWORD PTR _iI$222978[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222978[ebp], eax
$LN38@canBuild:
	cmp	DWORD PTR _iI$222978[ebp], 6
	jge	$LN36@canBuild

; 2382 : 				{
; 2383 : 					CvPlot *pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T238781[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T238785[ebp], ecx
	mov	edx, DWORD PTR _iI$222978[ebp]
	push	edx
	mov	eax, DWORD PTR $T238781[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238785[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$222982[ebp], eax

; 2384 : 					if (pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$222982[ebp], 0
	je	$LN35@canBuild

; 2385 : 					{
; 2386 : #ifdef AUI_WARNING_FIXES
; 2387 : 						if (!bLuxuryRequirementMet)
; 2388 : #else
; 2389 : 						if (bHasLuxuryRequirement)

	movzx	edx, BYTE PTR _bHasLuxuryRequirement$222973[ebp]
	test	edx, edx
	je	SHORT $LN34@canBuild

; 2390 : #endif
; 2391 : 						{
; 2392 : 							ResourceTypes eResource = pAdjacentPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pAdjacentPlot$222982[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$222986[ebp], eax

; 2393 : 							if (eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$222986[ebp], -1
	je	SHORT $LN34@canBuild

; 2394 : 							{
; 2395 : 								CvResourceInfo *pkResourceInfo = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$222986[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$222988[ebp], eax

; 2396 : 								if (pkResourceInfo && pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	cmp	DWORD PTR _pkResourceInfo$222988[ebp], 0
	je	SHORT $LN34@canBuild
	mov	ecx, DWORD PTR _pkResourceInfo$222988[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN34@canBuild

; 2397 : 								{
; 2398 : 									bLuxuryRequirementMet = true;

	mov	BYTE PTR _bLuxuryRequirementMet$222977[ebp], 1
$LN34@canBuild:

; 2399 : #ifdef AUI_WARNING_FIXES
; 2400 : 									if (!bHasNoAdjacencyRequirement)
; 2401 : 										break;
; 2402 : #endif
; 2403 : 								}
; 2404 : 							}
; 2405 : 						}
; 2406 : 						if (bHasNoAdjacencyRequirement)

	movzx	ecx, BYTE PTR _bHasNoAdjacencyRequirement$222974[ebp]
	test	ecx, ecx
	je	SHORT $LN35@canBuild

; 2407 : 						{
; 2408 : 							ImprovementTypes eAdjacentImprovement =  pAdjacentPlot->getImprovementType();

	mov	ecx, DWORD PTR _pAdjacentPlot$222982[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eAdjacentImprovement$222991[ebp], eax

; 2409 : 							if (eAdjacentImprovement != NO_IMPROVEMENT && eAdjacentImprovement == eImprovement)

	cmp	DWORD PTR _eAdjacentImprovement$222991[ebp], -1
	je	SHORT $LN30@canBuild
	mov	edx, DWORD PTR _eAdjacentImprovement$222991[ebp]
	cmp	edx, DWORD PTR _eImprovement$[ebp]
	jne	SHORT $LN30@canBuild

; 2410 : 							{
; 2411 : 								return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN30@canBuild:

; 2412 : 							}
; 2413 : 							int iBuildProgress = pAdjacentPlot->getBuildProgress(eBuild);

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdjacentPlot$222982[ebp]
	call	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress
	mov	DWORD PTR _iBuildProgress$222993[ebp], eax

; 2414 : 							if (iBuildProgress > 0)

	cmp	DWORD PTR _iBuildProgress$222993[ebp], 0
	jle	SHORT $LN35@canBuild

; 2415 : 							{
; 2416 : 								return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN35@canBuild:

; 2417 : 							}
; 2418 : 						}
; 2419 : 					}
; 2420 : 				}

	jmp	$LN37@canBuild
$LN36@canBuild:

; 2421 : 				if (bHasLuxuryRequirement && !bLuxuryRequirementMet)

	movzx	ecx, BYTE PTR _bHasLuxuryRequirement$222973[ebp]
	test	ecx, ecx
	je	SHORT $LN41@canBuild
	movzx	edx, BYTE PTR _bLuxuryRequirementMet$222977[ebp]
	test	edx, edx
	jne	SHORT $LN41@canBuild

; 2422 : 				{
; 2423 : 					return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN41@canBuild:

; 2424 : 				}
; 2425 : 			}
; 2426 : #ifdef AUI_WARNING_FIXES
; 2427 : 			if (!pkImprovement->IsIgnoreOwnership())
; 2428 : #else
; 2429 : 		}
; 2430 : 
; 2431 : 		if(!bTestVisible)

	movzx	eax, BYTE PTR _bTestVisible$[ebp]
	test	eax, eax
	jne	$LN27@canBuild

; 2432 : 		{
; 2433 : 			if(!GC.getImprovementInfo(eImprovement)->IsIgnoreOwnership())

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsIgnoreOwnership
	movzx	edx, al
	test	edx, edx
	jne	$LN27@canBuild

; 2434 : #endif
; 2435 : 			{
; 2436 : 				// Gifts for minors can ignore borders requirements
; 2437 : 				if(bTestPlotOwner)

	movzx	eax, BYTE PTR _bTestPlotOwner$[ebp]
	test	eax, eax
	je	$LN27@canBuild

; 2438 : 				{
; 2439 : 					// Outside Borders - Can be built in or outside our lands, but not in other lands
; 2440 : #ifdef AUI_WARNING_FIXES
; 2441 : 					if (pkImprovement->IsOutsideBorders())
; 2442 : #else
; 2443 : 					if(GC.getImprovementInfo(eImprovement)->IsOutsideBorders())

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOutsideBorders@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOutsideBorders
	movzx	edx, al
	test	edx, edx
	je	$LN24@canBuild

; 2444 : #endif
; 2445 : 					{
; 2446 : 						if (getTeam() != eTeam && getTeam() != NO_TEAM)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$238979[ebp], ecx
	cmp	DWORD PTR _playerID$238979[ebp], -1
	je	SHORT $LN160@canBuild
	mov	edx, DWORD PTR _playerID$238979[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238982[ebp], eax
	jmp	SHORT $LN161@canBuild
	jmp	SHORT $LN161@canBuild
$LN160@canBuild:
	mov	DWORD PTR $T238982[ebp], -1
$LN161@canBuild:
	mov	eax, DWORD PTR $T238982[ebp]
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN23@canBuild
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$238996[ebp], edx
	cmp	DWORD PTR _playerID$238996[ebp], -1
	je	SHORT $LN168@canBuild
	mov	eax, DWORD PTR _playerID$238996[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238999[ebp], eax
	jmp	SHORT $LN169@canBuild
	jmp	SHORT $LN169@canBuild
$LN168@canBuild:
	mov	DWORD PTR $T238999[ebp], -1
$LN169@canBuild:
	cmp	DWORD PTR $T238999[ebp], -1
	je	SHORT $LN23@canBuild

; 2447 : 						{
; 2448 : 							return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN23@canBuild:

; 2449 : 						}
; 2450 : 					}

	jmp	$LN27@canBuild
$LN24@canBuild:

; 2451 : 					// In Adjacent Friendly - Can be built in or adjacent to our lands
; 2452 : #ifdef AUI_WARNING_FIXES
; 2453 : 					else if (pkImprovement->IsInAdjacentFriendly())
; 2454 : #else
; 2455 : 					else if (GC.getImprovementInfo(eImprovement)->IsInAdjacentFriendly())

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsInAdjacentFriendly@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsInAdjacentFriendly
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@canBuild

; 2456 : #endif
; 2457 : 					{
; 2458 : 						if (getTeam() != eTeam && !isAdjacentTeam(eTeam, false))

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$239013[ebp], ecx
	cmp	DWORD PTR _playerID$239013[ebp], -1
	je	SHORT $LN176@canBuild
	mov	edx, DWORD PTR _playerID$239013[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239016[ebp], eax
	jmp	SHORT $LN177@canBuild
	jmp	SHORT $LN177@canBuild
$LN176@canBuild:
	mov	DWORD PTR $T239016[ebp], -1
$LN177@canBuild:
	mov	eax, DWORD PTR $T239016[ebp]
	cmp	eax, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN20@canBuild
	push	0
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentTeam
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@canBuild

; 2459 : 						{
; 2460 : 							return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN20@canBuild:

; 2461 : 						}
; 2462 : 					}

	jmp	$LN27@canBuild
$LN21@canBuild:

; 2463 : 					// Only City State Territory - Can only be built in City-State territory (not our own lands)
; 2464 : #ifdef AUI_WARNING_FIXES
; 2465 : 					else if (pkImprovement->IsOnlyCityStateTerritory())
; 2466 : 					{
; 2467 : 						if (!isOwned() || !GET_PLAYER(getOwner()).isMinorCiv())
; 2468 : #else
; 2469 : 					else if (GC.getImprovementInfo(eImprovement)->IsOnlyCityStateTerritory())

	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOnlyCityStateTerritory
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN191@canBuild

; 2470 : 					{
; 2471 : 						bool bCityStateTerritory = false;

	mov	BYTE PTR _bCityStateTerritory$223006[ebp], 0

; 2472 : 						if (isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN17@canBuild

; 2473 : 						{
; 2474 : 							if (GET_PLAYER(getOwner()).isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T239020[ebp], ecx
	mov	edx, DWORD PTR $T239020[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239024[ebp], edx
	mov	ecx, DWORD PTR $T239024[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@canBuild

; 2475 : 							{
; 2476 : 								bCityStateTerritory = true;

	mov	BYTE PTR _bCityStateTerritory$223006[ebp], 1
$LN17@canBuild:

; 2477 : 							}
; 2478 : 						}
; 2479 : 
; 2480 : 						if (!bCityStateTerritory)

	movzx	ecx, BYTE PTR _bCityStateTerritory$223006[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@canBuild

; 2481 : #endif
; 2482 : 						{
; 2483 : 							return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN15@canBuild:

; 2484 : 						}
; 2485 : 					}

	jmp	SHORT $LN27@canBuild

; 2486 : 					else if(getTeam() != eTeam) 

$LN191@canBuild:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$239038[ebp], eax
	cmp	DWORD PTR _playerID$239038[ebp], -1
	je	SHORT $LN188@canBuild
	mov	ecx, DWORD PTR _playerID$239038[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239041[ebp], eax
	jmp	SHORT $LN189@canBuild
	jmp	SHORT $LN189@canBuild
$LN188@canBuild:
	mov	DWORD PTR $T239041[ebp], -1
$LN189@canBuild:
	mov	edx, DWORD PTR $T239041[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN27@canBuild

; 2487 : 					{//only buildable in own culture
; 2488 : 						return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN27@canBuild:

; 2489 : 					}
; 2490 : 				}
; 2491 : 			}
; 2492 : 		}
; 2493 : 
; 2494 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN49@canBuild:

; 2495 : #ifdef AUI_WARNING_FIXES
; 2496 : 		}
; 2497 : #endif
; 2498 : 	}
; 2499 : 
; 2500 : 	eRoute = ((RouteTypes)(GC.getBuildInfo(eBuild)->getRoute()));

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eRoute$[ebp], eax

; 2501 : 
; 2502 : 	// Route
; 2503 : 	if(eRoute != NO_ROUTE)

	cmp	DWORD PTR _eRoute$[ebp], -1
	je	$LN199@canBuild

; 2504 : 	{
; 2505 : 		if(getRouteType() != NO_ROUTE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	$LN11@canBuild

; 2506 : 		{
; 2507 : 			if (isWater() && !thisBuildInfo.IsWater())

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@canBuild
	mov	ecx, DWORD PTR _thisBuildInfo$[ebp]
	call	?IsWater@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::IsWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@canBuild

; 2508 : 			{
; 2509 : 				return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN10@canBuild:

; 2510 : 			}
; 2511 : 
; 2512 : 			CvRouteInfo* pkPlotRoute = GC.getRouteInfo(getRouteType());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkPlotRoute$223016[ebp], eax

; 2513 : 			CvRouteInfo* pkBuildRoute = GC.getRouteInfo(eRoute);

	mov	eax, DWORD PTR _eRoute$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkBuildRoute$223017[ebp], eax

; 2514 : 			if(pkPlotRoute && pkBuildRoute)

	cmp	DWORD PTR _pkPlotRoute$223016[ebp], 0
	je	SHORT $LN11@canBuild
	cmp	DWORD PTR _pkBuildRoute$223017[ebp], 0
	je	SHORT $LN11@canBuild

; 2515 : 			{
; 2516 : 				// Can't build an older, less useful Route over the top of an existing one
; 2517 : 				if(pkPlotRoute->getValue() >= pkBuildRoute->getValue())

	mov	ecx, DWORD PTR _pkPlotRoute$223016[ebp]
	call	?getValue@CvRouteInfo@@QBEHXZ		; CvRouteInfo::getValue
	mov	esi, eax
	mov	ecx, DWORD PTR _pkBuildRoute$223017[ebp]
	call	?getValue@CvRouteInfo@@QBEHXZ		; CvRouteInfo::getValue
	cmp	esi, eax
	jl	SHORT $LN11@canBuild

; 2518 : 				{
; 2519 : 					if(!IsRoutePillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@canBuild

; 2520 : 					{
; 2521 : 						return false;

	xor	al, al
	jmp	$LN62@canBuild
$LN11@canBuild:

; 2522 : 					}
; 2523 : 				}
; 2524 : 			}
; 2525 : 		}
; 2526 : 
; 2527 : 		bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 2528 : 	}
; 2529 : 
; 2530 : 	// In general, cannot clear features in the lands of players that aren't on our team or that we're at war with
; 2531 : 	if(getFeatureType() != NO_FEATURE)

$LN199@canBuild:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$239053[ebp], al
	movsx	ecx, BYTE PTR _f$239053[ebp]
	cmp	ecx, -1
	je	$LN6@canBuild

; 2532 : 	{
; 2533 : 		if(GC.getBuildInfo(eBuild)->isFeatureRemove(getFeatureType()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$239062[ebp], al
	movsx	ecx, BYTE PTR _f$239062[ebp]
	push	ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	eax, al
	test	eax, eax
	je	$LN6@canBuild

; 2534 : 		{
; 2535 : 			if(bTestPlotOwner)

	movzx	ecx, BYTE PTR _bTestPlotOwner$[ebp]
	test	ecx, ecx
	je	$LN4@canBuild

; 2536 : 			{
; 2537 : 				if(isOwned() && (eTeam != getTeam()) && !atWar(eTeam, getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	$LN4@canBuild
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$239076[ebp], ecx
	cmp	DWORD PTR _playerID$239076[ebp], -1
	je	SHORT $LN206@canBuild
	mov	edx, DWORD PTR _playerID$239076[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239079[ebp], eax
	jmp	SHORT $LN207@canBuild
	jmp	SHORT $LN207@canBuild
$LN206@canBuild:
	mov	DWORD PTR $T239079[ebp], -1
$LN207@canBuild:
	mov	eax, DWORD PTR _eTeam$[ebp]
	cmp	eax, DWORD PTR $T239079[ebp]
	je	$LN4@canBuild
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$239093[ebp], edx
	cmp	DWORD PTR _playerID$239093[ebp], -1
	je	SHORT $LN214@canBuild
	mov	eax, DWORD PTR _playerID$239093[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239096[ebp], eax
	jmp	SHORT $LN215@canBuild
	jmp	SHORT $LN215@canBuild
$LN214@canBuild:
	mov	DWORD PTR $T239096[ebp], -1
$LN215@canBuild:
	mov	ecx, DWORD PTR $T239096[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@canBuild

; 2538 : 				{
; 2539 : 					if (eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	jne	SHORT $LN2@canBuild

; 2540 : 					{
; 2541 : 						return false;

	xor	al, al
	jmp	SHORT $LN62@canBuild
$LN2@canBuild:

; 2542 : 					}
; 2543 : 
; 2544 : 					// Some improvements are exceptions
; 2545 : #ifdef AUI_WARNING_FIXES
; 2546 : 					CvImprovementEntry *pkImprovement = GC.getImprovementInfo(eImprovement);
; 2547 : 					if (pkImprovement && !pkImprovement->IsIgnoreOwnership() && !pkImprovement->IsOnlyCityStateTerritory())
; 2548 : #else
; 2549 : 					if (!GC.getImprovementInfo(eImprovement)->IsIgnoreOwnership() &&
; 2550 : 						!GC.getImprovementInfo(eImprovement)->IsOnlyCityStateTerritory())

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsIgnoreOwnership@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsIgnoreOwnership
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@canBuild
	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsOnlyCityStateTerritory@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsOnlyCityStateTerritory
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@canBuild

; 2551 : #endif
; 2552 : 					{
; 2553 : 						return false;

	xor	al, al
	jmp	SHORT $LN62@canBuild
$LN4@canBuild:

; 2554 : 					}
; 2555 : 				}
; 2556 : 			}
; 2557 : 
; 2558 : 			bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN6@canBuild:

; 2559 : 		}
; 2560 : 	}
; 2561 : 
; 2562 : 	return bValid;

	mov	al, BYTE PTR _bValid$[ebp]
$LN62@canBuild:

; 2563 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ENDP ; CvPlot::canBuild
_TEXT	ENDS
PUBLIC	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
EXTRN	?getBuildPercent@CvEraInfo@@QBEHXZ:PROC		; CvEraInfo::getBuildPercent
EXTRN	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ:PROC ; CvGame::getStartEraInfo
EXTRN	?getBuildPercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getBuildPercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getBuildModifier@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getBuildModifier
EXTRN	?getFeatureTime@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureTime
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z:PROC ; CvTeam::getBuildTimeChange
EXTRN	?getTime@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTime
; Function compile flags: /Odtp
;	COMDAT ?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv200 = -64						; size = 4
_this$ = -60						; size = 4
$T239155 = -56						; size = 4
$T239151 = -52						; size = 4
$T239144 = -48						; size = 4
$T239138 = -44						; size = 4
_f$239134 = -38						; size = 1
_f$239125 = -37						; size = 1
$T239116 = -36						; size = 4
$T239104 = -32						; size = 4
$T239100 = -28						; size = 4
$T239099 = -24						; size = 4
_pkBuildInfo$223043 = -20				; size = 4
_iBuildLoop$223039 = -16				; size = 4
_eRoute$223037 = -12					; size = 4
_eTeam$223034 = -8					; size = 4
_iTime$ = -4						; size = 4
_eBuild$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::getBuildTime, COMDAT
; _this$ = ecx

; 2568 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 2569 : 	int iTime;
; 2570 : 
; 2571 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 2572 : 
; 2573 : 	iTime = GC.getBuildInfo(eBuild)->getTime();

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTime@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getTime
	mov	DWORD PTR _iTime$[ebp], eax

; 2574 : 	if (ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	SHORT $LN11@getBuildTi

; 2575 : 	{
; 2576 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239104[ebp], ecx
	mov	edx, DWORD PTR $T239104[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223034[ebp], eax

; 2577 : 		if (eTeam != NO_TEAM)

	cmp	DWORD PTR _eTeam$223034[ebp], -1
	je	SHORT $LN11@getBuildTi

; 2578 : 		{
; 2579 : 			iTime += GET_TEAM(eTeam).getBuildTimeChange(eBuild);

	mov	ecx, DWORD PTR _eTeam$223034[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T239116[ebp], ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239116[ebp]
	call	?getBuildTimeChange@CvTeam@@QBEHW4BuildTypes@@@Z ; CvTeam::getBuildTimeChange
	add	eax, DWORD PTR _iTime$[ebp]
	mov	DWORD PTR _iTime$[ebp], eax
$LN11@getBuildTi:

; 2580 : 		}
; 2581 : 	}
; 2582 : 
; 2583 : 	// Repair is either 3 turns or the original build time, whichever is shorter
; 2584 : 	if(GC.getBuildInfo(eBuild)->isRepair())

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@getBuildTi

; 2585 : 	{
; 2586 : 		RouteTypes eRoute = getRouteType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eRoute$223037[ebp], eax

; 2587 : 
; 2588 : 		if(eRoute != NO_ROUTE)

	cmp	DWORD PTR _eRoute$223037[ebp], -1
	je	SHORT $LN24@getBuildTi

; 2589 : 		{
; 2590 : #ifdef AUI_WARNING_FIXES
; 2591 : 			for (uint iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)
; 2592 : #else
; 2593 : 			for(int iBuildLoop = 0; iBuildLoop < GC.getNumBuildInfos(); iBuildLoop++)

	mov	DWORD PTR _iBuildLoop$223039[ebp], 0
	jmp	SHORT $LN7@getBuildTi
$LN6@getBuildTi:
	mov	edx, DWORD PTR _iBuildLoop$223039[ebp]
	add	edx, 1
	mov	DWORD PTR _iBuildLoop$223039[ebp], edx
$LN7@getBuildTi:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildLoop$223039[ebp], eax
	jge	SHORT $LN24@getBuildTi

; 2594 : #endif
; 2595 : 			{
; 2596 : 				CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iBuildLoop);

	mov	eax, DWORD PTR _iBuildLoop$223039[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$223043[ebp], eax

; 2597 : 				if(!pkBuildInfo)

	cmp	DWORD PTR _pkBuildInfo$223043[ebp], 0
	jne	SHORT $LN4@getBuildTi

; 2598 : 				{
; 2599 : 					continue;

	jmp	SHORT $LN6@getBuildTi
$LN4@getBuildTi:

; 2600 : 				}
; 2601 : 
; 2602 : 				if(pkBuildInfo->getRoute() == eRoute)

	mov	ecx, DWORD PTR _pkBuildInfo$223043[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, DWORD PTR _eRoute$223037[ebp]
	jne	SHORT $LN3@getBuildTi

; 2603 : 				{
; 2604 : 					if(pkBuildInfo->getTime() < iTime)

	mov	ecx, DWORD PTR _pkBuildInfo$223043[ebp]
	call	?getTime@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getTime
	cmp	eax, DWORD PTR _iTime$[ebp]
	jge	SHORT $LN3@getBuildTi

; 2605 : 					{
; 2606 : 						iTime = pkBuildInfo->getTime();

	mov	ecx, DWORD PTR _pkBuildInfo$223043[ebp]
	call	?getTime@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getTime
	mov	DWORD PTR _iTime$[ebp], eax
$LN3@getBuildTi:

; 2607 : 					}
; 2608 : 				}
; 2609 : 			}

	jmp	SHORT $LN6@getBuildTi

; 2610 : 		}
; 2611 : 	}
; 2612 : 	// End Repair time mod
; 2613 : 
; 2614 : 	if(getFeatureType() != NO_FEATURE)

$LN24@getBuildTi:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$239125[ebp], dl
	movsx	eax, BYTE PTR _f$239125[ebp]
	cmp	eax, -1
	je	SHORT $LN1@getBuildTi

; 2615 : 	{
; 2616 : 		iTime += GC.getBuildInfo(eBuild)->getFeatureTime(getFeatureType());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$239134[ebp], dl
	movsx	eax, BYTE PTR _f$239134[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureTime@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureTime
	add	eax, DWORD PTR _iTime$[ebp]
	mov	DWORD PTR _iTime$[ebp], eax
$LN1@getBuildTi:

; 2617 : 	}
; 2618 : 
; 2619 : 	iTime *= std::max(0, (GC.getTerrainInfo(getTerrainType())->getBuildModifier() + 100));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T239138[ebp], eax
	mov	ecx, DWORD PTR $T239138[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getBuildModifier@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getBuildModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T239099[ebp], eax
	mov	DWORD PTR $T239100[ebp], 0
	mov	edx, DWORD PTR $T239100[ebp]
	cmp	edx, DWORD PTR $T239099[ebp]
	jge	SHORT $LN34@getBuildTi
	lea	eax, DWORD PTR $T239099[ebp]
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN35@getBuildTi
$LN34@getBuildTi:
	lea	ecx, DWORD PTR $T239100[ebp]
	mov	DWORD PTR tv200[ebp], ecx
$LN35@getBuildTi:
	mov	edx, DWORD PTR tv200[ebp]
	mov	DWORD PTR $T239144[ebp], edx
	mov	eax, DWORD PTR $T239144[ebp]
	mov	ecx, DWORD PTR _iTime$[ebp]
	imul	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iTime$[ebp], ecx

; 2620 : 	iTime /= 100;

	mov	eax, DWORD PTR _iTime$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iTime$[ebp], eax

; 2621 : 
; 2622 : 	iTime *= GC.getGame().getGameSpeedInfo().getBuildPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239151[ebp], edx
	mov	ecx, DWORD PTR $T239151[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getBuildPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getBuildPercent
	imul	eax, DWORD PTR _iTime$[ebp]
	mov	DWORD PTR _iTime$[ebp], eax

; 2623 : 	iTime /= 100;

	mov	eax, DWORD PTR _iTime$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iTime$[ebp], eax

; 2624 : 
; 2625 : 	iTime *= GC.getGame().getStartEraInfo().getBuildPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239155[ebp], edx
	mov	ecx, DWORD PTR $T239155[ebp]
	call	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ ; CvGame::getStartEraInfo
	mov	ecx, eax
	call	?getBuildPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getBuildPercent
	imul	eax, DWORD PTR _iTime$[ebp]
	mov	DWORD PTR _iTime$[ebp], eax

; 2626 : 	iTime /= 100;

	mov	eax, DWORD PTR _iTime$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iTime$[ebp], eax

; 2627 : 
; 2628 : #ifdef NQ_ROUND_BUILD_TIMES_DOWN
; 2629 : 	iTime /= 10; // round to lowest 10 for the sake of quick speed

	mov	eax, DWORD PTR _iTime$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _iTime$[ebp], eax

; 2630 : 	iTime *= 10;

	mov	edx, DWORD PTR _iTime$[ebp]
	imul	edx, 10					; 0000000aH
	mov	DWORD PTR _iTime$[ebp], edx

; 2631 : #endif
; 2632 : 
; 2633 : 	return iTime;

	mov	eax, DWORD PTR _iTime$[ebp]

; 2634 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::getBuildTime
_TEXT	ENDS
PUBLIC	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z	; CvPlot::nextUnitNode
PUBLIC	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ		; CvPlot::headUnitNode
PUBLIC	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ; CvPlot::getBuildTurnsLeft
EXTRN	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z:PROC	; CvUnit::workRate
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ:PROC ; CvUnit::getBuildType
; Function compile flags: /Odtp
;	COMDAT ?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z
_TEXT	SEGMENT
tv73 = -44						; size = 4
tv154 = -40						; size = 4
_this$ = -36						; size = 4
$T239173 = -32						; size = 4
$T239158 = -28						; size = 4
_iTurnsLeft$ = -24					; size = 4
_iThenBuildRate$ = -20					; size = 4
_pUnitNode$ = -16					; size = 4
_pLoopUnit$ = -12					; size = 4
_iNowBuildRate$ = -8					; size = 4
_iBuildLeft$ = -4					; size = 4
_eBuild$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
_iNowExtra$ = 16					; size = 4
_iThenExtra$ = 20					; size = 4
?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z PROC ; CvPlot::getBuildTurnsLeft, COMDAT
; _this$ = ecx

; 2639 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 2640 : #ifdef NQ_FIX_BUILD_TIMES_UI
; 2641 : 	// work rate
; 2642 : 	int iTotalWorkRate = iThenExtra;
; 2643 : 	const CvUnit* pLoopUnit;
; 2644 : 	const IDInfo* pUnitNode = headUnitNode();
; 2645 : 	while(pUnitNode != NULL)
; 2646 : 	{
; 2647 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);
; 2648 : 		pUnitNode = nextUnitNode(pUnitNode);
; 2649 : 
; 2650 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)
; 2651 : 		{
; 2652 : 			iTotalWorkRate += pLoopUnit->workRate(true);
; 2653 : 		}
; 2654 : 	}
; 2655 : 	if(iTotalWorkRate <= 0)
; 2656 : 	{
; 2657 : 		//this means it will take forever under current circumstances
; 2658 : 		return INT_MAX;
; 2659 : 	}
; 2660 : 
; 2661 : 	// turns left = roundUp(build left / worker rate)
; 2662 : 	int iBuildLeft = getBuildTime(eBuild, ePlayer) - getBuildProgress(eBuild);
; 2663 : 	int iTurnsLeft = iBuildLeft / iTotalWorkRate;
; 2664 : 
; 2665 : 	// if there's anything leftover, we actually have to bump up by 1 turn
; 2666 : 	if (iBuildLeft % iTotalWorkRate > 0)
; 2667 : 	{
; 2668 : 		iTurnsLeft++;
; 2669 : 	}
; 2670 : 
; 2671 : 	return iTurnsLeft;
; 2672 : #else
; 2673 : 
; 2674 : 	int iBuildLeft = getBuildTime(eBuild, ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	DWORD PTR _iBuildLeft$[ebp], eax

; 2675 : 
; 2676 : 	if(iBuildLeft == 0)

	cmp	DWORD PTR _iBuildLeft$[ebp], 0
	jne	SHORT $LN7@getBuildTu

; 2677 : 		return 0;

	xor	eax, eax
	jmp	$LN8@getBuildTu
$LN7@getBuildTu:

; 2678 : 
; 2679 : 	const IDInfo* pUnitNode;
; 2680 : 	const CvUnit* pLoopUnit;
; 2681 : 	int iNowBuildRate;
; 2682 : 	int iThenBuildRate;
; 2683 : 	int iTurnsLeft;
; 2684 : 
; 2685 : 	iNowBuildRate = iNowExtra;

	mov	edx, DWORD PTR _iNowExtra$[ebp]
	mov	DWORD PTR _iNowBuildRate$[ebp], edx

; 2686 : 	iThenBuildRate = iThenExtra;

	mov	eax, DWORD PTR _iThenExtra$[ebp]
	mov	DWORD PTR _iThenBuildRate$[ebp], eax

; 2687 : 
; 2688 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN6@getBuildTu:

; 2689 : 
; 2690 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN5@getBuildTu

; 2691 : 	{
; 2692 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 0
	jl	SHORT $LN10@getBuildTu
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 64			; 00000040H
	jge	SHORT $LN10@getBuildTu
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+ecx+4472]
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR tv154[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN11@getBuildTu
$LN10@getBuildTu:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN11@getBuildTu:

; 2693 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 2694 : 
; 2695 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN4@getBuildTu
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	cmp	eax, DWORD PTR _eBuild$[ebp]
	jne	SHORT $LN4@getBuildTu

; 2696 : 		{
; 2697 : 			if(pLoopUnit->canMove())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@getBuildTu

; 2698 : 			{
; 2699 : 				iNowBuildRate += pLoopUnit->workRate(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	add	eax, DWORD PTR _iNowBuildRate$[ebp]
	mov	DWORD PTR _iNowBuildRate$[ebp], eax
$LN3@getBuildTu:

; 2700 : 			}
; 2701 : 			iThenBuildRate += pLoopUnit->workRate(true);

	push	-1
	push	1
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	add	eax, DWORD PTR _iThenBuildRate$[ebp]
	mov	DWORD PTR _iThenBuildRate$[ebp], eax
$LN4@getBuildTu:

; 2702 : 		}
; 2703 : 	}

	jmp	$LN6@getBuildTu
$LN5@getBuildTu:

; 2704 : 
; 2705 : 	if(iThenBuildRate == 0)

	cmp	DWORD PTR _iThenBuildRate$[ebp], 0
	jne	SHORT $LN2@getBuildTu

; 2706 : 	{
; 2707 : 		//this means it will take forever under current circumstances
; 2708 : 		return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH
	jmp	SHORT $LN8@getBuildTu
$LN2@getBuildTu:

; 2709 : 	}
; 2710 : 
; 2711 : 	iBuildLeft -= getBuildProgress(eBuild);

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress
	mov	ecx, DWORD PTR _iBuildLeft$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iBuildLeft$[ebp], ecx

; 2712 : 	iBuildLeft -= iNowBuildRate;

	mov	edx, DWORD PTR _iBuildLeft$[ebp]
	sub	edx, DWORD PTR _iNowBuildRate$[ebp]
	mov	DWORD PTR _iBuildLeft$[ebp], edx

; 2713 : 
; 2714 : 	iBuildLeft = std::max(0, iBuildLeft);

	mov	DWORD PTR $T239158[ebp], 0
	mov	eax, DWORD PTR $T239158[ebp]
	cmp	eax, DWORD PTR _iBuildLeft$[ebp]
	jge	SHORT $LN17@getBuildTu
	lea	ecx, DWORD PTR _iBuildLeft$[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	jmp	SHORT $LN18@getBuildTu
$LN17@getBuildTu:
	lea	edx, DWORD PTR $T239158[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN18@getBuildTu:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T239173[ebp], eax
	mov	ecx, DWORD PTR $T239173[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iBuildLeft$[ebp], edx

; 2715 : 
; 2716 : 	iTurnsLeft = (iBuildLeft / iThenBuildRate);

	mov	eax, DWORD PTR _iBuildLeft$[ebp]
	cdq
	idiv	DWORD PTR _iThenBuildRate$[ebp]
	mov	DWORD PTR _iTurnsLeft$[ebp], eax

; 2717 : 
; 2718 : 	if((iTurnsLeft * iThenBuildRate) < iBuildLeft)

	mov	eax, DWORD PTR _iTurnsLeft$[ebp]
	imul	eax, DWORD PTR _iThenBuildRate$[ebp]
	cmp	eax, DWORD PTR _iBuildLeft$[ebp]
	jge	SHORT $LN1@getBuildTu

; 2719 : 	{
; 2720 : 		iTurnsLeft++;

	mov	ecx, DWORD PTR _iTurnsLeft$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTurnsLeft$[ebp], ecx
$LN1@getBuildTu:

; 2721 : 	}
; 2722 : 
; 2723 : 	//iTurnsLeft++;
; 2724 : 
; 2725 : 	//return std::max(1, iTurnsLeft);
; 2726 : 	return iTurnsLeft;

	mov	eax, DWORD PTR _iTurnsLeft$[ebp]
$LN8@getBuildTu:

; 2727 : #endif
; 2728 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ENDP ; CvPlot::getBuildTurnsLeft
_TEXT	ENDS
PUBLIC	?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTurnsTotal
; Function compile flags: /Odtp
;	COMDAT ?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv129 = -56						; size = 4
tv68 = -52						; size = 4
tv149 = -48						; size = 4
_this$ = -44						; size = 4
$T239204 = -40						; size = 4
$T239195 = -36						; size = 4
$T239180 = -32						; size = 4
$T239179 = -28						; size = 4
_iTurnsLeft$ = -24					; size = 4
_iThenBuildRate$ = -20					; size = 4
_pUnitNode$ = -16					; size = 4
_pLoopUnit$ = -12					; size = 4
_iNowBuildRate$ = -8					; size = 4
_iBuildLeft$ = -4					; size = 4
_eBuild$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::getBuildTurnsTotal, COMDAT
; _this$ = ecx

; 2733 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 2734 : #ifdef NQ_FIX_BUILD_TIMES_UI
; 2735 : 	// work rate
; 2736 : 	int iTotalWorkRate = 0;
; 2737 : 	const CvUnit* pLoopUnit;
; 2738 : 	const IDInfo* pUnitNode = headUnitNode();
; 2739 : 	while(pUnitNode != NULL)
; 2740 : 	{
; 2741 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);
; 2742 : 		pUnitNode = nextUnitNode(pUnitNode);
; 2743 : 
; 2744 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)
; 2745 : 		{
; 2746 : 			iTotalWorkRate += pLoopUnit->workRate(true);
; 2747 : 		}
; 2748 : 	}
; 2749 : 	if(iTotalWorkRate <= 0)
; 2750 : 	{
; 2751 : 		//this means it will take forever under current circumstances
; 2752 : 		return INT_MAX;
; 2753 : 	}
; 2754 : 
; 2755 : 	// turns left = roundUp(build left / worker rate)
; 2756 : 	int iBuildTime = getBuildTime(eBuild, ePlayer);
; 2757 : 	int iTurnsTotal = iBuildTime / iTotalWorkRate;
; 2758 : 
; 2759 : 	// if there's anything leftover, we actually have to bump up by 1 turn
; 2760 : 	if (iBuildTime % iTotalWorkRate > 0)
; 2761 : 	{
; 2762 : 		iTurnsTotal++;
; 2763 : 	}
; 2764 : 
; 2765 : 	return iTurnsTotal;
; 2766 : #else
; 2767 : 	const IDInfo* pUnitNode;
; 2768 : 	const CvUnit* pLoopUnit;
; 2769 : 	int iNowBuildRate = 0;

	mov	DWORD PTR _iNowBuildRate$[ebp], 0

; 2770 : 	int iThenBuildRate = 0;

	mov	DWORD PTR _iThenBuildRate$[ebp], 0

; 2771 : 	int iBuildLeft = 0;

	mov	DWORD PTR _iBuildLeft$[ebp], 0

; 2772 : 	int iTurnsLeft = 0;

	mov	DWORD PTR _iTurnsLeft$[ebp], 0

; 2773 : 
; 2774 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN5@getBuildTu@2:

; 2775 : 
; 2776 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN4@getBuildTu@2

; 2777 : 	{
; 2778 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN8@getBuildTu@2
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN8@getBuildTu@2
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv149[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN9@getBuildTu@2
$LN8@getBuildTu@2:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN9@getBuildTu@2:

; 2779 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 2780 : 
; 2781 : 		if(pLoopUnit && pLoopUnit->getBuildType() == eBuild)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN3@getBuildTu@2
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	cmp	eax, DWORD PTR _eBuild$[ebp]
	jne	SHORT $LN3@getBuildTu@2

; 2782 : 		{
; 2783 : 			if(pLoopUnit->canMove())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@getBuildTu@2

; 2784 : 			{
; 2785 : 				iNowBuildRate += pLoopUnit->workRate(false);

	push	-1
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	add	eax, DWORD PTR _iNowBuildRate$[ebp]
	mov	DWORD PTR _iNowBuildRate$[ebp], eax
$LN2@getBuildTu@2:

; 2786 : 			}
; 2787 : 			iThenBuildRate += pLoopUnit->workRate(true);

	push	-1
	push	1
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	add	eax, DWORD PTR _iThenBuildRate$[ebp]
	mov	DWORD PTR _iThenBuildRate$[ebp], eax
$LN3@getBuildTu@2:

; 2788 : 		}
; 2789 : 	}

	jmp	$LN5@getBuildTu@2
$LN4@getBuildTu@2:

; 2790 : 
; 2791 : 	if(iThenBuildRate == 0)

	cmp	DWORD PTR _iThenBuildRate$[ebp], 0
	jne	SHORT $LN1@getBuildTu@2

; 2792 : 	{
; 2793 : 		//this means it will take forever under current circumstances
; 2794 : 		return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH
	jmp	SHORT $LN6@getBuildTu@2
$LN1@getBuildTu@2:

; 2795 : 	}
; 2796 : 
; 2797 : 	iBuildLeft = getBuildTime(eBuild, ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	DWORD PTR _iBuildLeft$[ebp], eax

; 2798 : 
; 2799 : 	iBuildLeft = std::max(0, iBuildLeft);

	mov	DWORD PTR $T239179[ebp], 0
	mov	ecx, DWORD PTR $T239179[ebp]
	cmp	ecx, DWORD PTR _iBuildLeft$[ebp]
	jge	SHORT $LN15@getBuildTu@2
	lea	edx, DWORD PTR _iBuildLeft$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN16@getBuildTu@2
$LN15@getBuildTu@2:
	lea	eax, DWORD PTR $T239179[ebp]
	mov	DWORD PTR tv68[ebp], eax
$LN16@getBuildTu@2:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR $T239195[ebp], ecx
	mov	edx, DWORD PTR $T239195[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iBuildLeft$[ebp], eax

; 2800 : 
; 2801 : 	iTurnsLeft = (iBuildLeft / iThenBuildRate);

	mov	eax, DWORD PTR _iBuildLeft$[ebp]
	cdq
	idiv	DWORD PTR _iThenBuildRate$[ebp]
	mov	DWORD PTR _iTurnsLeft$[ebp], eax

; 2802 : 
; 2803 : 	iTurnsLeft--;

	mov	ecx, DWORD PTR _iTurnsLeft$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iTurnsLeft$[ebp], ecx

; 2804 : 
; 2805 : 	return std::max(1, iTurnsLeft);

	mov	DWORD PTR $T239180[ebp], 1
	mov	edx, DWORD PTR $T239180[ebp]
	cmp	edx, DWORD PTR _iTurnsLeft$[ebp]
	jge	SHORT $LN19@getBuildTu@2
	lea	eax, DWORD PTR _iTurnsLeft$[ebp]
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN20@getBuildTu@2
$LN19@getBuildTu@2:
	lea	ecx, DWORD PTR $T239180[ebp]
	mov	DWORD PTR tv129[ebp], ecx
$LN20@getBuildTu@2:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR $T239204[ebp], edx
	mov	eax, DWORD PTR $T239204[ebp]
	mov	eax, DWORD PTR [eax]
$LN6@getBuildTu@2:

; 2806 : #endif
; 2807 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::getBuildTurnsTotal
_TEXT	ENDS
PUBLIC	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getWorkingCity
PUBLIC	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
EXTRN	?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getFeatureProductionPercent
EXTRN	?getFeatureProductionModifier@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getFeatureProductionModifier
EXTRN	?getFeatureProduction@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureProduction
EXTRN	?GetAllFeatureProduction@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetAllFeatureProduction
; Function compile flags: /Odtp
;	COMDAT ?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z
_TEXT	SEGMENT
tv247 = -184						; size = 4
tv250 = -180						; size = 4
tv238 = -176						; size = 4
_this$ = -172						; size = 4
$T239402 = -168						; size = 4
$T239395 = -164						; size = 4
$T239391 = -160						; size = 4
_playerID$239383 = -156					; size = 4
$T239374 = -152						; size = 4
$T239368 = -148						; size = 4
$T239361 = -144						; size = 4
$T239357 = -140						; size = 4
$T239346 = -136						; size = 4
$T239290 = -76						; size = 4
$T239286 = -72						; size = 4
$T239282 = -68						; size = 4
$T239273 = -64						; size = 4
_f$239261 = -57						; size = 1
$T239255 = -56						; size = 4
$T239251 = -52						; size = 4
$T239247 = -48						; size = 4
$T239243 = -44						; size = 4
$T239239 = -40						; size = 4
_f$239232 = -33						; size = 1
$T239218 = -32						; size = 4
$T239214 = -28						; size = 4
$T239213 = -24						; size = 4
$T239212 = -20						; size = 4
$T239211 = -16						; size = 4
$T239210 = -12						; size = 4
_iProduction$ = -8					; size = 4
_eTeam$ = -4						; size = 4
_eBuild$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
_ppCity$ = 16						; size = 4
?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z PROC ; CvPlot::getFeatureProduction, COMDAT
; _this$ = ecx

; 2812 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	DWORD PTR _this$[ebp], ecx

; 2813 : 	int iProduction;
; 2814 : 
; 2815 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239218[ebp], eax
	mov	ecx, DWORD PTR $T239218[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 2816 : 
; 2817 : 	if(getFeatureType() == NO_FEATURE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$239232[ebp], cl
	movsx	edx, BYTE PTR _f$239232[ebp]
	cmp	edx, -1
	jne	SHORT $LN6@getFeature

; 2818 : 	{
; 2819 : 		return 0;

	xor	eax, eax
	jmp	$LN7@getFeature
$LN6@getFeature:

; 2820 : 	}
; 2821 : 
; 2822 : 	*ppCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	ecx, DWORD PTR _ppCity$[ebp]
	mov	DWORD PTR [ecx], eax

; 2823 : 
; 2824 : 	if(*ppCity == NULL)

	mov	edx, DWORD PTR _ppCity$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN5@getFeature

; 2825 : 	{
; 2826 : 		*ppCity = GC.getMap().findCity(getX(), getY(), NO_PLAYER, eTeam, false);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239239[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T239243[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T239247[ebp], ecx
	push	0
	push	-1
	push	-1
	push	0
	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR $T239239[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239243[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239247[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	edx, DWORD PTR _ppCity$[ebp]
	mov	DWORD PTR [edx], eax
$LN5@getFeature:

; 2827 : 	}
; 2828 : 
; 2829 : 	if(*ppCity == NULL)

	mov	eax, DWORD PTR _ppCity$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@getFeature

; 2830 : 	{
; 2831 : 		return 0;

	xor	eax, eax
	jmp	$LN7@getFeature
$LN4@getFeature:

; 2832 : 	}
; 2833 : 
; 2834 : 	// Base value
; 2835 : 	if(GET_PLAYER(ePlayer).GetAllFeatureProduction() > 0)

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239251[ebp], ecx
	mov	ecx, DWORD PTR $T239251[ebp]
	call	?GetAllFeatureProduction@CvPlayer@@QBEHXZ ; CvPlayer::GetAllFeatureProduction
	test	eax, eax
	jle	SHORT $LN31@getFeature

; 2836 : 	{
; 2837 : 		iProduction = GET_PLAYER(ePlayer).GetAllFeatureProduction();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239255[ebp], edx
	mov	ecx, DWORD PTR $T239255[ebp]
	call	?GetAllFeatureProduction@CvPlayer@@QBEHXZ ; CvPlayer::GetAllFeatureProduction
	mov	DWORD PTR _iProduction$[ebp], eax

; 2838 : 	}
; 2839 : 	else

	jmp	SHORT $LN35@getFeature

; 2840 : 	{
; 2841 : 		iProduction = GC.getBuildInfo(eBuild)->getFeatureProduction(getFeatureType());

$LN31@getFeature:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$239261[ebp], cl
	movsx	edx, BYTE PTR _f$239261[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureProduction@CvBuildInfo@@QBEHH@Z ; CvBuildInfo::getFeatureProduction
	mov	DWORD PTR _iProduction$[ebp], eax

; 2842 : 	}
; 2843 : 
; 2844 : 	// Distance mod
; 2845 : 	iProduction -= (std::max(0, (plotDistance(getX(), getY(), (*ppCity)->getX(), (*ppCity)->getY()) - 2)) * 5);

$LN35@getFeature:
	mov	ecx, DWORD PTR _ppCity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T239273[ebp], eax
	mov	ecx, DWORD PTR _ppCity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T239282[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T239286[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T239290[ebp], ecx
	mov	edx, DWORD PTR $T239273[ebp]
	push	edx
	mov	eax, DWORD PTR $T239282[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239286[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239290[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	sub	eax, 2
	mov	DWORD PTR $T239210[ebp], eax
	mov	DWORD PTR $T239211[ebp], 0
	mov	eax, DWORD PTR $T239211[ebp]
	cmp	eax, DWORD PTR $T239210[ebp]
	jge	SHORT $LN79@getFeature
	lea	ecx, DWORD PTR $T239210[ebp]
	mov	DWORD PTR tv238[ebp], ecx
	jmp	SHORT $LN80@getFeature
$LN79@getFeature:
	lea	edx, DWORD PTR $T239211[ebp]
	mov	DWORD PTR tv238[ebp], edx
$LN80@getFeature:
	mov	eax, DWORD PTR tv238[ebp]
	mov	DWORD PTR $T239346[ebp], eax
	mov	ecx, DWORD PTR $T239346[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 5
	mov	eax, DWORD PTR _iProduction$[ebp]
	sub	eax, edx
	mov	DWORD PTR _iProduction$[ebp], eax

; 2846 : 
; 2847 : 	iProduction *= std::max(0, (GET_PLAYER((*ppCity)->getOwner()).getFeatureProductionModifier() + 100));

	mov	ecx, DWORD PTR _ppCity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T239357[ebp], eax
	mov	ecx, DWORD PTR $T239357[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239361[ebp], ecx
	mov	ecx, DWORD PTR $T239361[ebp]
	call	?getFeatureProductionModifier@CvPlayer@@QBEHXZ ; CvPlayer::getFeatureProductionModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T239212[ebp], eax
	mov	DWORD PTR $T239213[ebp], 0
	mov	edx, DWORD PTR $T239213[ebp]
	cmp	edx, DWORD PTR $T239212[ebp]
	jge	SHORT $LN89@getFeature
	lea	eax, DWORD PTR $T239212[ebp]
	mov	DWORD PTR tv250[ebp], eax
	jmp	SHORT $LN90@getFeature
$LN89@getFeature:
	lea	ecx, DWORD PTR $T239213[ebp]
	mov	DWORD PTR tv250[ebp], ecx
$LN90@getFeature:
	mov	edx, DWORD PTR tv250[ebp]
	mov	DWORD PTR $T239368[ebp], edx
	mov	eax, DWORD PTR $T239368[ebp]
	mov	ecx, DWORD PTR _iProduction$[ebp]
	imul	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iProduction$[ebp], ecx

; 2848 : 	iProduction /= 100;

	mov	eax, DWORD PTR _iProduction$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iProduction$[ebp], eax

; 2849 : 
; 2850 : 	iProduction *= GC.getGame().getGameSpeedInfo().getFeatureProductionPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239374[ebp], edx
	mov	ecx, DWORD PTR $T239374[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getFeatureProductionPercent
	imul	eax, DWORD PTR _iProduction$[ebp]
	mov	DWORD PTR _iProduction$[ebp], eax

; 2851 : 	iProduction /= 100;

	mov	eax, DWORD PTR _iProduction$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iProduction$[ebp], eax

; 2852 : 
; 2853 : 	if(getTeam() != eTeam)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$239383[ebp], eax
	cmp	DWORD PTR _playerID$239383[ebp], -1
	je	SHORT $LN94@getFeature
	mov	ecx, DWORD PTR _playerID$239383[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239391[ebp], eax
	jmp	SHORT $LN95@getFeature
	jmp	SHORT $LN95@getFeature
$LN94@getFeature:
	mov	DWORD PTR $T239391[ebp], -1
$LN95@getFeature:
	mov	edx, DWORD PTR $T239391[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN1@getFeature

; 2854 : 	{
; 2855 : 		iProduction *= GC.getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6704
	mov	DWORD PTR $T239395[ebp], eax
	mov	ecx, DWORD PTR _iProduction$[ebp]
	imul	ecx, DWORD PTR $T239395[ebp]
	mov	DWORD PTR _iProduction$[ebp], ecx

; 2856 : 		iProduction /= 100;

	mov	eax, DWORD PTR _iProduction$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iProduction$[ebp], eax
$LN1@getFeature:

; 2857 : 	}
; 2858 : 
; 2859 : 	return std::max(0, iProduction);

	mov	DWORD PTR $T239214[ebp], 0
	mov	edx, DWORD PTR $T239214[ebp]
	cmp	edx, DWORD PTR _iProduction$[ebp]
	jge	SHORT $LN105@getFeature
	lea	eax, DWORD PTR _iProduction$[ebp]
	mov	DWORD PTR tv247[ebp], eax
	jmp	SHORT $LN106@getFeature
$LN105@getFeature:
	lea	ecx, DWORD PTR $T239214[ebp]
	mov	DWORD PTR tv247[ebp], ecx
$LN106@getFeature:
	mov	edx, DWORD PTR tv247[ebp]
	mov	DWORD PTR $T239402[ebp], edx
	mov	eax, DWORD PTR $T239402[ebp]
	mov	eax, DWORD PTR [eax]
$LN7@getFeature:

; 2860 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ENDP ; CvPlot::getFeatureProduction
_TEXT	ENDS
PUBLIC	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureFood
EXTRN	?getFeatureFood@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureFood
; Function compile flags: /Odtp
;	COMDAT ?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z
_TEXT	SEGMENT
tv228 = -176						; size = 4
tv231 = -172						; size = 4
tv219 = -168						; size = 4
_this$ = -164						; size = 4
$T239591 = -160						; size = 4
$T239584 = -156						; size = 4
$T239580 = -152						; size = 4
_playerID$239572 = -148					; size = 4
$T239563 = -144						; size = 4
$T239557 = -140						; size = 4
$T239550 = -136						; size = 4
$T239546 = -132						; size = 4
$T239535 = -128						; size = 4
$T239479 = -68						; size = 4
$T239475 = -64						; size = 4
$T239471 = -60						; size = 4
$T239462 = -56						; size = 4
_f$239450 = -49						; size = 1
$T239444 = -48						; size = 4
$T239440 = -44						; size = 4
$T239436 = -40						; size = 4
_f$239429 = -33						; size = 1
$T239415 = -32						; size = 4
$T239411 = -28						; size = 4
$T239410 = -24						; size = 4
$T239409 = -20						; size = 4
$T239408 = -16						; size = 4
$T239407 = -12						; size = 4
_iFood$ = -8						; size = 4
_eTeam$ = -4						; size = 4
_eBuild$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
_ppCity$ = 16						; size = 4
?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z PROC ; CvPlot::getFeatureFood, COMDAT
; _this$ = ecx

; 2865 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	DWORD PTR _this$[ebp], ecx

; 2866 : 	int iFood;
; 2867 : 
; 2868 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239415[ebp], eax
	mov	ecx, DWORD PTR $T239415[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 2869 : 
; 2870 : 	if(getFeatureType() == NO_FEATURE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$239429[ebp], cl
	movsx	edx, BYTE PTR _f$239429[ebp]
	cmp	edx, -1
	jne	SHORT $LN4@getFeature@2

; 2871 : 	{
; 2872 : 		return 0;

	xor	eax, eax
	jmp	$LN5@getFeature@2
$LN4@getFeature@2:

; 2873 : 	}
; 2874 : 
; 2875 : 	*ppCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	ecx, DWORD PTR _ppCity$[ebp]
	mov	DWORD PTR [ecx], eax

; 2876 : 
; 2877 : 	if(*ppCity == NULL)

	mov	edx, DWORD PTR _ppCity$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@getFeature@2

; 2878 : 	{
; 2879 : 		*ppCity = GC.getMap().findCity(getX(), getY(), NO_PLAYER, eTeam, false);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239436[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T239440[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T239444[ebp], ecx
	push	0
	push	-1
	push	-1
	push	0
	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR $T239436[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239440[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239444[ebp]
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
	mov	edx, DWORD PTR _ppCity$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@getFeature@2:

; 2880 : 	}
; 2881 : 
; 2882 : 	if(*ppCity == NULL)

	mov	eax, DWORD PTR _ppCity$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN25@getFeature@2

; 2883 : 	{
; 2884 : 		return 0;

	xor	eax, eax
	jmp	$LN5@getFeature@2

; 2885 : 	}
; 2886 : 
; 2887 : 	// Base value
; 2888 : 	//if(GET_PLAYER(ePlayer).GetAllFeatureProduction() > 0)
; 2889 : 	//{
; 2890 : 	//	iProduction = GET_PLAYER(ePlayer).GetAllFeatureProduction();
; 2891 : 	//}
; 2892 : 	//else
; 2893 : 	//{
; 2894 : 	iFood = GC.getBuildInfo(eBuild)->getFeatureFood(getFeatureType());

$LN25@getFeature@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$239450[ebp], dl
	movsx	eax, BYTE PTR _f$239450[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureFood@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureFood
	mov	DWORD PTR _iFood$[ebp], eax

; 2895 : 	//}
; 2896 : 
; 2897 : 	// Distance mod
; 2898 : 	iFood -= (std::max(0, (plotDistance(getX(), getY(), (*ppCity)->getX(), (*ppCity)->getY()) - 2)) * 5);

	mov	edx, DWORD PTR _ppCity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T239462[ebp], ecx
	mov	edx, DWORD PTR _ppCity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T239471[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239475[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239479[ebp], edx
	mov	eax, DWORD PTR $T239462[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239471[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239475[ebp]
	push	edx
	mov	eax, DWORD PTR $T239479[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	sub	eax, 2
	mov	DWORD PTR $T239407[ebp], eax
	mov	DWORD PTR $T239408[ebp], 0
	mov	ecx, DWORD PTR $T239408[ebp]
	cmp	ecx, DWORD PTR $T239407[ebp]
	jge	SHORT $LN73@getFeature@2
	lea	edx, DWORD PTR $T239407[ebp]
	mov	DWORD PTR tv219[ebp], edx
	jmp	SHORT $LN74@getFeature@2
$LN73@getFeature@2:
	lea	eax, DWORD PTR $T239408[ebp]
	mov	DWORD PTR tv219[ebp], eax
$LN74@getFeature@2:
	mov	ecx, DWORD PTR tv219[ebp]
	mov	DWORD PTR $T239535[ebp], ecx
	mov	edx, DWORD PTR $T239535[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 5
	mov	ecx, DWORD PTR _iFood$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iFood$[ebp], ecx

; 2899 : 
; 2900 : 	iFood *= std::max(0, (GET_PLAYER((*ppCity)->getOwner()).getFeatureProductionModifier() + 100));

	mov	edx, DWORD PTR _ppCity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T239546[ebp], ecx
	mov	edx, DWORD PTR $T239546[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239550[ebp], edx
	mov	ecx, DWORD PTR $T239550[ebp]
	call	?getFeatureProductionModifier@CvPlayer@@QBEHXZ ; CvPlayer::getFeatureProductionModifier
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T239409[ebp], eax
	mov	DWORD PTR $T239410[ebp], 0
	mov	eax, DWORD PTR $T239410[ebp]
	cmp	eax, DWORD PTR $T239409[ebp]
	jge	SHORT $LN83@getFeature@2
	lea	ecx, DWORD PTR $T239409[ebp]
	mov	DWORD PTR tv231[ebp], ecx
	jmp	SHORT $LN84@getFeature@2
$LN83@getFeature@2:
	lea	edx, DWORD PTR $T239410[ebp]
	mov	DWORD PTR tv231[ebp], edx
$LN84@getFeature@2:
	mov	eax, DWORD PTR tv231[ebp]
	mov	DWORD PTR $T239557[ebp], eax
	mov	ecx, DWORD PTR $T239557[ebp]
	mov	edx, DWORD PTR _iFood$[ebp]
	imul	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iFood$[ebp], edx

; 2901 : 	iFood /= 100;

	mov	eax, DWORD PTR _iFood$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iFood$[ebp], eax

; 2902 : 
; 2903 : 	iFood *= GC.getGame().getGameSpeedInfo().getFeatureProductionPercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239563[ebp], edx
	mov	ecx, DWORD PTR $T239563[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getFeatureProductionPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getFeatureProductionPercent
	imul	eax, DWORD PTR _iFood$[ebp]
	mov	DWORD PTR _iFood$[ebp], eax

; 2904 : 	iFood /= 100;

	mov	eax, DWORD PTR _iFood$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iFood$[ebp], eax

; 2905 : 
; 2906 : 	if(getTeam() != eTeam)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$239572[ebp], eax
	cmp	DWORD PTR _playerID$239572[ebp], -1
	je	SHORT $LN88@getFeature@2
	mov	ecx, DWORD PTR _playerID$239572[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239580[ebp], eax
	jmp	SHORT $LN89@getFeature@2
	jmp	SHORT $LN89@getFeature@2
$LN88@getFeature@2:
	mov	DWORD PTR $T239580[ebp], -1
$LN89@getFeature@2:
	mov	edx, DWORD PTR $T239580[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN1@getFeature@2

; 2907 : 	{
; 2908 : 		iFood *= GC.getDIFFERENT_TEAM_FEATURE_PRODUCTION_PERCENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6704
	mov	DWORD PTR $T239584[ebp], eax
	mov	ecx, DWORD PTR _iFood$[ebp]
	imul	ecx, DWORD PTR $T239584[ebp]
	mov	DWORD PTR _iFood$[ebp], ecx

; 2909 : 		iFood /= 100;

	mov	eax, DWORD PTR _iFood$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iFood$[ebp], eax
$LN1@getFeature@2:

; 2910 : 	}
; 2911 : 
; 2912 : 	return std::max(0, iFood);

	mov	DWORD PTR $T239411[ebp], 0
	mov	edx, DWORD PTR $T239411[ebp]
	cmp	edx, DWORD PTR _iFood$[ebp]
	jge	SHORT $LN99@getFeature@2
	lea	eax, DWORD PTR _iFood$[ebp]
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN100@getFeature@2
$LN99@getFeature@2:
	lea	ecx, DWORD PTR $T239411[ebp]
	mov	DWORD PTR tv228[ebp], ecx
$LN100@getFeature@2:
	mov	edx, DWORD PTR tv228[ebp]
	mov	DWORD PTR $T239591[ebp], edx
	mov	eax, DWORD PTR $T239591[ebp]
	mov	eax, DWORD PTR [eax]
$LN5@getFeature@2:

; 2913 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ENDP ; CvPlot::getFeatureFood
_TEXT	ENDS
PUBLIC	?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
; Function compile flags: /Odtp
;	COMDAT ?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T239597 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_eOwner$ = 12						; size = 4
_eAttackingPlayer$ = 16					; size = 4
_pAttacker$ = 20					; size = 4
_bTestAtWar$ = 24					; size = 1
_bTestPotentialEnemy$ = 28				; size = 1
_bTestCanMove$ = 32					; size = 1
_bNoncombatAllowed$ = 36				; size = 1
?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z PROC ; CvPlot::getBestDefender, COMDAT
; _this$ = ecx

; 2919 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T239597[ebp], 0

; 2920 : 	// accesses another internal method, user code sees this (mutable) method and const guarantees are maintained
; 2921 : 	return (const_cast<const CvPlot*>(this)->getBestDefender(eOwner, eAttackingPlayer, pAttacker, bTestAtWar, bTestPotentialEnemy, bTestCanMove, bNoncombatAllowed));

	movzx	eax, BYTE PTR _bNoncombatAllowed$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bTestCanMove$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bTestPotentialEnemy$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bTestAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eAttackingPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOwner$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	edx, DWORD PTR $T239597[ebp]
	or	edx, 1
	mov	DWORD PTR $T239597[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2922 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ENDP ; CvPlot::getBestDefender
_TEXT	ENDS
EXTRN	?isBetterDefenderThan@CvUnit@@QBE_NPBV1@0@Z:PROC ; CvUnit::isBetterDefenderThan
EXTRN	?GetRangedCombatLimit@CvUnit@@QBEHXZ:PROC	; CvUnit::GetRangedCombatLimit
EXTRN	?getDamage@CvUnit@@QBEHXZ:PROC			; CvUnit::getDamage
EXTRN	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isPotentialEnemy
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$1
__ehfuncinfo$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
_TEXT	SEGMENT
tv330 = -160						; size = 4
_this$ = -156						; size = 4
$T239832 = -152						; size = 4
$T239828 = -148						; size = 4
$T239824 = -144						; size = 4
$T239820 = -140						; size = 4
$T239816 = -136						; size = 4
$T239812 = -132						; size = 4
$T239803 = -128						; size = 4
$T239799 = -124						; size = 4
$T239790 = -120						; size = 4
$T239786 = -116						; size = 4
$T239782 = -112						; size = 4
$T239773 = -108						; size = 4
$T239769 = -104						; size = 4
$T239760 = -100						; size = 4
$T239756 = -96						; size = 4
$T239747 = -92						; size = 4
$T239743 = -88						; size = 4
$T239739 = -84						; size = 4
$T239730 = -80						; size = 4
$T239726 = -76						; size = 4
$T239722 = -72						; size = 4
$T239713 = -68						; size = 4
$T239709 = -64						; size = 4
$T239700 = -60						; size = 4
$T239693 = -56						; size = 4
$T239671 = -52						; size = 4
$T239634 = -45						; size = 1
$T239624 = -44						; size = 4
$T239615 = -40						; size = 4
$T239604 = -36						; size = 4
_pUnitNode$ = -32					; size = 4
_pBestUnit$ = -28					; size = 8
_pLoopUnit$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eOwner$ = 12						; size = 4
_eAttackingPlayer$ = 16					; size = 4
_pAttacker$ = 20					; size = 4
_bTestAtWar$ = 24					; size = 1
_bTestPotentialEnemy$ = 28				; size = 1
_bTestCanMove$ = 32					; size = 1
_bNoncombatAllowed$ = 36				; size = 1
?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z PROC ; CvPlot::getBestDefender, COMDAT
; _this$ = ecx

; 2926 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T239604[ebp], 0

; 2927 : 	const IDInfo* pUnitNode;
; 2928 : 	const UnitHandle pLoopUnit;

	mov	DWORD PTR _pLoopUnit$[ebp], 0
	mov	BYTE PTR _pLoopUnit$[ebp+4], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2929 : 	const UnitHandle pBestUnit;

	mov	DWORD PTR _pBestUnit$[ebp], 0
	mov	BYTE PTR _pBestUnit$[ebp+4], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2930 : 
; 2931 : 	//NQMP GJS - fix radaring begin
; 2932 : 	if (eAttackingPlayer != NO_PLAYER && !isVisible(GET_PLAYER(eAttackingPlayer).getTeam()))

	cmp	DWORD PTR _eAttackingPlayer$[ebp], -1
	je	$LN18@getBestDef
	mov	eax, DWORD PTR _eAttackingPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239615[ebp], eax
	mov	ecx, DWORD PTR $T239615[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239624[ebp], eax
	cmp	DWORD PTR $T239624[ebp], -1
	jne	SHORT $LN38@getBestDef
	mov	BYTE PTR $T239634[ebp], 0
	jmp	SHORT $LN36@getBestDef
$LN38@getBestDef:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR $T239624[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T239634[ebp], cl
$LN36@getBestDef:
	movzx	edx, BYTE PTR $T239634[ebp]
	test	edx, edx
	jne	SHORT $LN18@getBestDef

; 2933 : 		return pBestUnit;	

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR _pBestUnit$[ebp+4]
	mov	BYTE PTR [edx+4], al
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN41@getBestDef
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN41@getBestDef:
	mov	eax, DWORD PTR $T239604[ebp]
	or	eax, 1
	mov	DWORD PTR $T239604[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN46@getBestDef
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN46@getBestDef:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN51@getBestDef
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN51@getBestDef:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN19@getBestDef
$LN18@getBestDef:

; 2934 : 	//NQMP GJS - fix radaring end
; 2935 : 
; 2936 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN17@getBestDef:

; 2937 : 
; 2938 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN16@getBestDef

; 2939 : 	{
; 2940 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 0
	jl	SHORT $LN55@getBestDef
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 64			; 00000040H
	jge	SHORT $LN55@getBestDef
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+ecx+4472]
	mov	DWORD PTR tv330[ebp], eax
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR tv330[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv330[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR $T239671[ebp], eax
	jmp	SHORT $LN56@getBestDef
$LN55@getBestDef:
	mov	DWORD PTR $T239671[ebp], 0
$LN56@getBestDef:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN61@getBestDef
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN61@getBestDef:
	mov	ecx, DWORD PTR $T239671[ebp]
	mov	DWORD PTR _pLoopUnit$[ebp], ecx
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN62@getBestDef
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@getBestDef:

; 2941 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 2942 : 
; 2943 : 		if(pLoopUnit && (bNoncombatAllowed || pLoopUnit->IsCanDefend()) && pLoopUnit != pAttacker)	// Does the unit exist, and can it fight, or do we care if it can't fight?

	xor	eax, eax
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@getBestDef
	movzx	edx, BYTE PTR _bNoncombatAllowed$[ebp]
	test	edx, edx
	jne	SHORT $LN72@getBestDef
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239693[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T239693[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@getBestDef
$LN72@getBestDef:
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _pAttacker$[ebp]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@getBestDef

; 2944 : 		{
; 2945 : 			if((eOwner ==  NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN12@getBestDef
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239700[ebp], edx
	mov	eax, DWORD PTR $T239700[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T239709[ebp], ecx
	mov	edx, DWORD PTR $T239709[ebp]
	cmp	edx, DWORD PTR _eOwner$[ebp]
	jne	$LN15@getBestDef
$LN12@getBestDef:

; 2946 : 			{
; 2947 : 				if((eAttackingPlayer == NO_PLAYER) || !(pLoopUnit->isInvisible(GET_PLAYER(eAttackingPlayer).getTeam(), false)))

	cmp	DWORD PTR _eAttackingPlayer$[ebp], -1
	je	SHORT $LN10@getBestDef
	mov	eax, DWORD PTR _eAttackingPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239713[ebp], eax
	mov	ecx, DWORD PTR $T239713[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239722[ebp], eax
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239726[ebp], eax
	push	1
	push	0
	mov	ecx, DWORD PTR $T239722[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239726[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	$LN15@getBestDef
$LN10@getBestDef:

; 2948 : 				{
; 2949 : 					if(!bTestAtWar || eAttackingPlayer == NO_PLAYER || pLoopUnit->isEnemy(GET_PLAYER(eAttackingPlayer).getTeam(), this) || (NULL != pAttacker && pAttacker->isEnemy(GET_PLAYER(pLoopUnit->getOwner()).getTeam(), this)))

	movzx	eax, BYTE PTR _bTestAtWar$[ebp]
	test	eax, eax
	je	$LN8@getBestDef
	cmp	DWORD PTR _eAttackingPlayer$[ebp], -1
	je	$LN8@getBestDef
	mov	ecx, DWORD PTR _eAttackingPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239730[ebp], ecx
	mov	edx, DWORD PTR $T239730[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239739[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239743[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T239739[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239743[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@getBestDef
	cmp	DWORD PTR _pAttacker$[ebp], 0
	je	$LN15@getBestDef
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239747[ebp], edx
	mov	eax, DWORD PTR $T239747[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T239756[ebp], ecx
	mov	edx, DWORD PTR $T239756[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239760[ebp], edx
	mov	eax, DWORD PTR $T239760[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239769[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T239769[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAttacker$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@getBestDef
$LN8@getBestDef:

; 2950 : 					{
; 2951 : 						if(!bTestPotentialEnemy || (eAttackingPlayer == NO_PLAYER) ||  pLoopUnit->isPotentialEnemy(GET_PLAYER(eAttackingPlayer).getTeam(), this) || (NULL != pAttacker && pAttacker->isPotentialEnemy(GET_PLAYER(pLoopUnit->getOwner()).getTeam(), this)))

	movzx	edx, BYTE PTR _bTestPotentialEnemy$[ebp]
	test	edx, edx
	je	$LN6@getBestDef
	cmp	DWORD PTR _eAttackingPlayer$[ebp], -1
	je	$LN6@getBestDef
	mov	eax, DWORD PTR _eAttackingPlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239773[ebp], eax
	mov	ecx, DWORD PTR $T239773[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239782[ebp], eax
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239786[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239782[ebp]
	push	edx
	mov	ecx, DWORD PTR $T239786[ebp]
	call	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isPotentialEnemy
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@getBestDef
	cmp	DWORD PTR _pAttacker$[ebp], 0
	je	$LN15@getBestDef
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239790[ebp], ecx
	mov	edx, DWORD PTR $T239790[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T239799[ebp], eax
	mov	ecx, DWORD PTR $T239799[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T239803[ebp], ecx
	mov	edx, DWORD PTR $T239803[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239812[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239812[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAttacker$[ebp]
	call	?isPotentialEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isPotentialEnemy
	movzx	eax, al
	test	eax, eax
	je	$LN15@getBestDef
$LN6@getBestDef:

; 2952 : 						{
; 2953 : 							if(!bTestCanMove || (pLoopUnit->canMove() && !(pLoopUnit->isCargo())))

	movzx	ecx, BYTE PTR _bTestCanMove$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@getBestDef
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239816[ebp], edx
	mov	ecx, DWORD PTR $T239816[ebp]
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	movzx	eax, al
	test	eax, eax
	je	$LN15@getBestDef
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239820[ebp], ecx
	mov	ecx, DWORD PTR $T239820[ebp]
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	movzx	edx, al
	test	edx, edx
	jne	$LN15@getBestDef
$LN4@getBestDef:

; 2954 : 							{
; 2955 : 								if((pAttacker == NULL) || (pAttacker->getDomainType() != DOMAIN_AIR) || (pLoopUnit->getDamage() < pAttacker->GetRangedCombatLimit()))

	cmp	DWORD PTR _pAttacker$[ebp], 0
	je	SHORT $LN2@getBestDef
	mov	ecx, DWORD PTR _pAttacker$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN2@getBestDef
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239824[ebp], eax
	mov	ecx, DWORD PTR $T239824[ebp]
	call	?getDamage@CvUnit@@QBEHXZ		; CvUnit::getDamage
	mov	esi, eax
	mov	ecx, DWORD PTR _pAttacker$[ebp]
	call	?GetRangedCombatLimit@CvUnit@@QBEHXZ	; CvUnit::GetRangedCombatLimit
	cmp	esi, eax
	jge	SHORT $LN15@getBestDef
$LN2@getBestDef:

; 2956 : 								{
; 2957 : 									if(pLoopUnit->isBetterDefenderThan(pBestUnit.pointer(), pAttacker))

	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	mov	DWORD PTR $T239828[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR $T239832[ebp], edx
	mov	eax, DWORD PTR _pAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239828[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239832[ebp]
	call	?isBetterDefenderThan@CvUnit@@QBE_NPBV1@0@Z ; CvUnit::isBetterDefenderThan
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@getBestDef

; 2958 : 									{
; 2959 : 										pBestUnit = pLoopUnit;

	lea	eax, DWORD PTR _pLoopUnit$[ebp]
	lea	ecx, DWORD PTR _pBestUnit$[ebp]
	cmp	eax, ecx
	je	SHORT $LN15@getBestDef
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN139@getBestDef
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN139@getBestDef:
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR _pBestUnit$[ebp], edx
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN15@getBestDef
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN15@getBestDef:

; 2960 : 									}
; 2961 : 								}
; 2962 : 							}
; 2963 : 						}
; 2964 : 					}
; 2965 : 				}
; 2966 : 			}
; 2967 : 		}
; 2968 : 	}

	jmp	$LN17@getBestDef
$LN16@getBestDef:

; 2969 : 
; 2970 : 	return pBestUnit;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR _pBestUnit$[ebp+4]
	mov	BYTE PTR [edx+4], al
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN148@getBestDef
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN148@getBestDef:
	mov	eax, DWORD PTR $T239604[ebp]
	or	eax, 1
	mov	DWORD PTR $T239604[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR _pBestUnit$[ebp], 0
	je	SHORT $LN153@getBestDef
	mov	ecx, DWORD PTR _pBestUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN153@getBestDef:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN158@getBestDef
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN158@getBestDef:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@getBestDef:

; 2971 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$0:
	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$1:
	lea	ecx, DWORD PTR _pBestUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z$2:
	mov	eax, DWORD PTR $T239604[ebp]
	and	eax, 1
	je	$LN24@getBestDef
	and	DWORD PTR $T239604[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
$LN24@getBestDef:
	ret	0
__ehhandler$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getBestDefender@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ENDP ; CvPlot::getBestDefender
PUBLIC	?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ	; CvPlot::getSelectedUnit
; Function compile flags: /Odtp
;	COMDAT ?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ PROC		; CvPlot::getSelectedUnit, COMDAT
; _this$ = ecx

; 2975 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2976 : 	return const_cast<CvUnit*>(const_cast<const CvPlot*>(this)->getSelectedUnit());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ ; CvPlot::getSelectedUnit

; 2977 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ ENDP		; CvPlot::getSelectedUnit
_TEXT	ENDS
EXTRN	?IsSelected@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsSelected
; Function compile flags: /Odtp
;	COMDAT ?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ
_TEXT	SEGMENT
tv91 = -16						; size = 4
_this$ = -12						; size = 4
_pUnitNode$ = -8					; size = 4
_pLoopUnit$ = -4					; size = 4
?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ PROC		; CvPlot::getSelectedUnit, COMDAT
; _this$ = ecx

; 2981 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2982 : 	const IDInfo* pUnitNode;
; 2983 : 	const CvUnit* pLoopUnit;
; 2984 : 
; 2985 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN3@getSelecte:

; 2986 : 
; 2987 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	SHORT $LN2@getSelecte

; 2988 : 	{
; 2989 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN6@getSelecte
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN6@getSelecte
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv91[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv91[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN7@getSelecte
$LN6@getSelecte:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN7@getSelecte:

; 2990 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 2991 : 
; 2992 : 		if(pLoopUnit && pLoopUnit->IsSelected())

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN1@getSelecte
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@getSelecte

; 2993 : 		{
; 2994 : 			return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN4@getSelecte
$LN1@getSelecte:

; 2995 : 		}
; 2996 : 	}

	jmp	SHORT $LN3@getSelecte
$LN2@getSelecte:

; 2997 : 
; 2998 : 	return NULL;

	xor	eax, eax
$LN4@getSelecte:

; 2999 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSelectedUnit@CvPlot@@QBEPBVCvUnit@@XZ ENDP		; CvPlot::getSelectedUnit
_TEXT	ENDS
PUBLIC	??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@		; `string'
PUBLIC	??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@		; `string'
PUBLIC	?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z	; CvPlot::getUnitPower
EXTRN	?GetFlavorValue@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetFlavorValue
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
;	COMDAT ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@ DB 'FLAVOR_DEFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
CONST	SEGMENT
??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@ DB 'FLAVOR_OFFENSE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
CONST	ENDS
;	COMDAT ?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv157 = -40						; size = 4
_this$ = -36						; size = 4
$T239926 = -32						; size = 4
$T239922 = -28						; size = 4
$T239918 = -24						; size = 4
$T239914 = -20						; size = 4
_iI$223201 = -16					; size = 4
_iCount$ = -12						; size = 4
_pUnitNode$ = -8					; size = 4
_pLoopUnit$ = -4					; size = 4
_eOwner$ = 8						; size = 4
?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z PROC	; CvPlot::getUnitPower, COMDAT
; _this$ = ecx

; 3004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 3005 : 	const IDInfo* pUnitNode;
; 3006 : 	const CvUnit* pLoopUnit;
; 3007 : 	int iCount;
; 3008 : 
; 3009 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3010 : 
; 3011 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN10@getUnitPow:

; 3012 : 
; 3013 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN9@getUnitPow

; 3014 : 	{
; 3015 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN13@getUnitPow
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN13@getUnitPow
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv157[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv157[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN14@getUnitPow
$LN13@getUnitPow:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN14@getUnitPow:

; 3016 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3017 : 
; 3018 : 		if(!pLoopUnit) continue;

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	jne	SHORT $LN8@getUnitPow
	jmp	SHORT $LN10@getUnitPow
$LN8@getUnitPow:

; 3019 : 
; 3020 : 		if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN6@getUnitPow
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T239914[ebp], edx
	mov	eax, DWORD PTR $T239914[ebp]
	cmp	eax, DWORD PTR _eOwner$[ebp]
	jne	$LN7@getUnitPow
$LN6@getUnitPow:

; 3021 : 		{
; 3022 : 			for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	mov	DWORD PTR _iI$223201[ebp], 0
	jmp	SHORT $LN5@getUnitPow
$LN4@getUnitPow:
	mov	ecx, DWORD PTR _iI$223201[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223201[ebp], ecx
$LN5@getUnitPow:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T239918[ebp], edx
	mov	eax, DWORD PTR _iI$223201[ebp]
	cmp	eax, DWORD PTR $T239918[ebp]
	jge	SHORT $LN7@getUnitPow

; 3023 : 			{
; 3024 : 				if(GC.getFlavorTypes((FlavorTypes)iI) == "FLAVOR_OFFENSE" ||
; 3025 : 				        GC.getFlavorTypes((FlavorTypes)iI) == "FLAVOR_DEFENSE")

	mov	ecx, DWORD PTR _iI$223201[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T239922[ebp], ecx
	push	OFFSET ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
	mov	edx, DWORD PTR $T239922[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@getUnitPow
	mov	ecx, DWORD PTR _iI$223201[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T239926[ebp], ecx
	push	OFFSET ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
	mov	edx, DWORD PTR $T239926[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@getUnitPow
$LN1@getUnitPow:

; 3026 : 				{
; 3027 : 					iCount += pLoopUnit->getUnitInfo().GetFlavorValue(iI);

	mov	ecx, DWORD PTR _iI$223201[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetFlavorValue@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetFlavorValue
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN2@getUnitPow:

; 3028 : 				}
; 3029 : 			}

	jmp	$LN4@getUnitPow
$LN7@getUnitPow:

; 3030 : 		}
; 3031 : 	}

	jmp	$LN10@getUnitPow
$LN9@getUnitPow:

; 3032 : 
; 3033 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3034 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP	; CvPlot::getUnitPower
_TEXT	ENDS
PUBLIC	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
PUBLIC	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z	; CvPlot::defenseModifier
EXTRN	?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetDefenseModifierGlobal
EXTRN	?GetDefenseModifier@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetDefenseModifier
EXTRN	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::isFriendlyTerritory
EXTRN	?getDefenseModifier@CvTerrainInfo@@QBEHXZ:PROC	; CvTerrainInfo::getDefenseModifier
EXTRN	?getDefenseModifier@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getDefenseModifier
; Function compile flags: /Odtp
;	COMDAT ?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T240009 = -56						; size = 4
$T240005 = -52						; size = 4
_playerID$240002 = -48					; size = 4
$T239988 = -44						; size = 4
_playerID$239985 = -40					; size = 4
$T239971 = -36						; size = 4
$T239967 = -32						; size = 4
$T239960 = -28						; size = 4
_f$239956 = -22						; size = 1
_f$239947 = -21						; size = 1
_pkImprovement$223231 = -20				; size = 4
_pkImprovement$223233 = -16				; size = 4
_eImprovement$ = -12					; size = 4
_pCity$ = -8						; size = 4
_iModifier$ = -4					; size = 4
_eDefender$ = 8						; size = 4
___formal$ = 12						; size = 1
_bHelp$ = 16						; size = 1
?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z PROC	; CvPlot::defenseModifier, COMDAT
; _this$ = ecx

; 3039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 3040 : 	CvCity* pCity;
; 3041 : 	ImprovementTypes eImprovement;
; 3042 : 	int iModifier;
; 3043 : 
; 3044 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 3045 : 
; 3046 : 	// Can only get Defensive Bonus from ONE thing - they don't stack
; 3047 : 
; 3048 : 	// Hill (and mountain)
; 3049 : 	if(isHills() || isMountain())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN14@defenseMod
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN26@defenseMod
$LN14@defenseMod:

; 3050 : 	{
; 3051 : 		iModifier = /*25*/ GC.getHILLS_EXTRA_DEFENSE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7384
	mov	DWORD PTR _iModifier$[ebp], eax

; 3052 : 	}
; 3053 : 	// Feature
; 3054 : 	else if(getFeatureType() != NO_FEATURE)

	jmp	$LN13@defenseMod
$LN26@defenseMod:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$239947[ebp], dl
	movsx	eax, BYTE PTR _f$239947[ebp]
	cmp	eax, -1
	je	SHORT $LN12@defenseMod

; 3055 : 	{
; 3056 : 		iModifier = GC.getFeatureInfo(getFeatureType())->getDefenseModifier();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$239956[ebp], dl
	movsx	eax, BYTE PTR _f$239956[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getDefenseModifier@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getDefenseModifier
	mov	DWORD PTR _iModifier$[ebp], eax

; 3057 : 	}
; 3058 : 	// Terrain
; 3059 : 	else

	jmp	SHORT $LN13@defenseMod
$LN12@defenseMod:

; 3060 : 	{
; 3061 : 		iModifier = GC.getTerrainInfo(getTerrainType())->getDefenseModifier();

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR $T239960[ebp], edx
	mov	eax, DWORD PTR $T239960[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getDefenseModifier@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getDefenseModifier
	mov	DWORD PTR _iModifier$[ebp], eax

; 3062 : 
; 3063 : 		// Flat land gives defensive PENALTY
; 3064 : 		if(!isWater())

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@defenseMod

; 3065 : 		{
; 3066 : 			iModifier += /*-25*/ GC.getFLAT_LAND_EXTRA_DEFENSE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7380
	mov	DWORD PTR $T239967[ebp], edx
	mov	eax, DWORD PTR _iModifier$[ebp]
	add	eax, DWORD PTR $T239967[ebp]
	mov	DWORD PTR _iModifier$[ebp], eax
$LN13@defenseMod:

; 3067 : 		}
; 3068 : 	}
; 3069 : 
; 3070 : 	if(bHelp)

	movzx	ecx, BYTE PTR _bHelp$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@defenseMod

; 3071 : 	{
; 3072 : 		eImprovement = getRevealedImprovementType(GC.getGame().getActiveTeam());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239971[ebp], edx
	mov	ecx, DWORD PTR $T239971[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 3073 : 	}
; 3074 : 	else

	jmp	SHORT $LN8@defenseMod
$LN9@defenseMod:

; 3075 : 	{
; 3076 : 		eImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax
$LN8@defenseMod:

; 3077 : 	}
; 3078 : 
; 3079 : 	if(eImprovement != NO_IMPROVEMENT && !IsImprovementPillaged())

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	$LN7@defenseMod
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	eax, al
	test	eax, eax
	jne	$LN7@defenseMod

; 3080 : 	{
; 3081 : 		if(eDefender != NO_TEAM && (getTeam() == NO_TEAM || GET_TEAM(eDefender).isFriendlyTerritory(getTeam())))

	cmp	DWORD PTR _eDefender$[ebp], -1
	je	$LN6@defenseMod
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$239985[ebp], edx
	cmp	DWORD PTR _playerID$239985[ebp], -1
	je	SHORT $LN41@defenseMod
	mov	eax, DWORD PTR _playerID$239985[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T239988[ebp], eax
	jmp	SHORT $LN42@defenseMod
	jmp	SHORT $LN42@defenseMod
$LN41@defenseMod:
	mov	DWORD PTR $T239988[ebp], -1
$LN42@defenseMod:
	cmp	DWORD PTR $T239988[ebp], -1
	je	SHORT $LN5@defenseMod
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$240002[ebp], edx
	cmp	DWORD PTR _playerID$240002[ebp], -1
	je	SHORT $LN49@defenseMod
	mov	eax, DWORD PTR _playerID$240002[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240005[ebp], eax
	jmp	SHORT $LN50@defenseMod
	jmp	SHORT $LN50@defenseMod
$LN49@defenseMod:
	mov	DWORD PTR $T240005[ebp], -1
$LN50@defenseMod:
	mov	ecx, DWORD PTR _eDefender$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T240009[ebp], ecx
	mov	edx, DWORD PTR $T240005[ebp]
	push	edx
	mov	ecx, DWORD PTR $T240009[ebp]
	call	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isFriendlyTerritory
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@defenseMod
$LN5@defenseMod:

; 3082 : 		{
; 3083 : 			CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovement$223231[ebp], eax

; 3084 : 			if (pkImprovement)

	cmp	DWORD PTR _pkImprovement$223231[ebp], 0
	je	SHORT $LN6@defenseMod

; 3085 : 				iModifier += pkImprovement->GetDefenseModifier();

	mov	ecx, DWORD PTR _pkImprovement$223231[ebp]
	call	?GetDefenseModifier@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetDefenseModifier
	add	eax, DWORD PTR _iModifier$[ebp]
	mov	DWORD PTR _iModifier$[ebp], eax
$LN6@defenseMod:

; 3086 : 		}
; 3087 : 		CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovement$223233[ebp], eax

; 3088 : 		if (pkImprovement)

	cmp	DWORD PTR _pkImprovement$223233[ebp], 0
	je	SHORT $LN7@defenseMod

; 3089 : 		{
; 3090 : 			iModifier += pkImprovement->GetDefenseModifierGlobal();

	mov	ecx, DWORD PTR _pkImprovement$223233[ebp]
	call	?GetDefenseModifierGlobal@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetDefenseModifierGlobal
	add	eax, DWORD PTR _iModifier$[ebp]
	mov	DWORD PTR _iModifier$[ebp], eax
$LN7@defenseMod:

; 3091 : 		}
; 3092 : 	}
; 3093 : 
; 3094 : 	if(!bHelp)

	movzx	eax, BYTE PTR _bHelp$[ebp]
	test	eax, eax
	jne	SHORT $LN2@defenseMod

; 3095 : 	{
; 3096 : 		pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN2@defenseMod:

; 3097 : 
; 3098 : 		if(pCity != NULL)
; 3099 : 		{
; 3100 : 		}
; 3101 : 	}
; 3102 : 
; 3103 : 	return iModifier;

	mov	eax, DWORD PTR _iModifier$[ebp]

; 3104 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ENDP	; CvPlot::defenseModifier
_TEXT	ENDS
PUBLIC	?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z	; CvPlot::movementCost
EXTRN	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCost
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
; Function compile flags: /Odtp
;	COMDAT ?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T240020 = -1						; size = 1
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_iMovesRemaining$ = 16					; size = 4
?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z PROC	; CvPlot::movementCost, COMDAT
; _this$ = ecx

; 3108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3109 : 	return CvUnitMovement::MovementCost(pUnit, pFromPlot, this, pUnit->baseMoves(isWater()?DOMAIN_SEA:NO_DOMAIN), pUnit->maxMoves(), iMovesRemaining);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	mov	BYTE PTR $T240020[ebp], dl
	mov	eax, DWORD PTR _iMovesRemaining$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	push	eax
	movzx	ecx, BYTE PTR $T240020[ebp]
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	sub	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	call	?MovementCost@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCost
	add	esp, 24					; 00000018H

; 3110 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ENDP	; CvPlot::movementCost
_TEXT	ENDS
PUBLIC	?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ; CvPlot::MovementCostNoZOC
EXTRN	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z:PROC ; CvUnitMovement::MovementCostNoZOC
; Function compile flags: /Odtp
;	COMDAT ?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T240026 = -1						; size = 1
_pUnit$ = 8						; size = 4
_pFromPlot$ = 12					; size = 4
_iMovesRemaining$ = 16					; size = 4
?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z PROC	; CvPlot::MovementCostNoZOC, COMDAT
; _this$ = ecx

; 3114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3115 : 	return CvUnitMovement::MovementCostNoZOC(pUnit, pFromPlot, this, pUnit->baseMoves(isWater()?DOMAIN_SEA:NO_DOMAIN), pUnit->maxMoves(), iMovesRemaining);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	mov	BYTE PTR $T240026[ebp], dl
	mov	eax, DWORD PTR _iMovesRemaining$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	push	eax
	movzx	ecx, BYTE PTR $T240026[ebp]
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	sub	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	call	?MovementCostNoZOC@CvUnitMovement@@SAHPBVCvUnit@@PBVCvPlot@@1HHH@Z ; CvUnitMovement::MovementCostNoZOC
	add	esp, 24					; 00000018H

; 3116 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MovementCostNoZOC@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ENDP	; CvPlot::MovementCostNoZOC
_TEXT	ENDS
PUBLIC	?IsAllowsWalkWater@CvPlot@@QBE_NXZ		; CvPlot::IsAllowsWalkWater
EXTRN	?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsAllowsWalkWater
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsWalkWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pkEntry$223254 = -8					; size = 4
_eImprovement$ = -4					; size = 4
?IsAllowsWalkWater@CvPlot@@QBE_NXZ PROC			; CvPlot::IsAllowsWalkWater, COMDAT
; _this$ = ecx

; 3120 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3121 : 	ImprovementTypes eImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 3122 : 	if (eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN2@IsAllowsWa

; 3123 : 	{
; 3124 : 		CvImprovementEntry *pkEntry = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkEntry$223254[ebp], eax

; 3125 : 		if (pkEntry)

	cmp	DWORD PTR _pkEntry$223254[ebp], 0
	je	SHORT $LN2@IsAllowsWa

; 3126 : 			return pkEntry->IsAllowsWalkWater();

	mov	ecx, DWORD PTR _pkEntry$223254[ebp]
	call	?IsAllowsWalkWater@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsAllowsWalkWater
	jmp	SHORT $LN3@IsAllowsWa
$LN2@IsAllowsWa:

; 3127 : 	}
; 3128 : 	return false;

	xor	al, al
$LN3@IsAllowsWa:

; 3129 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsWalkWater@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsAllowsWalkWater
_TEXT	ENDS
PUBLIC	?IsAllowsSailLand@CvPlot@@QBE_NXZ		; CvPlot::IsAllowsSailLand
EXTRN	?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsAllowsSailLand
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsSailLand@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pkEntry$223261 = -8					; size = 4
_eImprovement$ = -4					; size = 4
?IsAllowsSailLand@CvPlot@@QBE_NXZ PROC			; CvPlot::IsAllowsSailLand, COMDAT
; _this$ = ecx

; 3132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3133 :     ImprovementTypes eImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 3134 :     if (eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN2@IsAllowsSa

; 3135 :     {
; 3136 :         CvImprovementEntry *pkEntry = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkEntry$223261[ebp], eax

; 3137 :         if (pkEntry)

	cmp	DWORD PTR _pkEntry$223261[ebp], 0
	je	SHORT $LN2@IsAllowsSa

; 3138 :             return pkEntry->IsAllowsSailLand();

	mov	ecx, DWORD PTR _pkEntry$223261[ebp]
	call	?IsAllowsSailLand@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsAllowsSailLand
	jmp	SHORT $LN3@IsAllowsSa
$LN2@IsAllowsSa:

; 3139 :     }
; 3140 :     return false;

	xor	al, al
$LN3@IsAllowsSa:

; 3141 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsSailLand@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsAllowsSailLand
_TEXT	ENDS
PUBLIC	?getExtraMovePathCost@CvPlot@@QBEHXZ		; CvPlot::getExtraMovePathCost
EXTRN	?getPlotExtraCost@CvGame@@QBEHHH@Z:PROC		; CvGame::getPlotExtraCost
; Function compile flags: /Odtp
;	COMDAT ?getExtraMovePathCost@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T240044 = -12						; size = 4
$T240040 = -8						; size = 4
$T240036 = -4						; size = 4
?getExtraMovePathCost@CvPlot@@QBEHXZ PROC		; CvPlot::getExtraMovePathCost, COMDAT
; _this$ = ecx

; 3144 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3145 : 	return GC.getGame().getPlotExtraCost(getX(), getY());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T240036[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T240040[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240044[ebp], ecx
	mov	edx, DWORD PTR $T240036[ebp]
	push	edx
	mov	eax, DWORD PTR $T240040[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240044[ebp]
	call	?getPlotExtraCost@CvGame@@QBEHHH@Z	; CvGame::getPlotExtraCost

; 3146 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getExtraMovePathCost@CvPlot@@QBEHXZ ENDP		; CvPlot::getExtraMovePathCost
_TEXT	ENDS
PUBLIC	?changeExtraMovePathCost@CvPlot@@QAEXH@Z	; CvPlot::changeExtraMovePathCost
EXTRN	?changePlotExtraCost@CvGame@@QAEXHHH@Z:PROC	; CvGame::changePlotExtraCost
; Function compile flags: /Odtp
;	COMDAT ?changeExtraMovePathCost@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T240058 = -12						; size = 4
$T240054 = -8						; size = 4
$T240050 = -4						; size = 4
_iChange$ = 8						; size = 4
?changeExtraMovePathCost@CvPlot@@QAEXH@Z PROC		; CvPlot::changeExtraMovePathCost, COMDAT
; _this$ = ecx

; 3151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3152 : 	GC.getGame().changePlotExtraCost(getX(), getY(), iChange);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T240050[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T240054[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240058[ebp], ecx
	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240050[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240054[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T240058[ebp]
	call	?changePlotExtraCost@CvGame@@QAEXHHH@Z	; CvGame::changePlotExtraCost

; 3153 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeExtraMovePathCost@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeExtraMovePathCost
_TEXT	ENDS
PUBLIC	?isAdjacentOwned@CvPlot@@QBE_NXZ		; CvPlot::isAdjacentOwned
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentOwned@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T240068 = -16						; size = 4
$T240064 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?isAdjacentOwned@CvPlot@@QBE_NXZ PROC			; CvPlot::isAdjacentOwned, COMDAT
; _this$ = ecx

; 3157 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 3158 : 	CvPlot* pAdjacentPlot;
; 3159 : 	int iI;
; 3160 : 
; 3161 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@5
$LN4@isAdjacent@5:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent@5:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent@5

; 3162 : 	{
; 3163 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240064[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T240068[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240064[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240068[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3164 : 
; 3165 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@5

; 3166 : 		{
; 3167 : 			if(pAdjacentPlot->getOwner() != NO_PLAYER)

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, -1
	je	SHORT $LN2@isAdjacent@5

; 3168 : 			{
; 3169 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@5
$LN2@isAdjacent@5:

; 3170 : 			}
; 3171 : 		}
; 3172 : 	}

	jmp	SHORT $LN4@isAdjacent@5
$LN3@isAdjacent@5:

; 3173 : 
; 3174 : 	return false;

	xor	al, al
$LN6@isAdjacent@5:

; 3175 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isAdjacentOwned@CvPlot@@QBE_NXZ ENDP			; CvPlot::isAdjacentOwned
_TEXT	ENDS
PUBLIC	?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::isAdjacentPlayer
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T240288 = -16						; size = 4
$T240284 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
_bLandOnly$ = 12					; size = 1
?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z PROC	; CvPlot::isAdjacentPlayer, COMDAT
; _this$ = ecx

; 3180 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 3181 : 	CvPlot* pAdjacentPlot;
; 3182 : 	int iI;
; 3183 : 
; 3184 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@isAdjacent@6
$LN6@isAdjacent@6:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@isAdjacent@6:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN5@isAdjacent@6

; 3185 : 	{
; 3186 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240284[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T240288[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240284[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240288[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3187 : 
; 3188 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN4@isAdjacent@6

; 3189 : 		{
; 3190 : 			if(pAdjacentPlot->getOwner() == ePlayer)

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN4@isAdjacent@6

; 3191 : 			{
; 3192 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	movzx	ecx, BYTE PTR _bLandOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@isAdjacent@6
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN4@isAdjacent@6
$LN1@isAdjacent@6:

; 3193 : 				{
; 3194 : 					return true;

	mov	al, 1
	jmp	SHORT $LN8@isAdjacent@6
$LN4@isAdjacent@6:

; 3195 : 				}
; 3196 : 			}
; 3197 : 		}
; 3198 : 	}

	jmp	SHORT $LN6@isAdjacent@6
$LN5@isAdjacent@6:

; 3199 : 
; 3200 : 	return false;

	xor	al, al
$LN8@isAdjacent@6:

; 3201 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ENDP	; CvPlot::isAdjacentPlayer
_TEXT	ENDS
PUBLIC	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
; Function compile flags: /Odtp
;	COMDAT ?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T240752 = -120						; size = 4
_playerID$240749 = -116					; size = 4
$T240735 = -112						; size = 4
_playerID$240732 = -108					; size = 4
$T240511 = -16						; size = 4
$T240507 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z PROC ; CvPlot::IsAdjacentOwnedByOtherTeam, COMDAT
; _this$ = ecx

; 3205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 3206 : 	CvPlot* pAdjacentPlot;
; 3207 : 	int iI;
; 3208 : 
; 3209 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@IsAdjacent
$LN4@IsAdjacent:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@IsAdjacent:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN3@IsAdjacent

; 3210 : 	{
; 3211 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240507[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T240511[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240507[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240511[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3212 : 
; 3213 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@IsAdjacent

; 3214 : 		{
; 3215 : 			if(pAdjacentPlot->getTeam() != NO_TEAM && pAdjacentPlot->getTeam() != eTeam)

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$240732[ebp], eax
	cmp	DWORD PTR _playerID$240732[ebp], -1
	je	SHORT $LN97@IsAdjacent
	mov	ecx, DWORD PTR _playerID$240732[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240735[ebp], eax
	jmp	SHORT $LN98@IsAdjacent
	jmp	SHORT $LN98@IsAdjacent
$LN97@IsAdjacent:
	mov	DWORD PTR $T240735[ebp], -1
$LN98@IsAdjacent:
	cmp	DWORD PTR $T240735[ebp], -1
	je	SHORT $LN2@IsAdjacent
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$240749[ebp], eax
	cmp	DWORD PTR _playerID$240749[ebp], -1
	je	SHORT $LN105@IsAdjacent
	mov	ecx, DWORD PTR _playerID$240749[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240752[ebp], eax
	jmp	SHORT $LN106@IsAdjacent
	jmp	SHORT $LN106@IsAdjacent
$LN105@IsAdjacent:
	mov	DWORD PTR $T240752[ebp], -1
$LN106@IsAdjacent:
	mov	edx, DWORD PTR $T240752[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN2@IsAdjacent

; 3216 : 			{
; 3217 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@IsAdjacent
$LN2@IsAdjacent:

; 3218 : 			}
; 3219 : 		}
; 3220 : 	}

	jmp	$LN4@IsAdjacent
$LN3@IsAdjacent:

; 3221 : 
; 3222 : 	return false;

	xor	al, al
$LN6@IsAdjacent:

; 3223 : 
; 3224 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP ; CvPlot::IsAdjacentOwnedByOtherTeam
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T240986 = -112						; size = 4
_playerID$240983 = -108					; size = 4
$T240762 = -16						; size = 4
$T240758 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_bLandOnly$ = 12					; size = 1
?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC	; CvPlot::isAdjacentTeam, COMDAT
; _this$ = ecx

; 3229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 3230 : 	CvPlot* pAdjacentPlot;
; 3231 : 	int iI;
; 3232 : 
; 3233 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@isAdjacent@7
$LN6@isAdjacent@7:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@isAdjacent@7:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN5@isAdjacent@7

; 3234 : 	{
; 3235 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240758[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T240762[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240758[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240762[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3236 : 
; 3237 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN4@isAdjacent@7

; 3238 : 		{
; 3239 : 			if(pAdjacentPlot->getTeam() == eTeam)

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$240983[ebp], eax
	cmp	DWORD PTR _playerID$240983[ebp], -1
	je	SHORT $LN99@isAdjacent@7
	mov	ecx, DWORD PTR _playerID$240983[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T240986[ebp], eax
	jmp	SHORT $LN100@isAdjacent@7
	jmp	SHORT $LN100@isAdjacent@7
$LN99@isAdjacent@7:
	mov	DWORD PTR $T240986[ebp], -1
$LN100@isAdjacent@7:
	mov	edx, DWORD PTR $T240986[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN4@isAdjacent@7

; 3240 : 			{
; 3241 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	movzx	eax, BYTE PTR _bLandOnly$[ebp]
	test	eax, eax
	je	SHORT $LN1@isAdjacent@7
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@isAdjacent@7
$LN1@isAdjacent@7:

; 3242 : 				{
; 3243 : 					return true;

	mov	al, 1
	jmp	SHORT $LN8@isAdjacent@7
$LN4@isAdjacent@7:

; 3244 : 				}
; 3245 : 			}
; 3246 : 		}
; 3247 : 	}

	jmp	$LN6@isAdjacent@7
$LN5@isAdjacent@7:

; 3248 : 
; 3249 : 	return false;

	xor	al, al
$LN8@isAdjacent@7:

; 3250 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP	; CvPlot::isAdjacentTeam
_TEXT	ENDS
PUBLIC	?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z ; CvPlot::GetAdjacentFriendlyCity
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Odtp
;	COMDAT ?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T241196 = -108						; size = 4
_playerID$241188 = -104					; size = 4
$T240999 = -20						; size = 4
$T240995 = -16						; size = 4
_pCity$223338 = -12					; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_bLandOnly$ = 12					; size = 1
?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z PROC ; CvPlot::GetAdjacentFriendlyCity, COMDAT
; _this$ = ecx

; 3254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 3255 : 	CvPlot* pAdjacentPlot;
; 3256 : 	int iI;
; 3257 : 
; 3258 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN9@GetAdjacen
$LN8@GetAdjacen:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN9@GetAdjacen:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN7@GetAdjacen

; 3259 : 	{
; 3260 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T240995[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T240999[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240995[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240999[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3261 : 
; 3262 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	$LN6@GetAdjacen

; 3263 : 		{
; 3264 : 			if(pAdjacentPlot->getTeam() == eTeam && pAdjacentPlot->isCity())

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$241188[ebp], eax
	cmp	DWORD PTR _playerID$241188[ebp], -1
	je	SHORT $LN93@GetAdjacen
	mov	ecx, DWORD PTR _playerID$241188[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T241196[ebp], eax
	jmp	SHORT $LN94@GetAdjacen
	jmp	SHORT $LN94@GetAdjacen
$LN93@GetAdjacen:
	mov	DWORD PTR $T241196[ebp], -1
$LN94@GetAdjacen:
	mov	edx, DWORD PTR $T241196[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN6@GetAdjacen
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@GetAdjacen

; 3265 : 			{
; 3266 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	movzx	ecx, BYTE PTR _bLandOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@GetAdjacen
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN6@GetAdjacen
$LN3@GetAdjacen:

; 3267 : 				{
; 3268 : 					CvCity* pCity = pAdjacentPlot->getPlotCity();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$223338[ebp], eax

; 3269 : 					if(pCity)

	cmp	DWORD PTR _pCity$223338[ebp], 0
	je	SHORT $LN6@GetAdjacen

; 3270 : 					{
; 3271 : 						if(pCity->getTeam() == eTeam)

	mov	ecx, DWORD PTR _pCity$223338[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN6@GetAdjacen

; 3272 : 						{
; 3273 : 							return pCity;

	mov	eax, DWORD PTR _pCity$223338[ebp]
	jmp	SHORT $LN10@GetAdjacen
$LN6@GetAdjacen:

; 3274 : 						}
; 3275 : 					}
; 3276 : 				}
; 3277 : 			}
; 3278 : 		}
; 3279 : 	}

	jmp	$LN8@GetAdjacen
$LN7@GetAdjacen:

; 3280 : 
; 3281 : 	return NULL;

	xor	eax, eax
$LN10@GetAdjacen:

; 3282 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetAdjacentFriendlyCity@CvPlot@@QBEPAVCvCity@@W4TeamTypes@@_N@Z ENDP ; CvPlot::GetAdjacentFriendlyCity
_TEXT	ENDS
PUBLIC	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z	; CvPlot::GetAdjacentCity
; Function compile flags: /Odtp
;	COMDAT ?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T241219 = -20						; size = 4
$T241215 = -16						; size = 4
_pCity$223355 = -12					; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_bLandOnly$ = 8						; size = 1
?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z PROC	; CvPlot::GetAdjacentCity, COMDAT
; _this$ = ecx

; 3286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 3287 : 	CvPlot* pAdjacentPlot;
; 3288 : 	int iI;
; 3289 : 
; 3290 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN8@GetAdjacen@2
$LN7@GetAdjacen@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN8@GetAdjacen@2:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN6@GetAdjacen@2

; 3291 : 	{
; 3292 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T241215[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T241219[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T241215[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241219[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3293 : 
; 3294 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN5@GetAdjacen@2

; 3295 : 		{
; 3296 : 			if(pAdjacentPlot->isCity())

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@GetAdjacen@2

; 3297 : 			{
; 3298 : 				if(!bLandOnly || !(pAdjacentPlot->isWater()))

	movzx	eax, BYTE PTR _bLandOnly$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetAdjacen@2
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@GetAdjacen@2
$LN2@GetAdjacen@2:

; 3299 : 				{
; 3300 : 					CvCity* pCity = pAdjacentPlot->getPlotCity();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$223355[ebp], eax

; 3301 : 					if(pCity)

	cmp	DWORD PTR _pCity$223355[ebp], 0
	je	SHORT $LN5@GetAdjacen@2

; 3302 : 					{
; 3303 : 						return pCity;

	mov	eax, DWORD PTR _pCity$223355[ebp]
	jmp	SHORT $LN9@GetAdjacen@2
$LN5@GetAdjacen@2:

; 3304 : 					}
; 3305 : 				}
; 3306 : 			}
; 3307 : 		}
; 3308 : 	}

	jmp	$LN7@GetAdjacen@2
$LN6@GetAdjacen@2:

; 3309 : 
; 3310 : 	return NULL;

	xor	eax, eax
$LN9@GetAdjacen@2:

; 3311 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z ENDP	; CvPlot::GetAdjacentCity
_TEXT	ENDS
PUBLIC	?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z ; CvPlot::GetNumAdjacentDifferentTeam
; Function compile flags: /Odtp
;	COMDAT ?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T241649 = -116						; size = 4
_playerID$241641 = -112					; size = 4
$T241422 = -20						; size = 4
$T241418 = -16						; size = 4
_iRtnValue$ = -12					; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_bIgnoreWater$ = 12					; size = 1
?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z PROC ; CvPlot::GetNumAdjacentDifferentTeam, COMDAT
; _this$ = ecx

; 3316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 3317 : 	CvPlot* pAdjacentPlot;
; 3318 : 	int iI;
; 3319 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 3320 : 
; 3321 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@GetNumAdja
$LN5@GetNumAdja:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@GetNumAdja:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN4@GetNumAdja

; 3322 : 	{
; 3323 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T241418[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T241422[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T241418[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241422[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3324 : 
; 3325 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN3@GetNumAdja

; 3326 : 		{
; 3327 : 			if(bIgnoreWater && pAdjacentPlot->isWater())

	movzx	edx, BYTE PTR _bIgnoreWater$[ebp]
	test	edx, edx
	je	SHORT $LN103@GetNumAdja
	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN103@GetNumAdja

; 3328 : 			{
; 3329 : 				continue;

	jmp	SHORT $LN5@GetNumAdja

; 3330 : 			}
; 3331 : 
; 3332 : 			if(pAdjacentPlot->getTeam() != eTeam)

$LN103@GetNumAdja:
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$241641[ebp], edx
	cmp	DWORD PTR _playerID$241641[ebp], -1
	je	SHORT $LN100@GetNumAdja
	mov	eax, DWORD PTR _playerID$241641[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T241649[ebp], eax
	jmp	SHORT $LN101@GetNumAdja
	jmp	SHORT $LN101@GetNumAdja
$LN100@GetNumAdja:
	mov	DWORD PTR $T241649[ebp], -1
$LN101@GetNumAdja:
	mov	ecx, DWORD PTR $T241649[ebp]
	cmp	ecx, DWORD PTR _eTeam$[ebp]
	je	SHORT $LN3@GetNumAdja

; 3333 : 			{
; 3334 : 				iRtnValue++;

	mov	edx, DWORD PTR _iRtnValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _iRtnValue$[ebp], edx
$LN3@GetNumAdja:

; 3335 : 			}
; 3336 : 		}
; 3337 : 	}

	jmp	$LN5@GetNumAdja
$LN4@GetNumAdja:

; 3338 : 
; 3339 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 3340 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNumAdjacentDifferentTeam@CvPlot@@QBEHW4TeamTypes@@_N@Z ENDP ; CvPlot::GetNumAdjacentDifferentTeam
_TEXT	ENDS
PUBLIC	?GetNumAdjacentMountains@CvPlot@@QBEHXZ		; CvPlot::GetNumAdjacentMountains
; Function compile flags: /Odtp
;	COMDAT ?GetNumAdjacentMountains@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T241659 = -20						; size = 4
$T241655 = -16						; size = 4
_iNumMountains$ = -12					; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?GetNumAdjacentMountains@CvPlot@@QBEHXZ PROC		; CvPlot::GetNumAdjacentMountains, COMDAT
; _this$ = ecx

; 3343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 3344 : 	CvPlot* pAdjacentPlot;
; 3345 : 	int iI;
; 3346 : 	int iNumMountains = 0;

	mov	DWORD PTR _iNumMountains$[ebp], 0

; 3347 : 
; 3348 : 	for (iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@GetNumAdja@2
$LN4@GetNumAdja@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@GetNumAdja@2:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@GetNumAdja@2

; 3349 : 	{
; 3350 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T241655[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T241659[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T241655[ebp]
	push	eax
	mov	ecx, DWORD PTR $T241659[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3351 : 
; 3352 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@GetNumAdja@2

; 3353 : 		{
; 3354 : 			if (pAdjacentPlot->isMountain())

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetNumAdja@2

; 3355 : 			{
; 3356 : 				iNumMountains++;

	mov	edx, DWORD PTR _iNumMountains$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumMountains$[ebp], edx
$LN2@GetNumAdja@2:

; 3357 : 			}
; 3358 : 		}
; 3359 : 	}

	jmp	SHORT $LN4@GetNumAdja@2
$LN3@GetNumAdja@2:

; 3360 : 	return iNumMountains;

	mov	eax, DWORD PTR _iNumMountains$[ebp]

; 3361 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumAdjacentMountains@CvPlot@@QBEHXZ ENDP		; CvPlot::GetNumAdjacentMountains
_TEXT	ENDS
PUBLIC	?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::plotAction
; Function compile flags: /Odtp
;	COMDAT ?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
tv130 = -20						; size = 4
_this$ = -16						; size = 4
$T241889 = -12						; size = 4
_pUnitNode$ = -8					; size = 4
_pLoopUnit$ = -4					; size = 4
_func$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvPlot::plotAction, COMDAT
; _this$ = ecx

; 3365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3366 : 	IDInfo* pUnitNode;
; 3367 : 	CvUnit* pLoopUnit;
; 3368 : 
; 3369 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN7@plotAction:

; 3370 : 
; 3371 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN8@plotAction

; 3372 : 	{
; 3373 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN10@plotAction
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN10@plotAction
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv130[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv130[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN11@plotAction
$LN10@plotAction:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN11@plotAction:

; 3374 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3375 : 
; 3376 : 		if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN5@plotAction

; 3377 : 		{
; 3378 : 			if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN3@plotAction
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T241889[ebp], edx
	mov	eax, DWORD PTR $T241889[ebp]
	cmp	eax, DWORD PTR _eOwner$[ebp]
	jne	SHORT $LN5@plotAction
$LN3@plotAction:

; 3379 : 			{
; 3380 : 				if((eTeam == NO_TEAM) || (pLoopUnit->getTeam() == eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	SHORT $LN1@plotAction
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN5@plotAction
$LN1@plotAction:

; 3381 : 				{
; 3382 : 					func(pLoopUnit, iData1, iData2);

	mov	ecx, DWORD PTR _iData2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	push	eax
	call	DWORD PTR _func$[ebp]
	add	esp, 12					; 0000000cH
$LN5@plotAction:

; 3383 : 				}
; 3384 : 			}
; 3385 : 		}
; 3386 : 	}

	jmp	$LN7@plotAction
$LN8@plotAction:

; 3387 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?plotAction@CvPlot@@QAEXP6A_NPAVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::plotAction
_TEXT	ENDS
PUBLIC	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
; Function compile flags: /Odtp
;	COMDAT ?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z
_TEXT	SEGMENT
tv142 = -24						; size = 4
_this$ = -20						; size = 4
$T241909 = -16						; size = 4
_iCount$ = -12						; size = 4
_pUnitNode$ = -8					; size = 4
_pLoopUnit$ = -4					; size = 4
_funcA$ = 8						; size = 4
_iData1A$ = 12						; size = 4
_iData2A$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
_funcB$ = 28						; size = 4
_iData1B$ = 32						; size = 4
_iData2B$ = 36						; size = 4
?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z PROC ; CvPlot::plotCount, COMDAT
; _this$ = ecx

; 3392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3393 : 	const IDInfo* pUnitNode;
; 3394 : 	const CvUnit* pLoopUnit;
; 3395 : 	int iCount;
; 3396 : 
; 3397 : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3398 : 
; 3399 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN11@plotCount:

; 3400 : 
; 3401 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN10@plotCount

; 3402 : 	{
; 3403 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN14@plotCount
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN14@plotCount
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv142[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN15@plotCount
$LN14@plotCount:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN15@plotCount:

; 3404 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3405 : 
; 3406 : 		if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN9@plotCount

; 3407 : 		{
; 3408 : 			if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN7@plotCount
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T241909[ebp], edx
	mov	eax, DWORD PTR $T241909[ebp]
	cmp	eax, DWORD PTR _eOwner$[ebp]
	jne	SHORT $LN9@plotCount
$LN7@plotCount:

; 3409 : 			{
; 3410 : 				if((eTeam == NO_TEAM) || (pLoopUnit->getTeam() == eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	SHORT $LN5@plotCount
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN9@plotCount
$LN5@plotCount:

; 3411 : 				{
; 3412 : 					if((funcA == NULL) || funcA(pLoopUnit, iData1A, iData2A))

	cmp	DWORD PTR _funcA$[ebp], 0
	je	SHORT $LN3@plotCount
	mov	ecx, DWORD PTR _iData2A$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData1A$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	push	eax
	call	DWORD PTR _funcA$[ebp]
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@plotCount
$LN3@plotCount:

; 3413 : 					{
; 3414 : 						if((funcB == NULL) || funcB(pLoopUnit, iData1B, iData2B))

	cmp	DWORD PTR _funcB$[ebp], 0
	je	SHORT $LN1@plotCount
	mov	edx, DWORD PTR _iData2B$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData1B$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	push	ecx
	call	DWORD PTR _funcB$[ebp]
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@plotCount
$LN1@plotCount:

; 3415 : 						{
; 3416 : 							iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN9@plotCount:

; 3417 : 						}
; 3418 : 					}
; 3419 : 				}
; 3420 : 			}
; 3421 : 		}
; 3422 : 	}

	jmp	$LN11@plotCount
$LN10@plotCount:

; 3423 : 
; 3424 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3425 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ENDP ; CvPlot::plotCount
_TEXT	ENDS
PUBLIC	?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCheck
PUBLIC	?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCheck
; Function compile flags: /Odtp
;	COMDAT ?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_funcA$ = 8						; size = 4
_iData1A$ = 12						; size = 4
_iData2A$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
_funcB$ = 28						; size = 4
_iData1B$ = 32						; size = 4
_iData2B$ = 36						; size = 4
?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z PROC ; CvPlot::plotCheck, COMDAT
; _this$ = ecx

; 3430 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3431 : 	return const_cast<CvPlot*>(this)->plotCheck(funcA, iData1A, iData2A, eOwner, eTeam, funcB, iData1B, iData2B);

	mov	eax, DWORD PTR _iData2B$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData1B$[ebp]
	push	ecx
	mov	edx, DWORD PTR _funcB$[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOwner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData2A$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData1A$[ebp]
	push	eax
	mov	ecx, DWORD PTR _funcA$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCheck

; 3432 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?plotCheck@CvPlot@@QBEPBVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ENDP ; CvPlot::plotCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z
_TEXT	SEGMENT
tv140 = -20						; size = 4
_this$ = -16						; size = 4
$T241931 = -12						; size = 4
_pUnitNode$ = -8					; size = 4
_pLoopUnit$ = -4					; size = 4
_funcA$ = 8						; size = 4
_iData1A$ = 12						; size = 4
_iData2A$ = 16						; size = 4
_eOwner$ = 20						; size = 4
_eTeam$ = 24						; size = 4
_funcB$ = 28						; size = 4
_iData1B$ = 32						; size = 4
_iData2B$ = 36						; size = 4
?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z PROC ; CvPlot::plotCheck, COMDAT
; _this$ = ecx

; 3436 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3437 : 	IDInfo* pUnitNode;
; 3438 : 	CvUnit* pLoopUnit;
; 3439 : 
; 3440 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN10@plotCheck:

; 3441 : 
; 3442 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN9@plotCheck

; 3443 : 	{
; 3444 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN13@plotCheck
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN13@plotCheck
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv140[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN14@plotCheck
$LN13@plotCheck:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN14@plotCheck:

; 3445 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3446 : 
; 3447 : 		if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN8@plotCheck

; 3448 : 		{
; 3449 : 			if((eOwner == NO_PLAYER) || (pLoopUnit->getOwner() == eOwner))

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN6@plotCheck
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T241931[ebp], edx
	mov	eax, DWORD PTR $T241931[ebp]
	cmp	eax, DWORD PTR _eOwner$[ebp]
	jne	SHORT $LN8@plotCheck
$LN6@plotCheck:

; 3450 : 			{
; 3451 : 				if((eTeam == NO_TEAM) || (pLoopUnit->getTeam() == eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	SHORT $LN4@plotCheck
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN8@plotCheck
$LN4@plotCheck:

; 3452 : 				{
; 3453 : 					if(funcA(pLoopUnit, iData1A, iData2A))

	mov	ecx, DWORD PTR _iData2A$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData1A$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	push	eax
	call	DWORD PTR _funcA$[ebp]
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@plotCheck

; 3454 : 					{
; 3455 : 						if((funcB == NULL) || funcB(pLoopUnit, iData1B, iData2B))

	cmp	DWORD PTR _funcB$[ebp], 0
	je	SHORT $LN1@plotCheck
	mov	edx, DWORD PTR _iData2B$[ebp]
	push	edx
	mov	eax, DWORD PTR _iData1B$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	push	ecx
	call	DWORD PTR _funcB$[ebp]
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@plotCheck
$LN1@plotCheck:

; 3456 : 						{
; 3457 : 							return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN11@plotCheck
$LN8@plotCheck:

; 3458 : 						}
; 3459 : 					}
; 3460 : 				}
; 3461 : 			}
; 3462 : 		}
; 3463 : 	}

	jmp	$LN10@plotCheck
$LN9@plotCheck:

; 3464 : 
; 3465 : 	return NULL;

	xor	eax, eax
$LN11@plotCheck:

; 3466 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?plotCheck@CvPlot@@QAEPAVCvUnit@@P6A_NPBV2@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ENDP ; CvPlot::plotCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isOwned@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isOwned@CvPlot@@QBE_NXZ PROC				; CvPlot::isOwned, COMDAT
; _this$ = ecx

; 3470 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3471 : 	return (getOwner() != NO_PLAYER);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	xor	eax, eax
	cmp	ecx, -1
	setne	al

; 3472 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isOwned@CvPlot@@QBE_NXZ ENDP				; CvPlot::isOwned
_TEXT	ENDS
PUBLIC	?isBarbarian@CvPlot@@QBE_NXZ			; CvPlot::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?isBarbarian@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isBarbarian@CvPlot@@QBE_NXZ PROC			; CvPlot::isBarbarian, COMDAT
; _this$ = ecx

; 3477 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3478 : 	return (getOwner() == BARBARIAN_PLAYER);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	xor	eax, eax
	cmp	ecx, 63					; 0000003fH
	sete	al

; 3479 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isBarbarian@CvPlot@@QBE_NXZ ENDP			; CvPlot::isBarbarian
_TEXT	ENDS
PUBLIC	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedOwner
PUBLIC	?isRevealedBarbarian@CvPlot@@QBE_NXZ		; CvPlot::isRevealedBarbarian
; Function compile flags: /Odtp
;	COMDAT ?isRevealedBarbarian@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T241947 = -4						; size = 4
?isRevealedBarbarian@CvPlot@@QBE_NXZ PROC		; CvPlot::isRevealedBarbarian, COMDAT
; _this$ = ecx

; 3484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3485 : 	return (getRevealedOwner(GC.getGame().getActiveTeam(), true) == BARBARIAN_PLAYER);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241947[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T241947[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedOwner
	xor	ecx, ecx
	cmp	eax, 63					; 0000003fH
	sete	cl
	mov	al, cl

; 3486 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isRevealedBarbarian@CvPlot@@QBE_NXZ ENDP		; CvPlot::isRevealedBarbarian
_TEXT	ENDS
PUBLIC	?HasBarbarianCamp@CvPlot@@QAE_NXZ		; CvPlot::HasBarbarianCamp
; Function compile flags: /Odtp
;	COMDAT ?HasBarbarianCamp@CvPlot@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T241953 = -4						; size = 4
?HasBarbarianCamp@CvPlot@@QAE_NXZ PROC			; CvPlot::HasBarbarianCamp, COMDAT
; _this$ = ecx

; 3490 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3491 : 	return (getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T241953[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T241953[ebp]
	sete	cl
	mov	al, cl

; 3492 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasBarbarianCamp@CvPlot@@QAE_NXZ ENDP			; CvPlot::HasBarbarianCamp
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isActiveVisible@CvPlot@@QBE_N_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T241978 = -13						; size = 1
$T241977 = -12						; size = 4
$T241964 = -8						; size = 4
$T241959 = -4						; size = 4
_bDebug$ = 8						; size = 1
?isActiveVisible@CvPlot@@QBE_N_N@Z PROC			; CvPlot::isActiveVisible, COMDAT
; _this$ = ecx

; 3496 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3497 : 	return isVisible(GC.getGame().getActiveTeam(), bDebug);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241959[ebp], eax
	mov	ecx, DWORD PTR $T241959[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR $T241977[ebp], eax
	movzx	ecx, BYTE PTR _bDebug$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@isActiveVi
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241964[ebp], edx
	mov	ecx, DWORD PTR $T241964[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@isActiveVi
	mov	BYTE PTR $T241978[ebp], 1
	jmp	SHORT $LN8@isActiveVi
	jmp	SHORT $LN8@isActiveVi
$LN7@isActiveVi:
	cmp	DWORD PTR $T241977[ebp], -1
	jne	SHORT $LN12@isActiveVi
	mov	BYTE PTR $T241978[ebp], 0
	jmp	SHORT $LN8@isActiveVi
$LN12@isActiveVi:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR $T241977[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T241978[ebp], dl
$LN8@isActiveVi:
	mov	al, BYTE PTR $T241978[ebp]

; 3498 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isActiveVisible@CvPlot@@QBE_N_N@Z ENDP			; CvPlot::isActiveVisible
_TEXT	ENDS
PUBLIC	?isActiveVisible@CvPlot@@QBE_NXZ		; CvPlot::isActiveVisible
; Function compile flags: /Odtp
;	COMDAT ?isActiveVisible@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T241995 = -9						; size = 1
$T241994 = -8						; size = 4
$T241984 = -4						; size = 4
?isActiveVisible@CvPlot@@QBE_NXZ PROC			; CvPlot::isActiveVisible, COMDAT
; _this$ = ecx

; 3502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3503 : 	return isVisible(GC.getGame().getActiveTeam());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T241984[ebp], eax
	mov	ecx, DWORD PTR $T241984[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR $T241994[ebp], eax
	cmp	DWORD PTR $T241994[ebp], -1
	jne	SHORT $LN8@isActiveVi@2
	mov	BYTE PTR $T241995[ebp], 0
	jmp	SHORT $LN6@isActiveVi@2
$LN8@isActiveVi@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR $T241994[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T241995[ebp], dl
$LN6@isActiveVi@2:
	mov	al, BYTE PTR $T241995[ebp]

; 3504 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isActiveVisible@CvPlot@@QBE_NXZ ENDP			; CvPlot::isActiveVisible
_TEXT	ENDS
PUBLIC	?isVisibleToCivTeam@CvPlot@@QBE_NXZ		; CvPlot::isVisibleToCivTeam
; Function compile flags: /Odtp
;	COMDAT ?isVisibleToCivTeam@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T242014 = -9						; size = 1
$T242001 = -8						; size = 4
_iI$ = -4						; size = 4
?isVisibleToCivTeam@CvPlot@@QBE_NXZ PROC		; CvPlot::isVisibleToCivTeam, COMDAT
; _this$ = ecx

; 3508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3509 : 	int iI;
; 3510 : 
; 3511 : 	for(iI = 0; iI < MAX_CIV_TEAMS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isVisibleT
$LN4@isVisibleT:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isVisibleT:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN3@isVisibleT

; 3512 : 	{
; 3513 : 		if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T242001[ebp], ecx
	mov	edx, DWORD PTR $T242001[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@isVisibleT

; 3514 : 		{
; 3515 : 			if(isVisible(((TeamTypes)iI)))

	cmp	DWORD PTR _iI$[ebp], -1
	jne	SHORT $LN15@isVisibleT
	mov	BYTE PTR $T242014[ebp], 0
	jmp	SHORT $LN13@isVisibleT
$LN15@isVisibleT:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _iI$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T242014[ebp], al
$LN13@isVisibleT:
	movzx	ecx, BYTE PTR $T242014[ebp]
	test	ecx, ecx
	je	SHORT $LN2@isVisibleT

; 3516 : 			{
; 3517 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isVisibleT
$LN2@isVisibleT:

; 3518 : 			}
; 3519 : 		}
; 3520 : 	}

	jmp	SHORT $LN4@isVisibleT
$LN3@isVisibleT:

; 3521 : 
; 3522 : 	return false;

	xor	al, al
$LN6@isVisibleT:

; 3523 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isVisibleToCivTeam@CvPlot@@QBE_NXZ ENDP		; CvPlot::isVisibleToCivTeam
_TEXT	ENDS
PUBLIC	?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isVisibleToEnemyTeam
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
; Function compile flags: /Odtp
;	COMDAT ?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T242032 = -9						; size = 1
_kTeam$223504 = -8					; size = 4
_iI$ = -4						; size = 4
_eFriendlyTeam$ = 8					; size = 4
?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isVisibleToEnemyTeam, COMDAT
; _this$ = ecx

; 3528 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3529 : 	int iI;
; 3530 : 
; 3531 : 	for(iI = 0; iI < MAX_CIV_TEAMS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@isVisibleT@2
$LN5@isVisibleT@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@isVisibleT@2:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	SHORT $LN4@isVisibleT@2

; 3532 : 	{
; 3533 : 		CvTeam& kTeam = GET_TEAM((TeamTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$223504[ebp], ecx

; 3534 : 
; 3535 : 		if(kTeam.isAlive())

	mov	edx, DWORD PTR _kTeam$223504[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+12], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@isVisibleT@2

; 3536 : 		{
; 3537 : 			if(kTeam.isAtWar(eFriendlyTeam))

	mov	edx, DWORD PTR _eFriendlyTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam$223504[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@isVisibleT@2

; 3538 : 			{
; 3539 : 				if(isVisible(((TeamTypes)iI)))

	cmp	DWORD PTR _iI$[ebp], -1
	jne	SHORT $LN16@isVisibleT@2
	mov	BYTE PTR $T242032[ebp], 0
	jmp	SHORT $LN14@isVisibleT@2
$LN16@isVisibleT@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _iI$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T242032[ebp], dl
$LN14@isVisibleT@2:
	movzx	eax, BYTE PTR $T242032[ebp]
	test	eax, eax
	je	SHORT $LN3@isVisibleT@2

; 3540 : 				{
; 3541 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@isVisibleT@2
$LN3@isVisibleT@2:

; 3542 : 				}
; 3543 : 			}
; 3544 : 		}
; 3545 : 	}

	jmp	SHORT $LN5@isVisibleT@2
$LN4@isVisibleT@2:

; 3546 : 
; 3547 : 	return false;

	xor	al, al
$LN7@isVisibleT@2:

; 3548 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isVisibleToEnemyTeam
_TEXT	ENDS
PUBLIC	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ	; CvPlot::isVisibleToWatchingHuman
EXTRN	?slotClaim@CvPreGame@@YA?AW4SlotClaim@@W4PlayerTypes@@@Z:PROC ; CvPreGame::slotClaim
EXTRN	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z:PROC ; CvPreGame::slotStatus
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
; Function compile flags: /Odtp
;	COMDAT ?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T242065 = -17						; size = 1
$T242055 = -16						; size = 4
$T242046 = -9						; size = 1
_thisPlayer$223517 = -8					; size = 4
_iI$ = -4						; size = 4
?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ PROC		; CvPlot::isVisibleToWatchingHuman, COMDAT
; _this$ = ecx

; 3553 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 3554 : 	int iI;
; 3555 : 
; 3556 : 	for(iI = 0; iI < MAX_CIV_PLAYERS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@isVisibleT@3
$LN6@isVisibleT@3:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@isVisibleT@3:
	cmp	DWORD PTR _iI$[ebp], 63			; 0000003fH
	jge	$LN5@isVisibleT@3

; 3557 : 	{
; 3558 : 		CvPlayerAI& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$223517[ebp], ecx

; 3559 : 		if( (thisPlayer.isAlive() && thisPlayer.isHuman()) || ( CvPreGame::slotStatus((PlayerTypes)iI) == SS_OBSERVER && CvPreGame::slotClaim((PlayerTypes)iI) == SLOTCLAIM_ASSIGNED) )

	mov	edx, DWORD PTR _thisPlayer$223517[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T242046[ebp], al
	movzx	ecx, BYTE PTR $T242046[ebp]
	test	ecx, ecx
	je	SHORT $LN2@isVisibleT@3
	mov	ecx, DWORD PTR _thisPlayer$223517[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN18@isVisibleT@3
$LN2@isVisibleT@3:
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	call	?slotStatus@CvPreGame@@YA?AW4SlotStatus@@W4PlayerTypes@@@Z ; CvPreGame::slotStatus
	add	esp, 4
	cmp	eax, 4
	jne	SHORT $LN4@isVisibleT@3
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	call	?slotClaim@CvPreGame@@YA?AW4SlotClaim@@W4PlayerTypes@@@Z ; CvPreGame::slotClaim
	add	esp, 4
	cmp	eax, 2
	jne	SHORT $LN4@isVisibleT@3

; 3560 : 		{
; 3561 : 			if(isVisible(thisPlayer.getTeam()))

$LN18@isVisibleT@3:
	mov	edx, DWORD PTR _thisPlayer$223517[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T242055[ebp], eax
	cmp	DWORD PTR $T242055[ebp], -1
	jne	SHORT $LN23@isVisibleT@3
	mov	BYTE PTR $T242065[ebp], 0
	jmp	SHORT $LN21@isVisibleT@3
$LN23@isVisibleT@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR $T242055[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T242065[ebp], dl
$LN21@isVisibleT@3:
	movzx	eax, BYTE PTR $T242065[ebp]
	test	eax, eax
	je	SHORT $LN4@isVisibleT@3

; 3562 : 			{
; 3563 : 				return true;

	mov	al, 1
	jmp	SHORT $LN8@isVisibleT@3
$LN4@isVisibleT@3:

; 3564 : 			}
; 3565 : 		}
; 3566 : 	}

	jmp	$LN6@isVisibleT@3
$LN5@isVisibleT@3:

; 3567 : 
; 3568 : 	return false;

	xor	al, al
$LN8@isVisibleT@3:

; 3569 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ENDP		; CvPlot::isVisibleToWatchingHuman
_TEXT	ENDS
PUBLIC	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentVisible
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T242300 = -109						; size = 1
$T242287 = -108						; size = 4
$T242075 = -16						; size = 4
$T242071 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC	; CvPlot::isAdjacentVisible, COMDAT
; _this$ = ecx

; 3574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 3575 : 	CvPlot* pAdjacentPlot;
; 3576 : 	int iI;
; 3577 : 
; 3578 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@8
$LN4@isAdjacent@8:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent@8:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN3@isAdjacent@8

; 3579 : 	{
; 3580 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T242071[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T242075[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242071[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242075[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3581 : 
; 3582 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@8

; 3583 : 		{
; 3584 : 			if(pAdjacentPlot->isVisible(eTeam, bDebug))

	movzx	edx, BYTE PTR _bDebug$[ebp]
	test	edx, edx
	je	SHORT $LN98@isAdjacent@8
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T242287[ebp], eax
	mov	ecx, DWORD PTR $T242287[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN98@isAdjacent@8
	mov	BYTE PTR $T242300[ebp], 1
	jmp	SHORT $LN99@isAdjacent@8
	jmp	SHORT $LN99@isAdjacent@8
$LN98@isAdjacent@8:
	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN103@isAdjacent@8
	mov	BYTE PTR $T242300[ebp], 0
	jmp	SHORT $LN99@isAdjacent@8
$LN103@isAdjacent@8:
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T242300[ebp], al
$LN99@isAdjacent@8:
	movzx	ecx, BYTE PTR $T242300[ebp]
	test	ecx, ecx
	je	SHORT $LN2@isAdjacent@8

; 3585 : 			{
; 3586 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@8
$LN2@isAdjacent@8:

; 3587 : 			}
; 3588 : 		}
; 3589 : 	}

	jmp	$LN4@isAdjacent@8
$LN3@isAdjacent@8:

; 3590 : 
; 3591 : 	return false;

	xor	al, al
$LN6@isAdjacent@8:

; 3592 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP	; CvPlot::isAdjacentVisible
_TEXT	ENDS
PUBLIC	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isAdjacentVisible
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T242527 = -105						; size = 1
$T242310 = -16						; size = 4
$T242306 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isAdjacentVisible, COMDAT
; _this$ = ecx

; 3596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 3597 : 	CvPlot* pAdjacentPlot;
; 3598 : 	int iI;
; 3599 : 
; 3600 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@9
$LN4@isAdjacent@9:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent@9:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent@9

; 3601 : 	{
; 3602 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T242306[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T242310[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242306[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242310[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3603 : 
; 3604 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@9

; 3605 : 		{
; 3606 : 			if(pAdjacentPlot->isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN99@isAdjacent@9
	mov	BYTE PTR $T242527[ebp], 0
	jmp	SHORT $LN97@isAdjacent@9
$LN99@isAdjacent@9:
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T242527[ebp], al
$LN97@isAdjacent@9:
	movzx	ecx, BYTE PTR $T242527[ebp]
	test	ecx, ecx
	je	SHORT $LN2@isAdjacent@9

; 3607 : 			{
; 3608 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@9
$LN2@isAdjacent@9:

; 3609 : 			}
; 3610 : 		}
; 3611 : 	}

	jmp	SHORT $LN4@isAdjacent@9
$LN3@isAdjacent@9:

; 3612 : 
; 3613 : 	return false;

	xor	al, al
$LN6@isAdjacent@9:

; 3614 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isAdjacentVisible
_TEXT	ENDS
PUBLIC	?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonvisible
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T242754 = -105						; size = 1
$T242537 = -16						; size = 4
$T242533 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isAdjacentNonvisible, COMDAT
; _this$ = ecx

; 3618 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 3619 : 	CvPlot* pAdjacentPlot;
; 3620 : 	int iI;
; 3621 : 
; 3622 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@10
$LN4@isAdjacent@10:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent@10:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent@10

; 3623 : 	{
; 3624 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T242533[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T242537[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242533[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242537[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3625 : 
; 3626 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@10

; 3627 : 		{
; 3628 : 			if(!pAdjacentPlot->isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN99@isAdjacent@10
	mov	BYTE PTR $T242754[ebp], 0
	jmp	SHORT $LN97@isAdjacent@10
$LN99@isAdjacent@10:
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T242754[ebp], al
$LN97@isAdjacent@10:
	movzx	ecx, BYTE PTR $T242754[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@isAdjacent@10

; 3629 : 			{
; 3630 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@10
$LN2@isAdjacent@10:

; 3631 : 			}
; 3632 : 		}
; 3633 : 	}

	jmp	SHORT $LN4@isAdjacent@10
$LN3@isAdjacent@10:

; 3634 : 
; 3635 : 	return false;

	xor	al, al
$LN6@isAdjacent@10:

; 3636 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isAdjacentNonvisible
_TEXT	ENDS
PUBLIC	?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonvisible
; Function compile flags: /Odtp
;	COMDAT ?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T242981 = -109						; size = 1
$T242764 = -20						; size = 4
$T242760 = -16						; size = 4
_iI$223568 = -12					; size = 4
_iCount$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z PROC ; CvPlot::getNumAdjacentNonvisible, COMDAT
; _this$ = ecx

; 3640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 3641 : 	CvPlot* pAdjacentPlot;
; 3642 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3643 : 
; 3644 : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$223568[ebp], 0
	jmp	SHORT $LN5@getNumAdja
$LN4@getNumAdja:
	mov	eax, DWORD PTR _iI$223568[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$223568[ebp], eax
$LN5@getNumAdja:
	cmp	DWORD PTR _iI$223568[ebp], 6
	jge	SHORT $LN3@getNumAdja

; 3645 : 	{
; 3646 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T242760[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T242764[ebp], ecx
	mov	edx, DWORD PTR _iI$223568[ebp]
	push	edx
	mov	eax, DWORD PTR $T242760[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242764[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 3647 : 
; 3648 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@getNumAdja

; 3649 : 		{
; 3650 : 			if(!pAdjacentPlot->isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN99@getNumAdja
	mov	BYTE PTR $T242981[ebp], 0
	jmp	SHORT $LN97@getNumAdja
$LN99@getNumAdja:
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T242981[ebp], al
$LN97@getNumAdja:
	movzx	ecx, BYTE PTR $T242981[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@getNumAdja

; 3651 : 			{
; 3652 : 				iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$LN2@getNumAdja:

; 3653 : 			}
; 3654 : 		}
; 3655 : 	}

	jmp	SHORT $LN4@getNumAdja
$LN3@getNumAdja:

; 3656 : 
; 3657 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3658 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumAdjacentNonvisible@CvPlot@@QBEHW4TeamTypes@@@Z ENDP ; CvPlot::getNumAdjacentNonvisible
_TEXT	ENDS
PUBLIC	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isGoody
EXTRN	?IsGoody@CvImprovementEntry@@QBE_NXZ:PROC	; CvImprovementEntry::IsGoody
EXTRN	?isMinorCiv@CvTeam@@QBE_NXZ:PROC		; CvTeam::isMinorCiv
EXTRN	?isBarbarian@CvTeam@@QBE_NXZ:PROC		; CvTeam::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv87 = -13						; size = 1
_this$ = -12						; size = 4
$T242993 = -8						; size = 4
$T242989 = -4						; size = 4
_eTeam$ = 8						; size = 4
?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isGoody, COMDAT
; _this$ = ecx

; 3662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3663 : 	if((eTeam != NO_TEAM) && (GET_TEAM(eTeam).isBarbarian() || GET_TEAM(eTeam).isMinorCiv()))

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	SHORT $LN2@isGoody
	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T242989[ebp], eax
	mov	ecx, DWORD PTR $T242989[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@isGoody
	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T242993[ebp], edx
	mov	ecx, DWORD PTR $T242993[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@isGoody
$LN1@isGoody:

; 3664 : 	{
; 3665 : 		return false;

	xor	al, al
	jmp	SHORT $LN3@isGoody
$LN2@isGoody:

; 3666 : 	}
; 3667 : 
; 3668 : 	return ((getImprovementType() == NO_IMPROVEMENT) ? false : GC.getImprovementInfo(getImprovementType())->IsGoody());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	SHORT $LN5@isGoody
	mov	BYTE PTR tv87[ebp], 0
	jmp	SHORT $LN6@isGoody
$LN5@isGoody:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	mov	BYTE PTR tv87[ebp], al
$LN6@isGoody:
	mov	al, BYTE PTR tv87[ebp]
$LN3@isGoody:

; 3669 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isGoody
_TEXT	ENDS
PUBLIC	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealedGoody
; Function compile flags: /Odtp
;	COMDAT ?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
tv129 = -17						; size = 1
_this$ = -16						; size = 4
_uiOffset$243014 = -12					; size = 4
$T243005 = -8						; size = 4
$T243001 = -4						; size = 4
_eTeam$ = 8						; size = 4
?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isRevealedGoody, COMDAT
; _this$ = ecx

; 3674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3675 : 	if(eTeam == NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN4@isRevealed

; 3676 : 	{
; 3677 : 		return isGoody();

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	jmp	$LN5@isRevealed
$LN4@isRevealed:

; 3678 : 	}
; 3679 : 
; 3680 : 	if(GET_TEAM(eTeam).isBarbarian() || GET_TEAM(eTeam).isMinorCiv())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243001[ebp], eax
	mov	ecx, DWORD PTR $T243001[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@isRevealed
	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243005[ebp], edx
	mov	ecx, DWORD PTR $T243005[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@isRevealed
$LN2@isRevealed:

; 3681 : 	{
; 3682 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@isRevealed
$LN3@isRevealed:

; 3683 : 	}
; 3684 : 
; 3685 : 	if(!isRevealed(eTeam))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$243014[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$243014[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$243014[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@isRevealed

; 3686 : 	{
; 3687 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@isRevealed
$LN1@isRevealed:

; 3688 : 	}
; 3689 : 
; 3690 : 	return ((getRevealedImprovementType(eTeam) == NO_IMPROVEMENT) ? false : GC.getImprovementInfo(getRevealedImprovementType(eTeam))->IsGoody());

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	cmp	eax, -1
	jne	SHORT $LN7@isRevealed
	mov	BYTE PTR tv129[ebp], 0
	jmp	SHORT $LN8@isRevealed
$LN7@isRevealed:
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	mov	BYTE PTR tv129[ebp], al
$LN8@isRevealed:
	mov	al, BYTE PTR tv129[ebp]
$LN5@isRevealed:

; 3691 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isRevealedGoody
_TEXT	ENDS
PUBLIC	?removeGoody@CvPlot@@QAEXXZ			; CvPlot::removeGoody
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
; Function compile flags: /Odtp
;	COMDAT ?removeGoody@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T243034 = -16						; size = 4
$T243030 = -9						; size = 1
$T243021 = -8						; size = 4
_i$223592 = -4						; size = 4
?removeGoody@CvPlot@@QAEXXZ PROC			; CvPlot::removeGoody, COMDAT
; _this$ = ecx

; 3696 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3697 : 	setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 3698 : 	// Make sure the player's redo their goody hut searches
; 3699 : 	for(int i = 0; i < MAX_PLAYERS; i++)

	mov	DWORD PTR _i$223592[ebp], 0
	jmp	SHORT $LN4@removeGood
$LN3@removeGood:
	mov	eax, DWORD PTR _i$223592[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223592[ebp], eax
$LN4@removeGood:
	cmp	DWORD PTR _i$223592[ebp], 64		; 00000040H
	jge	SHORT $LN5@removeGood

; 3700 : 	{
; 3701 : 		if(GET_PLAYER((PlayerTypes)i).isAlive())

	mov	ecx, DWORD PTR _i$223592[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243021[ebp], ecx
	mov	edx, DWORD PTR $T243021[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T243030[ebp], al
	movzx	ecx, BYTE PTR $T243030[ebp]
	test	ecx, ecx
	je	SHORT $LN1@removeGood

; 3702 : 		{
; 3703 : 			GET_PLAYER((PlayerTypes)i).GetEconomicAI()->m_bExplorationPlotsDirty = true;

	mov	edx, DWORD PTR _i$223592[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243034[ebp], edx
	mov	ecx, DWORD PTR $T243034[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	BYTE PTR [eax], 1
$LN1@removeGood:

; 3704 : 		}

	jmp	SHORT $LN3@removeGood
$LN5@removeGood:

; 3705 : 	}
; 3706 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?removeGoody@CvPlot@@QAEXXZ ENDP			; CvPlot::removeGoody
_TEXT	ENDS
PUBLIC	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z	; CvPlot::isFriendlyCity
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z:PROC ; CvUnit::getCombatOwner
; Function compile flags: /Odtp
;	COMDAT ?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T243074 = -28						; size = 4
$T243062 = -24						; size = 4
$T243061 = -20						; size = 4
_playerID$243055 = -16					; size = 4
_eTeam$223607 = -8					; size = 4
_ePlotTeam$ = -4					; size = 4
_kUnit$ = 8						; size = 4
___formal$ = 12						; size = 1
?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z PROC	; CvPlot::isFriendlyCity, COMDAT
; _this$ = ecx

; 3710 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 3711 : 	if(!getPlotCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	jne	SHORT $LN16@isFriendly

; 3712 : 	{
; 3713 : 		return false;

	xor	al, al
	jmp	$LN5@isFriendly

; 3714 : 	}
; 3715 : 
; 3716 : 	TeamTypes ePlotTeam = getTeam();

$LN16@isFriendly:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$243055[ebp], ecx
	cmp	DWORD PTR _playerID$243055[ebp], -1
	je	SHORT $LN13@isFriendly
	mov	edx, DWORD PTR _playerID$243055[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlotTeam$[ebp], eax
	jmp	SHORT $LN14@isFriendly
	jmp	SHORT $LN14@isFriendly
$LN13@isFriendly:
	mov	DWORD PTR _ePlotTeam$[ebp], -1
$LN14@isFriendly:

; 3717 : 
; 3718 : 	if(NO_TEAM != ePlotTeam)

	cmp	DWORD PTR _ePlotTeam$[ebp], -1
	je	SHORT $LN3@isFriendly

; 3719 : 	{
; 3720 : 		TeamTypes eTeam = GET_PLAYER(kUnit.getCombatOwner(ePlotTeam, *this)).getTeam();

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlotTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUnit$[ebp]
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	mov	DWORD PTR $T243061[ebp], eax
	mov	edx, DWORD PTR $T243061[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243062[ebp], edx
	mov	eax, DWORD PTR $T243062[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223607[ebp], eax

; 3721 : 
; 3722 : 		if(eTeam == ePlotTeam)

	mov	edx, DWORD PTR _eTeam$223607[ebp]
	cmp	edx, DWORD PTR _ePlotTeam$[ebp]
	jne	SHORT $LN2@isFriendly

; 3723 : 		{
; 3724 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@isFriendly
$LN2@isFriendly:

; 3725 : 		}
; 3726 : 
; 3727 : 		if(GET_TEAM(ePlotTeam).IsAllowsOpenBordersToTeam(eTeam))

	mov	eax, DWORD PTR _ePlotTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243074[ebp], eax
	mov	ecx, DWORD PTR _eTeam$223607[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T243074[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@isFriendly

; 3728 : 		{
; 3729 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@isFriendly
$LN3@isFriendly:

; 3730 : 		}
; 3731 : 	}
; 3732 : 
; 3733 : 	return false;

	xor	al, al
$LN5@isFriendly:

; 3734 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ENDP	; CvPlot::isFriendlyCity
_TEXT	ENDS
PUBLIC	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
EXTRN	?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsPlayerHasOpenBorders
EXTRN	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ:PROC ; CvTeam::getLeaderID
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T243128 = -44						; size = 4
$T243124 = -40						; size = 4
$T243120 = -36						; size = 4
$T243116 = -32						; size = 4
$T243112 = -28						; size = 4
_playerID$243106 = -24					; size = 4
$T243084 = -20						; size = 4
$T243080 = -16						; size = 4
_eCityState$223621 = -12				; size = 4
_ePlotOwner$ = -8					; size = 4
_eTeam$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC ; CvPlot::IsFriendlyTerritory, COMDAT
; _this$ = ecx

; 3739 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 3740 : 	// No friendly territory for barbs!
; 3741 : 	if(GET_PLAYER(ePlayer).isBarbarian())

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243080[ebp], eax
	mov	ecx, DWORD PTR $T243080[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@IsFriendly

; 3742 : 	{
; 3743 : 		return false;

	xor	al, al
	jmp	$LN8@IsFriendly
$LN7@IsFriendly:

; 3744 : 	}
; 3745 : 
; 3746 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243084[ebp], edx
	mov	eax, DWORD PTR $T243084[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 3747 : 	TeamTypes ePlotOwner = getTeam();

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$243106[ebp], eax
	cmp	DWORD PTR _playerID$243106[ebp], -1
	je	SHORT $LN19@IsFriendly
	mov	ecx, DWORD PTR _playerID$243106[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlotOwner$[ebp], eax
	jmp	SHORT $LN20@IsFriendly
	jmp	SHORT $LN20@IsFriendly
$LN19@IsFriendly:
	mov	DWORD PTR _ePlotOwner$[ebp], -1
$LN20@IsFriendly:

; 3748 : 
; 3749 : 	// Nobody owns this plot
; 3750 : 	if(ePlotOwner == NO_TEAM)

	cmp	DWORD PTR _ePlotOwner$[ebp], -1
	jne	SHORT $LN6@IsFriendly

; 3751 : 	{
; 3752 : 		return false;

	xor	al, al
	jmp	$LN8@IsFriendly
$LN6@IsFriendly:

; 3753 : 	}
; 3754 : 
; 3755 : 	// Our territory
; 3756 : 	if(ePlotOwner == eTeam)

	mov	edx, DWORD PTR _ePlotOwner$[ebp]
	cmp	edx, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN5@IsFriendly

; 3757 : 	{
; 3758 : 		return true;

	mov	al, 1
	jmp	$LN8@IsFriendly
$LN5@IsFriendly:

; 3759 : 	}
; 3760 : 
; 3761 : 	// City State's territory we've earned OB with
; 3762 : 	if(!GET_PLAYER(ePlayer).isMinorCiv())

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243112[ebp], eax
	mov	ecx, DWORD PTR $T243112[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@IsFriendly

; 3763 : 	{
; 3764 : 		if(GET_TEAM(ePlotOwner).isMinorCiv())

	mov	edx, DWORD PTR _ePlotOwner$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243116[ebp], edx
	mov	ecx, DWORD PTR $T243116[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsFriendly

; 3765 : 		{
; 3766 : 			PlayerTypes eCityState = GET_TEAM(ePlotOwner).getLeaderID();

	mov	ecx, DWORD PTR _ePlotOwner$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243120[ebp], ecx
	mov	ecx, DWORD PTR $T243120[ebp]
	call	?getLeaderID@CvTeam@@QBE?AW4PlayerTypes@@XZ ; CvTeam::getLeaderID
	mov	DWORD PTR _eCityState$223621[ebp], eax

; 3767 : 
; 3768 : 			if(GET_PLAYER(eCityState).GetMinorCivAI()->IsPlayerHasOpenBorders(ePlayer))

	mov	edx, DWORD PTR _eCityState$223621[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243124[ebp], edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243124[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsPlayerHasOpenBorders@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsPlayerHasOpenBorders
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsFriendly

; 3769 : 			{
; 3770 : 				return true;

	mov	al, 1
	jmp	SHORT $LN8@IsFriendly
$LN4@IsFriendly:

; 3771 : 			}
; 3772 : 		}
; 3773 : 	}
; 3774 : 
; 3775 : 	// Major's territory we have OB with
; 3776 : 	if(GET_TEAM(ePlotOwner).IsAllowsOpenBordersToTeam(eTeam))

	mov	edx, DWORD PTR _ePlotOwner$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T243128[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243128[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@IsFriendly

; 3777 : 	{
; 3778 : 		return true;

	mov	al, 1
	jmp	SHORT $LN8@IsFriendly
$LN1@IsFriendly:

; 3779 : 	}
; 3780 : 
; 3781 : 	return false;

	xor	al, al
$LN8@IsFriendly:

; 3782 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP ; CvPlot::IsFriendlyTerritory
_TEXT	ENDS
EXTRN	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z:PROC ; CvCityCitizens::IsWorkingPlot
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
; Function compile flags: /Odtp
;	COMDAT ?isBeingWorked@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pWorkingCity$ = -4					; size = 4
?isBeingWorked@CvPlot@@QBE_NXZ PROC			; CvPlot::isBeingWorked, COMDAT
; _this$ = ecx

; 3786 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3787 : 	CvCity* pWorkingCity;
; 3788 : 
; 3789 : 	pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$[ebp], eax

; 3790 : 
; 3791 : 	if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN1@isBeingWor

; 3792 : 	{
; 3793 : 		return pWorkingCity->GetCityCitizens()->IsWorkingPlot(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	jmp	SHORT $LN2@isBeingWor
$LN1@isBeingWor:

; 3794 : 	}
; 3795 : 
; 3796 : 	return false;

	xor	al, al
$LN2@isBeingWor:

; 3797 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isBeingWorked@CvPlot@@QBE_NXZ ENDP			; CvPlot::isBeingWorked
_TEXT	ENDS
PUBLIC	?getNumUnits@CvPlot@@QBEHXZ			; CvPlot::getNumUnits
PUBLIC	?isUnit@CvPlot@@QBE_NXZ				; CvPlot::isUnit
; Function compile flags: /Odtp
;	COMDAT ?isUnit@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isUnit@CvPlot@@QBE_NXZ PROC				; CvPlot::isUnit, COMDAT
; _this$ = ecx

; 3802 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3803 : 	return (getNumUnits() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 3804 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isUnit@CvPlot@@QBE_NXZ ENDP				; CvPlot::isUnit
_TEXT	ENDS
PUBLIC	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
EXTRN	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z:PROC ; CvUnit::isAlwaysHostile
; Function compile flags: /Odtp
;	COMDAT ?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
tv165 = -68						; size = 4
_this$ = -64						; size = 4
$T243216 = -48						; size = 4
$T243202 = -44						; size = 4
$T243190 = -40						; size = 4
_iIndex$243215 = -36					; size = 4
$T243164 = -32						; size = 4
$T243160 = -28						; size = 4
$T243151 = -24						; size = 4
_uSize$243148 = -20					; size = 4
_pLoopUnit$223663 = -16					; size = 4
_bAlwaysHostile$223659 = -9				; size = 1
_eTeam$223658 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_pUnit$ = 8						; size = 4
?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z PROC	; CvPlot::isVisibleEnemyDefender, COMDAT
; _this$ = ecx

; 3843 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 3844 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 3845 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243151[ebp], eax
	mov	ecx, DWORD PTR $T243151[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243148[ebp], edx
	cmp	DWORD PTR _uSize$243148[ebp], 0
	jbe	SHORT $LN10@isVisibleE
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243151[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@isVisibleE
	jmp	SHORT $LN11@isVisibleE
$LN10@isVisibleE:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@isVisibleE:

; 3846 : 	if(pUnit && pUnitNode)

	cmp	DWORD PTR _pUnit$[ebp], 0
	je	$LN6@isVisibleE
	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@isVisibleE

; 3847 : 	{
; 3848 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T243160[ebp], eax
	mov	ecx, DWORD PTR $T243160[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243164[ebp], ecx
	mov	edx, DWORD PTR $T243164[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223658[ebp], eax

; 3849 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$223659[ebp], al
$LN5@isVisibleE:

; 3850 : 
; 3851 : 		do
; 3852 : 		{
; 3853 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN27@isVisibleE
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN27@isVisibleE
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv165[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv165[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv165[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223663[ebp], eax
	jmp	SHORT $LN28@isVisibleE
$LN27@isVisibleE:
	mov	DWORD PTR _pLoopUnit$223663[ebp], 0
$LN28@isVisibleE:

; 3854 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243216[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243216[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243215[ebp], edx
	mov	edx, DWORD PTR $T243216[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243190[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243215[ebp]
	cmp	ecx, DWORD PTR $T243190[ebp]
	jae	SHORT $LN37@isVisibleE
	mov	edx, DWORD PTR $T243216[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243215[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243202[ebp], edx
	jmp	SHORT $LN32@isVisibleE
	jmp	SHORT $LN32@isVisibleE
$LN37@isVisibleE:
	mov	DWORD PTR $T243202[ebp], 0
$LN32@isVisibleE:
	mov	eax, DWORD PTR $T243202[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3855 : 
; 3856 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 3857 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 3858 : #else
; 3859 : 			if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$223663[ebp], 0
	je	SHORT $LN4@isVisibleE

; 3860 : #endif
; 3861 : 			{
; 3862 : 				if(pLoopUnit->IsCanDefend() && isEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	push	0
	mov	ecx, DWORD PTR _pLoopUnit$223663[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@isVisibleE
	movzx	edx, BYTE PTR _bAlwaysHostile$223659[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$223658[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$223663[ebp]
	push	ecx
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@isVisibleE

; 3863 : 				{
; 3864 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@isVisibleE
$LN4@isVisibleE:

; 3865 : 				}
; 3866 : 			}
; 3867 : 		}
; 3868 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@isVisibleE
$LN6@isVisibleE:

; 3869 : 	}
; 3870 : 
; 3871 : 	return false;

	xor	al, al
$LN7@isVisibleE:

; 3872 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ENDP	; CvPlot::isVisibleEnemyDefender
_TEXT	ENDS
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z:PROC ; CvUnit::canCoexistWithEnemyUnit
; Function compile flags: /Odtp
;	COMDAT ?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv91 = -16						; size = 4
$T243241 = -12						; size = 4
$T243240 = -8						; size = 4
_eOurTeam$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_eOtherTeam$ = 12					; size = 4
_bAlwaysHostile$ = 16					; size = 1
?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z PROC		; isEnemy, COMDAT

; 3808 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3809 : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isEnemy

; 3810 : 	{
; 3811 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@isEnemy
$LN1@isEnemy:

; 3812 : 	}
; 3813 : 
; 3814 : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	edx, DWORD PTR _eOtherTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	mov	DWORD PTR $T243240[ebp], eax
	mov	eax, DWORD PTR $T243240[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243241[ebp], eax
	mov	ecx, DWORD PTR $T243241[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOurTeam$[ebp], eax

; 3815 : 	return (bAlwaysHostile ? eOtherTeam != eOurTeam : atWar(eOtherTeam, eOurTeam));

	movzx	eax, BYTE PTR _bAlwaysHostile$[ebp]
	test	eax, eax
	je	SHORT $LN4@isEnemy
	mov	ecx, DWORD PTR _eOtherTeam$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR _eOurTeam$[ebp]
	setne	dl
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN5@isEnemy
$LN4@isEnemy:
	mov	eax, DWORD PTR _eOurTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherTeam$[ebp]
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	edx, al
	mov	DWORD PTR tv91[ebp], edx
$LN5@isEnemy:
	mov	al, BYTE PTR tv91[ebp]
$LN2@isEnemy:

; 3816 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ENDP		; isEnemy
_TEXT	ENDS
PUBLIC	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender
; Function compile flags: /Odtp
;	COMDAT ?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv164 = -60						; size = 4
_this$ = -56						; size = 4
$T243324 = -40						; size = 4
$T243310 = -36						; size = 4
$T243298 = -32						; size = 4
_iIndex$243323 = -28					; size = 4
$T243272 = -24						; size = 4
$T243268 = -20						; size = 4
_uSize$243265 = -16					; size = 4
_pLoopUnit$223676 = -12					; size = 4
_eTeam$223672 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z PROC ; CvPlot::getVisibleEnemyDefender, COMDAT
; _this$ = ecx

; 3910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 3911 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243268[ebp], eax
	mov	ecx, DWORD PTR $T243268[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243265[ebp], edx
	cmp	DWORD PTR _uSize$243265[ebp], 0
	jbe	SHORT $LN10@getVisible
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243268[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@getVisible
	jmp	SHORT $LN11@getVisible
$LN10@getVisible:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@getVisible:

; 3912 : 	if(pUnitNode)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@getVisible

; 3913 : 	{
; 3914 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243272[ebp], edx
	mov	eax, DWORD PTR $T243272[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223672[ebp], eax
$LN5@getVisible:

; 3915 : 		do
; 3916 : 		{
; 3917 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN23@getVisible
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN23@getVisible
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv164[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv164[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv164[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223676[ebp], eax
	jmp	SHORT $LN24@getVisible
$LN23@getVisible:
	mov	DWORD PTR _pLoopUnit$223676[ebp], 0
$LN24@getVisible:

; 3918 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243324[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243324[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243323[ebp], edx
	mov	edx, DWORD PTR $T243324[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243298[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243323[ebp]
	cmp	ecx, DWORD PTR $T243298[ebp]
	jae	SHORT $LN33@getVisible
	mov	edx, DWORD PTR $T243324[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243323[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243310[ebp], edx
	jmp	SHORT $LN28@getVisible
	jmp	SHORT $LN28@getVisible
$LN33@getVisible:
	mov	DWORD PTR $T243310[ebp], 0
$LN28@getVisible:
	mov	eax, DWORD PTR $T243310[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3919 : 
; 3920 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 3921 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 3922 : #else
; 3923 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	cmp	DWORD PTR _pLoopUnit$223676[ebp], 0
	je	SHORT $LN4@getVisible
	push	1
	push	0
	mov	ecx, DWORD PTR _eTeam$223672[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$223676[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@getVisible

; 3924 : #endif
; 3925 : 			{
; 3926 : 				if(pLoopUnit->IsCanDefend() && isEnemy(pLoopUnit, eTeam, false))

	push	0
	mov	ecx, DWORD PTR _pLoopUnit$223676[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@getVisible
	push	0
	mov	ecx, DWORD PTR _eTeam$223672[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopUnit$223676[ebp]
	push	edx
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@getVisible

; 3927 : 				{
; 3928 : 					return const_cast<CvUnit*>(pLoopUnit);

	mov	eax, DWORD PTR _pLoopUnit$223676[ebp]
	jmp	SHORT $LN7@getVisible
$LN4@getVisible:

; 3929 : 				}
; 3930 : 			}
; 3931 : 		}
; 3932 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@getVisible
$LN6@getVisible:

; 3933 : 	}
; 3934 : 
; 3935 : 	return NULL;

	xor	eax, eax
$LN7@getVisible:

; 3936 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ENDP ; CvPlot::getVisibleEnemyDefender
_TEXT	ENDS
PUBLIC	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z	; CvPlot::getNumDefenders
; Function compile flags: /Odtp
;	COMDAT ?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv142 = -48						; size = 4
_this$ = -44						; size = 4
$T243412 = -40						; size = 4
$T243403 = -36						; size = 4
$T243389 = -32						; size = 4
$T243377 = -28						; size = 4
_iIndex$243402 = -24					; size = 4
$T243359 = -20						; size = 4
_uSize$243356 = -16					; size = 4
_pLoopUnit$223690 = -12					; size = 4
_iCount$223686 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z PROC	; CvPlot::getNumDefenders, COMDAT
; _this$ = ecx

; 3940 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 3941 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243359[ebp], eax
	mov	ecx, DWORD PTR $T243359[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243356[ebp], edx
	cmp	DWORD PTR _uSize$243356[ebp], 0
	jbe	SHORT $LN10@getNumDefe
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243359[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@getNumDefe
	jmp	SHORT $LN11@getNumDefe
$LN10@getNumDefe:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@getNumDefe:

; 3942 : 	if(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@getNumDefe

; 3943 : 	{
; 3944 : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player must be valid");
; 3945 : 		int iCount = 0;

	mov	DWORD PTR _iCount$223686[ebp], 0
$LN5@getNumDefe:

; 3946 : 
; 3947 : 		do
; 3948 : 		{
; 3949 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN17@getNumDefe
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN17@getNumDefe
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv142[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223690[ebp], eax
	jmp	SHORT $LN18@getNumDefe
$LN17@getNumDefe:
	mov	DWORD PTR _pLoopUnit$223690[ebp], 0
$LN18@getNumDefe:

; 3950 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243403[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243403[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243402[ebp], edx
	mov	edx, DWORD PTR $T243403[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243377[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243402[ebp]
	cmp	ecx, DWORD PTR $T243377[ebp]
	jae	SHORT $LN27@getNumDefe
	mov	edx, DWORD PTR $T243403[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243402[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243389[ebp], edx
	jmp	SHORT $LN22@getNumDefe
	jmp	SHORT $LN22@getNumDefe
$LN27@getNumDefe:
	mov	DWORD PTR $T243389[ebp], 0
$LN22@getNumDefe:
	mov	eax, DWORD PTR $T243389[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3951 : 
; 3952 : 			if(pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$223690[ebp], 0
	je	SHORT $LN4@getNumDefe

; 3953 : 			{
; 3954 : 				if(pLoopUnit->getOwner() == ePlayer && pLoopUnit->IsCanDefend())

	mov	ecx, DWORD PTR _pLoopUnit$223690[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T243412[ebp], edx
	mov	eax, DWORD PTR $T243412[ebp]
	cmp	eax, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN4@getNumDefe
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$223690[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@getNumDefe

; 3955 : 				{
; 3956 : 					++iCount;

	mov	edx, DWORD PTR _iCount$223686[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$223686[ebp], edx
$LN4@getNumDefe:

; 3957 : 				}
; 3958 : 			}
; 3959 : 		}
; 3960 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@getNumDefe

; 3961 : 		return iCount;

	mov	eax, DWORD PTR _iCount$223686[ebp]
	jmp	SHORT $LN7@getNumDefe
$LN6@getNumDefe:

; 3962 : 	}
; 3963 : 
; 3964 : 	return 0;

	xor	eax, eax
$LN7@getNumDefe:

; 3965 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP	; CvPlot::getNumDefenders
_TEXT	ENDS
PUBLIC	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
; Function compile flags: /Odtp
;	COMDAT ?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z
_TEXT	SEGMENT
tv173 = -72						; size = 4
_this$ = -68						; size = 4
$T243496 = -52						; size = 4
$T243482 = -48						; size = 4
$T243470 = -44						; size = 4
_iIndex$243495 = -40					; size = 4
$T243444 = -36						; size = 4
$T243440 = -32						; size = 4
$T243431 = -28						; size = 4
_uSize$243428 = -24					; size = 4
_pLoopUnit$223705 = -20					; size = 4
_iCount$223701 = -16					; size = 4
_bAlwaysHostile$223700 = -9				; size = 1
_eTeam$223699 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_pUnit$ = 8						; size = 4
?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z PROC ; CvPlot::getNumVisibleEnemyDefenders, COMDAT
; _this$ = ecx

; 3969 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 3970 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 3971 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243431[ebp], eax
	mov	ecx, DWORD PTR $T243431[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243428[ebp], edx
	cmp	DWORD PTR _uSize$243428[ebp], 0
	jbe	SHORT $LN10@getNumVisi
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243431[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@getNumVisi
	jmp	SHORT $LN11@getNumVisi
$LN10@getNumVisi:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@getNumVisi:

; 3972 : 	if(pUnit && pUnitNode)

	cmp	DWORD PTR _pUnit$[ebp], 0
	je	$LN6@getNumVisi
	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@getNumVisi

; 3973 : 	{
; 3974 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T243440[ebp], eax
	mov	ecx, DWORD PTR $T243440[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243444[ebp], ecx
	mov	edx, DWORD PTR $T243444[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223699[ebp], eax

; 3975 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$223700[ebp], al

; 3976 : 		int iCount = 0;

	mov	DWORD PTR _iCount$223701[ebp], 0
$LN5@getNumVisi:

; 3977 : 
; 3978 : 		do
; 3979 : 		{
; 3980 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN27@getNumVisi
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN27@getNumVisi
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223705[ebp], eax
	jmp	SHORT $LN28@getNumVisi
$LN27@getNumVisi:
	mov	DWORD PTR _pLoopUnit$223705[ebp], 0
$LN28@getNumVisi:

; 3981 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243496[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243496[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243495[ebp], edx
	mov	edx, DWORD PTR $T243496[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243470[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243495[ebp]
	cmp	ecx, DWORD PTR $T243470[ebp]
	jae	SHORT $LN37@getNumVisi
	mov	edx, DWORD PTR $T243496[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243495[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243482[ebp], edx
	jmp	SHORT $LN32@getNumVisi
	jmp	SHORT $LN32@getNumVisi
$LN37@getNumVisi:
	mov	DWORD PTR $T243482[ebp], 0
$LN32@getNumVisi:
	mov	eax, DWORD PTR $T243482[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 3982 : 
; 3983 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 3984 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 3985 : #else
; 3986 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	cmp	DWORD PTR _pLoopUnit$223705[ebp], 0
	je	SHORT $LN4@getNumVisi
	push	1
	push	0
	mov	ecx, DWORD PTR _eTeam$223699[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$223705[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@getNumVisi

; 3987 : #endif
; 3988 : 			{
; 3989 : 				if(pLoopUnit->IsCanDefend() && isEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	push	0
	mov	ecx, DWORD PTR _pLoopUnit$223705[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@getNumVisi
	movzx	ecx, BYTE PTR _bAlwaysHostile$223700[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$223699[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$223705[ebp]
	push	eax
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@getNumVisi

; 3990 : 				{
; 3991 : 					++iCount;

	mov	edx, DWORD PTR _iCount$223701[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$223701[ebp], edx
$LN4@getNumVisi:

; 3992 : 				}
; 3993 : 			}
; 3994 : 		}
; 3995 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@getNumVisi

; 3996 : 		return iCount;

	mov	eax, DWORD PTR _iCount$223701[ebp]
	jmp	SHORT $LN7@getNumVisi
$LN6@getNumVisi:

; 3997 : 	}
; 3998 : 	return 0;

	xor	eax, eax
$LN7@getNumVisi:

; 3999 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ENDP ; CvPlot::getNumVisibleEnemyDefenders
_TEXT	ENDS
PUBLIC	?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisiblePotentialEnemyDefenders
; Function compile flags: /Odtp
;	COMDAT ?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z
_TEXT	SEGMENT
tv173 = -72						; size = 4
_this$ = -68						; size = 4
$T243596 = -52						; size = 4
$T243582 = -48						; size = 4
$T243570 = -44						; size = 4
_iIndex$243584 = -40					; size = 4
$T243544 = -36						; size = 4
$T243540 = -32						; size = 4
$T243531 = -28						; size = 4
_uSize$243523 = -24					; size = 4
_pLoopUnit$223720 = -20					; size = 4
_iCount$223714 = -16					; size = 4
_bAlwaysHostile$223716 = -9				; size = 1
_eTeam$223715 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_pUnit$ = 8						; size = 4
?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z PROC ; CvPlot::getNumVisiblePotentialEnemyDefenders, COMDAT
; _this$ = ecx

; 4003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 4004 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 4005 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243531[ebp], eax
	mov	ecx, DWORD PTR $T243531[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243523[ebp], edx
	cmp	DWORD PTR _uSize$243523[ebp], 0
	jbe	SHORT $LN10@getNumVisi@2
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243531[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@getNumVisi@2
	jmp	SHORT $LN11@getNumVisi@2
$LN10@getNumVisi@2:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@getNumVisi@2:

; 4006 : 	if(pUnit && pUnitNode)

	cmp	DWORD PTR _pUnit$[ebp], 0
	je	$LN6@getNumVisi@2
	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@getNumVisi@2

; 4007 : 	{
; 4008 : 		int iCount = 0;

	mov	DWORD PTR _iCount$223714[ebp], 0

; 4009 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T243540[ebp], eax
	mov	ecx, DWORD PTR $T243540[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243544[ebp], ecx
	mov	edx, DWORD PTR $T243544[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223715[ebp], eax

; 4010 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$223716[ebp], al
$LN5@getNumVisi@2:

; 4011 : 
; 4012 : 		do
; 4013 : 		{
; 4014 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN27@getNumVisi@2
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN27@getNumVisi@2
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv173[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv173[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223720[ebp], eax
	jmp	SHORT $LN28@getNumVisi@2
$LN27@getNumVisi@2:
	mov	DWORD PTR _pLoopUnit$223720[ebp], 0
$LN28@getNumVisi@2:

; 4015 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243596[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243596[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243584[ebp], edx
	mov	edx, DWORD PTR $T243596[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243570[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243584[ebp]
	cmp	ecx, DWORD PTR $T243570[ebp]
	jae	SHORT $LN37@getNumVisi@2
	mov	edx, DWORD PTR $T243596[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243584[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243582[ebp], edx
	jmp	SHORT $LN32@getNumVisi@2
	jmp	SHORT $LN32@getNumVisi@2
$LN37@getNumVisi@2:
	mov	DWORD PTR $T243582[ebp], 0
$LN32@getNumVisi@2:
	mov	eax, DWORD PTR $T243582[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 4016 : 
; 4017 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4018 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4019 : #else
; 4020 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	cmp	DWORD PTR _pLoopUnit$223720[ebp], 0
	je	SHORT $LN4@getNumVisi@2
	push	1
	push	0
	mov	ecx, DWORD PTR _eTeam$223715[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$223720[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@getNumVisi@2

; 4021 : #endif
; 4022 : 			{
; 4023 : 				if(pLoopUnit->IsCanDefend() && isPotentialEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	push	0
	mov	ecx, DWORD PTR _pLoopUnit$223720[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@getNumVisi@2
	movzx	ecx, BYTE PTR _bAlwaysHostile$223716[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$223715[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopUnit$223720[ebp]
	push	eax
	call	?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isPotentialEnemy
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@getNumVisi@2

; 4024 : 				{
; 4025 : 					++iCount;

	mov	edx, DWORD PTR _iCount$223714[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$223714[ebp], edx
$LN4@getNumVisi@2:

; 4026 : 				}
; 4027 : 			}
; 4028 : 		}
; 4029 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@getNumVisi@2

; 4030 : 		return iCount;

	mov	eax, DWORD PTR _iCount$223714[ebp]
	jmp	SHORT $LN7@getNumVisi@2
$LN6@getNumVisi@2:

; 4031 : 	}
; 4032 : 
; 4033 : 	return 0;

	xor	eax, eax
$LN7@getNumVisi@2:

; 4034 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ENDP ; CvPlot::getNumVisiblePotentialEnemyDefenders
_TEXT	ENDS
EXTRN	?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z:PROC	; isPotentialEnemy
; Function compile flags: /Odtp
;	COMDAT ?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv91 = -16						; size = 4
$T243621 = -12						; size = 4
$T243620 = -8						; size = 4
_eOurTeam$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_eOtherTeam$ = 12					; size = 4
_bAlwaysHostile$ = 16					; size = 1
?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z PROC ; isPotentialEnemy, COMDAT

; 3820 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3821 : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isPotentia

; 3822 : 	{
; 3823 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@isPotentia
$LN1@isPotentia:

; 3824 : 	}
; 3825 : 
; 3826 : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	edx, DWORD PTR _eOtherTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	mov	DWORD PTR $T243620[ebp], eax
	mov	eax, DWORD PTR $T243620[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243621[ebp], eax
	mov	ecx, DWORD PTR $T243621[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOurTeam$[ebp], eax

; 3827 : 	return (bAlwaysHostile ? eOtherTeam != eOurTeam : isPotentialEnemy(eOtherTeam, eOurTeam));

	movzx	eax, BYTE PTR _bAlwaysHostile$[ebp]
	test	eax, eax
	je	SHORT $LN4@isPotentia
	mov	ecx, DWORD PTR _eOtherTeam$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR _eOurTeam$[ebp]
	setne	dl
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN5@isPotentia
$LN4@isPotentia:
	mov	eax, DWORD PTR _eOurTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eOtherTeam$[ebp]
	push	ecx
	call	?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z	; isPotentialEnemy
	add	esp, 8
	movzx	edx, al
	mov	DWORD PTR tv91[ebp], edx
$LN5@isPotentia:
	mov	al, BYTE PTR tv91[ebp]
$LN2@isPotentia:

; 3828 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isPotentialEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ENDP ; isPotentialEnemy
_TEXT	ENDS
PUBLIC	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit
; Function compile flags: /Odtp
;	COMDAT ?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv159 = -60						; size = 4
_this$ = -56						; size = 4
$T243704 = -40						; size = 4
$T243690 = -36						; size = 4
$T243678 = -32						; size = 4
_iIndex$243692 = -28					; size = 4
$T243652 = -24						; size = 4
$T243648 = -20						; size = 4
_uSize$243640 = -16					; size = 4
_pLoopUnit$223733 = -12					; size = 4
_eTeam$223729 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::isVisibleEnemyUnit, COMDAT
; _this$ = ecx

; 4038 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 4039 : 	CvAssertMsg(ePlayer != NO_PLAYER, "Source player must be valid");
; 4040 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243648[ebp], eax
	mov	ecx, DWORD PTR $T243648[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243640[ebp], edx
	cmp	DWORD PTR _uSize$243640[ebp], 0
	jbe	SHORT $LN10@isVisibleE@2
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243648[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@isVisibleE@2
	jmp	SHORT $LN11@isVisibleE@2
$LN10@isVisibleE@2:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@isVisibleE@2:

; 4041 : 	if(pUnitNode)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@isVisibleE@2

; 4042 : 	{
; 4043 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243652[ebp], edx
	mov	eax, DWORD PTR $T243652[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223729[ebp], eax
$LN5@isVisibleE@2:

; 4044 : 
; 4045 : 		do
; 4046 : 		{
; 4047 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN23@isVisibleE@2
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN23@isVisibleE@2
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv159[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv159[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223733[ebp], eax
	jmp	SHORT $LN24@isVisibleE@2
$LN23@isVisibleE@2:
	mov	DWORD PTR _pLoopUnit$223733[ebp], 0
$LN24@isVisibleE@2:

; 4048 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243704[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243704[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243692[ebp], edx
	mov	edx, DWORD PTR $T243704[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243678[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243692[ebp]
	cmp	ecx, DWORD PTR $T243678[ebp]
	jae	SHORT $LN33@isVisibleE@2
	mov	edx, DWORD PTR $T243704[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243692[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243690[ebp], edx
	jmp	SHORT $LN28@isVisibleE@2
	jmp	SHORT $LN28@isVisibleE@2
$LN33@isVisibleE@2:
	mov	DWORD PTR $T243690[ebp], 0
$LN28@isVisibleE@2:
	mov	eax, DWORD PTR $T243690[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 4049 : 
; 4050 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4051 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4052 : #else
; 4053 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	cmp	DWORD PTR _pLoopUnit$223733[ebp], 0
	je	SHORT $LN4@isVisibleE@2
	push	1
	push	0
	mov	ecx, DWORD PTR _eTeam$223729[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$223733[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@isVisibleE@2

; 4054 : #endif
; 4055 : 			{
; 4056 : 				if(isEnemy(pLoopUnit, eTeam, false))

	push	0
	mov	eax, DWORD PTR _eTeam$223729[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$223733[ebp]
	push	ecx
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@isVisibleE@2

; 4057 : 				{
; 4058 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@isVisibleE@2
$LN4@isVisibleE@2:

; 4059 : 				}
; 4060 : 			}
; 4061 : 		}
; 4062 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@isVisibleE@2
$LN6@isVisibleE@2:

; 4063 : 	}
; 4064 : 
; 4065 : 	return false;

	xor	al, al
$LN7@isVisibleE@2:

; 4066 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::isVisibleEnemyUnit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
tv167 = -68						; size = 4
_this$ = -64						; size = 4
$T243804 = -48						; size = 4
$T243790 = -44						; size = 4
$T243778 = -40						; size = 4
_iIndex$243803 = -36					; size = 4
$T243752 = -32						; size = 4
$T243748 = -28						; size = 4
$T243739 = -24						; size = 4
_uSize$243736 = -20					; size = 4
_pLoopUnit$223747 = -16					; size = 4
_bAlwaysHostile$223743 = -9				; size = 1
_eTeam$223742 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_pUnit$ = 8						; size = 4
?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z PROC	; CvPlot::isVisibleEnemyUnit, COMDAT
; _this$ = ecx

; 4070 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 4071 : 	CvAssertMsg(pUnit, "Source unit must be valid");
; 4072 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243739[ebp], eax
	mov	ecx, DWORD PTR $T243739[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243736[ebp], edx
	cmp	DWORD PTR _uSize$243736[ebp], 0
	jbe	SHORT $LN10@isVisibleE@3
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243739[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@isVisibleE@3
	jmp	SHORT $LN11@isVisibleE@3
$LN10@isVisibleE@3:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@isVisibleE@3:

; 4073 : 	if(pUnit && pUnitNode)

	cmp	DWORD PTR _pUnit$[ebp], 0
	je	$LN6@isVisibleE@3
	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@isVisibleE@3

; 4074 : 	{
; 4075 : 		TeamTypes eTeam = GET_PLAYER(pUnit->getOwner()).getTeam();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T243748[ebp], eax
	mov	ecx, DWORD PTR $T243748[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243752[ebp], ecx
	mov	edx, DWORD PTR $T243752[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223742[ebp], eax

; 4076 : 		bool bAlwaysHostile = pUnit->isAlwaysHostile(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isAlwaysHostile@CvUnit@@QBE_NABVCvPlot@@@Z ; CvUnit::isAlwaysHostile
	mov	BYTE PTR _bAlwaysHostile$223743[ebp], al
$LN5@isVisibleE@3:

; 4077 : 
; 4078 : 		do
; 4079 : 		{
; 4080 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN27@isVisibleE@3
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN27@isVisibleE@3
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv167[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv167[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv167[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223747[ebp], eax
	jmp	SHORT $LN28@isVisibleE@3
$LN27@isVisibleE@3:
	mov	DWORD PTR _pLoopUnit$223747[ebp], 0
$LN28@isVisibleE@3:

; 4081 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243804[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243804[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243803[ebp], edx
	mov	edx, DWORD PTR $T243804[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243778[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243803[ebp]
	cmp	ecx, DWORD PTR $T243778[ebp]
	jae	SHORT $LN37@isVisibleE@3
	mov	edx, DWORD PTR $T243804[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243803[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243790[ebp], edx
	jmp	SHORT $LN32@isVisibleE@3
	jmp	SHORT $LN32@isVisibleE@3
$LN37@isVisibleE@3:
	mov	DWORD PTR $T243790[ebp], 0
$LN32@isVisibleE@3:
	mov	eax, DWORD PTR $T243790[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 4082 : 
; 4083 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4084 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4085 : #else
; 4086 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	cmp	DWORD PTR _pLoopUnit$223747[ebp], 0
	je	SHORT $LN4@isVisibleE@3
	push	1
	push	0
	mov	ecx, DWORD PTR _eTeam$223742[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$223747[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@isVisibleE@3

; 4087 : #endif
; 4088 : 			{
; 4089 : 				if(isEnemy(pLoopUnit, eTeam, bAlwaysHostile))

	movzx	eax, BYTE PTR _bAlwaysHostile$223743[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$223742[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopUnit$223747[ebp]
	push	edx
	call	?isEnemy@@YA_NPBVCvUnit@@W4TeamTypes@@_N@Z ; isEnemy
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@isVisibleE@3

; 4090 : 				{
; 4091 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@isVisibleE@3
$LN4@isVisibleE@3:

; 4092 : 				}
; 4093 : 			}
; 4094 : 		}
; 4095 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@isVisibleE@3
$LN6@isVisibleE@3:

; 4096 : 	}
; 4097 : 
; 4098 : 	return false;

	xor	al, al
$LN7@isVisibleE@3:

; 4099 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isVisibleEnemyUnit@CvPlot@@QBE_NPBVCvUnit@@@Z ENDP	; CvPlot::isVisibleEnemyUnit
_TEXT	ENDS
PUBLIC	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
; Function compile flags: /Odtp
;	COMDAT ?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv158 = -52						; size = 4
_this$ = -48						; size = 4
$T243900 = -41						; size = 1
$T243895 = -40						; size = 4
$T243881 = -36						; size = 4
$T243869 = -32						; size = 4
_iIndex$243894 = -28					; size = 4
$T243843 = -24						; size = 4
$T243839 = -20						; size = 4
_uSize$243836 = -16					; size = 4
_pLoopUnit$223760 = -12					; size = 4
_eTeam$223756 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::isVisibleOtherUnit, COMDAT
; _this$ = ecx

; 4103 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 4104 : 	CvAssertMsg(ePlayer != NO_PLAYER, "Source player must be valid");
; 4105 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T243839[ebp], eax
	mov	ecx, DWORD PTR $T243839[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$243836[ebp], edx
	cmp	DWORD PTR _uSize$243836[ebp], 0
	jbe	SHORT $LN10@isVisibleO
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243839[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN11@isVisibleO
	jmp	SHORT $LN11@isVisibleO
$LN10@isVisibleO:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN11@isVisibleO:

; 4106 : 	if(pUnitNode)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN6@isVisibleO

; 4107 : 	{
; 4108 : 		TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243843[ebp], edx
	mov	eax, DWORD PTR $T243843[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$223756[ebp], eax
$LN5@isVisibleO:

; 4109 : 
; 4110 : 		do
; 4111 : 		{
; 4112 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN23@isVisibleO
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN23@isVisibleO
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv158[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv158[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv158[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223760[ebp], eax
	jmp	SHORT $LN24@isVisibleO
$LN23@isVisibleO:
	mov	DWORD PTR _pLoopUnit$223760[ebp], 0
$LN24@isVisibleO:

; 4113 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T243895[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T243895[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$243894[ebp], edx
	mov	edx, DWORD PTR $T243895[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243869[ebp], eax
	mov	ecx, DWORD PTR _iIndex$243894[ebp]
	cmp	ecx, DWORD PTR $T243869[ebp]
	jae	SHORT $LN33@isVisibleO
	mov	edx, DWORD PTR $T243895[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$243894[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T243881[ebp], edx
	jmp	SHORT $LN28@isVisibleO
	jmp	SHORT $LN28@isVisibleO
$LN33@isVisibleO:
	mov	DWORD PTR $T243881[ebp], 0
$LN28@isVisibleO:
	mov	eax, DWORD PTR $T243881[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 4114 : 
; 4115 : #ifdef AUI_PLOT_FIX_ENEMY_DEFENDER_GETTER_DOES_NOT_GET_DELAYED_DEAD
; 4116 : 			if (pLoopUnit && !pLoopUnit->isDelayedDeath() && !pLoopUnit->isInvisible(eTeam, false))
; 4117 : #else
; 4118 : 			if(pLoopUnit && !pLoopUnit->isInvisible(eTeam, false))

	cmp	DWORD PTR _pLoopUnit$223760[ebp], 0
	je	SHORT $LN4@isVisibleO
	push	1
	push	0
	mov	ecx, DWORD PTR _eTeam$223756[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$223760[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@isVisibleO

; 4119 : #endif
; 4120 : 			{
; 4121 : 				if(isOtherTeam(pLoopUnit, eTeam))

	mov	eax, DWORD PTR _eTeam$223756[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$223760[ebp]
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN40@isVisibleO
	mov	BYTE PTR $T243900[ebp], 0
	jmp	SHORT $LN41@isVisibleO
$LN40@isVisibleO:
	mov	ecx, DWORD PTR _pLoopUnit$223760[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	xor	edx, edx
	cmp	eax, DWORD PTR _eTeam$223756[ebp]
	setne	dl
	mov	BYTE PTR $T243900[ebp], dl
$LN41@isVisibleO:
	movzx	eax, BYTE PTR $T243900[ebp]
	test	eax, eax
	je	SHORT $LN4@isVisibleO

; 4122 : 				{
; 4123 : 					return true;

	mov	al, 1
	jmp	SHORT $LN7@isVisibleO
$LN4@isVisibleO:

; 4124 : 				}
; 4125 : 			}
; 4126 : 		}
; 4127 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN5@isVisibleO
$LN6@isVisibleO:

; 4128 : 	}
; 4129 : 
; 4130 : 	return false;

	xor	al, al
$LN7@isVisibleO:

; 4131 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::isVisibleOtherUnit
_TEXT	ENDS
PUBLIC	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z	; CvPlot::getUnitByIndex
PUBLIC	?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::IsActualEnemyUnit
; Function compile flags: /Odtp
;	COMDAT ?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T243906 = -20						; size = 4
_pkUnit$223774 = -16					; size = 4
_iUnitLoop$223770 = -12					; size = 4
_kTeam$ = -8						; size = 4
_eTeam$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_bCombatUnitsOnly$ = 12					; size = 1
?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z PROC ; CvPlot::IsActualEnemyUnit, COMDAT
; _this$ = ecx

; 4136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4137 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243906[ebp], eax
	mov	ecx, DWORD PTR $T243906[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 4138 : 	CvTeam& kTeam = GET_TEAM(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$[ebp], eax

; 4139 : 
; 4140 : #ifdef AUI_WARNING_FIXES
; 4141 : 	for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 4142 : #else
; 4143 : 	for(int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$223770[ebp], 0
	jmp	SHORT $LN7@IsActualEn
$LN6@IsActualEn:
	mov	ecx, DWORD PTR _iUnitLoop$223770[ebp]
	add	ecx, 1
	mov	DWORD PTR _iUnitLoop$223770[ebp], ecx
$LN7@IsActualEn:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$223770[ebp], eax
	jge	SHORT $LN5@IsActualEn

; 4144 : #endif
; 4145 : 	{
; 4146 : 		CvUnit* pkUnit = getUnitByIndex(iUnitLoop);

	mov	edx, DWORD PTR _iUnitLoop$223770[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pkUnit$223774[ebp], eax

; 4147 : 		if(pkUnit)

	cmp	DWORD PTR _pkUnit$223774[ebp], 0
	je	SHORT $LN4@IsActualEn

; 4148 : 		{
; 4149 : 			if(kTeam.isAtWar(pkUnit->getTeam()))

	mov	ecx, DWORD PTR _pkUnit$223774[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _kTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsActualEn

; 4150 : 			{
; 4151 : 				if(!bCombatUnitsOnly || pkUnit->IsCombatUnit())

	movzx	ecx, BYTE PTR _bCombatUnitsOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@IsActualEn
	mov	edx, DWORD PTR _pkUnit$223774[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+1044], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsActualEn
$LN1@IsActualEn:

; 4152 : 				{
; 4153 : 					return true;

	mov	al, 1
	jmp	SHORT $LN8@IsActualEn
$LN4@IsActualEn:

; 4154 : 				}
; 4155 : 			}
; 4156 : 		}
; 4157 : 	}

	jmp	SHORT $LN6@IsActualEn
$LN5@IsActualEn:

; 4158 : 
; 4159 : 	return false;

	xor	al, al
$LN8@IsActualEn:

; 4160 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsActualEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ENDP ; CvPlot::IsActualEnemyUnit
_TEXT	ENDS
PUBLIC	?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z	; CvPlot::HasAlliedUnit
; Function compile flags: /Odtp
;	COMDAT ?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T243931 = -16						; size = 4
_pkUnit$223789 = -12					; size = 4
_iUnitLoop$223785 = -8					; size = 4
_eTeam$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
_bCombatUnitsOnly$ = 12					; size = 1
?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z PROC	; CvPlot::HasAlliedUnit, COMDAT
; _this$ = ecx

; 4164 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4165 : 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243931[ebp], eax
	mov	ecx, DWORD PTR $T243931[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 4166 : 
; 4167 : #ifdef AUI_WARNING_FIXES
; 4168 : 	for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 4169 : #else
; 4170 : 	for (int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$223785[ebp], 0
	jmp	SHORT $LN7@HasAlliedU
$LN6@HasAlliedU:
	mov	eax, DWORD PTR _iUnitLoop$223785[ebp]
	add	eax, 1
	mov	DWORD PTR _iUnitLoop$223785[ebp], eax
$LN7@HasAlliedU:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$223785[ebp], eax
	jge	SHORT $LN5@HasAlliedU

; 4171 : #endif
; 4172 : 	{
; 4173 : 		CvUnit* pkUnit = getUnitByIndex(iUnitLoop);

	mov	ecx, DWORD PTR _iUnitLoop$223785[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pkUnit$223789[ebp], eax

; 4174 : 		if (pkUnit)

	cmp	DWORD PTR _pkUnit$223789[ebp], 0
	je	SHORT $LN4@HasAlliedU

; 4175 : 		{
; 4176 : 			if (pkUnit->getTeam() == eTeam)

	mov	ecx, DWORD PTR _pkUnit$223789[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN4@HasAlliedU

; 4177 : 			{
; 4178 : 				if (!bCombatUnitsOnly || pkUnit->IsCombatUnit())

	movzx	edx, BYTE PTR _bCombatUnitsOnly$[ebp]
	test	edx, edx
	je	SHORT $LN1@HasAlliedU
	mov	eax, DWORD PTR _pkUnit$223789[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@HasAlliedU
$LN1@HasAlliedU:

; 4179 : 				{
; 4180 : 					return true;

	mov	al, 1
	jmp	SHORT $LN8@HasAlliedU
$LN4@HasAlliedU:

; 4181 : 				}
; 4182 : 			}
; 4183 : 		}
; 4184 : 	}

	jmp	SHORT $LN6@HasAlliedU
$LN5@HasAlliedU:

; 4185 : 
; 4186 : 	return false;

	xor	al, al
$LN8@HasAlliedU:

; 4187 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?HasAlliedUnit@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ENDP	; CvPlot::HasAlliedUnit
_TEXT	ENDS
EXTRN	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z:PROC	; CvUnit::AreUnitsOfSameType
EXTRN	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z:PROC ; CvUnit::canEmbarkOnto
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
; Function compile flags: /Odtp
;	COMDAT ?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z
_TEXT	SEGMENT
tv182 = -44						; size = 4
_this$ = -40						; size = 4
$T243994 = -36						; size = 4
$T243985 = -32						; size = 4
$T243964 = -28						; size = 4
_bCombat$ = -22						; size = 1
_bPretendEmbarked$ = -21				; size = 1
_iPlotUnitLimit$ = -20					; size = 4
_pUnitNode$ = -16					; size = 4
_pLoopUnit$ = -12					; size = 4
_kUnitTeam$ = -8					; size = 4
_iNumUnitsOfSameType$ = -4				; size = 4
_pUnit$ = 8						; size = 4
_bBreakOnUnitLimit$ = 12				; size = 1
?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z PROC ; CvPlot::getNumFriendlyUnitsOfType, COMDAT
; _this$ = ecx

; 4193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 4194 : 	int iNumUnitsOfSameType = 0;

	mov	DWORD PTR _iNumUnitsOfSameType$[ebp], 0

; 4195 : 
; 4196 : 	bool bCombat = false;

	mov	BYTE PTR _bCombat$[ebp], 0

; 4197 : 
; 4198 : 	// slewis - trying to break the 1upt for trade units
; 4199 : 	if (pUnit->isTrade())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@getNumFrie

; 4200 : 	{
; 4201 : 		return 0;

	xor	eax, eax
	jmp	$LN13@getNumFrie

; 4202 : 	}
; 4203 : 
; 4204 : 	if(pUnit->IsCombatUnit())

$LN15@getNumFrie:
	mov	ecx, DWORD PTR _pUnit$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN11@getNumFrie

; 4205 : 	{
; 4206 : 		bCombat = true;

	mov	BYTE PTR _bCombat$[ebp], 1
$LN11@getNumFrie:

; 4207 : 	}
; 4208 : 
; 4209 : 	bool bPretendEmbarked = false;

	mov	BYTE PTR _bPretendEmbarked$[ebp], 0

; 4210 : 	if(isWater() && pUnit->canEmbarkOnto(*pUnit->plot(), *this))

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@getNumFrie
	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canEmbarkOnto@CvUnit@@QBE_NABVCvPlot@@0_N1@Z ; CvUnit::canEmbarkOnto
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@getNumFrie

; 4211 : 	{
; 4212 : 		bPretendEmbarked = true;

	mov	BYTE PTR _bPretendEmbarked$[ebp], 1
$LN10@getNumFrie:

; 4213 : 	}
; 4214 : 
; 4215 : 	CvTeam& kUnitTeam = GET_TEAM(pUnit->getTeam());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	mov	DWORD PTR $T243964[ebp], eax
	mov	ecx, DWORD PTR $T243964[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kUnitTeam$[ebp], ecx

; 4216 : 
; 4217 : 	const IDInfo* pUnitNode;
; 4218 : 	const CvUnit* pLoopUnit;
; 4219 : 
; 4220 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 4221 : 
; 4222 : 	int iPlotUnitLimit = GC.getPLOT_UNIT_LIMIT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR _iPlotUnitLimit$[ebp], edx
$LN9@getNumFrie:

; 4223 : 
; 4224 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN8@getNumFrie

; 4225 : 	{
; 4226 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN25@getNumFrie
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN25@getNumFrie
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv182[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv182[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv182[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN26@getNumFrie
$LN25@getNumFrie:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN26@getNumFrie:

; 4227 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 4228 : 
; 4229 : 		if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN7@getNumFrie

; 4230 : 		{
; 4231 : 			// Don't include an enemy unit, or else it won't let us attack it :)
; 4232 : 			if(!kUnitTeam.isAtWar(pLoopUnit->getTeam()))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _kUnitTeam$[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@getNumFrie

; 4233 : 			{
; 4234 : 				// Units of the same type OR Units belonging to different civs
; 4235 : 				if(pUnit->getOwner() != pLoopUnit->getOwner() || pLoopUnit->AreUnitsOfSameType(*pUnit, bPretendEmbarked))

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T243985[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T243994[ebp], edx
	mov	eax, DWORD PTR $T243985[ebp]
	cmp	eax, DWORD PTR $T243994[ebp]
	jne	SHORT $LN4@getNumFrie
	movzx	ecx, BYTE PTR _bPretendEmbarked$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AreUnitsOfSameType@CvUnit@@QBE_NABV1@_N@Z ; CvUnit::AreUnitsOfSameType
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@getNumFrie
$LN4@getNumFrie:

; 4236 : 				{
; 4237 : 					// We should allow as many cargo units as we want
; 4238 : 					if(!pLoopUnit->isCargo())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@getNumFrie

; 4239 : 					{
; 4240 : 						// Unit is the same domain & combat type, not allowed more than the limit
; 4241 : 						iNumUnitsOfSameType++;

	mov	edx, DWORD PTR _iNumUnitsOfSameType$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumUnitsOfSameType$[ebp], edx
$LN5@getNumFrie:

; 4242 : 					}
; 4243 : 				}
; 4244 : 
; 4245 : 				// Does the calling function want us to break out? (saves processing time)
; 4246 : 				if(bBreakOnUnitLimit)

	movzx	eax, BYTE PTR _bBreakOnUnitLimit$[ebp]
	test	eax, eax
	je	SHORT $LN7@getNumFrie

; 4247 : 				{
; 4248 : 					if(iNumUnitsOfSameType > iPlotUnitLimit)

	mov	ecx, DWORD PTR _iNumUnitsOfSameType$[ebp]
	cmp	ecx, DWORD PTR _iPlotUnitLimit$[ebp]
	jle	SHORT $LN7@getNumFrie

; 4249 : 					{
; 4250 : 						return iNumUnitsOfSameType;

	mov	eax, DWORD PTR _iNumUnitsOfSameType$[ebp]
	jmp	SHORT $LN13@getNumFrie
$LN7@getNumFrie:

; 4251 : 					}
; 4252 : 				}
; 4253 : 			}
; 4254 : 		}
; 4255 : 	}

	jmp	$LN9@getNumFrie
$LN8@getNumFrie:

; 4256 : 	return iNumUnitsOfSameType;

	mov	eax, DWORD PTR _iNumUnitsOfSameType$[ebp]
$LN13@getNumFrie:

; 4257 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ENDP ; CvPlot::getNumFriendlyUnitsOfType
_TEXT	ENDS
PUBLIC	?isCityFighting@CvPlot@@QBE_NXZ			; CvPlot::isCityFighting
PUBLIC	?isUnitFighting@CvPlot@@QBE_NXZ			; CvPlot::isUnitFighting
PUBLIC	?isFighting@CvPlot@@QBE_NXZ			; CvPlot::isFighting
; Function compile flags: /Odtp
;	COMDAT ?isFighting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?isFighting@CvPlot@@QBE_NXZ PROC			; CvPlot::isFighting, COMDAT
; _this$ = ecx

; 4262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4263 : 	return (isUnitFighting() || isCityFighting());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isUnitFighting@CvPlot@@QBE_NXZ		; CvPlot::isUnitFighting
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@isFighting
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCityFighting@CvPlot@@QBE_NXZ		; CvPlot::isCityFighting
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isFighting
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isFighting
$LN3@isFighting:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isFighting:
	mov	al, BYTE PTR tv72[ebp]

; 4264 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isFighting@CvPlot@@QBE_NXZ ENDP			; CvPlot::isFighting
_TEXT	ENDS
EXTRN	?isFighting@CvUnit@@QBE_NXZ:PROC		; CvUnit::isFighting
; Function compile flags: /Odtp
;	COMDAT ?isUnitFighting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
tv137 = -40						; size = 4
_this$ = -36						; size = 4
$T244061 = -32						; size = 4
$T244047 = -28						; size = 4
$T244035 = -24						; size = 4
_iIndex$244060 = -20					; size = 4
$T244017 = -16						; size = 4
_uSize$244014 = -12					; size = 4
_pLoopUnit$223830 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
?isUnitFighting@CvPlot@@QBE_NXZ PROC			; CvPlot::isUnitFighting, COMDAT
; _this$ = ecx

; 4269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 4270 : 	const IDInfo* pUnitNode = m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T244017[ebp], eax
	mov	ecx, DWORD PTR $T244017[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$244014[ebp], edx
	cmp	DWORD PTR _uSize$244014[ebp], 0
	jbe	SHORT $LN9@isUnitFigh
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T244017[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pUnitNode$[ebp], eax
	jmp	SHORT $LN10@isUnitFigh
	jmp	SHORT $LN10@isUnitFigh
$LN9@isUnitFigh:
	mov	DWORD PTR _pUnitNode$[ebp], 0
$LN10@isUnitFigh:

; 4271 : 	if(pUnitNode)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN5@isUnitFigh
$LN4@isUnitFigh:

; 4272 : 	{
; 4273 : 		do
; 4274 : 		{
; 4275 : 			const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN16@isUnitFigh
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN16@isUnitFigh
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv137[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv137[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv137[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pLoopUnit$223830[ebp], eax
	jmp	SHORT $LN17@isUnitFigh
$LN16@isUnitFigh:
	mov	DWORD PTR _pLoopUnit$223830[ebp], 0
$LN17@isUnitFigh:

; 4276 : 			pUnitNode = m_units.next(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T244061[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	add	edx, 8
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T244061[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, eax
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$244060[ebp], edx
	mov	edx, DWORD PTR $T244061[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244035[ebp], eax
	mov	ecx, DWORD PTR _iIndex$244060[ebp]
	cmp	ecx, DWORD PTR $T244035[ebp]
	jae	SHORT $LN26@isUnitFigh
	mov	edx, DWORD PTR $T244061[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$244060[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T244047[ebp], edx
	jmp	SHORT $LN21@isUnitFigh
	jmp	SHORT $LN21@isUnitFigh
$LN26@isUnitFigh:
	mov	DWORD PTR $T244047[ebp], 0
$LN21@isUnitFigh:
	mov	eax, DWORD PTR $T244047[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 4277 : 
; 4278 : 			if(pLoopUnit && pLoopUnit->isFighting())

	cmp	DWORD PTR _pLoopUnit$223830[ebp], 0
	je	SHORT $LN3@isUnitFigh
	mov	ecx, DWORD PTR _pLoopUnit$223830[ebp]
	call	?isFighting@CvUnit@@QBE_NXZ		; CvUnit::isFighting
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@isUnitFigh

; 4279 : 			{
; 4280 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isUnitFigh
$LN3@isUnitFigh:

; 4281 : 			}
; 4282 : 		}
; 4283 : 		while(pUnitNode != NULL);

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	jne	$LN4@isUnitFigh
$LN5@isUnitFigh:

; 4284 : 	}
; 4285 : 
; 4286 : 	return false;

	xor	al, al
$LN6@isUnitFigh:

; 4287 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isUnitFighting@CvPlot@@QBE_NXZ ENDP			; CvPlot::isUnitFighting
_TEXT	ENDS
EXTRN	?isFighting@CvCity@@QBE_NXZ:PROC		; CvCity::isFighting
; Function compile flags: /Odtp
;	COMDAT ?isCityFighting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pkCity$ = -4						; size = 4
?isCityFighting@CvPlot@@QBE_NXZ PROC			; CvPlot::isCityFighting, COMDAT
; _this$ = ecx

; 4292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4293 : 	CvCity* pkCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pkCity$[ebp], eax

; 4294 : 	if(pkCity)

	cmp	DWORD PTR _pkCity$[ebp], 0
	je	SHORT $LN1@isCityFigh

; 4295 : 		return pkCity->isFighting();

	mov	ecx, DWORD PTR _pkCity$[ebp]
	call	?isFighting@CvCity@@QBE_NXZ		; CvCity::isFighting
	jmp	SHORT $LN2@isCityFigh
$LN1@isCityFigh:

; 4296 : 
; 4297 : 	return false;

	xor	al, al
$LN2@isCityFigh:

; 4298 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isCityFighting@CvPlot@@QBE_NXZ ENDP			; CvPlot::isCityFighting
_TEXT	ENDS
PUBLIC	?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z	; CvPlot::canHaveFeature
EXTRN	?isRequiresRiver@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isRequiresRiver
EXTRN	?isNoAdjacent@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isNoAdjacent
EXTRN	?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ:PROC ; CvFeatureInfo::isRequiresFlatlands
EXTRN	?isNoRiver@CvFeatureInfo@@QBE_NXZ:PROC		; CvFeatureInfo::isNoRiver
EXTRN	?isNoCoast@CvFeatureInfo@@QBE_NXZ:PROC		; CvFeatureInfo::isNoCoast
EXTRN	?isTerrain@CvFeatureInfo@@QBE_NH@Z:PROC		; CvFeatureInfo::isTerrain
; Function compile flags: /Odtp
;	COMDAT ?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
_f$244291 = -113					; size = 1
$T244105 = -32						; size = 4
$T244101 = -28						; size = 4
$T244091 = -24						; size = 4
_f$244079 = -13						; size = 1
_pAdjacentPlot$223856 = -12				; size = 4
_iI$223852 = -8						; size = 4
_pkFeature$ = -4					; size = 4
_eFeature$ = 8						; size = 4
?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z PROC	; CvPlot::canHaveFeature, COMDAT
; _this$ = ecx

; 4302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 4303 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 4304 : 
; 4305 : 	if(eFeature == NO_FEATURE)

	cmp	DWORD PTR _eFeature$[ebp], -1
	jne	SHORT $LN21@canHaveFea

; 4306 : 	{
; 4307 : 		return true;

	mov	al, 1
	jmp	$LN17@canHaveFea

; 4308 : 	}
; 4309 : 
; 4310 : 	if(getFeatureType() != NO_FEATURE)

$LN21@canHaveFea:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$244079[ebp], cl
	movsx	edx, BYTE PTR _f$244079[ebp]
	cmp	edx, -1
	je	SHORT $LN23@canHaveFea

; 4311 : 	{
; 4312 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea

; 4313 : 	}
; 4314 : 
; 4315 : 	if(isMountain())

$LN23@canHaveFea:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN14@canHaveFea

; 4316 : 	{
; 4317 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea
$LN14@canHaveFea:

; 4318 : 	}
; 4319 : 
; 4320 : 	if(isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@canHaveFea

; 4321 : 	{
; 4322 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea
$LN13@canHaveFea:

; 4323 : 	}
; 4324 : 
; 4325 : 	CvFeatureInfo* pkFeature = GC.getFeatureInfo(eFeature);

	mov	ecx, DWORD PTR _eFeature$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _pkFeature$[ebp], eax

; 4326 : 	if(pkFeature == NULL)

	cmp	DWORD PTR _pkFeature$[ebp], 0
	jne	SHORT $LN12@canHaveFea

; 4327 : 	{
; 4328 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea
$LN12@canHaveFea:

; 4329 : 	}
; 4330 : 
; 4331 : 	if(!pkFeature->isTerrain(getTerrainType()))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T244091[ebp], eax
	mov	ecx, DWORD PTR $T244091[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkFeature$[ebp]
	call	?isTerrain@CvFeatureInfo@@QBE_NH@Z	; CvFeatureInfo::isTerrain
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@canHaveFea

; 4332 : 	{
; 4333 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea
$LN11@canHaveFea:

; 4334 : 	}
; 4335 : 
; 4336 : 	if(pkFeature->isNoCoast() && isCoastalLand())

	mov	ecx, DWORD PTR _pkFeature$[ebp]
	call	?isNoCoast@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoCoast
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@canHaveFea
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@canHaveFea

; 4337 : 	{
; 4338 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea
$LN10@canHaveFea:

; 4339 : 	}
; 4340 : 
; 4341 : 	if(pkFeature->isNoRiver() && isRiver())

	mov	ecx, DWORD PTR _pkFeature$[ebp]
	call	?isNoRiver@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoRiver
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@canHaveFea
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN9@canHaveFea

; 4342 : 	{
; 4343 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea
$LN9@canHaveFea:

; 4344 : 	}
; 4345 : 
; 4346 : 	if(pkFeature->isRequiresFlatlands() && isHills())

	mov	ecx, DWORD PTR _pkFeature$[ebp]
	call	?isRequiresFlatlands@CvFeatureInfo@@QBE_NXZ ; CvFeatureInfo::isRequiresFlatlands
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@canHaveFea
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@canHaveFea

; 4347 : 	{
; 4348 : 		return false;

	xor	al, al
	jmp	$LN17@canHaveFea
$LN8@canHaveFea:

; 4349 : 	}
; 4350 : 
; 4351 : 	if(pkFeature->isNoAdjacent())

	mov	ecx, DWORD PTR _pkFeature$[ebp]
	call	?isNoAdjacent@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoAdjacent
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN120@canHaveFea

; 4352 : 	{
; 4353 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$223852[ebp], 0
	jmp	SHORT $LN6@canHaveFea
$LN5@canHaveFea:
	mov	eax, DWORD PTR _iI$223852[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$223852[ebp], eax
$LN6@canHaveFea:
	cmp	DWORD PTR _iI$223852[ebp], 6
	jge	SHORT $LN120@canHaveFea

; 4354 : 		{
; 4355 : 			CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T244101[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T244105[ebp], ecx
	mov	edx, DWORD PTR _iI$223852[ebp]
	push	edx
	mov	eax, DWORD PTR $T244101[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244105[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$223856[ebp], eax

; 4356 : 
; 4357 : 			if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$223856[ebp], 0
	je	SHORT $LN3@canHaveFea

; 4358 : 			{
; 4359 : 				if(pAdjacentPlot->getFeatureType() == eFeature)

	mov	edx, DWORD PTR _pAdjacentPlot$223856[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$244291[ebp], al
	movsx	ecx, BYTE PTR _f$244291[ebp]
	cmp	ecx, DWORD PTR _eFeature$[ebp]
	jne	SHORT $LN3@canHaveFea

; 4360 : 				{
; 4361 : 					return false;

	xor	al, al
	jmp	SHORT $LN17@canHaveFea
$LN3@canHaveFea:

; 4362 : 				}
; 4363 : 			}

	jmp	SHORT $LN5@canHaveFea

; 4364 : 		}
; 4365 : 	}
; 4366 : 
; 4367 : 	if(!isRiver() && pkFeature->isRequiresRiver())

$LN120@canHaveFea:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+457]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@canHaveFea
	mov	ecx, DWORD PTR _pkFeature$[ebp]
	call	?isRequiresRiver@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isRequiresRiver
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@canHaveFea

; 4368 : 	{
; 4369 : 		return false;

	xor	al, al
	jmp	SHORT $LN17@canHaveFea
$LN1@canHaveFea:

; 4370 : 	}
; 4371 : 
; 4372 : 	return true;

	mov	al, 1
$LN17@canHaveFea:

; 4373 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z ENDP	; CvPlot::canHaveFeature
_TEXT	ENDS
PUBLIC	?isRoute@CvPlot@@QBE_NXZ			; CvPlot::isRoute
; Function compile flags: /Odtp
;	COMDAT ?isRoute@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isRoute@CvPlot@@QBE_NXZ PROC				; CvPlot::isRoute, COMDAT
; _this$ = ecx

; 4378 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4379 : 	return ((RouteTypes)m_eRouteType != NO_ROUTE);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+447]
	xor	eax, eax
	cmp	ecx, -1
	setne	al

; 4380 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isRoute@CvPlot@@QBE_NXZ ENDP				; CvPlot::isRoute
_TEXT	ENDS
PUBLIC	?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z	; CvPlot::isValidRoute
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?isEnemyRoute@CvUnit@@QBE_NXZ:PROC		; CvUnit::isEnemyRoute
; Function compile flags: /Odtp
;	COMDAT ?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
_f$244373 = -38						; size = 1
_f$244364 = -37						; size = 1
$T244358 = -36						; size = 4
$T244349 = -32						; size = 4
$T244345 = -25						; size = 1
$T244344 = -24						; size = 4
$T244340 = -20						; size = 4
$T244336 = -16						; size = 4
$T244327 = -12						; size = 4
$T244318 = -8						; size = 4
_playerID$244310 = -4					; size = 4
_pUnit$ = 8						; size = 4
?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z PROC		; CvPlot::isValidRoute, COMDAT
; _this$ = ecx

; 4385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 4386 : 	if((RouteTypes)m_eRouteType != NO_ROUTE && !m_bRoutePillaged)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+447]
	cmp	ecx, -1
	je	SHORT $LN19@isValidRou
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+461]
	shr	al, 1
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@isValidRou

; 4387 : 	{
; 4388 : 		if(!pUnit->isEnemy(getTeam(), this) || pUnit->isEnemyRoute())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$244310[ebp], eax
	cmp	DWORD PTR _playerID$244310[ebp], -1
	je	SHORT $LN10@isValidRou
	mov	ecx, DWORD PTR _playerID$244310[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T244318[ebp], eax
	jmp	SHORT $LN11@isValidRou
	jmp	SHORT $LN11@isValidRou
$LN10@isValidRou:
	mov	DWORD PTR $T244318[ebp], -1
$LN11@isValidRou:
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T244318[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@isValidRou
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isEnemyRoute@CvUnit@@QBE_NXZ		; CvUnit::isEnemyRoute
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN19@isValidRou
$LN4@isValidRou:

; 4389 : 		{
; 4390 : 			return true;

	mov	al, 1
	jmp	$LN7@isValidRou

; 4391 : 		}
; 4392 : 	}
; 4393 : #ifdef AUI_UNIT_MOVEMENT_IROQUOIS_ROAD_TRANSITION_FIX
; 4394 : 	if (pUnit->getOwner() != NO_PLAYER && GET_PLAYER(pUnit->getOwner()).GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad())

$LN19@isValidRou:
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T244327[ebp], ecx
	cmp	DWORD PTR $T244327[ebp], -1
	je	$LN3@isValidRou
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T244336[ebp], eax
	mov	ecx, DWORD PTR $T244336[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T244340[ebp], ecx
	mov	ecx, DWORD PTR $T244340[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T244344[ebp], eax
	mov	edx, DWORD PTR $T244344[ebp]
	mov	al, BYTE PTR [edx+333]
	mov	BYTE PTR $T244345[ebp], al
	movzx	ecx, BYTE PTR $T244345[ebp]
	test	ecx, ecx
	je	SHORT $LN3@isValidRou

; 4395 : 	{
; 4396 : 		if (getOwner() == pUnit->getOwner() && (getFeatureType() == FEATURE_FOREST || getFeatureType() == FEATURE_JUNGLE))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T244349[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T244358[ebp], edx
	mov	eax, DWORD PTR $T244349[ebp]
	cmp	eax, DWORD PTR $T244358[ebp]
	jne	SHORT $LN3@isValidRou
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$244364[ebp], dl
	movsx	eax, BYTE PTR _f$244364[ebp]
	cmp	eax, 5
	je	SHORT $LN1@isValidRou
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$244373[ebp], dl
	movsx	eax, BYTE PTR _f$244373[ebp]
	cmp	eax, 1
	jne	SHORT $LN3@isValidRou
$LN1@isValidRou:

; 4397 : 		{
; 4398 : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@isValidRou
$LN3@isValidRou:

; 4399 : 		}
; 4400 : 	}
; 4401 : #endif
; 4402 : 
; 4403 : 	return false;

	xor	al, al
$LN7@isValidRou:

; 4404 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isValidRoute@CvPlot@@QBE_NPBVCvUnit@@@Z ENDP		; CvPlot::isValidRoute
_TEXT	ENDS
PUBLIC	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z	; CvPlot::IsTradeRoute
PUBLIC	?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z	; CvPlot::SetTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T244399 = -21						; size = 1
$T244389 = -20						; size = 4
$T244382 = -16						; size = 4
_iI$223886 = -12					; size = 4
_bWasTradeRoute$ = -5					; size = 1
_uiNewBitValue$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
_bActive$ = 12						; size = 1
?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z PROC	; CvPlot::SetTradeRoute, COMDAT
; _this$ = ecx

; 4408 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4409 : 	bool bWasTradeRoute = IsTradeRoute();

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	mov	BYTE PTR _bWasTradeRoute$[ebp], al

; 4410 : 
; 4411 : 	uint uiNewBitValue = (1 << ePlayer);

	mov	eax, 1
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	shl	eax, cl
	mov	DWORD PTR _uiNewBitValue$[ebp], eax

; 4412 : 	if(bActive)

	movzx	ecx, BYTE PTR _bActive$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@SetTradeRo

; 4413 : 	{
; 4414 : 		m_uiTradeRouteBitFlags |= uiNewBitValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	or	eax, DWORD PTR _uiNewBitValue$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+388], eax

; 4415 : 	}
; 4416 : 	else

	jmp	SHORT $LN7@SetTradeRo
$LN8@SetTradeRo:

; 4417 : 	{
; 4418 : 		m_uiTradeRouteBitFlags &= ~uiNewBitValue;

	mov	edx, DWORD PTR _uiNewBitValue$[ebp]
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+388]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+388], edx
$LN7@SetTradeRo:

; 4419 : 	}
; 4420 : 
; 4421 : 	if(IsTradeRoute() != bWasTradeRoute)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	movzx	edx, al
	movzx	eax, BYTE PTR _bWasTradeRoute$[ebp]
	cmp	edx, eax
	je	$LN9@SetTradeRo

; 4422 : 	{
; 4423 : 		for(int iI = 0; iI < MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$223886[ebp], 0
	jmp	SHORT $LN5@SetTradeRo
$LN4@SetTradeRo:
	mov	ecx, DWORD PTR _iI$223886[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$223886[ebp], ecx
$LN5@SetTradeRo:
	cmp	DWORD PTR _iI$223886[ebp], 64		; 00000040H
	jge	SHORT $LN9@SetTradeRo

; 4424 : 		{
; 4425 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 4426 : 			if (iI == OBSERVER_TEAM || ((GET_TEAM((TeamTypes)iI).isAlive()) && GC.getGame().getActiveTeam() == (TeamTypes)iI))
; 4427 : #else
; 4428 : 			if(GET_TEAM((TeamTypes)iI).isAlive() && GC.getGame().getActiveTeam() == (TeamTypes)iI)

	mov	edx, DWORD PTR _iI$223886[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T244382[ebp], edx
	mov	eax, DWORD PTR $T244382[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@SetTradeRo
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T244389[ebp], eax
	mov	ecx, DWORD PTR $T244389[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, DWORD PTR _iI$223886[ebp]
	jne	SHORT $LN2@SetTradeRo

; 4429 : #endif
; 4430 : 			{
; 4431 : 				if(isVisible((TeamTypes)iI))

	cmp	DWORD PTR _iI$223886[ebp], -1
	jne	SHORT $LN20@SetTradeRo
	mov	BYTE PTR $T244399[ebp], 0
	jmp	SHORT $LN18@SetTradeRo
$LN20@SetTradeRo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _iI$223886[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T244399[ebp], dl
$LN18@SetTradeRo:
	movzx	eax, BYTE PTR $T244399[ebp]
	test	eax, eax
	je	SHORT $LN2@SetTradeRo

; 4432 : 				{
; 4433 : 					setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN2@SetTradeRo:

; 4434 : 				}
; 4435 : 			}
; 4436 : 		}

	jmp	$LN4@SetTradeRo
$LN9@SetTradeRo:

; 4437 : 	}
; 4438 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTradeRoute@CvPlot@@QAEXW4PlayerTypes@@_N@Z ENDP	; CvPlot::SetTradeRoute
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiNewBitValue$223902 = -4				; size = 4
_ePlayer$ = 8						; size = 4
?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::IsTradeRoute, COMDAT
; _this$ = ecx

; 4443 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4444 : 	if(ePlayer == NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	jne	SHORT $LN5@IsTradeRou

; 4445 : 	{
; 4446 : 		if(m_uiTradeRouteBitFlags > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+388], 0
	jbe	SHORT $LN4@IsTradeRou

; 4447 : 		{
; 4448 : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@IsTradeRou
$LN4@IsTradeRou:

; 4449 : 		}
; 4450 : 	}
; 4451 : 	else

	jmp	SHORT $LN3@IsTradeRou
$LN5@IsTradeRou:

; 4452 : 	{
; 4453 : 		uint uiNewBitValue = (1 << ePlayer);

	mov	edx, 1
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	shl	edx, cl
	mov	DWORD PTR _uiNewBitValue$223902[ebp], edx

; 4454 : 		if(m_uiTradeRouteBitFlags & uiNewBitValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	and	ecx, DWORD PTR _uiNewBitValue$223902[ebp]
	je	SHORT $LN2@IsTradeRou

; 4455 : 		{
; 4456 : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@IsTradeRou

; 4457 : 		}
; 4458 : 		else

	jmp	SHORT $LN3@IsTradeRou
$LN2@IsTradeRou:

; 4459 : 		{
; 4460 : 			return false;

	xor	al, al
	jmp	SHORT $LN6@IsTradeRou
$LN3@IsTradeRou:

; 4461 : 		}
; 4462 : 	}
; 4463 : 
; 4464 : 	return false;

	xor	al, al
$LN6@IsTradeRou:

; 4465 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::IsTradeRoute
_TEXT	ENDS
PUBLIC	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction
EXTRN	?canLoad@CvUnit@@QBE_NABVCvPlot@@@Z:PROC	; CvUnit::canLoad
; Function compile flags: /Odtp
;	COMDAT ?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_unit$ = 8						; size = 4
?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z PROC ; CvPlot::isValidDomainForLocation, COMDAT
; _this$ = ecx

; 4470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4471 : 	if(isValidDomainForAction(unit))

	mov	eax, DWORD PTR _unit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@isValidDom

; 4472 : 	{
; 4473 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@isValidDom
$LN2@isValidDom:

; 4474 : 	}
; 4475 : 
; 4476 : 	if (unit.getDomainType() == DOMAIN_AIR && unit.canLoad(*this))

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN1@isValidDom
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?canLoad@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::canLoad
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@isValidDom

; 4477 : 	{
; 4478 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@isValidDom
$LN1@isValidDom:

; 4479 : 	}
; 4480 : 
; 4481 : 	return isCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
$LN3@isValidDom:

; 4482 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ENDP ; CvPlot::isValidDomainForLocation
_TEXT	ENDS
EXTRN	?IsHoveringUnit@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsHoveringUnit
EXTRN	?canMoveAllTerrain@CvUnit@@QBE_NXZ:PROC		; CvUnit::canMoveAllTerrain
; Function compile flags: /Odtp
;	COMDAT ?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z
_TEXT	SEGMENT
tv133 = -20						; size = 4
tv79 = -16						; size = 4
tv66 = -12						; size = 4
_this$ = -8						; size = 4
$T244429 = -1						; size = 1
_unit$ = 8						; size = 4
?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z PROC	; CvPlot::isValidDomainForAction, COMDAT
; _this$ = ecx

; 4487 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4488 : 	switch(unit.getDomainType())

	mov	ecx, DWORD PTR _unit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 3
	ja	$LN5@isValidDom@2
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN21@isValidDom@2[eax*4]

; 4489 : 	{
; 4490 : 	case DOMAIN_SEA:
; 4491 : 		  return (isWater() || unit.canMoveAllTerrain() || IsAllowsSailLand());

$LN13@isValidDom@2:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@isValidDom@2
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@isValidDom@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAllowsSailLand@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsSailLand
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@isValidDom@2
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN10@isValidDom@2
$LN9@isValidDom@2:
	mov	DWORD PTR tv79[ebp], 1
$LN10@isValidDom@2:
	mov	al, BYTE PTR tv79[ebp]
	jmp	SHORT $LN7@isValidDom@2

; 4492 : 		break;

	jmp	SHORT $LN5@isValidDom@2
$LN3@isValidDom@2:

; 4493 : 
; 4494 : 	case DOMAIN_AIR:
; 4495 : 		return false;

	xor	al, al
	jmp	SHORT $LN7@isValidDom@2

; 4496 : 		break;

	jmp	SHORT $LN5@isValidDom@2

; 4497 : 
; 4498 : 	case DOMAIN_LAND:
; 4499 : 	case DOMAIN_IMMOBILE:
; 4500 : 		return (!isWater() || unit.IsHoveringUnit() || unit.canMoveAllTerrain() || unit.isEmbarked() || IsAllowsWalkWater());

$LN15@isValidDom@2:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@isValidDom@2
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?IsHoveringUnit@CvUnit@@QBE_NXZ		; CvUnit::IsHoveringUnit
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@isValidDom@2
	mov	ecx, DWORD PTR _unit$[ebp]
	call	?canMoveAllTerrain@CvUnit@@QBE_NXZ	; CvUnit::canMoveAllTerrain
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@isValidDom@2
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	dl, BYTE PTR [ecx+1652]
	mov	BYTE PTR $T244429[ebp], dl
	movzx	eax, BYTE PTR $T244429[ebp]
	test	eax, eax
	jne	SHORT $LN11@isValidDom@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsAllowsWalkWater@CvPlot@@QBE_NXZ	; CvPlot::IsAllowsWalkWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN11@isValidDom@2
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $LN12@isValidDom@2
$LN11@isValidDom@2:
	mov	DWORD PTR tv133[ebp], 1
$LN12@isValidDom@2:
	mov	al, BYTE PTR tv133[ebp]
	jmp	SHORT $LN7@isValidDom@2
$LN5@isValidDom@2:

; 4501 : 		break;
; 4502 : 
; 4503 : 	default:
; 4504 : 		CvAssert(false);
; 4505 : 		break;
; 4506 : 	}
; 4507 : 
; 4508 : 	return false;

	xor	al, al
$LN7@isValidDom@2:

; 4509 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN21@isValidDom@2:
	DD	$LN13@isValidDom@2
	DD	$LN3@isValidDom@2
	DD	$LN15@isValidDom@2
	DD	$LN15@isValidDom@2
?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ENDP	; CvPlot::isValidDomainForAction
_TEXT	ENDS
PUBLIC	?at@CvPlot@@QBE_NHH@Z				; CvPlot::at
; Function compile flags: /Odtp
;	COMDAT ?at@CvPlot@@QBE_NHH@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?at@CvPlot@@QBE_NHH@Z PROC				; CvPlot::at, COMDAT
; _this$ = ecx

; 4513 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4514 : 	return ((getX() == iX) && (getY() == iY));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, DWORD PTR _iX$[ebp]
	jne	SHORT $LN3@at
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	cmp	eax, DWORD PTR _iY$[ebp]
	jne	SHORT $LN3@at
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@at
$LN3@at:
	mov	DWORD PTR tv70[ebp], 0
$LN4@at:
	mov	al, BYTE PTR tv70[ebp]

; 4515 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?at@CvPlot@@QBE_NHH@Z ENDP				; CvPlot::at
_TEXT	ENDS
EXTRN	?getBottomLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getBottomLatitude
EXTRN	?getTopLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getTopLatitude
; Function compile flags: /Odtp
;	COMDAT ?getLatitude@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T244494 = -56						; size = 4
$T244490 = -52						; size = 4
$T244486 = -48						; size = 4
$T244482 = -44						; size = 4
$T244478 = -40						; size = 4
$T244474 = -36						; size = 4
$T244470 = -32						; size = 4
$T244466 = -28						; size = 4
$T244462 = -24						; size = 4
$T244458 = -17						; size = 1
$T244454 = -16						; size = 4
$T244450 = -9						; size = 1
$T244446 = -8						; size = 4
_iLatitude$ = -4					; size = 4
?getLatitude@CvPlot@@QBEHXZ PROC			; CvPlot::getLatitude, COMDAT
; _this$ = ecx

; 4520 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4521 : 	int iLatitude;
; 4522 : 
; 4523 : 	if(GC.getMap().isWrapX() || !(GC.getMap().isWrapY()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244446[ebp], eax
	mov	ecx, DWORD PTR $T244446[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T244450[ebp], dl
	movzx	eax, BYTE PTR $T244450[ebp]
	test	eax, eax
	jne	SHORT $LN2@getLatitud
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244454[ebp], ecx
	mov	edx, DWORD PTR $T244454[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T244458[ebp], al
	movzx	ecx, BYTE PTR $T244458[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@getLatitud
$LN2@getLatitud:

; 4524 : 	{
; 4525 : 		iLatitude = ((getY() * 100) / GC.getMap().getGridHeight());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T244462[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244466[ebp], ecx
	mov	edx, DWORD PTR $T244466[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T244470[ebp], eax
	mov	eax, DWORD PTR $T244462[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR $T244470[ebp]
	mov	DWORD PTR _iLatitude$[ebp], eax

; 4526 : 	}
; 4527 : 	else

	jmp	SHORT $LN1@getLatitud
$LN3@getLatitud:

; 4528 : 	{
; 4529 : 		iLatitude = ((getX() * 100) / GC.getMap().getGridWidth());

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T244474[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244478[ebp], eax
	mov	ecx, DWORD PTR $T244478[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T244482[ebp], edx
	mov	eax, DWORD PTR $T244474[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR $T244482[ebp]
	mov	DWORD PTR _iLatitude$[ebp], eax
$LN1@getLatitud:

; 4530 : 	}
; 4531 : 
; 4532 : 	iLatitude = ((iLatitude * (GC.getMap().getTopLatitude() - GC.getMap().getBottomLatitude())) / 100);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244486[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244490[ebp], ecx
	mov	ecx, DWORD PTR $T244486[ebp]
	call	?getTopLatitude@CvMap@@QAEHXZ		; CvMap::getTopLatitude
	mov	esi, eax
	mov	ecx, DWORD PTR $T244490[ebp]
	call	?getBottomLatitude@CvMap@@QAEHXZ	; CvMap::getBottomLatitude
	sub	esi, eax
	mov	eax, esi
	imul	eax, DWORD PTR _iLatitude$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iLatitude$[ebp], eax

; 4533 : 
; 4534 : 	return abs(iLatitude + GC.getMap().getBottomLatitude());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244494[ebp], edx
	mov	ecx, DWORD PTR $T244494[ebp]
	call	?getBottomLatitude@CvMap@@QAEHXZ	; CvMap::getBottomLatitude
	add	eax, DWORD PTR _iLatitude$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx

; 4535 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getLatitude@CvPlot@@QBEHXZ ENDP			; CvPlot::getLatitude
_TEXT	ENDS
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
; Function compile flags: /Odtp
;	COMDAT ?area@CvPlot@@QBEPAVCvArea@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T244504 = -8						; size = 4
$T244500 = -4						; size = 4
?area@CvPlot@@QBEPAVCvArea@@XZ PROC			; CvPlot::area, COMDAT
; _this$ = ecx

; 4540 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4541 : 	return GC.getMap().getArea(getArea());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T244500[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244504[ebp], edx
	mov	eax, DWORD PTR $T244500[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244504[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea

; 4542 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?area@CvPlot@@QBEPAVCvArea@@XZ ENDP			; CvPlot::area
_TEXT	ENDS
PUBLIC	?waterArea@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::waterArea
; Function compile flags: /Odtp
;	COMDAT ?waterArea@CvPlot@@QBEPAVCvArea@@XZ
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T244517 = -28						; size = 4
$T244513 = -24						; size = 4
_pBestArea$ = -20					; size = 4
_iBestValue$ = -16					; size = 4
_iI$ = -12						; size = 4
_iValue$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?waterArea@CvPlot@@QBEPAVCvArea@@XZ PROC		; CvPlot::waterArea, COMDAT
; _this$ = ecx

; 4547 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 4548 : 	CvArea* pBestArea;
; 4549 : 	CvPlot* pAdjacentPlot;
; 4550 : 	int iValue;
; 4551 : 	int iBestValue;
; 4552 : 	int iI;
; 4553 : 
; 4554 : 	if(isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN7@waterArea

; 4555 : 	{
; 4556 : 		return area();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	jmp	$LN8@waterArea
$LN7@waterArea:

; 4557 : 	}
; 4558 : 
; 4559 : 	iBestValue = 0;

	mov	DWORD PTR _iBestValue$[ebp], 0

; 4560 : 	pBestArea = NULL;

	mov	DWORD PTR _pBestArea$[ebp], 0

; 4561 : 
; 4562 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@waterArea
$LN5@waterArea:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN6@waterArea:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN4@waterArea

; 4563 : 	{
; 4564 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T244513[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T244517[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244513[ebp]
	push	ecx
	mov	edx, DWORD PTR $T244517[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 4565 : 
; 4566 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN3@waterArea

; 4567 : 		{
; 4568 : 			if(pAdjacentPlot->isWater())

	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@waterArea

; 4569 : 			{
; 4570 : 				iValue = pAdjacentPlot->area()->getNumTiles();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	DWORD PTR _iValue$[ebp], eax

; 4571 : 
; 4572 : 				if(iValue > iBestValue)

	mov	ecx, DWORD PTR _iValue$[ebp]
	cmp	ecx, DWORD PTR _iBestValue$[ebp]
	jle	SHORT $LN3@waterArea

; 4573 : 				{
; 4574 : 					iBestValue = iValue;

	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], edx

; 4575 : 					pBestArea = pAdjacentPlot->area();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pBestArea$[ebp], eax
$LN3@waterArea:

; 4576 : 				}
; 4577 : 			}
; 4578 : 		}
; 4579 : 	}

	jmp	$LN5@waterArea
$LN4@waterArea:

; 4580 : 
; 4581 : 	return pBestArea;

	mov	eax, DWORD PTR _pBestArea$[ebp]
$LN8@waterArea:

; 4582 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?waterArea@CvPlot@@QBEPAVCvArea@@XZ ENDP		; CvPlot::waterArea
_TEXT	ENDS
PUBLIC	?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ	; CvPlot::secondWaterArea
; Function compile flags: /Odtp
;	COMDAT ?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T244928 = -120						; size = 4
$T244924 = -116						; size = 4
$T244737 = -32						; size = 4
$T244733 = -28						; size = 4
_pBestArea$ = -24					; size = 4
_iBestValue$ = -20					; size = 4
_pWaterArea$ = -16					; size = 4
_iI$ = -12						; size = 4
_iValue$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ PROC		; CvPlot::secondWaterArea, COMDAT
; _this$ = ecx

; 4586 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 4587 : 
; 4588 : 	CvArea* pWaterArea = waterArea();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?waterArea@CvPlot@@QBEPAVCvArea@@XZ	; CvPlot::waterArea
	mov	DWORD PTR _pWaterArea$[ebp], eax

; 4589 : 	CvArea* pBestArea;
; 4590 : 	CvPlot* pAdjacentPlot;
; 4591 : 	int iValue;
; 4592 : 	int iBestValue;
; 4593 : 	int iI;
; 4594 : 
; 4595 : 	CvAssert(!isWater());
; 4596 : 
; 4597 : 	iBestValue = 0;

	mov	DWORD PTR _iBestValue$[ebp], 0

; 4598 : 	pBestArea = NULL;

	mov	DWORD PTR _pBestArea$[ebp], 0

; 4599 : 
; 4600 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@secondWate
$LN5@secondWate:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@secondWate:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN4@secondWate

; 4601 : 	{
; 4602 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T244733[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T244737[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T244733[ebp]
	push	eax
	mov	ecx, DWORD PTR $T244737[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 4603 : 
; 4604 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN3@secondWate

; 4605 : 		{
; 4606 : 			if(pAdjacentPlot->isWater() && (pAdjacentPlot->getArea() != pWaterArea->GetID()))

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@secondWate
	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T244924[ebp], ecx
	mov	edx, DWORD PTR _pWaterArea$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244928[ebp], eax
	mov	ecx, DWORD PTR $T244924[ebp]
	cmp	ecx, DWORD PTR $T244928[ebp]
	je	SHORT $LN3@secondWate

; 4607 : 			{
; 4608 : 				iValue = pAdjacentPlot->area()->getNumTiles();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	DWORD PTR _iValue$[ebp], eax

; 4609 : 
; 4610 : 				if(iValue > iBestValue)

	mov	edx, DWORD PTR _iValue$[ebp]
	cmp	edx, DWORD PTR _iBestValue$[ebp]
	jle	SHORT $LN3@secondWate

; 4611 : 				{
; 4612 : 					iBestValue = iValue;

	mov	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], eax

; 4613 : 					pBestArea = pAdjacentPlot->area();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pBestArea$[ebp], eax
$LN3@secondWate:

; 4614 : 				}
; 4615 : 			}
; 4616 : 		}
; 4617 : 	}

	jmp	$LN5@secondWate
$LN4@secondWate:

; 4618 : 
; 4619 : 	return pBestArea;

	mov	eax, DWORD PTR _pBestArea$[ebp]

; 4620 : 
; 4621 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?secondWaterArea@CvPlot@@QBEPAVCvArea@@XZ ENDP		; CvPlot::secondWaterArea
_TEXT	ENDS
PUBLIC	?updateYield@CvPlot@@QAEXXZ			; CvPlot::updateYield
PUBLIC	?processArea@CvPlot@@IAEXPAVCvArea@@H@Z		; CvPlot::processArea
PUBLIC	?setArea@CvPlot@@QAEXH@Z			; CvPlot::setArea
; Function compile flags: /Odtp
;	COMDAT ?setArea@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T244934 = -8						; size = 4
_bOldLake$ = -1						; size = 1
_iNewValue$ = 8						; size = 4
?setArea@CvPlot@@QAEXH@Z PROC				; CvPlot::setArea, COMDAT
; _this$ = ecx

; 4625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 4626 : 	bool bOldLake;
; 4627 : 
; 4628 : 	if(getArea() != iNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T244934[ebp], ecx
	mov	edx, DWORD PTR $T244934[ebp]
	cmp	edx, DWORD PTR _iNewValue$[ebp]
	je	SHORT $LN4@setArea

; 4629 : 	{
; 4630 : 		bOldLake = isLake();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	mov	BYTE PTR _bOldLake$[ebp], al

; 4631 : 
; 4632 : 		if(area() != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN2@setArea

; 4633 : 		{
; 4634 : 			processArea(area(), -1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?processArea@CvPlot@@IAEXPAVCvArea@@H@Z	; CvPlot::processArea
$LN2@setArea:

; 4635 : 		}
; 4636 : 
; 4637 : 		m_iArea = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [eax+356], ecx

; 4638 : 
; 4639 : 		if(area() != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN4@setArea

; 4640 : 		{
; 4641 : 			processArea(area(), 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?processArea@CvPlot@@IAEXPAVCvArea@@H@Z	; CvPlot::processArea

; 4642 : 
; 4643 : 			updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN4@setArea:

; 4644 : 		}
; 4645 : 	}
; 4646 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setArea@CvPlot@@QAEXH@Z ENDP				; CvPlot::setArea
_TEXT	ENDS
PUBLIC	?setLandmass@CvPlot@@QAEXH@Z			; CvPlot::setLandmass
EXTRN	?ChangeCentroidY@CvLandmass@@QAEXH@Z:PROC	; CvLandmass::ChangeCentroidY
EXTRN	?ChangeCentroidX@CvLandmass@@QAEXH@Z:PROC	; CvLandmass::ChangeCentroidX
EXTRN	?changeNumTiles@CvLandmass@@QAEXH@Z:PROC	; CvLandmass::changeNumTiles
; Function compile flags: /Odtp
;	COMDAT ?setLandmass@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T244944 = -12						; size = 4
$T244940 = -8						; size = 4
_pLandmass$223983 = -4					; size = 4
_iNewValue$ = 8						; size = 4
?setLandmass@CvPlot@@QAEXH@Z PROC			; CvPlot::setLandmass, COMDAT
; _this$ = ecx

; 4650 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 4651 : 	if(m_iLandmass != iNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	cmp	ecx, DWORD PTR _iNewValue$[ebp]
	je	$LN4@setLandmas

; 4652 : 	{
; 4653 : 		// cleanup old one
; 4654 : 		CvLandmass* pLandmass = GC.getMap().getLandmass(m_iLandmass);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244940[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	push	ecx
	mov	ecx, DWORD PTR $T244940[ebp]
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	DWORD PTR _pLandmass$223983[ebp], eax

; 4655 : 		if(pLandmass != NULL)

	cmp	DWORD PTR _pLandmass$223983[ebp], 0
	je	SHORT $LN2@setLandmas

; 4656 : 		{
; 4657 : 			pLandmass->changeNumTiles(-1);

	push	-1
	mov	ecx, DWORD PTR _pLandmass$223983[ebp]
	call	?changeNumTiles@CvLandmass@@QAEXH@Z	; CvLandmass::changeNumTiles

; 4658 : 			pLandmass->ChangeCentroidX(-m_iX);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _pLandmass$223983[ebp]
	call	?ChangeCentroidX@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidX

; 4659 : 			pLandmass->ChangeCentroidY(-m_iY);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	neg	edx
	push	edx
	mov	ecx, DWORD PTR _pLandmass$223983[ebp]
	call	?ChangeCentroidY@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidY
$LN2@setLandmas:

; 4660 : 		}
; 4661 : 
; 4662 : 		m_iLandmass = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [eax+360], ecx

; 4663 : 
; 4664 : 		pLandmass = GC.getMap().getLandmass(m_iLandmass);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T244944[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	push	ecx
	mov	ecx, DWORD PTR $T244944[ebp]
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	DWORD PTR _pLandmass$223983[ebp], eax

; 4665 : 		if(pLandmass != NULL)

	cmp	DWORD PTR _pLandmass$223983[ebp], 0
	je	SHORT $LN4@setLandmas

; 4666 : 		{
; 4667 : 			pLandmass->changeNumTiles(1);

	push	1
	mov	ecx, DWORD PTR _pLandmass$223983[ebp]
	call	?changeNumTiles@CvLandmass@@QAEXH@Z	; CvLandmass::changeNumTiles

; 4668 : 			pLandmass->ChangeCentroidX(m_iX);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pLandmass$223983[ebp]
	call	?ChangeCentroidX@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidX

; 4669 : 			pLandmass->ChangeCentroidY(m_iY);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	push	edx
	mov	ecx, DWORD PTR _pLandmass$223983[ebp]
	call	?ChangeCentroidY@CvLandmass@@QAEXH@Z	; CvLandmass::ChangeCentroidY
$LN4@setLandmas:

; 4670 : 		}
; 4671 : 	}
; 4672 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setLandmass@CvPlot@@QAEXH@Z ENDP			; CvPlot::setLandmass
_TEXT	ENDS
PUBLIC	?getFeatureVariety@CvPlot@@QBEHXZ		; CvPlot::getFeatureVariety
; Function compile flags: /Odtp
;	COMDAT ?getFeatureVariety@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFeatureVariety@CvPlot@@QBEHXZ PROC			; CvPlot::getFeatureVariety, COMDAT
; _this$ = ecx

; 4677 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4678 : 	return m_iFeatureVariety;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+453]

; 4679 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getFeatureVariety@CvPlot@@QBEHXZ ENDP			; CvPlot::getFeatureVariety
_TEXT	ENDS
PUBLIC	?getOwnershipDuration@CvPlot@@QBEHXZ		; CvPlot::getOwnershipDuration
; Function compile flags: /Odtp
;	COMDAT ?getOwnershipDuration@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getOwnershipDuration@CvPlot@@QBEHXZ PROC		; CvPlot::getOwnershipDuration, COMDAT
; _this$ = ecx

; 4684 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4685 : 	return m_iOwnershipDuration;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+380]

; 4686 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getOwnershipDuration@CvPlot@@QBEHXZ ENDP		; CvPlot::getOwnershipDuration
_TEXT	ENDS
PUBLIC	?isOwnershipScore@CvPlot@@QBE_NXZ		; CvPlot::isOwnershipScore
; Function compile flags: /Odtp
;	COMDAT ?isOwnershipScore@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T244954 = -4						; size = 4
?isOwnershipScore@CvPlot@@QBE_NXZ PROC			; CvPlot::isOwnershipScore, COMDAT
; _this$ = ecx

; 4691 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4692 : 	return (getOwnershipDuration() >= GC.getOWNERSHIP_SCORE_DURATION_THRESHOLD());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6252
	mov	DWORD PTR $T244954[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getOwnershipDuration@CvPlot@@QBEHXZ	; CvPlot::getOwnershipDuration
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T244954[ebp]
	setge	cl
	mov	al, cl

; 4693 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isOwnershipScore@CvPlot@@QBE_NXZ ENDP			; CvPlot::isOwnershipScore
_TEXT	ENDS
PUBLIC	?setOwnershipDuration@CvPlot@@QAEXH@Z		; CvPlot::setOwnershipDuration
EXTRN	?changeTotalLandScored@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeTotalLandScored
; Function compile flags: /Odtp
;	COMDAT ?setOwnershipDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T244967 = -12						; size = 4
$T244963 = -8						; size = 4
_bOldOwnershipScore$ = -1				; size = 1
_iNewValue$ = 8						; size = 4
?setOwnershipDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::setOwnershipDuration, COMDAT
; _this$ = ecx

; 4698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4699 : 	bool bOldOwnershipScore;
; 4700 : 
; 4701 : 	if(getOwnershipDuration() != iNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getOwnershipDuration@CvPlot@@QBEHXZ	; CvPlot::getOwnershipDuration
	cmp	eax, DWORD PTR _iNewValue$[ebp]
	je	$LN5@setOwnersh

; 4702 : 	{
; 4703 : 		bOldOwnershipScore = isOwnershipScore();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwnershipScore@CvPlot@@QBE_NXZ	; CvPlot::isOwnershipScore
	mov	BYTE PTR _bOldOwnershipScore$[ebp], al

; 4704 : 
; 4705 : 		m_iOwnershipDuration = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _iNewValue$[ebp]
	mov	WORD PTR [eax+380], cx

; 4706 : 		CvAssert(getOwnershipDuration() >= 0);
; 4707 : 
; 4708 : 		if(bOldOwnershipScore != isOwnershipScore())

	movzx	esi, BYTE PTR _bOldOwnershipScore$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwnershipScore@CvPlot@@QBE_NXZ	; CvPlot::isOwnershipScore
	movzx	edx, al
	cmp	esi, edx
	je	SHORT $LN5@setOwnersh

; 4709 : 		{
; 4710 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@setOwnersh

; 4711 : 			{
; 4712 : 				if(!isWater())

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@setOwnersh

; 4713 : 				{
; 4714 : 					GET_PLAYER(getOwner()).changeTotalLandScored((isOwnershipScore()) ? 1 : -1);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T244963[ebp], eax
	mov	ecx, DWORD PTR $T244963[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T244967[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwnershipScore@CvPlot@@QBE_NXZ	; CvPlot::isOwnershipScore
	movzx	edx, al
	neg	edx
	sbb	edx, edx
	and	edx, 2
	add	edx, -1
	push	edx
	mov	ecx, DWORD PTR $T244967[ebp]
	call	?changeTotalLandScored@CvPlayer@@QAEXH@Z ; CvPlayer::changeTotalLandScored
$LN5@setOwnersh:

; 4715 : 				}
; 4716 : 			}
; 4717 : 		}
; 4718 : 	}
; 4719 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?setOwnershipDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::setOwnershipDuration
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeOwnershipDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeOwnershipDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::changeOwnershipDuration, COMDAT
; _this$ = ecx

; 4724 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4725 : 	setOwnershipDuration(getOwnershipDuration() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getOwnershipDuration@CvPlot@@QBEHXZ	; CvPlot::getOwnershipDuration
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setOwnershipDuration@CvPlot@@QAEXH@Z	; CvPlot::setOwnershipDuration

; 4726 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeOwnershipDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeOwnershipDuration
_TEXT	ENDS
PUBLIC	?getImprovementDuration@CvPlot@@QBEHXZ		; CvPlot::getImprovementDuration
; Function compile flags: /Odtp
;	COMDAT ?getImprovementDuration@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getImprovementDuration@CvPlot@@QBEHXZ PROC		; CvPlot::getImprovementDuration, COMDAT
; _this$ = ecx

; 4731 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4732 : 	return m_iImprovementDuration;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+382]

; 4733 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getImprovementDuration@CvPlot@@QBEHXZ ENDP		; CvPlot::getImprovementDuration
_TEXT	ENDS
PUBLIC	?setImprovementDuration@CvPlot@@QAEXH@Z		; CvPlot::setImprovementDuration
; Function compile flags: /Odtp
;	COMDAT ?setImprovementDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNewValue$ = 8						; size = 4
?setImprovementDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::setImprovementDuration, COMDAT
; _this$ = ecx

; 4738 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4739 : 	m_iImprovementDuration = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _iNewValue$[ebp]
	mov	WORD PTR [eax+382], cx

; 4740 : 	CvAssert(getImprovementDuration() >= 0);
; 4741 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setImprovementDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::setImprovementDuration
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeImprovementDuration@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeImprovementDuration@CvPlot@@QAEXH@Z PROC		; CvPlot::changeImprovementDuration, COMDAT
; _this$ = ecx

; 4746 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4747 : 	setImprovementDuration(getImprovementDuration() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementDuration@CvPlot@@QBEHXZ	; CvPlot::getImprovementDuration
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementDuration@CvPlot@@QAEXH@Z	; CvPlot::setImprovementDuration

; 4748 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeImprovementDuration@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeImprovementDuration
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getUpgradeProgress@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getUpgradeProgress@CvPlot@@QBEHXZ PROC			; CvPlot::getUpgradeProgress, COMDAT
; _this$ = ecx

; 4753 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4754 : 	return m_iUpgradeProgress;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+384]

; 4755 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getUpgradeProgress@CvPlot@@QBEHXZ ENDP			; CvPlot::getUpgradeProgress
_TEXT	ENDS
PUBLIC	?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::getUpgradeTimeLeft
; Function compile flags: /Odtp
;	COMDAT ?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv131 = -40						; size = 4
tv76 = -36						; size = 4
_this$ = -32						; size = 4
$T244996 = -28						; size = 4
$T244990 = -24						; size = 4
$T244986 = -20						; size = 4
$T244982 = -16						; size = 4
_iUpgradeRate$ = -12					; size = 4
_iTurnsLeft$ = -8					; size = 4
_iUpgradeLeft$ = -4					; size = 4
_eImprovement$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::getUpgradeTimeLeft, COMDAT
; _this$ = ecx

; 4760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 4761 : 	int iUpgradeLeft;
; 4762 : 	int iUpgradeRate;
; 4763 : 	int iTurnsLeft;
; 4764 : 
; 4765 : 	iUpgradeLeft = ((100 * GC.getGame().getImprovementUpgradeTime(eImprovement, const_cast<CvPlot*>(this))) - ((getImprovementType() == eImprovement) ? getUpgradeProgress() : 0));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eImprovement$[ebp]
	jne	SHORT $LN6@getUpgrade
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUpgradeProgress@CvPlot@@QBEHXZ	; CvPlot::getUpgradeProgress
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN7@getUpgrade
$LN6@getUpgrade:
	mov	DWORD PTR tv76[ebp], 0
$LN7@getUpgrade:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T244986[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T244986[ebp]
	call	?getImprovementUpgradeTime@CvGame@@QBEHW4ImprovementTypes@@PBVCvPlot@@@Z ; CvGame::getImprovementUpgradeTime
	imul	eax, 100				; 00000064H
	sub	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR _iUpgradeLeft$[ebp], eax

; 4766 : 	iUpgradeLeft /= 100;

	mov	eax, DWORD PTR _iUpgradeLeft$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iUpgradeLeft$[ebp], eax

; 4767 : 
; 4768 : 	if(ePlayer == NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	jne	SHORT $LN3@getUpgrade

; 4769 : 	{
; 4770 : 		return iUpgradeLeft;

	mov	eax, DWORD PTR _iUpgradeLeft$[ebp]
	jmp	SHORT $LN4@getUpgrade
$LN3@getUpgrade:

; 4771 : 	}
; 4772 : 
; 4773 : 	iUpgradeRate = GET_PLAYER(ePlayer).getImprovementUpgradeRate();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T244990[ebp], edx
	mov	ecx, DWORD PTR $T244990[ebp]
	call	?getImprovementUpgradeRate@CvPlayer@@QBEHXZ ; CvPlayer::getImprovementUpgradeRate
	mov	DWORD PTR _iUpgradeRate$[ebp], eax

; 4774 : 
; 4775 : 	if(iUpgradeRate == 0)

	cmp	DWORD PTR _iUpgradeRate$[ebp], 0
	jne	SHORT $LN2@getUpgrade

; 4776 : 	{
; 4777 : 		return iUpgradeLeft;

	mov	eax, DWORD PTR _iUpgradeLeft$[ebp]
	jmp	SHORT $LN4@getUpgrade
$LN2@getUpgrade:

; 4778 : 	}
; 4779 : 
; 4780 : 	// Upgrade rate is stored at 100x
; 4781 : 	iTurnsLeft = (100 * iUpgradeLeft / iUpgradeRate);

	mov	eax, DWORD PTR _iUpgradeLeft$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iUpgradeRate$[ebp]
	mov	DWORD PTR _iTurnsLeft$[ebp], eax

; 4782 : 
; 4783 : 	if((iTurnsLeft * iUpgradeRate) < iUpgradeLeft)

	mov	eax, DWORD PTR _iTurnsLeft$[ebp]
	imul	eax, DWORD PTR _iUpgradeRate$[ebp]
	cmp	eax, DWORD PTR _iUpgradeLeft$[ebp]
	jge	SHORT $LN1@getUpgrade

; 4784 : 	{
; 4785 : 		iTurnsLeft++;

	mov	ecx, DWORD PTR _iTurnsLeft$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTurnsLeft$[ebp], ecx
$LN1@getUpgrade:

; 4786 : 	}
; 4787 : 
; 4788 : 	return std::max(1, iTurnsLeft);

	mov	DWORD PTR $T244982[ebp], 1
	mov	edx, DWORD PTR $T244982[ebp]
	cmp	edx, DWORD PTR _iTurnsLeft$[ebp]
	jge	SHORT $LN14@getUpgrade
	lea	eax, DWORD PTR _iTurnsLeft$[ebp]
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN15@getUpgrade
$LN14@getUpgrade:
	lea	ecx, DWORD PTR $T244982[ebp]
	mov	DWORD PTR tv131[ebp], ecx
$LN15@getUpgrade:
	mov	edx, DWORD PTR tv131[ebp]
	mov	DWORD PTR $T244996[ebp], edx
	mov	eax, DWORD PTR $T244996[ebp]
	mov	eax, DWORD PTR [eax]
$LN4@getUpgrade:

; 4789 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::getUpgradeTimeLeft
_TEXT	ENDS
PUBLIC	?setUpgradeProgress@CvPlot@@QAEXH@Z		; CvPlot::setUpgradeProgress
; Function compile flags: /Odtp
;	COMDAT ?setUpgradeProgress@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNewValue$ = 8						; size = 4
?setUpgradeProgress@CvPlot@@QAEXH@Z PROC		; CvPlot::setUpgradeProgress, COMDAT
; _this$ = ecx

; 4794 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4795 : 	m_iUpgradeProgress = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _iNewValue$[ebp]
	mov	WORD PTR [eax+384], cx

; 4796 : 	CvAssert(getUpgradeProgress() >= 0);
; 4797 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setUpgradeProgress@CvPlot@@QAEXH@Z ENDP		; CvPlot::setUpgradeProgress
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changeUpgradeProgress@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeUpgradeProgress@CvPlot@@QAEXH@Z PROC		; CvPlot::changeUpgradeProgress, COMDAT
; _this$ = ecx

; 4802 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4803 : 	setUpgradeProgress(getUpgradeProgress() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUpgradeProgress@CvPlot@@QBEHXZ	; CvPlot::getUpgradeProgress
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setUpgradeProgress@CvPlot@@QAEXH@Z	; CvPlot::setUpgradeProgress

; 4804 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeUpgradeProgress@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeUpgradeProgress
_TEXT	ENDS
PUBLIC	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
EXTRN	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetCultureAdjacentSameType
; Function compile flags: /Odtp
;	COMDAT ?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T245013 = -20						; size = 4
$T245009 = -16						; size = 4
_iI$224051 = -12					; size = 4
_iRtnValue$ = -8					; size = 4
_pAdjacentPlot$ = -4					; size = 4
_kImprovement$ = 8					; size = 4
_eValue$ = 12						; size = 4
?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z PROC ; CvPlot::ComputeCultureFromAdjacentImprovement, COMDAT
; _this$ = ecx

; 4808 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 4809 : 	CvPlot* pAdjacentPlot;
; 4810 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 4811 : 
; 4812 : 	if(kImprovement.GetCultureAdjacentSameType() > 0)

	mov	ecx, DWORD PTR _kImprovement$[ebp]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	test	eax, eax
	jle	SHORT $LN5@ComputeCul

; 4813 : 	{
; 4814 : 		for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$224051[ebp], 0
	jmp	SHORT $LN4@ComputeCul
$LN3@ComputeCul:
	mov	eax, DWORD PTR _iI$224051[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$224051[ebp], eax
$LN4@ComputeCul:
	cmp	DWORD PTR _iI$224051[ebp], 6
	jge	SHORT $LN5@ComputeCul

; 4815 : 		{
; 4816 : 			pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T245009[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T245013[ebp], ecx
	mov	edx, DWORD PTR _iI$224051[ebp]
	push	edx
	mov	eax, DWORD PTR $T245009[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245013[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 4817 : 			if(pAdjacentPlot && pAdjacentPlot->getImprovementType() == eValue)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN1@ComputeCul
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eValue$[ebp]
	jne	SHORT $LN1@ComputeCul

; 4818 : 			{
; 4819 : 				iRtnValue += kImprovement.GetCultureAdjacentSameType();

	mov	ecx, DWORD PTR _kImprovement$[ebp]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	add	eax, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN1@ComputeCul:

; 4820 : 			}
; 4821 : 		}

	jmp	SHORT $LN3@ComputeCul
$LN5@ComputeCul:

; 4822 : 	}
; 4823 : 
; 4824 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 4825 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ENDP ; CvPlot::ComputeCultureFromAdjacentImprovement
_TEXT	ENDS
PUBLIC	?getNumMajorCivsRevealed@CvPlot@@QBEHXZ		; CvPlot::getNumMajorCivsRevealed
; Function compile flags: /Odtp
;	COMDAT ?getNumMajorCivsRevealed@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumMajorCivsRevealed@CvPlot@@QBEHXZ PROC		; CvPlot::getNumMajorCivsRevealed, COMDAT
; _this$ = ecx

; 4829 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4830 : 	return m_iNumMajorCivsRevealed;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+454]

; 4831 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumMajorCivsRevealed@CvPlot@@QBEHXZ ENDP		; CvPlot::getNumMajorCivsRevealed
_TEXT	ENDS
PUBLIC	?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z	; CvPlot::setNumMajorCivsRevealed
; Function compile flags: /Odtp
;	COMDAT ?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNewValue$ = 8						; size = 4
?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z PROC		; CvPlot::setNumMajorCivsRevealed, COMDAT
; _this$ = ecx

; 4835 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4836 : 	m_iNumMajorCivsRevealed = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _iNewValue$[ebp]
	mov	BYTE PTR [eax+454], cl

; 4837 : 	CvAssert(getNumMajorCivsRevealed() >= 0);
; 4838 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z ENDP		; CvPlot::setNumMajorCivsRevealed
_TEXT	ENDS
PUBLIC	?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z	; CvPlot::changeNumMajorCivsRevealed
; Function compile flags: /Odtp
;	COMDAT ?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z PROC	; CvPlot::changeNumMajorCivsRevealed, COMDAT
; _this$ = ecx

; 4843 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4844 : 	setNumMajorCivsRevealed(getNumMajorCivsRevealed() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumMajorCivsRevealed@CvPlot@@QBEHXZ	; CvPlot::getNumMajorCivsRevealed
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setNumMajorCivsRevealed@CvPlot@@QAEXH@Z ; CvPlot::setNumMajorCivsRevealed

; 4845 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z ENDP	; CvPlot::changeNumMajorCivsRevealed
_TEXT	ENDS
PUBLIC	?getCityRadiusCount@CvPlot@@QBEHXZ		; CvPlot::getCityRadiusCount
; Function compile flags: /Odtp
;	COMDAT ?getCityRadiusCount@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCityRadiusCount@CvPlot@@QBEHXZ PROC			; CvPlot::getCityRadiusCount, COMDAT
; _this$ = ecx

; 4850 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4851 : 	return m_iCityRadiusCount;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+455]

; 4852 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getCityRadiusCount@CvPlot@@QBEHXZ ENDP			; CvPlot::getCityRadiusCount
_TEXT	ENDS
PUBLIC	?isCityRadius@CvPlot@@QBEHXZ			; CvPlot::isCityRadius
; Function compile flags: /Odtp
;	COMDAT ?isCityRadius@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isCityRadius@CvPlot@@QBEHXZ PROC			; CvPlot::isCityRadius, COMDAT
; _this$ = ecx

; 4857 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4858 : 	return (getCityRadiusCount() > 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCityRadiusCount@CvPlot@@QBEHXZ	; CvPlot::getCityRadiusCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	eax, ecx

; 4859 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isCityRadius@CvPlot@@QBEHXZ ENDP			; CvPlot::isCityRadius
_TEXT	ENDS
PUBLIC	?changeCityRadiusCount@CvPlot@@QAEXH@Z		; CvPlot::changeCityRadiusCount
; Function compile flags: /Odtp
;	COMDAT ?changeCityRadiusCount@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeCityRadiusCount@CvPlot@@QAEXH@Z PROC		; CvPlot::changeCityRadiusCount, COMDAT
; _this$ = ecx

; 4864 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4865 : 	m_iCityRadiusCount = (m_iCityRadiusCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+455]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+455], cl

; 4866 : 	CvAssert(getCityRadiusCount() >= 0);
; 4867 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeCityRadiusCount@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeCityRadiusCount
_TEXT	ENDS
PUBLIC	?isStartingPlot@CvPlot@@QBE_NXZ			; CvPlot::isStartingPlot
; Function compile flags: /Odtp
;	COMDAT ?isStartingPlot@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isStartingPlot@CvPlot@@QBE_NXZ PROC			; CvPlot::isStartingPlot, COMDAT
; _this$ = ecx

; 4872 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4873 : 	return m_bStartingPlot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+461]
	shr	al, 2
	and	al, 1

; 4874 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isStartingPlot@CvPlot@@QBE_NXZ ENDP			; CvPlot::isStartingPlot
_TEXT	ENDS
PUBLIC	?setStartingPlot@CvPlot@@QAEX_N@Z		; CvPlot::setStartingPlot
; Function compile flags: /Odtp
;	COMDAT ?setStartingPlot@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bNewValue$ = 8						; size = 1
?setStartingPlot@CvPlot@@QAEX_N@Z PROC			; CvPlot::setStartingPlot, COMDAT
; _this$ = ecx

; 4879 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4880 : 	m_bStartingPlot = bNewValue;

	mov	al, BYTE PTR _bNewValue$[ebp]
	and	al, 1
	shl	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 251					; 000000fbH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 4881 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setStartingPlot@CvPlot@@QAEX_N@Z ENDP			; CvPlot::setStartingPlot
_TEXT	ENDS
PUBLIC	?isNEOfRiver@CvPlot@@QBE_NXZ			; CvPlot::isNEOfRiver
; Function compile flags: /Odtp
;	COMDAT ?isNEOfRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isNEOfRiver@CvPlot@@QBE_NXZ PROC			; CvPlot::isNEOfRiver, COMDAT
; _this$ = ecx

; 4886 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4887 : 	return m_bNEOfRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+461]
	shr	al, 4
	and	al, 1

; 4888 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isNEOfRiver@CvPlot@@QBE_NXZ ENDP			; CvPlot::isNEOfRiver
_TEXT	ENDS
PUBLIC	?updateRiverCrossing@CvPlot@@QAEXXZ		; CvPlot::updateRiverCrossing
EXTRN	?changeNumRiverEdges@CvArea@@QAEXH@Z:PROC	; CvArea::changeNumRiverEdges
; Function compile flags: /Odtp
;	COMDAT ?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T245261 = -16						; size = 4
$T245257 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_bNewValue$ = 8						; size = 1
_eRiverDir$ = 12					; size = 4
?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z PROC ; CvPlot::setNEOfRiver, COMDAT
; _this$ = ecx

; 4893 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 4894 : 	CvPlot* pAdjacentPlot;
; 4895 : 	int iI;
; 4896 : 
; 4897 : 	if((isNEOfRiver() != bNewValue) || (eRiverDir != m_eRiverSWFlowDirection))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	movzx	eax, al
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN7@setNEOfRiv
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+452]
	cmp	DWORD PTR _eRiverDir$[ebp], eax
	je	$LN9@setNEOfRiv
$LN7@setNEOfRiv:

; 4898 : 	{
; 4899 : 		CvAssertMsg(m_eRiverSWFlowDirection == NO_FLOWDIRECTION && eRiverDir != NO_FLOWDIRECTION, "invalid parameter");
; 4900 : 		if(isNEOfRiver() != bNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN6@setNEOfRiv

; 4901 : 		{
; 4902 : 			m_bNEOfRiver = bNewValue;

	mov	al, BYTE PTR _bNewValue$[ebp]
	and	al, 1
	shl	al, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 239					; 000000efH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 4903 : 
; 4904 : 			updateRiverCrossing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateRiverCrossing@CvPlot@@QAEXXZ	; CvPlot::updateRiverCrossing

; 4905 : 			updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 4906 : 
; 4907 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@setNEOfRiv
$LN4@setNEOfRiv:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@setNEOfRiv:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@setNEOfRiv

; 4908 : 			{
; 4909 : 				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T245257[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T245261[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245257[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245261[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 4910 : 
; 4911 : 				if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@setNEOfRiv

; 4912 : 				{
; 4913 : 					pAdjacentPlot->updateRiverCrossing();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?updateRiverCrossing@CvPlot@@QAEXXZ	; CvPlot::updateRiverCrossing

; 4914 : 					pAdjacentPlot->updateYield();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN2@setNEOfRiv:

; 4915 : 				}
; 4916 : 			}

	jmp	SHORT $LN4@setNEOfRiv
$LN3@setNEOfRiv:

; 4917 : 
; 4918 : 			if(area() != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN6@setNEOfRiv

; 4919 : 			{
; 4920 : 				area()->changeNumRiverEdges((isNEOfRiver()) ? 1 : -1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN6@setNEOfRiv:

; 4921 : 			}
; 4922 : 		}
; 4923 : 
; 4924 : 		CvAssertMsg(eRiverDir == FLOWDIRECTION_NORTHWEST || eRiverDir == FLOWDIRECTION_SOUTHEAST || eRiverDir == NO_FLOWDIRECTION, "invalid parameter");
; 4925 : 		m_eRiverSWFlowDirection = eRiverDir;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _eRiverDir$[ebp]
	mov	BYTE PTR [ecx+452], dl
$LN9@setNEOfRiv:

; 4926 : 	}
; 4927 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ENDP ; CvPlot::setNEOfRiver
_TEXT	ENDS
PUBLIC	?isWOfRiver@CvPlot@@QBE_NXZ			; CvPlot::isWOfRiver
; Function compile flags: /Odtp
;	COMDAT ?isWOfRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isWOfRiver@CvPlot@@QBE_NXZ PROC			; CvPlot::isWOfRiver, COMDAT
; _this$ = ecx

; 4932 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4933 : 	return m_bWOfRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+461]
	shr	al, 5
	and	al, 1

; 4934 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isWOfRiver@CvPlot@@QBE_NXZ ENDP			; CvPlot::isWOfRiver
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T245493 = -16						; size = 4
$T245489 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_bNewValue$ = 8						; size = 1
_eRiverDir$ = 12					; size = 4
?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z PROC ; CvPlot::setWOfRiver, COMDAT
; _this$ = ecx

; 4939 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 4940 : 	CvPlot* pAdjacentPlot;
; 4941 : 	int iI;
; 4942 : 
; 4943 : 	if((isWOfRiver() != bNewValue) || (eRiverDir != m_eRiverEFlowDirection))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	movzx	eax, al
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN7@setWOfRive
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+450]
	cmp	DWORD PTR _eRiverDir$[ebp], eax
	je	$LN9@setWOfRive
$LN7@setWOfRive:

; 4944 : 	{
; 4945 : 		CvAssertMsg(m_eRiverEFlowDirection == NO_FLOWDIRECTION && eRiverDir != NO_FLOWDIRECTION, "invalid parameter");
; 4946 : 		if(isWOfRiver() != bNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN6@setWOfRive

; 4947 : 		{
; 4948 : 			m_bWOfRiver = bNewValue;

	mov	al, BYTE PTR _bNewValue$[ebp]
	and	al, 1
	shl	al, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 223					; 000000dfH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 4949 : 
; 4950 : 			updateRiverCrossing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateRiverCrossing@CvPlot@@QAEXXZ	; CvPlot::updateRiverCrossing

; 4951 : 			updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 4952 : 
; 4953 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@setWOfRive
$LN4@setWOfRive:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@setWOfRive:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@setWOfRive

; 4954 : 			{
; 4955 : 				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T245489[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T245493[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245489[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245493[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 4956 : 
; 4957 : 				if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@setWOfRive

; 4958 : 				{
; 4959 : 					pAdjacentPlot->updateRiverCrossing();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?updateRiverCrossing@CvPlot@@QAEXXZ	; CvPlot::updateRiverCrossing

; 4960 : 					pAdjacentPlot->updateYield();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN2@setWOfRive:

; 4961 : 				}
; 4962 : 			}

	jmp	SHORT $LN4@setWOfRive
$LN3@setWOfRive:

; 4963 : 
; 4964 : 			if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN6@setWOfRive

; 4965 : 			{
; 4966 : 				area()->changeNumRiverEdges((isWOfRiver()) ? 1 : -1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN6@setWOfRive:

; 4967 : 			}
; 4968 : 		}
; 4969 : 
; 4970 : 		CvAssertMsg(eRiverDir == FLOWDIRECTION_NORTH || eRiverDir == FLOWDIRECTION_SOUTH || eRiverDir == NO_FLOWDIRECTION, "invalid parameter");
; 4971 : 		m_eRiverEFlowDirection= eRiverDir;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _eRiverDir$[ebp]
	mov	BYTE PTR [ecx+450], dl
$LN9@setWOfRive:

; 4972 : 	}
; 4973 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ENDP ; CvPlot::setWOfRiver
_TEXT	ENDS
PUBLIC	?isNWOfRiver@CvPlot@@QBE_NXZ			; CvPlot::isNWOfRiver
; Function compile flags: /Odtp
;	COMDAT ?isNWOfRiver@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isNWOfRiver@CvPlot@@QBE_NXZ PROC			; CvPlot::isNWOfRiver, COMDAT
; _this$ = ecx

; 4978 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4979 : 	return m_bNWOfRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+461]
	shr	al, 6
	and	al, 1

; 4980 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isNWOfRiver@CvPlot@@QBE_NXZ ENDP			; CvPlot::isNWOfRiver
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T245725 = -16						; size = 4
$T245721 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_bNewValue$ = 8						; size = 1
_eRiverDir$ = 12					; size = 4
?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z PROC ; CvPlot::setNWOfRiver, COMDAT
; _this$ = ecx

; 4985 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 4986 : 	CvPlot* pAdjacentPlot;
; 4987 : 	int iI;
; 4988 : 
; 4989 : 	if((isNWOfRiver() != bNewValue) || (eRiverDir != m_eRiverSEFlowDirection))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	movzx	eax, al
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN7@setNWOfRiv
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+451]
	cmp	DWORD PTR _eRiverDir$[ebp], eax
	je	$LN9@setNWOfRiv
$LN7@setNWOfRiv:

; 4990 : 	{
; 4991 : 		CvAssertMsg(m_eRiverSEFlowDirection == NO_FLOWDIRECTION && eRiverDir != NO_FLOWDIRECTION, "invalid parameter");
; 4992 : 		if(isNWOfRiver() != bNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN6@setNWOfRiv

; 4993 : 		{
; 4994 : 			m_bNWOfRiver = bNewValue;

	mov	al, BYTE PTR _bNewValue$[ebp]
	and	al, 1
	shl	al, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 191					; 000000bfH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 4995 : 
; 4996 : 			updateRiverCrossing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateRiverCrossing@CvPlot@@QAEXXZ	; CvPlot::updateRiverCrossing

; 4997 : 			updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 4998 : 
; 4999 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@setNWOfRiv
$LN4@setNWOfRiv:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@setNWOfRiv:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@setNWOfRiv

; 5000 : 			{
; 5001 : 				pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T245721[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T245725[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T245721[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245725[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 5002 : 
; 5003 : 				if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@setNWOfRiv

; 5004 : 				{
; 5005 : 					pAdjacentPlot->updateRiverCrossing();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?updateRiverCrossing@CvPlot@@QAEXXZ	; CvPlot::updateRiverCrossing

; 5006 : 					pAdjacentPlot->updateYield();

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN2@setNWOfRiv:

; 5007 : 				}
; 5008 : 			}

	jmp	SHORT $LN4@setNWOfRiv
$LN3@setNWOfRiv:

; 5009 : 
; 5010 : 			if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN6@setNWOfRiv

; 5011 : 			{
; 5012 : 				area()->changeNumRiverEdges((isNWOfRiver()) ? 1 : -1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN6@setNWOfRiv:

; 5013 : 			}
; 5014 : 		}
; 5015 : 
; 5016 : 		CvAssertMsg(eRiverDir == FLOWDIRECTION_NORTHEAST || eRiverDir == FLOWDIRECTION_SOUTHWEST || eRiverDir == NO_FLOWDIRECTION, "invalid parameter");
; 5017 : 		m_eRiverSEFlowDirection = eRiverDir;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _eRiverDir$[ebp]
	mov	BYTE PTR [ecx+451], dl
$LN9@setNWOfRiv:

; 5018 : 	}
; 5019 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ENDP ; CvPlot::setNWOfRiver
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ PROC ; CvPlot::getRiverEFlowDirection, COMDAT
; _this$ = ecx

; 5024 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5025 : 	return (FlowDirectionTypes)m_eRiverEFlowDirection;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+450]

; 5026 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ENDP ; CvPlot::getRiverEFlowDirection
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ PROC ; CvPlot::getRiverSEFlowDirection, COMDAT
; _this$ = ecx

; 5031 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5032 : 	return (FlowDirectionTypes)m_eRiverSEFlowDirection;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+451]

; 5033 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ENDP ; CvPlot::getRiverSEFlowDirection
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ PROC ; CvPlot::getRiverSWFlowDirection, COMDAT
; _this$ = ecx

; 5037 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5038 : 	return (FlowDirectionTypes)m_eRiverSWFlowDirection;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+452]

; 5039 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ENDP ; CvPlot::getRiverSWFlowDirection
_TEXT	ENDS
PUBLIC	?hasCoastAtSECorner@CvPlot@@QBE_NXZ		; CvPlot::hasCoastAtSECorner
PUBLIC	?getInlandCorner@CvPlot@@QBEPAV1@XZ		; CvPlot::getInlandCorner
EXTRN	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z:PROC	; shuffleArray
EXTRN	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ:PROC	; CvGame::getMapRand
; Function compile flags: /Odtp
;	COMDAT ?getInlandCorner@CvPlot@@QBEPAV1@XZ
_TEXT	SEGMENT
tv75 = -316						; size = 4
_this$ = -312						; size = 4
$T246358 = -228						; size = 4
$T246354 = -224						; size = 4
$T246170 = -140						; size = 4
$T246166 = -136						; size = 4
$T245995 = -52						; size = 4
$T245991 = -48						; size = 4
$T245975 = -44						; size = 4
$T245969 = -40						; size = 4
$T245965 = -36						; size = 4
$T245961 = -32						; size = 4
$T245957 = -28						; size = 4
_iI$224159 = -24					; size = 4
_pRiverPlot$ = -20					; size = 4
_aiShuffle$ = -16					; size = 16
?getInlandCorner@CvPlot@@QBEPAV1@XZ PROC		; CvPlot::getInlandCorner, COMDAT
; _this$ = ecx

; 5047 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	mov	DWORD PTR _this$[ebp], ecx

; 5048 : 	CvPlot* pRiverPlot = NULL; // will be a plot through whose SE corner we want the river to run

	mov	DWORD PTR _pRiverPlot$[ebp], 0

; 5049 : 	int aiShuffle[4];
; 5050 : 
; 5051 : 	shuffleArray(aiShuffle, 4, GC.getGame().getMapRand());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T245957[ebp], eax
	mov	ecx, DWORD PTR $T245957[ebp]
	call	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getMapRand
	push	eax
	push	4
	lea	ecx, DWORD PTR _aiShuffle$[ebp]
	push	ecx
	call	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z	; shuffleArray
	add	esp, 12					; 0000000cH

; 5052 : 
; 5053 : 	for(int iI = 0; iI < 4; ++iI)

	mov	DWORD PTR _iI$224159[ebp], 0
	jmp	SHORT $LN11@getInlandC
$LN10@getInlandC:
	mov	edx, DWORD PTR _iI$224159[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$224159[ebp], edx
$LN11@getInlandC:
	cmp	DWORD PTR _iI$224159[ebp], 4
	jge	$LN9@getInlandC

; 5054 : 	{
; 5055 : 		switch(aiShuffle[iI])

	mov	eax, DWORD PTR _iI$224159[ebp]
	mov	ecx, DWORD PTR _aiShuffle$[ebp+eax*4]
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 3
	ja	$LN7@getInlandC
	mov	edx, DWORD PTR tv75[ebp]
	jmp	DWORD PTR $LN270@getInlandC[edx*4]
$LN6@getInlandC:

; 5056 : 		{
; 5057 : 		case 0:
; 5058 : 			pRiverPlot = GC.getMap().plotCheckInvalid(getX(), getY());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T245961[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T245965[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T245969[ebp], ecx
	cmp	DWORD PTR $T245965[ebp], -2147483647	; 80000001H
	je	SHORT $LN22@getInlandC
	cmp	DWORD PTR $T245961[ebp], -2147483647	; 80000001H
	jne	SHORT $LN23@getInlandC
$LN22@getInlandC:
	mov	DWORD PTR _pRiverPlot$[ebp], 0
	jmp	SHORT $LN24@getInlandC
$LN23@getInlandC:
	mov	edx, DWORD PTR $T245969[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T245975[ebp], eax
	mov	ecx, DWORD PTR $T245961[ebp]
	imul	ecx, DWORD PTR $T245975[ebp]
	add	ecx, DWORD PTR $T245965[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T245969[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pRiverPlot$[ebp], ecx
$LN24@getInlandC:

; 5059 : 			break;

	jmp	$LN7@getInlandC
$LN5@getInlandC:

; 5060 : 		case 1:
; 5061 : 			pRiverPlot = plotDirection(getX(), getY(), DIRECTION_NORTH);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T245991[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T245995[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T245991[ebp]
	push	ecx
	mov	edx, DWORD PTR $T245995[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pRiverPlot$[ebp], eax

; 5062 : 			break;

	jmp	SHORT $LN7@getInlandC
$LN4@getInlandC:

; 5063 : 		case 2:
; 5064 : 			pRiverPlot = plotDirection(getX(), getY(), DIRECTION_NORTHWEST);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T246166[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T246170[ebp], eax
	push	5
	mov	ecx, DWORD PTR $T246166[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246170[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pRiverPlot$[ebp], eax

; 5065 : 			break;

	jmp	SHORT $LN7@getInlandC
$LN3@getInlandC:

; 5066 : 		case 3:
; 5067 : 			pRiverPlot = plotDirection(getX(), getY(), DIRECTION_WEST);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T246354[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T246358[ebp], eax
	push	4
	mov	ecx, DWORD PTR $T246354[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246358[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pRiverPlot$[ebp], eax
$LN7@getInlandC:

; 5068 : 			break;
; 5069 : 		}
; 5070 : 		if(pRiverPlot != NULL && !pRiverPlot->hasCoastAtSECorner())

	cmp	DWORD PTR _pRiverPlot$[ebp], 0
	je	SHORT $LN2@getInlandC
	mov	ecx, DWORD PTR _pRiverPlot$[ebp]
	call	?hasCoastAtSECorner@CvPlot@@QBE_NXZ	; CvPlot::hasCoastAtSECorner
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@getInlandC

; 5071 : 		{
; 5072 : 			break;

	jmp	SHORT $LN9@getInlandC

; 5073 : 		}
; 5074 : 		else

	jmp	SHORT $LN1@getInlandC
$LN2@getInlandC:

; 5075 : 		{
; 5076 : 			pRiverPlot = NULL;

	mov	DWORD PTR _pRiverPlot$[ebp], 0
$LN1@getInlandC:

; 5077 : 		}
; 5078 : 	}

	jmp	$LN10@getInlandC
$LN9@getInlandC:

; 5079 : 
; 5080 : 	return pRiverPlot;

	mov	eax, DWORD PTR _pRiverPlot$[ebp]

; 5081 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN270@getInlandC:
	DD	$LN6@getInlandC
	DD	$LN5@getInlandC
	DD	$LN4@getInlandC
	DD	$LN3@getInlandC
?getInlandCorner@CvPlot@@QBEPAV1@XZ ENDP		; CvPlot::getInlandCorner
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?hasCoastAtSECorner@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -184						; size = 4
$T246729 = -92						; size = 4
$T246725 = -88						; size = 4
$T246565 = -12						; size = 4
$T246561 = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
?hasCoastAtSECorner@CvPlot@@QBE_NXZ PROC		; CvPlot::hasCoastAtSECorner, COMDAT
; _this$ = ecx

; 5086 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	DWORD PTR _this$[ebp], ecx

; 5087 : 	CvPlot* pAdjacentPlot;
; 5088 : 
; 5089 : 	if(isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@hasCoastAt

; 5090 : 	{
; 5091 : 		return true;

	mov	al, 1
	jmp	$LN4@hasCoastAt
$LN3@hasCoastAt:

; 5092 : 	}
; 5093 : 
; 5094 : 	pAdjacentPlot = plotDirection(getX(), getY(), DIRECTION_EAST);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T246561[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T246565[ebp], ecx
	push	1
	mov	edx, DWORD PTR $T246561[ebp]
	push	edx
	mov	eax, DWORD PTR $T246565[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 5095 : 	if(pAdjacentPlot != NULL && pAdjacentPlot->isWater())

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@hasCoastAt
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@hasCoastAt

; 5096 : 	{
; 5097 : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@hasCoastAt
$LN2@hasCoastAt:

; 5098 : 	}
; 5099 : 
; 5100 : 	pAdjacentPlot = plotDirection(getX(), getY(), DIRECTION_SOUTHEAST);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T246725[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T246729[ebp], edx
	push	2
	mov	eax, DWORD PTR $T246725[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246729[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 5101 : 	if(pAdjacentPlot != NULL && pAdjacentPlot->isWater())

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN1@hasCoastAt
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@hasCoastAt

; 5102 : 	{
; 5103 : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@hasCoastAt
$LN1@hasCoastAt:

; 5104 : 	}
; 5105 : 
; 5106 : 	return false;

	xor	al, al
$LN4@hasCoastAt:

; 5107 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hasCoastAtSECorner@CvPlot@@QBE_NXZ ENDP		; CvPlot::hasCoastAtSECorner
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPotentialCityWork@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isPotentialCityWork@CvPlot@@QBE_NXZ PROC		; CvPlot::isPotentialCityWork, COMDAT
; _this$ = ecx

; 5112 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5113 : 	return m_bPotentialCityWork;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+461]
	shr	al, 7
	and	al, 1

; 5114 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isPotentialCityWork@CvPlot@@QBE_NXZ ENDP		; CvPlot::isPotentialCityWork
_TEXT	ENDS
PUBLIC	?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z ; CvPlot::isPotentialCityWorkForArea
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
; Function compile flags: /Odtp
;	COMDAT ?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T246958 = -20						; size = 4
$T246951 = -16						; size = 4
$T246947 = -12						; size = 4
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_pArea$ = 8						; size = 4
?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z PROC ; CvPlot::isPotentialCityWorkForArea, COMDAT
; _this$ = ecx

; 5119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 5120 : 	CvPlot* pLoopPlot;
; 5121 : 	int iI;
; 5122 : 
; 5123 : 	for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@isPotentia@2
$LN6@isPotentia@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@isPotentia@2:
	cmp	DWORD PTR _iI$[ebp], 37			; 00000025H
	jge	SHORT $LN5@isPotentia@2

; 5124 : 	{
; 5125 : 		pLoopPlot = plotCity(getX(), getY(), iI);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T246947[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T246951[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T246947[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246951[ebp]
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5126 : 
; 5127 : 		if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN4@isPotentia@2

; 5128 : 		{
; 5129 : 			if(!(pLoopPlot->isWater()) || GC.getWATER_POTENTIAL_CITY_WORK_FOR_AREA())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@isPotentia@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6884
	mov	DWORD PTR $T246958[ebp], eax
	cmp	DWORD PTR $T246958[ebp], 0
	je	SHORT $LN4@isPotentia@2
$LN2@isPotentia@2:

; 5130 : 			{
; 5131 : 				if(pLoopPlot->area() == pArea)

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	eax, DWORD PTR _pArea$[ebp]
	jne	SHORT $LN4@isPotentia@2

; 5132 : 				{
; 5133 : 					return true;

	mov	al, 1
	jmp	SHORT $LN8@isPotentia@2
$LN4@isPotentia@2:

; 5134 : 				}
; 5135 : 			}
; 5136 : 		}
; 5137 : 	}

	jmp	SHORT $LN6@isPotentia@2
$LN5@isPotentia@2:

; 5138 : 
; 5139 : 	return false;

	xor	al, al
$LN8@isPotentia@2:

; 5140 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z ENDP ; CvPlot::isPotentialCityWorkForArea
_TEXT	ENDS
PUBLIC	?updatePotentialCityWork@CvPlot@@QAEXXZ		; CvPlot::updatePotentialCityWork
; Function compile flags: /Odtp
;	COMDAT ?updatePotentialCityWork@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T246968 = -20						; size = 4
$T246964 = -16						; size = 4
_bValid$ = -9						; size = 1
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
?updatePotentialCityWork@CvPlot@@QAEXXZ PROC		; CvPlot::updatePotentialCityWork, COMDAT
; _this$ = ecx

; 5145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 5146 : 	CvPlot* pLoopPlot;
; 5147 : 	bool bValid;
; 5148 : 	int iI;
; 5149 : 
; 5150 : 	bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 5151 : 
; 5152 : 	for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@updatePote
$LN5@updatePote:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@updatePote:
	cmp	DWORD PTR _iI$[ebp], 37			; 00000025H
	jge	SHORT $LN4@updatePote

; 5153 : 	{
; 5154 : 		pLoopPlot = plotCity(getX(), getY(), iI);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T246964[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T246968[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T246964[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246968[ebp]
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5155 : 
; 5156 : 		if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN3@updatePote

; 5157 : 		{
; 5158 : 			if(!(pLoopPlot->isWater()))

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN3@updatePote

; 5159 : 			{
; 5160 : 				bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 5161 : 				break;

	jmp	SHORT $LN4@updatePote
$LN3@updatePote:

; 5162 : 			}
; 5163 : 		}
; 5164 : 	}

	jmp	SHORT $LN5@updatePote
$LN4@updatePote:

; 5165 : 
; 5166 : 	if(isPotentialCityWork() != bValid)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPotentialCityWork@CvPlot@@QBE_NXZ	; CvPlot::isPotentialCityWork
	movzx	eax, al
	movzx	ecx, BYTE PTR _bValid$[ebp]
	cmp	eax, ecx
	je	SHORT $LN7@updatePote

; 5167 : 	{
; 5168 : 		m_bPotentialCityWork = bValid;

	mov	dl, BYTE PTR _bValid$[ebp]
	and	dl, 1
	shl	dl, 7
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	and	cl, 127					; 0000007fH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+461], cl

; 5169 : 
; 5170 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN7@updatePote:

; 5171 : 	}
; 5172 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updatePotentialCityWork@CvPlot@@QAEXXZ ENDP		; CvPlot::updatePotentialCityWork
_TEXT	ENDS
PUBLIC	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
PUBLIC	?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ; CvPlot::updateRevealedOwner
PUBLIC	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo
PUBLIC	?updateWorkingCity@CvPlot@@QAEXXZ		; CvPlot::updateWorkingCity
PUBLIC	?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::setWorkingCityOverride
PUBLIC	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatClearedBarbCampHere
PUBLIC	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForRoute
PUBLIC	?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForImprovement
PUBLIC	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
PUBLIC	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
PUBLIC	?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::SetResourceLinkedCity
PUBLIC	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::GetResourceLinkedCity
PUBLIC	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z	; CvPlot::setOwner
EXTRN	?DoUpdateHappiness@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateHappiness
EXTRN	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::IsNaturalWonder
EXTRN	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z:PROC ; CvGlobals::WrapPlotPointer
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z:PROC ; CvGlobals::UnwrapCityPointer
EXTRN	?SetCityDistanceHighwaterMark@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::SetCityDistanceHighwaterMark
EXTRN	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetCityDistanceHighwaterMark
EXTRN	?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z:PROC ; CvBarbarians::DoBarbCampCleared
EXTRN	?doGoody@CvPlayer@@QAEXPAVCvPlot@@PAVCvUnit@@@Z:PROC ; CvPlayer::doGoody
EXTRN	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlayer::changeNumResourceTotal
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getTechCityTrade@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechCityTrade
EXTRN	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::GetGoldMaintenance
EXTRN	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z:PROC ; CvTreasury::ChangeBaseImprovementGoldMaintenance
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetGoldMaintenance
EXTRN	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z:PROC ; CvPlayer::changeSiphonLuxuryCount
EXTRN	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
EXTRN	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z:PROC ; CvPlayer::changeImprovementCount
EXTRN	?changeTotalLand@CvTeam@@QAEXH@Z:PROC		; CvTeam::changeTotalLand
EXTRN	?changeTotalLand@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::changeTotalLand
EXTRN	?changeOwnedPlots@CvMap@@QAEXH@Z:PROC		; CvMap::changeOwnedPlots
EXTRN	?changeNumOwnedTiles@CvArea@@QAEXH@Z:PROC	; CvArea::changeNumOwnedTiles
EXTRN	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z:PROC ; CvGame::addReplayMessage
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
_TEXT	SEGMENT
tv1143 = -792						; size = 4
tv1130 = -788						; size = 4
tv1104 = -784						; size = 4
tv1006 = -780						; size = 4
tv970 = -776						; size = 4
tv955 = -772						; size = 4
tv884 = -768						; size = 4
tv882 = -764						; size = 4
tv879 = -760						; size = 4
tv875 = -756						; size = 4
tv872 = -752						; size = 4
tv1181 = -748						; size = 4
_this$ = -744						; size = 4
_inst$247778 = -740					; size = 4
$T247775 = -736						; size = 4
$T247766 = -732						; size = 4
$T247759 = -728						; size = 4
_inst$247753 = -724					; size = 4
$T247750 = -720						; size = 4
$T247741 = -716						; size = 4
__Ptr$247740 = -712					; size = 4
$T247736 = -708						; size = 4
__Cvtptr$247731 = -704					; size = 4
__Ans$247732 = -700					; size = 4
_inst$247723 = -696					; size = 4
$T247720 = -692						; size = 4
$T247708 = -688						; size = 4
_inst$247702 = -684					; size = 4
$T247699 = -680						; size = 4
$T247690 = -676						; size = 4
__Ptr$247689 = -672					; size = 4
$T247685 = -668						; size = 4
__Cvtptr$247680 = -664					; size = 4
__Ans$247681 = -660					; size = 4
$T247674 = -656						; size = 4
$T247667 = -652						; size = 4
$T247663 = -648						; size = 4
_playerID$247655 = -644					; size = 4
$T247646 = -640						; size = 4
_playerID$247638 = -636					; size = 4
_f$247626 = -630					; size = 1
_f$247617 = -629					; size = 1
$T247608 = -628						; size = 4
_inst$247604 = -624					; size = 4
$T247600 = -620						; size = 4
_inst$247589 = -616					; size = 4
$T247585 = -612						; size = 4
$T247573 = -608						; size = 4
_inst$247568 = -604					; size = 4
$T247564 = -600						; size = 4
$T247555 = -596						; size = 4
__Ptr$247554 = -592					; size = 4
$T247550 = -588						; size = 4
__Cvtptr$247545 = -584					; size = 4
__Ans$247546 = -580					; size = 4
$T247539 = -576						; size = 4
$T247532 = -572						; size = 4
$T247528 = -568						; size = 4
$T247524 = -564						; size = 4
$T247520 = -560						; size = 4
$T247412 = -504						; size = 4
$T247408 = -500						; size = 4
$T247401 = -496						; size = 4
$T247397 = -492						; size = 4
$T247393 = -488						; size = 4
$T247389 = -484						; size = 4
$T247385 = -480						; size = 4
_playerID$247377 = -476					; size = 4
$T247368 = -472						; size = 4
$T247359 = -464						; size = 4
$T247355 = -460						; size = 4
$T247354 = -456						; size = 4
$T247350 = -452						; size = 4
$T247346 = -448						; size = 4
$T247339 = -444						; size = 4
$T247332 = -440						; size = 4
_playerID$247324 = -436					; size = 4
$T247312 = -432						; size = 4
$T247305 = -428						; size = 4
$T247293 = -424						; size = 4
$T247292 = -420						; size = 4
$T247288 = -416						; size = 4
$T247273 = -412						; size = 4
$T247269 = -408						; size = 4
$T247265 = -404						; size = 4
$T247261 = -400						; size = 4
_playerID$247258 = -396					; size = 4
$T247244 = -392						; size = 4
$T247237 = -388						; size = 4
$T247230 = -384						; size = 4
$T247229 = -380						; size = 4
$T247225 = -376						; size = 4
$T247224 = -372						; size = 4
$T247220 = -368						; size = 4
$T247216 = -364						; size = 4
$T247212 = -360						; size = 4
$T247208 = -356						; size = 4
$T247204 = -352						; size = 4
_playerID$247201 = -348					; size = 4
$T247187 = -344						; size = 4
$T247183 = -340						; size = 4
$T247179 = -336						; size = 4
$T247170 = -328						; size = 4
$T247166 = -324						; size = 4
$T247162 = -320						; size = 4
$T247158 = -316						; size = 4
$T247157 = -312						; size = 4
$T247153 = -308						; size = 4
$T247149 = -304						; size = 4
$T247145 = -300						; size = 4
$T247138 = -296						; size = 4
$T247131 = -292						; size = 4
_playerID$247128 = -288					; size = 4
$T247111 = -284						; size = 4
$T247104 = -280						; size = 4
$T247092 = -276						; size = 4
$T247091 = -272						; size = 4
$T247087 = -268						; size = 4
$T247072 = -264						; size = 4
$T247068 = -260						; size = 4
$T247064 = -256						; size = 4
$T247060 = -252						; size = 4
_playerID$247057 = -248					; size = 4
$T247043 = -244						; size = 4
$T247030 = -236						; size = 4
$T247026 = -232						; size = 4
$T247022 = -228						; size = 4
$T246991 = -224						; size = 4
$T246990 = -220						; size = 4
$T246989 = -216						; size = 4
$T246988 = -212						; size = 4
$T246987 = -208						; size = 4
$T246986 = -204						; size = 4
$T246975 = -200						; size = 28
_pDllPlot$224409 = -172					; size = 4
_bShouldUpdateHappiness$224399 = -165			; size = 1
_pkHeadSelectedCity$224379 = -164			; size = 4
_pDllPlot$224381 = -160					; size = 4
_pHeadSelectedCity$224368 = -156			; size = 4
_thisCity$224316 = -152					; size = 4
_pLoopPlot$224314 = -148				; size = 4
_iAbsDY$224312 = -144					; size = 4
_iAbsDX$224311 = -140					; size = 4
_iAbsDY$224309 = -136					; size = 4
_iAbsDX$224308 = -132					; size = 4
_hexRange$224306 = -128					; size = 4
_iDY$224302 = -124					; size = 4
_iDX$224298 = -120					; size = 4
_bestHighWaterMark$224297 = -116			; size = 4
_pImprovementInfo$224282 = -112				; size = 4
_thisPlayer$224275 = -108				; size = 4
_pMinorCivAI$224276 = -104				; size = 4
_ePlayer$224270 = -100					; size = 4
_ui$224266 = -96					; size = 4
_newPlayer$224262 = -92					; size = 4
_iMaxCityHighWaterMark$224295 = -88			; size = 4
_pImprovementInfo$224240 = -84				; size = 4
_thisPlayer$224233 = -80				; size = 4
_pMinorCivAI$224234 = -76				; size = 4
_ePlayer$224228 = -72					; size = 4
_ui$224224 = -68					; size = 4
_eOldOwner$224220 = -64					; size = 4
_pDllPlot$224413 = -60					; size = 4
_strBuffer$ = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_pUnitNode$ = -24					; size = 4
_pOldCity$ = -20					; size = 4
_iI$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eNewValue$ = 8						; size = 4
_iAcquiringCityID$ = 12					; size = 4
_bCheckUnits$ = 16					; size = 1
___formal$ = 20						; size = 1
?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z PROC	; CvPlot::setOwner, COMDAT
; _this$ = ecx

; 5176 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 780				; 0000030cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5177 : 	IDInfo* pUnitNode;
; 5178 : 	CvCity* pOldCity;
; 5179 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5180 : 	int iI;
; 5181 : 
; 5182 : 	// Remove effects for old owner before changing the member
; 5183 : 	if(getOwner() != eNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR _eNewValue$[ebp]
	je	$LN86@setOwner

; 5184 : 	{
; 5185 : 		PlayerTypes eOldOwner = getOwner();;

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _eOldOwner$224220[ebp], eax

; 5186 : 
; 5187 : 		GC.getGame().addReplayMessage(REPLAY_MESSAGE_PLOT_OWNER_CHANGE, eNewValue, "", getX(), getY());

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	ecx, ecx
	je	SHORT $LN117@setOwner
	mov	DWORD PTR tv1181[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
	jmp	SHORT $LN118@setOwner
$LN117@setOwner:
	mov	DWORD PTR tv1181[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN118@setOwner:
	mov	edx, DWORD PTR tv1181[ebp]
	push	edx
	lea	ecx, DWORD PTR $T246975[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T247022[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T247026[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T247030[ebp], ecx
	mov	edx, DWORD PTR $T247022[ebp]
	push	edx
	mov	eax, DWORD PTR $T247026[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246975[ebp]
	push	ecx
	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	push	2
	mov	ecx, DWORD PTR $T247030[ebp]
	call	?addReplayMessage@CvGame@@QAEXW4ReplayMessageTypes@@W4PlayerTypes@@ABVCvString@@HH@Z ; CvGame::addReplayMessage
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T246975[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5188 : 
; 5189 : 		pOldCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pOldCity$[ebp], eax

; 5190 : 
; 5191 : 		{
; 5192 : 			setOwnershipDuration(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setOwnershipDuration@CvPlot@@QAEXH@Z	; CvPlot::setOwnershipDuration

; 5193 : 
; 5194 : 			// Plot was owned by someone else
; 5195 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	$LN85@setOwner

; 5196 : 			{
; 5197 : 				changeAdjacentSight(getTeam(), GC.getPLOT_VISIBILITY_RANGE(), false, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	DWORD PTR $T247043[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$247057[ebp], eax
	cmp	DWORD PTR _playerID$247057[ebp], -1
	je	SHORT $LN137@setOwner
	mov	ecx, DWORD PTR _playerID$247057[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247060[ebp], eax
	jmp	SHORT $LN138@setOwner
	jmp	SHORT $LN138@setOwner
$LN137@setOwner:
	mov	DWORD PTR $T247060[ebp], -1
$LN138@setOwner:
	push	0
	push	-1
	push	-1
	push	0
	mov	edx, DWORD PTR $T247043[ebp]
	push	edx
	mov	eax, DWORD PTR $T247060[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight

; 5198 : 
; 5199 : 				// if this tile is owned by a minor share the visibility with my ally
; 5200 : 				if(pOldCity)

	cmp	DWORD PTR _pOldCity$[ebp], 0
	je	$LN84@setOwner

; 5201 : 				{
; 5202 : 					for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$224224[ebp], 0
	jmp	SHORT $LN83@setOwner
$LN82@setOwner:
	mov	ecx, DWORD PTR _ui$224224[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$224224[ebp], ecx
$LN83@setOwner:
	cmp	DWORD PTR _ui$224224[ebp], 22		; 00000016H
	jae	$LN84@setOwner

; 5203 : 					{
; 5204 : 						PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	edx, DWORD PTR _ui$224224[ebp]
	mov	DWORD PTR _ePlayer$224228[ebp], edx

; 5205 : 						if(GET_PLAYER(ePlayer).GetEspionage()->HasEstablishedSurveillanceInCity(pOldCity))

	mov	eax, DWORD PTR _ePlayer$224228[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247064[ebp], eax
	mov	ecx, DWORD PTR _pOldCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T247064[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN80@setOwner

; 5206 : 						{
; 5207 : 							changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), false, NO_INVISIBLE, NO_DIRECTION, false);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	mov	DWORD PTR $T247068[ebp], eax
	mov	ecx, DWORD PTR _ePlayer$224228[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247072[ebp], ecx
	push	0
	push	-1
	push	-1
	push	0
	mov	edx, DWORD PTR $T247068[ebp]
	push	edx
	mov	eax, DWORD PTR $T247072[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN80@setOwner:

; 5208 : 						}
; 5209 : 					}

	jmp	$LN82@setOwner
$LN84@setOwner:

; 5210 : 				}
; 5211 : 
; 5212 : 				if(eOldOwner >= MAX_MAJOR_CIVS && eOldOwner != BARBARIAN_PLAYER)

	cmp	DWORD PTR _eOldOwner$224220[ebp], 22	; 00000016H
	jl	$LN79@setOwner
	cmp	DWORD PTR _eOldOwner$224220[ebp], 63	; 0000003fH
	je	$LN79@setOwner

; 5213 : 				{
; 5214 : 					CvPlayer& thisPlayer = GET_PLAYER(eOldOwner);

	mov	edx, DWORD PTR _eOldOwner$224220[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$224233[ebp], edx

; 5215 : 					CvMinorCivAI* pMinorCivAI = thisPlayer.GetMinorCivAI();

	mov	ecx, DWORD PTR _thisPlayer$224233[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	DWORD PTR _pMinorCivAI$224234[ebp], eax

; 5216 : 					if(pMinorCivAI && pMinorCivAI->GetAlly() != NO_PLAYER)

	cmp	DWORD PTR _pMinorCivAI$224234[ebp], 0
	je	SHORT $LN79@setOwner
	mov	ecx, DWORD PTR _pMinorCivAI$224234[ebp]
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	je	SHORT $LN79@setOwner

; 5217 : 					{
; 5218 : 						changeAdjacentSight(GET_PLAYER(pMinorCivAI->GetAlly()).getTeam(), GC.getPLOT_VISIBILITY_RANGE(), false, NO_INVISIBLE, NO_DIRECTION, false);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	DWORD PTR $T247087[ebp], eax
	mov	ecx, DWORD PTR _pMinorCivAI$224234[ebp]
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR $T247091[ebp], eax
	mov	ecx, DWORD PTR $T247091[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247092[ebp], ecx
	push	0
	push	-1
	push	-1
	push	0
	mov	edx, DWORD PTR $T247087[ebp]
	push	edx
	mov	eax, DWORD PTR $T247092[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN79@setOwner:

; 5219 : 					}
; 5220 : 				}
; 5221 : 
; 5222 : 				if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN77@setOwner

; 5223 : 				{
; 5224 : 					area()->changeNumOwnedTiles(-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumOwnedTiles@CvArea@@QAEXH@Z	; CvArea::changeNumOwnedTiles
$LN77@setOwner:

; 5225 : 				}
; 5226 : 				GC.getMap().changeOwnedPlots(-1);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T247104[ebp], edx
	push	-1
	mov	ecx, DWORD PTR $T247104[ebp]
	call	?changeOwnedPlots@CvMap@@QAEXH@Z	; CvMap::changeOwnedPlots

; 5227 : 
; 5228 : 				if(!isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN76@setOwner

; 5229 : 				{
; 5230 : 					GET_PLAYER(getOwner()).changeTotalLand(-1);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247111[ebp], edx
	push	-1
	mov	ecx, DWORD PTR $T247111[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeTotalLand@CvPlayer@@QAEXH@Z	; CvPlayer::changeTotalLand

; 5231 : 					GET_TEAM(getTeam()).changeTotalLand(-1);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$247128[ebp], ecx
	cmp	DWORD PTR _playerID$247128[ebp], -1
	je	SHORT $LN173@setOwner
	mov	edx, DWORD PTR _playerID$247128[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247131[ebp], eax
	jmp	SHORT $LN180@setOwner
	jmp	SHORT $LN180@setOwner
$LN173@setOwner:
	mov	DWORD PTR $T247131[ebp], -1
$LN180@setOwner:
	push	-1
	mov	ecx, DWORD PTR $T247131[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?changeTotalLand@CvTeam@@QAEXH@Z	; CvTeam::changeTotalLand

; 5232 : 
; 5233 : 					if(isOwnershipScore())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwnershipScore@CvPlot@@QBE_NXZ	; CvPlot::isOwnershipScore
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN76@setOwner

; 5234 : 					{
; 5235 : 						GET_PLAYER(getOwner()).changeTotalLandScored(-1);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247138[ebp], edx
	push	-1
	mov	ecx, DWORD PTR $T247138[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeTotalLandScored@CvPlayer@@QAEXH@Z ; CvPlayer::changeTotalLandScored
$LN76@setOwner:

; 5236 : 					}
; 5237 : 				}
; 5238 : 
; 5239 : 				// Improvement is here
; 5240 : 				if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN74@setOwner

; 5241 : 				{
; 5242 : 					GET_PLAYER(getOwner()).changeImprovementCount(getImprovementType(), -1);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T247145[ebp], ecx
	mov	edx, DWORD PTR $T247145[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247149[ebp], edx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, DWORD PTR $T247149[ebp]
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 5243 : 
; 5244 : 					// Remove siphoned resources
; 5245 : 					CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(getImprovementType());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovementInfo$224240[ebp], eax

; 5246 : 					if (pImprovementInfo != NULL && pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor() > 0)

	cmp	DWORD PTR _pImprovementInfo$224240[ebp], 0
	je	$LN73@setOwner
	mov	ecx, DWORD PTR _pImprovementInfo$224240[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN73@setOwner

; 5247 : 					{
; 5248 : 						if (GetPlayerThatBuiltImprovement() != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
	cmp	eax, -1
	je	SHORT $LN73@setOwner

; 5249 : 						{
; 5250 : 							if (GET_PLAYER(eOldOwner).isMinorCiv())

	mov	eax, DWORD PTR _eOldOwner$224220[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247153[ebp], eax
	mov	ecx, DWORD PTR $T247153[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN73@setOwner

; 5251 : 							{
; 5252 : 								GET_PLAYER(GetPlayerThatBuiltImprovement()).changeSiphonLuxuryCount(eOldOwner, -1 * pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
	mov	DWORD PTR $T247157[ebp], eax
	mov	edx, DWORD PTR $T247157[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247158[ebp], edx
	mov	ecx, DWORD PTR _pImprovementInfo$224240[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	imul	eax, -1
	push	eax
	mov	eax, DWORD PTR _eOldOwner$224220[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247158[ebp]
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN73@setOwner:

; 5253 : 							}
; 5254 : 						}
; 5255 : 					}
; 5256 : 
; 5257 : 					// Maintenance change!
; 5258 : 					if(MustPayMaintenanceHere(getOwner()))

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247162[ebp], edx
	mov	eax, DWORD PTR $T247162[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN74@setOwner

; 5259 : 					{
; 5260 : #ifdef AUI_WARNING_FIXES
; 5261 : 						if (pImprovementInfo)
; 5262 : 							GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pImprovementInfo->GetGoldMaintenance());
; 5263 : #else
; 5264 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T247166[ebp], eax
	mov	ecx, DWORD PTR $T247166[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247170[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T247170[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN74@setOwner:

; 5265 : #endif
; 5266 : 					}
; 5267 : 				}
; 5268 : 
; 5269 : 				// Route is here
; 5270 : 				if(getRouteType() != NO_ROUTE && !isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	$LN69@setOwner
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	jne	$LN69@setOwner

; 5271 : 				{
; 5272 : 					// Maintenance change!
; 5273 : 					if(MustPayMaintenanceHere(getOwner()))

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T247179[ebp], ecx
	mov	edx, DWORD PTR $T247179[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN69@setOwner

; 5274 : 					{
; 5275 : #ifdef AUI_WARNING_FIXES
; 5276 : 						CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 5277 : 						if (pRouteInfo)
; 5278 : 							GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pRouteInfo->GetGoldMaintenance());
; 5279 : #else
; 5280 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247183[ebp], edx
	mov	eax, DWORD PTR $T247183[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247187[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T247187[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN69@setOwner:

; 5281 : #endif
; 5282 : 					}
; 5283 : 				}
; 5284 : 
; 5285 : 				// Remove Resource Quantity from total
; 5286 : 				if(getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN67@setOwner

; 5287 : 				{
; 5288 : 					// Disconnect resource link
; 5289 : 					if(GetResourceLinkedCity() != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN215@setOwner

; 5290 : 					{
; 5291 : 						SetResourceLinkedCity(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::SetResourceLinkedCity

; 5292 : 					}
; 5293 : 
; 5294 : 					if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

$LN215@setOwner:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$247201[ebp], edx
	cmp	DWORD PTR _playerID$247201[ebp], -1
	je	SHORT $LN212@setOwner
	mov	eax, DWORD PTR _playerID$247201[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247204[ebp], eax
	jmp	SHORT $LN213@setOwner
	jmp	SHORT $LN213@setOwner
$LN212@setOwner:
	mov	DWORD PTR $T247204[ebp], -1
$LN213@setOwner:
	mov	ecx, DWORD PTR $T247204[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T247208[ebp], ecx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, DWORD PTR $T247208[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	$LN67@setOwner

; 5295 : 					{
; 5296 : 						if(getImprovementType() != NO_IMPROVEMENT && GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN67@setOwner
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN67@setOwner

; 5297 : 						{
; 5298 : 							if(!IsImprovementPillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN67@setOwner

; 5299 : 							{
; 5300 : 								GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), -getNumResourceForPlayer(getOwner()));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T247212[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247216[ebp], edx
	mov	eax, DWORD PTR $T247216[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247220[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T247212[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	neg	eax
	push	eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR $T247220[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal
$LN67@setOwner:

; 5301 : 							}
; 5302 : 						}
; 5303 : 					}
; 5304 : 				}
; 5305 : 			}
; 5306 : 			// Plot is unowned
; 5307 : 			else

	jmp	$LN62@setOwner
$LN85@setOwner:

; 5308 : 			{
; 5309 : 				// Someone paying for this improvement
; 5310 : 				if(GetPlayerResponsibleForImprovement() != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
	cmp	eax, -1
	je	$LN61@setOwner

; 5311 : 				{
; 5312 : 					if(MustPayMaintenanceHere(GetPlayerResponsibleForImprovement()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN60@setOwner

; 5313 : 					{
; 5314 : 						GET_PLAYER(GetPlayerResponsibleForImprovement()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
	mov	DWORD PTR $T247224[ebp], eax
	mov	eax, DWORD PTR $T247224[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247225[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T247225[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN60@setOwner:

; 5315 : 					}
; 5316 : 					SetPlayerResponsibleForImprovement(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForImprovement
$LN61@setOwner:

; 5317 : 				}
; 5318 : 				// Someone paying for this Route
; 5319 : 				if(GetPlayerResponsibleForRoute() != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	cmp	eax, -1
	je	$LN62@setOwner

; 5320 : 				{
; 5321 : 					if(MustPayMaintenanceHere(GetPlayerResponsibleForRoute()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN58@setOwner

; 5322 : 					{
; 5323 : 						GET_PLAYER(GetPlayerResponsibleForRoute()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	mov	DWORD PTR $T247229[ebp], eax
	mov	edx, DWORD PTR $T247229[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247230[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T247230[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN58@setOwner:

; 5324 : 					}
; 5325 : 					SetPlayerResponsibleForRoute(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForRoute
$LN62@setOwner:

; 5326 : 				}
; 5327 : 			}
; 5328 : 
; 5329 : 			// This plot is ABOUT TO BE owned. Pop Goody Huts/remove barb camps, etc. Otherwise it will try to reduce the # of Improvements we have in our borders, and these guys shouldn't apply to that count
; 5330 : 			if(eNewValue != NO_PLAYER)

	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	$LN57@setOwner

; 5331 : 			{
; 5332 : 				// Pop Goody Huts here
; 5333 : 				if(isGoody())

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@setOwner

; 5334 : 				{
; 5335 : 					GET_PLAYER(eNewValue).doGoody(this, NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?doGoody@CvPlayer@@QAEXPAVCvPlot@@PAVCvUnit@@@Z ; CvPlayer::doGoody
$LN56@setOwner:

; 5336 : 				}
; 5337 : 
; 5338 : 				// If there's a camp here, clear it
; 5339 : 				if(getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T247237[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR $T247237[ebp]
	jne	SHORT $LN57@setOwner

; 5340 : 				{
; 5341 : 					setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 5342 : 					CvBarbarians::DoBarbCampCleared(this, eNewValue);

	mov	eax, DWORD PTR _eNewValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?DoBarbCampCleared@CvBarbarians@@SAXPAVCvPlot@@W4PlayerTypes@@@Z ; CvBarbarians::DoBarbCampCleared
	add	esp, 8

; 5343 : 					SetPlayerThatClearedBarbCampHere(eNewValue);

	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatClearedBarbCampHere
$LN57@setOwner:

; 5344 : 
; 5345 : 					// Don't give gold for Camps cleared by settling
; 5346 : 				}
; 5347 : 			}
; 5348 : 
; 5349 : 			pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 5350 : 
; 5351 : 			// ACTUALLY CHANGE OWNERSHIP HERE
; 5352 : 			m_eOwner = eNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [eax+4], cl

; 5353 : 
; 5354 : 			setWorkingCityOverride(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::setWorkingCityOverride

; 5355 : 			updateWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity

; 5356 : 
; 5357 : 			// Post ownership switch
; 5358 : 
; 5359 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	$LN54@setOwner

; 5360 : 			{
; 5361 : 				CvPlayerAI& newPlayer = GET_PLAYER(eNewValue);

	mov	eax, DWORD PTR _eNewValue$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _newPlayer$224262[ebp], eax

; 5362 : 				if(iAcquiringCityID >= 0)

	cmp	DWORD PTR _iAcquiringCityID$[ebp], 0
	jl	SHORT $LN53@setOwner

; 5363 : 				{
; 5364 : 					m_purchaseCity.eOwner = eNewValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eNewValue$[ebp]
	mov	DWORD PTR [ecx+136], edx

; 5365 : 					m_purchaseCity.iID = iAcquiringCityID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iAcquiringCityID$[ebp]
	mov	DWORD PTR [eax+140], ecx

; 5366 : 				}
; 5367 : 				else

	jmp	SHORT $LN52@setOwner
$LN53@setOwner:

; 5368 : 				{
; 5369 : 					m_purchaseCity.eOwner = NO_PLAYER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], -1

; 5370 : 					m_purchaseCity.iID = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], -1
$LN52@setOwner:

; 5371 : 				}
; 5372 : 
; 5373 : 				changeAdjacentSight(getTeam(), GC.getPLOT_VISIBILITY_RANGE(), true, NO_INVISIBLE, NO_DIRECTION, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	DWORD PTR $T247244[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$247258[ebp], eax
	cmp	DWORD PTR _playerID$247258[ebp], -1
	je	SHORT $LN240@setOwner
	mov	ecx, DWORD PTR _playerID$247258[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247261[ebp], eax
	jmp	SHORT $LN241@setOwner
	jmp	SHORT $LN241@setOwner
$LN240@setOwner:
	mov	DWORD PTR $T247261[ebp], -1
$LN241@setOwner:
	push	0
	push	-1
	push	-1
	push	1
	mov	edx, DWORD PTR $T247244[ebp]
	push	edx
	mov	eax, DWORD PTR $T247261[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight

; 5374 : 
; 5375 : 				// if this tile is owned by a minor share the visibility with my ally
; 5376 : 				if(pOldCity)

	cmp	DWORD PTR _pOldCity$[ebp], 0
	je	$LN51@setOwner

; 5377 : 				{
; 5378 : 					for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$224266[ebp], 0
	jmp	SHORT $LN50@setOwner
$LN49@setOwner:
	mov	ecx, DWORD PTR _ui$224266[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$224266[ebp], ecx
$LN50@setOwner:
	cmp	DWORD PTR _ui$224266[ebp], 22		; 00000016H
	jae	$LN51@setOwner

; 5379 : 					{
; 5380 : 						PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	edx, DWORD PTR _ui$224266[ebp]
	mov	DWORD PTR _ePlayer$224270[ebp], edx

; 5381 : 						if(GET_PLAYER(ePlayer).GetEspionage()->HasEstablishedSurveillanceInCity(pOldCity))

	mov	eax, DWORD PTR _ePlayer$224270[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247265[ebp], eax
	mov	ecx, DWORD PTR _pOldCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T247265[ebp]
	call	?GetEspionage@CvPlayer@@QBEPAVCvPlayerEspionage@@XZ ; CvPlayer::GetEspionage
	mov	ecx, eax
	call	?HasEstablishedSurveillanceInCity@CvPlayerEspionage@@QAE_NPAVCvCity@@@Z ; CvPlayerEspionage::HasEstablishedSurveillanceInCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN47@setOwner

; 5382 : 						{
; 5383 : 							changeAdjacentSight(GET_PLAYER(ePlayer).getTeam(), GC.getESPIONAGE_SURVEILLANCE_SIGHT_RANGE(), true, NO_INVISIBLE, NO_DIRECTION, false);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7948
	mov	DWORD PTR $T247269[ebp], eax
	mov	ecx, DWORD PTR _ePlayer$224270[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247273[ebp], ecx
	push	0
	push	-1
	push	-1
	push	1
	mov	edx, DWORD PTR $T247269[ebp]
	push	edx
	mov	eax, DWORD PTR $T247273[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN47@setOwner:

; 5384 : 						}
; 5385 : 					}

	jmp	$LN49@setOwner
$LN51@setOwner:

; 5386 : 				}
; 5387 : 
; 5388 : 				if(eNewValue >= MAX_MAJOR_CIVS && eNewValue != BARBARIAN_PLAYER)

	cmp	DWORD PTR _eNewValue$[ebp], 22		; 00000016H
	jl	$LN46@setOwner
	cmp	DWORD PTR _eNewValue$[ebp], 63		; 0000003fH
	je	$LN46@setOwner

; 5389 : 				{
; 5390 : 					CvPlayer& thisPlayer = GET_PLAYER(eNewValue);

	mov	edx, DWORD PTR _eNewValue$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$224275[ebp], edx

; 5391 : 					CvMinorCivAI* pMinorCivAI = thisPlayer.GetMinorCivAI();

	mov	ecx, DWORD PTR _thisPlayer$224275[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	DWORD PTR _pMinorCivAI$224276[ebp], eax

; 5392 : 					if(pMinorCivAI && pMinorCivAI->GetAlly() != NO_PLAYER)

	cmp	DWORD PTR _pMinorCivAI$224276[ebp], 0
	je	SHORT $LN46@setOwner
	mov	ecx, DWORD PTR _pMinorCivAI$224276[ebp]
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	cmp	eax, -1
	je	SHORT $LN46@setOwner

; 5393 : 					{
; 5394 : 						changeAdjacentSight(GET_PLAYER(pMinorCivAI->GetAlly()).getTeam(), GC.getPLOT_VISIBILITY_RANGE(), true, NO_INVISIBLE, NO_DIRECTION, false);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6196
	mov	DWORD PTR $T247288[ebp], eax
	mov	ecx, DWORD PTR _pMinorCivAI$224276[ebp]
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR $T247292[ebp], eax
	mov	ecx, DWORD PTR $T247292[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247293[ebp], ecx
	push	0
	push	-1
	push	-1
	push	1
	mov	edx, DWORD PTR $T247288[ebp]
	push	edx
	mov	eax, DWORD PTR $T247293[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeAdjacentSight@CvPlot@@QAEXW4TeamTypes@@H_NW4InvisibleTypes@@W4DirectionTypes@@1@Z ; CvPlot::changeAdjacentSight
$LN46@setOwner:

; 5395 : 					}
; 5396 : 				}
; 5397 : 
; 5398 : 				if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN44@setOwner

; 5399 : 				{
; 5400 : 					area()->changeNumOwnedTiles(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumOwnedTiles@CvArea@@QAEXH@Z	; CvArea::changeNumOwnedTiles
$LN44@setOwner:

; 5401 : 				}
; 5402 : 				GC.getMap().changeOwnedPlots(1);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T247305[ebp], edx
	push	1
	mov	ecx, DWORD PTR $T247305[ebp]
	call	?changeOwnedPlots@CvMap@@QAEXH@Z	; CvMap::changeOwnedPlots

; 5403 : 
; 5404 : 				if(!isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN43@setOwner

; 5405 : 				{
; 5406 : 					GET_PLAYER(getOwner()).changeTotalLand(1);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247312[ebp], edx
	push	1
	mov	ecx, DWORD PTR $T247312[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeTotalLand@CvPlayer@@QAEXH@Z	; CvPlayer::changeTotalLand

; 5407 : 					GET_TEAM(getTeam()).changeTotalLand(1);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$247324[ebp], ecx
	cmp	DWORD PTR _playerID$247324[ebp], -1
	je	SHORT $LN276@setOwner
	mov	edx, DWORD PTR _playerID$247324[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247332[ebp], eax
	jmp	SHORT $LN283@setOwner
	jmp	SHORT $LN283@setOwner
$LN276@setOwner:
	mov	DWORD PTR $T247332[ebp], -1
$LN283@setOwner:
	push	1
	mov	ecx, DWORD PTR $T247332[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?changeTotalLand@CvTeam@@QAEXH@Z	; CvTeam::changeTotalLand

; 5408 : 
; 5409 : 					if(isOwnershipScore())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwnershipScore@CvPlot@@QBE_NXZ	; CvPlot::isOwnershipScore
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN43@setOwner

; 5410 : 					{
; 5411 : 						GET_PLAYER(getOwner()).changeTotalLandScored(1);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247339[ebp], edx
	push	1
	mov	ecx, DWORD PTR $T247339[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeTotalLandScored@CvPlayer@@QAEXH@Z ; CvPlayer::changeTotalLandScored
$LN43@setOwner:

; 5412 : 					}
; 5413 : 				}
; 5414 : 
; 5415 : 				// Improvement is here
; 5416 : 				if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN41@setOwner

; 5417 : 				{
; 5418 : 					GET_PLAYER(eNewValue).changeImprovementCount(getImprovementType(), 1);

	mov	eax, DWORD PTR _eNewValue$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247346[ebp], eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, DWORD PTR $T247346[ebp]
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 5419 : 
; 5420 : 					// Add siphoned resources
; 5421 : 					CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(getImprovementType());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovementInfo$224282[ebp], eax

; 5422 : 					if (pImprovementInfo != NULL && pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor() > 0)

	cmp	DWORD PTR _pImprovementInfo$224282[ebp], 0
	je	$LN40@setOwner
	mov	ecx, DWORD PTR _pImprovementInfo$224282[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN40@setOwner

; 5423 : 					{
; 5424 : 						if (GetPlayerThatBuiltImprovement() != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
	cmp	eax, -1
	je	SHORT $LN40@setOwner

; 5425 : 						{
; 5426 : 							if (GET_PLAYER(eNewValue).isMinorCiv())

	mov	ecx, DWORD PTR _eNewValue$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247350[ebp], ecx
	mov	ecx, DWORD PTR $T247350[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN40@setOwner

; 5427 : 							{
; 5428 : 								GET_PLAYER(GetPlayerThatBuiltImprovement()).changeSiphonLuxuryCount(eNewValue, pImprovementInfo->GetLuxuryCopiesSiphonedFromMinor());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
	mov	DWORD PTR $T247354[ebp], eax
	mov	eax, DWORD PTR $T247354[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247355[ebp], eax
	mov	ecx, DWORD PTR _pImprovementInfo$224282[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	push	eax
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T247355[ebp]
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN40@setOwner:

; 5429 : 							}
; 5430 : 						}
; 5431 : 					}
; 5432 : 
; 5433 : 					// Maintenance change!
; 5434 : 					if(MustPayMaintenanceHere(eNewValue))

	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN41@setOwner

; 5435 : 					{
; 5436 : #ifdef AUI_WARNING_FIXES
; 5437 : 						if (pImprovementInfo)
; 5438 : 							GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(pImprovementInfo->GetGoldMaintenance());
; 5439 : #else
; 5440 : 						GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	mov	ecx, DWORD PTR _eNewValue$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247359[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR $T247359[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN41@setOwner:

; 5441 : #endif
; 5442 : 					}
; 5443 : 				}
; 5444 : 
; 5445 : 				// Route is here
; 5446 : 				if(getRouteType() != NO_ROUTE && !isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN36@setOwner
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN36@setOwner

; 5447 : 				{
; 5448 : 					// Maintenance change!
; 5449 : 					if(MustPayMaintenanceHere(eNewValue))

	mov	eax, DWORD PTR _eNewValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN36@setOwner

; 5450 : 					{
; 5451 : #ifdef AUI_WARNING_FIXES
; 5452 : 						CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 5453 : 						if (pRouteInfo)
; 5454 : 							GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(pRouteInfo->GetGoldMaintenance());
; 5455 : #else
; 5456 : 						GET_PLAYER(eNewValue).GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	mov	edx, DWORD PTR _eNewValue$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247368[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR $T247368[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN36@setOwner:

; 5457 : #endif
; 5458 : 					}
; 5459 : 				}
; 5460 : 
; 5461 : 				if(getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN34@setOwner

; 5462 : 				{
; 5463 : 					// Add Resource Quantity to total
; 5464 : 					if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$247377[ebp], ecx
	cmp	DWORD PTR _playerID$247377[ebp], -1
	je	SHORT $LN305@setOwner
	mov	edx, DWORD PTR _playerID$247377[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247385[ebp], eax
	jmp	SHORT $LN306@setOwner
	jmp	SHORT $LN306@setOwner
$LN305@setOwner:
	mov	DWORD PTR $T247385[ebp], -1
$LN306@setOwner:
	mov	eax, DWORD PTR $T247385[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T247389[ebp], eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, DWORD PTR $T247389[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	$LN33@setOwner

; 5465 : 					{
; 5466 : 						if(getImprovementType() != NO_IMPROVEMENT && GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN33@setOwner
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN33@setOwner

; 5467 : 						{
; 5468 : 							if(!IsImprovementPillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN33@setOwner

; 5469 : 							{
; 5470 : 								GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), getNumResourceForPlayer(getOwner()));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247393[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T247397[ebp], ecx
	mov	edx, DWORD PTR $T247397[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247401[ebp], edx
	push	0
	mov	eax, DWORD PTR $T247393[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	push	eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR $T247401[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal
$LN33@setOwner:

; 5471 : 							}
; 5472 : 						}
; 5473 : 					}
; 5474 : 
; 5475 : 					// Should we link the Resource here with a City so special Buildings may be constructed?
; 5476 : 					if(GetResourceLinkedCity() == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	jne	SHORT $LN34@setOwner

; 5477 : 					{
; 5478 : 						DoFindCityToLinkResourceTo();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ; CvPlot::DoFindCityToLinkResourceTo
$LN34@setOwner:

; 5479 : 					}
; 5480 : 				}
; 5481 : 
; 5482 : 				// update the high water mark for player (if human)
; 5483 : 				int iMaxCityHighWaterMark = GC.getMAX_CITY_DIST_HIGHWATER_MARK();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7804
	mov	DWORD PTR _iMaxCityHighWaterMark$224295[ebp], ecx

; 5484 : 				if(newPlayer.isHuman() && newPlayer.GetCityDistanceHighwaterMark() < iMaxCityHighWaterMark)

	mov	ecx, DWORD PTR _newPlayer$224262[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	$LN54@setOwner
	mov	ecx, DWORD PTR _newPlayer$224262[ebp]
	call	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ ; CvPlayer::GetCityDistanceHighwaterMark
	cmp	eax, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	jge	$LN54@setOwner

; 5485 : 				{
; 5486 : 					int bestHighWaterMark = newPlayer.GetCityDistanceHighwaterMark();

	mov	ecx, DWORD PTR _newPlayer$224262[ebp]
	call	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ ; CvPlayer::GetCityDistanceHighwaterMark
	mov	DWORD PTR _bestHighWaterMark$224297[ebp], eax

; 5487 : 					for(int iDX = -iMaxCityHighWaterMark; iDX <= iMaxCityHighWaterMark && bestHighWaterMark < iMaxCityHighWaterMark; iDX++)

	mov	eax, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	neg	eax
	mov	DWORD PTR _iDX$224298[ebp], eax
	jmp	SHORT $LN28@setOwner
$LN27@setOwner:
	mov	ecx, DWORD PTR _iDX$224298[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDX$224298[ebp], ecx
$LN28@setOwner:
	mov	edx, DWORD PTR _iDX$224298[ebp]
	cmp	edx, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	jg	$LN26@setOwner
	mov	eax, DWORD PTR _bestHighWaterMark$224297[ebp]
	cmp	eax, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	jge	$LN26@setOwner

; 5488 : 					{
; 5489 : 						for(int iDY = -iMaxCityHighWaterMark; iDY <= iMaxCityHighWaterMark && bestHighWaterMark < iMaxCityHighWaterMark; iDY++)

	mov	ecx, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	neg	ecx
	mov	DWORD PTR _iDY$224302[ebp], ecx
	jmp	SHORT $LN25@setOwner
$LN24@setOwner:
	mov	edx, DWORD PTR _iDY$224302[ebp]
	add	edx, 1
	mov	DWORD PTR _iDY$224302[ebp], edx
$LN25@setOwner:
	mov	eax, DWORD PTR _iDY$224302[ebp]
	cmp	eax, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	jg	$LN23@setOwner
	mov	ecx, DWORD PTR _bestHighWaterMark$224297[ebp]
	cmp	ecx, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	jge	$LN23@setOwner

; 5490 : 						{
; 5491 : 							int hexRange;
; 5492 : 
; 5493 : 							// I'm assuming iDX and iDY are in hex-space
; 5494 : 							if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	edx, edx
	cmp	DWORD PTR _iDX$224298[ebp], 0
	setge	dl
	xor	eax, eax
	cmp	DWORD PTR _iDY$224302[ebp], 0
	setge	al
	cmp	edx, eax
	jne	SHORT $LN22@setOwner

; 5495 : 							{
; 5496 : 								int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$224298[ebp], 0
	jl	SHORT $LN89@setOwner
	mov	ecx, DWORD PTR _iDX$224298[ebp]
	mov	DWORD PTR tv872[ebp], ecx
	jmp	SHORT $LN90@setOwner
$LN89@setOwner:
	mov	edx, DWORD PTR _iDX$224298[ebp]
	neg	edx
	mov	DWORD PTR tv872[ebp], edx
$LN90@setOwner:
	mov	eax, DWORD PTR tv872[ebp]
	mov	DWORD PTR _iAbsDX$224308[ebp], eax

; 5497 : 								int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$224302[ebp], 0
	jl	SHORT $LN91@setOwner
	mov	ecx, DWORD PTR _iDY$224302[ebp]
	mov	DWORD PTR tv875[ebp], ecx
	jmp	SHORT $LN92@setOwner
$LN91@setOwner:
	mov	edx, DWORD PTR _iDY$224302[ebp]
	neg	edx
	mov	DWORD PTR tv875[ebp], edx
$LN92@setOwner:
	mov	eax, DWORD PTR tv875[ebp]
	mov	DWORD PTR _iAbsDY$224309[ebp], eax

; 5498 : 								hexRange = iAbsDX + iAbsDY;

	mov	ecx, DWORD PTR _iAbsDX$224308[ebp]
	add	ecx, DWORD PTR _iAbsDY$224309[ebp]
	mov	DWORD PTR _hexRange$224306[ebp], ecx

; 5499 : 							}
; 5500 : 							else

	jmp	$LN21@setOwner
$LN22@setOwner:

; 5501 : 							{
; 5502 : 								int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$224298[ebp], 0
	jl	SHORT $LN93@setOwner
	mov	edx, DWORD PTR _iDX$224298[ebp]
	mov	DWORD PTR tv879[ebp], edx
	jmp	SHORT $LN94@setOwner
$LN93@setOwner:
	mov	eax, DWORD PTR _iDX$224298[ebp]
	neg	eax
	mov	DWORD PTR tv879[ebp], eax
$LN94@setOwner:
	mov	ecx, DWORD PTR tv879[ebp]
	mov	DWORD PTR _iAbsDX$224311[ebp], ecx

; 5503 : 								int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$224302[ebp], 0
	jl	SHORT $LN95@setOwner
	mov	edx, DWORD PTR _iDY$224302[ebp]
	mov	DWORD PTR tv882[ebp], edx
	jmp	SHORT $LN96@setOwner
$LN95@setOwner:
	mov	eax, DWORD PTR _iDY$224302[ebp]
	neg	eax
	mov	DWORD PTR tv882[ebp], eax
$LN96@setOwner:
	mov	ecx, DWORD PTR tv882[ebp]
	mov	DWORD PTR _iAbsDY$224312[ebp], ecx

; 5504 : 								hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$224311[ebp]
	cmp	edx, DWORD PTR _iAbsDY$224312[ebp]
	jl	SHORT $LN97@setOwner
	mov	eax, DWORD PTR _iAbsDX$224311[ebp]
	mov	DWORD PTR tv884[ebp], eax
	jmp	SHORT $LN98@setOwner
$LN97@setOwner:
	mov	ecx, DWORD PTR _iAbsDY$224312[ebp]
	mov	DWORD PTR tv884[ebp], ecx
$LN98@setOwner:
	mov	edx, DWORD PTR tv884[ebp]
	mov	DWORD PTR _hexRange$224306[ebp], edx
$LN21@setOwner:

; 5505 : 							}
; 5506 : 
; 5507 : 							if(hexRange > bestHighWaterMark && hexRange <= iMaxCityHighWaterMark)

	mov	eax, DWORD PTR _hexRange$224306[ebp]
	cmp	eax, DWORD PTR _bestHighWaterMark$224297[ebp]
	jle	$LN20@setOwner
	mov	ecx, DWORD PTR _hexRange$224306[ebp]
	cmp	ecx, DWORD PTR _iMaxCityHighWaterMark$224295[ebp]
	jg	$LN20@setOwner

; 5508 : 							{
; 5509 : 								CvPlot* pLoopPlot = plotXY(getX(), getY(), iDX, iDY);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T247408[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T247412[ebp], edx
	mov	eax, DWORD PTR _iDY$224302[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$224298[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247408[ebp]
	push	edx
	mov	eax, DWORD PTR $T247412[ebp]
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pLoopPlot$224314[ebp], eax

; 5510 : 								if(pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$224314[ebp], 0
	je	SHORT $LN20@setOwner

; 5511 : 								{
; 5512 : 									CvCity* thisCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR _pLoopPlot$224314[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _thisCity$224316[ebp], eax

; 5513 : 									if(thisCity)

	cmp	DWORD PTR _thisCity$224316[ebp], 0
	je	SHORT $LN20@setOwner

; 5514 : 									{
; 5515 : 										if(thisCity->getOwner() == eNewValue)

	mov	ecx, DWORD PTR _thisCity$224316[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T247520[ebp], edx
	mov	eax, DWORD PTR $T247520[ebp]
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	jne	SHORT $LN20@setOwner

; 5516 : 										{
; 5517 : 											bestHighWaterMark = hexRange;

	mov	ecx, DWORD PTR _hexRange$224306[ebp]
	mov	DWORD PTR _bestHighWaterMark$224297[ebp], ecx
$LN20@setOwner:

; 5518 : 										}
; 5519 : 									}
; 5520 : 								}
; 5521 : 							}
; 5522 : 						}

	jmp	$LN24@setOwner
$LN23@setOwner:

; 5523 : 					}

	jmp	$LN27@setOwner
$LN26@setOwner:

; 5524 : 					if(bestHighWaterMark > newPlayer.GetCityDistanceHighwaterMark())

	mov	ecx, DWORD PTR _newPlayer$224262[ebp]
	call	?GetCityDistanceHighwaterMark@CvPlayer@@QBEHXZ ; CvPlayer::GetCityDistanceHighwaterMark
	cmp	DWORD PTR _bestHighWaterMark$224297[ebp], eax
	jle	$LN54@setOwner

; 5525 : 					{
; 5526 : 						newPlayer.SetCityDistanceHighwaterMark(bestHighWaterMark);

	mov	edx, DWORD PTR _bestHighWaterMark$224297[ebp]
	push	edx
	mov	ecx, DWORD PTR _newPlayer$224262[ebp]
	call	?SetCityDistanceHighwaterMark@CvPlayer@@QAEXH@Z ; CvPlayer::SetCityDistanceHighwaterMark

; 5527 : 						if(GC.GetEngineUserInterface()->isCityScreenUp())

	mov	eax, DWORD PTR $T247524[ebp]
	mov	DWORD PTR tv955[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv955[ebp], ecx
	mov	edx, DWORD PTR tv955[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv955[ebp]
	mov	edx, DWORD PTR [eax+312]
	call	edx
	movzx	eax, al
	test	eax, eax
	je	$LN54@setOwner

; 5528 : 						{
; 5529 : 							auto_ptr<ICvCity1> pHeadSelectedCity(GC.GetEngineUserInterface()->getHeadSelectedCity());

	mov	ecx, DWORD PTR $T247528[ebp]
	mov	DWORD PTR tv970[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv970[ebp], edx
	mov	eax, DWORD PTR tv970[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv970[ebp]
	mov	eax, DWORD PTR [edx+136]
	call	eax
	mov	DWORD PTR $T247532[ebp], eax
	mov	ecx, DWORD PTR $T247532[ebp]
	mov	DWORD PTR _pHeadSelectedCity$224368[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 5530 : 							if(pHeadSelectedCity.get())

	cmp	DWORD PTR _pHeadSelectedCity$224368[ebp], 0
	je	$LN14@setOwner

; 5531 : 							{
; 5532 : 								CvCity* pkHeadSelectedCity = GC.UnwrapCityPointer(pHeadSelectedCity.get());

	mov	edx, DWORD PTR _pHeadSelectedCity$224368[ebp]
	mov	DWORD PTR $T247539[ebp], edx
	mov	eax, DWORD PTR $T247539[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?UnwrapCityPointer@CvGlobals@@QAEPAVCvCity@@PAVICvCity1@@@Z ; CvGlobals::UnwrapCityPointer
	mov	DWORD PTR _pkHeadSelectedCity$224379[ebp], eax

; 5533 : 								auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(pkHeadSelectedCity->plot());

	mov	ecx, DWORD PTR _pkHeadSelectedCity$224379[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	lea	ecx, DWORD PTR $T246986[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	DWORD PTR $T247550[ebp], eax
	mov	edx, DWORD PTR $T247550[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Cvtptr$247545[ebp], eax
	mov	ecx, DWORD PTR __Cvtptr$247545[ebp]
	mov	DWORD PTR __Ans$247546[ebp], ecx
	mov	edx, DWORD PTR $T247550[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR __Ans$247546[ebp]
	mov	DWORD PTR $T246987[ebp], eax
	mov	ecx, DWORD PTR $T246987[ebp]
	mov	DWORD PTR $T247555[ebp], ecx
	mov	edx, DWORD PTR $T247555[ebp]
	mov	DWORD PTR __Ptr$247554[ebp], edx
	mov	DWORD PTR $T247555[ebp], 0
	mov	eax, DWORD PTR __Ptr$247554[ebp]
	mov	DWORD PTR _pDllPlot$224381[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T246986[ebp]
	mov	DWORD PTR $T247564[ebp], ecx
	cmp	DWORD PTR $T247564[ebp], 0
	je	SHORT $LN393@setOwner
	mov	edx, DWORD PTR $T247564[ebp]
	mov	DWORD PTR _inst$247568[ebp], edx
	mov	eax, DWORD PTR _inst$247568[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$247568[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN393@setOwner:

; 5534 : 								GC.GetEngineUserInterface()->lookAt(pDllPlot.get(), CAMERALOOKAT_CITY_ZOOM_IN);

	mov	ecx, DWORD PTR $T247573[ebp]
	mov	DWORD PTR tv1006[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1006[ebp], edx
	push	1
	mov	eax, DWORD PTR _pDllPlot$224381[ebp]
	push	eax
	mov	ecx, DWORD PTR tv1006[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1006[ebp]
	mov	eax, DWORD PTR [edx+272]
	call	eax

; 5535 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _pDllPlot$224381[ebp]
	mov	DWORD PTR $T247585[ebp], ecx
	cmp	DWORD PTR $T247585[ebp], 0
	je	SHORT $LN14@setOwner
	mov	edx, DWORD PTR $T247585[ebp]
	mov	DWORD PTR _inst$247589[ebp], edx
	mov	eax, DWORD PTR _inst$247589[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$247589[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN14@setOwner:

; 5536 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _pHeadSelectedCity$224368[ebp]
	mov	DWORD PTR $T247600[ebp], ecx
	cmp	DWORD PTR $T247600[ebp], 0
	je	SHORT $LN54@setOwner
	mov	edx, DWORD PTR $T247600[ebp]
	mov	DWORD PTR _inst$247604[ebp], edx
	mov	eax, DWORD PTR _inst$247604[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$247604[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN54@setOwner:

; 5537 : 					}
; 5538 : 				}
; 5539 : 			}
; 5540 : 
; 5541 : 			pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 5542 : 
; 5543 : 			for(iI = 0; iI < MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@setOwner
$LN12@setOwner:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN13@setOwner:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN11@setOwner

; 5544 : 			{
; 5545 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 5546 : 				if (iI == OBSERVER_TEAM || GET_TEAM((TeamTypes)iI).isAlive())
; 5547 : #else
; 5548 : 				if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T247608[ebp], edx
	mov	eax, DWORD PTR $T247608[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN10@setOwner

; 5549 : #endif
; 5550 : 				{
; 5551 : 					updateRevealedOwner((TeamTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ; CvPlot::updateRevealedOwner
$LN10@setOwner:

; 5552 : 				}
; 5553 : 			}

	jmp	SHORT $LN12@setOwner
$LN11@setOwner:

; 5554 : 
; 5555 : 			updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 5556 : 
; 5557 : 			// Update happiness if there's a luxury or natural wonder here
; 5558 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@setOwner

; 5559 : 			{
; 5560 : 				bool bShouldUpdateHappiness = false;

	mov	BYTE PTR _bShouldUpdateHappiness$224399[ebp], 0

; 5561 : 
; 5562 : 				if(getFeatureType() != NO_FEATURE)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$247617[ebp], al
	movsx	ecx, BYTE PTR _f$247617[ebp]
	cmp	ecx, -1
	je	SHORT $LN8@setOwner

; 5563 : 				{
; 5564 : 					if(GC.getFeatureInfo(getFeatureType())->IsNaturalWonder())

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$247626[ebp], al
	movsx	ecx, BYTE PTR _f$247626[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@setOwner

; 5565 : 					{
; 5566 : 						bShouldUpdateHappiness = true;

	mov	BYTE PTR _bShouldUpdateHappiness$224399[ebp], 1
$LN8@setOwner:

; 5567 : 					}
; 5568 : 				}
; 5569 : 
; 5570 : 				if(!bShouldUpdateHappiness && getResourceType(getTeam()) != NO_RESOURCE)

	movzx	eax, BYTE PTR _bShouldUpdateHappiness$224399[ebp]
	test	eax, eax
	jne	$LN6@setOwner
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$247638[ebp], edx
	cmp	DWORD PTR _playerID$247638[ebp], -1
	je	SHORT $LN425@setOwner
	mov	eax, DWORD PTR _playerID$247638[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247646[ebp], eax
	jmp	SHORT $LN426@setOwner
	jmp	SHORT $LN426@setOwner
$LN425@setOwner:
	mov	DWORD PTR $T247646[ebp], -1
$LN426@setOwner:
	mov	ecx, DWORD PTR $T247646[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN6@setOwner

; 5571 : 				{
; 5572 : 					if(GC.getResourceInfo(getResourceType(getTeam()))->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$247655[ebp], eax
	cmp	DWORD PTR _playerID$247655[ebp], -1
	je	SHORT $LN433@setOwner
	mov	ecx, DWORD PTR _playerID$247655[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T247663[ebp], eax
	jmp	SHORT $LN434@setOwner
	jmp	SHORT $LN434@setOwner
$LN433@setOwner:
	mov	DWORD PTR $T247663[ebp], -1
$LN434@setOwner:
	mov	edx, DWORD PTR $T247663[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN6@setOwner

; 5573 : 					{
; 5574 : 						if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN6@setOwner

; 5575 : 						{
; 5576 : 							bShouldUpdateHappiness = true;

	mov	BYTE PTR _bShouldUpdateHappiness$224399[ebp], 1
$LN6@setOwner:

; 5577 : 						}
; 5578 : 					}
; 5579 : 				}
; 5580 : 
; 5581 : 				if(bShouldUpdateHappiness)

	movzx	eax, BYTE PTR _bShouldUpdateHappiness$224399[ebp]
	test	eax, eax
	je	SHORT $LN9@setOwner

; 5582 : 				{
; 5583 : 					GET_PLAYER(getOwner()).DoUpdateHappiness();

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T247667[ebp], edx
	mov	ecx, DWORD PTR $T247667[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN9@setOwner:

; 5584 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 5585 : 					GET_PLAYER(getOwner()).doSelfConsistencyCheckAllCities();
; 5586 : #endif
; 5587 : 				}
; 5588 : 			}
; 5589 : 
; 5590 : 			if(bCheckUnits)

	movzx	eax, BYTE PTR _bCheckUnits$[ebp]
	test	eax, eax
	je	SHORT $LN2@setOwner

; 5591 : 			{
; 5592 : 				verifyUnitValidPlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?verifyUnitValidPlot@CvPlot@@QAEXXZ	; CvPlot::verifyUnitValidPlot
$LN2@setOwner:

; 5593 : 			}
; 5594 : 
; 5595 : 			if(GC.getGame().isDebugMode())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T247674[ebp], ecx
	mov	ecx, DWORD PTR $T247674[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	$LN1@setOwner

; 5596 : 			{
; 5597 : 				auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246988[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	DWORD PTR $T247685[ebp], eax
	mov	edx, DWORD PTR $T247685[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Cvtptr$247680[ebp], eax
	mov	ecx, DWORD PTR __Cvtptr$247680[ebp]
	mov	DWORD PTR __Ans$247681[ebp], ecx
	mov	edx, DWORD PTR $T247685[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR __Ans$247681[ebp]
	mov	DWORD PTR $T246989[ebp], eax
	mov	ecx, DWORD PTR $T246989[ebp]
	mov	DWORD PTR $T247690[ebp], ecx
	mov	edx, DWORD PTR $T247690[ebp]
	mov	DWORD PTR __Ptr$247689[ebp], edx
	mov	DWORD PTR $T247690[ebp], 0
	mov	eax, DWORD PTR __Ptr$247689[ebp]
	mov	DWORD PTR _pDllPlot$224409[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T246988[ebp]
	mov	DWORD PTR $T247699[ebp], ecx
	cmp	DWORD PTR $T247699[ebp], 0
	je	SHORT $LN452@setOwner
	mov	edx, DWORD PTR $T247699[ebp]
	mov	DWORD PTR _inst$247702[ebp], edx
	mov	eax, DWORD PTR _inst$247702[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$247702[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN452@setOwner:

; 5598 : 				GC.GetEngineUserInterface()->UpdateCountryBorder(pDllPlot.get());

	mov	ecx, DWORD PTR $T247708[ebp]
	mov	DWORD PTR tv1104[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1104[ebp], edx
	mov	eax, DWORD PTR _pDllPlot$224409[ebp]
	push	eax
	mov	ecx, DWORD PTR tv1104[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1104[ebp]
	mov	eax, DWORD PTR [edx+424]
	call	eax

; 5599 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _pDllPlot$224409[ebp]
	mov	DWORD PTR $T247720[ebp], ecx
	cmp	DWORD PTR $T247720[ebp], 0
	je	SHORT $LN1@setOwner
	mov	edx, DWORD PTR $T247720[ebp]
	mov	DWORD PTR _inst$247723[ebp], edx
	mov	eax, DWORD PTR _inst$247723[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$247723[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@setOwner:

; 5600 : 		}
; 5601 : 
; 5602 : 		auto_ptr<ICvPlot1> pDllPlot = GC.WrapPlotPointer(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T246990[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?WrapPlotPointer@CvGlobals@@QAE?AV?$auto_ptr@VICvPlot1@@@std@@PAVCvPlot@@@Z ; CvGlobals::WrapPlotPointer
	mov	DWORD PTR $T247736[ebp], eax
	mov	eax, DWORD PTR $T247736[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Cvtptr$247731[ebp], ecx
	mov	edx, DWORD PTR __Cvtptr$247731[ebp]
	mov	DWORD PTR __Ans$247732[ebp], edx
	mov	eax, DWORD PTR $T247736[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR __Ans$247732[ebp]
	mov	DWORD PTR $T246991[ebp], ecx
	mov	edx, DWORD PTR $T246991[ebp]
	mov	DWORD PTR $T247741[ebp], edx
	mov	eax, DWORD PTR $T247741[ebp]
	mov	DWORD PTR __Ptr$247740[ebp], eax
	mov	DWORD PTR $T247741[ebp], 0
	mov	ecx, DWORD PTR __Ptr$247740[ebp]
	mov	DWORD PTR _pDllPlot$224413[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR $T246990[ebp]
	mov	DWORD PTR $T247750[ebp], edx
	cmp	DWORD PTR $T247750[ebp], 0
	je	SHORT $LN472@setOwner
	mov	eax, DWORD PTR $T247750[ebp]
	mov	DWORD PTR _inst$247753[ebp], eax
	mov	ecx, DWORD PTR _inst$247753[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _inst$247753[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+4]
	call	ecx
$LN472@setOwner:

; 5603 : 		GC.GetEngineUserInterface()->UpdateCountryBorder(pDllPlot.get());

	mov	edx, DWORD PTR $T247759[ebp]
	mov	DWORD PTR tv1130[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1130[ebp], eax
	mov	ecx, DWORD PTR _pDllPlot$224413[ebp]
	push	ecx
	mov	edx, DWORD PTR tv1130[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1130[ebp]
	mov	edx, DWORD PTR [eax+424]
	call	edx

; 5604 : 		GC.GetEngineUserInterface()->setDirty(NationalBorders_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T247766[ebp]
	mov	DWORD PTR tv1143[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv1143[ebp], ecx
	push	1
	push	31					; 0000001fH
	mov	edx, DWORD PTR tv1143[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1143[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx

; 5605 : 		updateSymbols();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 5606 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _pDllPlot$224413[ebp]
	mov	DWORD PTR $T247775[ebp], eax
	cmp	DWORD PTR $T247775[ebp], 0
	je	SHORT $LN86@setOwner
	mov	ecx, DWORD PTR $T247775[ebp]
	mov	DWORD PTR _inst$247778[ebp], ecx
	mov	edx, DWORD PTR _inst$247778[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$247778[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN86@setOwner:

; 5607 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$1:
	lea	ecx, DWORD PTR $T246975[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$2:
	lea	ecx, DWORD PTR _pHeadSelectedCity$224368[ebp]
	jmp	??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ	; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$4:
	lea	ecx, DWORD PTR _pDllPlot$224381[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$6:
	lea	ecx, DWORD PTR _pDllPlot$224409[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z$8:
	lea	ecx, DWORD PTR _pDllPlot$224413[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-784]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z ENDP	; CvPlot::setOwner
PUBLIC	?ClearCityPurchaseInfo@CvPlot@@QAEXXZ		; CvPlot::ClearCityPurchaseInfo
; Function compile flags: /Odtp
;	COMDAT ?ClearCityPurchaseInfo@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearCityPurchaseInfo@CvPlot@@QAEXXZ PROC		; CvPlot::ClearCityPurchaseInfo, COMDAT
; _this$ = ecx

; 5611 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5612 : 	m_purchaseCity.eOwner = NO_PLAYER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+136], -1

; 5613 : 	m_purchaseCity.iID = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], -1

; 5614 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearCityPurchaseInfo@CvPlot@@QAEXXZ ENDP		; CvPlot::ClearCityPurchaseInfo
_TEXT	ENDS
PUBLIC	?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ ; CvPlot::GetCityPurchaseOwner
; Function compile flags: /Odtp
;	COMDAT ?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetCityPurchaseOwner, COMDAT
; _this$ = ecx

; 5622 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5623 : 	return m_purchaseCity.eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+136]

; 5624 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityPurchaseOwner@CvPlot@@QAE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetCityPurchaseOwner
_TEXT	ENDS
PUBLIC	?GetCityPurchaseID@CvPlot@@QAEHXZ		; CvPlot::GetCityPurchaseID
; Function compile flags: /Odtp
;	COMDAT ?GetCityPurchaseID@CvPlot@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityPurchaseID@CvPlot@@QAEHXZ PROC			; CvPlot::GetCityPurchaseID, COMDAT
; _this$ = ecx

; 5632 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5633 : 	return m_purchaseCity.iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+140]

; 5634 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityPurchaseID@CvPlot@@QAEHXZ ENDP			; CvPlot::GetCityPurchaseID
_TEXT	ENDS
PUBLIC	?SetCityPurchaseID@CvPlot@@QAEXH@Z		; CvPlot::SetCityPurchaseID
; Function compile flags: /Odtp
;	COMDAT ?SetCityPurchaseID@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iAcquiringCityID$ = 8					; size = 4
?SetCityPurchaseID@CvPlot@@QAEXH@Z PROC			; CvPlot::SetCityPurchaseID, COMDAT
; _this$ = ecx

; 5638 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5639 : 	m_purchaseCity.iID = iAcquiringCityID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iAcquiringCityID$[ebp]
	mov	DWORD PTR [eax+140], ecx

; 5640 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCityPurchaseID@CvPlot@@QAEXH@Z ENDP			; CvPlot::SetCityPurchaseID
_TEXT	ENDS
PUBLIC	?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsHomeFrontForPlayer
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Odtp
;	COMDAT ?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T247840 = -36						; size = 4
$T247836 = -32						; size = 4
$T247832 = -28						; size = 4
$T247823 = -24						; size = 4
$T247814 = -20						; size = 4
$T247810 = -16						; size = 4
_iCityLoop$ = -12					; size = 4
_iRange$ = -8						; size = 4
_pLoopCity$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC ; CvPlot::IsHomeFrontForPlayer, COMDAT
; _this$ = ecx

; 5646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 5647 : 	// Owned?
; 5648 : 	if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@IsHomeFron

; 5649 : 	{
; 5650 : 		if(getOwner() == ePlayer)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, DWORD PTR _ePlayer$[ebp]
	jne	SHORT $LN6@IsHomeFron

; 5651 : 		{
; 5652 : 			return true;

	mov	al, 1
	jmp	$LN7@IsHomeFron
$LN6@IsHomeFron:

; 5653 : 		}
; 5654 : 	}
; 5655 : 
; 5656 : 	CvCity* pLoopCity;
; 5657 : 	int iCityLoop;
; 5658 : 
; 5659 : 	int iRange = GC.getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2704
	mov	DWORD PTR _iRange$[ebp], eax

; 5660 : 
; 5661 : 	// Not owned by this player, so we have to check things the hard way, and see how close the Plot is to any of this Player's Cities
; 5662 : 	for(pLoopCity = GET_PLAYER(ePlayer).firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(ePlayer).nextCity(&iCityLoop))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247810[ebp], ecx
	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T247810[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN4@IsHomeFron
$LN3@IsHomeFron:
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T247814[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T247814[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN4@IsHomeFron:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN2@IsHomeFron

; 5663 : 	{
; 5664 : 		if(::plotDistance(getX(), getY(), pLoopCity->getX(), pLoopCity->getY()) < iRange)

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T247823[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T247832[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T247836[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T247840[ebp], eax
	mov	ecx, DWORD PTR $T247823[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247832[ebp]
	push	edx
	mov	eax, DWORD PTR $T247836[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247840[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iRange$[ebp]
	jge	SHORT $LN1@IsHomeFron

; 5665 : 		{
; 5666 : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@IsHomeFron
$LN1@IsHomeFron:

; 5667 : 		}
; 5668 : 	}

	jmp	SHORT $LN3@IsHomeFron
$LN2@IsHomeFron:

; 5669 : 
; 5670 : 	return false;

	xor	al, al
$LN7@IsHomeFron:

; 5671 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsHomeFrontForPlayer@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP ; CvPlot::IsHomeFrontForPlayer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isFlatlands@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isFlatlands@CvPlot@@QBE_NXZ PROC			; CvPlot::isFlatlands, COMDAT
; _this$ = ecx

; 5675 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5676 : 	return (getPlotType() == PLOT_LAND);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	eax, eax
	cmp	ecx, 2
	sete	al

; 5677 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isFlatlands@CvPlot@@QBE_NXZ ENDP			; CvPlot::isFlatlands
_TEXT	ENDS
PUBLIC	?IsRoughFeature@CvPlot@@QBE_NXZ			; CvPlot::IsRoughFeature
; Function compile flags: /Odtp
;	COMDAT ?IsRoughFeature@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRoughFeature@CvPlot@@QBE_NXZ PROC			; CvPlot::IsRoughFeature, COMDAT
; _this$ = ecx

; 5681 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5682 : 	return m_bRoughFeature;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	shr	al, 3
	and	al, 1

; 5683 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRoughFeature@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsRoughFeature
_TEXT	ENDS
PUBLIC	?SetRoughFeature@CvPlot@@QAEX_N@Z		; CvPlot::SetRoughFeature
; Function compile flags: /Odtp
;	COMDAT ?SetRoughFeature@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetRoughFeature@CvPlot@@QAEX_N@Z PROC			; CvPlot::SetRoughFeature, COMDAT
; _this$ = ecx

; 5687 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 5688 : 	if(IsRoughFeature() != bValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoughFeature@CvPlot@@QBE_NXZ		; CvPlot::IsRoughFeature
	movzx	eax, al
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN2@SetRoughFe

; 5689 : 	{
; 5690 : 		m_bRoughFeature = bValue;

	mov	dl, BYTE PTR _bValue$[ebp]
	and	dl, 1
	shl	dl, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	and	cl, 247					; 000000f7H
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+462], cl
$LN2@SetRoughFe:

; 5691 : 	}
; 5692 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRoughFeature@CvPlot@@QAEX_N@Z ENDP			; CvPlot::SetRoughFeature
_TEXT	ENDS
PUBLIC	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
PUBLIC	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z	; CvPlot::setPlotType
EXTRN	?init@CvArea@@QAEXH_N@Z:PROC			; CvArea::init
EXTRN	?addArea@CvMap@@QAEPAVCvArea@@XZ:PROC		; CvMap::addArea
EXTRN	?deleteArea@CvMap@@QAEXH@Z:PROC			; CvMap::deleteArea
EXTRN	?recalculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::recalculateAreas
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z:PROC ; CvMap::changeNumResourcesOnLand
EXTRN	?changeLandPlots@CvMap@@QAEXH@Z:PROC		; CvMap::changeLandPlots
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?isWater@CvTerrainInfo@@QBE_NXZ:PROC		; CvTerrainInfo::isWater
; Function compile flags: /Odtp
;	COMDAT ?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z
_TEXT	SEGMENT
_this$ = -644						; size = 4
$T249087 = -640						; size = 4
$T249083 = -636						; size = 4
$T249079 = -629						; size = 1
$T249075 = -628						; size = 4
$T249071 = -624						; size = 4
$T249067 = -620						; size = 4
$T249063 = -616						; size = 4
$T248879 = -532						; size = 4
$T248875 = -528						; size = 4
$T248691 = -444						; size = 4
$T248687 = -440						; size = 4
$T248530 = -364						; size = 4
$T248526 = -360						; size = 4
$T248369 = -284						; size = 4
$T248365 = -280						; size = 4
$T248355 = -276						; size = 4
_playerID$248347 = -272					; size = 4
$T248338 = -265						; size = 1
$T248331 = -264						; size = 4
$T248327 = -257						; size = 1
$T248323 = -256						; size = 4
$T248319 = -249						; size = 1
$T248315 = -248						; size = 4
$T248311 = -241						; size = 1
$T248307 = -240						; size = 4
$T248303 = -236						; size = 4
$T248159 = -160						; size = 4
$T248155 = -156						; size = 4
$T248151 = -152						; size = 4
$T248147 = -148						; size = 4
$T247986 = -64						; size = 4
$T247982 = -60						; size = 4
$T247975 = -56						; size = 4
$T247971 = -52						; size = 4
$T247967 = -48						; size = 4
$T247963 = -44						; size = 4
$T247956 = -37						; size = 1
$T247952 = -36						; size = 4
_iAreaCount$ = -32					; size = 4
_pCurrArea$ = -28					; size = 4
_pLastArea$ = -24					; size = 4
_bRecalculateAreas$ = -17				; size = 1
_iI$ = -16						; size = 4
_pNewArea$ = -12					; size = 4
_pLoopPlot$ = -8					; size = 4
_bWasWater$ = -1					; size = 1
_eNewValue$ = 8						; size = 4
_bRecalculate$ = 12					; size = 1
_bRebuildGraphics$ = 16					; size = 1
_bEraseUnitsIfWater$ = 20				; size = 1
?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z PROC	; CvPlot::setPlotType, COMDAT
; _this$ = ecx

; 5696 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 644				; 00000284H
	mov	DWORD PTR _this$[ebp], ecx

; 5697 : 	CvArea* pNewArea;
; 5698 : 	CvArea* pCurrArea;
; 5699 : 	CvArea* pLastArea;
; 5700 : 	CvPlot* pLoopPlot;
; 5701 : 	bool bWasWater;
; 5702 : 	bool bRecalculateAreas;
; 5703 : 	int iAreaCount;
; 5704 : 	int iI;
; 5705 : 
; 5706 : 	if(getPlotType() != eNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	cmp	ecx, DWORD PTR _eNewValue$[ebp]
	je	$LN63@setPlotTyp

; 5707 : 	{
; 5708 : 		if((getPlotType() == PLOT_OCEAN) || (eNewValue == PLOT_OCEAN))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	cmp	eax, 3
	je	SHORT $LN60@setPlotTyp
	cmp	DWORD PTR _eNewValue$[ebp], 3
	jne	SHORT $LN69@setPlotTyp
$LN60@setPlotTyp:

; 5709 : 		{
; 5710 : 			erase(bEraseUnitsIfWater);

	movzx	ecx, BYTE PTR _bEraseUnitsIfWater$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@CvPlot@@QAEX_N@Z			; CvPlot::erase

; 5711 : 		}
; 5712 : 
; 5713 : 		bWasWater = isWater();

$LN69@setPlotTyp:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR _bWasWater$[ebp], cl

; 5714 : 
; 5715 : 		updateSeeFromSight(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight

; 5716 : 
; 5717 : 		m_ePlotType = eNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [edx+5], al

; 5718 : 
; 5719 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 5720 : 
; 5721 : 		updateSeeFromSight(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight

; 5722 : 
; 5723 : 		if((getTerrainType() == NO_TERRAIN) || (GC.getTerrainInfo(getTerrainType())->isWater() != isWater()))

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	cmp	edx, -1
	je	SHORT $LN77@setPlotTyp
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR $T247952[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR $T247956[ebp], cl
	mov	edx, DWORD PTR $T247952[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?isWater@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isWater
	movzx	eax, al
	movzx	ecx, BYTE PTR $T247956[ebp]
	cmp	eax, ecx
	je	$LN59@setPlotTyp

; 5724 : 		{
; 5725 : 			if(isWater())

$LN77@setPlotTyp:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN57@setPlotTyp

; 5726 : 			{
; 5727 : 				if(isAdjacentToLand())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN56@setPlotTyp

; 5728 : 				{
; 5729 : 					setTerrainType(((TerrainTypes)(GC.getSHALLOW_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR $T247963[ebp], ecx
	movzx	edx, BYTE PTR _bRebuildGraphics$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bRecalculate$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247963[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5730 : 					m_bIsAdjacentToLand = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+462], al

; 5731 : 				}
; 5732 : 				else

	jmp	SHORT $LN55@setPlotTyp
$LN56@setPlotTyp:

; 5733 : 				{
; 5734 : 					setTerrainType(((TerrainTypes)(GC.getDEEP_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8392
	mov	DWORD PTR $T247967[ebp], edx
	movzx	eax, BYTE PTR _bRebuildGraphics$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bRecalculate$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T247967[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5735 : 					m_bIsAdjacentToLand = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+462], cl
$LN55@setPlotTyp:

; 5736 : 				}
; 5737 : 			}
; 5738 : 			else

	jmp	SHORT $LN59@setPlotTyp
$LN57@setPlotTyp:

; 5739 : 			{
; 5740 : 				setTerrainType(((TerrainTypes)(GC.getLAND_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8388
	mov	DWORD PTR $T247971[ebp], eax
	movzx	ecx, BYTE PTR _bRebuildGraphics$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bRecalculate$[ebp]
	push	edx
	mov	eax, DWORD PTR $T247971[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN59@setPlotTyp:

; 5741 : 			}
; 5742 : 		}
; 5743 : 
; 5744 : 		GC.getStepFinder().ForceReset();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR $T247975[ebp], eax
	mov	ecx, DWORD PTR $T247975[ebp]
	mov	BYTE PTR [ecx+78], 1

; 5745 : 
; 5746 : 		if(bWasWater != isWater())

	movzx	edx, BYTE PTR _bWasWater$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	eax, eax
	cmp	ecx, 3
	sete	al
	movzx	ecx, al
	cmp	edx, ecx
	je	$LN53@setPlotTyp

; 5747 : 		{
; 5748 : 			if(bRecalculate)

	movzx	edx, BYTE PTR _bRecalculate$[ebp]
	test	edx, edx
	je	$LN52@setPlotTyp

; 5749 : 			{
; 5750 : 				for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN51@setPlotTyp
$LN50@setPlotTyp:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN51@setPlotTyp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN52@setPlotTyp

; 5751 : 				{
; 5752 : 					pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T247982[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T247986[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T247982[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247986[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5753 : 
; 5754 : 					if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	$LN48@setPlotTyp

; 5755 : 					{
; 5756 : 						if(pLoopPlot->isWater())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN48@setPlotTyp

; 5757 : 						{
; 5758 : 							if(pLoopPlot->isAdjacentToLand())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN46@setPlotTyp

; 5759 : 							{
; 5760 : 								pLoopPlot->setTerrainType(((TerrainTypes)(GC.getSHALLOW_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8396
	mov	DWORD PTR $T248147[ebp], ecx
	movzx	edx, BYTE PTR _bRebuildGraphics$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bRecalculate$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248147[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5761 : 								m_bIsAdjacentToLand = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	or	al, 64					; 00000040H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+462], al

; 5762 : 							}
; 5763 : 							else

	jmp	SHORT $LN48@setPlotTyp
$LN46@setPlotTyp:

; 5764 : 							{
; 5765 : 								pLoopPlot->setTerrainType(((TerrainTypes)(GC.getDEEP_WATER_TERRAIN())), bRecalculate, bRebuildGraphics);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8392
	mov	DWORD PTR $T248151[ebp], edx
	movzx	eax, BYTE PTR _bRebuildGraphics$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bRecalculate$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248151[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 5766 : 								m_bIsAdjacentToLand = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	and	cl, 191					; 000000bfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+462], cl
$LN48@setPlotTyp:

; 5767 : 							}
; 5768 : 						}
; 5769 : 					}
; 5770 : 				}

	jmp	$LN50@setPlotTyp
$LN52@setPlotTyp:

; 5771 : 			}
; 5772 : 
; 5773 : 			for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN44@setPlotTyp
$LN43@setPlotTyp:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN44@setPlotTyp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN42@setPlotTyp

; 5774 : 			{
; 5775 : 				pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T248155[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T248159[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T248155[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248159[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5776 : 
; 5777 : 				if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN41@setPlotTyp

; 5778 : 				{
; 5779 : 					pLoopPlot->updateYield();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN41@setPlotTyp:

; 5780 : 				}
; 5781 : 			}

	jmp	SHORT $LN43@setPlotTyp
$LN42@setPlotTyp:

; 5782 : 
; 5783 : 			for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN40@setPlotTyp
$LN39@setPlotTyp:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN40@setPlotTyp:
	cmp	DWORD PTR _iI$[ebp], 37			; 00000025H
	jge	SHORT $LN38@setPlotTyp

; 5784 : 			{
; 5785 : 				pLoopPlot = plotCity(getX(), getY(), iI);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T248303[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T248307[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248303[ebp]
	push	edx
	mov	eax, DWORD PTR $T248307[ebp]
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5786 : 
; 5787 : 				if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN37@setPlotTyp

; 5788 : 				{
; 5789 : 					pLoopPlot->updatePotentialCityWork();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?updatePotentialCityWork@CvPlot@@QAEXXZ	; CvPlot::updatePotentialCityWork
$LN37@setPlotTyp:

; 5790 : 				}
; 5791 : 			}

	jmp	SHORT $LN39@setPlotTyp
$LN38@setPlotTyp:

; 5792 : 
; 5793 : 			GC.getMap().changeLandPlots((isWater()) ? -1 : 1);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	mov	BYTE PTR $T248311[ebp], al
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T248315[ebp], ecx
	movzx	edx, BYTE PTR $T248311[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, -2					; fffffffeH
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR $T248315[ebp]
	call	?changeLandPlots@CvMap@@QAEXH@Z		; CvMap::changeLandPlots

; 5794 : 
; 5795 : 			if(getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN36@setPlotTyp

; 5796 : 			{
; 5797 : 				GC.getMap().changeNumResourcesOnLand(getResourceType(), ((isWater()) ? -1 : 1));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	mov	BYTE PTR $T248319[ebp], dl
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T248323[ebp], eax
	movzx	ecx, BYTE PTR $T248319[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 1
	push	ecx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR $T248323[ebp]
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN36@setPlotTyp:

; 5798 : 			}
; 5799 : 
; 5800 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	$LN35@setPlotTyp

; 5801 : 			{
; 5802 : 				GET_PLAYER(getOwner()).changeTotalLand((isWater()) ? -1 : 1);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	mov	BYTE PTR $T248327[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T248331[ebp], ecx
	movzx	edx, BYTE PTR $T248327[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, -2					; fffffffeH
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR $T248331[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?changeTotalLand@CvPlayer@@QAEXH@Z	; CvPlayer::changeTotalLand

; 5803 : 				GET_TEAM(getTeam()).changeTotalLand((isWater()) ? -1 : 1);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	mov	BYTE PTR $T248338[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$248347[ebp], ecx
	cmp	DWORD PTR _playerID$248347[ebp], -1
	je	SHORT $LN250@setPlotTyp
	mov	edx, DWORD PTR _playerID$248347[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T248355[ebp], eax
	jmp	SHORT $LN257@setPlotTyp
	jmp	SHORT $LN257@setPlotTyp
$LN250@setPlotTyp:
	mov	DWORD PTR $T248355[ebp], -1
$LN257@setPlotTyp:
	movzx	eax, BYTE PTR $T248338[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR $T248355[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?changeTotalLand@CvTeam@@QAEXH@Z	; CvTeam::changeTotalLand
$LN35@setPlotTyp:

; 5804 : 			}
; 5805 : 
; 5806 : 			if(bRecalculate)

	movzx	ecx, BYTE PTR _bRecalculate$[ebp]
	test	ecx, ecx
	je	$LN53@setPlotTyp

; 5807 : 			{
; 5808 : 				pNewArea = NULL;

	mov	DWORD PTR _pNewArea$[ebp], 0

; 5809 : 				bRecalculateAreas = false;

	mov	BYTE PTR _bRecalculateAreas$[ebp], 0

; 5810 : 
; 5811 : 				if(isWater())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN33@setPlotTyp

; 5812 : 				{
; 5813 : 					for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN32@setPlotTyp
$LN31@setPlotTyp:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN32@setPlotTyp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN30@setPlotTyp

; 5814 : 					{
; 5815 : 						pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T248365[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T248369[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T248365[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248369[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5816 : 
; 5817 : 						if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN29@setPlotTyp

; 5818 : 						{
; 5819 : 							if(pLoopPlot->area()->isWater())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@setPlotTyp

; 5820 : 							{
; 5821 : 								if(pNewArea == NULL)

	cmp	DWORD PTR _pNewArea$[ebp], 0
	jne	SHORT $LN27@setPlotTyp

; 5822 : 								{
; 5823 : 									pNewArea = pLoopPlot->area();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pNewArea$[ebp], eax
	jmp	SHORT $LN29@setPlotTyp
$LN27@setPlotTyp:

; 5824 : 								}
; 5825 : 								else if(pNewArea != pLoopPlot->area())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	DWORD PTR _pNewArea$[ebp], eax
	je	SHORT $LN29@setPlotTyp

; 5826 : 								{
; 5827 : 									bRecalculateAreas = true;

	mov	BYTE PTR _bRecalculateAreas$[ebp], 1

; 5828 : 									break;

	jmp	SHORT $LN30@setPlotTyp
$LN29@setPlotTyp:

; 5829 : 								}
; 5830 : 							}
; 5831 : 						}
; 5832 : 					}

	jmp	$LN31@setPlotTyp
$LN30@setPlotTyp:

; 5833 : 				}
; 5834 : 				else

	jmp	$LN24@setPlotTyp
$LN33@setPlotTyp:

; 5835 : 				{
; 5836 : 					for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN23@setPlotTyp
$LN22@setPlotTyp:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN23@setPlotTyp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN24@setPlotTyp

; 5837 : 					{
; 5838 : 						pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T248526[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T248530[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T248526[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248530[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5839 : 
; 5840 : 						if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN20@setPlotTyp

; 5841 : 						{
; 5842 : 							if(!(pLoopPlot->area()->isWater()))

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@setPlotTyp

; 5843 : 							{
; 5844 : 								if(pNewArea == NULL)

	cmp	DWORD PTR _pNewArea$[ebp], 0
	jne	SHORT $LN18@setPlotTyp

; 5845 : 								{
; 5846 : 									pNewArea = pLoopPlot->area();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pNewArea$[ebp], eax
	jmp	SHORT $LN20@setPlotTyp
$LN18@setPlotTyp:

; 5847 : 								}
; 5848 : 								else if(pNewArea != pLoopPlot->area())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	DWORD PTR _pNewArea$[ebp], eax
	je	SHORT $LN20@setPlotTyp

; 5849 : 								{
; 5850 : 									bRecalculateAreas = true;

	mov	BYTE PTR _bRecalculateAreas$[ebp], 1

; 5851 : 									break;

	jmp	SHORT $LN24@setPlotTyp
$LN20@setPlotTyp:

; 5852 : 								}
; 5853 : 							}
; 5854 : 						}
; 5855 : 					}

	jmp	$LN22@setPlotTyp
$LN24@setPlotTyp:

; 5856 : 				}
; 5857 : 
; 5858 : 				if(!bRecalculateAreas)

	movzx	eax, BYTE PTR _bRecalculateAreas$[ebp]
	test	eax, eax
	jne	$LN15@setPlotTyp

; 5859 : 				{
; 5860 : 					pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)(NUM_DIRECTION_TYPES - 1)));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T248687[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T248691[ebp], ecx
	push	5
	mov	edx, DWORD PTR $T248687[ebp]
	push	edx
	mov	eax, DWORD PTR $T248691[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5861 : 
; 5862 : 					if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN14@setPlotTyp

; 5863 : 					{
; 5864 : 						pLastArea = pLoopPlot->area();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pLastArea$[ebp], eax

; 5865 : 					}
; 5866 : 					else

	jmp	SHORT $LN13@setPlotTyp
$LN14@setPlotTyp:

; 5867 : 					{
; 5868 : 						pLastArea = NULL;

	mov	DWORD PTR _pLastArea$[ebp], 0
$LN13@setPlotTyp:

; 5869 : 					}
; 5870 : 
; 5871 : 					iAreaCount = 0;

	mov	DWORD PTR _iAreaCount$[ebp], 0

; 5872 : 
; 5873 : 					for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@setPlotTyp
$LN11@setPlotTyp:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN12@setPlotTyp:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN10@setPlotTyp

; 5874 : 					{
; 5875 : 						pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T248875[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T248879[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T248875[ebp]
	push	ecx
	mov	edx, DWORD PTR $T248879[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 5876 : 
; 5877 : 						if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN9@setPlotTyp

; 5878 : 						{
; 5879 : 							pCurrArea = pLoopPlot->area();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pCurrArea$[ebp], eax

; 5880 : 						}
; 5881 : 						else

	jmp	SHORT $LN8@setPlotTyp
$LN9@setPlotTyp:

; 5882 : 						{
; 5883 : 							pCurrArea = NULL;

	mov	DWORD PTR _pCurrArea$[ebp], 0
$LN8@setPlotTyp:

; 5884 : 						}
; 5885 : 
; 5886 : 						if(pCurrArea != pLastArea)

	mov	eax, DWORD PTR _pCurrArea$[ebp]
	cmp	eax, DWORD PTR _pLastArea$[ebp]
	je	SHORT $LN7@setPlotTyp

; 5887 : 						{
; 5888 : 							iAreaCount++;

	mov	ecx, DWORD PTR _iAreaCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iAreaCount$[ebp], ecx
$LN7@setPlotTyp:

; 5889 : 						}
; 5890 : 
; 5891 : 						pLastArea = pCurrArea;

	mov	edx, DWORD PTR _pCurrArea$[ebp]
	mov	DWORD PTR _pLastArea$[ebp], edx

; 5892 : 					}

	jmp	SHORT $LN11@setPlotTyp
$LN10@setPlotTyp:

; 5893 : 
; 5894 : 					if(iAreaCount > 2)

	cmp	DWORD PTR _iAreaCount$[ebp], 2
	jle	SHORT $LN15@setPlotTyp

; 5895 : 					{
; 5896 : 						bRecalculateAreas = true;

	mov	BYTE PTR _bRecalculateAreas$[ebp], 1
$LN15@setPlotTyp:

; 5897 : 					}
; 5898 : 				}
; 5899 : 
; 5900 : 				if(bRecalculateAreas)

	movzx	eax, BYTE PTR _bRecalculateAreas$[ebp]
	test	eax, eax
	je	SHORT $LN5@setPlotTyp

; 5901 : 				{
; 5902 : 					GC.getMap().recalculateAreas();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249063[ebp], ecx
	mov	ecx, DWORD PTR $T249063[ebp]
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas

; 5903 : 				}
; 5904 : 				else

	jmp	$LN53@setPlotTyp
$LN5@setPlotTyp:

; 5905 : 				{
; 5906 : 					setArea(FFreeList::INVALID_INDEX);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea

; 5907 : 
; 5908 : 					if((area() != NULL) && (area()->getNumTiles() == 1))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN3@setPlotTyp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, 1
	jne	SHORT $LN3@setPlotTyp

; 5909 : 					{
; 5910 : 						GC.getMap().deleteArea(getArea());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T249067[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249071[ebp], ecx
	mov	edx, DWORD PTR $T249067[ebp]
	push	edx
	mov	ecx, DWORD PTR $T249071[ebp]
	call	?deleteArea@CvMap@@QAEXH@Z		; CvMap::deleteArea
$LN3@setPlotTyp:

; 5911 : 					}
; 5912 : 
; 5913 : 					if(pNewArea == NULL)

	cmp	DWORD PTR _pNewArea$[ebp], 0
	jne	SHORT $LN2@setPlotTyp

; 5914 : 					{
; 5915 : 						pNewArea = GC.getMap().addArea();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249075[ebp], eax
	mov	ecx, DWORD PTR $T249075[ebp]
	call	?addArea@CvMap@@QAEPAVCvArea@@XZ	; CvMap::addArea
	mov	DWORD PTR _pNewArea$[ebp], eax

; 5916 : 						pNewArea->init(pNewArea->GetID(), isWater());

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	mov	BYTE PTR $T249079[ebp], al
	mov	ecx, DWORD PTR _pNewArea$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T249083[ebp], edx
	movzx	eax, BYTE PTR $T249079[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249083[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pNewArea$[ebp]
	call	?init@CvArea@@QAEXH_N@Z			; CvArea::init
$LN2@setPlotTyp:

; 5917 : 					}
; 5918 : 
; 5919 : 					setArea(pNewArea->GetID());

	mov	edx, DWORD PTR _pNewArea$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T249087[ebp], eax
	mov	ecx, DWORD PTR $T249087[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea
$LN53@setPlotTyp:

; 5920 : 				}
; 5921 : 			}
; 5922 : 		}
; 5923 : 
; 5924 : 		if(bRebuildGraphics && GC.IsGraphicsInitialized())

	movzx	edx, BYTE PTR _bRebuildGraphics$[ebp]
	test	edx, edx
	je	SHORT $LN63@setPlotTyp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN63@setPlotTyp

; 5925 : 		{
; 5926 : 			//Update terrain graphical
; 5927 : 			setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN63@setPlotTyp:

; 5928 : 		}
; 5929 : 	}
; 5930 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ENDP	; CvPlot::setPlotType
_TEXT	ENDS
PUBLIC	?updateImpassable@CvPlot@@IAEXXZ		; CvPlot::updateImpassable
; Function compile flags: /Odtp
;	COMDAT ?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T249107 = -16						; size = 4
$T249103 = -12						; size = 4
$T249099 = -8						; size = 4
_bTypeIsWater$224557 = -2				; size = 1
_bUpdateSight$ = -1					; size = 1
_eNewValue$ = 8						; size = 4
_bRecalculate$ = 12					; size = 1
_bRebuildGraphics$ = 16					; size = 1
?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z PROC	; CvPlot::setTerrainType, COMDAT
; _this$ = ecx

; 5934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 5935 : 	bool bUpdateSight;
; 5936 : 
; 5937 : 	if(getTerrainType() != eNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	cmp	ecx, DWORD PTR _eNewValue$[ebp]
	je	$LN8@setTerrain

; 5938 : 	{
; 5939 : 		if((getTerrainType() != NO_TERRAIN) &&
; 5940 : 		        (eNewValue != NO_TERRAIN) &&
; 5941 : 		        ((GC.getTerrainInfo(getTerrainType())->getSeeFromLevel() != GC.getTerrainInfo(eNewValue)->getSeeFromLevel()) ||
; 5942 : 		         (GC.getTerrainInfo(getTerrainType())->getSeeThroughLevel() != GC.getTerrainInfo(eNewValue)->getSeeThroughLevel())))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	cmp	eax, -1
	je	$LN6@setTerrain
	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN6@setTerrain
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR $T249099[ebp], edx
	mov	eax, DWORD PTR $T249099[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getSeeFromLevel
	mov	esi, eax
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeFromLevel@CvTerrainInfo@@QBEHXZ	; CvTerrainInfo::getSeeFromLevel
	cmp	esi, eax
	jne	SHORT $LN5@setTerrain
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T249103[ebp], eax
	mov	ecx, DWORD PTR $T249103[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getSeeThroughLevel
	mov	esi, eax
	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getSeeThroughLevel@CvTerrainInfo@@QBEHXZ ; CvTerrainInfo::getSeeThroughLevel
	cmp	esi, eax
	je	SHORT $LN6@setTerrain
$LN5@setTerrain:

; 5943 : 		{
; 5944 : 			bUpdateSight = true;

	mov	BYTE PTR _bUpdateSight$[ebp], 1

; 5945 : 		}
; 5946 : 		else

	jmp	SHORT $LN4@setTerrain
$LN6@setTerrain:

; 5947 : 		{
; 5948 : 			bUpdateSight = false;

	mov	BYTE PTR _bUpdateSight$[ebp], 0
$LN4@setTerrain:

; 5949 : 		}
; 5950 : 
; 5951 : 		if(bUpdateSight)

	movzx	eax, BYTE PTR _bUpdateSight$[ebp]
	test	eax, eax
	je	SHORT $LN3@setTerrain

; 5952 : 		{
; 5953 : 			updateSeeFromSight(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN3@setTerrain:

; 5954 : 		}
; 5955 : 
; 5956 : 		m_eTerrainType = eNewValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [ecx+6], dl

; 5957 : 
; 5958 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 5959 : 		updateImpassable();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateImpassable@CvPlot@@IAEXXZ	; CvPlot::updateImpassable

; 5960 : 
; 5961 : 		if(bUpdateSight)

	movzx	eax, BYTE PTR _bUpdateSight$[ebp]
	test	eax, eax
	je	SHORT $LN2@setTerrain

; 5962 : 		{
; 5963 : 			updateSeeFromSight(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN2@setTerrain:

; 5964 : 		}
; 5965 : 
; 5966 : 		const bool bTypeIsWater = GC.getTerrainInfo(getTerrainType())->isWater();

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR $T249107[ebp], edx
	mov	eax, DWORD PTR $T249107[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?isWater@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isWater
	mov	BYTE PTR _bTypeIsWater$224557[ebp], al

; 5967 : 		if(bTypeIsWater != isWater())

	movzx	ecx, BYTE PTR _bTypeIsWater$224557[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	edx, edx
	cmp	eax, 3
	sete	dl
	movzx	eax, dl
	cmp	ecx, eax
	je	SHORT $LN8@setTerrain

; 5968 : 		{
; 5969 : 			setPlotType((bTypeIsWater)? PLOT_OCEAN : PLOT_LAND, bRecalculate, bRebuildGraphics);

	push	1
	movzx	ecx, BYTE PTR _bRebuildGraphics$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bRecalculate$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bTypeIsWater$224557[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType
$LN8@setTerrain:

; 5970 : 		}
; 5971 : 	}
; 5972 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ENDP	; CvPlot::setTerrainType
_TEXT	ENDS
EXTRN	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z:PROC	; CvArea::ChangeNumNaturalWonders
EXTRN	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z:PROC	; CvMap::ChangeNumNaturalWonders
EXTRN	?IsRough@CvFeatureInfo@@QBE_NXZ:PROC		; CvFeatureInfo::IsRough
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$1
__ehfuncinfo$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
_TEXT	SEGMENT
tv142 = -112						; size = 4
tv132 = -108						; size = 4
_this$ = -104						; size = 4
_inst$249212 = -100					; size = 4
$T249208 = -96						; size = 4
_f$249199 = -89						; size = 1
$T249190 = -88						; size = 4
$T249186 = -84						; size = 4
$T249182 = -80						; size = 4
$T249178 = -76						; size = 4
$T249174 = -72						; size = 4
$T249170 = -68						; size = 4
$T249166 = -64						; size = 4
$T249148 = -60						; size = 4
$T249160 = -56						; size = 8
$T249159 = -48						; size = 4
$T249135 = -44						; size = 4
_f$249128 = -38						; size = 1
$T249117 = -37						; size = 1
$T249114 = -36						; size = 4
$T249113 = -32						; size = 4
_bRough$224580 = -25					; size = 1
_pDllPlot$224577 = -24					; size = 4
_bUpdateSight$ = -17					; size = 1
_eOldFeature$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eNewValue$ = 8						; size = 4
_iVariety$ = 12						; size = 4
?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z PROC	; CvPlot::setFeatureType, COMDAT
; _this$ = ecx

; 5976 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 5977 : 	FeatureTypes eOldFeature;
; 5978 : 	bool bUpdateSight;
; 5979 : 
; 5980 : 	eOldFeature = getFeatureType();

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$249128[ebp], cl
	movsx	edx, BYTE PTR _f$249128[ebp]
	mov	DWORD PTR _eOldFeature$[ebp], edx

; 5981 : 
; 5982 : #ifndef AUI_WARNING_FIXES
; 5983 : 	iVariety = 0;

	mov	DWORD PTR _iVariety$[ebp], 0

; 5984 : #endif
; 5985 : 
; 5986 : 	if((eOldFeature != eNewValue) || (m_iFeatureVariety != iVariety))

	mov	eax, DWORD PTR _eOldFeature$[ebp]
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	jne	SHORT $LN16@setFeature
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+453]
	cmp	edx, DWORD PTR _iVariety$[ebp]
	je	$LN18@setFeature
$LN16@setFeature:

; 5987 : 	{
; 5988 : 		if((eOldFeature == NO_FEATURE) ||
; 5989 : 		        (eNewValue == NO_FEATURE) ||
; 5990 : 		        (GC.getFeatureInfo(eOldFeature)->getSeeThroughChange() != GC.getFeatureInfo(eNewValue)->getSeeThroughChange()))

	cmp	DWORD PTR _eOldFeature$[ebp], -1
	je	SHORT $LN14@setFeature
	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN14@setFeature
	mov	eax, DWORD PTR _eOldFeature$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	mov	esi, eax
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	cmp	esi, eax
	je	SHORT $LN15@setFeature
$LN14@setFeature:

; 5991 : 		{
; 5992 : 			bUpdateSight = true;

	mov	BYTE PTR _bUpdateSight$[ebp], 1

; 5993 : 		}
; 5994 : 		else

	jmp	SHORT $LN13@setFeature
$LN15@setFeature:

; 5995 : 		{
; 5996 : 			bUpdateSight = false;

	mov	BYTE PTR _bUpdateSight$[ebp], 0
$LN13@setFeature:

; 5997 : 		}
; 5998 : 
; 5999 : 		if(bUpdateSight)

	movzx	edx, BYTE PTR _bUpdateSight$[ebp]
	test	edx, edx
	je	SHORT $LN12@setFeature

; 6000 : 		{
; 6001 : 			updateSeeFromSight(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN12@setFeature:

; 6002 : 		}
; 6003 : 
; 6004 : 		auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T249114[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T249114[ebp], 0
	je	SHORT $LN20@setFeature
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249114[ebp]
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN21@setFeature
$LN20@setFeature:
	mov	DWORD PTR tv132[ebp], 0
$LN21@setFeature:
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T249113[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T249113[ebp]
	mov	DWORD PTR _pDllPlot$224577[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 6005 : 		gDLL->GameplayFeatureChanged(pDllPlot.get(), eNewValue);

	mov	eax, DWORD PTR $T249135[ebp]
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv142[ebp], ecx
	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDllPlot$224577[ebp]
	push	eax
	mov	ecx, DWORD PTR tv142[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR [edx+688]
	call	eax

; 6006 : 
; 6007 : 		m_eFeatureType = eNewValue;

	mov	cl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR $T249117[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 428				; 000001acH
	mov	DWORD PTR $T249166[ebp], edx
	movsx	eax, BYTE PTR $T249117[ebp]
	mov	ecx, DWORD PTR $T249166[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	eax, edx
	je	SHORT $LN35@setFeature
	mov	eax, DWORD PTR $T249166[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	movsx	edx, BYTE PTR $T249117[ebp]
	cmp	ecx, edx
	je	SHORT $LN35@setFeature
	mov	eax, DWORD PTR $T249166[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T249148[ebp], ecx
	mov	edx, DWORD PTR $T249166[ebp]
	mov	DWORD PTR $T249159[ebp], edx
	lea	eax, DWORD PTR $T249159[ebp]
	push	eax
	lea	ecx, DWORD PTR $T249160[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T249148[ebp]
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	edx, DWORD PTR $T249166[ebp]
	mov	al, BYTE PTR $T249117[ebp]
	mov	BYTE PTR [edx+4], al
$LN35@setFeature:

; 6008 : 
; 6009 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6010 : 		updateImpassable();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateImpassable@CvPlot@@IAEXXZ	; CvPlot::updateImpassable

; 6011 : 
; 6012 : 		if(bUpdateSight)

	movzx	ecx, BYTE PTR _bUpdateSight$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@setFeature

; 6013 : 		{
; 6014 : 			updateSeeFromSight(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSeeFromSight@CvPlot@@QAEX_N@Z	; CvPlot::updateSeeFromSight
$LN11@setFeature:

; 6015 : 		}
; 6016 : 		m_iFeatureVariety = iVariety;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _iVariety$[ebp]
	mov	BYTE PTR [edx+453], al

; 6017 : 
; 6018 : 		// Rough feature?
; 6019 : 		bool bRough = false;

	mov	BYTE PTR _bRough$224580[ebp], 0

; 6020 : 		if(eNewValue != NO_FEATURE)

	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN10@setFeature

; 6021 : 			bRough = GC.getFeatureInfo(eNewValue)->IsRough();

	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsRough@CvFeatureInfo@@QBE_NXZ		; CvFeatureInfo::IsRough
	mov	BYTE PTR _bRough$224580[ebp], al
$LN10@setFeature:

; 6022 : 
; 6023 : 		SetRoughFeature(bRough);

	movzx	edx, BYTE PTR _bRough$224580[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRoughFeature@CvPlot@@QAEX_N@Z	; CvPlot::SetRoughFeature

; 6024 : 
; 6025 : 		if(eNewValue != NO_FEATURE)

	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN9@setFeature

; 6026 : 		{
; 6027 : 			// Now a Natural Wonder here
; 6028 : 			if((eOldFeature == NO_FEATURE || !GC.getFeatureInfo(eOldFeature)->IsNaturalWonder()) && GC.getFeatureInfo(eNewValue)->IsNaturalWonder())

	cmp	DWORD PTR _eOldFeature$[ebp], -1
	je	SHORT $LN7@setFeature
	mov	eax, DWORD PTR _eOldFeature$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@setFeature
$LN7@setFeature:
	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@setFeature

; 6029 : 			{
; 6030 : 				GC.getMap().ChangeNumNaturalWonders(1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249170[ebp], ecx
	push	1
	mov	ecx, DWORD PTR $T249170[ebp]
	call	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z	; CvMap::ChangeNumNaturalWonders

; 6031 : 				GC.getMap().getArea(getArea())->ChangeNumNaturalWonders(1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T249174[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249178[ebp], ecx
	push	1
	mov	edx, DWORD PTR $T249174[ebp]
	push	edx
	mov	ecx, DWORD PTR $T249178[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z ; CvArea::ChangeNumNaturalWonders
$LN9@setFeature:

; 6032 : 			}
; 6033 : 		}
; 6034 : 		if(eOldFeature != NO_FEATURE)

	cmp	DWORD PTR _eOldFeature$[ebp], -1
	je	SHORT $LN56@setFeature

; 6035 : 		{
; 6036 : 			// Was a Natural Wonder, isn't any more
; 6037 : 			if(GC.getFeatureInfo(eOldFeature)->IsNaturalWonder() && (eNewValue == NO_FEATURE || !GC.getFeatureInfo(eNewValue)->IsNaturalWonder()))

	mov	eax, DWORD PTR _eOldFeature$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN56@setFeature
	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN4@setFeature
	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN56@setFeature
$LN4@setFeature:

; 6038 : 			{
; 6039 : 				GC.getMap().ChangeNumNaturalWonders(-1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249182[ebp], ecx
	push	-1
	mov	ecx, DWORD PTR $T249182[ebp]
	call	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z	; CvMap::ChangeNumNaturalWonders

; 6040 : 				GC.getMap().getArea(getArea())->ChangeNumNaturalWonders(-1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T249186[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249190[ebp], ecx
	push	-1
	mov	edx, DWORD PTR $T249186[ebp]
	push	edx
	mov	ecx, DWORD PTR $T249190[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z ; CvArea::ChangeNumNaturalWonders

; 6041 : 			}
; 6042 : 		}
; 6043 : 
; 6044 : 		if(getFeatureType() == NO_FEATURE)

$LN56@setFeature:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$249199[ebp], cl
	movsx	edx, BYTE PTR _f$249199[ebp]
	cmp	edx, -1
	jne	SHORT $LN3@setFeature

; 6045 : 		{
; 6046 : 			if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN3@setFeature

; 6047 : 			{
; 6048 : 				if(GC.getImprovementInfo(getImprovementType())->IsRequiresFeature())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsRequiresFeature@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRequiresFeature
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@setFeature

; 6049 : 				{
; 6050 : 					setImprovementType(NO_IMPROVEMENT);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
$LN3@setFeature:

; 6051 : 				}
; 6052 : 			}
; 6053 : 		}
; 6054 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllPlot$224577[ebp]
	mov	DWORD PTR $T249208[ebp], ecx
	cmp	DWORD PTR $T249208[ebp], 0
	je	SHORT $LN18@setFeature
	mov	edx, DWORD PTR $T249208[ebp]
	mov	DWORD PTR _inst$249212[ebp], edx
	mov	eax, DWORD PTR _inst$249212[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$249212[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN18@setFeature:

; 6055 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$0:
	mov	eax, DWORD PTR $T249114[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$224577[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ENDP	; CvPlot::setFeatureType
PUBLIC	?IsNaturalWonder@CvPlot@@QBE_NXZ		; CvPlot::IsNaturalWonder
; Function compile flags: /Odtp
;	COMDAT ?IsNaturalWonder@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_f$249230 = -5						; size = 1
_eFeature$ = -4						; size = 4
?IsNaturalWonder@CvPlot@@QBE_NXZ PROC			; CvPlot::IsNaturalWonder, COMDAT
; _this$ = ecx

; 6060 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 6061 : 	FeatureTypes eFeature = getFeatureType();

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$249230[ebp], cl
	movsx	edx, BYTE PTR _f$249230[ebp]
	mov	DWORD PTR _eFeature$[ebp], edx

; 6062 : 
; 6063 : 	if(eFeature == NO_FEATURE)

	cmp	DWORD PTR _eFeature$[ebp], -1
	jne	SHORT $LN1@IsNaturalW

; 6064 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@IsNaturalW
$LN1@IsNaturalW:

; 6065 : 
; 6066 : 	return GC.getFeatureInfo(eFeature)->IsNaturalWonder();

	mov	eax, DWORD PTR _eFeature$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
$LN2@IsNaturalW:

; 6067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNaturalWonder@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsNaturalWonder
_TEXT	ENDS
PUBLIC	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsResourceForceReveal
EXTRN	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z:PROC ; CvTeam::isForceRevealedResource
EXTRN	?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z:PROC ; CvTeam::HavePolicyInTeam
EXTRN	?getPolicyReveal@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getPolicyReveal
; Function compile flags: /Odtp
;	COMDAT ?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T249247 = -24						; size = 4
$T249243 = -20						; size = 4
$T249239 = -16						; size = 4
_Game$224602 = -12					; size = 4
_bDebug$224603 = -5					; size = 1
_iPolicyReveal$224604 = -4				; size = 4
_eTeam$ = 8						; size = 4
?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getResourceType, COMDAT
; _this$ = ecx

; 6071 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 6072 : 	if(eTeam != NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	$LN5@getResourc

; 6073 : 	{
; 6074 : 		if(m_eResourceType != NO_RESOURCE)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	cmp	ecx, -1
	je	$LN5@getResourc

; 6075 : 		{
; 6076 : 			CvGame& Game = GC.getGame();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _Game$224602[ebp], edx

; 6077 : 			bool bDebug = Game.isDebugMode();

	mov	ecx, DWORD PTR _Game$224602[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	mov	BYTE PTR _bDebug$224603[ebp], al

; 6078 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_RESOURCES
; 6079 : 			if (eTeam == OBSERVER_TEAM)
; 6080 : 				bDebug = true;
; 6081 : #endif
; 6082 : 
; 6083 : 			int iPolicyReveal = GC.getResourceInfo((ResourceTypes)m_eResourceType)->getPolicyReveal();

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	mov	DWORD PTR _iPolicyReveal$224604[ebp], eax

; 6084 : 			if (!bDebug && iPolicyReveal != NO_POLICY)

	movzx	edx, BYTE PTR _bDebug$224603[ebp]
	test	edx, edx
	jne	SHORT $LN3@getResourc
	cmp	DWORD PTR _iPolicyReveal$224604[ebp], -1
	je	SHORT $LN3@getResourc

; 6085 : 			{
; 6086 : 				if (!GET_TEAM(eTeam).HavePolicyInTeam((PolicyTypes)iPolicyReveal))

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249239[ebp], eax
	mov	ecx, DWORD PTR _iPolicyReveal$224604[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T249239[ebp]
	call	?HavePolicyInTeam@CvTeam@@QAE_NW4PolicyTypes@@@Z ; CvTeam::HavePolicyInTeam
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@getResourc

; 6087 : 				{
; 6088 : 					return NO_RESOURCE;

	or	eax, -1
	jmp	$LN6@getResourc
$LN3@getResourc:

; 6089 : 				}
; 6090 : 			}
; 6091 : 
; 6092 : 			if(!bDebug && !GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)(GC.getResourceInfo((ResourceTypes)m_eResourceType)->getTechReveal())) &&
; 6093 : 			        !GET_TEAM(eTeam).isForceRevealedResource((ResourceTypes)m_eResourceType) &&
; 6094 : 			        !IsResourceForceReveal(eTeam))

	movzx	eax, BYTE PTR _bDebug$224603[ebp]
	test	eax, eax
	jne	$LN5@getResourc
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249243[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+440]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	push	eax
	mov	ecx, DWORD PTR $T249243[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@getResourc
	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249247[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	push	ecx
	mov	ecx, DWORD PTR $T249247[ebp]
	call	?isForceRevealedResource@CvTeam@@QBE_NW4ResourceTypes@@@Z ; CvTeam::isForceRevealedResource
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN5@getResourc
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsResourceForceReveal
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@getResourc

; 6095 : 			{
; 6096 : 				return NO_RESOURCE;

	or	eax, -1
	jmp	SHORT $LN6@getResourc
$LN5@getResourc:

; 6097 : 			}
; 6098 : 		}
; 6099 : 	}
; 6100 : 
; 6101 : 	return (ResourceTypes)m_eResourceType;

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+440]
$LN6@getResourc:

; 6102 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getResourceType
_TEXT	ENDS
PUBLIC	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
EXTRN	?getTechObsolete@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechObsolete
; Function compile flags: /Odtp
;	COMDAT ?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T249253 = -8						; size = 4
_eResource$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getNonObsoleteResourceType, COMDAT
; _this$ = ecx

; 6107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 6108 : 	ResourceTypes eResource;
; 6109 : 
; 6110 : 	CvAssert(eTeam != NO_TEAM);
; 6111 : 
; 6112 : 	eResource = getResourceType(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 6113 : 
; 6114 : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN2@getNonObso

; 6115 : 	{
; 6116 : 		if((GC.getResourceInfo(eResource)->getTechObsolete() != NO_TECH) && GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes)(GC.getResourceInfo(eResource)->getTechObsolete())))

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechObsolete@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechObsolete
	cmp	eax, -1
	je	SHORT $LN2@getNonObso
	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249253[ebp], edx
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechObsolete@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechObsolete
	push	eax
	mov	ecx, DWORD PTR $T249253[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@getNonObso

; 6117 : 		{
; 6118 : 			return NO_RESOURCE;

	or	eax, -1
	jmp	SHORT $LN3@getNonObso
$LN2@getNonObso:

; 6119 : 		}
; 6120 : 	}
; 6121 : 
; 6122 : 	return eResource;

	mov	eax, DWORD PTR _eResource$[ebp]
$LN3@getNonObso:

; 6123 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getNonObsoleteResourceType
_TEXT	ENDS
PUBLIC	?setNumResource@CvPlot@@QAEXH@Z			; CvPlot::setNumResource
EXTRN	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z:PROC ; CvMap::changeNumResources
EXTRN	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z:PROC ; CvArea::changeNumResources
; Function compile flags: /Odtp
;	COMDAT ?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T249277 = -20						; size = 4
$T249270 = -16						; size = 4
$T249266 = -12						; size = 4
$T249259 = -8						; size = 4
_pkResourceInfo$224630 = -4				; size = 4
_eNewValue$ = 8						; size = 4
_iResourceNum$ = 12					; size = 4
_bForMinorCivPlot$ = 16					; size = 1
?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z PROC ; CvPlot::setResourceType, COMDAT
; _this$ = ecx

; 6128 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 6129 : 	if(m_eResourceType != eNewValue)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	cmp	ecx, DWORD PTR _eNewValue$[ebp]
	je	$LN13@setResourc

; 6130 : 	{
; 6131 : 		if (eNewValue != -1)

	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN11@setResourc

; 6132 : 		{
; 6133 : 			CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eNewValue);

	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$224630[ebp], eax

; 6134 : 			if (pkResourceInfo)

	cmp	DWORD PTR _pkResourceInfo$224630[ebp], 0
	je	SHORT $LN11@setResourc

; 6135 : 			{
; 6136 : 				if (pkResourceInfo->isOnlyMinorCivs())

	mov	ecx, DWORD PTR _pkResourceInfo$224630[ebp]
	call	?isOnlyMinorCivs@CvResourceInfo@@QBE_NXZ ; CvResourceInfo::isOnlyMinorCivs
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@setResourc

; 6137 : 				{
; 6138 : 					if (!bForMinorCivPlot)

	movzx	ecx, BYTE PTR _bForMinorCivPlot$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@setResourc

; 6139 : 					{
; 6140 : 						CvAssertMsg(false, "Tried to place a city-state unique luxury when not allowed.  PLEASE send Anton your save game, settings, and version!");
; 6141 : 						return;

	jmp	$LN13@setResourc
$LN11@setResourc:

; 6142 : 					}
; 6143 : 				}
; 6144 : 			}
; 6145 : 		}
; 6146 : 
; 6147 : 		if(m_eResourceType != NO_RESOURCE)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+440]
	cmp	eax, -1
	je	SHORT $LN7@setResourc

; 6148 : 		{
; 6149 : 			if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN6@setResourc

; 6150 : 			{
; 6151 : 				area()->changeNumResources((ResourceTypes)m_eResourceType, -1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+440]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN6@setResourc:

; 6152 : 			}
; 6153 : 			GC.getMap().changeNumResources((ResourceTypes)m_eResourceType, -1);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249259[ebp], eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+440]
	push	edx
	mov	ecx, DWORD PTR $T249259[ebp]
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources

; 6154 : 
; 6155 : 			if(!isWater())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN7@setResourc

; 6156 : 			{
; 6157 : 				GC.getMap().changeNumResourcesOnLand((ResourceTypes)m_eResourceType, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249266[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+440]
	push	eax
	mov	ecx, DWORD PTR $T249266[ebp]
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN7@setResourc:

; 6158 : 			}
; 6159 : 
; 6160 : 		}
; 6161 : 
; 6162 : 		m_eResourceType = eNewValue; // !!! Here is where we actually change the value

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [ecx+440], dl

; 6163 : 
; 6164 : 		setNumResource(iResourceNum);

	mov	eax, DWORD PTR _iResourceNum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setNumResource@CvPlot@@QAEXH@Z		; CvPlot::setNumResource

; 6165 : 
; 6166 : 		if(m_eResourceType != NO_RESOURCE)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+440]
	cmp	edx, -1
	je	SHORT $LN4@setResourc

; 6167 : 		{
; 6168 : 			if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN3@setResourc

; 6169 : 			{
; 6170 : 				area()->changeNumResources((ResourceTypes)m_eResourceType, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN3@setResourc:

; 6171 : 			}
; 6172 : 			GC.getMap().changeNumResources((ResourceTypes)m_eResourceType, 1);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249270[ebp], edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	push	ecx
	mov	ecx, DWORD PTR $T249270[ebp]
	call	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources

; 6173 : 
; 6174 : 			if(!isWater())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN4@setResourc

; 6175 : 			{
; 6176 : 				GC.getMap().changeNumResourcesOnLand((ResourceTypes)m_eResourceType, 1);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T249277[ebp], eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+440]
	push	edx
	mov	ecx, DWORD PTR $T249277[ebp]
	call	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
$LN4@setResourc:

; 6177 : 			}
; 6178 : 		}
; 6179 : 
; 6180 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6181 : 
; 6182 : 		if(GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@setResourc

; 6183 : 		{
; 6184 : 			setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN13@setResourc:

; 6185 : 		}
; 6186 : 	}
; 6187 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ENDP ; CvPlot::setResourceType
_TEXT	ENDS
PUBLIC	?getNumResource@CvPlot@@QBEHXZ			; CvPlot::getNumResource
; Function compile flags: /Odtp
;	COMDAT ?getNumResource@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumResource@CvPlot@@QBEHXZ PROC			; CvPlot::getNumResource, COMDAT
; _this$ = ecx

; 6192 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6193 : 	return m_iResourceNum;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+458]

; 6194 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumResource@CvPlot@@QBEHXZ ENDP			; CvPlot::getNumResource
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setNumResource@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNum$ = 8						; size = 4
?setNumResource@CvPlot@@QAEXH@Z PROC			; CvPlot::setNumResource, COMDAT
; _this$ = ecx

; 6198 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6199 : 	m_iResourceNum = iNum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _iNum$[ebp]
	mov	BYTE PTR [eax+458], cl

; 6200 : 	CvAssert(getNumResource() >= 0);
; 6201 : 	FAssertMsg(getResourceType() == NO_RESOURCE || m_iResourceNum > 0, "If a plot contains a Resource it should always have a quantity of at least 1.");
; 6202 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setNumResource@CvPlot@@QAEXH@Z ENDP			; CvPlot::setNumResource
_TEXT	ENDS
PUBLIC	?changeNumResource@CvPlot@@QAEXH@Z		; CvPlot::changeNumResource
; Function compile flags: /Odtp
;	COMDAT ?changeNumResource@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumResource@CvPlot@@QAEXH@Z PROC			; CvPlot::changeNumResource, COMDAT
; _this$ = ecx

; 6206 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6207 : 	setNumResource(getNumResource() + iChange);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	add	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setNumResource@CvPlot@@QAEXH@Z		; CvPlot::setNumResource

; 6208 : 	CvAssert(getNumResource() >= 0);
; 6209 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumResource@CvPlot@@QAEXH@Z ENDP			; CvPlot::changeNumResource
_TEXT	ENDS
EXTRN	?IsExtraLuxuryResources@CvCity@@QAE_NXZ:PROC	; CvCity::IsExtraLuxuryResources
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
; Function compile flags: /Odtp
;	COMDAT ?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv232 = -96						; size = 4
tv220 = -92						; size = 4
_this$ = -88						; size = 4
$T249385 = -84						; size = 4
$T249373 = -80						; size = 4
$T249366 = -76						; size = 4
$T249362 = -72						; size = 4
$T249350 = -68						; size = 4
$T249343 = -64						; size = 4
$T249339 = -60						; size = 4
$T249335 = -56						; size = 4
$T249331 = -52						; size = 4
$T249327 = -48						; size = 4
$T249323 = -44						; size = 4
$T249319 = -40						; size = 4
_playerID$249316 = -36					; size = 4
$T249302 = -32						; size = 4
_playerID$249299 = -28					; size = 4
_iQuantityMod$224679 = -24				; size = 4
_pCity$224675 = -20					; size = 4
_iQuantityMod$224672 = -16				; size = 4
_pkResource$224665 = -12				; size = 4
_iRtnValue$ = -8					; size = 4
_eResource$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z PROC ; CvPlot::getNumResourceForPlayer, COMDAT
; _this$ = ecx

; 6213 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 6214 : 	int iRtnValue = m_iResourceNum;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+458]
	mov	DWORD PTR _iRtnValue$[ebp], ecx

; 6215 : 
; 6216 : 	ResourceTypes eResource = getResourceType(getTeam());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$249299[ebp], eax
	cmp	DWORD PTR _playerID$249299[ebp], -1
	je	SHORT $LN14@getNumReso
	mov	ecx, DWORD PTR _playerID$249299[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249302[ebp], eax
	jmp	SHORT $LN15@getNumReso
	jmp	SHORT $LN15@getNumReso
$LN14@getNumReso:
	mov	DWORD PTR $T249302[ebp], -1
$LN15@getNumReso:
	mov	edx, DWORD PTR $T249302[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 6217 : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	$LN10@getNumReso

; 6218 : 	{
; 6219 : 		CvResourceInfo *pkResource = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResource$224665[ebp], eax

; 6220 : 		if (pkResource)

	cmp	DWORD PTR _pkResource$224665[ebp], 0
	je	$LN10@getNumReso

; 6221 : 		{
; 6222 : 			if (GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) pkResource->getTechReveal()) && 
; 6223 : 				(pkResource->getPolicyReveal() == NO_POLICY || GET_PLAYER(ePlayer).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkResource->getPolicyReveal())))

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$249316[ebp], edx
	cmp	DWORD PTR _playerID$249316[ebp], -1
	je	SHORT $LN22@getNumReso
	mov	eax, DWORD PTR _playerID$249316[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249319[ebp], eax
	jmp	SHORT $LN23@getNumReso
	jmp	SHORT $LN23@getNumReso
$LN22@getNumReso:
	mov	DWORD PTR $T249319[ebp], -1
$LN23@getNumReso:
	mov	ecx, DWORD PTR $T249319[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249323[ebp], ecx
	mov	ecx, DWORD PTR _pkResource$224665[ebp]
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	push	eax
	mov	ecx, DWORD PTR $T249323[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	$LN10@getNumReso
	mov	ecx, DWORD PTR _pkResource$224665[ebp]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	cmp	eax, -1
	je	SHORT $LN7@getNumReso
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249327[ebp], eax
	mov	ecx, DWORD PTR _pkResource$224665[ebp]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	push	eax
	mov	ecx, DWORD PTR $T249327[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@getNumReso
$LN7@getNumReso:

; 6224 : 			{
; 6225 : 				if(pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ecx, DWORD PTR _pkResource$224665[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN6@getNumReso

; 6226 : 				{
; 6227 : 					int iQuantityMod = GET_PLAYER(ePlayer).GetPlayerTraits()->GetStrategicResourceQuantityModifier(getTerrainType());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T249331[ebp], eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249335[ebp], ecx
	mov	ecx, DWORD PTR $T249335[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T249339[ebp], eax
	mov	edx, DWORD PTR $T249331[ebp]
	mov	eax, DWORD PTR $T249339[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+576]
	mov	DWORD PTR _iQuantityMod$224672[ebp], ecx

; 6228 : 					iRtnValue *= 100 + iQuantityMod;

	mov	edx, DWORD PTR _iQuantityMod$224672[ebp]
	add	edx, 100				; 00000064H
	imul	edx, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], edx

; 6229 : 					iRtnValue /= 100;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iRtnValue$[ebp], eax
	jmp	SHORT $LN5@getNumReso
$LN6@getNumReso:

; 6230 : 				}
; 6231 : 
; 6232 : 				else if(pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _pkResource$224665[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN5@getNumReso

; 6233 : 				{
; 6234 : 					CvCity* pCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pCity$224675[ebp], eax

; 6235 : 					if(pCity)

	cmp	DWORD PTR _pCity$224675[ebp], 0
	je	SHORT $LN5@getNumReso

; 6236 : 					{
; 6237 : 						if(pCity->IsExtraLuxuryResources())

	mov	ecx, DWORD PTR _pCity$224675[ebp]
	call	?IsExtraLuxuryResources@CvCity@@QAE_NXZ	; CvCity::IsExtraLuxuryResources
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@getNumReso

; 6238 : 						{
; 6239 : 							iRtnValue++;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN5@getNumReso:

; 6240 : 						}
; 6241 : 					}
; 6242 : 				}
; 6243 : 
; 6244 : 				if(GET_PLAYER(ePlayer).GetPlayerTraits()->GetResourceQuantityModifier(eResource) > 0)

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249343[ebp], ecx
	mov	ecx, DWORD PTR $T249343[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T249362[ebp], eax
	mov	edx, DWORD PTR $T249362[ebp]
	add	edx, 612				; 00000264H
	mov	DWORD PTR $T249350[ebp], edx
	mov	eax, DWORD PTR $T249350[ebp]
	mov	ecx, DWORD PTR $T249350[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _eResource$[ebp], edx
	jae	SHORT $LN43@getNumReso
	mov	eax, DWORD PTR $T249362[ebp]
	mov	ecx, DWORD PTR [eax+616]
	mov	edx, DWORD PTR _eResource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv220[ebp], eax
	jmp	SHORT $LN41@getNumReso
$LN43@getNumReso:
	mov	DWORD PTR tv220[ebp], 0
$LN41@getNumReso:
	cmp	DWORD PTR tv220[ebp], 0
	jle	SHORT $LN10@getNumReso

; 6245 : 				{
; 6246 : 					int iQuantityMod = GET_PLAYER(ePlayer).GetPlayerTraits()->GetResourceQuantityModifier(eResource);

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249366[ebp], ecx
	mov	ecx, DWORD PTR $T249366[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T249385[ebp], eax
	mov	edx, DWORD PTR $T249385[ebp]
	add	edx, 612				; 00000264H
	mov	DWORD PTR $T249373[ebp], edx
	mov	eax, DWORD PTR $T249373[ebp]
	mov	ecx, DWORD PTR $T249373[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR _eResource$[ebp], edx
	jae	SHORT $LN53@getNumReso
	mov	eax, DWORD PTR $T249385[ebp]
	mov	ecx, DWORD PTR [eax+616]
	mov	edx, DWORD PTR _eResource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv232[ebp], eax
	jmp	SHORT $LN51@getNumReso
$LN53@getNumReso:
	mov	DWORD PTR tv232[ebp], 0
$LN51@getNumReso:
	mov	ecx, DWORD PTR tv232[ebp]
	mov	DWORD PTR _iQuantityMod$224679[ebp], ecx

; 6247 : 					iRtnValue *= 100 + iQuantityMod;

	mov	edx, DWORD PTR _iQuantityMod$224679[ebp]
	add	edx, 100				; 00000064H
	imul	edx, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], edx

; 6248 : 					iRtnValue /= 100;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN10@getNumReso:

; 6249 : 				}
; 6250 : 			}
; 6251 : 		}
; 6252 : 	}
; 6253 : 
; 6254 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 6255 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlot::getNumResourceForPlayer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ PROC ; CvPlot::getImprovementType, COMDAT
; _this$ = ecx

; 6259 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6260 : 	return (ImprovementTypes)m_eImprovementType;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+441]

; 6261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ENDP ; CvPlot::getImprovementType
_TEXT	ENDS
PUBLIC	?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z ; CvPlot::getImprovementTypeNeededToImproveResource
EXTRN	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsCreatedByGreatPerson
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
; Function compile flags: /Odtp
;	COMDAT ?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T249410 = -41						; size = 1
$T249406 = -40						; size = 4
$T249402 = -36						; size = 4
$T249393 = -32						; size = 4
_eImprovement$224705 = -28				; size = 4
_eBuild$224698 = -24					; size = 4
_pBuildInfo$224700 = -20				; size = 4
_pImprovementInfo$224708 = -16				; size = 4
_iBuildIndex$224694 = -12				; size = 4
_eImprovementNeeded$ = -8				; size = 4
_eResource$ = -4					; size = 4
_ePlayer$ = 8						; size = 4
_bTestPlotOwner$ = 12					; size = 1
?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z PROC ; CvPlot::getImprovementTypeNeededToImproveResource, COMDAT
; _this$ = ecx

; 6265 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 6266 : 	CvAssertMsg(ePlayer == NO_PLAYER || ePlayer >= 0, "ePlayer is expected to be non-negative (invalid Index)");
; 6267 : 	CvAssertMsg(ePlayer == NO_PLAYER || ePlayer < MAX_MAJOR_CIVS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 6268 : 
; 6269 : 	ResourceTypes eResource = NO_RESOURCE;

	mov	DWORD PTR _eResource$[ebp], -1

; 6270 : 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	SHORT $LN15@getImprove

; 6271 : 	{
; 6272 : 		eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249393[ebp], eax
	mov	ecx, DWORD PTR $T249393[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249402[ebp], eax
	mov	eax, DWORD PTR $T249402[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 6273 : 	}
; 6274 : 	else

	jmp	SHORT $LN14@getImprove
$LN15@getImprove:

; 6275 : 	{
; 6276 : 		eResource = getResourceType();

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax
$LN14@getImprove:

; 6277 : 	}
; 6278 : 
; 6279 : 	if(eResource == NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	jne	SHORT $LN13@getImprove

; 6280 : 	{
; 6281 : 		return NO_IMPROVEMENT;

	or	eax, -1
	jmp	$LN16@getImprove
$LN13@getImprove:

; 6282 : 	}
; 6283 : 
; 6284 : 	ImprovementTypes eImprovementNeeded = NO_IMPROVEMENT;

	mov	DWORD PTR _eImprovementNeeded$[ebp], -1

; 6285 : 
; 6286 : 	// see if we can improve the resource
; 6287 : #ifdef AUI_WARNING_FIXES
; 6288 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 6289 : #else
; 6290 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$224694[ebp], 0
	jmp	SHORT $LN12@getImprove
$LN11@getImprove:
	mov	ecx, DWORD PTR _iBuildIndex$224694[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBuildIndex$224694[ebp], ecx
$LN12@getImprove:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$224694[ebp], eax
	jge	$LN10@getImprove

; 6291 : #endif
; 6292 : 	{
; 6293 : 		BuildTypes eBuild = (BuildTypes) iBuildIndex;

	mov	edx, DWORD PTR _iBuildIndex$224694[ebp]
	mov	DWORD PTR _eBuild$224698[ebp], edx

; 6294 : 		CvBuildInfo* pBuildInfo = GC.getBuildInfo(eBuild);

	mov	eax, DWORD PTR _eBuild$224698[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pBuildInfo$224700[ebp], eax

; 6295 : 		if(pBuildInfo == NULL)

	cmp	DWORD PTR _pBuildInfo$224700[ebp], 0
	jne	SHORT $LN9@getImprove

; 6296 : 			continue;

	jmp	SHORT $LN11@getImprove
$LN9@getImprove:

; 6297 : 
; 6298 : 		if(!canBuild(eBuild, ePlayer, false /*bTestVisible*/, bTestPlotOwner))

	movzx	ecx, BYTE PTR _bTestPlotOwner$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$224698[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ; CvPlot::canBuild
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@getImprove

; 6299 : 			continue;

	jmp	SHORT $LN11@getImprove
$LN8@getImprove:

; 6300 : 
; 6301 : 		if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	SHORT $LN7@getImprove

; 6302 : 		{
; 6303 : 			if(!GET_PLAYER(ePlayer).canBuild(this, eBuild, false /*bTestEra*/, false /*bTestVisible*/, false /*bTestGold*/, bTestPlotOwner))

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249406[ebp], edx
	movzx	eax, BYTE PTR _bTestPlotOwner$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _eBuild$224698[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T249406[ebp]
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@getImprove

; 6304 : 			{
; 6305 : 				continue;

	jmp	$LN11@getImprove
$LN7@getImprove:

; 6306 : 			}
; 6307 : 		}
; 6308 : 
; 6309 : 		ImprovementTypes eImprovement = (ImprovementTypes) pBuildInfo->getImprovement();

	mov	ecx, DWORD PTR _pBuildInfo$224700[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$224705[ebp], eax

; 6310 : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$224705[ebp], -1
	jne	SHORT $LN5@getImprove

; 6311 : 			continue;

	jmp	$LN11@getImprove
$LN5@getImprove:

; 6312 : 
; 6313 : 		CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$224705[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovementInfo$224708[ebp], eax

; 6314 : 		if(pImprovementInfo == NULL)

	cmp	DWORD PTR _pImprovementInfo$224708[ebp], 0
	jne	SHORT $LN4@getImprove

; 6315 : 			continue;

	jmp	$LN11@getImprove
$LN4@getImprove:

; 6316 : 
; 6317 : 		if(!pImprovementInfo->IsImprovementResourceTrade(eResource))

	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovementInfo$224708[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@getImprove

; 6318 : 			continue;

	jmp	$LN11@getImprove
$LN3@getImprove:

; 6319 : 
; 6320 : 		if(pImprovementInfo->IsCreatedByGreatPerson())

	mov	ecx, DWORD PTR _pImprovementInfo$224708[ebp]
	call	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsCreatedByGreatPerson
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@getImprove

; 6321 : 			continue;

	jmp	$LN11@getImprove
$LN2@getImprove:

; 6322 : 
; 6323 : 		if(pImprovementInfo->IsWater() != isWater())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR $T249410[ebp], cl
	mov	ecx, DWORD PTR _pImprovementInfo$224708[ebp]
	call	?IsWater@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsWater
	movzx	edx, al
	movzx	eax, BYTE PTR $T249410[ebp]
	cmp	edx, eax
	je	SHORT $LN1@getImprove

; 6324 : 			continue;

	jmp	$LN11@getImprove
$LN1@getImprove:

; 6325 : 
; 6326 : 		eImprovementNeeded = eImprovement;

	mov	ecx, DWORD PTR _eImprovement$224705[ebp]
	mov	DWORD PTR _eImprovementNeeded$[ebp], ecx

; 6327 : 	}

	jmp	$LN11@getImprove
$LN10@getImprove:

; 6328 : 
; 6329 : 	return eImprovementNeeded;

	mov	eax, DWORD PTR _eImprovementNeeded$[ebp]
$LN16@getImprove:

; 6330 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getImprovementTypeNeededToImproveResource@CvPlot@@QAE?AW4ImprovementTypes@@W4PlayerTypes@@_N@Z ENDP ; CvPlot::getImprovementTypeNeededToImproveResource
_TEXT	ENDS
PUBLIC	?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z	; CvPlot::SetImprovedByGiftFromMajor
PUBLIC	?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatBuiltImprovement
PUBLIC	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ	; CvPlot::IsImprovedByGiftFromMajor
PUBLIC	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z	; CvPlot::SetResourceLinkedCityActive
PUBLIC	?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ	; CvPlot::IsResourceLinkedCityActive
PUBLIC	??_C@_0BF@ONGHEHDC@IMPROVEMENT_FEITORIA?$AA@	; `string'
PUBLIC	??_C@_0BJ@CGEJKJPK@IMPROVEMENT_MOTTE_BAILEY?$AA@ ; `string'
PUBLIC	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
PUBLIC	?SetImprovementPillaged@CvPlot@@QAEX_N@Z	; CvPlot::SetImprovementPillaged
EXTRN	?isLocalPlayer@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isLocalPlayer
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	__imp__strncmp:PROC
EXTRN	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z:PROC ; CvPlayer::changeNumResourceUsed
EXTRN	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetResourceQuantityRequirement
EXTRN	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z:PROC ; CvArea::changeNumImprovements
;	COMDAT ??_C@_0BF@ONGHEHDC@IMPROVEMENT_FEITORIA?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BF@ONGHEHDC@IMPROVEMENT_FEITORIA?$AA@ DB 'IMPROVEMENT_FEITORIA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CGEJKJPK@IMPROVEMENT_MOTTE_BAILEY?$AA@
CONST	SEGMENT
??_C@_0BJ@CGEJKJPK@IMPROVEMENT_MOTTE_BAILEY?$AA@ DB 'IMPROVEMENT_MOTTE_BA'
	DB	'ILEY', 00H					; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
CONST	ENDS
;	COMDAT ?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv419 = -396						; size = 4
tv360 = -392						; size = 4
tv346 = -388						; size = 4
_this$ = -384						; size = 4
$T249933 = -380						; size = 4
$T249926 = -376						; size = 4
_playerID$249923 = -372					; size = 4
$T249909 = -368						; size = 4
$T249905 = -364						; size = 4
_playerID$249902 = -360					; size = 4
$T249880 = -352						; size = 4
_playerID$249877 = -348					; size = 4
$T249863 = -344						; size = 4
$T249859 = -340						; size = 4
_playerID$249851 = -336					; size = 4
$T249842 = -332						; size = 4
$T249838 = -328						; size = 4
$T249834 = -324						; size = 4
$T249830 = -320						; size = 4
$T249826 = -316						; size = 4
$T249822 = -312						; size = 4
$T249818 = -308						; size = 4
$T249814 = -304						; size = 4
$T249810 = -300						; size = 4
$T249806 = -296						; size = 4
$T249802 = -292						; size = 4
$T249642 = -216						; size = 4
$T249638 = -212						; size = 4
$T249634 = -205						; size = 1
$T249621 = -204						; size = 4
$T249617 = -200						; size = 4
$T249613 = -196						; size = 4
$T249612 = -192						; size = 4
$T249608 = -188						; size = 4
$T249604 = -184						; size = 4
$T249430 = -100						; size = 4
$T249426 = -96						; size = 4
$T249419 = -92						; size = 4
_iResourceLoop$224813 = -88				; size = 4
_owningPlayer$224810 = -84				; size = 4
_newImprovementEntry$224811 = -80			; size = 4
_iNumResourceInfos$224812 = -76				; size = 4
_owningPlayer$224798 = -72				; size = 4
_eResource$224805 = -68					; size = 4
_eAlly$224780 = -64					; size = 4
_owningPlayer$224772 = -60				; size = 4
_eResource$224791 = -56					; size = 4
_pAdjacentPlot$224767 = -52				; size = 4
_newImprovementEntry$224762 = -48			; size = 4
_iResourceLoop$224743 = -44				; size = 4
_eOldBuilder$224739 = -40				; size = 4
_owningPlayer$224737 = -36				; size = 4
_iNumResourceInfos$224742 = -32				; size = 4
_pAdjacentPlot$224732 = -28				; size = 4
_oldImprovementEntry$224727 = -24			; size = 4
_owningPlayerID$224725 = -20				; size = 4
_eOldImprovement$ = -16					; size = 4
_bIgnoreResourceTechPrereq$ = -9			; size = 1
_iI$ = -8						; size = 4
_bGiftFromMajor$ = -1					; size = 1
_eNewValue$ = 8						; size = 4
_eBuilder$ = 12						; size = 4
?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::setImprovementType, COMDAT
; _this$ = ecx

; 6335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH
	mov	DWORD PTR _this$[ebp], ecx

; 6336 : 	int iI;
; 6337 : 	ImprovementTypes eOldImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eOldImprovement$[ebp], eax

; 6338 : 	bool bGiftFromMajor = false;

	mov	BYTE PTR _bGiftFromMajor$[ebp], 0

; 6339 : 	if (eBuilder != NO_PLAYER)

	cmp	DWORD PTR _eBuilder$[ebp], -1
	je	SHORT $LN70@setImprove

; 6340 : 	{
; 6341 : 		if (getOwner() != eBuilder && !GET_PLAYER(eBuilder).isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR _eBuilder$[ebp]
	je	SHORT $LN70@setImprove
	mov	edx, DWORD PTR _eBuilder$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249419[ebp], edx
	mov	ecx, DWORD PTR $T249419[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN70@setImprove

; 6342 : 		{
; 6343 : 			bGiftFromMajor = true;

	mov	BYTE PTR _bGiftFromMajor$[ebp], 1
$LN70@setImprove:

; 6344 : 		}
; 6345 : 	}
; 6346 : 	bool bIgnoreResourceTechPrereq = bGiftFromMajor; // If it is a gift from a major civ, our tech limitations do not apply

	mov	cl, BYTE PTR _bGiftFromMajor$[ebp]
	mov	BYTE PTR _bIgnoreResourceTechPrereq$[ebp], cl

; 6347 : 
; 6348 : 	if(eOldImprovement != eNewValue)

	mov	edx, DWORD PTR _eOldImprovement$[ebp]
	cmp	edx, DWORD PTR _eNewValue$[ebp]
	je	$LN71@setImprove

; 6349 : 	{
; 6350 : #ifdef AUI_PLOT_FIX_PILLAGED_PLOT_ON_NEW_IMPROVEMENT
; 6351 : 		SetImprovementPillaged(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged

; 6352 : #endif
; 6353 : 		PlayerTypes owningPlayerID = getOwner();

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _owningPlayerID$224725[ebp], ecx

; 6354 : 		if(eOldImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eOldImprovement$[ebp], -1
	je	$LN67@setImprove

; 6355 : 		{
; 6356 : 			CvImprovementEntry& oldImprovementEntry = *GC.getImprovementInfo(eOldImprovement);

	mov	edx, DWORD PTR _eOldImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _oldImprovementEntry$224727[ebp], eax

; 6357 : 
; 6358 : 			// If this improvement can add culture to nearby improvements, update them as well
; 6359 : 			if(oldImprovementEntry.GetCultureAdjacentSameType() > 0)

	mov	ecx, DWORD PTR _oldImprovementEntry$224727[ebp]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	test	eax, eax
	jle	SHORT $LN66@setImprove

; 6360 : 			{
; 6361 : 				for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN65@setImprove
$LN64@setImprove:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN65@setImprove:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN66@setImprove

; 6362 : 				{
; 6363 : 					CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T249426[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T249430[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T249426[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249430[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$224732[ebp], eax

; 6364 : 					if(pAdjacentPlot && pAdjacentPlot->getImprovementType() == eOldImprovement)

	cmp	DWORD PTR _pAdjacentPlot$224732[ebp], 0
	je	SHORT $LN62@setImprove
	mov	ecx, DWORD PTR _pAdjacentPlot$224732[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eOldImprovement$[ebp]
	jne	SHORT $LN62@setImprove

; 6365 : 					{
; 6366 : 						pAdjacentPlot->updateYield();

	mov	ecx, DWORD PTR _pAdjacentPlot$224732[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN62@setImprove:

; 6367 : 					}
; 6368 : 				}

	jmp	SHORT $LN64@setImprove
$LN66@setImprove:

; 6369 : 			}
; 6370 : 
; 6371 : 			if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN61@setImprove

; 6372 : 			{
; 6373 : 				area()->changeNumImprovements(eOldImprovement, -1);

	push	-1
	mov	edx, DWORD PTR _eOldImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
$LN61@setImprove:

; 6374 : 			}
; 6375 : 			// Someone owns this plot
; 6376 : 			if(owningPlayerID != NO_PLAYER)

	cmp	DWORD PTR _owningPlayerID$224725[ebp], -1
	je	$LN60@setImprove

; 6377 : 			{
; 6378 : 				CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	eax, DWORD PTR _owningPlayerID$224725[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$224737[ebp], eax

; 6379 : 				owningPlayer.changeImprovementCount(eOldImprovement, -1);

	push	-1
	mov	ecx, DWORD PTR _eOldImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _owningPlayer$224737[ebp]
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 6380 : 
; 6381 : 				// Maintenance change!
; 6382 : 				if(MustPayMaintenanceHere(owningPlayerID))

	mov	edx, DWORD PTR _owningPlayerID$224725[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN59@setImprove

; 6383 : 				{
; 6384 : #ifdef AUI_WARNING_FIXES
; 6385 : 					GET_PLAYER(owningPlayerID).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-oldImprovementEntry.GetGoldMaintenance());
; 6386 : #else
; 6387 : 					GET_PLAYER(owningPlayerID).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	mov	ecx, DWORD PTR _owningPlayerID$224725[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249604[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T249604[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN59@setImprove:

; 6388 : #endif
; 6389 : 				}
; 6390 : 
; 6391 : 				// Siphon resource changes
; 6392 : 				PlayerTypes eOldBuilder = GetPlayerThatBuiltImprovement();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
	mov	DWORD PTR _eOldBuilder$224739[ebp], eax

; 6393 : 				if(oldImprovementEntry.GetLuxuryCopiesSiphonedFromMinor() > 0 && eOldBuilder != NO_PLAYER)

	mov	ecx, DWORD PTR _oldImprovementEntry$224727[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN58@setImprove
	cmp	DWORD PTR _eOldBuilder$224739[ebp], -1
	je	SHORT $LN58@setImprove

; 6394 : 				{
; 6395 : 					if (owningPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _owningPlayer$224737[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN58@setImprove

; 6396 : 					{
; 6397 : 						GET_PLAYER(eOldBuilder).changeSiphonLuxuryCount(owningPlayerID, -1 * oldImprovementEntry.GetLuxuryCopiesSiphonedFromMinor());

	mov	eax, DWORD PTR _eOldBuilder$224739[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249608[ebp], eax
	mov	ecx, DWORD PTR _oldImprovementEntry$224727[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	imul	eax, -1
	push	eax
	mov	ecx, DWORD PTR _owningPlayerID$224725[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T249608[ebp]
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN58@setImprove:

; 6398 : 					}
; 6399 : 				}
; 6400 : 
; 6401 : 				// Update the amount of a Resource used up by the previous Improvement that is being removed
; 6402 : 				int iNumResourceInfos= GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResourceInfos$224742[ebp], eax

; 6403 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$224743[ebp], 0
	jmp	SHORT $LN56@setImprove
$LN55@setImprove:
	mov	edx, DWORD PTR _iResourceLoop$224743[ebp]
	add	edx, 1
	mov	DWORD PTR _iResourceLoop$224743[ebp], edx
$LN56@setImprove:
	mov	eax, DWORD PTR _iResourceLoop$224743[ebp]
	cmp	eax, DWORD PTR _iNumResourceInfos$224742[ebp]
	jge	SHORT $LN60@setImprove

; 6404 : 				{
; 6405 : 					if(oldImprovementEntry.GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	ecx, DWORD PTR _iResourceLoop$224743[ebp]
	push	ecx
	mov	ecx, DWORD PTR _oldImprovementEntry$224727[ebp]
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	SHORT $LN53@setImprove

; 6406 : 					{
; 6407 : 						owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, -oldImprovementEntry.GetResourceQuantityRequirement(iResourceLoop));

	mov	edx, DWORD PTR _iResourceLoop$224743[ebp]
	push	edx
	mov	ecx, DWORD PTR _oldImprovementEntry$224727[ebp]
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	neg	eax
	push	eax
	mov	eax, DWORD PTR _iResourceLoop$224743[ebp]
	push	eax
	mov	ecx, DWORD PTR _owningPlayer$224737[ebp]
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN53@setImprove:

; 6408 : 					}
; 6409 : 				}

	jmp	SHORT $LN55@setImprove
$LN60@setImprove:

; 6410 : 			}
; 6411 : 
; 6412 : 			// Someone had built something here in an unowned plot, remove effects of the old improvement
; 6413 : 			if(GetPlayerResponsibleForImprovement() != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
	cmp	eax, -1
	je	$LN67@setImprove

; 6414 : 			{
; 6415 : 				// Maintenance change!
; 6416 : 				if(MustPayMaintenanceHere(GetPlayerResponsibleForImprovement()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN51@setImprove

; 6417 : 				{
; 6418 : #ifdef AUI_WARNING_FIXES
; 6419 : 					GET_PLAYER(GetPlayerResponsibleForImprovement()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-oldImprovementEntry.GetGoldMaintenance());
; 6420 : #else
; 6421 : 					GET_PLAYER(GetPlayerResponsibleForImprovement()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getImprovementInfo(getImprovementType())->GetGoldMaintenance());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
	mov	DWORD PTR $T249612[ebp], eax
	mov	edx, DWORD PTR $T249612[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249613[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T249613[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN51@setImprove:

; 6422 : #endif
; 6423 : 				}
; 6424 : 
; 6425 : 				SetPlayerResponsibleForImprovement(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForImprovement
$LN67@setImprove:

; 6426 : 			}
; 6427 : 		}
; 6428 : 
; 6429 : 		m_eImprovementType = eNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [eax+441], cl

; 6430 : 
; 6431 : 		if(getImprovementType() == NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	SHORT $LN50@setImprove

; 6432 : 		{
; 6433 : 			setImprovementDuration(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementDuration@CvPlot@@QAEXH@Z	; CvPlot::setImprovementDuration
$LN50@setImprove:

; 6434 : 		}
; 6435 : 
; 6436 : 		// Reset who cleared a Barb camp here last (if we're putting a new one down)
; 6437 : 		if(eNewValue == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T249617[ebp], edx
	mov	eax, DWORD PTR _eNewValue$[ebp]
	cmp	eax, DWORD PTR $T249617[ebp]
	jne	SHORT $LN49@setImprove

; 6438 : 		{
; 6439 : 			SetPlayerThatClearedBarbCampHere(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatClearedBarbCampHere
$LN49@setImprove:

; 6440 : 		}
; 6441 : 
; 6442 : 		setUpgradeProgress(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setUpgradeProgress@CvPlot@@QAEXH@Z	; CvPlot::setUpgradeProgress

; 6443 : 
; 6444 : #ifndef AUI_PLOT_FIX_PILLAGED_PLOT_ON_NEW_IMPROVEMENT
; 6445 : 		// make sure this plot is not disabled
; 6446 : 		SetImprovementPillaged(false);
; 6447 : #endif
; 6448 : 
; 6449 : 		for(iI = 0; iI < MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN48@setImprove
$LN47@setImprove:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN48@setImprove:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN46@setImprove

; 6450 : 		{
; 6451 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 6452 : 			if (iI == OBSERVER_TEAM || GET_TEAM((TeamTypes)iI).isAlive())
; 6453 : #else
; 6454 : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249621[ebp], edx
	mov	eax, DWORD PTR $T249621[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN45@setImprove

; 6455 : #endif
; 6456 : 			{
; 6457 : 				if(isVisible((TeamTypes)iI))

	cmp	DWORD PTR _iI$[ebp], -1
	jne	SHORT $LN170@setImprove
	mov	BYTE PTR $T249634[ebp], 0
	jmp	SHORT $LN168@setImprove
$LN170@setImprove:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _iI$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T249634[ebp], cl
$LN168@setImprove:
	movzx	edx, BYTE PTR $T249634[ebp]
	test	edx, edx
	je	SHORT $LN45@setImprove

; 6458 : 				{
; 6459 : 					setRevealedImprovementType((TeamTypes)iI, eNewValue);

	mov	eax, DWORD PTR _eNewValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
$LN45@setImprove:

; 6460 : 				}
; 6461 : 			}
; 6462 : 		}

	jmp	$LN47@setImprove
$LN46@setImprove:

; 6463 : 
; 6464 : 		if(m_eImprovementType != NO_IMPROVEMENT)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+441]
	cmp	eax, -1
	je	$LN43@setImprove

; 6465 : 		{
; 6466 : 			CvImprovementEntry& newImprovementEntry = *GC.getImprovementInfo(eNewValue);

	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _newImprovementEntry$224762[ebp], eax

; 6467 : 
; 6468 : 			// If this improvement can add culture to nearby improvements, update them as well
; 6469 : 			if(newImprovementEntry.GetCultureAdjacentSameType() > 0)

	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	test	eax, eax
	jle	SHORT $LN42@setImprove

; 6470 : 			{
; 6471 : 				for(iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN41@setImprove
$LN40@setImprove:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN41@setImprove:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN42@setImprove

; 6472 : 				{
; 6473 : 					CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T249638[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T249642[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T249638[ebp]
	push	edx
	mov	eax, DWORD PTR $T249642[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$224767[ebp], eax

; 6474 : 					if(pAdjacentPlot && pAdjacentPlot->getImprovementType() == eNewValue)

	cmp	DWORD PTR _pAdjacentPlot$224767[ebp], 0
	je	SHORT $LN38@setImprove
	mov	ecx, DWORD PTR _pAdjacentPlot$224767[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	jne	SHORT $LN38@setImprove

; 6475 : 					{
; 6476 : 						pAdjacentPlot->updateYield();

	mov	ecx, DWORD PTR _pAdjacentPlot$224767[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN38@setImprove:

; 6477 : 					}
; 6478 : 				}

	jmp	SHORT $LN40@setImprove
$LN42@setImprove:

; 6479 : 			}
; 6480 : 
; 6481 : 			if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN37@setImprove

; 6482 : 			{
; 6483 : 				area()->changeNumImprovements(eNewValue, 1);

	push	1
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
$LN37@setImprove:

; 6484 : 			}
; 6485 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	$LN43@setImprove

; 6486 : 			{
; 6487 : 				CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	eax, DWORD PTR _owningPlayerID$224725[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$224772[ebp], eax

; 6488 : 				owningPlayer.changeImprovementCount(eNewValue, 1);

	push	1
	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _owningPlayer$224772[ebp]
	call	?changeImprovementCount@CvPlayer@@QAEXW4ImprovementTypes@@H@Z ; CvPlayer::changeImprovementCount

; 6489 : 
; 6490 : 				//DLC_04 Achievement
; 6491 : 				if(owningPlayerID == GC.getGame().getActivePlayer() && strncmp(newImprovementEntry.GetType(), "IMPROVEMENT_MOTTE_BAILEY", 64) == 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T249802[ebp], edx
	mov	ecx, DWORD PTR $T249802[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR _owningPlayerID$224725[ebp], eax
	jne	$LN35@setImprove
	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T249806[ebp], eax
	push	64					; 00000040H
	push	OFFSET ??_C@_0BJ@CGEJKJPK@IMPROVEMENT_MOTTE_BAILEY?$AA@
	mov	eax, DWORD PTR $T249806[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@setImprove

; 6492 : 				{
; 6493 : 					//string compares are faster than testing if the mod is activated, so perform this after the compare test.
; 6494 : 					if(gDLL->IsModActivated(CIV5_DLC_04_SCENARIO_MODID))

	mov	ecx, DWORD PTR $T249810[ebp]
	mov	DWORD PTR tv346[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv346[ebp], edx
	mov	eax, DWORD PTR _CIV5_DLC_04_SCENARIO_MODID
	push	eax
	mov	ecx, DWORD PTR tv346[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv346[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@setImprove

; 6495 : 					{
; 6496 : 						gDLL->UnlockAchievement(ACHIEVEMENT_SCENARIO_04_BUILD_MOTTE);

	mov	edx, DWORD PTR $T249814[ebp]
	mov	DWORD PTR tv360[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv360[ebp], eax
	push	157					; 0000009dH
	mov	ecx, DWORD PTR tv360[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv360[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN35@setImprove:

; 6497 : 					}
; 6498 : 				}
; 6499 : 				
; 6500 : 				// XP2 Achievement
; 6501 : 				if (eBuilder != NO_PLAYER && !GC.getGame().isGameMultiPlayer())

	cmp	DWORD PTR _eBuilder$[ebp], -1
	je	$LN33@setImprove
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T249818[ebp], ecx
	mov	ecx, DWORD PTR $T249818[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	$LN33@setImprove

; 6502 : 				{
; 6503 : 					if (GET_PLAYER(eBuilder).isHuman() && GET_PLAYER(eBuilder).isLocalPlayer() && strncmp(newImprovementEntry.GetType(), "IMPROVEMENT_FEITORIA", 64) == 0)

	mov	eax, DWORD PTR _eBuilder$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249822[ebp], eax
	mov	ecx, DWORD PTR $T249822[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	je	$LN33@setImprove
	mov	edx, DWORD PTR _eBuilder$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249826[ebp], edx
	mov	ecx, DWORD PTR $T249826[ebp]
	call	?isLocalPlayer@CvPlayer@@QBE_NXZ	; CvPlayer::isLocalPlayer
	movzx	eax, al
	test	eax, eax
	je	$LN33@setImprove
	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T249830[ebp], eax
	push	64					; 00000040H
	push	OFFSET ??_C@_0BF@ONGHEHDC@IMPROVEMENT_FEITORIA?$AA@
	mov	ecx, DWORD PTR $T249830[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@setImprove

; 6504 : 					{
; 6505 : 						if (owningPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _owningPlayer$224772[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN33@setImprove

; 6506 : 						{
; 6507 : 							PlayerTypes eAlly = owningPlayer.GetMinorCivAI()->GetAlly();

	mov	ecx, DWORD PTR _owningPlayer$224772[ebp]
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?GetAlly@CvMinorCivAI@@QBE?AW4PlayerTypes@@XZ ; CvMinorCivAI::GetAlly
	mov	DWORD PTR _eAlly$224780[ebp], eax

; 6508 : 							if (eAlly != NO_PLAYER && eAlly != eBuilder)

	cmp	DWORD PTR _eAlly$224780[ebp], -1
	je	SHORT $LN33@setImprove
	mov	eax, DWORD PTR _eAlly$224780[ebp]
	cmp	eax, DWORD PTR _eBuilder$[ebp]
	je	SHORT $LN33@setImprove

; 6509 : 							{
; 6510 : 								gDLL->UnlockAchievement(ACHIEVEMENT_XP2_24);

	mov	ecx, DWORD PTR $T249834[ebp]
	mov	DWORD PTR tv419[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv419[ebp], edx
	push	266					; 0000010aH
	mov	eax, DWORD PTR tv419[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv419[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN33@setImprove:

; 6511 : 							}
; 6512 : 						}
; 6513 : 					}
; 6514 : 				}
; 6515 : 
; 6516 : 				// Maintenance
; 6517 : 				if(MustPayMaintenanceHere(owningPlayerID))

	mov	ecx, DWORD PTR _owningPlayerID$224725[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@setImprove

; 6518 : 				{
; 6519 : 					GET_PLAYER(owningPlayerID).GetTreasury()->ChangeBaseImprovementGoldMaintenance(newImprovementEntry.GetGoldMaintenance());

	mov	eax, DWORD PTR _owningPlayerID$224725[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249838[ebp], eax
	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR $T249838[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN29@setImprove:

; 6520 : 				}
; 6521 : 
; 6522 : 				// Siphon resource changes
; 6523 : 				if(newImprovementEntry.GetLuxuryCopiesSiphonedFromMinor() > 0 && eBuilder != NO_PLAYER)

	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	test	eax, eax
	jle	SHORT $LN28@setImprove
	cmp	DWORD PTR _eBuilder$[ebp], -1
	je	SHORT $LN28@setImprove

; 6524 : 				{
; 6525 : 					if (owningPlayer.isMinorCiv())

	mov	ecx, DWORD PTR _owningPlayer$224772[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN28@setImprove

; 6526 : 					{
; 6527 : 						GET_PLAYER(eBuilder).changeSiphonLuxuryCount(owningPlayerID, newImprovementEntry.GetLuxuryCopiesSiphonedFromMinor());

	mov	edx, DWORD PTR _eBuilder$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249842[ebp], edx
	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	call	?GetLuxuryCopiesSiphonedFromMinor@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetLuxuryCopiesSiphonedFromMinor
	push	eax
	mov	eax, DWORD PTR _owningPlayerID$224725[ebp]
	push	eax
	mov	ecx, DWORD PTR $T249842[ebp]
	call	?changeSiphonLuxuryCount@CvPlayer@@QAEXW4PlayerTypes@@H@Z ; CvPlayer::changeSiphonLuxuryCount
$LN28@setImprove:

; 6528 : 					}
; 6529 : 				}
; 6530 : 
; 6531 : 				// Add Resource Quantity to total
; 6532 : 				if(getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN282@setImprove

; 6533 : 				{
; 6534 : 					if(bIgnoreResourceTechPrereq || GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	movzx	ecx, BYTE PTR _bIgnoreResourceTechPrereq$[ebp]
	test	ecx, ecx
	jne	$LN24@setImprove
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$249851[ebp], eax
	cmp	DWORD PTR _playerID$249851[ebp], -1
	je	SHORT $LN269@setImprove
	mov	ecx, DWORD PTR _playerID$249851[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249859[ebp], eax
	jmp	SHORT $LN270@setImprove
	jmp	SHORT $LN270@setImprove
$LN269@setImprove:
	mov	DWORD PTR $T249859[ebp], -1
$LN270@setImprove:
	mov	edx, DWORD PTR $T249859[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249863[ebp], edx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, DWORD PTR $T249863[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN282@setImprove
$LN24@setImprove:

; 6535 : 					{
; 6536 : 						if(newImprovementEntry.IsImprovementResourceTrade(getResourceType()))

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN282@setImprove

; 6537 : 						{
; 6538 : 							owningPlayer.changeNumResourceTotal(getResourceType(), getNumResourceForPlayer(owningPlayerID));

	push	0
	mov	edx, DWORD PTR _owningPlayerID$224725[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	push	eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _owningPlayer$224772[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6539 : 
; 6540 : 							// Activate Resource city link?
; 6541 : 							if(GetResourceLinkedCity() != NULL && !IsResourceLinkedCityActive())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN282@setImprove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ ; CvPlot::IsResourceLinkedCityActive
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN282@setImprove

; 6542 : 								SetResourceLinkedCityActive(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive

; 6543 : 						}
; 6544 : 					}
; 6545 : 				}
; 6546 : 
; 6547 : 				ResourceTypes eResource = getResourceType(getTeam());

$LN282@setImprove:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$249877[ebp], edx
	cmp	DWORD PTR _playerID$249877[ebp], -1
	je	SHORT $LN279@setImprove
	mov	eax, DWORD PTR _playerID$249877[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249880[ebp], eax
	jmp	SHORT $LN280@setImprove
	jmp	SHORT $LN280@setImprove
$LN279@setImprove:
	mov	DWORD PTR $T249880[ebp], -1
$LN280@setImprove:
	mov	ecx, DWORD PTR $T249880[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$224791[ebp], eax

; 6548 : 				if(bIgnoreResourceTechPrereq)

	movzx	edx, BYTE PTR _bIgnoreResourceTechPrereq$[ebp]
	test	edx, edx
	je	SHORT $LN21@setImprove

; 6549 : 					eResource = getResourceType();

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$224791[ebp], eax
$LN21@setImprove:

; 6550 : 
; 6551 : 				if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$224791[ebp], -1
	je	SHORT $LN43@setImprove

; 6552 : 				{
; 6553 : 					if(newImprovementEntry.IsImprovementResourceTrade(eResource))

	mov	eax, DWORD PTR _eResource$224791[ebp]
	push	eax
	mov	ecx, DWORD PTR _newImprovementEntry$224762[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN43@setImprove

; 6554 : 					{
; 6555 : 						if(GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	edx, DWORD PTR _eResource$224791[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN43@setImprove

; 6556 : 						{
; 6557 : 							owningPlayer.DoUpdateHappiness();

	mov	ecx, DWORD PTR _owningPlayer$224772[ebp]
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN43@setImprove:

; 6558 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6559 : 							owningPlayer.doSelfConsistencyCheckAllCities();
; 6560 : #endif
; 6561 : 						}
; 6562 : 					}
; 6563 : 				}
; 6564 : 			}
; 6565 : 		}
; 6566 : 
; 6567 : 		// If we're removing an Improvement that hooked up a resource then we need to take away the bonus
; 6568 : 		if(eOldImprovement != NO_IMPROVEMENT && !isCity())

	cmp	DWORD PTR _eOldImprovement$[ebp], -1
	je	$LN17@setImprove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	jne	$LN17@setImprove

; 6569 : 		{
; 6570 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	ecx, al
	test	ecx, ecx
	je	$LN17@setImprove

; 6571 : 			{
; 6572 : 				CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	edx, DWORD PTR _owningPlayerID$224725[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$224798[ebp], edx

; 6573 : 				// Remove Resource Quantity from total
; 6574 : 				if(getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN307@setImprove

; 6575 : 				{
; 6576 : 					if(IsImprovedByGiftFromMajor() || // If old improvement was a gift, it ignored our tech limits, so be sure to remove resources properly
; 6577 : 						GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ ; CvPlot::IsImprovedByGiftFromMajor
	movzx	eax, al
	test	eax, eax
	jne	$LN13@setImprove
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$249902[ebp], edx
	cmp	DWORD PTR _playerID$249902[ebp], -1
	je	SHORT $LN294@setImprove
	mov	eax, DWORD PTR _playerID$249902[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249905[ebp], eax
	jmp	SHORT $LN295@setImprove
	jmp	SHORT $LN295@setImprove
$LN294@setImprove:
	mov	DWORD PTR $T249905[ebp], -1
$LN295@setImprove:
	mov	ecx, DWORD PTR $T249905[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249909[ebp], ecx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, DWORD PTR $T249909[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN307@setImprove
$LN13@setImprove:

; 6578 : 					{
; 6579 : 						if(GC.getImprovementInfo(eOldImprovement)->IsImprovementResourceTrade(getResourceType()))

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	eax, DWORD PTR _eOldImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN307@setImprove

; 6580 : 						{
; 6581 : 							owningPlayer.changeNumResourceTotal(getResourceType(), -getNumResourceForPlayer(owningPlayerID));

	push	0
	mov	edx, DWORD PTR _owningPlayerID$224725[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	neg	eax
	push	eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _owningPlayer$224798[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6582 : 
; 6583 : 							// Disconnect resource link
; 6584 : 							if(GetResourceLinkedCity() != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN307@setImprove

; 6585 : 								SetResourceLinkedCityActive(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive

; 6586 : 						}
; 6587 : 					}
; 6588 : 				}
; 6589 : 
; 6590 : 				ResourceTypes eResource = getResourceType(getTeam());

$LN307@setImprove:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$249923[ebp], ecx
	cmp	DWORD PTR _playerID$249923[ebp], -1
	je	SHORT $LN304@setImprove
	mov	edx, DWORD PTR _playerID$249923[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249926[ebp], eax
	jmp	SHORT $LN305@setImprove
	jmp	SHORT $LN305@setImprove
$LN304@setImprove:
	mov	DWORD PTR $T249926[ebp], -1
$LN305@setImprove:
	mov	eax, DWORD PTR $T249926[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$224805[ebp], eax

; 6591 : 
; 6592 : 				if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$224805[ebp], -1
	je	SHORT $LN17@setImprove

; 6593 : 				{
; 6594 : 					if(GC.getImprovementInfo(eOldImprovement)->IsImprovementResourceTrade(eResource))

	mov	ecx, DWORD PTR _eResource$224805[ebp]
	push	ecx
	mov	edx, DWORD PTR _eOldImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@setImprove

; 6595 : 					{
; 6596 : 						if(GC.getResourceInfo(eResource)->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _eResource$224805[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN17@setImprove

; 6597 : 						{
; 6598 : 							owningPlayer.DoUpdateHappiness();

	mov	ecx, DWORD PTR _owningPlayer$224798[ebp]
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness
$LN17@setImprove:

; 6599 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 6600 : 							owningPlayer.doSelfConsistencyCheckAllCities();
; 6601 : #endif
; 6602 : 						}
; 6603 : 					}
; 6604 : 				}
; 6605 : 			}
; 6606 : 		}
; 6607 : 
; 6608 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6609 : 
; 6610 : 		// Update the amount of a Resource used up by this Improvement
; 6611 : 		if(isOwned() && eNewValue != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@setImprove
	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN7@setImprove

; 6612 : 		{
; 6613 : 			CvPlayer& owningPlayer = GET_PLAYER(owningPlayerID);

	mov	eax, DWORD PTR _owningPlayerID$224725[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$224810[ebp], eax

; 6614 : 			CvImprovementEntry& newImprovementEntry = *GC.getImprovementInfo(eNewValue);

	mov	ecx, DWORD PTR _eNewValue$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _newImprovementEntry$224811[ebp], eax

; 6615 : 			int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResourceInfos$224812[ebp], eax

; 6616 : 			for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$224813[ebp], 0
	jmp	SHORT $LN6@setImprove
$LN5@setImprove:
	mov	edx, DWORD PTR _iResourceLoop$224813[ebp]
	add	edx, 1
	mov	DWORD PTR _iResourceLoop$224813[ebp], edx
$LN6@setImprove:
	mov	eax, DWORD PTR _iResourceLoop$224813[ebp]
	cmp	eax, DWORD PTR _iNumResourceInfos$224812[ebp]
	jge	SHORT $LN7@setImprove

; 6617 : 			{
; 6618 : 				if(newImprovementEntry.GetResourceQuantityRequirement(iResourceLoop) > 0)

	mov	ecx, DWORD PTR _iResourceLoop$224813[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newImprovementEntry$224811[ebp]
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	test	eax, eax
	jle	SHORT $LN3@setImprove

; 6619 : 				{
; 6620 : 					owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, newImprovementEntry.GetResourceQuantityRequirement(iResourceLoop));

	mov	edx, DWORD PTR _iResourceLoop$224813[ebp]
	push	edx
	mov	ecx, DWORD PTR _newImprovementEntry$224811[ebp]
	call	?GetResourceQuantityRequirement@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetResourceQuantityRequirement
	push	eax
	mov	eax, DWORD PTR _iResourceLoop$224813[ebp]
	push	eax
	mov	ecx, DWORD PTR _owningPlayer$224810[ebp]
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN3@setImprove:

; 6621 : 				}
; 6622 : 			}

	jmp	SHORT $LN5@setImprove
$LN7@setImprove:

; 6623 : 		}
; 6624 : 
; 6625 : 		// Update the most recent builder
; 6626 : 		if (GetPlayerThatBuiltImprovement() != eBuilder)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatBuiltImprovement
	cmp	eax, DWORD PTR _eBuilder$[ebp]
	je	SHORT $LN2@setImprove

; 6627 : 		{
; 6628 : 			SetPlayerThatBuiltImprovement(eBuilder);

	mov	ecx, DWORD PTR _eBuilder$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerThatBuiltImprovement
$LN2@setImprove:

; 6629 : 		}
; 6630 : 
; 6631 : 		SetImprovedByGiftFromMajor(bGiftFromMajor); // Assumes that only one tile improvement can be on this plot at a time

	movzx	edx, BYTE PTR _bGiftFromMajor$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovedByGiftFromMajor

; 6632 : 
; 6633 : 		if(GC.getGame().isDebugMode())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T249933[ebp], eax
	mov	ecx, DWORD PTR $T249933[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN71@setImprove

; 6634 : 		{
; 6635 : 			setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN71@setImprove:

; 6636 : 		}
; 6637 : 	}
; 6638 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::setImprovementType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsImprovementPillaged@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsImprovementPillaged@CvPlot@@QBE_NXZ PROC		; CvPlot::IsImprovementPillaged, COMDAT
; _this$ = ecx

; 6643 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6644 : 	return m_bImprovementPillaged;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+461]
	and	al, 1

; 6645 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsImprovementPillaged@CvPlot@@QBE_NXZ ENDP		; CvPlot::IsImprovementPillaged
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetImprovementPillaged@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T249999 = -48						; size = 4
$T249995 = -44						; size = 4
$T249991 = -40						; size = 4
$T249987 = -36						; size = 4
$T249983 = -32						; size = 4
$T249979 = -28						; size = 4
$T249975 = -24						; size = 4
$T249971 = -20						; size = 4
_playerID$249968 = -16					; size = 4
$T249954 = -12						; size = 4
_playerID$249951 = -8					; size = 4
_bWasPillaged$ = -1					; size = 1
_bPillaged$ = 8						; size = 1
?SetImprovementPillaged@CvPlot@@QAEX_N@Z PROC		; CvPlot::SetImprovementPillaged, COMDAT
; _this$ = ecx

; 6649 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 6650 : 	bool bWasPillaged = m_bImprovementPillaged;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	and	cl, 1
	mov	BYTE PTR _bWasPillaged$[ebp], cl

; 6651 : 
; 6652 : 	if(bPillaged != bWasPillaged)

	movzx	edx, BYTE PTR _bPillaged$[ebp]
	movzx	eax, BYTE PTR _bWasPillaged$[ebp]
	cmp	edx, eax
	je	$LN10@SetImprove

; 6653 : 	{
; 6654 : 		m_bImprovementPillaged = bPillaged;

	mov	cl, BYTE PTR _bPillaged$[ebp]
	and	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+461]
	and	al, 254					; 000000feH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+461], al

; 6655 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 6656 : 
; 6657 : 		// Quantified Resource changes
; 6658 : 		if(getResourceType() != NO_RESOURCE && getImprovementType() != NO_IMPROVEMENT)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	$LN10@SetImprove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN10@SetImprove

; 6659 : 		{
; 6660 : 			if(getTeam() != NO_TEAM)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$249951[ebp], eax
	cmp	DWORD PTR _playerID$249951[ebp], -1
	je	SHORT $LN14@SetImprove
	mov	ecx, DWORD PTR _playerID$249951[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249954[ebp], eax
	jmp	SHORT $LN15@SetImprove
	jmp	SHORT $LN15@SetImprove
$LN14@SetImprove:
	mov	DWORD PTR $T249954[ebp], -1
$LN15@SetImprove:
	cmp	DWORD PTR $T249954[ebp], -1
	je	$LN10@SetImprove

; 6661 : 			{
; 6662 : 				if(GET_TEAM(getTeam()).GetTeamTechs()->HasTech((TechTypes) GC.getResourceInfo(getResourceType())->getTechCityTrade()))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$249968[ebp], eax
	cmp	DWORD PTR _playerID$249968[ebp], -1
	je	SHORT $LN22@SetImprove
	mov	ecx, DWORD PTR _playerID$249968[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T249971[ebp], eax
	jmp	SHORT $LN23@SetImprove
	jmp	SHORT $LN23@SetImprove
$LN22@SetImprove:
	mov	DWORD PTR $T249971[ebp], -1
$LN23@SetImprove:
	mov	edx, DWORD PTR $T249971[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T249975[ebp], edx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, DWORD PTR $T249975[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	je	$LN10@SetImprove

; 6663 : 				{
; 6664 : 					if(GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	ecx, al
	test	ecx, ecx
	je	$LN10@SetImprove

; 6665 : 					{
; 6666 : 						if(bPillaged)

	movzx	edx, BYTE PTR _bPillaged$[ebp]
	test	edx, edx
	je	SHORT $LN5@SetImprove

; 6667 : 						{
; 6668 : 							GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), -getNumResourceForPlayer(getOwner()));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T249979[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T249983[ebp], eax
	mov	ecx, DWORD PTR $T249983[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249987[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T249979[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	neg	eax
	push	eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR $T249987[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6669 : 
; 6670 : 							// Disconnect resource link
; 6671 : 							if(GetResourceLinkedCity() != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN4@SetImprove

; 6672 : 								SetResourceLinkedCityActive(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive
$LN4@SetImprove:

; 6673 : 						}
; 6674 : 						else

	jmp	SHORT $LN10@SetImprove
$LN5@SetImprove:

; 6675 : 						{
; 6676 : 							GET_PLAYER(getOwner()).changeNumResourceTotal(getResourceType(), getNumResourceForPlayer(getOwner()));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T249991[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T249995[ebp], eax
	mov	ecx, DWORD PTR $T249995[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T249999[ebp], ecx
	push	0
	mov	edx, DWORD PTR $T249991[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResourceForPlayer@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumResourceForPlayer
	push	eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR $T249999[ebp]
	call	?changeNumResourceTotal@CvPlayer@@QAEXW4ResourceTypes@@H_N@Z ; CvPlayer::changeNumResourceTotal

; 6677 : 
; 6678 : 							// Reconnect resource link
; 6679 : 							if(GetResourceLinkedCity() != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	test	eax, eax
	je	SHORT $LN10@SetImprove

; 6680 : 								SetResourceLinkedCityActive(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive
$LN10@SetImprove:

; 6681 : 						}
; 6682 : 					}
; 6683 : 				}
; 6684 : 			}
; 6685 : 		}
; 6686 : 	}
; 6687 : 
; 6688 : 	if(bWasPillaged != m_bImprovementPillaged)

	movzx	eax, BYTE PTR _bWasPillaged$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 1
	movzx	ecx, dl
	cmp	eax, ecx
	je	SHORT $LN11@SetImprove

; 6689 : 	{
; 6690 : 		setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN11@SetImprove:

; 6691 : 	}
; 6692 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetImprovementPillaged@CvPlot@@QAEX_N@Z ENDP		; CvPlot::SetImprovementPillaged
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ PROC		; CvPlot::IsImprovedByGiftFromMajor, COMDAT
; _this$ = ecx

; 6696 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6697 : 	return m_bImprovedByGiftFromMajor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	shr	al, 5
	and	al, 1

; 6698 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ ENDP		; CvPlot::IsImprovedByGiftFromMajor
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z PROC	; CvPlot::SetImprovedByGiftFromMajor, COMDAT
; _this$ = ecx

; 6702 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6703 : 	m_bImprovedByGiftFromMajor = bValue;

	mov	al, BYTE PTR _bValue$[ebp]
	and	al, 1
	shl	al, 5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 223					; 000000dfH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 6704 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetImprovedByGiftFromMajor@CvPlot@@QAEX_N@Z ENDP	; CvPlot::SetImprovedByGiftFromMajor
_TEXT	ENDS
PUBLIC	?HasSpecialImprovement@CvPlot@@QBE_NXZ		; CvPlot::HasSpecialImprovement
; Function compile flags: /Odtp
;	COMDAT ?HasSpecialImprovement@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T250012 = -16						; size = 4
_pImprovementInfo$224856 = -12				; size = 4
_pOwner$224851 = -8					; size = 4
_eImprovement$ = -4					; size = 4
?HasSpecialImprovement@CvPlot@@QBE_NXZ PROC		; CvPlot::HasSpecialImprovement, COMDAT
; _this$ = ecx

; 6709 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 6710 : 	// Gifted improvements (if we are a minor civ)
; 6711 : 	if (getOwner() != NO_PLAYER)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -1
	je	SHORT $LN5@HasSpecial

; 6712 : 	{
; 6713 : 		CvPlayer* pOwner = &GET_PLAYER(getOwner());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T250012[ebp], eax
	mov	ecx, DWORD PTR $T250012[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _pOwner$224851[ebp], ecx

; 6714 : 		if (pOwner->isMinorCiv())

	mov	ecx, DWORD PTR _pOwner$224851[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@HasSpecial

; 6715 : 		{
; 6716 : 			if (IsImprovedByGiftFromMajor())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovedByGiftFromMajor@CvPlot@@QBE_NXZ ; CvPlot::IsImprovedByGiftFromMajor
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@HasSpecial

; 6717 : 			{
; 6718 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@HasSpecial
$LN5@HasSpecial:

; 6719 : 			}
; 6720 : 		}
; 6721 : 	}
; 6722 : 
; 6723 : 	// Great person improvements
; 6724 : 	ImprovementTypes eImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 6725 : 	if (eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN2@HasSpecial

; 6726 : 	{
; 6727 : 		CvImprovementEntry* pImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovementInfo$224856[ebp], eax

; 6728 : 		if (pImprovementInfo && pImprovementInfo->IsCreatedByGreatPerson())

	cmp	DWORD PTR _pImprovementInfo$224856[ebp], 0
	je	SHORT $LN2@HasSpecial
	mov	ecx, DWORD PTR _pImprovementInfo$224856[ebp]
	call	?IsCreatedByGreatPerson@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsCreatedByGreatPerson
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@HasSpecial

; 6729 : 		{
; 6730 : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@HasSpecial
$LN2@HasSpecial:

; 6731 : 		}
; 6732 : 	}
; 6733 : 
; 6734 : 	return false;

	xor	al, al
$LN6@HasSpecial:

; 6735 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasSpecialImprovement@CvPlot@@QBE_NXZ ENDP		; CvPlot::HasSpecialImprovement
_TEXT	ENDS
PUBLIC	?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ	; CvPlot::IsBarbarianCampNotConverting
; Function compile flags: /Odtp
;	COMDAT ?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ PROC	; CvPlot::IsBarbarianCampNotConverting, COMDAT
; _this$ = ecx

; 6739 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6740 : 	return m_bBarbCampNotConverting;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	shr	al, 2
	and	al, 1

; 6741 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsBarbarianCampNotConverting@CvPlot@@QBE_NXZ ENDP	; CvPlot::IsBarbarianCampNotConverting
_TEXT	ENDS
PUBLIC	?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z	; CvPlot::SetBarbarianCampNotConverting
; Function compile flags: /Odtp
;	COMDAT ?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bNotConverting$ = 8					; size = 1
?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z PROC	; CvPlot::SetBarbarianCampNotConverting, COMDAT
; _this$ = ecx

; 6745 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6746 : 	m_bBarbCampNotConverting = bNotConverting;

	mov	al, BYTE PTR _bNotConverting$[ebp]
	and	al, 1
	shl	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 251					; 000000fbH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 6747 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBarbarianCampNotConverting@CvPlot@@QAEX_N@Z ENDP	; CvPlot::SetBarbarianCampNotConverting
_TEXT	ENDS
PUBLIC	?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ ; CvPlot::GetWorldAnchor
; Function compile flags: /Odtp
;	COMDAT ?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ PROC ; CvPlot::GetWorldAnchor, COMDAT
; _this$ = ecx

; 6751 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6752 : 	return (GenericWorldAnchorTypes) m_eWorldAnchor;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+448]

; 6753 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorldAnchor@CvPlot@@QBE?AW4GenericWorldAnchorTypes@@XZ ENDP ; CvPlot::GetWorldAnchor
_TEXT	ENDS
PUBLIC	?GetWorldAnchorData@CvPlot@@QBEHXZ		; CvPlot::GetWorldAnchorData
; Function compile flags: /Odtp
;	COMDAT ?GetWorldAnchorData@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorldAnchorData@CvPlot@@QBEHXZ PROC			; CvPlot::GetWorldAnchorData, COMDAT
; _this$ = ecx

; 6757 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6758 : 	return (int) m_cWorldAnchorData;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+449]

; 6759 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorldAnchorData@CvPlot@@QBEHXZ ENDP			; CvPlot::GetWorldAnchorData
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z
_TEXT	SEGMENT
tv128 = -32						; size = 4
tv76 = -28						; size = 4
_this$ = -24						; size = 4
$T250044 = -20						; size = 4
$T250040 = -16						; size = 4
$T250033 = -12						; size = 4
$T250029 = -8						; size = 4
_eOldAnchor$ = -4					; size = 4
_eAnchor$ = 8						; size = 4
_iData1$ = 12						; size = 4
?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z PROC ; CvPlot::SetWorldAnchor, COMDAT
; _this$ = ecx

; 6763 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 6764 : 	GenericWorldAnchorTypes eOldAnchor = (GenericWorldAnchorTypes) m_eWorldAnchor;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+448]
	mov	DWORD PTR _eOldAnchor$[ebp], ecx

; 6765 : 
; 6766 : 	// Set the new anchor
; 6767 : 	m_eWorldAnchor = eAnchor;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _eAnchor$[ebp]
	mov	BYTE PTR [edx+448], al

; 6768 : 	m_cWorldAnchorData = iData1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _iData1$[ebp]
	mov	BYTE PTR [ecx+449], dl

; 6769 : 
; 6770 : 	// Remove old
; 6771 : 	if(eOldAnchor != NO_WORLD_ANCHOR)

	cmp	DWORD PTR _eOldAnchor$[ebp], -1
	je	SHORT $LN2@SetWorldAn

; 6772 : 		gDLL->GameplayWorldAnchor(eOldAnchor, /*bAdd*/ false, getX(), getY(), iData1);

	mov	eax, DWORD PTR $T250029[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T250033[ebp], eax
	mov	ecx, DWORD PTR _iData1$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250033[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	0
	mov	edx, DWORD PTR _eOldAnchor$[ebp]
	push	edx
	mov	eax, DWORD PTR tv76[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv76[ebp]
	mov	eax, DWORD PTR [edx+792]
	call	eax
$LN2@SetWorldAn:

; 6773 : 
; 6774 : 	// Add new
; 6775 : 	if(eAnchor == WORLD_ANCHOR_NATURAL_WONDER)

	cmp	DWORD PTR _eAnchor$[ebp], 0
	jne	SHORT $LN3@SetWorldAn

; 6776 : 		gDLL->GameplayWorldAnchor(eAnchor, /*bAdd*/ true, getX(), getY(), iData1);

	mov	ecx, DWORD PTR $T250040[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T250044[ebp], ecx
	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	eax, DWORD PTR $T250044[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	1
	mov	eax, DWORD PTR _eAnchor$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv128[ebp]
	mov	eax, DWORD PTR [edx+792]
	call	eax
$LN3@SetWorldAn:

; 6777 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z ENDP ; CvPlot::SetWorldAnchor
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ PROC	; CvPlot::getRouteType, COMDAT
; _this$ = ecx

; 6782 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6783 : 	return (RouteTypes)m_eRouteType;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+447]

; 6784 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ENDP	; CvPlot::getRouteType
_TEXT	ENDS
PUBLIC	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
PUBLIC	?SetRoutePillaged@CvPlot@@QAEX_N@Z		; CvPlot::SetRoutePillaged
EXTRN	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z:PROC ; CvRouteInfo::getResourceQuantityRequirement
; Function compile flags: /Odtp
;	COMDAT ?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T250121 = -109						; size = 1
$T250108 = -108						; size = 4
$T250104 = -104						; size = 4
$T250100 = -100						; size = 4
$T250096 = -96						; size = 4
$T250089 = -92						; size = 4
$T250080 = -84						; size = 4
$T250079 = -80						; size = 4
$T250075 = -76						; size = 4
$T250071 = -72						; size = 4
$T250067 = -68						; size = 4
$T250060 = -64						; size = 4
_iRequiredResources$224922 = -56			; size = 4
_iResourceLoop$224918 = -52				; size = 4
_owningPlayer$224915 = -48				; size = 4
_iNumResourceInfos$224917 = -44				; size = 4
_newRouteInfo$224913 = -40				; size = 4
_pkRouteInfo$224910 = -36				; size = 4
_iRequiredResources$224905 = -32			; size = 4
_iResourceLoop$224901 = -28				; size = 4
_oldRouteInfo$224897 = -24				; size = 4
_owningPlayer$224898 = -20				; size = 4
_iNumResourceInfos$224900 = -16				; size = 4
_bOldRoute$ = -9					; size = 1
_eOldRoute$ = -8					; size = 4
_iI$ = -4						; size = 4
_eNewValue$ = 8						; size = 4
?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z PROC		; CvPlot::setRouteType, COMDAT
; _this$ = ecx

; 6789 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 6790 : 	bool bOldRoute;
; 6791 : 	RouteTypes eOldRoute = getRouteType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eOldRoute$[ebp], eax

; 6792 : 	int iI;
; 6793 : 
; 6794 : 	if(eOldRoute != eNewValue || (eOldRoute == eNewValue && IsRoutePillaged()))

	mov	eax, DWORD PTR _eOldRoute$[ebp]
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	jne	SHORT $LN23@setRouteTy
	mov	ecx, DWORD PTR _eOldRoute$[ebp]
	cmp	ecx, DWORD PTR _eNewValue$[ebp]
	jne	$LN25@setRouteTy
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	edx, al
	test	edx, edx
	je	$LN25@setRouteTy
$LN23@setRouteTy:

; 6795 : 	{
; 6796 : 		bOldRoute = isRoute(); // XXX is this right???

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRoute@CvPlot@@QBE_NXZ		; CvPlot::isRoute
	mov	BYTE PTR _bOldRoute$[ebp], al

; 6797 : 
; 6798 : 		// Remove old effects
; 6799 : 		if(eOldRoute != NO_ROUTE && !isCity())

	cmp	DWORD PTR _eOldRoute$[ebp], -1
	je	$LN22@setRouteTy
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	jne	$LN22@setRouteTy

; 6800 : 		{
; 6801 : 			// Owned by someone
; 6802 : 			if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	ecx, al
	test	ecx, ecx
	je	$LN21@setRouteTy

; 6803 : 			{
; 6804 : 				CvRouteInfo& oldRouteInfo = *GC.getRouteInfo(eOldRoute);

	mov	edx, DWORD PTR _eOldRoute$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _oldRouteInfo$224897[ebp], eax

; 6805 : 				CvPlayer& owningPlayer = GET_PLAYER(getOwner());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T250060[ebp], ecx
	mov	edx, DWORD PTR $T250060[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$224898[ebp], edx

; 6806 : 
; 6807 : 				// Maintenance change!
; 6808 : 				if(MustPayMaintenanceHere(getOwner()))

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T250067[ebp], ecx
	mov	edx, DWORD PTR $T250067[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@setRouteTy

; 6809 : 				{
; 6810 : #ifdef AUI_WARNING_FIXES
; 6811 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-oldRouteInfo.GetGoldMaintenance());
; 6812 : #else
; 6813 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T250071[ebp], edx
	mov	eax, DWORD PTR $T250071[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250075[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T250075[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN20@setRouteTy:

; 6814 : #endif
; 6815 : 				}
; 6816 : 
; 6817 : 				// Update the amount of a Resource used up by a Route which was previously here
; 6818 : 				int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResourceInfos$224900[ebp], eax

; 6819 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$224901[ebp], 0
	jmp	SHORT $LN19@setRouteTy
$LN18@setRouteTy:
	mov	ecx, DWORD PTR _iResourceLoop$224901[ebp]
	add	ecx, 1
	mov	DWORD PTR _iResourceLoop$224901[ebp], ecx
$LN19@setRouteTy:
	mov	edx, DWORD PTR _iResourceLoop$224901[ebp]
	cmp	edx, DWORD PTR _iNumResourceInfos$224900[ebp]
	jge	SHORT $LN21@setRouteTy

; 6820 : 				{
; 6821 : 					int iRequiredResources = oldRouteInfo.getResourceQuantityRequirement(iResourceLoop);

	mov	eax, DWORD PTR _iResourceLoop$224901[ebp]
	push	eax
	mov	ecx, DWORD PTR _oldRouteInfo$224897[ebp]
	call	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getResourceQuantityRequirement
	mov	DWORD PTR _iRequiredResources$224905[ebp], eax

; 6822 : 					if(iRequiredResources > 0)

	cmp	DWORD PTR _iRequiredResources$224905[ebp], 0
	jle	SHORT $LN16@setRouteTy

; 6823 : 					{
; 6824 : 						owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, -iRequiredResources);

	mov	ecx, DWORD PTR _iRequiredResources$224905[ebp]
	neg	ecx
	push	ecx
	mov	edx, DWORD PTR _iResourceLoop$224901[ebp]
	push	edx
	mov	ecx, DWORD PTR _owningPlayer$224898[ebp]
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN16@setRouteTy:

; 6825 : 					}
; 6826 : 				}

	jmp	SHORT $LN18@setRouteTy
$LN21@setRouteTy:

; 6827 : 			}
; 6828 : 
; 6829 : 			// Someone built a route here in an unowned plot, remove the effects of it (since we're changing it to something else)
; 6830 : 			if(GetPlayerResponsibleForRoute() != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	cmp	eax, -1
	je	SHORT $LN22@setRouteTy

; 6831 : 			{
; 6832 : 				// Maintenance change!
; 6833 : 				if(MustPayMaintenanceHere(GetPlayerResponsibleForRoute()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@setRouteTy

; 6834 : 				{
; 6835 : 					CvRouteInfo* pkRouteInfo = GC.getRouteInfo(getRouteType());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkRouteInfo$224910[ebp], eax

; 6836 : 					if(pkRouteInfo)

	cmp	DWORD PTR _pkRouteInfo$224910[ebp], 0
	je	SHORT $LN14@setRouteTy

; 6837 : 					{
; 6838 : 						GET_PLAYER(GetPlayerResponsibleForRoute()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pkRouteInfo->GetGoldMaintenance());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	mov	DWORD PTR $T250079[ebp], eax
	mov	ecx, DWORD PTR $T250079[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250080[ebp], ecx
	mov	ecx, DWORD PTR _pkRouteInfo$224910[ebp]
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T250080[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN14@setRouteTy:

; 6839 : 					}
; 6840 : 				}
; 6841 : 
; 6842 : 				SetPlayerResponsibleForRoute(NO_PLAYER);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForRoute
$LN22@setRouteTy:

; 6843 : 			}
; 6844 : 		}
; 6845 : 
; 6846 : 		// Route switch here!
; 6847 : 		m_eRouteType = eNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [edx+447], al

; 6848 : 
; 6849 : 		// Apply new effects
; 6850 : 		if(isOwned() && eNewValue != NO_ROUTE && !isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@setRouteTy
	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	$LN12@setRouteTy
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	jne	$LN12@setRouteTy

; 6851 : 		{
; 6852 : 			CvRouteInfo* newRouteInfo = GC.getRouteInfo(eNewValue);

	mov	eax, DWORD PTR _eNewValue$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _newRouteInfo$224913[ebp], eax

; 6853 : 			if(newRouteInfo)

	cmp	DWORD PTR _newRouteInfo$224913[ebp], 0
	je	$LN12@setRouteTy

; 6854 : 			{
; 6855 : 				CvPlayer& owningPlayer = GET_PLAYER(getOwner());

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T250089[ebp], edx
	mov	eax, DWORD PTR $T250089[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _owningPlayer$224915[ebp], eax

; 6856 : 
; 6857 : 				// Maintenance
; 6858 : 				if(MustPayMaintenanceHere(getOwner()))

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T250096[ebp], edx
	mov	eax, DWORD PTR $T250096[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@setRouteTy

; 6859 : 				{
; 6860 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(newRouteInfo->GetGoldMaintenance());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T250100[ebp], eax
	mov	ecx, DWORD PTR $T250100[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250104[ebp], ecx
	mov	ecx, DWORD PTR _newRouteInfo$224913[ebp]
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR $T250104[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN10@setRouteTy:

; 6861 : 				}
; 6862 : 
; 6863 : 				// Update the amount of a Resource used up by this Route
; 6864 : 				int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResourceInfos$224917[ebp], eax

; 6865 : 				for(int iResourceLoop = 0; iResourceLoop < iNumResourceInfos; iResourceLoop++)

	mov	DWORD PTR _iResourceLoop$224918[ebp], 0
	jmp	SHORT $LN9@setRouteTy
$LN8@setRouteTy:
	mov	edx, DWORD PTR _iResourceLoop$224918[ebp]
	add	edx, 1
	mov	DWORD PTR _iResourceLoop$224918[ebp], edx
$LN9@setRouteTy:
	mov	eax, DWORD PTR _iResourceLoop$224918[ebp]
	cmp	eax, DWORD PTR _iNumResourceInfos$224917[ebp]
	jge	SHORT $LN12@setRouteTy

; 6866 : 				{
; 6867 : 					int iRequiredResources = newRouteInfo->getResourceQuantityRequirement(iResourceLoop);

	mov	ecx, DWORD PTR _iResourceLoop$224918[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newRouteInfo$224913[ebp]
	call	?getResourceQuantityRequirement@CvRouteInfo@@QBEHH@Z ; CvRouteInfo::getResourceQuantityRequirement
	mov	DWORD PTR _iRequiredResources$224922[ebp], eax

; 6868 : 					if(iRequiredResources > 0)

	cmp	DWORD PTR _iRequiredResources$224922[ebp], 0
	jle	SHORT $LN6@setRouteTy

; 6869 : 					{
; 6870 : 						owningPlayer.changeNumResourceUsed((ResourceTypes) iResourceLoop, iRequiredResources);

	mov	edx, DWORD PTR _iRequiredResources$224922[ebp]
	push	edx
	mov	eax, DWORD PTR _iResourceLoop$224918[ebp]
	push	eax
	mov	ecx, DWORD PTR _owningPlayer$224915[ebp]
	call	?changeNumResourceUsed@CvPlayer@@QAEXW4ResourceTypes@@H@Z ; CvPlayer::changeNumResourceUsed
$LN6@setRouteTy:

; 6871 : 					}
; 6872 : 				}

	jmp	SHORT $LN8@setRouteTy
$LN12@setRouteTy:

; 6873 : 			}
; 6874 : 		}
; 6875 : 
; 6876 : 		// make sure this plot is not disabled
; 6877 : 		SetRoutePillaged(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRoutePillaged@CvPlot@@QAEX_N@Z	; CvPlot::SetRoutePillaged

; 6878 : 
; 6879 : 		for(iI = 0; iI < MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@setRouteTy
$LN4@setRouteTy:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@setRouteTy:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN3@setRouteTy

; 6880 : 		{
; 6881 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 6882 : 			if (iI == OBSERVER_TEAM || GET_TEAM((TeamTypes)iI).isAlive())
; 6883 : #else
; 6884 : 			if(GET_TEAM((TeamTypes)iI).isAlive())

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T250108[ebp], edx
	mov	eax, DWORD PTR $T250108[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@setRouteTy

; 6885 : #endif
; 6886 : 			{
; 6887 : 				if(isVisible((TeamTypes)iI))

	cmp	DWORD PTR _iI$[ebp], -1
	jne	SHORT $LN66@setRouteTy
	mov	BYTE PTR $T250121[ebp], 0
	jmp	SHORT $LN64@setRouteTy
$LN66@setRouteTy:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _iI$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T250121[ebp], cl
$LN64@setRouteTy:
	movzx	edx, BYTE PTR $T250121[ebp]
	test	edx, edx
	je	SHORT $LN2@setRouteTy

; 6888 : 				{
; 6889 : 					setRevealedRouteType((TeamTypes)iI, getRouteType());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
$LN2@setRouteTy:

; 6890 : 				}
; 6891 : 			}
; 6892 : 		}

	jmp	SHORT $LN4@setRouteTy
$LN3@setRouteTy:

; 6893 : 
; 6894 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN25@setRouteTy:

; 6895 : 	}
; 6896 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ENDP		; CvPlot::setRouteType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsRoutePillaged@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRoutePillaged@CvPlot@@QBE_NXZ PROC			; CvPlot::IsRoutePillaged, COMDAT
; _this$ = ecx

; 6900 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6901 : 	return m_bRoutePillaged;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+461]
	shr	al, 1
	and	al, 1

; 6902 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRoutePillaged@CvPlot@@QBE_NXZ ENDP			; CvPlot::IsRoutePillaged
_TEXT	ENDS
EXTRN	?Update@CvCityConnections@@QAEXXZ:PROC		; CvCityConnections::Update
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Odtp
;	COMDAT ?SetRoutePillaged@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T250163 = -36						; size = 4
$T250159 = -29						; size = 1
$T250150 = -28						; size = 4
$T250146 = -21						; size = 1
$T250136 = -20						; size = 4
$T250129 = -16						; size = 4
_ePlayer$224955 = -12					; size = 4
_i$224951 = -8						; size = 4
_iI$224941 = -4						; size = 4
_bPillaged$ = 8						; size = 1
?SetRoutePillaged@CvPlot@@QAEX_N@Z PROC			; CvPlot::SetRoutePillaged, COMDAT
; _this$ = ecx

; 6906 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 6907 : 	if(m_bRoutePillaged != bPillaged)

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 1
	and	cl, 1
	movzx	edx, cl
	movzx	eax, BYTE PTR _bPillaged$[ebp]
	cmp	edx, eax
	je	$LN12@SetRoutePi

; 6908 : 	{
; 6909 : 		for(int iI = 0; iI < MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$224941[ebp], 0
	jmp	SHORT $LN11@SetRoutePi
$LN10@SetRoutePi:
	mov	ecx, DWORD PTR _iI$224941[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$224941[ebp], ecx
$LN11@SetRoutePi:
	cmp	DWORD PTR _iI$224941[ebp], 64		; 00000040H
	jge	SHORT $LN12@SetRoutePi

; 6910 : 		{
; 6911 : #ifdef AUI_PLOT_OBSERVER_SEE_ALL_PLOTS
; 6912 : 			if (iI == OBSERVER_TEAM || (GET_TEAM((TeamTypes)iI).isAlive() && GC.getGame().getActiveTeam() == (TeamTypes)iI))
; 6913 : #else
; 6914 : 			if(GET_TEAM((TeamTypes)iI).isAlive() && GC.getGame().getActiveTeam() == (TeamTypes)iI)

	mov	edx, DWORD PTR _iI$224941[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T250129[ebp], edx
	mov	eax, DWORD PTR $T250129[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN8@SetRoutePi
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250136[ebp], eax
	mov	ecx, DWORD PTR $T250136[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, DWORD PTR _iI$224941[ebp]
	jne	SHORT $LN8@SetRoutePi

; 6915 : #endif
; 6916 : 			{
; 6917 : 				if(isVisible((TeamTypes)iI))

	cmp	DWORD PTR _iI$224941[ebp], -1
	jne	SHORT $LN24@SetRoutePi
	mov	BYTE PTR $T250146[ebp], 0
	jmp	SHORT $LN22@SetRoutePi
$LN24@SetRoutePi:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _iI$224941[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T250146[ebp], dl
$LN22@SetRoutePi:
	movzx	eax, BYTE PTR $T250146[ebp]
	test	eax, eax
	je	SHORT $LN8@SetRoutePi

; 6918 : 				{
; 6919 : 					setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN8@SetRoutePi:

; 6920 : 				}
; 6921 : 			}
; 6922 : 		}

	jmp	$LN10@SetRoutePi
$LN12@SetRoutePi:

; 6923 : 	}
; 6924 : 
; 6925 : 	m_bRoutePillaged = bPillaged;

	mov	cl, BYTE PTR _bPillaged$[ebp]
	and	cl, 1
	shl	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+461]
	and	al, 253					; 000000fdH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+461], al

; 6926 : 
; 6927 : 	if(bPillaged && IsTradeRoute(NO_PLAYER))

	movzx	edx, BYTE PTR _bPillaged$[ebp]
	test	edx, edx
	je	$LN13@SetRoutePi
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@SetRoutePi

; 6928 : 	{
; 6929 : 		for(int i = 0; i < MAX_CIV_PLAYERS; i++)

	mov	DWORD PTR _i$224951[ebp], 0
	jmp	SHORT $LN5@SetRoutePi
$LN4@SetRoutePi:
	mov	ecx, DWORD PTR _i$224951[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$224951[ebp], ecx
$LN5@SetRoutePi:
	cmp	DWORD PTR _i$224951[ebp], 63		; 0000003fH
	jge	SHORT $LN13@SetRoutePi

; 6930 : 		{
; 6931 : 			PlayerTypes ePlayer = (PlayerTypes)i;

	mov	edx, DWORD PTR _i$224951[ebp]
	mov	DWORD PTR _ePlayer$224955[ebp], edx

; 6932 : 			if(GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR _ePlayer$224955[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250150[ebp], eax
	mov	ecx, DWORD PTR $T250150[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T250159[ebp], dl
	movzx	eax, BYTE PTR $T250159[ebp]
	test	eax, eax
	je	SHORT $LN2@SetRoutePi

; 6933 : 			{
; 6934 : 				if(IsTradeRoute(ePlayer))

	mov	ecx, DWORD PTR _ePlayer$224955[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@SetRoutePi

; 6935 : 				{
; 6936 : 					GET_PLAYER(ePlayer).GetCityConnections()->Update();

	mov	eax, DWORD PTR _ePlayer$224955[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250163[ebp], eax
	mov	ecx, DWORD PTR $T250163[ebp]
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	ecx, eax
	call	?Update@CvCityConnections@@QAEXXZ	; CvCityConnections::Update
$LN2@SetRoutePi:

; 6937 : 				}
; 6938 : 			}
; 6939 : 		}

	jmp	SHORT $LN4@SetRoutePi
$LN13@SetRoutePi:

; 6940 : 	}
; 6941 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRoutePillaged@CvPlot@@QAEX_N@Z ENDP			; CvPlot::SetRoutePillaged
_TEXT	ENDS
PUBLIC	?updateCityRoute@CvPlot@@QAEXXZ			; CvPlot::updateCityRoute
EXTRN	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::getBestRoute
; Function compile flags: /Odtp
;	COMDAT ?updateCityRoute@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T250178 = -16						; size = 4
$T250174 = -12						; size = 4
_eCityRoute$ = -4					; size = 4
?updateCityRoute@CvPlot@@QAEXXZ PROC			; CvPlot::updateCityRoute, COMDAT
; _this$ = ecx

; 6945 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 6946 : 	RouteTypes eCityRoute;
; 6947 : 
; 6948 : 	if(isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@updateCity

; 6949 : 	{
; 6950 : 		CvAssertMsg(isOwned(), "isOwned is expected to be true");
; 6951 : 
; 6952 : 		eCityRoute = GET_PLAYER(getOwner()).getBestRoute();

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T250174[ebp], edx
	mov	eax, DWORD PTR $T250174[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250178[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T250178[ebp]
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	mov	DWORD PTR _eCityRoute$[ebp], eax

; 6953 : 
; 6954 : 		if(eCityRoute == NO_ROUTE)

	cmp	DWORD PTR _eCityRoute$[ebp], -1
	jne	SHORT $LN1@updateCity

; 6955 : 		{
; 6956 : 			eCityRoute = ((RouteTypes)(GC.getINITIAL_CITY_ROUTE_TYPE()));

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8448
	mov	DWORD PTR _eCityRoute$[ebp], ecx
$LN1@updateCity:

; 6957 : 		}
; 6958 : 
; 6959 : 		setRouteType(eCityRoute);

	mov	edx, DWORD PTR _eCityRoute$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType
$LN3@updateCity:

; 6960 : 	}
; 6961 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateCityRoute@CvPlot@@QAEXXZ ENDP			; CvPlot::updateCityRoute
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerThatBuiltImprovement, COMDAT
; _this$ = ecx

; 6966 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6967 : 	return (PlayerTypes) m_ePlayerBuiltImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+443]

; 6968 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerThatBuiltImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerThatBuiltImprovement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBuilder$ = 8						; size = 4
?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerThatBuiltImprovement, COMDAT
; _this$ = ecx

; 6973 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6974 : 	m_ePlayerBuiltImprovement = eBuilder;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _eBuilder$[ebp]
	mov	BYTE PTR [eax+443], cl

; 6975 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPlayerThatBuiltImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerThatBuiltImprovement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerResponsibleForImprovement, COMDAT
; _this$ = ecx

; 6980 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6981 : 	return (PlayerTypes) m_ePlayerResponsibleForImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+444]

; 6982 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerResponsibleForImprovement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eNewValue$ = 8						; size = 4
?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerResponsibleForImprovement, COMDAT
; _this$ = ecx

; 6987 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6988 : 	if(GetPlayerResponsibleForImprovement() != eNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForImprovement@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForImprovement
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	je	SHORT $LN2@SetPlayerR

; 6989 : 	{
; 6990 : 		m_ePlayerResponsibleForImprovement = eNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [eax+444], cl
$LN2@SetPlayerR:

; 6991 : 	}
; 6992 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerResponsibleForImprovement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerResponsibleForRoute, COMDAT
; _this$ = ecx

; 6997 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 6998 : 	return (PlayerTypes) m_ePlayerResponsibleForRoute;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+445]

; 6999 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerResponsibleForRoute
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eNewValue$ = 8						; size = 4
?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerResponsibleForRoute, COMDAT
; _this$ = ecx

; 7004 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7005 : 	if(GetPlayerResponsibleForRoute() != eNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	je	SHORT $LN2@SetPlayerR@2

; 7006 : 	{
; 7007 : 		m_ePlayerResponsibleForRoute = eNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [eax+445], cl
$LN2@SetPlayerR@2:

; 7008 : 	}
; 7009 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerResponsibleForRoute
_TEXT	ENDS
PUBLIC	?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerThatClearedBarbCampHere
; Function compile flags: /Odtp
;	COMDAT ?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetPlayerThatClearedBarbCampHere, COMDAT
; _this$ = ecx

; 7013 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7014 : 	return (PlayerTypes) m_ePlayerThatClearedBarbCampHere;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+446]

; 7015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayerThatClearedBarbCampHere@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetPlayerThatClearedBarbCampHere
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eNewValue$ = 8						; size = 4
?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetPlayerThatClearedBarbCampHere, COMDAT
; _this$ = ecx

; 7019 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7020 : 	m_ePlayerThatClearedBarbCampHere = eNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [eax+446], cl

; 7021 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetPlayerThatClearedBarbCampHere@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetPlayerThatClearedBarbCampHere
_TEXT	ENDS
EXTRN	?getCity@@YAPAVCvCity@@UIDInfo@@@Z:PROC		; getCity
; Function compile flags: /Odtp
;	COMDAT ?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ PROC	; CvPlot::GetResourceLinkedCity, COMDAT
; _this$ = ecx

; 7026 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7027 : 	return getCity(m_ResourceLinkedCity);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	mov	edx, DWORD PTR [eax+128]
	push	edx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 7028 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ENDP	; CvPlot::GetResourceLinkedCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T250206 = -12						; size = 4
$T250202 = -8						; size = 8
_pCity$ = 8						; size = 4
?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z PROC	; CvPlot::SetResourceLinkedCity, COMDAT
; _this$ = ecx

; 7033 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 7034 : 	if(GetResourceLinkedCity() != pCity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	cmp	eax, DWORD PTR _pCity$[ebp]
	je	SHORT $LN4@SetResourc

; 7035 : 	{
; 7036 : 		if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN2@SetResourc

; 7037 : 		{
; 7038 : 			CvAssertMsg(pCity->getOwner() == getOwner(), "Argument city pNewValue's owner is expected to be the same as the current instance");
; 7039 : 			m_ResourceLinkedCity = pCity->GetIDInfo();

	lea	eax, DWORD PTR $T250202[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], ecx
	mov	DWORD PTR [eax+132], edx

; 7040 : 		}
; 7041 : 		else

	jmp	SHORT $LN4@SetResourc
$LN2@SetResourc:

; 7042 : 		{
; 7043 : 			// Set to inactive BEFORE unassigning linked City
; 7044 : 			SetResourceLinkedCityActive(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive

; 7045 : 
; 7046 : 			m_ResourceLinkedCity.reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	DWORD PTR $T250206[ebp], ecx
	mov	edx, DWORD PTR $T250206[ebp]
	mov	DWORD PTR [edx], -1
	mov	eax, DWORD PTR $T250206[ebp]
	mov	DWORD PTR [eax+4], -1
$LN4@SetResourc:

; 7047 : 		}
; 7048 : 	}
; 7049 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ENDP	; CvPlot::SetResourceLinkedCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ PROC	; CvPlot::IsResourceLinkedCityActive, COMDAT
; _this$ = ecx

; 7054 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7055 : 	return m_bResourceLinkedCityActive;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	shr	al, 4
	and	al, 1

; 7056 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ ENDP	; CvPlot::IsResourceLinkedCityActive
_TEXT	ENDS
EXTRN	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z:PROC ; CvCity::ChangeNumResourceLocal
; Function compile flags: /Odtp
;	COMDAT ?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv82 = -12						; size = 4
_this$ = -8						; size = 4
_iResourceChange$225019 = -4				; size = 4
_bValue$ = 8						; size = 1
?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z PROC	; CvPlot::SetResourceLinkedCityActive, COMDAT
; _this$ = ecx

; 7061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 7062 : 	if(bValue != IsResourceLinkedCityActive())

	movzx	esi, BYTE PTR _bValue$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsResourceLinkedCityActive@CvPlot@@QBE_NXZ ; CvPlot::IsResourceLinkedCityActive
	movzx	eax, al
	cmp	esi, eax
	je	SHORT $LN2@SetResourc@2

; 7063 : 	{
; 7064 : 		m_bResourceLinkedCityActive = bValue;

	mov	cl, BYTE PTR _bValue$[ebp]
	and	cl, 1
	shl	cl, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	and	al, 239					; 000000efH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+462], al

; 7065 : 
; 7066 : 		// Now change num resource local to linked city (new or former)
; 7067 : 
; 7068 : 		FAssertMsg(GetResourceLinkedCity() != NULL, "Resource linked city is null for some reason. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 7069 : 		FAssertMsg(getOwner() != NO_PLAYER, "Owner of a tile with a resource linkned to a city is not valid. Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 7070 : 
; 7071 : 		int iResourceChange = bValue ? getNumResource() : -getNumResource();

	movzx	edx, BYTE PTR _bValue$[ebp]
	test	edx, edx
	je	SHORT $LN4@SetResourc@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN5@SetResourc@2
$LN4@SetResourc@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	neg	eax
	mov	DWORD PTR tv82[ebp], eax
$LN5@SetResourc@2:
	mov	eax, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iResourceChange$225019[ebp], eax

; 7072 : 		GetResourceLinkedCity()->ChangeNumResourceLocal(getResourceType(), iResourceChange);

	mov	ecx, DWORD PTR _iResourceChange$225019[ebp]
	push	ecx
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceLinkedCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::GetResourceLinkedCity
	mov	ecx, eax
	call	?ChangeNumResourceLocal@CvCity@@QAEXW4ResourceTypes@@H@Z ; CvCity::ChangeNumResourceLocal
$LN2@SetResourc@2:

; 7073 : 	}
; 7074 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ENDP	; CvPlot::SetResourceLinkedCityActive
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T250253 = -44						; size = 4
$T250239 = -36						; size = 4
$T250235 = -32						; size = 4
$T250231 = -28						; size = 4
_playerID$250228 = -24					; size = 4
_pLoopCity$225034 = -20					; size = 4
_iJ$225029 = -16					; size = 4
_pBestCity$ = -12					; size = 4
_pLoopPlot$ = -8					; size = 4
_eResource$ = -4					; size = 4
_pCityToExclude$ = 8					; size = 4
?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z PROC ; CvPlot::DoFindCityToLinkResourceTo, COMDAT
; _this$ = ecx

; 7079 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 7080 : 	// Make sure we can actually use this Resource first
; 7081 : 
; 7082 : 	// No resource here period
; 7083 : 	if(getResourceType() == NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	jne	SHORT $LN21@DoFindCity

; 7084 : 		return;

	jmp	$LN15@DoFindCity

; 7085 : 
; 7086 : 	ResourceTypes eResource = getResourceType(getTeam());

$LN21@DoFindCity:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$250228[ebp], ecx
	cmp	DWORD PTR _playerID$250228[ebp], -1
	je	SHORT $LN18@DoFindCity
	mov	edx, DWORD PTR _playerID$250228[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T250231[ebp], eax
	jmp	SHORT $LN19@DoFindCity
	jmp	SHORT $LN19@DoFindCity
$LN18@DoFindCity:
	mov	DWORD PTR $T250231[ebp], -1
$LN19@DoFindCity:
	mov	eax, DWORD PTR $T250231[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 7087 : 
; 7088 : 	// Owner can't see resource here yet
; 7089 : 	if(eResource == NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	jne	SHORT $LN13@DoFindCity

; 7090 : 		return;

	jmp	$LN15@DoFindCity
$LN13@DoFindCity:

; 7091 : 
; 7092 : 	CvCity* pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[ebp], 0

; 7093 : 
; 7094 : 	// Loop through nearby plots to find the closest city to link to
; 7095 : 	CvPlot* pLoopPlot;
; 7096 : 	for(int iJ = 0; iJ < NUM_CITY_PLOTS; iJ++)

	mov	DWORD PTR _iJ$225029[ebp], 0
	jmp	SHORT $LN12@DoFindCity
$LN11@DoFindCity:
	mov	ecx, DWORD PTR _iJ$225029[ebp]
	add	ecx, 1
	mov	DWORD PTR _iJ$225029[ebp], ecx
$LN12@DoFindCity:
	cmp	DWORD PTR _iJ$225029[ebp], 37		; 00000025H
	jge	SHORT $LN10@DoFindCity

; 7097 : 	{
; 7098 : 		// We're not actually looking around a City but Resources have to be within the RANGE of a City, so we can still use this
; 7099 : 		pLoopPlot = plotCity(getX(), getY(), iJ);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T250235[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T250239[ebp], edx
	mov	eax, DWORD PTR _iJ$225029[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250235[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250239[ebp]
	push	edx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 7100 : 
; 7101 : 		if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN9@DoFindCity

; 7102 : 		{
; 7103 : 			CvCity* pLoopCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pLoopCity$225034[ebp], eax

; 7104 : 			if(pLoopCity)

	cmp	DWORD PTR _pLoopCity$225034[ebp], 0
	je	SHORT $LN9@DoFindCity

; 7105 : 			{
; 7106 : 				// Owner of the City must match the owner of the Resource Plot Tile (Don't want to give the Resource to another player!)
; 7107 : 				if(pLoopCity->getOwner() == getOwner())

	mov	eax, DWORD PTR _pLoopCity$225034[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T250253[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	DWORD PTR $T250253[ebp], eax
	jne	SHORT $LN9@DoFindCity

; 7108 : 				{
; 7109 : 					if(pLoopCity != pCityToExclude)

	mov	ecx, DWORD PTR _pLoopCity$225034[ebp]
	cmp	ecx, DWORD PTR _pCityToExclude$[ebp]
	je	SHORT $LN9@DoFindCity

; 7110 : 					{
; 7111 : 						pBestCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$225034[ebp]
	mov	DWORD PTR _pBestCity$[ebp], edx

; 7112 : 
; 7113 : 						break;

	jmp	SHORT $LN10@DoFindCity
$LN9@DoFindCity:

; 7114 : 					}
; 7115 : 				}
; 7116 : 			}
; 7117 : 		}
; 7118 : 	}

	jmp	SHORT $LN11@DoFindCity
$LN10@DoFindCity:

; 7119 : 
; 7120 : 	if(pBestCity != NULL)

	cmp	DWORD PTR _pBestCity$[ebp], 0
	je	SHORT $LN15@DoFindCity

; 7121 : 	{
; 7122 : 		SetResourceLinkedCity(pBestCity);

	mov	eax, DWORD PTR _pBestCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCity@CvPlot@@QAEXPBVCvCity@@@Z ; CvPlot::SetResourceLinkedCity

; 7123 : 
; 7124 : 		// Already have a valid improvement here?
; 7125 : 		if(isCity() || getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@DoFindCity
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN15@DoFindCity
$LN3@DoFindCity:

; 7126 : 		{
; 7127 : 			if(isCity() || GC.getImprovementInfo(getImprovementType())->IsImprovementResourceTrade(getResourceType()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@DoFindCity
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@DoFindCity
$LN1@DoFindCity:

; 7128 : 			{
; 7129 : 				SetResourceLinkedCityActive(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetResourceLinkedCityActive@CvPlot@@QAEX_N@Z ; CvPlot::SetResourceLinkedCityActive
$LN15@DoFindCity:

; 7130 : 			}
; 7131 : 		}
; 7132 : 	}
; 7133 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoFindCityToLinkResourceTo@CvPlot@@QAEXPAVCvCity@@@Z ENDP ; CvPlot::DoFindCityToLinkResourceTo
_TEXT	ENDS
PUBLIC	?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::changePlayerCityRadiusCount
PUBLIC	?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z		; CvPlot::setPlotCity
; Function compile flags: /Odtp
;	COMDAT ?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T250394 = -120						; size = 4
$T250390 = -116						; size = 4
$T250386 = -112						; size = 4
$T250379 = -108						; size = 4
$T250378 = -104						; size = 4
$T250364 = -96						; size = 4
$T250363 = -92						; size = 4
$T250349 = -84						; size = 4
$T250345 = -80						; size = 4
$T250336 = -72						; size = 4
$T250332 = -68						; size = 4
$T250331 = -64						; size = 4
$T250317 = -56						; size = 4
$T250313 = -52						; size = 4
$T250309 = -48						; size = 4
$T250305 = -44						; size = 4
$T250301 = -40						; size = 4
$T250294 = -36						; size = 4
$T250293 = -32						; size = 4
$T250269 = -16						; size = 8
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_pNewValue$ = 8						; size = 4
?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z PROC		; CvPlot::setPlotCity, COMDAT
; _this$ = ecx

; 7137 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 7138 : 	CvPlot* pLoopPlot;
; 7139 : 	int iI;
; 7140 : 
; 7141 : 	if(getPlotCity() != pNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	cmp	eax, DWORD PTR _pNewValue$[ebp]
	je	$LN18@setPlotCit

; 7142 : 	{
; 7143 : 		if(isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	je	$LN16@setPlotCit

; 7144 : 		{
; 7145 : 			// Is a route is here?  If so, we may now need to pay maintenance for it.  Yes, yes, I know, we're removing a city
; 7146 : 			// so most likely the owner will loose the plot shortly, but it is best to keep the costs in sync, else bad things happen
; 7147 : 			// if it doesn't get properly updated (like it has been == negative maintenance costs asserts)
; 7148 : 			if(getRouteType() != NO_ROUTE && getPlotCity()->getOwner() == getOwner())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	$LN15@setPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR $T250293[ebp], eax
	mov	ecx, DWORD PTR $T250293[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T250294[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T250294[ebp], ecx
	jne	SHORT $LN15@setPlotCit

; 7149 : 			{
; 7150 : 				// Maintenance change!
; 7151 : 				if(MustPayMaintenanceHere(getOwner()))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T250301[ebp], eax
	mov	ecx, DWORD PTR $T250301[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@setPlotCit

; 7152 : 				{
; 7153 : #ifdef AUI_WARNING_FIXES
; 7154 : 					CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 7155 : 					if (pRouteInfo)
; 7156 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(pRouteInfo->GetGoldMaintenance());
; 7157 : #else
; 7158 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T250305[ebp], ecx
	mov	edx, DWORD PTR $T250305[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250309[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR $T250309[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN15@setPlotCit:

; 7159 : #endif
; 7160 : 				}
; 7161 : 			}
; 7162 : 
; 7163 : 			for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@setPlotCit
$LN12@setPlotCit:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN13@setPlotCit:
	cmp	DWORD PTR _iI$[ebp], 37			; 00000025H
	jge	SHORT $LN16@setPlotCit

; 7164 : 			{
; 7165 : 				pLoopPlot = plotCity(getX(), getY(), iI);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T250313[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T250317[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T250313[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250317[ebp]
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 7166 : 
; 7167 : 				if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN10@setPlotCit

; 7168 : 				{
; 7169 : 					pLoopPlot->changeCityRadiusCount(-1);

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?changeCityRadiusCount@CvPlot@@QAEXH@Z	; CvPlot::changeCityRadiusCount

; 7170 : 					pLoopPlot->changePlayerCityRadiusCount(getPlotCity()->getOwner(), -1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR $T250331[ebp], eax
	mov	edx, DWORD PTR $T250331[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T250332[ebp], eax
	push	-1
	mov	ecx, DWORD PTR $T250332[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::changePlayerCityRadiusCount
$LN10@setPlotCit:

; 7171 : 				}
; 7172 : 			}

	jmp	SHORT $LN12@setPlotCit
$LN16@setPlotCit:

; 7173 : 		}
; 7174 : 
; 7175 : 		if(pNewValue != NULL)

	cmp	DWORD PTR _pNewValue$[ebp], 0
	je	SHORT $LN9@setPlotCit

; 7176 : 		{
; 7177 : 			m_plotCity = pNewValue->GetIDInfo();

	lea	edx, DWORD PTR $T250269[ebp]
	push	edx
	mov	ecx, DWORD PTR _pNewValue$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+108], edx

; 7178 : 		}
; 7179 : 		else

	jmp	SHORT $LN8@setPlotCit
$LN9@setPlotCit:

; 7180 : 		{
; 7181 : 			m_plotCity.reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	mov	DWORD PTR $T250336[ebp], ecx
	mov	edx, DWORD PTR $T250336[ebp]
	mov	DWORD PTR [edx], -1
	mov	eax, DWORD PTR $T250336[ebp]
	mov	DWORD PTR [eax+4], -1
$LN8@setPlotCit:

; 7182 : 		}
; 7183 : 
; 7184 : 		if(isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@setPlotCit

; 7185 : 		{
; 7186 : 			for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@setPlotCit
$LN5@setPlotCit:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN6@setPlotCit:
	cmp	DWORD PTR _iI$[ebp], 37			; 00000025H
	jge	SHORT $LN4@setPlotCit

; 7187 : 			{
; 7188 : 				pLoopPlot = plotCity(getX(), getY(), iI);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T250345[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T250349[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250345[ebp]
	push	edx
	mov	eax, DWORD PTR $T250349[ebp]
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 7189 : 
; 7190 : 				if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN3@setPlotCit

; 7191 : 				{
; 7192 : 					pLoopPlot->changeCityRadiusCount(1);

	push	1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?changeCityRadiusCount@CvPlot@@QAEXH@Z	; CvPlot::changeCityRadiusCount

; 7193 : 					pLoopPlot->changePlayerCityRadiusCount(getPlotCity()->getOwner(), 1);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR $T250363[ebp], eax
	mov	ecx, DWORD PTR $T250363[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T250364[ebp], edx
	push	1
	mov	eax, DWORD PTR $T250364[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z ; CvPlot::changePlayerCityRadiusCount
$LN3@setPlotCit:

; 7194 : 				}
; 7195 : 			}

	jmp	SHORT $LN5@setPlotCit
$LN4@setPlotCit:

; 7196 : 
; 7197 : 			// Is a route is here?  If we already owned this plot, then we were paying maintenance, now we don't have to.
; 7198 : 			if(getRouteType() != NO_ROUTE && getPlotCity()->getOwner() == getOwner())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	$LN7@setPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR $T250378[ebp], eax
	mov	ecx, DWORD PTR $T250378[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T250379[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T250379[ebp], ecx
	jne	SHORT $LN7@setPlotCit

; 7199 : 			{
; 7200 : 				// Maintenance change!
; 7201 : 				if(MustPayMaintenanceHere(getOwner()))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T250386[ebp], eax
	mov	ecx, DWORD PTR $T250386[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@setPlotCit

; 7202 : 				{
; 7203 : #ifdef AUI_WARNING_FIXES
; 7204 : 					CvRouteInfo* pRouteInfo = GC.getRouteInfo(getRouteType());
; 7205 : 					if (pRouteInfo)
; 7206 : 						GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-pRouteInfo->GetGoldMaintenance());
; 7207 : #else
; 7208 : 					GET_PLAYER(getOwner()).GetTreasury()->ChangeBaseImprovementGoldMaintenance(-GC.getRouteInfo(getRouteType())->GetGoldMaintenance());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T250390[ebp], ecx
	mov	edx, DWORD PTR $T250390[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250394[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	neg	eax
	push	eax
	mov	ecx, DWORD PTR $T250394[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN7@setPlotCit:

; 7209 : #endif
; 7210 : 				}
; 7211 : 			}
; 7212 : 
; 7213 : 		}
; 7214 : 
; 7215 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
$LN18@setPlotCit:

; 7216 : 	}
; 7217 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setPlotCity@CvPlot@@QAEXPAVCvCity@@@Z ENDP		; CvPlot::setPlotCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getWorkingCity, COMDAT
; _this$ = ecx

; 7221 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7222 : 	return getCity(m_workingCity);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	mov	edx, DWORD PTR [eax+112]
	push	edx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 7223 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getWorkingCity
_TEXT	ENDS
PUBLIC	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride
EXTRN	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ:PROC ; CvCityCitizens::DoAddBestCitizenFromUnassigned
EXTRN	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z:PROC ; CvCityCitizens::SetWorkingPlot
EXTRN	?getGameTurnFounded@CvCity@@QBEHXZ:PROC		; CvCity::getGameTurnFounded
EXTRN	?getCityPlotPriority@CvGlobals@@QAEPAHXZ:PROC	; CvGlobals::getCityPlotPriority
; Function compile flags: /Odtp
;	COMDAT ?updateWorkingCity@CvPlot@@QAEXXZ
_TEXT	SEGMENT
tv189 = -76						; size = 4
_this$ = -72						; size = 4
$T250455 = -68						; size = 4
$T250451 = -64						; size = 4
$T250447 = -60						; size = 4
$T250438 = -56						; size = 4
$T250426 = -52						; size = 4
$T250412 = -44						; size = 4
$T250408 = -40						; size = 4
$T250399 = -32						; size = 8
_pOldWorkingCity$ = -24					; size = 4
_pBestCity$ = -20					; size = 4
_iI$ = -16						; size = 4
_iBestPlot$ = -12					; size = 4
_pLoopPlot$ = -8					; size = 4
_pLoopCity$ = -4					; size = 4
?updateWorkingCity@CvPlot@@QAEXXZ PROC			; CvPlot::updateWorkingCity, COMDAT
; _this$ = ecx

; 7228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 7229 : 	CvCity* pOldWorkingCity;
; 7230 : 	CvCity* pLoopCity;
; 7231 : 	CvCity* pBestCity;
; 7232 : 	CvPlot* pLoopPlot;
; 7233 : 	int iBestPlot;
; 7234 : 	int iI;
; 7235 : 
; 7236 : 	pBestCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pBestCity$[ebp], eax

; 7237 : 
; 7238 : 	if(pBestCity == NULL)

	cmp	DWORD PTR _pBestCity$[ebp], 0
	jne	SHORT $LN16@updateWork

; 7239 : 	{
; 7240 : 		pBestCity = getWorkingCityOverride();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride
	mov	DWORD PTR _pBestCity$[ebp], eax
$LN16@updateWork:

; 7241 : 		CvAssertMsg((pBestCity == NULL) || (pBestCity->getOwner() == getOwner()), "pBest city is expected to either be NULL or the current plot instance's");
; 7242 : 	}
; 7243 : 
; 7244 : 	if((pBestCity == NULL) && isOwned())

	cmp	DWORD PTR _pBestCity$[ebp], 0
	jne	$LN15@updateWork
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	$LN15@updateWork

; 7245 : 	{
; 7246 : 		iBestPlot = 0;

	mov	DWORD PTR _iBestPlot$[ebp], 0

; 7247 : 
; 7248 : 		for(iI = 0; iI < NUM_CITY_PLOTS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN14@updateWork
$LN13@updateWork:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN14@updateWork:
	cmp	DWORD PTR _iI$[ebp], 37			; 00000025H
	jge	$LN15@updateWork

; 7249 : 		{
; 7250 : 			pLoopPlot = plotCity(getX(), getY(), iI);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T250408[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T250412[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250408[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250412[ebp]
	push	edx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 7251 : 
; 7252 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	$LN11@updateWork

; 7253 : 			{
; 7254 : 				pLoopCity = pLoopPlot->getPlotCity();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pLoopCity$[ebp], eax

; 7255 : 
; 7256 : 				if(pLoopCity != NULL)

	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN11@updateWork

; 7257 : 				{
; 7258 : 					if(pLoopCity->getOwner() == getOwner())

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T250426[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	DWORD PTR $T250426[ebp], eax
	jne	$LN11@updateWork

; 7259 : 					{
; 7260 : 						// XXX use getGameTurnAcquired() instead???
; 7261 : 						if((pBestCity == NULL) ||
; 7262 : 						        (GC.getCityPlotPriority()[iI] < GC.getCityPlotPriority()[iBestPlot]) ||
; 7263 : 						        ((GC.getCityPlotPriority()[iI] == GC.getCityPlotPriority()[iBestPlot]) &&
; 7264 : 						         ((pLoopCity->getGameTurnFounded() < pBestCity->getGameTurnFounded()) ||
; 7265 : 						          ((pLoopCity->getGameTurnFounded() == pBestCity->getGameTurnFounded()) &&
; 7266 : 						           (pLoopCity->GetID() < pBestCity->GetID())))))

	cmp	DWORD PTR _pBestCity$[ebp], 0
	je	$LN7@updateWork
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	esi, eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _iBestPlot$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	cmp	ecx, DWORD PTR [eax+edx*4]
	jl	SHORT $LN7@updateWork
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	esi, eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCityPlotPriority@CvGlobals@@QAEPAHXZ ; CvGlobals::getCityPlotPriority
	mov	edx, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR _iBestPlot$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	cmp	edx, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN11@updateWork
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	mov	esi, eax
	mov	ecx, DWORD PTR _pBestCity$[ebp]
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	cmp	esi, eax
	jl	SHORT $LN7@updateWork
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	mov	esi, eax
	mov	ecx, DWORD PTR _pBestCity$[ebp]
	call	?getGameTurnFounded@CvCity@@QBEHXZ	; CvCity::getGameTurnFounded
	cmp	esi, eax
	jne	SHORT $LN11@updateWork
	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR $T250438[ebp], ecx
	mov	edx, DWORD PTR _pBestCity$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR $T250447[ebp], eax
	mov	ecx, DWORD PTR $T250438[ebp]
	cmp	ecx, DWORD PTR $T250447[ebp]
	jge	SHORT $LN11@updateWork
$LN7@updateWork:

; 7267 : 						{
; 7268 : 							iBestPlot = iI;

	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _iBestPlot$[ebp], edx

; 7269 : 							pBestCity = pLoopCity;

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestCity$[ebp], eax
$LN11@updateWork:

; 7270 : 						}
; 7271 : 					}
; 7272 : 				}
; 7273 : 			}
; 7274 : 		}

	jmp	$LN13@updateWork
$LN15@updateWork:

; 7275 : 	}
; 7276 : 
; 7277 : 	pOldWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pOldWorkingCity$[ebp], eax

; 7278 : 
; 7279 : 	if(pOldWorkingCity != pBestCity)

	mov	ecx, DWORD PTR _pOldWorkingCity$[ebp]
	cmp	ecx, DWORD PTR _pBestCity$[ebp]
	je	$LN17@updateWork

; 7280 : 	{
; 7281 : 		// Change what City's allowed to work this Plot
; 7282 : 		if(pBestCity != NULL)

	cmp	DWORD PTR _pBestCity$[ebp], 0
	je	SHORT $LN4@updateWork

; 7283 : 		{
; 7284 : 			// Remove Citizen from this plot if another City's using it
; 7285 : 			if(pOldWorkingCity != NULL)

	cmp	DWORD PTR _pOldWorkingCity$[ebp], 0
	je	SHORT $LN3@updateWork

; 7286 : 			{
; 7287 : 				// Remove citizen
; 7288 : 				pOldWorkingCity->GetCityCitizens()->SetWorkingPlot(this, false);

	push	1
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOldWorkingCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?SetWorkingPlot@CvCityCitizens@@QAEXPAVCvPlot@@_N1@Z ; CvCityCitizens::SetWorkingPlot
$LN3@updateWork:

; 7289 : 			}
; 7290 : 
; 7291 : 			CvAssertMsg(isOwned(), "isOwned is expected to be true");
; 7292 : 			CvAssertMsg(!isBeingWorked(), "isBeingWorked did not return false as expected");
; 7293 : 			m_workingCity = pBestCity->GetIDInfo();

	lea	eax, DWORD PTR $T250399[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestCity$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], ecx
	mov	DWORD PTR [eax+116], edx

; 7294 : 
; 7295 : 			// If we told a City to stop working this plot, tell it to do something else instead
; 7296 : 			if(pOldWorkingCity != NULL)

	cmp	DWORD PTR _pOldWorkingCity$[ebp], 0
	je	SHORT $LN2@updateWork

; 7297 : 			{
; 7298 : 				// Re-add citizen somewhere else
; 7299 : 				pOldWorkingCity->GetCityCitizens()->DoAddBestCitizenFromUnassigned();

	mov	ecx, DWORD PTR _pOldWorkingCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?DoAddBestCitizenFromUnassigned@CvCityCitizens@@QAE_NXZ ; CvCityCitizens::DoAddBestCitizenFromUnassigned
$LN2@updateWork:

; 7300 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 7301 : 				pOldWorkingCity->GetCityCitizens()->DoSelfConsistencyCheck();
; 7302 : #endif
; 7303 : 			}
; 7304 : 		}
; 7305 : 		else

	jmp	SHORT $LN1@updateWork
$LN4@updateWork:

; 7306 : 		{
; 7307 : 			m_workingCity.reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T250451[ebp], ecx
	mov	edx, DWORD PTR $T250451[ebp]
	mov	DWORD PTR [edx], -1
	mov	eax, DWORD PTR $T250451[ebp]
	mov	DWORD PTR [eax+4], -1
$LN1@updateWork:

; 7308 : 		}
; 7309 : 
; 7310 : 		updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield

; 7311 : 
; 7312 : 		GC.GetEngineUserInterface()->setDirty(ColoredPlots_DIRTY_BIT, true);

	mov	ecx, DWORD PTR $T250455[ebp]
	mov	DWORD PTR tv189[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv189[ebp], edx
	push	1
	push	24					; 00000018H
	mov	eax, DWORD PTR tv189[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv189[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN17@updateWork:

; 7313 : 	}
; 7314 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?updateWorkingCity@CvPlot@@QAEXXZ ENDP			; CvPlot::updateWorkingCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ PROC	; CvPlot::getWorkingCityOverride, COMDAT
; _this$ = ecx

; 7319 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7320 : 	return getCity(m_workingCityOverride);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR [eax+120]
	push	edx
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 7321 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ENDP	; CvPlot::getWorkingCityOverride
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T250464 = -12						; size = 4
$T250460 = -8						; size = 8
_pNewValue$ = 8						; size = 4
?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z PROC	; CvPlot::setWorkingCityOverride, COMDAT
; _this$ = ecx

; 7326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 7327 : 	if(getWorkingCityOverride() != pNewValue)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride
	cmp	eax, DWORD PTR _pNewValue$[ebp]
	je	SHORT $LN4@setWorking

; 7328 : 	{
; 7329 : 		if(pNewValue != NULL)

	cmp	DWORD PTR _pNewValue$[ebp], 0
	je	SHORT $LN2@setWorking

; 7330 : 		{
; 7331 : 			CvAssertMsg(pNewValue->getOwner() == getOwner(), "Argument city pNewValue's owner is expected to be the same as the current instance");
; 7332 : 			m_workingCityOverride = pNewValue->GetIDInfo();

	lea	eax, DWORD PTR $T250460[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewValue$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], ecx
	mov	DWORD PTR [eax+124], edx

; 7333 : 		}
; 7334 : 		else

	jmp	SHORT $LN1@setWorking
$LN2@setWorking:

; 7335 : 		{
; 7336 : 			m_workingCityOverride.reset();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T250464[ebp], ecx
	mov	edx, DWORD PTR $T250464[ebp]
	mov	DWORD PTR [edx], -1
	mov	eax, DWORD PTR $T250464[ebp]
	mov	DWORD PTR [eax+4], -1
$LN1@setWorking:

; 7337 : 		}
; 7338 : 
; 7339 : 		updateWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity
$LN4@setWorking:

; 7340 : 	}
; 7341 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setWorkingCityOverride@CvPlot@@QAEXPBVCvCity@@@Z ENDP	; CvPlot::setWorkingCityOverride
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getReconCount@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getReconCount@CvPlot@@QBEHXZ PROC			; CvPlot::getReconCount, COMDAT
; _this$ = ecx

; 7345 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7346 : 	return m_iReconCount;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+456]

; 7347 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getReconCount@CvPlot@@QBEHXZ ENDP			; CvPlot::getReconCount
_TEXT	ENDS
PUBLIC	?changeReconCount@CvPlot@@QAEXH@Z		; CvPlot::changeReconCount
; Function compile flags: /Odtp
;	COMDAT ?changeReconCount@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeReconCount@CvPlot@@QAEXH@Z PROC			; CvPlot::changeReconCount, COMDAT
; _this$ = ecx

; 7352 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7353 : 	m_iReconCount = (m_iReconCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+456]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+456], cl

; 7354 : 	CvAssert(getReconCount() >= 0);
; 7355 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeReconCount@CvPlot@@QAEXH@Z ENDP			; CvPlot::changeReconCount
_TEXT	ENDS
PUBLIC	?getRiverCrossingCount@CvPlot@@QBEHXZ		; CvPlot::getRiverCrossingCount
; Function compile flags: /Odtp
;	COMDAT ?getRiverCrossingCount@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRiverCrossingCount@CvPlot@@QBEHXZ PROC		; CvPlot::getRiverCrossingCount, COMDAT
; _this$ = ecx

; 7360 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7361 : 	return m_iRiverCrossingCount;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+457]

; 7362 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getRiverCrossingCount@CvPlot@@QBEHXZ ENDP		; CvPlot::getRiverCrossingCount
_TEXT	ENDS
PUBLIC	?changeRiverCrossingCount@CvPlot@@QAEXH@Z	; CvPlot::changeRiverCrossingCount
; Function compile flags: /Odtp
;	COMDAT ?changeRiverCrossingCount@CvPlot@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeRiverCrossingCount@CvPlot@@QAEXH@Z PROC		; CvPlot::changeRiverCrossingCount, COMDAT
; _this$ = ecx

; 7367 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7368 : 	m_iRiverCrossingCount = (m_iRiverCrossingCount + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+457], cl

; 7369 : 	CvAssert(getRiverCrossingCount() >= 0);
; 7370 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeRiverCrossingCount@CvPlot@@QAEXH@Z ENDP		; CvPlot::changeRiverCrossingCount
_TEXT	ENDS
PUBLIC	?getYield@CvPlot@@QAEPAFXZ			; CvPlot::getYield
; Function compile flags: /Odtp
;	COMDAT ?getYield@CvPlot@@QAEPAFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getYield@CvPlot@@QAEPAFXZ PROC				; CvPlot::getYield, COMDAT
; _this$ = ecx

; 7379 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7380 : 	return m_aiYield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]

; 7381 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getYield@CvPlot@@QAEPAFXZ ENDP				; CvPlot::getYield
_TEXT	ENDS
PUBLIC	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z		; CvPlot::getYield
; Function compile flags: /Odtp
;	COMDAT ?getYield@CvPlot@@QBEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getYield@CvPlot@@QBEHW4YieldTypes@@@Z PROC		; CvPlot::getYield, COMDAT
; _this$ = ecx

; 7386 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 7387 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 7388 : 	CvAssertMsg(eIndex < NUM_YIELD_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 7389 : 	return (int)(m_aiYield[eIndex]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _eIndex$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]

; 7390 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getYield@CvPlot@@QBEHW4YieldTypes@@@Z ENDP		; CvPlot::getYield
_TEXT	ENDS
EXTRN	?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z:PROC ; CvTerrainInfo::getHillsYieldChange
EXTRN	?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z:PROC ; CvFeatureInfo::getHillsYieldChange
EXTRN	?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z:PROC ; CvTerrainInfo::getRiverYieldChange
EXTRN	?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z:PROC ; CvFeatureInfo::getRiverYieldChange
EXTRN	?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z:PROC ; CvBeliefEntry::GetResourceYieldChange
EXTRN	?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetResourceYieldChange
EXTRN	?getYieldChange@CvResourceInfo@@QBEHH@Z:PROC	; CvResourceInfo::getYieldChange
EXTRN	?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z:PROC ; CvBeliefEntry::GetTerrainYieldChange
EXTRN	?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetTerrainYieldChange
EXTRN	?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isYieldNotAdditive
EXTRN	?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z:PROC ; CvBeliefEntry::GetYieldModifierNaturalWonder
EXTRN	?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetYieldModifierNaturalWonder
EXTRN	?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z:PROC ; CvBeliefEntry::GetYieldChangeNaturalWonder
EXTRN	?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetYieldChangeNaturalWonder
EXTRN	?GetFeatureYieldChange@CvGameLeagues@@QAEHW4PlayerTypes@@W4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvGameLeagues::GetFeatureYieldChange
EXTRN	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ:PROC ; CvGame::GetGameLeagues
EXTRN	?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
EXTRN	?getYieldChange@CvFeatureInfo@@QBEHH@Z:PROC	; CvFeatureInfo::getYieldChange
EXTRN	?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z:PROC ; CvBeliefEntry::GetFeatureYieldChange
EXTRN	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z:PROC ; CvBeliefXMLEntries::GetEntry
EXTRN	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ:PROC ; CvGlobals::GetGameBeliefs
EXTRN	?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetFeatureYieldChange
EXTRN	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z:PROC ; CvGameReligions::GetReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
EXTRN	?getLakeChange@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getLakeChange
EXTRN	?getMountainChange@CvYieldInfo@@QBEHXZ:PROC	; CvYieldInfo::getMountainChange
EXTRN	?getHillsChange@CvYieldInfo@@QBEHXZ:PROC	; CvYieldInfo::getHillsChange
EXTRN	?getYield@CvTerrainInfo@@QBEHH@Z:PROC		; CvTerrainInfo::getYield
EXTRN	?GetSecondaryReligionPantheonBelief@CvCityReligions@@QAE?AW4BeliefTypes@@XZ:PROC ; CvCityReligions::GetSecondaryReligionPantheonBelief
EXTRN	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ:PROC ; CvCityReligions::GetReligiousMajority
EXTRN	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ:PROC ; CvCity::GetCityReligions
EXTRN	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z:PROC ; CvGlobals::getYieldInfo
; Function compile flags: /Odtp
;	COMDAT ?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
tv610 = -220						; size = 4
tv490 = -216						; size = 4
tv463 = -212						; size = 4
_this$ = -208						; size = 4
$T250745 = -204						; size = 4
$T250738 = -200						; size = 4
_f$250731 = -194					; size = 1
_f$250722 = -193					; size = 1
$T250713 = -192						; size = 4
_f$250706 = -186					; size = 1
_f$250697 = -185					; size = 1
$T250688 = -184						; size = 4
$T250684 = -180						; size = 4
$T250675 = -176						; size = 4
$T250671 = -172						; size = 4
$T250667 = -168						; size = 4
$T250663 = -164						; size = 4
$T250654 = -160						; size = 4
$T250653 = -156						; size = 4
$T250649 = -152						; size = 4
$T250645 = -148						; size = 4
$T250644 = -144						; size = 4
$T250640 = -140						; size = 4
$T250636 = -136						; size = 4
$T250632 = -132						; size = 4
_f$250620 = -127					; size = 1
_f$250611 = -126					; size = 1
_f$250602 = -125					; size = 1
$T250596 = -124						; size = 4
$T250592 = -120						; size = 4
$T250583 = -116						; size = 4
$T250579 = -112						; size = 4
_f$250567 = -105					; size = 1
$T250561 = -104						; size = 4
_f$250554 = -99						; size = 1
_f$250545 = -98						; size = 1
_f$250536 = -97						; size = 1
$T250530 = -96						; size = 4
$T250526 = -92						; size = 4
$T250511 = -88						; size = 4
_f$250504 = -82						; size = 1
_f$250495 = -81						; size = 1
$T250483 = -80						; size = 4
_iReligionChange$225189 = -76				; size = 4
_pReligion$225187 = -72					; size = 4
_iReligionChange$225182 = -68				; size = 4
_pReligion$225180 = -64					; size = 4
_iReligionMod$225172 = -60				; size = 4
_iReligionChange$225170 = -56				; size = 4
_pReligion$225168 = -52					; size = 4
_iMod$225166 = -48					; size = 4
_iReligionChange$225163 = -44				; size = 4
_pReligion$225161 = -40					; size = 4
_pFeatureInfo$225155 = -36				; size = 4
_iYieldChange$225156 = -32				; size = 4
_pReligion$225150 = -28					; size = 4
_eSecondaryPantheon$ = -24				; size = 4
_pWorkingCity$ = -20					; size = 4
_eMajority$ = -16					; size = 4
_kYield$ = -12						; size = 4
_iYield$ = -8						; size = 4
_eResource$ = -4					; size = 4
_eYield$ = 8						; size = 4
_eTeam$ = 12						; size = 4
_bIgnoreFeature$ = 16					; size = 1
?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::calculateNatureYield, COMDAT
; _this$ = ecx

; 7395 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	DWORD PTR _this$[ebp], ecx

; 7396 : 	ResourceTypes eResource;
; 7397 : 	int iYield;
; 7398 : 	ReligionTypes eMajority = NO_RELIGION;

	mov	DWORD PTR _eMajority$[ebp], -1

; 7399 : 	BeliefTypes eSecondaryPantheon = NO_BELIEF;

	mov	DWORD PTR _eSecondaryPantheon$[ebp], -1

; 7400 : 
; 7401 : 	if(isImpassable() || isMountain())

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN49@calculateN
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN36@calculateN

; 7402 : 	{
; 7403 : 		// No Feature, or the Feature isn't a Natural Wonder (which are impassable but allowed to be worked)
; 7404 : 		if(getFeatureType() == NO_FEATURE || !GC.getFeatureInfo(getFeatureType())->IsNaturalWonder())

$LN49@calculateN:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$250495[ebp], cl
	movsx	edx, BYTE PTR _f$250495[ebp]
	cmp	edx, -1
	je	SHORT $LN33@calculateN
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$250504[ebp], cl
	movsx	edx, BYTE PTR _f$250504[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN36@calculateN
$LN33@calculateN:

; 7405 : 		{
; 7406 : 			return 0;

	xor	eax, eax
	jmp	$LN37@calculateN
$LN36@calculateN:

; 7407 : 		}
; 7408 : 	}
; 7409 : 
; 7410 : 	const CvYieldInfo& kYield = *GC.getYieldInfo(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo
	mov	DWORD PTR _kYield$[ebp], eax

; 7411 : 
; 7412 : 	CvCity* pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$[ebp], eax

; 7413 : 	if(pWorkingCity)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN32@calculateN

; 7414 : 	{
; 7415 : 		eMajority = pWorkingCity->GetCityReligions()->GetReligiousMajority();

	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority
	mov	DWORD PTR _eMajority$[ebp], eax

; 7416 : 		eSecondaryPantheon = pWorkingCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();

	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetSecondaryReligionPantheonBelief@CvCityReligions@@QAE?AW4BeliefTypes@@XZ ; CvCityReligions::GetSecondaryReligionPantheonBelief
	mov	DWORD PTR _eSecondaryPantheon$[ebp], eax
$LN32@calculateN:

; 7417 : 	}
; 7418 : 
; 7419 : 	CvAssertMsg(getTerrainType() != NO_TERRAIN, "TerrainType is not assigned a valid value");
; 7420 : 
; 7421 : 	iYield = GC.getTerrainInfo(getTerrainType())->getYield(eYield);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T250511[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250511[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getYield@CvTerrainInfo@@QBEHH@Z	; CvTerrainInfo::getYield
	mov	DWORD PTR _iYield$[ebp], eax

; 7422 : 
; 7423 : 	if(isHills())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN59@calculateN

; 7424 : 	{
; 7425 : 		iYield += kYield.getHillsChange();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getHillsChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getHillsChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7426 : 	}
; 7427 : 
; 7428 : 	if(isMountain())

$LN59@calculateN:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN30@calculateN

; 7429 : 	{
; 7430 : 		iYield += kYield.getMountainChange();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getMountainChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getMountainChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN30@calculateN:

; 7431 : 	}
; 7432 : 
; 7433 : 	if(isLake())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	eax, al
	test	eax, eax
	je	$LN29@calculateN

; 7434 : 	{
; 7435 : 		iYield += kYield.getLakeChange();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getLakeChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getLakeChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7436 : #ifdef NQ_LAKE_BELIEF_BONUSES
; 7437 : 		if (pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN29@calculateN

; 7438 : 		{
; 7439 : 			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T250526[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250530[ebp], eax
	mov	ecx, DWORD PTR $T250526[ebp]
	push	ecx
	mov	edx, DWORD PTR _eMajority$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T250530[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$225150[ebp], eax

; 7440 : 			if (pReligion)

	cmp	DWORD PTR _pReligion$225150[ebp], 0
	je	SHORT $LN29@calculateN

; 7441 : 			{
; 7442 : 				iYield += pReligion->m_Beliefs.GetFeatureYieldChange(FEATURE_ICE, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pReligion$225150[ebp]
	add	ecx, 152				; 00000098H
	call	?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetFeatureYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7443 : 				if (eSecondaryPantheon != NO_BELIEF)

	cmp	DWORD PTR _eSecondaryPantheon$[ebp], -1
	je	SHORT $LN29@calculateN

; 7444 : 				{
; 7445 : 					iYield += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetFeatureYieldChange(FEATURE_ICE, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _eSecondaryPantheon$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetFeatureYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN29@calculateN:

; 7446 : 				}
; 7447 : 			}
; 7448 : 		}
; 7449 : #endif
; 7450 : 	}
; 7451 : 
; 7452 : 	if(!bIgnoreFeature)

	movzx	eax, BYTE PTR _bIgnoreFeature$[ebp]
	test	eax, eax
	jne	$LN25@calculateN

; 7453 : 	{
; 7454 : 		if(getFeatureType() != NO_FEATURE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$250536[ebp], dl
	movsx	eax, BYTE PTR _f$250536[ebp]
	cmp	eax, -1
	je	$LN25@calculateN

; 7455 : 		{
; 7456 : 			CvFeatureInfo* pFeatureInfo = GC.getFeatureInfo(getFeatureType());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$250545[ebp], dl
	movsx	eax, BYTE PTR _f$250545[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _pFeatureInfo$225155[ebp], eax

; 7457 : 
; 7458 : 			// Some Features REPLACE the Yield of the Plot instead of adding to it
; 7459 : 			int iYieldChange = pFeatureInfo->getYieldChange(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFeatureInfo$225155[ebp]
	call	?getYieldChange@CvFeatureInfo@@QBEHH@Z	; CvFeatureInfo::getYieldChange
	mov	DWORD PTR _iYieldChange$225156[ebp], eax

; 7460 : 
; 7461 : 			// Player Trait
; 7462 : 			if(m_eOwner != NO_PLAYER && getImprovementType() == NO_IMPROVEMENT)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, -1
	je	SHORT $LN23@calculateN
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	SHORT $LN23@calculateN

; 7463 : 			{
; 7464 : 				iYieldChange +=  GET_PLAYER((PlayerTypes)m_eOwner).GetPlayerTraits()->GetUnimprovedFeatureYieldChange(getFeatureType(), eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$250554[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250561[ebp], ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	movsx	eax, BYTE PTR _f$250554[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250561[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetUnimprovedFeatureYieldChange@CvPlayerTraits@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetUnimprovedFeatureYieldChange
	add	eax, DWORD PTR _iYieldChange$225156[ebp]
	mov	DWORD PTR _iYieldChange$225156[ebp], eax
$LN23@calculateN:

; 7465 : 			}
; 7466 : 
; 7467 : 			// Leagues
; 7468 : 			if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN22@calculateN

; 7469 : 			{
; 7470 : 				iYieldChange += GC.getGame().GetGameLeagues()->GetFeatureYieldChange(pWorkingCity->getOwner(), getFeatureType(), eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$250567[ebp], dl
	mov	eax, DWORD PTR _pWorkingCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T250579[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250583[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _f$250567[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250579[ebp]
	push	edx
	mov	ecx, DWORD PTR $T250583[ebp]
	call	?GetGameLeagues@CvGame@@QAEPAVCvGameLeagues@@XZ ; CvGame::GetGameLeagues
	mov	ecx, eax
	call	?GetFeatureYieldChange@CvGameLeagues@@QAEHW4PlayerTypes@@W4FeatureTypes@@W4YieldTypes@@@Z ; CvGameLeagues::GetFeatureYieldChange
	add	eax, DWORD PTR _iYieldChange$225156[ebp]
	mov	DWORD PTR _iYieldChange$225156[ebp], eax
$LN22@calculateN:

; 7471 : 			}
; 7472 : 
; 7473 : 			// Religion
; 7474 : 			if(pWorkingCity != NULL && eMajority != NO_RELIGION)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	$LN21@calculateN
	cmp	DWORD PTR _eMajority$[ebp], -1
	je	$LN21@calculateN

; 7475 : 			{
; 7476 : 				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	eax, DWORD PTR _pWorkingCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T250592[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250596[ebp], edx
	mov	eax, DWORD PTR $T250592[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMajority$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T250596[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$225161[ebp], eax

; 7477 : #ifdef NQ_LAKE_BELIEF_BONUSES
; 7478 : 				if(pReligion && getFeatureType() != FEATURE_ICE)

	cmp	DWORD PTR _pReligion$225161[ebp], 0
	je	$LN21@calculateN
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$250602[ebp], al
	movsx	ecx, BYTE PTR _f$250602[ebp]
	test	ecx, ecx
	je	SHORT $LN21@calculateN

; 7479 : #else
; 7480 : 				if(pReligion)
; 7481 : #endif
; 7482 : 				{
; 7483 : 					int iReligionChange = pReligion->m_Beliefs.GetFeatureYieldChange(getFeatureType(), eYield);

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$250611[ebp], al
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	movsx	edx, BYTE PTR _f$250611[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligion$225161[ebp]
	add	ecx, 152				; 00000098H
	call	?GetFeatureYieldChange@CvReligionBeliefs@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetFeatureYieldChange
	mov	DWORD PTR _iReligionChange$225163[ebp], eax

; 7484 : 					if (eSecondaryPantheon != NO_BELIEF)

	cmp	DWORD PTR _eSecondaryPantheon$[ebp], -1
	je	SHORT $LN19@calculateN

; 7485 : 					{
; 7486 : 						iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetFeatureYieldChange(getFeatureType(), eYield);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$250620[ebp], cl
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	movsx	eax, BYTE PTR _f$250620[ebp]
	push	eax
	mov	ecx, DWORD PTR _eSecondaryPantheon$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetFeatureYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetFeatureYieldChange
	add	eax, DWORD PTR _iReligionChange$225163[ebp]
	mov	DWORD PTR _iReligionChange$225163[ebp], eax
$LN19@calculateN:

; 7487 : 					}
; 7488 : 					iYieldChange += iReligionChange;

	mov	edx, DWORD PTR _iYieldChange$225156[ebp]
	add	edx, DWORD PTR _iReligionChange$225163[ebp]
	mov	DWORD PTR _iYieldChange$225156[ebp], edx
$LN21@calculateN:

; 7489 : 				}
; 7490 : 			}
; 7491 : 			// Natural Wonders
; 7492 : 			if(m_eOwner != NO_PLAYER && pFeatureInfo->IsNaturalWonder())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, -1
	je	$LN18@calculateN
	mov	ecx, DWORD PTR _pFeatureInfo$225155[ebp]
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	edx, al
	test	edx, edx
	je	$LN18@calculateN

; 7493 : 			{
; 7494 : 				int iMod = 0;

	mov	DWORD PTR _iMod$225166[ebp], 0

; 7495 : 
; 7496 : 				// Boost from religion in nearby city?
; 7497 : 				if(pWorkingCity && eMajority != NO_RELIGION)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	$LN17@calculateN
	cmp	DWORD PTR _eMajority$[ebp], -1
	je	$LN17@calculateN

; 7498 : 				{
; 7499 : 					const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	eax, DWORD PTR _pWorkingCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T250632[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250636[ebp], edx
	mov	eax, DWORD PTR $T250632[ebp]
	push	eax
	mov	ecx, DWORD PTR _eMajority$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T250636[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$225168[ebp], eax

; 7500 : 					if(pReligion)

	cmp	DWORD PTR _pReligion$225168[ebp], 0
	je	$LN17@calculateN

; 7501 : 					{
; 7502 : 						int iReligionChange = pReligion->m_Beliefs.GetYieldChangeNaturalWonder(eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligion$225168[ebp]
	add	ecx, 152				; 00000098H
	call	?GetYieldChangeNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldChangeNaturalWonder
	mov	DWORD PTR _iReligionChange$225170[ebp], eax

; 7503 : 						if (eSecondaryPantheon != NO_BELIEF)

	cmp	DWORD PTR _eSecondaryPantheon$[ebp], -1
	je	SHORT $LN15@calculateN

; 7504 : 						{
; 7505 : 							iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldChangeNaturalWonder(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eSecondaryPantheon$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetYieldChangeNaturalWonder@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldChangeNaturalWonder
	add	eax, DWORD PTR _iReligionChange$225170[ebp]
	mov	DWORD PTR _iReligionChange$225170[ebp], eax
$LN15@calculateN:

; 7506 : 						}
; 7507 : 						iYieldChange += iReligionChange;

	mov	edx, DWORD PTR _iYieldChange$225156[ebp]
	add	edx, DWORD PTR _iReligionChange$225170[ebp]
	mov	DWORD PTR _iYieldChange$225156[ebp], edx

; 7508 : 
; 7509 : 						int iReligionMod = pReligion->m_Beliefs.GetYieldModifierNaturalWonder(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pReligion$225168[ebp]
	add	ecx, 152				; 00000098H
	call	?GetYieldModifierNaturalWonder@CvReligionBeliefs@@QBEHW4YieldTypes@@@Z ; CvReligionBeliefs::GetYieldModifierNaturalWonder
	mov	DWORD PTR _iReligionMod$225172[ebp], eax

; 7510 : 						if (eSecondaryPantheon != NO_BELIEF)

	cmp	DWORD PTR _eSecondaryPantheon$[ebp], -1
	je	SHORT $LN14@calculateN

; 7511 : 						{
; 7512 : 							iReligionMod += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetYieldModifierNaturalWonder(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eSecondaryPantheon$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetYieldModifierNaturalWonder@CvBeliefEntry@@QBEHH@Z ; CvBeliefEntry::GetYieldModifierNaturalWonder
	add	eax, DWORD PTR _iReligionMod$225172[ebp]
	mov	DWORD PTR _iReligionMod$225172[ebp], eax
$LN14@calculateN:

; 7513 : 						}
; 7514 : 						iMod += iReligionMod;

	mov	eax, DWORD PTR _iMod$225166[ebp]
	add	eax, DWORD PTR _iReligionMod$225172[ebp]
	mov	DWORD PTR _iMod$225166[ebp], eax
$LN17@calculateN:

; 7515 : 					}
; 7516 : 				}
; 7517 : 
; 7518 : 				iYieldChange += GET_PLAYER((PlayerTypes)m_eOwner).GetPlayerTraits()->GetYieldChangeNaturalWonder(eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250640[ebp], edx
	mov	ecx, DWORD PTR $T250640[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T250644[ebp], eax
	mov	eax, DWORD PTR _eYield$[ebp]
	mov	ecx, DWORD PTR $T250644[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+480]
	mov	DWORD PTR $T250645[ebp], edx
	mov	eax, DWORD PTR _iYieldChange$225156[ebp]
	add	eax, DWORD PTR $T250645[ebp]
	mov	DWORD PTR _iYieldChange$225156[ebp], eax

; 7519 : 
; 7520 : 				iMod += GET_PLAYER((PlayerTypes)m_eOwner).GetPlayerTraits()->GetNaturalWonderYieldModifier();

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250649[ebp], edx
	mov	ecx, DWORD PTR $T250649[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T250653[ebp], eax
	mov	eax, DWORD PTR $T250653[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR $T250654[ebp], ecx
	mov	edx, DWORD PTR _iMod$225166[ebp]
	add	edx, DWORD PTR $T250654[ebp]
	mov	DWORD PTR _iMod$225166[ebp], edx

; 7521 : 				if(iMod > 0)

	cmp	DWORD PTR _iMod$225166[ebp], 0
	jle	SHORT $LN18@calculateN

; 7522 : 				{
; 7523 : 					iYieldChange *= (100 + iMod);

	mov	eax, DWORD PTR _iMod$225166[ebp]
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iYieldChange$225156[ebp]
	mov	DWORD PTR _iYieldChange$225156[ebp], eax

; 7524 : 					iYieldChange /= 100;

	mov	eax, DWORD PTR _iYieldChange$225156[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iYieldChange$225156[ebp], eax
$LN18@calculateN:

; 7525 : 				}
; 7526 : 			}
; 7527 : 			
; 7528 : 			if(pFeatureInfo->isYieldNotAdditive())

	mov	ecx, DWORD PTR _pFeatureInfo$225155[ebp]
	call	?isYieldNotAdditive@CvFeatureInfo@@QBE_NXZ ; CvFeatureInfo::isYieldNotAdditive
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@calculateN

; 7529 : 			{
; 7530 : 				iYield = iYieldChange;

	mov	eax, DWORD PTR _iYieldChange$225156[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7531 : 			}
; 7532 : 			else

	jmp	SHORT $LN25@calculateN
$LN12@calculateN:

; 7533 : 			{
; 7534 : 				iYield += iYieldChange;

	mov	ecx, DWORD PTR _iYield$[ebp]
	add	ecx, DWORD PTR _iYieldChange$225156[ebp]
	mov	DWORD PTR _iYield$[ebp], ecx
$LN25@calculateN:

; 7535 : 			}
; 7536 : 		}
; 7537 : 	}
; 7538 : 
; 7539 : 	// GJS - this was moved after the Feature terrain yield replacement if statement (just above this) to allow yield changes from religion based on terrain with replacement features
; 7540 : 	// Extra yield for religion on this terrain
; 7541 : 	if(pWorkingCity != NULL && eMajority != NO_RELIGION)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	$LN10@calculateN
	cmp	DWORD PTR _eMajority$[ebp], -1
	je	$LN10@calculateN

; 7542 : 	{
; 7543 : 		const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	edx, DWORD PTR _pWorkingCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T250663[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250667[ebp], ecx
	mov	edx, DWORD PTR $T250663[ebp]
	push	edx
	mov	eax, DWORD PTR _eMajority$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250667[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$225180[ebp], eax

; 7544 : 		if(pReligion)

	cmp	DWORD PTR _pReligion$225180[ebp], 0
	je	SHORT $LN10@calculateN

; 7545 : 		{
; 7546 : 			int iReligionChange = pReligion->m_Beliefs.GetTerrainYieldChange(getTerrainType(), eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR $T250671[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250671[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pReligion$225180[ebp]
	add	ecx, 152				; 00000098H
	call	?GetTerrainYieldChange@CvReligionBeliefs@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetTerrainYieldChange
	mov	DWORD PTR _iReligionChange$225182[ebp], eax

; 7547 : 			if (eSecondaryPantheon != NO_BELIEF)

	cmp	DWORD PTR _eSecondaryPantheon$[ebp], -1
	je	SHORT $LN8@calculateN

; 7548 : 			{
; 7549 : 				iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetTerrainYieldChange(getTerrainType(), eYield);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T250675[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250675[ebp]
	push	edx
	mov	eax, DWORD PTR _eSecondaryPantheon$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetTerrainYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetTerrainYieldChange
	add	eax, DWORD PTR _iReligionChange$225182[ebp]
	mov	DWORD PTR _iReligionChange$225182[ebp], eax
$LN8@calculateN:

; 7550 : 			}
; 7551 : 			iYield += iReligionChange;

	mov	ecx, DWORD PTR _iYield$[ebp]
	add	ecx, DWORD PTR _iReligionChange$225182[ebp]
	mov	DWORD PTR _iYield$[ebp], ecx
$LN10@calculateN:

; 7552 : 		}
; 7553 : 	}
; 7554 : 
; 7555 : 	if(eTeam != NO_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	$LN139@calculateN

; 7556 : 	{
; 7557 : 		eResource = getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 7558 : 
; 7559 : 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	$LN139@calculateN

; 7560 : 		{
; 7561 : 			iYield += GC.getResourceInfo(eResource)->getYieldChange(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getYieldChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7562 : 
; 7563 : 			// Extra yield for religion
; 7564 : 			if(pWorkingCity != NULL && eMajority != NO_RELIGION)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	$LN139@calculateN
	cmp	DWORD PTR _eMajority$[ebp], -1
	je	$LN139@calculateN

; 7565 : 			{
; 7566 : 				const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	edx, DWORD PTR _pWorkingCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T250684[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T250688[ebp], ecx
	mov	edx, DWORD PTR $T250684[ebp]
	push	edx
	mov	eax, DWORD PTR _eMajority$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250688[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$225187[ebp], eax

; 7567 : 				if(pReligion)

	cmp	DWORD PTR _pReligion$225187[ebp], 0
	je	SHORT $LN139@calculateN

; 7568 : 				{
; 7569 : 					int iReligionChange = pReligion->m_Beliefs.GetResourceYieldChange(eResource, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligion$225187[ebp]
	add	ecx, 152				; 00000098H
	call	?GetResourceYieldChange@CvReligionBeliefs@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetResourceYieldChange
	mov	DWORD PTR _iReligionChange$225189[ebp], eax

; 7570 : 					if (eSecondaryPantheon != NO_BELIEF)

	cmp	DWORD PTR _eSecondaryPantheon$[ebp], -1
	je	SHORT $LN3@calculateN

; 7571 : 					{
; 7572 : 						iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetResourceYieldChange(eResource, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eSecondaryPantheon$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetResourceYieldChange@CvBeliefEntry@@QBEHHH@Z ; CvBeliefEntry::GetResourceYieldChange
	add	eax, DWORD PTR _iReligionChange$225189[ebp]
	mov	DWORD PTR _iReligionChange$225189[ebp], eax
$LN3@calculateN:

; 7573 : 					}
; 7574 : 					iYield += iReligionChange;

	mov	eax, DWORD PTR _iYield$[ebp]
	add	eax, DWORD PTR _iReligionChange$225189[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7575 : 				}
; 7576 : 			}
; 7577 : 		}
; 7578 : 	}
; 7579 : 
; 7580 : 	if(isRiver())

$LN139@calculateN:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+457]
	xor	eax, eax
	test	edx, edx
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN151@calculateN

; 7581 : 	{
; 7582 : 		iYield += ((bIgnoreFeature || (getFeatureType() == NO_FEATURE)) ? GC.getTerrainInfo(getTerrainType())->getRiverYieldChange(eYield) : GC.getFeatureInfo(getFeatureType())->getRiverYieldChange(eYield));

	movzx	edx, BYTE PTR _bIgnoreFeature$[ebp]
	test	edx, edx
	jne	SHORT $LN39@calculateN
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$250697[ebp], cl
	movsx	edx, BYTE PTR _f$250697[ebp]
	cmp	edx, -1
	je	SHORT $LN39@calculateN
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$250706[ebp], cl
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	movsx	eax, BYTE PTR _f$250706[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getRiverYieldChange@CvFeatureInfo@@QBEHH@Z ; CvFeatureInfo::getRiverYieldChange
	mov	DWORD PTR tv463[ebp], eax
	jmp	SHORT $LN40@calculateN
$LN39@calculateN:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR $T250713[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T250713[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getRiverYieldChange@CvTerrainInfo@@QBEHH@Z ; CvTerrainInfo::getRiverYieldChange
	mov	DWORD PTR tv463[ebp], eax
$LN40@calculateN:
	mov	edx, DWORD PTR _iYield$[ebp]
	add	edx, DWORD PTR tv463[ebp]
	mov	DWORD PTR _iYield$[ebp], edx

; 7583 : 	}
; 7584 : 
; 7585 : 	if(isHills())

$LN151@calculateN:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@calculateN

; 7586 : 	{
; 7587 : 		iYield += ((bIgnoreFeature || (getFeatureType() == NO_FEATURE)) ? GC.getTerrainInfo(getTerrainType())->getHillsYieldChange(eYield) : GC.getFeatureInfo(getFeatureType())->getHillsYieldChange(eYield));

	movzx	eax, BYTE PTR _bIgnoreFeature$[ebp]
	test	eax, eax
	jne	SHORT $LN41@calculateN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$250722[ebp], dl
	movsx	eax, BYTE PTR _f$250722[ebp]
	cmp	eax, -1
	je	SHORT $LN41@calculateN
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$250731[ebp], dl
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _f$250731[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getHillsYieldChange@CvFeatureInfo@@QBEHH@Z ; CvFeatureInfo::getHillsYieldChange
	mov	DWORD PTR tv490[ebp], eax
	jmp	SHORT $LN42@calculateN
$LN41@calculateN:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T250738[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250738[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	ecx, eax
	call	?getHillsYieldChange@CvTerrainInfo@@QBEHH@Z ; CvTerrainInfo::getHillsYieldChange
	mov	DWORD PTR tv490[ebp], eax
$LN42@calculateN:
	mov	eax, DWORD PTR _iYield$[ebp]
	add	eax, DWORD PTR tv490[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN1@calculateN:

; 7588 : 	}
; 7589 : 
; 7590 : 	return std::max(0, iYield);

	mov	DWORD PTR $T250483[ebp], 0
	mov	ecx, DWORD PTR $T250483[ebp]
	cmp	ecx, DWORD PTR _iYield$[ebp]
	jge	SHORT $LN165@calculateN
	lea	edx, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR tv610[ebp], edx
	jmp	SHORT $LN166@calculateN
$LN165@calculateN:
	lea	eax, DWORD PTR $T250483[ebp]
	mov	DWORD PTR tv610[ebp], eax
$LN166@calculateN:
	mov	ecx, DWORD PTR tv610[ebp]
	mov	DWORD PTR $T250745[ebp], ecx
	mov	edx, DWORD PTR $T250745[ebp]
	mov	eax, DWORD PTR [edx]
$LN37@calculateN:

; 7591 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::calculateNatureYield
_TEXT	ENDS
PUBLIC	?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ; CvPlot::calculateBestNatureYield
; Function compile flags: /Odtp
;	COMDAT ?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
tv78 = -20						; size = 4
_this$ = -16						; size = 4
$T250758 = -12						; size = 4
$T250751 = -8						; size = 4
$T250750 = -4						; size = 4
_eIndex$ = 8						; size = 4
_eTeam$ = 12						; size = 4
?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z PROC ; CvPlot::calculateBestNatureYield, COMDAT
; _this$ = ecx

; 7596 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 7597 : 	return std::max(calculateNatureYield(eIndex, eTeam, false), calculateNatureYield(eIndex, eTeam, true));

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR $T250750[ebp], eax
	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR $T250751[ebp], eax
	mov	ecx, DWORD PTR $T250751[ebp]
	cmp	ecx, DWORD PTR $T250750[ebp]
	jge	SHORT $LN5@calculateB
	lea	edx, DWORD PTR $T250750[ebp]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN6@calculateB
$LN5@calculateB:
	lea	eax, DWORD PTR $T250751[ebp]
	mov	DWORD PTR tv78[ebp], eax
$LN6@calculateB:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR $T250758[ebp], ecx
	mov	edx, DWORD PTR $T250758[ebp]
	mov	eax, DWORD PTR [edx]

; 7598 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::calculateBestNatureYield
_TEXT	ENDS
PUBLIC	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::calculateTotalBestNatureYield
; Function compile flags: /Odtp
;	COMDAT ?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z PROC ; CvPlot::calculateTotalBestNatureYield, COMDAT
; _this$ = ecx

; 7603 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 7604 : 	return (calculateBestNatureYield(YIELD_FOOD, eTeam) + calculateBestNatureYield(YIELD_PRODUCTION, eTeam) + calculateBestNatureYield(YIELD_GOLD, eTeam));

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ; CvPlot::calculateBestNatureYield
	mov	esi, eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ; CvPlot::calculateBestNatureYield
	add	esi, eax
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ; CvPlot::calculateBestNatureYield
	add	eax, esi

; 7605 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ENDP ; CvPlot::calculateTotalBestNatureYield
_TEXT	ENDS
PUBLIC	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
PUBLIC	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
EXTRN	?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvBeliefEntry::GetImprovementYieldChange
EXTRN	?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvReligionBeliefs::GetImprovementYieldChange
EXTRN	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetImprovementResourceYield
EXTRN	?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvTeam::getImprovementNoFreshWaterYieldChange
EXTRN	?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvTeam::getImprovementFreshWaterYieldChange
EXTRN	?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvTeam::getImprovementYieldChange
EXTRN	?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvPlayerTraits::GetImprovementYieldChange
EXTRN	?getImprovementYieldChange@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvPlayer::getImprovementYieldChange
EXTRN	?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z:PROC ; CvPolicyEntry::GetImprovementYieldChanges
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
EXTRN	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
EXTRN	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechFreshWaterYieldChanges
EXTRN	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetTechYieldChanges
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
EXTRN	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetRouteYieldChanges
EXTRN	?getNumRouteInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumRouteInfos
EXTRN	?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetFreshWaterYieldChange
EXTRN	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetAdjacentMountainYieldChange
EXTRN	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetAdjacentCityYieldChange
EXTRN	?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetHillsYieldChange
EXTRN	?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetCoastalLandYieldChange
EXTRN	?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetRiverSideYieldChange
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChangePerEra
EXTRN	?GetYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChange
; Function compile flags: /Odtp
;	COMDAT ?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z
_TEXT	SEGMENT
tv507 = -236						; size = 4
_this$ = -232						; size = 4
$T251009 = -228						; size = 4
$T251005 = -224						; size = 4
$T250996 = -220						; size = 4
$T250987 = -216						; size = 4
$T250980 = -212						; size = 4
$T250965 = -208						; size = 4
$T250953 = -204						; size = 4
$T250952 = -200						; size = 4
$T250780 = -116						; size = 4
$T250776 = -112						; size = 4
$T250766 = -108						; size = 4
$T250765 = -104						; size = 20
_eSecondaryPantheon$225281 = -84			; size = 4
_iReligionChange$225280 = -80				; size = 4
_pReligion$225278 = -76					; size = 4
_eMajority$225276 = -72					; size = 4
_kTeam$225269 = -68					; size = 4
_kPlayer$225268 = -64					; size = 4
_pkPolicyEntry$225265 = -60				; size = 4
_ePolicy$225263 = -56					; size = 4
_eRouteType$225248 = -52				; size = 4
_pAdjacentPlot$225234 = -48				; size = 4
_iPlotEra$225222 = -44					; size = 4
_kPlayer$225221 = -40					; size = 4
_iNumEras$225224 = -36					; size = 4
_pWorkingCity$ = -32					; size = 4
_bIsFreshWater$ = -25					; size = 1
_iYield$ = -24						; size = 4
_pImprovement$ = -20					; size = 4
_iYieldChangePerEra$ = -16				; size = 4
_iI$ = -12						; size = 4
_eResource$ = -8					; size = 4
_iBestYield$ = -4					; size = 4
_eImprovement$ = 8					; size = 4
_eYield$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
_bOptimal$ = 20						; size = 1
_eAssumeThisRoute$ = 24					; size = 4
?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z PROC ; CvPlot::calculateImprovementYieldChange, COMDAT
; _this$ = ecx

; 7610 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	mov	DWORD PTR _this$[ebp], ecx

; 7611 : 	ResourceTypes eResource;
; 7612 : 	int iBestYield;
; 7613 : 	int iYield;
; 7614 : #ifdef AUI_WARNING_FIXES
; 7615 : 	uint iI;
; 7616 : #else
; 7617 : 	int iI;
; 7618 : #endif
; 7619 : 
; 7620 : 	CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovement$[ebp], eax

; 7621 : 	if (!pImprovement)

	cmp	DWORD PTR _pImprovement$[ebp], 0
	jne	SHORT $LN45@calculateI

; 7622 : 		return 0;

	xor	eax, eax
	jmp	$LN46@calculateI
$LN45@calculateI:

; 7623 : 
; 7624 : 	iYield = pImprovement->GetYieldChange(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	mov	DWORD PTR _iYield$[ebp], eax

; 7625 : 
; 7626 : 	int iYieldChangePerEra = pImprovement->GetYieldChangePerEra(eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetYieldChangePerEra@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChangePerEra
	mov	DWORD PTR _iYieldChangePerEra$[ebp], eax

; 7627 : 	if (ePlayer != NO_PLAYER && iYieldChangePerEra > 0)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	SHORT $LN44@calculateI
	cmp	DWORD PTR _iYieldChangePerEra$[ebp], 0
	jle	SHORT $LN44@calculateI

; 7628 : 	{
; 7629 : 		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225221[ebp], eax

; 7630 : 
; 7631 : 		int iPlotEra = GetArchaeologicalRecord().m_eEra;

	lea	ecx, DWORD PTR $T250765[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _iPlotEra$225222[ebp], edx

; 7632 : 		int iNumEras = kPlayer.GetCurrentEra() - iPlotEra;

	mov	ecx, DWORD PTR _kPlayer$225221[ebp]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	sub	eax, DWORD PTR _iPlotEra$225222[ebp]
	mov	DWORD PTR _iNumEras$225224[ebp], eax

; 7633 : 
; 7634 : 		if (iPlotEra != NO_ERA && iNumEras > 0)

	cmp	DWORD PTR _iPlotEra$225222[ebp], -1
	je	SHORT $LN44@calculateI
	cmp	DWORD PTR _iNumEras$225224[ebp], 0
	jle	SHORT $LN44@calculateI

; 7635 : 		{
; 7636 : 			iYield += (iNumEras * iYieldChangePerEra);

	mov	eax, DWORD PTR _iNumEras$225224[ebp]
	imul	eax, DWORD PTR _iYieldChangePerEra$[ebp]
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN44@calculateI:

; 7637 : 		}
; 7638 : 	}
; 7639 : 
; 7640 : 	if(isRiverSide())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverSide@CvPlot@@QBE_NXZ		; CvPlot::isRiverSide
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN42@calculateI

; 7641 : 	{
; 7642 : 		iYield += pImprovement->GetRiverSideYieldChange(eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetRiverSideYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetRiverSideYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN42@calculateI:

; 7643 : 	}
; 7644 : 
; 7645 : 	if(isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN50@calculateI

; 7646 : 	{
; 7647 : 		iYield += pImprovement->GetCoastalLandYieldChange(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetCoastalLandYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetCoastalLandYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7648 : 	}
; 7649 : 
; 7650 : 	if(isHills())

$LN50@calculateI:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN40@calculateI

; 7651 : 	{
; 7652 : 		iYield += pImprovement->GetHillsYieldChange(eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetHillsYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetHillsYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN40@calculateI:

; 7653 : 	}
; 7654 : 
; 7655 : 	// Check to see if there's a bonus to apply before doing any looping
; 7656 : 	if(pImprovement->GetAdjacentCityYieldChange(eYield) > 0 ||
; 7657 : 	        pImprovement->GetAdjacentMountainYieldChange(eYield) > 0)

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentCityYieldChange
	test	eax, eax
	jg	SHORT $LN38@calculateI
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentMountainYieldChange
	test	eax, eax
	jle	$LN39@calculateI
$LN38@calculateI:

; 7658 : 	{
; 7659 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN37@calculateI
$LN36@calculateI:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN37@calculateI:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN39@calculateI

; 7660 : 		{
; 7661 : 			CvPlot* pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T250776[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T250780[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T250776[ebp]
	push	edx
	mov	eax, DWORD PTR $T250780[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$225234[ebp], eax

; 7662 : 
; 7663 : 			if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$225234[ebp], 0
	je	SHORT $LN34@calculateI

; 7664 : 			{
; 7665 : 				if(pAdjacentPlot->isCity())

	mov	ecx, DWORD PTR _pAdjacentPlot$225234[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN140@calculateI

; 7666 : 				{
; 7667 : 					// Is the owner of this Plot (with the Improvement) also the owner of an adjacent City?
; 7668 : 					if(pAdjacentPlot->getPlotCity()->getOwner() == getOwner())

	mov	ecx, DWORD PTR _pAdjacentPlot$225234[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR $T250952[ebp], eax
	mov	edx, DWORD PTR $T250952[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T250953[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	DWORD PTR $T250953[ebp], edx
	jne	SHORT $LN32@calculateI

; 7669 : 					{
; 7670 : 						iYield += pImprovement->GetAdjacentCityYieldChange(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetAdjacentCityYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentCityYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN32@calculateI:

; 7671 : 					}
; 7672 : 				}

	jmp	SHORT $LN34@calculateI

; 7673 : 				else if(pAdjacentPlot->isMountain())

$LN140@calculateI:
	mov	ecx, DWORD PTR _pAdjacentPlot$225234[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN34@calculateI

; 7674 : 				{
; 7675 : 					iYield += pImprovement->GetAdjacentMountainYieldChange(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetAdjacentMountainYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetAdjacentMountainYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN34@calculateI:

; 7676 : 				}
; 7677 : 			}
; 7678 : 		}

	jmp	$LN36@calculateI
$LN39@calculateI:

; 7679 : 	}
; 7680 : 
; 7681 : 	if(bOptimal)

	movzx	edx, BYTE PTR _bOptimal$[ebp]
	test	edx, edx
	je	SHORT $LN29@calculateI

; 7682 : 	{
; 7683 : 		iYield += pImprovement->GetFreshWaterYieldChange(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetFreshWaterYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetFreshWaterYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN29@calculateI:

; 7684 : 	}
; 7685 : 
; 7686 : 	if(bOptimal)

	movzx	ecx, BYTE PTR _bOptimal$[ebp]
	test	ecx, ecx
	je	SHORT $LN28@calculateI

; 7687 : 	{
; 7688 : 		iBestYield = 0;

	mov	DWORD PTR _iBestYield$[ebp], 0

; 7689 : 
; 7690 : 		for(iI = 0; iI < GC.getNumRouteInfos(); ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN27@calculateI
$LN26@calculateI:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN27@calculateI:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumRouteInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumRouteInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN25@calculateI

; 7691 : 		{
; 7692 : 			iBestYield = std::max(iBestYield, pImprovement->GetRouteYieldChanges(iI, eYield));

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	mov	DWORD PTR $T250766[ebp], eax
	mov	edx, DWORD PTR _iBestYield$[ebp]
	cmp	edx, DWORD PTR $T250766[ebp]
	jge	SHORT $LN144@calculateI
	lea	eax, DWORD PTR $T250766[ebp]
	mov	DWORD PTR tv507[ebp], eax
	jmp	SHORT $LN145@calculateI
$LN144@calculateI:
	lea	ecx, DWORD PTR _iBestYield$[ebp]
	mov	DWORD PTR tv507[ebp], ecx
$LN145@calculateI:
	mov	edx, DWORD PTR tv507[ebp]
	mov	DWORD PTR $T250965[ebp], edx
	mov	eax, DWORD PTR $T250965[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iBestYield$[ebp], ecx

; 7693 : 		}

	jmp	SHORT $LN26@calculateI
$LN25@calculateI:

; 7694 : 
; 7695 : 		iYield += iBestYield;

	mov	edx, DWORD PTR _iYield$[ebp]
	add	edx, DWORD PTR _iBestYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], edx

; 7696 : 	}
; 7697 : 	else

	jmp	SHORT $LN24@calculateI
$LN28@calculateI:

; 7698 : 	{
; 7699 : 		RouteTypes eRouteType = NO_ROUTE;

	mov	DWORD PTR _eRouteType$225248[ebp], -1

; 7700 : 		if(eAssumeThisRoute != NUM_ROUTE_TYPES)

	cmp	DWORD PTR _eAssumeThisRoute$[ebp], 2
	je	SHORT $LN23@calculateI

; 7701 : 		{
; 7702 : 			eRouteType = eAssumeThisRoute;

	mov	eax, DWORD PTR _eAssumeThisRoute$[ebp]
	mov	DWORD PTR _eRouteType$225248[ebp], eax

; 7703 : 		}
; 7704 : #ifdef AUI_PLOT_FIX_IMPROVEMENT_YIELD_CHANGES_CATCH_PILLAGED_ROUTE
; 7705 : 		else if (!IsRoutePillaged())
; 7706 : #else
; 7707 : 		else

	jmp	SHORT $LN22@calculateI
$LN23@calculateI:

; 7708 : #endif
; 7709 : 		{
; 7710 : 			eRouteType = getRouteType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eRouteType$225248[ebp], eax
$LN22@calculateI:

; 7711 : 		}
; 7712 : 
; 7713 : 		if(eRouteType != NO_ROUTE)

	cmp	DWORD PTR _eRouteType$225248[ebp], -1
	je	SHORT $LN24@calculateI

; 7714 : 		{
; 7715 : 			iYield += pImprovement->GetRouteYieldChanges(eRouteType, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eRouteType$225248[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN24@calculateI:

; 7716 : 		}
; 7717 : 	}
; 7718 : 
; 7719 : 	bool bIsFreshWater = isFreshWater();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater
	mov	BYTE PTR _bIsFreshWater$[ebp], al

; 7720 : 
; 7721 : 	if(bOptimal || ePlayer == NO_PLAYER)

	movzx	eax, BYTE PTR _bOptimal$[ebp]
	test	eax, eax
	jne	SHORT $LN19@calculateI
	cmp	DWORD PTR _ePlayer$[ebp], -1
	jne	$LN146@calculateI
$LN19@calculateI:

; 7722 : 	{
; 7723 : 		for(iI = 0; iI < GC.getNumTechInfos(); ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN18@calculateI
$LN17@calculateI:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN18@calculateI:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN16@calculateI

; 7724 : 		{
; 7725 : 			iYield += pImprovement->GetTechYieldChanges(iI, eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetTechYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechYieldChanges
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7726 : 
; 7727 : 			if(bIsFreshWater)

	movzx	ecx, BYTE PTR _bIsFreshWater$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@calculateI

; 7728 : 			{
; 7729 : 				iYield += pImprovement->GetTechFreshWaterYieldChanges(iI, eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetTechFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechFreshWaterYieldChanges
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7730 : 			}
; 7731 : 			else

	jmp	SHORT $LN14@calculateI
$LN15@calculateI:

; 7732 : 			{
; 7733 : 				iYield += pImprovement->GetTechNoFreshWaterYieldChanges(iI, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetTechNoFreshWaterYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetTechNoFreshWaterYieldChanges
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN14@calculateI:

; 7734 : 			}
; 7735 : 		}

	jmp	SHORT $LN17@calculateI
$LN16@calculateI:

; 7736 : 
; 7737 : 		for(iI = 0; iI < GC.getNumPolicyInfos(); ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@calculateI
$LN12@calculateI:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN13@calculateI:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN11@calculateI

; 7738 : 		{
; 7739 : 			const PolicyTypes ePolicy = static_cast<PolicyTypes>(iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _ePolicy$225263[ebp], ecx

; 7740 : 			CvPolicyEntry* pkPolicyEntry = GC.getPolicyInfo(ePolicy);

	mov	edx, DWORD PTR _ePolicy$225263[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyEntry$225265[ebp], eax

; 7741 : 			if(pkPolicyEntry)

	cmp	DWORD PTR _pkPolicyEntry$225265[ebp], 0
	je	SHORT $LN10@calculateI

; 7742 : 			{
; 7743 : 				iYield += pkPolicyEntry->GetImprovementYieldChanges(eImprovement, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPolicyEntry$225265[ebp]
	call	?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetImprovementYieldChanges
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN10@calculateI:

; 7744 : 			}
; 7745 : 		}

	jmp	SHORT $LN12@calculateI
$LN11@calculateI:

; 7746 : 	}
; 7747 : 	else

	jmp	$LN9@calculateI

; 7748 : 	{
; 7749 : 		CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

$LN146@calculateI:
	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225268[ebp], edx

; 7750 : 		CvTeam& kTeam = GET_TEAM(kPlayer.getTeam());

	mov	eax, DWORD PTR _kPlayer$225268[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T250980[ebp], eax
	mov	edx, DWORD PTR $T250980[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$225269[ebp], edx

; 7751 : 
; 7752 : 		iYield += kPlayer.getImprovementYieldChange(eImprovement, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$225268[ebp]
	call	?getImprovementYieldChange@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayer::getImprovementYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7753 : 		iYield += kPlayer.GetPlayerTraits()->GetImprovementYieldChange(eImprovement, eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$225268[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?GetImprovementYieldChange@CvPlayerTraits@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayerTraits::GetImprovementYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7754 : 		iYield += kTeam.getImprovementYieldChange(eImprovement, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam$225269[ebp]
	call	?getImprovementYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7755 : 
; 7756 : 		if(bIsFreshWater)

	movzx	eax, BYTE PTR _bIsFreshWater$[ebp]
	test	eax, eax
	je	SHORT $LN8@calculateI

; 7757 : 		{
; 7758 : 			iYield += kTeam.getImprovementFreshWaterYieldChange(eImprovement, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kTeam$225269[ebp]
	call	?getImprovementFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementFreshWaterYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7759 : 		}
; 7760 : 		else

	jmp	SHORT $LN9@calculateI
$LN8@calculateI:

; 7761 : 		{
; 7762 : 			iYield += kTeam.getImprovementNoFreshWaterYieldChange(eImprovement, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kTeam$225269[ebp]
	call	?getImprovementNoFreshWaterYieldChange@CvTeam@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvTeam::getImprovementNoFreshWaterYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN9@calculateI:

; 7763 : 		}
; 7764 : 	}
; 7765 : 
; 7766 : 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	SHORT $LN6@calculateI

; 7767 : 	{
; 7768 : 		eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T250987[ebp], edx
	mov	eax, DWORD PTR $T250987[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T250996[ebp], eax
	mov	edx, DWORD PTR $T250996[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 7769 : 
; 7770 : 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN6@calculateI

; 7771 : 		{
; 7772 : 			iYield += pImprovement->GetImprovementResourceYield(eResource, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovement$[ebp]
	call	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN6@calculateI:

; 7773 : 		}
; 7774 : 	}
; 7775 : 
; 7776 : 	// Working city
; 7777 : 	CvCity* pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$[ebp], eax

; 7778 : 	if(pWorkingCity)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	$LN4@calculateI

; 7779 : 	{
; 7780 : 		ReligionTypes eMajority = pWorkingCity->GetCityReligions()->GetReligiousMajority();

	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetReligiousMajority@CvCityReligions@@QAE?AW4ReligionTypes@@XZ ; CvCityReligions::GetReligiousMajority
	mov	DWORD PTR _eMajority$225276[ebp], eax

; 7781 : 		if(eMajority != NO_RELIGION)

	cmp	DWORD PTR _eMajority$225276[ebp], -1
	je	$LN4@calculateI

; 7782 : 		{
; 7783 : 			const CvReligion* pReligion = GC.getGame().GetGameReligions()->GetReligion(eMajority, pWorkingCity->getOwner());

	mov	edx, DWORD PTR _pWorkingCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T251005[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251009[ebp], ecx
	mov	edx, DWORD PTR $T251005[ebp]
	push	edx
	mov	eax, DWORD PTR _eMajority$225276[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251009[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	ecx, eax
	call	?GetReligion@CvGameReligions@@QBEPBVCvReligion@@W4ReligionTypes@@W4PlayerTypes@@@Z ; CvGameReligions::GetReligion
	mov	DWORD PTR _pReligion$225278[ebp], eax

; 7784 : 			if(pReligion)

	cmp	DWORD PTR _pReligion$225278[ebp], 0
	je	SHORT $LN4@calculateI

; 7785 : 			{
; 7786 : 				int iReligionChange = pReligion->m_Beliefs.GetImprovementYieldChange(eImprovement, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligion$225278[ebp]
	add	ecx, 152				; 00000098H
	call	?GetImprovementYieldChange@CvReligionBeliefs@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvReligionBeliefs::GetImprovementYieldChange
	mov	DWORD PTR _iReligionChange$225280[ebp], eax

; 7787 : 				BeliefTypes eSecondaryPantheon = pWorkingCity->GetCityReligions()->GetSecondaryReligionPantheonBelief();

	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetCityReligions@CvCity@@QBEPAVCvCityReligions@@XZ ; CvCity::GetCityReligions
	mov	ecx, eax
	call	?GetSecondaryReligionPantheonBelief@CvCityReligions@@QAE?AW4BeliefTypes@@XZ ; CvCityReligions::GetSecondaryReligionPantheonBelief
	mov	DWORD PTR _eSecondaryPantheon$225281[ebp], eax

; 7788 : 				if (eSecondaryPantheon != NO_BELIEF)

	cmp	DWORD PTR _eSecondaryPantheon$225281[ebp], -1
	je	SHORT $LN1@calculateI

; 7789 : 				{
; 7790 : 					iReligionChange += GC.GetGameBeliefs()->GetEntry(eSecondaryPantheon)->GetImprovementYieldChange(eImprovement, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eSecondaryPantheon$225281[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBeliefs@CvGlobals@@QBEPAVCvBeliefXMLEntries@@XZ ; CvGlobals::GetGameBeliefs
	mov	ecx, eax
	call	?GetEntry@CvBeliefXMLEntries@@QAEPAVCvBeliefEntry@@H@Z ; CvBeliefXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetImprovementYieldChange@CvBeliefEntry@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvBeliefEntry::GetImprovementYieldChange
	add	eax, DWORD PTR _iReligionChange$225280[ebp]
	mov	DWORD PTR _iReligionChange$225280[ebp], eax
$LN1@calculateI:

; 7791 : 				}
; 7792 : 				iYield += iReligionChange;

	mov	eax, DWORD PTR _iYield$[ebp]
	add	eax, DWORD PTR _iReligionChange$225280[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN4@calculateI:

; 7793 : 			}
; 7794 : 		}
; 7795 : 	}
; 7796 : 
; 7797 : 	return iYield;

	mov	eax, DWORD PTR _iYield$[ebp]
$LN46@calculateI:

; 7798 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ENDP ; CvPlot::calculateImprovementYieldChange
_TEXT	ENDS
PUBLIC	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedRouteType
PUBLIC	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner
PUBLIC	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z	; CvPlot::calculateYield
EXTRN	?getGoldenAgeYield@CvYieldInfo@@QBEHXZ:PROC	; CvYieldInfo::getGoldenAgeYield
EXTRN	?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getGoldenAgeYieldThreshold
EXTRN	?isGoldenAge@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isGoldenAge
EXTRN	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::getExtraYieldThreshold
EXTRN	?getPlotExtraYield@CvGame@@QBEHHHW4YieldTypes@@@Z:PROC ; CvGame::getPlotExtraYield
EXTRN	?GetCapitalYieldPerPopChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCapitalYieldPerPopChange
EXTRN	?GetCapitalYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCapitalYieldChange
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GetCoastalCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCoastalCityYieldChange
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
EXTRN	?GetCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::GetCityYieldChange
EXTRN	?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getMinCityOnHillsAdjust
EXTRN	?getMinCity@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getMinCity
EXTRN	?getResourceYieldChange@CvPlayer@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z:PROC ; CvPlayer::getResourceYieldChange
EXTRN	?GetResourceExtraYield@CvCity@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetResourceExtraYield
EXTRN	?GetTerrainExtraYield@CvCity@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetTerrainExtraYield
EXTRN	?GetImprovementExtraYield@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvPlayer::GetImprovementExtraYield
EXTRN	?GetImprovementExtraYield@CvCity@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetImprovementExtraYield
EXTRN	?GetFeatureExtraYield@CvCity@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z:PROC ; CvCity::GetFeatureExtraYield
EXTRN	?getHillYieldChangesFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getHillYieldChangesFromBuildings
EXTRN	?getMountainScienceYield@CvCity@@QBEHXZ:PROC	; CvCity::getMountainScienceYield
EXTRN	?getRiverPlotYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getRiverPlotYield
EXTRN	?getSeaResourceYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getSeaResourceYield
EXTRN	?getSeaPlotYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getSeaPlotYield
EXTRN	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getLakePlotYield
EXTRN	?getSeaPlotYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::getSeaPlotYield
EXTRN	?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getPopulationChangeOffset
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ:PROC ; CvYieldInfo::getPopulationChangeDivisor
EXTRN	?getCityChange@CvYieldInfo@@QBEHXZ:PROC		; CvYieldInfo::getCityChange
EXTRN	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z:PROC	; CvCity::isRevealed
EXTRN	?getYieldChange@CvRouteInfo@@QBEHH@Z:PROC	; CvRouteInfo::getYieldChange
EXTRN	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z:PROC ; CvPlayerPolicies::GetImprovementCultureChange
EXTRN	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z:PROC ; CvPlayerPolicies::GetNumericModifier
; Function compile flags: /Odtp
;	COMDAT ?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z
_TEXT	SEGMENT
tv841 = -300						; size = 4
tv829 = -296						; size = 4
tv163 = -292						; size = 4
_this$ = -288						; size = 4
$T251300 = -284						; size = 4
$T251294 = -280						; size = 4
$T251293 = -276						; size = 4
$T251289 = -272						; size = 4
$T251285 = -268						; size = 4
$T251281 = -264						; size = 4
$T251277 = -260						; size = 4
$T251273 = -256						; size = 4
$T251269 = -252						; size = 4
$T251265 = -248						; size = 4
$T251261 = -244						; size = 4
$T251257 = -240						; size = 4
$T251253 = -236						; size = 4
$T251249 = -232						; size = 4
$T251245 = -228						; size = 4
$T251241 = -224						; size = 4
$T251237 = -220						; size = 4
$T251230 = -216						; size = 4
$T251218 = -212						; size = 4
$T251217 = -208						; size = 4
$T251213 = -204						; size = 4
$T251209 = -200						; size = 4
$T251208 = -196						; size = 4
$T251204 = -192						; size = 4
$T251200 = -188						; size = 4
$T251196 = -184						; size = 4
$T251184 = -180						; size = 4
$T251180 = -176						; size = 4
$T251171 = -172						; size = 4
$T251167 = -168						; size = 4
_f$251151 = -162					; size = 1
_f$251142 = -161					; size = 1
$T251127 = -160						; size = 4
$T251114 = -156						; size = 4
$T251110 = -152						; size = 4
$T251101 = -148						; size = 4
$T251097 = -144						; size = 4
$T251093 = -140						; size = 4
$T251080 = -136						; size = 4
$T251071 = -128						; size = 4
$T251067 = -124						; size = 4
$T251063 = -120						; size = 4
$T251059 = -116						; size = 4
$T251044 = -112						; size = 4
$T251037 = -108						; size = 4
$T251033 = -104						; size = 4
$T251029 = -100						; size = 4
$T251025 = -96						; size = 4
$T251018 = -92						; size = 4
$T251014 = -88						; size = 4
_iPerPopYield$225368 = -84				; size = 4
_iMinCityYield$225363 = -80				; size = 4
_iTemp$225365 = -76					; size = 4
_kPlayer$225361 = -72					; size = 4
_eTeam$225350 = -68					; size = 4
_pkResourceInfo$225351 = -64				; size = 4
_kPlayer$225345 = -60					; size = 4
_iCityYield$225323 = -56				; size = 4
_eResource$225348 = -52					; size = 4
_pkRouteInfo$225311 = -48				; size = 4
_iAdjacentCulture$225307 = -44				; size = 4
_pImprovement$225305 = -40				; size = 4
_iCultureBoost$225303 = -36				; size = 4
_pWorkingCity$ = -32					; size = 4
_ePlayer$ = -28						; size = 4
_eImprovement$ = -24					; size = 4
_eRoute$ = -20						; size = 4
_kYield$ = -16						; size = 4
_bCity$ = -9						; size = 1
_pCity$ = -8						; size = 4
_iYield$ = -4						; size = 4
_eYield$ = 8						; size = 4
_bDisplay$ = 12						; size = 1
?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z PROC	; CvPlot::calculateYield, COMDAT
; _this$ = ecx

; 7803 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 7804 : 	CvCity* pCity = 0;

	mov	DWORD PTR _pCity$[ebp], 0

; 7805 : 	CvCity* pWorkingCity = 0;

	mov	DWORD PTR _pWorkingCity$[ebp], 0

; 7806 : 	ImprovementTypes eImprovement = NO_IMPROVEMENT;

	mov	DWORD PTR _eImprovement$[ebp], -1

; 7807 : 	RouteTypes eRoute = NO_ROUTE;

	mov	DWORD PTR _eRoute$[ebp], -1

; 7808 : 	PlayerTypes ePlayer = NO_PLAYER;

	mov	DWORD PTR _ePlayer$[ebp], -1

; 7809 : 	bool bCity = false;

	mov	BYTE PTR _bCity$[ebp], 0

; 7810 : 	int iYield = 0;

	mov	DWORD PTR _iYield$[ebp], 0

; 7811 : 
; 7812 : 	const CvYieldInfo& kYield = *GC.getYieldInfo(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo
	mov	DWORD PTR _kYield$[ebp], eax

; 7813 : 
; 7814 : 	if(bDisplay && GC.getGame().isDebugMode())

	movzx	ecx, BYTE PTR _bDisplay$[ebp]
	test	ecx, ecx
	je	SHORT $LN71@calculateY
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251018[ebp], edx
	mov	ecx, DWORD PTR $T251018[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@calculateY

; 7815 : 	{
; 7816 : 		return getYield(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	jmp	$LN65@calculateY

; 7817 : 	}
; 7818 : 
; 7819 : 	if(getTerrainType() == NO_TERRAIN)

$LN71@calculateY:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	cmp	eax, -1
	jne	SHORT $LN63@calculateY

; 7820 : 	{
; 7821 : 		return 0;

	xor	eax, eax
	jmp	$LN65@calculateY
$LN63@calculateY:

; 7822 : 	}
; 7823 : 
; 7824 : 	if(!isPotentialCityWork())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPotentialCityWork@CvPlot@@QBE_NXZ	; CvPlot::isPotentialCityWork
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN62@calculateY

; 7825 : 	{
; 7826 : 		return 0;

	xor	eax, eax
	jmp	$LN65@calculateY
$LN62@calculateY:

; 7827 : 	}
; 7828 : 
; 7829 : 	bCity = false;

	mov	BYTE PTR _bCity$[ebp], 0

; 7830 : 
; 7831 : 	if(bDisplay)

	movzx	edx, BYTE PTR _bDisplay$[ebp]
	test	edx, edx
	je	SHORT $LN81@calculateY

; 7832 : 	{
; 7833 : 		ePlayer = getRevealedOwner(GC.getGame().getActiveTeam());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251025[ebp], eax
	mov	ecx, DWORD PTR $T251025[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner
	mov	DWORD PTR _ePlayer$[ebp], eax

; 7834 : 		eImprovement = getRevealedImprovementType(GC.getGame().getActiveTeam());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251029[ebp], ecx
	mov	ecx, DWORD PTR $T251029[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 7835 : 		eRoute = getRevealedRouteType(GC.getGame().getActiveTeam());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251033[ebp], edx
	mov	ecx, DWORD PTR $T251033[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedRouteType
	mov	DWORD PTR _eRoute$[ebp], eax

; 7836 : 
; 7837 : 		if(ePlayer == NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	jne	SHORT $LN60@calculateY

; 7838 : 		{
; 7839 : 			ePlayer = GC.getGame().getActivePlayer();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251037[ebp], eax
	mov	ecx, DWORD PTR $T251037[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR _ePlayer$[ebp], eax
$LN60@calculateY:

; 7840 : 		}
; 7841 : 	}
; 7842 : 	else

	jmp	SHORT $LN59@calculateY

; 7843 : 	{
; 7844 : 		ePlayer = getOwner();

$LN81@calculateY:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _ePlayer$[ebp], edx

; 7845 : 		eImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 7846 : 		eRoute = getRouteType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eRoute$[ebp], eax
$LN59@calculateY:

; 7847 : 	}
; 7848 : 
; 7849 : 	iYield = calculateNatureYield(eYield, ((ePlayer != NO_PLAYER) ? GET_PLAYER(ePlayer).getTeam() : NO_TEAM));

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	SHORT $LN67@calculateY
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251044[ebp], eax
	mov	ecx, DWORD PTR $T251044[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN68@calculateY
$LN67@calculateY:
	mov	DWORD PTR tv163[ebp], -1
$LN68@calculateY:
	push	0
	mov	eax, DWORD PTR tv163[ebp]
	push	eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR _iYield$[ebp], eax

; 7850 : 
; 7851 : 	if(eImprovement != NO_IMPROVEMENT && !IsImprovementPillaged())

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	$LN58@calculateY
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	edx, al
	test	edx, edx
	jne	$LN58@calculateY

; 7852 : 	{
; 7853 : 		int iCultureBoost = calculateImprovementYieldChange(eImprovement, eYield, ePlayer);

	push	2
	push	0
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
	mov	DWORD PTR _iCultureBoost$225303[ebp], eax

; 7854 : 		iYield += iCultureBoost;

	mov	eax, DWORD PTR _iYield$[ebp]
	add	eax, DWORD PTR _iCultureBoost$225303[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7855 : 		if(eYield == YIELD_CULTURE)

	cmp	DWORD PTR _eYield$[ebp], 4
	jne	$LN58@calculateY

; 7856 : 		{
; 7857 : 			CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovement$225305[ebp], eax

; 7858 : 			if(pImprovement && pImprovement->GetYieldChange(YIELD_CULTURE) > 0)

	cmp	DWORD PTR _pImprovement$225305[ebp], 0
	je	SHORT $LN89@calculateY
	push	4
	mov	ecx, DWORD PTR _pImprovement$225305[ebp]
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN89@calculateY

; 7859 : 			{
; 7860 : 				int iAdjacentCulture = pImprovement->GetCultureAdjacentSameType();

	mov	ecx, DWORD PTR _pImprovement$225305[ebp]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	mov	DWORD PTR _iAdjacentCulture$225307[ebp], eax

; 7861 : 				if(iAdjacentCulture > 0)

	cmp	DWORD PTR _iAdjacentCulture$225307[ebp], 0
	jle	SHORT $LN89@calculateY

; 7862 : 				{
; 7863 : 					iYield += ComputeCultureFromAdjacentImprovement(*pImprovement, eImprovement);

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	eax, DWORD PTR _pImprovement$225305[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7864 : 				}
; 7865 : 			}
; 7866 : 			if(getOwner() != NO_PLAYER)

$LN89@calculateY:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	je	SHORT $LN58@calculateY

; 7867 : 			{
; 7868 : 				iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_CULTURE_FROM_IMPROVEMENTS);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T251059[ebp], ecx
	mov	edx, DWORD PTR $T251059[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251063[ebp], edx
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T251063[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7869 : 				iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetImprovementCultureChange(eImprovement);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T251067[ebp], ecx
	mov	edx, DWORD PTR $T251067[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251071[ebp], edx
	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251071[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ; CvPlayerPolicies::GetImprovementCultureChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN58@calculateY:

; 7870 : 			}
; 7871 : 		}
; 7872 : 
; 7873 : 		
; 7874 : 	}
; 7875 : 
; 7876 : 	if(eRoute != NO_ROUTE && !IsRoutePillaged())

	cmp	DWORD PTR _eRoute$[ebp], -1
	je	SHORT $LN53@calculateY
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN53@calculateY

; 7877 : 	{
; 7878 : 		CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkRouteInfo$225311[ebp], eax

; 7879 : 		if(pkRouteInfo)

	cmp	DWORD PTR _pkRouteInfo$225311[ebp], 0
	je	SHORT $LN53@calculateY

; 7880 : 		{
; 7881 : 			iYield += pkRouteInfo->getYieldChange(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkRouteInfo$225311[ebp]
	call	?getYieldChange@CvRouteInfo@@QBEHH@Z	; CvRouteInfo::getYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN53@calculateY:

; 7882 : 		}
; 7883 : 	}
; 7884 : 
; 7885 : 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	$LN51@calculateY

; 7886 : 	{
; 7887 : 		pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 7888 : 
; 7889 : 		if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN50@calculateY

; 7890 : 		{
; 7891 : 			if(!bDisplay || pCity->isRevealed(GC.getGame().getActiveTeam(), false))

	movzx	ecx, BYTE PTR _bDisplay$[ebp]
	test	ecx, ecx
	je	SHORT $LN48@calculateY
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251080[ebp], edx
	push	0
	mov	ecx, DWORD PTR $T251080[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN50@calculateY
$LN48@calculateY:

; 7892 : 			{
; 7893 : 				iYield += kYield.getCityChange();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getCityChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getCityChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7894 : 
; 7895 : 				if(kYield.getPopulationChangeDivisor() != 0)

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	test	eax, eax
	je	SHORT $LN47@calculateY

; 7896 : 				{
; 7897 : 					iYield += (pCity->getPopulation() + kYield.getPopulationChangeOffset()) / kYield.getPopulationChangeDivisor();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	esi, eax
	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeOffset
	add	esi, eax
	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN47@calculateY:

; 7898 : 				}
; 7899 : 				bCity = true;

	mov	BYTE PTR _bCity$[ebp], 1
$LN50@calculateY:

; 7900 : 			}
; 7901 : 		}
; 7902 : 
; 7903 : 		pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$[ebp], eax

; 7904 : 
; 7905 : 		if(isWater())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN124@calculateY

; 7906 : 		{
; 7907 : 			if(!isImpassable() && !isMountain())

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN124@calculateY
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN124@calculateY

; 7908 : 			{
; 7909 : 				iYield += GET_PLAYER(ePlayer).getSeaPlotYield(eYield);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251093[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T251093[ebp]
	call	?getSeaPlotYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getSeaPlotYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7910 : 
; 7911 : 				if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	$LN44@calculateY

; 7912 : 				{
; 7913 : 					if(!bDisplay || pWorkingCity->isRevealed(GC.getGame().getActiveTeam(), false))

	movzx	edx, BYTE PTR _bDisplay$[ebp]
	test	edx, edx
	je	SHORT $LN42@calculateY
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251097[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T251097[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@calculateY
$LN42@calculateY:

; 7914 : 					{
; 7915 : 						int iCityYield = 0;

	mov	DWORD PTR _iCityYield$225323[ebp], 0

; 7916 : 						if (isLake())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN41@calculateY

; 7917 : 						{
; 7918 : 							if (pWorkingCity->getLakePlotYield(eYield) > 0)

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield
	test	eax, eax
	jle	SHORT $LN40@calculateY

; 7919 : 							{
; 7920 : 								iCityYield = pWorkingCity->getLakePlotYield(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield
	mov	DWORD PTR _iCityYield$225323[ebp], eax
$LN40@calculateY:

; 7921 : 							}
; 7922 : 						}
; 7923 : 						else

	jmp	SHORT $LN39@calculateY
$LN41@calculateY:

; 7924 : 						{
; 7925 : 							iCityYield = pWorkingCity->getSeaPlotYield(eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?getSeaPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaPlotYield
	mov	DWORD PTR _iCityYield$225323[ebp], eax
$LN39@calculateY:

; 7926 : 						}
; 7927 : 						iYield += iCityYield;

	mov	eax, DWORD PTR _iYield$[ebp]
	add	eax, DWORD PTR _iCityYield$225323[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN44@calculateY:

; 7928 : 					}
; 7929 : 				}
; 7930 : 
; 7931 : 				if(getResourceType(GET_PLAYER(ePlayer).getTeam()) != NO_RESOURCE)

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251101[ebp], ecx
	mov	edx, DWORD PTR $T251101[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T251110[ebp], eax
	mov	ecx, DWORD PTR $T251110[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN124@calculateY

; 7932 : 				{
; 7933 : 					if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN124@calculateY

; 7934 : 					{
; 7935 : 						if(!bDisplay || pWorkingCity->isRevealed(GC.getGame().getActiveTeam(), false))

	movzx	edx, BYTE PTR _bDisplay$[ebp]
	test	edx, edx
	je	SHORT $LN35@calculateY
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251114[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T251114[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN124@calculateY
$LN35@calculateY:

; 7936 : 						{
; 7937 : 							iYield += pWorkingCity->getSeaResourceYield(eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?getSeaResourceYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaResourceYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7938 : 						}
; 7939 : 					}
; 7940 : 				}
; 7941 : 
; 7942 : 			}
; 7943 : 		}
; 7944 : 
; 7945 : 		if(isRiver())

$LN124@calculateY:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN132@calculateY

; 7946 : 		{
; 7947 : 			if(!isImpassable() && !isMountain())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN132@calculateY
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN132@calculateY

; 7948 : 			{
; 7949 : 				if(NULL != pWorkingCity)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN132@calculateY

; 7950 : 				{
; 7951 : 					if(!bDisplay || pWorkingCity->isRevealed(GC.getGame().getActiveTeam(), false))

	movzx	ecx, BYTE PTR _bDisplay$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@calculateY
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251127[ebp], edx
	push	0
	mov	ecx, DWORD PTR $T251127[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN132@calculateY
$LN30@calculateY:

; 7952 : 					{
; 7953 : 						iYield += pWorkingCity->getRiverPlotYield(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?getRiverPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getRiverPlotYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7954 : 					}
; 7955 : 				}
; 7956 : 			}
; 7957 : 		}
; 7958 : 		
; 7959 : 		// NQMP GJS - mountain science yield begin
; 7960 : 		if (isMountain() && !IsNaturalWonder())

$LN132@calculateY:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN134@calculateY
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsNaturalWonder@CvPlot@@QBE_NXZ	; CvPlot::IsNaturalWonder
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN134@calculateY

; 7961 : 		{
; 7962 : 			if (NULL != pWorkingCity)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN134@calculateY

; 7963 : 			{
; 7964 : 				if (eYield == YIELD_SCIENCE)

	cmp	DWORD PTR _eYield$[ebp], 3
	jne	SHORT $LN134@calculateY

; 7965 : 				{
; 7966 : 					iYield += pWorkingCity->getMountainScienceYield();

	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?getMountainScienceYield@CvCity@@QBEHXZ	; CvCity::getMountainScienceYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7967 : 				}
; 7968 : 			}
; 7969 : 		}
; 7970 : 		// NQMP GJS - mountain science yield end
; 7971 : 
; 7972 : #ifdef NQ_ALLOW_BUILDING_HILL_YIELD_CHANGES
; 7973 : 		if (isHills())

$LN134@calculateY:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN138@calculateY

; 7974 : 		{
; 7975 : 			if (NULL != pWorkingCity)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN138@calculateY

; 7976 : 			{
; 7977 : 				iYield += pWorkingCity->getHillYieldChangesFromBuildings(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?getHillYieldChangesFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getHillYieldChangesFromBuildings
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 7978 : 			}
; 7979 : 		}
; 7980 : #endif
; 7981 : 
; 7982 : 		// Extra yield for features
; 7983 : 		if(getFeatureType() != NO_FEATURE)

$LN138@calculateY:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$251142[ebp], dl
	movsx	eax, BYTE PTR _f$251142[ebp]
	cmp	eax, -1
	je	SHORT $LN24@calculateY

; 7984 : 		{
; 7985 : 			if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN24@calculateY

; 7986 : 			{
; 7987 : 				iYield += pWorkingCity->GetFeatureExtraYield(getFeatureType(), eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$251151[ebp], dl
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _f$251151[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetFeatureExtraYield@CvCity@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvCity::GetFeatureExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN24@calculateY:

; 7988 : 			}
; 7989 : 		}
; 7990 : 
; 7991 : 		if (eImprovement != NO_IMPROVEMENT && !IsImprovementPillaged())

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN146@calculateY
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN146@calculateY

; 7992 : 		{
; 7993 : 			if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN146@calculateY

; 7994 : 			{
; 7995 : 		
; 7996 : 				//pPlot = plotDirection(getX(), getY(), DIRECTION_NORTHEAST);
; 7997 : 				pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$[ebp], eax

; 7998 : 				//CvCity* pOwningCity = getOwningCity(pPlot);
; 7999 : 				CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225345[ebp], eax

; 8000 : 				iYield += pWorkingCity->GetImprovementExtraYield(eImprovement, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetImprovementExtraYield@CvCity@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvCity::GetImprovementExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 8001 : 				iYield += kPlayer.GetImprovementExtraYield(eImprovement, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$225345[ebp]
	call	?GetImprovementExtraYield@CvPlayer@@QBEHW4ImprovementTypes@@W4YieldTypes@@@Z ; CvPlayer::GetImprovementExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 8002 : 		
; 8003 : 			}
; 8004 : 		}
; 8005 : 		// Extra yield for terrain
; 8006 : 		if(getTerrainType() != NO_TERRAIN)

$LN146@calculateY:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	cmp	eax, -1
	je	SHORT $LN20@calculateY

; 8007 : 		{
; 8008 : 			if(pWorkingCity != NULL && !isImpassable() && !isMountain())

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN20@calculateY
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN20@calculateY
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN20@calculateY

; 8009 : 			{
; 8010 : 				iYield += pWorkingCity->GetTerrainExtraYield(getTerrainType(), eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	DWORD PTR $T251167[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251167[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetTerrainExtraYield@CvCity@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ; CvCity::GetTerrainExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN20@calculateY:

; 8011 : 			}
; 8012 : 		}
; 8013 : 
; 8014 : 		ResourceTypes eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251171[ebp], edx
	mov	eax, DWORD PTR $T251171[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T251180[ebp], eax
	mov	edx, DWORD PTR $T251180[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$225348[ebp], eax

; 8015 : 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$225348[ebp], -1
	je	$LN51@calculateY

; 8016 : 		{
; 8017 : 			TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251184[ebp], eax
	mov	ecx, DWORD PTR $T251184[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$225350[ebp], eax

; 8018 : 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$225348[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$225351[ebp], eax

; 8019 : 			if(pkResourceInfo != NULL && eTeam != NO_TEAM && GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes) pkResourceInfo->getTechReveal()))

	cmp	DWORD PTR _pkResourceInfo$225351[ebp], 0
	je	$LN51@calculateY
	cmp	DWORD PTR _eTeam$225350[ebp], -1
	je	$LN51@calculateY
	mov	ecx, DWORD PTR _eTeam$225350[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T251196[ebp], ecx
	mov	ecx, DWORD PTR _pkResourceInfo$225351[ebp]
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	push	eax
	mov	ecx, DWORD PTR $T251196[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	$LN51@calculateY

; 8020 : 			{
; 8021 : 				if (pkResourceInfo->getPolicyReveal() == NO_POLICY || GET_PLAYER(ePlayer).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkResourceInfo->getPolicyReveal()))

	mov	ecx, DWORD PTR _pkResourceInfo$225351[ebp]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	cmp	eax, -1
	je	SHORT $LN15@calculateY
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251200[ebp], eax
	mov	ecx, DWORD PTR _pkResourceInfo$225351[ebp]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	push	eax
	mov	ecx, DWORD PTR $T251200[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN178@calculateY
$LN15@calculateY:

; 8022 : 				{
; 8023 : 					// Extra yield from resources
; 8024 : 					if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN14@calculateY

; 8025 : 						iYield += pWorkingCity->GetResourceExtraYield(eResource, eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$225348[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?GetResourceExtraYield@CvCity@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvCity::GetResourceExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN14@calculateY:

; 8026 : 
; 8027 : 					// Extra yield from Trait
; 8028 : 					if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ecx, DWORD PTR _pkResourceInfo$225351[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN13@calculateY

; 8029 : 					{
; 8030 : 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeStrategicResources(eYield);

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251204[ebp], ecx
	mov	ecx, DWORD PTR $T251204[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T251208[ebp], eax
	mov	edx, DWORD PTR _eYield$[ebp]
	mov	eax, DWORD PTR $T251208[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+432]
	mov	DWORD PTR $T251209[ebp], ecx
	mov	edx, DWORD PTR _iYield$[ebp]
	add	edx, DWORD PTR $T251209[ebp]
	mov	DWORD PTR _iYield$[ebp], edx
	jmp	SHORT $LN178@calculateY
$LN13@calculateY:

; 8031 : 					}
; 8032 : 					// NQMP GJS - New Netherlands UA BEGIN
; 8033 : 					else if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _pkResourceInfo$225351[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN178@calculateY

; 8034 : 					{
; 8035 : 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeLuxuryResources(eYield);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251213[ebp], eax
	mov	ecx, DWORD PTR $T251213[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T251217[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR $T251217[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+456]
	mov	DWORD PTR $T251218[ebp], eax
	mov	ecx, DWORD PTR _iYield$[ebp]
	add	ecx, DWORD PTR $T251218[ebp]
	mov	DWORD PTR _iYield$[ebp], ecx

; 8036 : 					}
; 8037 : 					// NQMP GJS - New Netherlands UA END
; 8038 : 				}
; 8039 : 				CvPlayer &kPlayer = GET_PLAYER(ePlayer);

$LN178@calculateY:
	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$225361[ebp], edx

; 8040 : 				iYield += kPlayer.getResourceYieldChange(eResource, eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eResource$225348[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$225361[ebp]
	call	?getResourceYieldChange@CvPlayer@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvPlayer::getResourceYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN51@calculateY:

; 8041 : 			}
; 8042 : 		}
; 8043 : 	}
; 8044 : 
; 8045 : 	if(bCity)

	movzx	edx, BYTE PTR _bCity$[ebp]
	test	edx, edx
	je	$LN10@calculateY

; 8046 : 	{
; 8047 : #ifdef NQM_YIELD_MIN_CITY_ON_HILLS_ADJUST
; 8048 : 		int iMinCityYield = kYield.getMinCity();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getMinCity@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getMinCity
	mov	DWORD PTR _iMinCityYield$225363[ebp], eax

; 8049 : 		if (isHills())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@calculateY

; 8050 : 		{
; 8051 : 			iMinCityYield += kYield.getMinCityOnHillsAdjust();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getMinCityOnHillsAdjust@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getMinCityOnHillsAdjust
	add	eax, DWORD PTR _iMinCityYield$225363[ebp]
	mov	DWORD PTR _iMinCityYield$225363[ebp], eax
$LN9@calculateY:

; 8052 : 		}
; 8053 : 		iYield = MAX(iYield, iMinCityYield);

	mov	eax, DWORD PTR _iYield$[ebp]
	cmp	eax, DWORD PTR _iMinCityYield$225363[ebp]
	jge	SHORT $LN184@calculateY
	lea	ecx, DWORD PTR _iMinCityYield$225363[ebp]
	mov	DWORD PTR tv829[ebp], ecx
	jmp	SHORT $LN185@calculateY
$LN184@calculateY:
	lea	edx, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR tv829[ebp], edx
$LN185@calculateY:
	mov	eax, DWORD PTR tv829[ebp]
	mov	DWORD PTR $T251230[ebp], eax
	mov	ecx, DWORD PTR $T251230[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iYield$[ebp], edx

; 8054 : #else
; 8055 : 		iYield = std::max(iYield, kYield.getMinCity());
; 8056 : #endif
; 8057 : #ifndef AUI_PLOT_FIX_CITY_YIELD_CHANGE_RELOCATED
; 8058 : 		// Mod for Player; used for Policies and such
; 8059 : 		int iTemp = GET_PLAYER(getOwner()).GetCityYieldChange(eYield);	// In hundreds - will be added to capitalYieldChange below

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T251237[ebp], ecx
	mov	edx, DWORD PTR $T251237[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251241[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251241[ebp]
	call	?GetCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCityYieldChange
	mov	DWORD PTR _iTemp$225365[ebp], eax

; 8060 : 
; 8061 : 		// Coastal City Mod
; 8062 : 		if(pCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@calculateY

; 8063 : 		{
; 8064 : 			iYield += GET_PLAYER(getOwner()).GetCoastalCityYieldChange(eYield);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T251245[ebp], eax
	mov	ecx, DWORD PTR $T251245[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251249[ebp], ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T251249[ebp]
	call	?GetCoastalCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCoastalCityYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN8@calculateY:

; 8065 : 		}
; 8066 : 
; 8067 : 		// Capital Mod
; 8068 : 		if(pCity->isCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	$LN7@calculateY

; 8069 : 		{
; 8070 : 			iTemp += GET_PLAYER(getOwner()).GetCapitalYieldChange(eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T251253[ebp], edx
	mov	eax, DWORD PTR $T251253[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251257[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T251257[ebp]
	call	?GetCapitalYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldChange
	add	eax, DWORD PTR _iTemp$225365[ebp]
	mov	DWORD PTR _iTemp$225365[ebp], eax

; 8071 : 
; 8072 : 			int iPerPopYield = pCity->getPopulation() * GET_PLAYER(getOwner()).GetCapitalYieldPerPopChange(eYield);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T251261[ebp], eax
	mov	ecx, DWORD PTR $T251261[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251265[ebp], ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	esi, eax
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T251265[ebp]
	call	?GetCapitalYieldPerPopChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldPerPopChange
	imul	esi, eax
	mov	DWORD PTR _iPerPopYield$225368[ebp], esi

; 8073 : 			iPerPopYield /= 100;

	mov	eax, DWORD PTR _iPerPopYield$225368[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iPerPopYield$225368[ebp], eax

; 8074 : 			iYield += iPerPopYield;

	mov	edx, DWORD PTR _iYield$[ebp]
	add	edx, DWORD PTR _iPerPopYield$225368[ebp]
	mov	DWORD PTR _iYield$[ebp], edx
$LN7@calculateY:

; 8075 : 		}
; 8076 : 
; 8077 : 		iYield += (iTemp / 100);

	mov	eax, DWORD PTR _iTemp$225365[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN10@calculateY:

; 8078 : #endif
; 8079 : 	}
; 8080 : 
; 8081 : 	iYield += GC.getGame().getPlotExtraYield(m_iX, m_iY, eYield);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251269[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T251269[ebp]
	call	?getPlotExtraYield@CvGame@@QBEHHHW4YieldTypes@@@Z ; CvGame::getPlotExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 8082 : 
; 8083 : 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	$LN6@calculateY

; 8084 : 	{
; 8085 : 		if(GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield) > 0)

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251273[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251273[ebp]
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	test	eax, eax
	jle	SHORT $LN5@calculateY

; 8086 : 		{
; 8087 : 			if(iYield >= GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251277[ebp], ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T251277[ebp]
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	cmp	DWORD PTR _iYield$[ebp], eax
	jl	SHORT $LN5@calculateY

; 8088 : 			{
; 8089 : 				iYield += GC.getEXTRA_YIELD();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6608
	mov	DWORD PTR $T251281[ebp], eax
	mov	ecx, DWORD PTR _iYield$[ebp]
	add	ecx, DWORD PTR $T251281[ebp]
	mov	DWORD PTR _iYield$[ebp], ecx
$LN5@calculateY:

; 8090 : 			}
; 8091 : 		}
; 8092 : 
; 8093 : 		if(GET_PLAYER(ePlayer).isGoldenAge())

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251285[ebp], edx
	mov	ecx, DWORD PTR $T251285[ebp]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@calculateY

; 8094 : 		{
; 8095 : 			if(iYield >= kYield.getGoldenAgeYieldThreshold())

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getGoldenAgeYieldThreshold
	cmp	DWORD PTR _iYield$[ebp], eax
	jl	SHORT $LN2@calculateY

; 8096 : 			{
; 8097 : 				iYield += kYield.getGoldenAgeYield();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getGoldenAgeYield@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getGoldenAgeYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN2@calculateY:

; 8098 : 			}
; 8099 : #ifdef NQ_GOLDEN_PILGRIMAGE
; 8100 : 			// this is super hacky, I am a bad person and I should feel bad...
; 8101 : 			if (eYield == YIELD_FAITH && calculateYield(YIELD_GOLD, bDisplay) > 0)

	cmp	DWORD PTR _eYield$[ebp], 5
	jne	SHORT $LN6@calculateY
	movzx	ecx, BYTE PTR _bDisplay$[ebp]
	push	ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	test	eax, eax
	jle	SHORT $LN6@calculateY

; 8102 : 			{
; 8103 : 				iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetGoldenAgeTileBonusFaith();

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251289[ebp], edx
	mov	ecx, DWORD PTR $T251289[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T251293[ebp], eax
	mov	eax, DWORD PTR $T251293[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	DWORD PTR $T251294[ebp], ecx
	mov	edx, DWORD PTR _iYield$[ebp]
	add	edx, DWORD PTR $T251294[ebp]
	mov	DWORD PTR _iYield$[ebp], edx
$LN6@calculateY:

; 8104 : 			}
; 8105 : //int CvPlot::getYieldWithBuild(BuildTypes eBuild, YieldTypes eYield, bool bWithUpgrade, PlayerTypes ePlayer) const
; 8106 : #endif
; 8107 : 		}
; 8108 : 	}
; 8109 : 
; 8110 : 	return std::max(0, iYield);

	mov	DWORD PTR $T251014[ebp], 0
	mov	eax, DWORD PTR $T251014[ebp]
	cmp	eax, DWORD PTR _iYield$[ebp]
	jge	SHORT $LN218@calculateY
	lea	ecx, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR tv841[ebp], ecx
	jmp	SHORT $LN219@calculateY
$LN218@calculateY:
	lea	edx, DWORD PTR $T251014[ebp]
	mov	DWORD PTR tv841[ebp], edx
$LN219@calculateY:
	mov	eax, DWORD PTR tv841[ebp]
	mov	DWORD PTR $T251300[ebp], eax
	mov	ecx, DWORD PTR $T251300[ebp]
	mov	eax, DWORD PTR [ecx]
$LN65@calculateY:

; 8111 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ENDP	; CvPlot::calculateYield
_TEXT	ENDS
PUBLIC	?hasYield@CvPlot@@QBE_NXZ			; CvPlot::hasYield
; Function compile flags: /Odtp
;	COMDAT ?hasYield@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$ = -4						; size = 4
?hasYield@CvPlot@@QBE_NXZ PROC				; CvPlot::hasYield, COMDAT
; _this$ = ecx

; 8116 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 8117 : 	int iI;
; 8118 : 
; 8119 : 	for(iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@hasYield
$LN3@hasYield:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@hasYield:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN2@hasYield

; 8120 : 	{
; 8121 : 		if(getYield((YieldTypes)iI) > 0)

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	test	eax, eax
	jle	SHORT $LN1@hasYield

; 8122 : 		{
; 8123 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@hasYield
$LN1@hasYield:

; 8124 : 		}
; 8125 : 	}

	jmp	SHORT $LN3@hasYield
$LN2@hasYield:

; 8126 : 
; 8127 : 	return false;

	xor	al, al
$LN5@hasYield:

; 8128 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hasYield@CvPlot@@QBE_NXZ ENDP				; CvPlot::hasYield
_TEXT	ENDS
EXTRN	?ChangeBaseYieldRateFromTerrain@CvCity@@QAEXW4YieldTypes@@H@Z:PROC ; CvCity::ChangeBaseYieldRateFromTerrain
; Function compile flags: /Odtp
;	COMDAT ?updateYield@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_pWorkingCity$ = -20					; size = 4
_iOldYield$ = -16					; size = 4
_bChange$ = -9						; size = 1
_iNewYield$ = -8					; size = 2
_iI$ = -4						; size = 4
?updateYield@CvPlot@@QAEXXZ PROC			; CvPlot::updateYield, COMDAT
; _this$ = ecx

; 8133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 8134 : 	CvCity* pWorkingCity;
; 8135 : 	bool bChange;
; 8136 : 	short iNewYield;
; 8137 : 	int iOldYield;
; 8138 : 	int iI;
; 8139 : 
; 8140 : 	if(area() == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	jne	SHORT $LN8@updateYiel

; 8141 : 	{
; 8142 : 		return;

	jmp	$LN9@updateYiel
$LN8@updateYiel:

; 8143 : 	}
; 8144 : 
; 8145 : 	bChange = false;

	mov	BYTE PTR _bChange$[ebp], 0

; 8146 : 
; 8147 : 	for(iI = 0; iI < NUM_YIELD_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@updateYiel
$LN6@updateYiel:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@updateYiel:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN5@updateYiel

; 8148 : 	{
; 8149 : 		iNewYield = (short)calculateYield((YieldTypes)iI);

	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	mov	WORD PTR _iNewYield$[ebp], ax

; 8150 : 
; 8151 : 		if(getYield((YieldTypes)iI) != (int)iNewYield)

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	movsx	ecx, WORD PTR _iNewYield$[ebp]
	cmp	eax, ecx
	je	SHORT $LN4@updateYiel

; 8152 : 		{
; 8153 : 			iOldYield = getYield((YieldTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	mov	DWORD PTR _iOldYield$[ebp], eax

; 8154 : 
; 8155 : 			m_aiYield[iI] = iNewYield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	ax, WORD PTR _iNewYield$[ebp]
	mov	WORD PTR [ecx+edx*2], ax

; 8156 : 			CvAssertMsg(getYield((YieldTypes)iI) >= 0 && getYield((YieldTypes)iI) < 50, "GAMEPLAY: Yield for a plot is either negative or a ridiculously large number.  Please send Jon this with your last 5 autosaves and what changelist # you're playing.");
; 8157 : 
; 8158 : 			pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$[ebp], eax

; 8159 : 
; 8160 : 			if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$[ebp], 0
	je	SHORT $LN3@updateYiel

; 8161 : 			{
; 8162 : 				if(isBeingWorked())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@updateYiel

; 8163 : 				{
; 8164 : 					pWorkingCity->ChangeBaseYieldRateFromTerrain(((YieldTypes)iI), (getYield((YieldTypes)iI) - iOldYield));

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	sub	eax, DWORD PTR _iOldYield$[ebp]
	push	eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$[ebp]
	call	?ChangeBaseYieldRateFromTerrain@CvCity@@QAEXW4YieldTypes@@H@Z ; CvCity::ChangeBaseYieldRateFromTerrain
$LN3@updateYiel:

; 8165 : 				}
; 8166 : 
; 8167 : 				// JON: New City Citizens AI shoulud update here 08/17/09
; 8168 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 8169 : 				pWorkingCity->GetCityCitizens()->DoSelfConsistencyCheck();
; 8170 : #endif
; 8171 : 			}
; 8172 : 
; 8173 : 			bChange = true;

	mov	BYTE PTR _bChange$[ebp], 1
$LN4@updateYiel:

; 8174 : 		}
; 8175 : 	}

	jmp	$LN6@updateYiel
$LN5@updateYiel:

; 8176 : 
; 8177 : 	if(bChange)

	movzx	ecx, BYTE PTR _bChange$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@updateYiel

; 8178 : 	{
; 8179 : 		updateSymbols();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols
$LN9@updateYiel:

; 8180 : 	}
; 8181 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateYield@CvPlot@@QAEXXZ ENDP			; CvPlot::updateYield
_TEXT	ENDS
PUBLIC	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z	; CvPlot::getFoundValue
; Function compile flags: /Odtp
;	COMDAT ?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv78 = -16						; size = 4
_this$ = -12						; size = 4
$T251320 = -8						; size = 4
$T251316 = -4						; size = 4
_eIndex$ = 8						; size = 4
?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z PROC	; CvPlot::getFoundValue, COMDAT
; _this$ = ecx

; 8185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 8186 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8187 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8188 : 
; 8189 : 	if(m_aiFoundValue[eIndex] == -1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _eIndex$[ebp]
	cmp	DWORD PTR [ecx+edx*4], -1
	jne	SHORT $LN1@getFoundVa

; 8190 : 	{
; 8191 : 		m_aiFoundValue[eIndex] = GET_PLAYER(eIndex).AI_foundValue(getX(), getY(), -1, true);

	mov	eax, DWORD PTR _eIndex$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T251316[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T251320[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+148]
	push	1
	push	-1
	mov	eax, DWORD PTR $T251316[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251320[ebp]
	push	ecx
	mov	edx, DWORD PTR tv78[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv78[ebp]
	mov	edx, DWORD PTR [eax+48]
	call	edx
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [esi+ecx*4], eax
$LN1@getFoundVa:

; 8192 : 	}
; 8193 : 
; 8194 : 	return m_aiFoundValue[eIndex];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 8195 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ENDP	; CvPlot::getFoundValue
_TEXT	ENDS
PUBLIC	?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z ; CvPlot::isBestAdjacentFound
; Function compile flags: /Odtp
;	COMDAT ?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T251548 = -128						; size = 4
$T251544 = -124						; size = 4
_uiOffset$251539 = -120					; size = 4
$T251530 = -116						; size = 4
$T251341 = -32						; size = 4
$T251337 = -28						; size = 4
$T251333 = -24						; size = 4
$T251329 = -20						; size = 4
_thisPlayer$ = -16					; size = 4
_iI$ = -12						; size = 4
_pAdjacentPlot$ = -8					; size = 4
_iPlotValue$ = -4					; size = 4
_eIndex$ = 8						; size = 4
?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z PROC ; CvPlot::isBestAdjacentFound, COMDAT
; _this$ = ecx

; 8200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 8201 : 	CvPlot* pAdjacentPlot;
; 8202 : 	int iI;
; 8203 : 
; 8204 : 	CvPlayer& thisPlayer = GET_PLAYER(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[ebp], eax

; 8205 : 	int iPlotValue = thisPlayer.AI_foundValue(getX(), getY());

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T251329[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T251333[ebp], ecx
	push	0
	push	-1
	mov	edx, DWORD PTR $T251329[ebp]
	push	edx
	mov	eax, DWORD PTR $T251333[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	mov	DWORD PTR _iPlotValue$[ebp], eax

; 8206 : 
; 8207 : 	if(iPlotValue == 0)

	cmp	DWORD PTR _iPlotValue$[ebp], 0
	jne	SHORT $LN6@isBestAdja

; 8208 : 	{
; 8209 : 		return false;

	xor	al, al
	jmp	$LN7@isBestAdja
$LN6@isBestAdja:

; 8210 : 	}
; 8211 : 
; 8212 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isBestAdja
$LN4@isBestAdja:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@isBestAdja:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	$LN3@isBestAdja

; 8213 : 	{
; 8214 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T251337[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T251341[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251337[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251341[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 8215 : 
; 8216 : 		if((pAdjacentPlot != NULL) && pAdjacentPlot->isRevealed(thisPlayer.getTeam()))

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isBestAdja
	mov	eax, DWORD PTR _thisPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T251530[ebp], eax
	mov	edx, DWORD PTR $T251530[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$251539[ebp], edx
	mov	eax, DWORD PTR _uiOffset$251539[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T251530[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$251539[ebp]
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@isBestAdja

; 8217 : 		{
; 8218 : 			if(thisPlayer.AI_foundValue(pAdjacentPlot->getX(), pAdjacentPlot->getY()) > iPlotValue)

	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T251544[ebp], edx
	mov	eax, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T251548[ebp], ecx
	push	0
	push	-1
	mov	edx, DWORD PTR $T251544[ebp]
	push	edx
	mov	eax, DWORD PTR $T251548[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _thisPlayer$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	cmp	eax, DWORD PTR _iPlotValue$[ebp]
	jle	SHORT $LN2@isBestAdja

; 8219 : 			{
; 8220 : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBestAdja
$LN2@isBestAdja:

; 8221 : 			}
; 8222 : 		}
; 8223 : 	}

	jmp	$LN4@isBestAdja
$LN3@isBestAdja:

; 8224 : 
; 8225 : 	return true;

	mov	al, 1
$LN7@isBestAdja:

; 8226 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z ENDP ; CvPlot::isBestAdjacentFound
_TEXT	ENDS
PUBLIC	?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z	; CvPlot::setFoundValue
; Function compile flags: /Odtp
;	COMDAT ?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z PROC	; CvPlot::setFoundValue, COMDAT
; _this$ = ecx

; 8231 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8232 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8233 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8234 : 
; 8235 : 	m_aiFoundValue[eIndex] = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 8236 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setFoundValue@CvPlot@@QAEXW4PlayerTypes@@H@Z ENDP	; CvPlot::setFoundValue
_TEXT	ENDS
PUBLIC	?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getPlayerCityRadiusCount
; Function compile flags: /Odtp
;	COMDAT ?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z PROC ; CvPlot::getPlayerCityRadiusCount, COMDAT
; _this$ = ecx

; 8241 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8242 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8243 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8244 : 
; 8245 : 	return m_aiPlayerCityRadiusCount[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	edx, DWORD PTR _eIndex$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]

; 8246 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z ENDP ; CvPlot::getPlayerCityRadiusCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::isPlayerCityRadius, COMDAT
; _this$ = ecx

; 8251 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8252 : 	return (getPlayerCityRadiusCount(eIndex) > 0);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getPlayerCityRadiusCount
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	al, cl

; 8253 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::isPlayerCityRadius
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z PROC ; CvPlot::changePlayerCityRadiusCount, COMDAT
; _this$ = ecx

; 8258 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8259 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8260 : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8261 : 
; 8262 : 	if(0 != iChange)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN2@changePlay

; 8263 : 	{
; 8264 : 		m_aiPlayerCityRadiusCount[eIndex] += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	mov	edx, DWORD PTR _eIndex$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+152]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	BYTE PTR [edx+ecx], al
$LN2@changePlay:

; 8265 : 		CvAssert(getPlayerCityRadiusCount(eIndex) >= 0);
; 8266 : 	}
; 8267 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changePlayerCityRadiusCount@CvPlot@@QAEXW4PlayerTypes@@H@Z ENDP ; CvPlot::changePlayerCityRadiusCount
_TEXT	ENDS
PUBLIC	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z	; CvPlot::setRevealed
PUBLIC	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
EXTRN	?isHuman@CvCity@@QBE_NXZ:PROC			; CvCity::isHuman
EXTRN	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z:PROC	; CvTeam::meet
EXTRN	?isHuman@CvUnit@@QBE_NXZ:PROC			; CvUnit::isHuman
EXTRN	?isHuman@CvTeam@@QBE_NXZ:PROC			; CvTeam::isHuman
; Function compile flags: /Odtp
;	COMDAT ?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z
_TEXT	SEGMENT
_this$ = -192						; size = 4
$T251851 = -188						; size = 4
$T251842 = -180						; size = 4
$T251835 = -176						; size = 4
_playerID$251827 = -172					; size = 4
$T251813 = -164						; size = 4
$T251804 = -156						; size = 4
$T251800 = -152						; size = 4
$T251629 = -68						; size = 4
$T251625 = -64						; size = 4
$T251613 = -57						; size = 1
$T251601 = -56						; size = 4
_uiOffset$251596 = -52					; size = 4
$T251587 = -46						; size = 1
$T251577 = -45						; size = 1
_loopUnit$225492 = -44					; size = 4
_iUnitLoop$225488 = -40					; size = 4
_iI$225482 = -36					; size = 4
_playerI$225478 = -32					; size = 4
_iI$225474 = -28					; size = 4
_bOldRevealed$225470 = -21				; size = 1
_iI$225463 = -20					; size = 4
_eResult$ = -16						; size = 4
_pCity$ = -12						; size = 4
_bOldVisible$ = -5					; size = 1
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_iChange$ = 12						; size = 4
_eSeeInvisible$ = 16					; size = 4
_bInformExplorationTracking$ = 20			; size = 1
_bAlwaysSeeInvisible$ = 24				; size = 1
?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z PROC ; CvPlot::changeVisibilityCount, COMDAT
; _this$ = ecx

; 8271 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	DWORD PTR _this$[ebp], ecx

; 8272 : 	CvCity* pCity;
; 8273 : 	CvPlot* pAdjacentPlot;
; 8274 : 	bool bOldVisible;
; 8275 : 
; 8276 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8277 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8278 : 
; 8279 : 	PlotVisibilityChangeResult eResult = VISIBILTY_CHANGE_NONE;

	mov	DWORD PTR _eResult$[ebp], 0

; 8280 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN32@changeVisi

; 8281 : 	{
; 8282 : 		bOldVisible = isVisible(eTeam);

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN38@changeVisi
	mov	BYTE PTR _bOldVisible$[ebp], 0
	jmp	SHORT $LN36@changeVisi
$LN38@changeVisi:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR _bOldVisible$[ebp], cl
$LN36@changeVisi:

; 8283 : 
; 8284 : 		m_aiVisibilityCount[eTeam] += iChange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 8285 : 		CvAssertFmt(m_aiVisibilityCount[eTeam]>=0, "Changing plot X:%d, Y:%d to a negative visibility", getX(), getY());
; 8286 : 		if (m_aiVisibilityCount[eTeam] < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _eTeam$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	test	ecx, ecx
	jge	SHORT $LN31@changeVisi

; 8287 : 			m_aiVisibilityCount[eTeam] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	xor	ecx, ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	mov	WORD PTR [eax+edx*2], cx
$LN31@changeVisi:

; 8288 : 
; 8289 : 		if(eSeeInvisible != NO_INVISIBLE)

	cmp	DWORD PTR _eSeeInvisible$[ebp], -1
	je	SHORT $LN30@changeVisi

; 8290 : 		{
; 8291 : 			changeInvisibleVisibilityCount(eTeam, eSeeInvisible, iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eSeeInvisible$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
$LN30@changeVisi:

; 8292 : 		}
; 8293 : 
; 8294 : 		if(bAlwaysSeeInvisible)

	movzx	eax, BYTE PTR _bAlwaysSeeInvisible$[ebp]
	test	eax, eax
	je	SHORT $LN29@changeVisi

; 8295 : 		{
; 8296 : 			for(int iI = 0; iI < NUM_INVISIBLE_TYPES; iI++)

	mov	DWORD PTR _iI$225463[ebp], 0
	jmp	SHORT $LN28@changeVisi
$LN27@changeVisi:
	mov	ecx, DWORD PTR _iI$225463[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225463[ebp], ecx
$LN28@changeVisi:
	cmp	DWORD PTR _iI$225463[ebp], 1
	jge	SHORT $LN29@changeVisi

; 8297 : 			{
; 8298 : 				changeInvisibleVisibilityCount(eTeam, (InvisibleTypes) iI, iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	eax, DWORD PTR _iI$225463[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount

; 8299 : 			}

	jmp	SHORT $LN27@changeVisi
$LN29@changeVisi:

; 8300 : 		}
; 8301 : 
; 8302 : 		if(bOldVisible != isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN43@changeVisi
	mov	BYTE PTR $T251577[ebp], 0
	jmp	SHORT $LN41@changeVisi
$LN43@changeVisi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	xor	eax, eax
	test	edx, edx
	setg	al
	mov	BYTE PTR $T251577[ebp], al
$LN41@changeVisi:
	movzx	ecx, BYTE PTR _bOldVisible$[ebp]
	movzx	edx, BYTE PTR $T251577[ebp]
	cmp	ecx, edx
	je	$LN32@changeVisi

; 8303 : 		{
; 8304 : 			// We couldn't see the Plot before but we can now
; 8305 : 			if(isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN48@changeVisi
	mov	BYTE PTR $T251587[ebp], 0
	jmp	SHORT $LN46@changeVisi
$LN48@changeVisi:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T251587[ebp], cl
$LN46@changeVisi:
	movzx	edx, BYTE PTR $T251587[ebp]
	test	edx, edx
	je	$LN24@changeVisi

; 8306 : 			{
; 8307 : 				eResult = VISIBILITY_CHANGE_TO_VISIBLE;

	mov	DWORD PTR _eResult$[ebp], 2

; 8308 : 				bool bOldRevealed = isRevealed(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$251596[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$251596[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$251596[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	mov	BYTE PTR _bOldRevealed$225470[ebp], al

; 8309 : 				if (!setRevealed(eTeam, true))	// Change to revealed, returns true if the visibility was changed

	push	-1
	push	0
	push	1
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN23@changeVisi

; 8310 : 				{
; 8311 : 					// The visibility was not changed because it was already revealed, but we are changing to a visible state as well, so we must update.
; 8312 : 					// Just trying to avoid redundant messages.
; 8313 : 					if (eTeam == GC.getGame().getActiveTeam())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251601[ebp], eax
	mov	ecx, DWORD PTR $T251601[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN23@changeVisi

; 8314 : 					{
; 8315 : 						updateSymbols();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 8316 : 						updateFog(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog

; 8317 : #ifndef AUI_PLOT_FIX_RESPONSIVE_VISIBILITY_UPDATE
; 8318 : 						updateVisibility();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
$LN23@changeVisi:

; 8319 : #endif
; 8320 : 					}
; 8321 : 				}
; 8322 : 
; 8323 : 				if(bInformExplorationTracking && !bOldRevealed)

	movzx	ecx, BYTE PTR _bInformExplorationTracking$[ebp]
	test	ecx, ecx
	je	SHORT $LN21@changeVisi
	movzx	edx, BYTE PTR _bOldRevealed$225470[ebp]
	test	edx, edx
	jne	SHORT $LN21@changeVisi

; 8324 : 				{
; 8325 : 					// slewis - ghetto-tastic hack. ugh
; 8326 : 					for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$225474[ebp], 0
	jmp	SHORT $LN20@changeVisi
$LN19@changeVisi:
	mov	eax, DWORD PTR _iI$225474[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225474[ebp], eax
$LN20@changeVisi:
	cmp	DWORD PTR _iI$225474[ebp], 64		; 00000040H
	jge	SHORT $LN21@changeVisi

; 8327 : 					{
; 8328 : 						CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$225474[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225478[ebp], ecx

; 8329 : 						if(playerI.isAlive())

	mov	edx, DWORD PTR _playerI$225478[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T251613[ebp], al
	movzx	ecx, BYTE PTR $T251613[ebp]
	test	ecx, ecx
	je	SHORT $LN17@changeVisi

; 8330 : 						{
; 8331 : 							if(playerI.getTeam() == eTeam)

	mov	edx, DWORD PTR _playerI$225478[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN17@changeVisi

; 8332 : 							{
; 8333 : 								playerI.GetEconomicAI()->m_bExplorationPlotsDirty = true;

	mov	ecx, DWORD PTR _playerI$225478[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	BYTE PTR [eax], 1
$LN17@changeVisi:

; 8334 : 							}
; 8335 : 						}
; 8336 : 					}

	jmp	SHORT $LN19@changeVisi
$LN21@changeVisi:

; 8337 : 				}
; 8338 : 
; 8339 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$225482[ebp], 0
	jmp	SHORT $LN15@changeVisi
$LN14@changeVisi:
	mov	ecx, DWORD PTR _iI$225482[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225482[ebp], ecx
$LN15@changeVisi:
	cmp	DWORD PTR _iI$225482[ebp], 6
	jge	SHORT $LN13@changeVisi

; 8340 : 				{
; 8341 : 					pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T251625[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T251629[ebp], edx
	mov	eax, DWORD PTR _iI$225482[ebp]
	push	eax
	mov	ecx, DWORD PTR $T251625[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251629[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 8342 : 
; 8343 : 					if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN12@changeVisi

; 8344 : 					{
; 8345 : 						pAdjacentPlot->updateRevealedOwner(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ; CvPlot::updateRevealedOwner
$LN12@changeVisi:

; 8346 : 					}
; 8347 : 				}

	jmp	SHORT $LN14@changeVisi
$LN13@changeVisi:

; 8348 : 
; 8349 : 				// If there are any Units here, meet their owners
; 8350 : #ifdef AUI_WARNING_FIXES
; 8351 : 				for (uint iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)
; 8352 : #else
; 8353 : 				for(int iUnitLoop = 0; iUnitLoop < getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$225488[ebp], 0
	jmp	SHORT $LN11@changeVisi
$LN10@changeVisi:
	mov	ecx, DWORD PTR _iUnitLoop$225488[ebp]
	add	ecx, 1
	mov	DWORD PTR _iUnitLoop$225488[ebp], ecx
$LN11@changeVisi:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$225488[ebp], eax
	jge	$LN9@changeVisi

; 8354 : #endif
; 8355 : 				{
; 8356 : 					// If the AI spots a human Unit, don't meet - wait for the human to find the AI
; 8357 : 					CvUnit* loopUnit = getUnitByIndex(iUnitLoop);

	mov	edx, DWORD PTR _iUnitLoop$225488[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _loopUnit$225492[ebp], eax

; 8358 : 
; 8359 : 					if(!loopUnit) continue;

	cmp	DWORD PTR _loopUnit$225492[ebp], 0
	jne	SHORT $LN8@changeVisi
	jmp	SHORT $LN10@changeVisi
$LN8@changeVisi:

; 8360 : 
; 8361 : 					if(!GET_TEAM(eTeam).isHuman() && loopUnit->isHuman())

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T251800[ebp], eax
	mov	ecx, DWORD PTR $T251800[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@changeVisi
	mov	ecx, DWORD PTR _loopUnit$225492[ebp]
	call	?isHuman@CvUnit@@QBE_NXZ		; CvUnit::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@changeVisi

; 8362 : 					{
; 8363 : 						continue;

	jmp	SHORT $LN10@changeVisi
$LN7@changeVisi:

; 8364 : 					}
; 8365 : 
; 8366 : 					GET_TEAM(eTeam).meet(loopUnit->getTeam(), false);

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T251804[ebp], eax
	push	0
	mov	ecx, DWORD PTR _loopUnit$225492[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR $T251804[ebp]
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet

; 8367 : 				}

	jmp	$LN10@changeVisi
$LN9@changeVisi:

; 8368 : 
; 8369 : 				// If there's a City here, meet its owner
; 8370 : 				if(isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@changeVisi

; 8371 : 				{
; 8372 : 					// If the AI spots a human City, don't meet - wait for the human to find the AI
; 8373 : 					if(GET_TEAM(eTeam).isHuman() || !getPlotCity()->isHuman())

	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T251813[ebp], edx
	mov	ecx, DWORD PTR $T251813[ebp]
	call	?isHuman@CvTeam@@QBE_NXZ		; CvTeam::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN160@changeVisi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	ecx, eax
	call	?isHuman@CvCity@@QBE_NXZ		; CvCity::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@changeVisi

; 8374 : 					{
; 8375 : 						GET_TEAM(eTeam).meet(getTeam(), false);	// If there's a City here, we can assume its owner is the same as the plot owner

$LN160@changeVisi:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR _playerID$251827[ebp], eax
	cmp	DWORD PTR _playerID$251827[ebp], -1
	je	SHORT $LN157@changeVisi
	mov	ecx, DWORD PTR _playerID$251827[ebp]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T251835[ebp], eax
	jmp	SHORT $LN164@changeVisi
	jmp	SHORT $LN164@changeVisi
$LN157@changeVisi:
	mov	DWORD PTR $T251835[ebp], -1
$LN164@changeVisi:
	push	0
	mov	edx, DWORD PTR $T251835[ebp]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?meet@CvTeam@@QAEXW4TeamTypes@@_N@Z	; CvTeam::meet
$LN6@changeVisi:

; 8376 : 					}
; 8377 : 				}
; 8378 : 			}
; 8379 : 			else

	jmp	SHORT $LN3@changeVisi
$LN24@changeVisi:

; 8380 : 			{
; 8381 : 				eResult = VISIBILITY_CHANGE_TO_INVISIBLE;

	mov	DWORD PTR _eResult$[ebp], 1

; 8382 : 				if(eTeam == GC.getGame().getActiveTeam())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251842[ebp], eax
	mov	ecx, DWORD PTR $T251842[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN3@changeVisi

; 8383 : 					updateFog(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog
$LN3@changeVisi:

; 8384 : 			}
; 8385 : 
; 8386 : 			pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 8387 : 
; 8388 : 			if(eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251851[ebp], ecx
	mov	ecx, DWORD PTR $T251851[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN32@changeVisi

; 8389 : 			{
; 8390 : 				//updateFog();
; 8391 : #ifndef AUI_PLOT_FIX_RESPONSIVE_VISIBILITY_UPDATE
; 8392 : 				updateVisibility();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility

; 8393 : #endif
; 8394 : 				updateCenterUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN32@changeVisi:

; 8395 : 			}
; 8396 : 		}
; 8397 : 	}
; 8398 : 
; 8399 : 	return eResult;

	mov	eax, DWORD PTR _eResult$[ebp]

; 8400 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ENDP ; CvPlot::changeVisibilityCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T251857 = -4						; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::getRevealedOwner, COMDAT
; _this$ = ecx

; 8404 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 8405 : 	if(bDebug && GC.getGame().isDebugMode())

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	je	SHORT $LN2@getReveale
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T251857[ebp], ecx
	mov	ecx, DWORD PTR $T251857[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@getReveale

; 8406 : 	{
; 8407 : 		return getOwner();

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+4]
	jmp	SHORT $LN3@getReveale

; 8408 : 	}
; 8409 : 	else

	jmp	SHORT $LN3@getReveale
$LN2@getReveale:

; 8410 : 	{
; 8411 : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8412 : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8413 : 
; 8414 : 		return (PlayerTypes)m_aiRevealedOwner[eTeam];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	eax, DWORD PTR _eTeam$[ebp]
	movsx	eax, BYTE PTR [edx+eax]
$LN3@getReveale:

; 8415 : 	}
; 8416 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::getRevealedOwner
_TEXT	ENDS
PUBLIC	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z ; CvPlot::getRevealedTeam
; Function compile flags: /Odtp
;	COMDAT ?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T251866 = -8						; size = 4
_eRevealedOwner$ = -4					; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z PROC ; CvPlot::getRevealedTeam, COMDAT
; _this$ = ecx

; 8421 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 8422 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8423 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8424 : 
; 8425 : 	PlayerTypes eRevealedOwner = getRevealedOwner(eTeam, bDebug);

	movzx	eax, BYTE PTR _bDebug$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedOwner
	mov	DWORD PTR _eRevealedOwner$[ebp], eax

; 8426 : 
; 8427 : 	if(eRevealedOwner != NO_PLAYER)

	cmp	DWORD PTR _eRevealedOwner$[ebp], -1
	je	SHORT $LN2@getReveale@2

; 8428 : 	{
; 8429 : 		return GET_PLAYER(eRevealedOwner).getTeam();

	mov	edx, DWORD PTR _eRevealedOwner$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251866[ebp], edx
	mov	eax, DWORD PTR $T251866[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	jmp	SHORT $LN3@getReveale@2

; 8430 : 	}
; 8431 : 	else

	jmp	SHORT $LN3@getReveale@2
$LN2@getReveale@2:

; 8432 : 	{
; 8433 : 		return NO_TEAM;

	or	eax, -1
$LN3@getReveale@2:

; 8434 : 	}
; 8435 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z ENDP ; CvPlot::getRevealedTeam
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getRevealedOwner, COMDAT
; _this$ = ecx

; 8439 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8440 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8441 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8442 : 
; 8443 : 	return (PlayerTypes)m_aiRevealedOwner[eTeam];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]

; 8444 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getRevealedOwner
_TEXT	ENDS
PUBLIC	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z ; CvPlot::getRevealedTeam
; Function compile flags: /Odtp
;	COMDAT ?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T251882 = -8						; size = 4
_eRevealedOwner$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z PROC	; CvPlot::getRevealedTeam, COMDAT
; _this$ = ecx

; 8449 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 8450 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8451 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8452 : 
; 8453 : 	PlayerTypes eRevealedOwner = getRevealedOwner(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner
	mov	DWORD PTR _eRevealedOwner$[ebp], eax

; 8454 : 
; 8455 : 	if(eRevealedOwner != NO_PLAYER)

	cmp	DWORD PTR _eRevealedOwner$[ebp], -1
	je	SHORT $LN2@getReveale@3

; 8456 : 	{
; 8457 : 		return GET_PLAYER(eRevealedOwner).getTeam();

	mov	ecx, DWORD PTR _eRevealedOwner$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T251882[ebp], ecx
	mov	edx, DWORD PTR $T251882[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	jmp	SHORT $LN3@getReveale@3

; 8458 : 	}
; 8459 : 	else

	jmp	SHORT $LN3@getReveale@3
$LN2@getReveale@3:

; 8460 : 	{
; 8461 : 		return NO_TEAM;

	or	eax, -1
$LN3@getReveale@3:

; 8462 : 	}
; 8463 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z ENDP	; CvPlot::getRevealedTeam
_TEXT	ENDS
PUBLIC	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner
EXTRN	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvTeam::SetHasFoundPlayersTerritory
; Function compile flags: /Odtp
;	COMDAT ?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_eNewValue$ = 12					; size = 4
?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlot::setRevealedOwner, COMDAT
; _this$ = ecx

; 8468 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8469 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8470 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8471 : 
; 8472 : 	if(getRevealedOwner(eTeam, false) != eNewValue)

	push	0
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedOwner
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	je	SHORT $LN2@setReveale

; 8473 : 	{
; 8474 : 		m_aiRevealedOwner[eTeam] = eNewValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+160]
	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	cl, BYTE PTR _eNewValue$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 8475 : 
; 8476 : 		// Let the team know we've found someone (if eNewValue IS someone)
; 8477 : 		if(eNewValue != NO_PLAYER)

	cmp	DWORD PTR _eNewValue$[ebp], -1
	je	SHORT $LN1@setReveale

; 8478 : 		{
; 8479 : 			GET_TEAM(eTeam).SetHasFoundPlayersTerritory(eNewValue, true);

	push	1
	mov	edx, DWORD PTR _eNewValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ; CvTeam::SetHasFoundPlayersTerritory
$LN1@setReveale:

; 8480 : 		}
; 8481 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@setReveale
$LN2@setReveale:

; 8482 : 	}
; 8483 : 
; 8484 : 	CvAssert(m_aiRevealedOwner[eTeam] == eNewValue);
; 8485 : 	return false;

	xor	al, al
$LN3@setReveale:

; 8486 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlot::setRevealedOwner
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z
_TEXT	SEGMENT
tv95 = -120						; size = 4
_this$ = -116						; size = 4
$T252134 = -109						; size = 1
$T251917 = -20						; size = 4
$T251913 = -16						; size = 4
$T251909 = -10						; size = 1
_bRevealed$ = -9					; size = 1
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z PROC	; CvPlot::updateRevealedOwner, COMDAT
; _this$ = ecx

; 8491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 8492 : 	CvPlot* pAdjacentPlot;
; 8493 : 	bool bRevealed;
; 8494 : 	int iI;
; 8495 : 
; 8496 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8497 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8498 : 
; 8499 : 	bRevealed = false;

	mov	BYTE PTR _bRevealed$[ebp], 0

; 8500 : 
; 8501 : 	if(!bRevealed)

	movzx	eax, BYTE PTR _bRevealed$[ebp]
	test	eax, eax
	jne	SHORT $LN8@updateReve

; 8502 : 	{
; 8503 : 		if(isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN16@updateReve
	mov	BYTE PTR $T251909[ebp], 0
	jmp	SHORT $LN14@updateReve
$LN16@updateReve:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _eTeam$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T251909[ebp], dl
$LN14@updateReve:
	movzx	eax, BYTE PTR $T251909[ebp]
	test	eax, eax
	je	SHORT $LN8@updateReve

; 8504 : 		{
; 8505 : 			bRevealed = true;

	mov	BYTE PTR _bRevealed$[ebp], 1
$LN8@updateReve:

; 8506 : 		}
; 8507 : 	}
; 8508 : 
; 8509 : 	if(!bRevealed)

	movzx	ecx, BYTE PTR _bRevealed$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@updateReve

; 8510 : 	{
; 8511 : 		for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@updateReve
$LN4@updateReve:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN5@updateReve:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN6@updateReve

; 8512 : 		{
; 8513 : 			pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T251913[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T251917[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T251913[ebp]
	push	edx
	mov	eax, DWORD PTR $T251917[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 8514 : 
; 8515 : 			if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@updateReve

; 8516 : 			{
; 8517 : 				if(pAdjacentPlot->isVisible(eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN109@updateReve
	mov	BYTE PTR $T252134[ebp], 0
	jmp	SHORT $LN107@updateReve
$LN109@updateReve:
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _eTeam$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T252134[ebp], dl
$LN107@updateReve:
	movzx	eax, BYTE PTR $T252134[ebp]
	test	eax, eax
	je	SHORT $LN2@updateReve

; 8518 : 				{
; 8519 : 					bRevealed = true;

	mov	BYTE PTR _bRevealed$[ebp], 1

; 8520 : 					break;

	jmp	SHORT $LN6@updateReve
$LN2@updateReve:

; 8521 : 				}
; 8522 : 			}
; 8523 : 		}

	jmp	SHORT $LN4@updateReve
$LN6@updateReve:

; 8524 : 	}
; 8525 : 
; 8526 : 	setRevealedOwner(eTeam, ((bRevealed) ? getOwner() : NO_PLAYER));

	movzx	ecx, BYTE PTR _bRevealed$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@updateReve
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN12@updateReve
$LN11@updateReve:
	mov	DWORD PTR tv95[ebp], -1
$LN12@updateReve:
	mov	ecx, DWORD PTR tv95[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner

; 8527 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateRevealedOwner@CvPlot@@QAEXW4TeamTypes@@@Z ENDP	; CvPlot::updateRevealedOwner
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iFlowMask$ = -4					; size = 4
_eIndex$ = 8						; size = 4
?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z PROC	; CvPlot::isRiverCrossing, COMDAT
; _this$ = ecx

; 8532 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 8533 : 	CvAssertMsg(eIndex < NUM_DIRECTION_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8534 : 
; 8535 : 	if(eIndex == NO_DIRECTION)

	cmp	DWORD PTR _eIndex$[ebp], -1
	jne	SHORT $LN1@isRiverCro@2

; 8536 : 	{
; 8537 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@isRiverCro@2
$LN1@isRiverCro@2:

; 8538 : 	}
; 8539 : 
; 8540 : 	int iFlowMask = 1 << eIndex;

	mov	eax, 1
	mov	ecx, DWORD PTR _eIndex$[ebp]
	shl	eax, cl
	mov	DWORD PTR _iFlowMask$[ebp], eax

; 8541 : 
; 8542 : 	return ((m_cRiverCrossing & iFlowMask) != 0);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [ecx+460]
	and	eax, DWORD PTR _iFlowMask$[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax
$LN2@isRiverCro@2:

; 8543 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ENDP	; CvPlot::isRiverCrossing
_TEXT	ENDS
PUBLIC	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
; Function compile flags: /Odtp
;	COMDAT ?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv81 = -112						; size = 4
_this$ = -108						; size = 4
$T252149 = -16						; size = 4
$T252145 = -12						; size = 4
_iFlowMask$225581 = -6					; size = 1
_bValid$ = -5						; size = 1
_pPlot$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z PROC ; CvPlot::updateRiverCrossing, COMDAT
; _this$ = ecx

; 8548 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 8549 : 
; 8550 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 8551 : 	CvAssertMsg(eIndex < NUM_DIRECTION_TYPES, "eIndex is expected to be within maximum bounds (invalid Index)");
; 8552 : 
; 8553 : 	bool bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0

; 8554 : 	CvPlot* pPlot = plotDirection(getX(), getY(), eIndex);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T252145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T252149[ebp], eax
	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252145[ebp]
	push	edx
	mov	eax, DWORD PTR $T252149[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pPlot$[ebp], eax

; 8555 : 
; 8556 : 	if((NULL == pPlot) || (!pPlot->isWater() && !isWater()))  // if there is no plot in that direction or both plots are land

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN16@updateRive
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN17@updateRive
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN17@updateRive
$LN16@updateRive:

; 8557 : 	{
; 8558 : 		switch(eIndex)

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 5
	ja	SHORT $LN17@updateRive
	mov	ecx, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $LN112@updateRive[ecx*4]
$LN13@updateRive:

; 8559 : 		{
; 8560 : 
; 8561 : 		case DIRECTION_NORTHEAST:
; 8562 : 		{
; 8563 : 			if(pPlot && pPlot->isNEOfRiver())

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN12@updateRive
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN12@updateRive

; 8564 : 			{
; 8565 : 				bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 8566 : 				break;

	jmp	SHORT $LN17@updateRive
$LN12@updateRive:

; 8567 : 			}
; 8568 : 		}
; 8569 : 		break;

	jmp	SHORT $LN17@updateRive
$LN11@updateRive:

; 8570 : 
; 8571 : 		case DIRECTION_EAST:
; 8572 : 			bValid = isWOfRiver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	mov	BYTE PTR _bValid$[ebp], al

; 8573 : 			break;

	jmp	SHORT $LN17@updateRive
$LN10@updateRive:

; 8574 : 
; 8575 : 		case DIRECTION_SOUTHEAST:
; 8576 : 			bValid = isNWOfRiver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	mov	BYTE PTR _bValid$[ebp], al

; 8577 : 			break;

	jmp	SHORT $LN17@updateRive
$LN9@updateRive:

; 8578 : 
; 8579 : 		case DIRECTION_SOUTHWEST:
; 8580 : 			bValid = isNEOfRiver();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	mov	BYTE PTR _bValid$[ebp], al

; 8581 : 			break;

	jmp	SHORT $LN17@updateRive
$LN8@updateRive:

; 8582 : 
; 8583 : 		case DIRECTION_WEST:
; 8584 : 			if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN7@updateRive

; 8585 : 			{
; 8586 : 				bValid = pPlot->isWOfRiver();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	mov	BYTE PTR _bValid$[ebp], al
$LN7@updateRive:

; 8587 : 			}
; 8588 : 			break;

	jmp	SHORT $LN17@updateRive
$LN6@updateRive:

; 8589 : 
; 8590 : 		case DIRECTION_NORTHWEST:
; 8591 : 			if(pPlot != NULL)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	SHORT $LN17@updateRive

; 8592 : 			{
; 8593 : 				bValid = pPlot->isNWOfRiver();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	mov	BYTE PTR _bValid$[ebp], al
$LN17@updateRive:

; 8594 : 			}
; 8595 : 			break;
; 8596 : 
; 8597 : 		default:
; 8598 : 			CvAssert(false);
; 8599 : 			break;
; 8600 : 		}
; 8601 : 	}
; 8602 : 
; 8603 : 	if(isRiverCrossing(eIndex) != bValid)

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	movzx	edx, BYTE PTR _bValid$[ebp]
	cmp	ecx, edx
	je	SHORT $LN18@updateRive

; 8604 : 	{
; 8605 : 		char iFlowMask = 1 << eIndex;

	mov	eax, 1
	mov	ecx, DWORD PTR _eIndex$[ebp]
	shl	eax, cl
	mov	BYTE PTR _iFlowMask$225581[ebp], al

; 8606 : 		if(bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@updateRive

; 8607 : 		{
; 8608 : 			m_cRiverCrossing |= iFlowMask;

	movsx	edx, BYTE PTR _iFlowMask$225581[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+460]
	or	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+460], cl

; 8609 : 			changeRiverCrossingCount(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeRiverCrossingCount@CvPlot@@QAEXH@Z ; CvPlot::changeRiverCrossingCount

; 8610 : 		}
; 8611 : 		else

	jmp	SHORT $LN18@updateRive
$LN2@updateRive:

; 8612 : 		{
; 8613 : 			m_cRiverCrossing &= ~iFlowMask;

	movsx	eax, BYTE PTR _iFlowMask$225581[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+460]
	and	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+460], dl

; 8614 : 			changeRiverCrossingCount(-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeRiverCrossingCount@CvPlot@@QAEXH@Z ; CvPlot::changeRiverCrossingCount
$LN18@updateRive:

; 8615 : 		}
; 8616 : 	}
; 8617 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN112@updateRive:
	DD	$LN13@updateRive
	DD	$LN11@updateRive
	DD	$LN10@updateRive
	DD	$LN9@updateRive
	DD	$LN8@updateRive
	DD	$LN6@updateRive
?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ENDP ; CvPlot::updateRiverCrossing
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?updateRiverCrossing@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$ = -4						; size = 4
?updateRiverCrossing@CvPlot@@QAEXXZ PROC		; CvPlot::updateRiverCrossing, COMDAT
; _this$ = ecx

; 8622 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 8623 : 	int iI;
; 8624 : 
; 8625 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateRive@2
$LN2@updateRive@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateRive@2:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN4@updateRive@2

; 8626 : 	{
; 8627 : 		updateRiverCrossing((DirectionTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateRiverCrossing@CvPlot@@QAEXW4DirectionTypes@@@Z ; CvPlot::updateRiverCrossing
	jmp	SHORT $LN2@updateRive@2
$LN4@updateRive@2:

; 8628 : 	}
; 8629 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateRiverCrossing@CvPlot@@QAEXXZ ENDP		; CvPlot::updateRiverCrossing
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z PROC ; CvPlot::IsResourceForceReveal, COMDAT
; _this$ = ecx

; 8634 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8635 : 	return m_abResourceForceReveal[eTeam];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _eTeam$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 8636 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP ; CvPlot::IsResourceForceReveal
_TEXT	ENDS
PUBLIC	?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z ; CvPlot::SetResourceForceReveal
; Function compile flags: /Odtp
;	COMDAT ?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z PROC ; CvPlot::SetResourceForceReveal, COMDAT
; _this$ = ecx

; 8641 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8642 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8643 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8644 : 	m_abResourceForceReveal[eTeam] = bValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _eTeam$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 8645 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetResourceForceReveal@CvPlot@@QAEXW4TeamTypes@@_N@Z ENDP ; CvPlot::SetResourceForceReveal
_TEXT	ENDS
PUBLIC	?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z	; CvPlot::IsNoSettling
; Function compile flags: /Odtp
;	COMDAT ?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eMajor$ = 8						; size = 4
?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC	; CvPlot::IsNoSettling, COMDAT
; _this$ = ecx

; 8649 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8650 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 8651 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 8652 : 
; 8653 : 	return m_abNoSettling[eMajor];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	edx, DWORD PTR _eMajor$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 8654 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP	; CvPlot::IsNoSettling
_TEXT	ENDS
PUBLIC	?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z	; CvPlot::SetNoSettling
; Function compile flags: /Odtp
;	COMDAT ?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eMajor$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z PROC	; CvPlot::SetNoSettling, COMDAT
; _this$ = ecx

; 8658 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 8659 : 	CvAssertMsg(eMajor >= 0, "eMajor is expected to be non-negative (invalid Index)");
; 8660 : 	CvAssertMsg(eMajor < MAX_MAJOR_CIVS, "eMajor is expected to be within maximum bounds (invalid Index)");
; 8661 : 
; 8662 : 	if(bValue != IsNoSettling(eMajor))

	movzx	esi, BYTE PTR _bValue$[ebp]
	mov	eax, DWORD PTR _eMajor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsNoSettling@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsNoSettling
	movzx	ecx, al
	cmp	esi, ecx
	je	SHORT $LN2@SetNoSettl

; 8663 : 		m_abNoSettling[eMajor] = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	ecx, DWORD PTR _eMajor$[ebp]
	mov	dl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl
$LN2@SetNoSettl:

; 8664 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetNoSettling@CvPlot@@QAEXW4PlayerTypes@@_N@Z ENDP	; CvPlot::SetNoSettling
_TEXT	ENDS
PUBLIC	??_C@_0CN@NFGJELEM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ ; `string'
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
PUBLIC	??_C@_0CF@MNIFPDPL@TXT_KEY_NOTIFICATION_FOUND_GOODY@ ; `string'
PUBLIC	??_C@_0BC@GLIGLMLG@FEATURE_EL_DORADO?$AA@	; `string'
PUBLIC	??_C@_0BH@EEIKGJAB@FEATURE_FOUNTAIN_YOUTH?$AA@	; `string'
PUBLIC	??_C@_0CH@LBEHLJKE@?$FLCOLOR_WHITE?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON_@ ; `string'
PUBLIC	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ		; sprintf_s<256>
PUBLIC	??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@ ; `string'
PUBLIC	__real@40400000
PUBLIC	??_C@_0BA@BEBKMHGP@HANDICAP_PRINCE?$AA@		; `string'
PUBLIC	??_C@_0DC@HCANBME@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ ; `string'
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
PUBLIC	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z	; operator<<<int>
PUBLIC	??_C@_0CK@FPOCNCCI@TXT_KEY_NOTIFICATION_FOUND_NATUR@ ; `string'
PUBLIC	??_C@_0BI@ELMNPECH@NaturalWonderDiscovered?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?setRevealed@CvCity@@QAE_NW4TeamTypes@@_N@Z:PROC ; CvCity::setRevealed
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	?CancelActivePlayerEndTurn@@YA_NXZ:PROC		; CancelActivePlayerEndTurn
EXTRN	?ChangeFaith@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::ChangeFaith
EXTRN	?ChangeGold@CvTreasury@@QAEXH@Z:PROC		; CvTreasury::ChangeGold
EXTRN	?getNumMembers@CvTeam@@QBEHXZ:PROC		; CvTeam::getNumMembers
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?getBarbCampGold@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getBarbCampGold
EXTRN	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z:PROC ; CvGlobals::getHandicapInfo
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?getFirstFinderGold@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getFirstFinderGold
EXTRN	?isObserver@CvTeam@@QBE_NXZ:PROC		; CvTeam::isObserver
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDXZ:PROC
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?ChangeNumNaturalWondersDiscoveredInArea@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeNumNaturalWondersDiscoveredInArea
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ:PROC ; CvTeam::GetNumNaturalWondersDiscovered
EXTRN	?GetNumNaturalWonders@CvMap@@QBEHXZ:PROC	; CvMap::GetNumNaturalWonders
EXTRN	?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z:PROC ; CvTeam::ChangeNumNaturalWondersDiscovered
EXTRN	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z:PROC ; CvArea::changeNumRevealedTiles
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CN@NFGJELEM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
CONST	SEGMENT
??_C@_0CN@NFGJELEM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_FOUND_GOODY_HUT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MNIFPDPL@TXT_KEY_NOTIFICATION_FOUND_GOODY@
CONST	SEGMENT
??_C@_0CF@MNIFPDPL@TXT_KEY_NOTIFICATION_FOUND_GOODY@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_FOUND_GOODY_HUT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GLIGLMLG@FEATURE_EL_DORADO?$AA@
CONST	SEGMENT
??_C@_0BC@GLIGLMLG@FEATURE_EL_DORADO?$AA@ DB 'FEATURE_EL_DORADO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EEIKGJAB@FEATURE_FOUNTAIN_YOUTH?$AA@
CONST	SEGMENT
??_C@_0BH@EEIKGJAB@FEATURE_FOUNTAIN_YOUTH?$AA@ DB 'FEATURE_FOUNTAIN_YOUTH'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LBEHLJKE@?$FLCOLOR_WHITE?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON_@
CONST	SEGMENT
??_C@_0CH@LBEHLJKE@?$FLCOLOR_WHITE?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON_@ DB '['
	DB	'COLOR_WHITE]+%d[ENDCOLOR][ICON_PEACE]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@
CONST	SEGMENT
??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@ DB '['
	DB	'COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]', 00H	; `string'
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT ??_C@_0BA@BEBKMHGP@HANDICAP_PRINCE?$AA@
CONST	SEGMENT
??_C@_0BA@BEBKMHGP@HANDICAP_PRINCE?$AA@ DB 'HANDICAP_PRINCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HCANBME@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
CONST	SEGMENT
??_C@_0DC@HCANBME@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ DB 'TXT_KEY_NOTIFICAT'
	DB	'ION_SUMMARY_FOUND_NATURAL_WONDER', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FPOCNCCI@TXT_KEY_NOTIFICATION_FOUND_NATUR@
CONST	SEGMENT
??_C@_0CK@FPOCNCCI@TXT_KEY_NOTIFICATION_FOUND_NATUR@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_FOUND_NATURAL_WONDER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ELMNPECH@NaturalWonderDiscovered?$AA@
CONST	SEGMENT
??_C@_0BI@ELMNPECH@NaturalWonderDiscovered?$AA@ DB 'NaturalWonderDiscover'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
_TEXT	SEGMENT
tv922 = -1836						; size = 4
tv867 = -1832						; size = 4
tv811 = -1828						; size = 4
tv801 = -1824						; size = 4
tv784 = -1820						; size = 4
tv764 = -1816						; size = 4
tv1307 = -1812						; size = 4
tv726 = -1808						; size = 4
tv666 = -1804						; size = 4
tv647 = -1800						; size = 4
tv587 = -1796						; size = 4
tv224 = -1792						; size = 4
tv215 = -1788						; size = 4
tv206 = -1784						; size = 4
tv197 = -1780						; size = 4
tv190 = -1776						; size = 4
tv179 = -1772						; size = 4
tv133 = -1768						; size = 4
_this$ = -1764						; size = 4
$T252941 = -1760					; size = 4
$T252937 = -1756					; size = 4
$T252933 = -1752					; size = 4
$T252929 = -1748					; size = 4
_uiOffset$252921 = -1744				; size = 4
$T252912 = -1740					; size = 4
$T252897 = -1736					; size = 4
$T252893 = -1732					; size = 4
$T252889 = -1728					; size = 4
$T252877 = -1721					; size = 1
$T252865 = -1720					; size = 4
_uiOffset$252860 = -1716				; size = 4
_inst$252849 = -1712					; size = 4
$T252846 = -1708					; size = 4
$T252834 = -1704					; size = 4
$T252823 = -1700					; size = 4
$T252819 = -1696					; size = 4
$T252807 = -1692					; size = 4
_f$252800 = -1685					; size = 1
$T252794 = -1684					; size = 4
$T252790 = -1680					; size = 4
$T252778 = -1676					; size = 4
$T252774 = -1672					; size = 4
$T252770 = -1668					; size = 4
$T252763 = -1664					; size = 4
$T252759 = -1660					; size = 4
$T252755 = -1656					; size = 4
$T252748 = -1652					; size = 4
$T252744 = -1648					; size = 4
$T252740 = -1644					; size = 4
$T252728 = -1637					; size = 1
$T252713 = -1636					; size = 4
$T252709 = -1632					; size = 4
$T252705 = -1628					; size = 4
$T252693 = -1621					; size = 1
$T252681 = -1620					; size = 4
$T252677 = -1616					; size = 4
$T252676 = -1612					; size = 4
$T252664 = -1605					; size = 1
$T252652 = -1604					; size = 4
$T252651 = -1600					; size = 4
$T252639 = -1593					; size = 1
$T252627 = -1592					; size = 4
$T252626 = -1588					; size = 4
$T252614 = -1581					; size = 1
$T252602 = -1580					; size = 4
$T252601 = -1576					; size = 4
$T252589 = -1570					; size = 1
_f$252574 = -1569					; size = 1
$T252565 = -1568					; size = 4
$T252561 = -1564					; size = 4
_f$252554 = -1557					; size = 1
$T252548 = -1556					; size = 4
_f$252541 = -1549					; size = 1
$T252535 = -1548					; size = 4
$T252534 = -1544					; size = 4
$T252530 = -1540					; size = 4
$T252518 = -1535					; size = 1
_f$252503 = -1534					; size = 1
_f$252476 = -1533					; size = 1
$T252464 = -1532					; size = 4
$T252460 = -1528					; size = 4
$T252456 = -1524					; size = 4
_f$252449 = -1518					; size = 1
_f$252440 = -1517					; size = 1
$T252431 = -1516					; size = 4
$T252427 = -1512					; size = 4
$T252426 = -1508					; size = 4
$T252422 = -1504					; size = 4
$T252418 = -1500					; size = 4
_uiOffset$252417 = -1496				; size = 4
_uiOffset$252412 = -1492				; size = 4
$T252400 = -1488					; size = 4
$T252381 = -1480					; size = 4
$T252380 = -1476					; size = 4
$T252379 = -1472					; size = 4
_bImprovementVisibilityChanged$225786 = -1466		; size = 1
_bVisibilityChanged$225785 = -1465			; size = 1
_pNotifications$225779 = -1464				; size = 4
_playerI$225775 = -1460					; size = 4
_strBuffer$225765 = -1456				; size = 28
_strSummary$225768 = -1428				; size = 28
_strFeatureType$225747 = -1400				; size = 28
_pkFeatureInfo$225745 = -1372				; size = 4
_kActivePlayer$225742 = -1368				; size = 4
_kPopupInfo$225741 = -1364				; size = 536
_bDontShowRewardPopup$225739 = -821			; size = 1
_pDllPlot$225758 = -820					; size = 4
_fDelay$225736 = -816					; size = 4
_text$225735 = -812					; size = 256
_playerI$225730 = -552					; size = 4
_iFaithPerTeamMember$225725 = -548			; size = 4
_fDelay$225717 = -544					; size = 4
_text$225716 = -540					; size = 256
__$ArrayPad$ = -284					; size = 4
_playerI$225711 = -280					; size = 4
_iGoldPerTeamMember$225706 = -276			; size = 4
_pkHandicapInfo$225702 = -272				; size = 4
_iStandardHandicap$225699 = -268			; size = 4
_iIncrease$225693 = -264				; size = 4
_playerI$225694 = -260					; size = 4
_playerI$225686 = -256					; size = 4
_iIncrease$225677 = -252				; size = 4
_playerI$225678 = -248					; size = 4
_playerI$225670 = -244					; size = 4
_pNotifications$225658 = -240				; size = 4
_playerI$225651 = -236					; size = 4
_bResult$225634 = -229					; size = 1
_args$225633 = -228					; size = 4
_bFirstFinder$225663 = -221				; size = 1
_iNumNaturalWondersLeft$225630 = -220			; size = 4
_iFinderGold$225661 = -216				; size = 4
_strText$225636 = -212					; size = 80
_strSummary$225645 = -132				; size = 80
_kTeam$225664 = -48					; size = 4
_pkScriptSystem$225631 = -44				; size = 4
_iFinderFaith$225662 = -40				; size = 4
_bEligibleForAchievement$225624 = -33			; size = 1
_pInterface$ = -32					; size = 4
_eActiveTeam$ = -28					; size = 4
_bVisbilityUpdated$ = -21				; size = 1
_pCity$ = -20						; size = 4
_iI$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_bTerrainOnly$ = 16					; size = 1
_eFromTeam$ = 20					; size = 4
?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z PROC	; CvPlot::setRevealed, COMDAT
; _this$ = ecx

; 8668 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1824				; 00000720H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 8669 : 	int iI;
; 8670 : 
; 8671 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 8672 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 8673 : 
; 8674 : 	CvCity* pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 8675 : 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252400[ebp], eax
	mov	ecx, DWORD PTR $T252400[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eActiveTeam$[ebp], eax

; 8676 : 	ICvUserInterface2* pInterface =  GC.GetEngineUserInterface();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR _pInterface$[ebp], ecx

; 8677 : 
; 8678 : 	bool bVisbilityUpdated = false;

	mov	BYTE PTR _bVisbilityUpdated$[ebp], 0

; 8679 : 	if(isRevealed(eTeam) != bNewValue)

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$252412[ebp], edx
	mov	eax, DWORD PTR _uiOffset$252412[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$252412[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	cmp	eax, ecx
	je	$LN18@setReveale@2

; 8680 : 	{
; 8681 : 
; 8682 : 		m_bfRevealed.ToggleBit(eTeam);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T252418[ebp], edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$252417[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$252417[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$252417[ebp]
	mov	edx, DWORD PTR $T252418[ebp]
	xor	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _uiOffset$252417[ebp]
	mov	edx, DWORD PTR $T252418[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 8683 : 
; 8684 : 		bool bEligibleForAchievement = GET_PLAYER(GC.getGame().getActivePlayer()).isHuman() && !GC.getGame().isGameMultiPlayer();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252422[ebp], eax
	mov	ecx, DWORD PTR $T252422[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR $T252426[ebp], eax
	mov	ecx, DWORD PTR $T252426[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T252427[ebp], ecx
	mov	ecx, DWORD PTR $T252427[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN101@setReveale@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252431[ebp], eax
	mov	ecx, DWORD PTR $T252431[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN101@setReveale@2
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN102@setReveale@2
$LN101@setReveale@2:
	mov	DWORD PTR tv133[ebp], 0
$LN102@setReveale@2:
	mov	dl, BYTE PTR tv133[ebp]
	mov	BYTE PTR _bEligibleForAchievement$225624[ebp], dl

; 8685 : 
; 8686 : 		if(area())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	test	eax, eax
	je	SHORT $LN97@setReveale@2

; 8687 : 		{
; 8688 : 			area()->changeNumRevealedTiles(eTeam, (bNewValue ? 1 : -1));

	movzx	eax, BYTE PTR _bNewValue$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 2
	add	eax, -1
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ; CvArea::changeNumRevealedTiles
$LN97@setReveale@2:

; 8689 : 		}
; 8690 : 
; 8691 : 		// Natural Wonder
; 8692 : 		if(eTeam != BARBARIAN_TEAM)

	cmp	DWORD PTR _eTeam$[ebp], 63		; 0000003fH
	je	$LN94@setReveale@2

; 8693 : 		{
; 8694 : 			if(getFeatureType() != NO_FEATURE)

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$252440[ebp], al
	movsx	ecx, BYTE PTR _f$252440[ebp]
	cmp	ecx, -1
	je	$LN94@setReveale@2

; 8695 : 			{
; 8696 : 				if(GC.getFeatureInfo(getFeatureType())->IsNaturalWonder())

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$252449[ebp], al
	movsx	ecx, BYTE PTR _f$252449[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	edx, al
	test	edx, edx
	je	$LN94@setReveale@2

; 8697 : 				{
; 8698 : 					GET_TEAM(eTeam).ChangeNumNaturalWondersDiscovered(1);

	push	1
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?ChangeNumNaturalWondersDiscovered@CvTeam@@QAEXH@Z ; CvTeam::ChangeNumNaturalWondersDiscovered

; 8699 : 
; 8700 : 					int iNumNaturalWondersLeft = GC.getMap().GetNumNaturalWonders() - GET_TEAM(eTeam).GetNumNaturalWondersDiscovered();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T252456[ebp], eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T252460[ebp], ecx
	mov	ecx, DWORD PTR $T252456[ebp]
	call	?GetNumNaturalWonders@CvMap@@QBEHXZ	; CvMap::GetNumNaturalWonders
	mov	esi, eax
	mov	ecx, DWORD PTR $T252460[ebp]
	call	?GetNumNaturalWondersDiscovered@CvTeam@@QBEHXZ ; CvTeam::GetNumNaturalWondersDiscovered
	sub	esi, eax
	mov	DWORD PTR _iNumNaturalWondersLeft$225630[ebp], esi

; 8701 : 
; 8702 : 					ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T252464[ebp]
	mov	DWORD PTR tv179[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv179[ebp], eax
	mov	ecx, DWORD PTR tv179[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv179[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$225631[ebp], eax

; 8703 : 					if (pkScriptSystem) 

	cmp	DWORD PTR _pkScriptSystem$225631[ebp], 0
	je	$LN93@setReveale@2

; 8704 : 					{
; 8705 : 						CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225633[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 8706 : 						args->Push(eTeam);

	mov	ecx, DWORD PTR _args$225633[ebp]
	mov	DWORD PTR tv190[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR tv190[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv190[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 8707 : 						args->Push(getFeatureType());

	mov	ecx, DWORD PTR _args$225633[ebp]
	mov	DWORD PTR tv197[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$252476[ebp], al
	movsx	ecx, BYTE PTR _f$252476[ebp]
	push	ecx
	mov	edx, DWORD PTR tv197[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv197[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 8708 : 						args->Push(getX());

	mov	eax, DWORD PTR _args$225633[ebp]
	mov	DWORD PTR tv206[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR tv206[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv206[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 8709 : 						args->Push(getY());

	mov	ecx, DWORD PTR _args$225633[ebp]
	mov	DWORD PTR tv215[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR tv215[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv215[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 8710 : 						args->Push((getNumMajorCivsRevealed() == 0)); // bFirst

	mov	ecx, DWORD PTR _args$225633[ebp]
	mov	DWORD PTR tv224[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumMajorCivsRevealed@CvPlot@@QBEHXZ	; CvPlot::getNumMajorCivsRevealed
	test	eax, eax
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR tv224[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv224[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 8711 : 
; 8712 : 						bool bResult = false;

	mov	BYTE PTR _bResult$225634[ebp], 0

; 8713 : 						LuaSupport::CallHook(pkScriptSystem, "NaturalWonderDiscovered", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$225634[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$225633[ebp]
	push	edx
	push	OFFSET ??_C@_0BI@ELMNPECH@NaturalWonderDiscovered?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$225631[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 8714 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$225633[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN93@setReveale@2:

; 8715 : 
; 8716 : 					Localization::String strText = Localization::Lookup("TXT_KEY_NOTIFICATION_FOUND_NATURAL_WONDER");

	push	OFFSET ??_C@_0CK@FPOCNCCI@TXT_KEY_NOTIFICATION_FOUND_NATUR@
	lea	ecx, DWORD PTR _strText$225636[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 8717 : 					strText << iNumNaturalWondersLeft;

	lea	edx, DWORD PTR _iNumNaturalWondersLeft$225630[ebp]
	push	edx
	lea	eax, DWORD PTR _strText$225636[ebp]
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8

; 8718 : 					strText << GC.getFeatureInfo(getFeatureType())->GetTextKey();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$252503[ebp], dl
	movsx	eax, BYTE PTR _f$252503[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T252379[ebp], eax
	lea	ecx, DWORD PTR $T252379[ebp]
	push	ecx
	lea	edx, DWORD PTR _strText$225636[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 8719 : 					Localization::String strSummary = Localization::Lookup("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_NATURAL_WONDER");

	push	OFFSET ??_C@_0DC@HCANBME@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
	lea	eax, DWORD PTR _strSummary$225645[ebp]
	push	eax
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 8720 : 
; 8721 : 					// Loop through all players to give them a Notification
; 8722 : 					for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN92@setReveale@2
$LN91@setReveale@2:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN92@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN90@setReveale@2

; 8723 : 					{
; 8724 : 						CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225651[ebp], edx

; 8725 : 						if(playerI.isAlive())

	mov	eax, DWORD PTR _playerI$225651[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T252518[ebp], cl
	movzx	edx, BYTE PTR $T252518[ebp]
	test	edx, edx
	je	$LN84@setReveale@2

; 8726 : 						{
; 8727 : 							if(playerI.getTeam() == eTeam)

	mov	eax, DWORD PTR _playerI$225651[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	$LN84@setReveale@2

; 8728 : 							{
; 8729 : 								// Num Natural Wonders found in a player's area
; 8730 : 								if(playerI.getStartingPlot() != NULL)

	mov	ecx, DWORD PTR _playerI$225651[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	je	SHORT $LN86@setReveale@2

; 8731 : 								{
; 8732 : 									if(getArea() == playerI.getStartingPlot()->getArea())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T252530[ebp], eax
	mov	ecx, DWORD PTR _playerI$225651[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	DWORD PTR $T252534[ebp], eax
	mov	ecx, DWORD PTR $T252534[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T252535[ebp], edx
	mov	eax, DWORD PTR $T252530[ebp]
	cmp	eax, DWORD PTR $T252535[ebp]
	jne	SHORT $LN86@setReveale@2

; 8733 : 									{
; 8734 : 										playerI.ChangeNumNaturalWondersDiscoveredInArea(1);

	push	1
	mov	ecx, DWORD PTR _playerI$225651[ebp]
	call	?ChangeNumNaturalWondersDiscoveredInArea@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumNaturalWondersDiscoveredInArea
$LN86@setReveale@2:

; 8735 : 									}
; 8736 : 								}
; 8737 : 
; 8738 : 								playerI.DoUpdateHappiness();

	mov	ecx, DWORD PTR _playerI$225651[ebp]
	call	?DoUpdateHappiness@CvPlayer@@QAEXXZ	; CvPlayer::DoUpdateHappiness

; 8739 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 8740 : 								playerI.doSelfConsistencyCheckAllCities();
; 8741 : #endif
; 8742 : 
; 8743 : 								// Add World Anchor
; 8744 : 								if(eTeam == eActiveTeam)

	mov	ecx, DWORD PTR _eTeam$[ebp]
	cmp	ecx, DWORD PTR _eActiveTeam$[ebp]
	jne	SHORT $LN85@setReveale@2

; 8745 : 									SetWorldAnchor(WORLD_ANCHOR_NATURAL_WONDER, getFeatureType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$252541[ebp], al
	movsx	ecx, BYTE PTR _f$252541[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetWorldAnchor@CvPlot@@QAEXW4GenericWorldAnchorTypes@@H@Z ; CvPlot::SetWorldAnchor
$LN85@setReveale@2:

; 8746 : 
; 8747 : 								// Notification
; 8748 : 								CvNotifications* pNotifications = GET_PLAYER((PlayerTypes)iI).GetNotifications();

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T252548[ebp], edx
	mov	ecx, DWORD PTR $T252548[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225658[ebp], eax

; 8749 : 								if(pNotifications)

	cmp	DWORD PTR _pNotifications$225658[ebp], 0
	je	SHORT $LN84@setReveale@2

; 8750 : 								{
; 8751 : 									pNotifications->Add(NOTIFICATION_EXPLORATION_RACE, strText.toUTF8(), strSummary.toUTF8(), getX(), getY(), getFeatureType());

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$252554[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T252561[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T252565[ebp], edx
	push	-1
	movsx	eax, BYTE PTR _f$252554[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252561[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252565[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$225645[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strText$225636[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDXZ
	push	eax
	push	-1753116946				; 97818eeeH
	mov	ecx, DWORD PTR _pNotifications$225658[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN84@setReveale@2:

; 8752 : 								}
; 8753 : 							}
; 8754 : 						}
; 8755 : 					}

	jmp	$LN91@setReveale@2
$LN90@setReveale@2:

; 8756 : 
; 8757 : 					// FIRST (MAJOR CIV) FINDER?
; 8758 : 					int iFinderGold = 0;

	mov	DWORD PTR _iFinderGold$225661[ebp], 0

; 8759 : 					int iFinderFaith = 0;

	mov	DWORD PTR _iFinderFaith$225662[ebp], 0

; 8760 : 					bool bFirstFinder = false;

	mov	BYTE PTR _bFirstFinder$225663[ebp], 0

; 8761 : 					CvTeam& kTeam = GET_TEAM(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$225664[ebp], eax

; 8762 : 					if(!kTeam.isMinorCiv() && !kTeam.isBarbarian() && !kTeam.isObserver())

	mov	ecx, DWORD PTR _kTeam$225664[ebp]
	call	?isMinorCiv@CvTeam@@QBE_NXZ		; CvTeam::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN45@setReveale@2
	mov	ecx, DWORD PTR _kTeam$225664[ebp]
	call	?isBarbarian@CvTeam@@QBE_NXZ		; CvTeam::isBarbarian
	movzx	edx, al
	test	edx, edx
	jne	$LN45@setReveale@2
	mov	ecx, DWORD PTR _kTeam$225664[ebp]
	call	?isObserver@CvTeam@@QBE_NXZ		; CvTeam::isObserver
	movzx	eax, al
	test	eax, eax
	jne	$LN45@setReveale@2

; 8763 : 					{
; 8764 : 						if(getNumMajorCivsRevealed() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumMajorCivsRevealed@CvPlot@@QBEHXZ	; CvPlot::getNumMajorCivsRevealed
	test	eax, eax
	jne	$LN82@setReveale@2

; 8765 : 						{
; 8766 : 							changeNumMajorCivsRevealed(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?changeNumMajorCivsRevealed@CvPlot@@QAEXH@Z ; CvPlot::changeNumMajorCivsRevealed

; 8767 : 							bFirstFinder = true;

	mov	BYTE PTR _bFirstFinder$225663[ebp], 1

; 8768 : 
; 8769 : 							// Does it yields gold to the first major civ finder?
; 8770 : 							iFinderGold = GC.getFeatureInfo(getFeatureType())->getFirstFinderGold();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$252574[ebp], dl
	movsx	eax, BYTE PTR _f$252574[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getFirstFinderGold@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getFirstFinderGold
	mov	DWORD PTR _iFinderGold$225661[ebp], eax

; 8771 : 
; 8772 : 							// Does a player on this team have a trait that gives first finder gold?
; 8773 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN81@setReveale@2
$LN80@setReveale@2:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN81@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN79@setReveale@2

; 8774 : 							{
; 8775 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225670[ebp], edx

; 8776 : 								if(playerI.isAlive())

	mov	eax, DWORD PTR _playerI$225670[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T252589[ebp], cl
	movzx	edx, BYTE PTR $T252589[ebp]
	test	edx, edx
	je	SHORT $LN77@setReveale@2

; 8777 : 								{
; 8778 : 									if(playerI.getTeam() == eTeam)

	mov	eax, DWORD PTR _playerI$225670[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN77@setReveale@2

; 8779 : 									{
; 8780 : 										iFinderGold += playerI.GetPlayerTraits()->GetNaturalWonderFirstFinderGold();

	mov	ecx, DWORD PTR _playerI$225670[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T252601[ebp], eax
	mov	edx, DWORD PTR $T252601[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR $T252602[ebp], eax
	mov	ecx, DWORD PTR _iFinderGold$225661[ebp]
	add	ecx, DWORD PTR $T252602[ebp]
	mov	DWORD PTR _iFinderGold$225661[ebp], ecx
$LN77@setReveale@2:

; 8781 : 									}
; 8782 : 								}
; 8783 : 							}

	jmp	$LN80@setReveale@2
$LN79@setReveale@2:

; 8784 : 
; 8785 : 							// EAP: First finder FAITH Incremental
; 8786 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN76@setReveale@2
$LN75@setReveale@2:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN76@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN74@setReveale@2

; 8787 : 							{
; 8788 : 								int iIncrease;
; 8789 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225678[ebp], eax

; 8790 : 								if(playerI.isAlive())

	mov	ecx, DWORD PTR _playerI$225678[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T252614[ebp], dl
	movzx	eax, BYTE PTR $T252614[ebp]
	test	eax, eax
	je	SHORT $LN72@setReveale@2

; 8791 : 								{
; 8792 : 									if(playerI.getTeam() == eTeam)

	mov	ecx, DWORD PTR _playerI$225678[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN72@setReveale@2

; 8793 : 									{
; 8794 : 										iIncrease += iFinderFaith += playerI.GetPlayerTraits()->GetNaturalWonderFirstFinderFaith();

	mov	ecx, DWORD PTR _playerI$225678[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T252626[ebp], eax
	mov	eax, DWORD PTR $T252626[ebp]
	mov	ecx, DWORD PTR [eax+216]
	mov	DWORD PTR $T252627[ebp], ecx
	mov	edx, DWORD PTR _iFinderFaith$225662[ebp]
	add	edx, DWORD PTR $T252627[ebp]
	mov	DWORD PTR _iFinderFaith$225662[ebp], edx
	mov	eax, DWORD PTR _iIncrease$225677[ebp]
	add	eax, DWORD PTR _iFinderFaith$225662[ebp]
	mov	DWORD PTR _iIncrease$225677[ebp], eax

; 8795 : 										iIncrease += 10;

	mov	ecx, DWORD PTR _iIncrease$225677[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _iIncrease$225677[ebp], ecx
$LN72@setReveale@2:

; 8796 : 									}
; 8797 : 								}
; 8798 : 							}

	jmp	$LN75@setReveale@2
$LN74@setReveale@2:

; 8799 : 		
; 8800 : 						}
; 8801 : 						else

	jmp	$LN63@setReveale@2
$LN82@setReveale@2:

; 8802 : 						{
; 8803 : 							// Does a player on this team have a trait that gives subsequent finder gold?
; 8804 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN70@setReveale@2
$LN69@setReveale@2:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN70@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN68@setReveale@2

; 8805 : 							{
; 8806 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225686[ebp], eax

; 8807 : 								if(playerI.isAlive())

	mov	ecx, DWORD PTR _playerI$225686[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T252639[ebp], dl
	movzx	eax, BYTE PTR $T252639[ebp]
	test	eax, eax
	je	SHORT $LN66@setReveale@2

; 8808 : 								{
; 8809 : 									if(playerI.getTeam() == eTeam)

	mov	ecx, DWORD PTR _playerI$225686[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN66@setReveale@2

; 8810 : 									{
; 8811 : 										iFinderGold += playerI.GetPlayerTraits()->GetNaturalWonderSubsequentFinderGold();

	mov	ecx, DWORD PTR _playerI$225686[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T252651[ebp], eax
	mov	eax, DWORD PTR $T252651[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR $T252652[ebp], ecx
	mov	edx, DWORD PTR _iFinderGold$225661[ebp]
	add	edx, DWORD PTR $T252652[ebp]
	mov	DWORD PTR _iFinderGold$225661[ebp], edx
$LN66@setReveale@2:

; 8812 : 
; 8813 : 									}
; 8814 : 								}
; 8815 : 							}

	jmp	$LN69@setReveale@2
$LN68@setReveale@2:

; 8816 : 
; 8817 : 							// EAP: Subsequent FAITH for the finder incremental
; 8818 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN65@setReveale@2
$LN64@setReveale@2:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN65@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN63@setReveale@2

; 8819 : 							{
; 8820 : 								int iIncrease;
; 8821 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225694[ebp], ecx

; 8822 : 								if(playerI.isAlive())

	mov	edx, DWORD PTR _playerI$225694[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T252664[ebp], al
	movzx	ecx, BYTE PTR $T252664[ebp]
	test	ecx, ecx
	je	SHORT $LN61@setReveale@2

; 8823 : 								{
; 8824 : 
; 8825 : 									if(playerI.getTeam() == eTeam)

	mov	edx, DWORD PTR _playerI$225694[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN61@setReveale@2

; 8826 : 									{
; 8827 : 										iIncrease += iFinderFaith += playerI.GetPlayerTraits()->GetNaturalWonderSubsequentFinderFaith();

	mov	ecx, DWORD PTR _playerI$225694[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T252676[ebp], eax
	mov	ecx, DWORD PTR $T252676[ebp]
	mov	edx, DWORD PTR [ecx+220]
	mov	DWORD PTR $T252677[ebp], edx
	mov	eax, DWORD PTR _iFinderFaith$225662[ebp]
	add	eax, DWORD PTR $T252677[ebp]
	mov	DWORD PTR _iFinderFaith$225662[ebp], eax
	mov	ecx, DWORD PTR _iIncrease$225693[ebp]
	add	ecx, DWORD PTR _iFinderFaith$225662[ebp]
	mov	DWORD PTR _iIncrease$225693[ebp], ecx

; 8828 : 										iIncrease += 10;

	mov	edx, DWORD PTR _iIncrease$225693[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _iIncrease$225693[ebp], edx
$LN61@setReveale@2:

; 8829 : 									}
; 8830 : 								}
; 8831 : 							}

	jmp	$LN64@setReveale@2
$LN63@setReveale@2:

; 8832 : 						}
; 8833 : 
; 8834 : 						// Scale up or down based on difficulty
; 8835 : 						if(iFinderGold > 0)

	cmp	DWORD PTR _iFinderGold$225661[ebp], 0
	jle	$LN58@setReveale@2

; 8836 : 						{
; 8837 : 							const int iStandardHandicap = GC.getInfoTypeForString("HANDICAP_PRINCE");

	push	0
	push	OFFSET ??_C@_0BA@BEBKMHGP@HANDICAP_PRINCE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _iStandardHandicap$225699[ebp], eax

; 8838 : 							if(iStandardHandicap >= 0)

	cmp	DWORD PTR _iStandardHandicap$225699[ebp], 0
	jl	SHORT $LN58@setReveale@2

; 8839 : 							{
; 8840 : 								const CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo((HandicapTypes)iStandardHandicap);

	mov	eax, DWORD PTR _iStandardHandicap$225699[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo
	mov	DWORD PTR _pkHandicapInfo$225702[ebp], eax

; 8841 : 								if(pkHandicapInfo)

	cmp	DWORD PTR _pkHandicapInfo$225702[ebp], 0
	je	SHORT $LN58@setReveale@2

; 8842 : 								{
; 8843 : 									iFinderGold *= pkHandicapInfo->getBarbCampGold();

	mov	ecx, DWORD PTR _pkHandicapInfo$225702[ebp]
	call	?getBarbCampGold@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getBarbCampGold
	imul	eax, DWORD PTR _iFinderGold$225661[ebp]
	mov	DWORD PTR _iFinderGold$225661[ebp], eax

; 8844 : 									iFinderGold /= GC.getGame().getHandicapInfo().getBarbCampGold();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252681[ebp], ecx
	mov	ecx, DWORD PTR $T252681[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?getBarbCampGold@CvHandicapInfo@@QBEHXZ	; CvHandicapInfo::getBarbCampGold
	mov	ecx, eax
	mov	eax, DWORD PTR _iFinderGold$225661[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iFinderGold$225661[ebp], eax
$LN58@setReveale@2:

; 8845 : 								}
; 8846 : 							}
; 8847 : 						}
; 8848 : 						
; 8849 : 
; 8850 : 						if(iFinderGold > 0)

	cmp	DWORD PTR _iFinderGold$225661[ebp], 0
	jle	$LN53@setReveale@2

; 8851 : 						{
; 8852 : 							// Compute gold per team member
; 8853 : 							int iGoldPerTeamMember = iFinderGold;

	mov	edx, DWORD PTR _iFinderGold$225661[ebp]
	mov	DWORD PTR _iGoldPerTeamMember$225706[ebp], edx

; 8854 : 
; 8855 : 							if(kTeam.getNumMembers() > 0)

	mov	ecx, DWORD PTR _kTeam$225664[ebp]
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	test	eax, eax
	jle	SHORT $LN56@setReveale@2

; 8856 : 							{
; 8857 : 								iGoldPerTeamMember = iFinderGold / kTeam.getNumMembers();

	mov	ecx, DWORD PTR _kTeam$225664[ebp]
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	mov	ecx, eax
	mov	eax, DWORD PTR _iFinderGold$225661[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iGoldPerTeamMember$225706[ebp], eax
$LN56@setReveale@2:

; 8858 : 							}
; 8859 : 
; 8860 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN55@setReveale@2
$LN54@setReveale@2:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN55@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN53@setReveale@2

; 8861 : 							{
; 8862 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225711[ebp], eax

; 8863 : 								if(playerI.isAlive())

	mov	ecx, DWORD PTR _playerI$225711[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T252693[ebp], dl
	movzx	eax, BYTE PTR $T252693[ebp]
	test	eax, eax
	je	SHORT $LN51@setReveale@2

; 8864 : 								{
; 8865 : 									if(playerI.getTeam() == eTeam)

	mov	ecx, DWORD PTR _playerI$225711[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN51@setReveale@2

; 8866 : 									{
; 8867 : 										playerI.GetTreasury()->ChangeGold(iGoldPerTeamMember);

	mov	eax, DWORD PTR _iGoldPerTeamMember$225706[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerI$225711[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeGold@CvTreasury@@QAEXH@Z		; CvTreasury::ChangeGold
$LN51@setReveale@2:

; 8868 : 									}
; 8869 : 								}
; 8870 : 
; 8871 : 								if(eTeam == eActiveTeam)

	mov	ecx, DWORD PTR _eTeam$[ebp]
	cmp	ecx, DWORD PTR _eActiveTeam$[ebp]
	jne	$LN50@setReveale@2

; 8872 : 								{
; 8873 : 									char text[256] = {0};

	mov	BYTE PTR _text$225716[ebp], 0
	push	255					; 000000ffH
	push	0
	lea	edx, DWORD PTR _text$225716[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 8874 : 									float fDelay = GC.getPOST_COMBAT_TEXT_DELAY() * 3;

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8040
	movss	DWORD PTR $T252705[ebp], xmm0
	movss	xmm0, DWORD PTR $T252705[ebp]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _fDelay$225717[ebp], xmm0

; 8875 : 									text[0] = NULL;

	mov	BYTE PTR _text$225716[ebp], 0

; 8876 : 									sprintf_s(text, "[COLOR_YELLOW]+%d[ENDCOLOR][ICON_GOLD]", iFinderGold);

	mov	eax, DWORD PTR _iFinderGold$225661[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@NDAFPEL@?$FLCOLOR_YELLOW?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON@
	lea	ecx, DWORD PTR _text$225716[ebp]
	push	ecx
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>
	add	esp, 12					; 0000000cH

; 8877 : 									GC.GetEngineUserInterface()->AddPopupText(getX(), getY(), text, fDelay);

	mov	edx, DWORD PTR $T252709[ebp]
	mov	DWORD PTR tv587[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv587[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T252713[ebp], edx
	push	ecx
	fld	DWORD PTR _fDelay$225717[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _text$225716[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252713[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv587[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv587[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
$LN50@setReveale@2:

; 8878 : 								}
; 8879 : 							}

	jmp	$LN54@setReveale@2
$LN53@setReveale@2:

; 8880 : 						}
; 8881 : 						
; 8882 : 						//EAP: Now do it for Faith too!
; 8883 : 						if(iFinderFaith > 0)

	cmp	DWORD PTR _iFinderFaith$225662[ebp], 0
	jle	$LN45@setReveale@2

; 8884 : 						{
; 8885 : 							// Compute gold per team member
; 8886 : 							int iFaithPerTeamMember = iFinderFaith;

	mov	ecx, DWORD PTR _iFinderFaith$225662[ebp]
	mov	DWORD PTR _iFaithPerTeamMember$225725[ebp], ecx

; 8887 : 
; 8888 : 							if(kTeam.getNumMembers() > 0)

	mov	ecx, DWORD PTR _kTeam$225664[ebp]
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	test	eax, eax
	jle	SHORT $LN48@setReveale@2

; 8889 : 							{
; 8890 : 								iFaithPerTeamMember = iFinderFaith / kTeam.getNumMembers();

	mov	ecx, DWORD PTR _kTeam$225664[ebp]
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	mov	ecx, eax
	mov	eax, DWORD PTR _iFinderFaith$225662[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iFaithPerTeamMember$225725[ebp], eax
$LN48@setReveale@2:

; 8891 : 							}
; 8892 : 
; 8893 : 							for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN47@setReveale@2
$LN46@setReveale@2:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN47@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN45@setReveale@2

; 8894 : 							{
; 8895 : 								CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225730[ebp], eax

; 8896 : 								if(playerI.isAlive())

	mov	ecx, DWORD PTR _playerI$225730[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T252728[ebp], dl
	movzx	eax, BYTE PTR $T252728[ebp]
	test	eax, eax
	je	SHORT $LN43@setReveale@2

; 8897 : 								{
; 8898 : 									if(playerI.getTeam() == eTeam)

	mov	ecx, DWORD PTR _playerI$225730[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN43@setReveale@2

; 8899 : 									{
; 8900 : 										playerI.ChangeFaith(iFaithPerTeamMember);

	mov	eax, DWORD PTR _iFaithPerTeamMember$225725[ebp]
	push	eax
	mov	ecx, DWORD PTR _playerI$225730[ebp]
	call	?ChangeFaith@CvPlayer@@QAEXH@Z		; CvPlayer::ChangeFaith
$LN43@setReveale@2:

; 8901 : 									}
; 8902 : 								}
; 8903 : 
; 8904 : 								if(eTeam == eActiveTeam)

	mov	ecx, DWORD PTR _eTeam$[ebp]
	cmp	ecx, DWORD PTR _eActiveTeam$[ebp]
	jne	$LN42@setReveale@2

; 8905 : 								{
; 8906 : 									char text[256] = {0};

	mov	BYTE PTR _text$225735[ebp], 0
	push	255					; 000000ffH
	push	0
	lea	edx, DWORD PTR _text$225735[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 8907 : 									float fDelay = GC.getPOST_COMBAT_TEXT_DELAY() * 3;

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8040
	movss	DWORD PTR $T252740[ebp], xmm0
	movss	xmm0, DWORD PTR $T252740[ebp]
	mulss	xmm0, DWORD PTR __real@40400000
	movss	DWORD PTR _fDelay$225736[ebp], xmm0

; 8908 : 									text[0] = NULL;

	mov	BYTE PTR _text$225735[ebp], 0

; 8909 : 									sprintf_s(text, "[COLOR_WHITE]+%d[ENDCOLOR][ICON_PEACE]", iFinderFaith);

	mov	eax, DWORD PTR _iFinderFaith$225662[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@LBEHLJKE@?$FLCOLOR_WHITE?$FN?$CL?$CFd?$FLENDCOLOR?$FN?$FLICON_@
	lea	ecx, DWORD PTR _text$225735[ebp]
	push	ecx
	call	??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ	; sprintf_s<256>
	add	esp, 12					; 0000000cH

; 8910 : 									GC.GetEngineUserInterface()->AddPopupText(getX(), getY(), text, fDelay);

	mov	edx, DWORD PTR $T252744[ebp]
	mov	DWORD PTR tv647[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv647[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T252748[ebp], edx
	push	ecx
	fld	DWORD PTR _fDelay$225736[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR _text$225735[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252748[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv647[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv647[ebp]
	mov	eax, DWORD PTR [edx+184]
	call	eax
$LN42@setReveale@2:

; 8911 : 								}
; 8912 : 							}

	jmp	$LN46@setReveale@2
$LN45@setReveale@2:

; 8913 : 						}
; 8914 : 					}
; 8915 : 
; 8916 : 					// If it's the active team then tell them they found something
; 8917 : 					if(eTeam == eActiveTeam)

	mov	ecx, DWORD PTR _eTeam$[ebp]
	cmp	ecx, DWORD PTR _eActiveTeam$[ebp]
	jne	$LN340@setReveale@2

; 8918 : 					{
; 8919 : 						bool bDontShowRewardPopup = GC.GetEngineUserInterface()->IsOptionNoRewardPopups();

	mov	edx, DWORD PTR $T252755[ebp]
	mov	DWORD PTR tv666[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv666[ebp], eax
	mov	ecx, DWORD PTR tv666[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv666[ebp]
	mov	eax, DWORD PTR [edx+456]
	call	eax
	mov	BYTE PTR _bDontShowRewardPopup$225739[ebp], al

; 8920 : #ifdef AUI_PLOT_OBSERVER_NO_NW_POPUPS
; 8921 : 						if (eTeam == OBSERVER_TEAM)
; 8922 : 							bDontShowRewardPopup = true;
; 8923 : #endif
; 8924 : 
; 8925 : 						// Popup (no MP)
; 8926 : 						if(!GC.getGame().isNetworkMultiPlayer() && !bDontShowRewardPopup)	// KWG: candidate for !GC.getGame().isOption(GAMEOPTION_SIMULTANEOUS_TURNS)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252759[ebp], ecx
	mov	ecx, DWORD PTR $T252759[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	$LN38@setReveale@2
	movzx	eax, BYTE PTR _bDontShowRewardPopup$225739[ebp]
	test	eax, eax
	jne	$LN38@setReveale@2

; 8927 : 						{
; 8928 : 							CvPopupInfo kPopupInfo(BUTTONPOPUP_NATURAL_WONDER_REWARD, getX(), getY(), iFinderGold, 0 /*iFlags */, bFirstFinder);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T252763[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T252770[ebp], ecx
	mov	edx, DWORD PTR $T252770[ebp]
	mov	DWORD PTR _kPopupInfo$225741[ebp], edx
	mov	eax, DWORD PTR $T252763[ebp]
	mov	DWORD PTR _kPopupInfo$225741[ebp+4], eax
	mov	ecx, DWORD PTR _iFinderGold$225661[ebp]
	mov	DWORD PTR _kPopupInfo$225741[ebp+8], ecx
	mov	DWORD PTR _kPopupInfo$225741[ebp+12], 0
	mov	dl, BYTE PTR _bFirstFinder$225663[ebp]
	mov	BYTE PTR _kPopupInfo$225741[ebp+16], dl
	mov	BYTE PTR _kPopupInfo$225741[ebp+17], 0
	mov	DWORD PTR _kPopupInfo$225741[ebp+20], 56 ; 00000038H
	mov	BYTE PTR _kPopupInfo$225741[ebp+24], 0

; 8929 : 							pInterface->AddPopup(kPopupInfo);

	lea	eax, DWORD PTR _kPopupInfo$225741[ebp]
	push	eax
	mov	ecx, DWORD PTR _pInterface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pInterface$[ebp]
	mov	eax, DWORD PTR [edx+180]
	call	eax

; 8930 : 							CvPlayer& kActivePlayer = GET_PLAYER(GC.getGame().getActivePlayer());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252774[ebp], ecx
	mov	ecx, DWORD PTR $T252774[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR $T252778[ebp], eax
	mov	edx, DWORD PTR $T252778[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kActivePlayer$225742[ebp], edx

; 8931 : 							if (kActivePlayer.getTeam() == eActiveTeam)

	mov	eax, DWORD PTR _kActivePlayer$225742[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eActiveTeam$[ebp]
	jne	SHORT $LN39@setReveale@2

; 8932 : 							{
; 8933 : 								// We are adding a popup that the player must make a choice in, make sure they are not in the end-turn phase.
; 8934 : 								CancelActivePlayerEndTurn();

	call	?CancelActivePlayerEndTurn@@YA_NXZ	; CancelActivePlayerEndTurn
$LN39@setReveale@2:

; 8935 : 							}
; 8936 : 
; 8937 : 							//Add Stat and check for Achievement
; 8938 : 							if(bEligibleForAchievement && !GC.getGame().isGameMultiPlayer())

	movzx	edx, BYTE PTR _bEligibleForAchievement$225624[ebp]
	test	edx, edx
	je	SHORT $LN38@setReveale@2
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T252790[ebp], eax
	mov	ecx, DWORD PTR $T252790[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN38@setReveale@2

; 8939 : 							{
; 8940 : 								gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_NATURALWONDERS, 100, ACHIEVEMENT_ALL_NATURALWONDER);

	mov	edx, DWORD PTR $T252794[ebp]
	mov	DWORD PTR tv726[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv726[ebp], eax
	push	88					; 00000058H
	push	100					; 00000064H
	push	116					; 00000074H
	mov	ecx, DWORD PTR tv726[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv726[ebp]
	mov	eax, DWORD PTR [edx+848]
	call	eax
$LN38@setReveale@2:

; 8941 : 							}
; 8942 : 
; 8943 : 						}
; 8944 : 
; 8945 : 						//DLC2 Natural Wonder Achievements
; 8946 : 						{
; 8947 : 							CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo(getFeatureType());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$252800[ebp], dl
	movsx	eax, BYTE PTR _f$252800[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _pkFeatureInfo$225745[ebp], eax

; 8948 : 							if(pkFeatureInfo)

	cmp	DWORD PTR _pkFeatureInfo$225745[ebp], 0
	je	$LN37@setReveale@2

; 8949 : 							{
; 8950 : 								CvString strFeatureType = pkFeatureInfo->GetType();

	mov	ecx, DWORD PTR _pkFeatureInfo$225745[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T252807[ebp], eax
	cmp	DWORD PTR $T252807[ebp], 0
	je	SHORT $LN324@setReveale@2
	mov	ecx, DWORD PTR $T252807[ebp]
	mov	DWORD PTR tv1307[ebp], ecx
	jmp	SHORT $LN325@setReveale@2
$LN324@setReveale@2:
	mov	DWORD PTR tv1307[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN325@setReveale@2:
	mov	edx, DWORD PTR tv1307[ebp]
	push	edx
	lea	ecx, DWORD PTR _strFeatureType$225747[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 8951 : 								if(strFeatureType == "FEATURE_FOUNTAIN_YOUTH")

	push	OFFSET ??_C@_0BH@EEIKGJAB@FEATURE_FOUNTAIN_YOUTH?$AA@
	lea	eax, DWORD PTR _strFeatureType$225747[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN36@setReveale@2

; 8952 : 									gDLL->UnlockAchievement(ACHIEVEMENT_SCENARIO_02_DISCOVER_FOUNTAIN);

	mov	edx, DWORD PTR $T252819[ebp]
	mov	DWORD PTR tv764[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv764[ebp], eax
	push	137					; 00000089H
	mov	ecx, DWORD PTR tv764[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv764[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
	jmp	SHORT $LN34@setReveale@2
$LN36@setReveale@2:

; 8953 : 								else if(strFeatureType == "FEATURE_EL_DORADO")

	push	OFFSET ??_C@_0BC@GLIGLMLG@FEATURE_EL_DORADO?$AA@
	lea	ecx, DWORD PTR _strFeatureType$225747[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@setReveale@2

; 8954 : 									gDLL->UnlockAchievement(ACHIEVEMENT_SCENARIO_02_DISCOVER_EL_DORADO);

	mov	eax, DWORD PTR $T252823[ebp]
	mov	DWORD PTR tv784[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv784[ebp], ecx
	push	138					; 0000008aH
	mov	edx, DWORD PTR tv784[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv784[ebp]
	mov	edx, DWORD PTR [eax+828]
	call	edx
$LN34@setReveale@2:

; 8955 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strFeatureType$225747[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN37@setReveale@2:

; 8956 : 						}
; 8957 : 
; 8958 : 						auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T252381[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T252381[ebp], 0
	je	SHORT $LN103@setReveale@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252381[ebp]
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	DWORD PTR tv801[ebp], eax
	jmp	SHORT $LN104@setReveale@2
$LN103@setReveale@2:
	mov	DWORD PTR tv801[ebp], 0
$LN104@setReveale@2:
	mov	ecx, DWORD PTR tv801[ebp]
	mov	DWORD PTR $T252380[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T252380[ebp]
	mov	DWORD PTR _pDllPlot$225758[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 8959 : 						gDLL->GameplayNaturalWonderRevealed(pDllPlot.get());

	mov	eax, DWORD PTR $T252834[ebp]
	mov	DWORD PTR tv811[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv811[ebp], ecx
	mov	edx, DWORD PTR _pDllPlot$225758[ebp]
	push	edx
	mov	eax, DWORD PTR tv811[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv811[ebp]
	mov	eax, DWORD PTR [edx+700]
	call	eax

; 8960 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _pDllPlot$225758[ebp]
	mov	DWORD PTR $T252846[ebp], ecx
	cmp	DWORD PTR $T252846[ebp], 0
	je	SHORT $LN342@setReveale@2
	mov	edx, DWORD PTR $T252846[ebp]
	mov	DWORD PTR _inst$252849[ebp], edx
	mov	eax, DWORD PTR _inst$252849[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$252849[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN342@setReveale@2:
$LN340@setReveale@2:

; 8961 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strSummary$225645[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strText$225636[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
$LN94@setReveale@2:

; 8962 : 			}
; 8963 : 		}
; 8964 : 
; 8965 : 		if(eTeam == eActiveTeam)

	mov	ecx, DWORD PTR _eTeam$[ebp]
	cmp	ecx, DWORD PTR _eActiveTeam$[ebp]
	jne	$LN20@setReveale@2

; 8966 : 		{
; 8967 : 			bVisbilityUpdated = true;

	mov	BYTE PTR _bVisbilityUpdated$[ebp], 1

; 8968 : 			updateSymbols();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 8969 : 			updateFog(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog

; 8970 : 			updateVisibility();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility

; 8971 : 
; 8972 : 			// Active player is seeing this Plot for the first time
; 8973 : 			if(isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$252860[ebp], edx
	mov	eax, DWORD PTR _uiOffset$252860[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$252860[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN20@setReveale@2

; 8974 : 			{
; 8975 : 				// update the resources
; 8976 : 				if(getResourceType(eTeam) != NO_RESOURCE)

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN30@setReveale@2

; 8977 : 				{
; 8978 : 					// If we've force revealed the resource for this team, then don't send another event
; 8979 : 					if(!IsResourceForceReveal(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsResourceForceReveal@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsResourceForceReveal
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN30@setReveale@2

; 8980 : 					{
; 8981 : 						setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN30@setReveale@2:

; 8982 : 					}
; 8983 : 				}
; 8984 : 
; 8985 : 				// Found a Goody Hut
; 8986 : 				if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	$LN28@setReveale@2

; 8987 : 				{
; 8988 : 					if(GC.getImprovementInfo(getImprovementType())->IsGoody())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsGoody@CvImprovementEntry@@QBE_NXZ	; CvImprovementEntry::IsGoody
	movzx	ecx, al
	test	ecx, ecx
	je	$LN28@setReveale@2

; 8989 : 					{
; 8990 : 						CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_GOODY_HUT");

	push	OFFSET ??_C@_0CF@MNIFPDPL@TXT_KEY_NOTIFICATION_FOUND_GOODY@
	lea	edx, DWORD PTR _strBuffer$225765[ebp]
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 8991 : 						CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_GOODY_HUT");

	push	OFFSET ??_C@_0CN@NFGJELEM@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
	lea	eax, DWORD PTR _strSummary$225768[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 8992 : 						if(bEligibleForAchievement)

	movzx	ecx, BYTE PTR _bEligibleForAchievement$225624[ebp]
	test	ecx, ecx
	je	SHORT $LN27@setReveale@2

; 8993 : 						{
; 8994 : 							gDLL->UnlockAchievement(ACHIEVEMENT_ANCIENT_RUIN);

	mov	edx, DWORD PTR $T252865[ebp]
	mov	DWORD PTR tv867[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv867[ebp], eax
	push	49					; 00000031H
	mov	ecx, DWORD PTR tv867[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv867[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN27@setReveale@2:

; 8995 : 							OutputDebugString("RUINS!");
; 8996 : 						}
; 8997 : 						for(iI = 0; iI < MAX_MAJOR_CIVS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN26@setReveale@2
$LN25@setReveale@2:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN26@setReveale@2:
	cmp	DWORD PTR _iI$[ebp], 22			; 00000016H
	jge	$LN24@setReveale@2

; 8998 : 						{
; 8999 : 							CvPlayerAI& playerI = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _playerI$225775[ebp], edx

; 9000 : 							if(playerI.isAlive())

	mov	eax, DWORD PTR _playerI$225775[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T252877[ebp], cl
	movzx	edx, BYTE PTR $T252877[ebp]
	test	edx, edx
	je	$LN21@setReveale@2

; 9001 : 							{
; 9002 : 								if(playerI.getTeam() == eTeam)

	mov	eax, DWORD PTR _playerI$225775[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	$LN21@setReveale@2

; 9003 : 								{
; 9004 : 									CvNotifications* pNotifications = playerI.GetNotifications();

	mov	ecx, DWORD PTR _playerI$225775[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225779[ebp], eax

; 9005 : 									if(pNotifications)

	cmp	DWORD PTR _pNotifications$225779[ebp], 0
	je	SHORT $LN21@setReveale@2

; 9006 : 									{
; 9007 : 										pNotifications->Add(NOTIFICATION_GOODY, strBuffer, strSummary, getX(), getY(), -1);

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T252889[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T252893[ebp], edx
	lea	ecx, DWORD PTR _strSummary$225768[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T252897[ebp], eax
	push	-1
	push	-1
	mov	eax, DWORD PTR $T252889[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252893[ebp]
	push	ecx
	mov	edx, DWORD PTR $T252897[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$225765[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-597231081				; dc66fa17H
	mov	ecx, DWORD PTR _pNotifications$225779[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add
$LN21@setReveale@2:

; 9008 : 									}
; 9009 : 								}
; 9010 : 							}
; 9011 : 						}

	jmp	$LN25@setReveale@2
$LN24@setReveale@2:

; 9012 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _strSummary$225768[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225765[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN28@setReveale@2:

; 9013 : 				}
; 9014 : 				if(bEligibleForAchievement)

	movzx	eax, BYTE PTR _bEligibleForAchievement$225624[ebp]
	test	eax, eax
	je	SHORT $LN20@setReveale@2

; 9015 : 				{
; 9016 : 					gDLL->IncrementSteamStatAndUnlock(ESTEAMSTAT_TILESDISCOVERED, 1000, ACHIEVEMENT_1000TILES);

	mov	ecx, DWORD PTR $T252912[ebp]
	mov	DWORD PTR tv922[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv922[ebp], edx
	push	94					; 0000005eH
	push	1000					; 000003e8H
	push	127					; 0000007fH
	mov	eax, DWORD PTR tv922[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv922[ebp]
	mov	eax, DWORD PTR [edx+848]
	call	eax
$LN20@setReveale@2:

; 9017 : 				}
; 9018 : 
; 9019 : 
; 9020 : 			}
; 9021 : 		}
; 9022 : 
; 9023 : 		if(bNewValue)

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@setReveale@2

; 9024 : 		{
; 9025 : 			if(pInterface->GetHeadSelectedUnit() != NULL)

	mov	edx, DWORD PTR _pInterface$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pInterface$[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	test	eax, eax
	je	SHORT $LN18@setReveale@2

; 9026 : 			{
; 9027 : 				// This is what determines if the camera jumps quickly or slowly - if we're revealing new plots go slower.  The following function sets this flag
; 9028 : 				pInterface->SetSelectedUnitRevealingNewPlots(true);

	push	1
	mov	eax, DWORD PTR _pInterface$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pInterface$[ebp]
	mov	eax, DWORD PTR [edx+232]
	call	eax
$LN18@setReveale@2:

; 9029 : 			}
; 9030 : 		}
; 9031 : 	}
; 9032 : 
; 9033 : 	if(!bTerrainOnly)

	movzx	ecx, BYTE PTR _bTerrainOnly$[ebp]
	test	ecx, ecx
	jne	$LN4@setReveale@2

; 9034 : 	{
; 9035 : 		bool bVisibilityChanged = false;

	mov	BYTE PTR _bVisibilityChanged$225785[ebp], 0

; 9036 : 		bool bImprovementVisibilityChanged = false;

	mov	BYTE PTR _bImprovementVisibilityChanged$225786[ebp], 0

; 9037 : 		if(isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$252921[ebp], edx
	mov	eax, DWORD PTR _uiOffset$252921[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$252921[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN16@setReveale@2

; 9038 : 		{
; 9039 : 			// If this plot is owned by someone, let the team know
; 9040 : 			if(getOwner() != NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	je	SHORT $LN15@setReveale@2

; 9041 : 			{
; 9042 : 				bVisibilityChanged |= GET_TEAM(eTeam).SetHasFoundPlayersTerritory(getOwner(), true);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T252929[ebp], ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T252933[ebp], edx
	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	push	1
	mov	eax, DWORD PTR $T252929[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252933[ebp]
	call	?SetHasFoundPlayersTerritory@CvTeam@@QAE_NW4PlayerTypes@@_N@Z ; CvTeam::SetHasFoundPlayersTerritory
	movzx	ecx, al
	or	ebx, ecx
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl
$LN15@setReveale@2:

; 9043 : 			}
; 9044 : 
; 9045 : 			if(eFromTeam == NO_TEAM)

	cmp	DWORD PTR _eFromTeam$[ebp], -1
	jne	$LN14@setReveale@2

; 9046 : 			{
; 9047 : 				bVisibilityChanged |= setRevealedOwner(eTeam, getOwner());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T252937[ebp], eax
	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	mov	ecx, DWORD PTR $T252937[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner
	movzx	eax, al
	or	ebx, eax
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl

; 9048 : 				bImprovementVisibilityChanged |= setRevealedImprovementType(eTeam, getImprovementType());

	movzx	ebx, BYTE PTR _bImprovementVisibilityChanged$225786[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
	movzx	edx, al
	or	ebx, edx
	mov	BYTE PTR _bImprovementVisibilityChanged$225786[ebp], bl

; 9049 : 				bVisibilityChanged |= setRevealedRouteType(eTeam, getRouteType());

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
	movzx	ecx, al
	or	ebx, ecx
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl

; 9050 : 
; 9051 : 				if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN13@setReveale@2

; 9052 : 				{
; 9053 : 					bVisibilityChanged |= pCity->setRevealed(eTeam, true);

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	push	1
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?setRevealed@CvCity@@QAE_NW4TeamTypes@@_N@Z ; CvCity::setRevealed
	movzx	eax, al
	or	ebx, eax
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl
$LN13@setReveale@2:

; 9054 : 				}
; 9055 : 			}
; 9056 : 			else

	jmp	$LN7@setReveale@2
$LN14@setReveale@2:

; 9057 : 			{
; 9058 : 				if(getRevealedOwner(eFromTeam) == getOwner())

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T252941[ebp], edx
	mov	eax, DWORD PTR _eFromTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner
	cmp	eax, DWORD PTR $T252941[ebp]
	jne	SHORT $LN11@setReveale@2

; 9059 : 				{
; 9060 : 					bVisibilityChanged |= setRevealedOwner(eTeam, getRevealedOwner(eFromTeam));

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner
	push	eax
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner
	movzx	eax, al
	or	ebx, eax
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl
$LN11@setReveale@2:

; 9061 : 				}
; 9062 : 
; 9063 : 				if(getRevealedImprovementType(eFromTeam) == getImprovementType())

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	esi, eax
	jne	SHORT $LN10@setReveale@2

; 9064 : 				{
; 9065 : 					bImprovementVisibilityChanged |= setRevealedImprovementType(eTeam, getRevealedImprovementType(eFromTeam));

	movzx	ebx, BYTE PTR _bImprovementVisibilityChanged$225786[ebp]
	mov	edx, DWORD PTR _eFromTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	push	eax
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
	movzx	ecx, al
	or	ebx, ecx
	mov	BYTE PTR _bImprovementVisibilityChanged$225786[ebp], bl
$LN10@setReveale@2:

; 9066 : 				}
; 9067 : 
; 9068 : 				if(getRevealedRouteType(eFromTeam) == getRouteType())

	mov	edx, DWORD PTR _eFromTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedRouteType
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	esi, eax
	jne	SHORT $LN9@setReveale@2

; 9069 : 				{
; 9070 : 					bVisibilityChanged |= setRevealedRouteType(eTeam, getRevealedRouteType(eFromTeam));

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	mov	eax, DWORD PTR _eFromTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedRouteType
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
	movzx	edx, al
	or	ebx, edx
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl
$LN9@setReveale@2:

; 9071 : 				}
; 9072 : 
; 9073 : 				if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN7@setReveale@2

; 9074 : 				{
; 9075 : 					if(pCity->isRevealed(eFromTeam, false))

	push	0
	mov	eax, DWORD PTR _eFromTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@setReveale@2

; 9076 : 					{
; 9077 : 						bVisibilityChanged |= pCity->setRevealed(eTeam, true);

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	push	1
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?setRevealed@CvCity@@QAE_NW4TeamTypes@@_N@Z ; CvCity::setRevealed
	movzx	eax, al
	or	ebx, eax
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl
$LN7@setReveale@2:

; 9078 : 					}
; 9079 : 				}
; 9080 : 			}
; 9081 : 		}
; 9082 : 		else

	jmp	$LN5@setReveale@2
$LN16@setReveale@2:

; 9083 : 		{
; 9084 : 			bVisibilityChanged |= setRevealedOwner(eTeam, NO_PLAYER);

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	push	-1
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedOwner@CvPlot@@QAE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::setRevealedOwner
	movzx	edx, al
	or	ebx, edx
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl

; 9085 : 			bImprovementVisibilityChanged |= setRevealedImprovementType(eTeam, NO_IMPROVEMENT);

	movzx	ebx, BYTE PTR _bImprovementVisibilityChanged$225786[ebp]
	push	-1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ; CvPlot::setRevealedImprovementType
	movzx	ecx, al
	or	ebx, ecx
	mov	BYTE PTR _bImprovementVisibilityChanged$225786[ebp], bl

; 9086 : 			bVisibilityChanged |= setRevealedRouteType(eTeam, NO_ROUTE);

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	push	-1
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ; CvPlot::setRevealedRouteType
	movzx	eax, al
	or	ebx, eax
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl

; 9087 : 
; 9088 : 			if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN5@setReveale@2

; 9089 : 			{
; 9090 : 				bVisibilityChanged |= pCity->setRevealed(eTeam, false);

	movzx	ebx, BYTE PTR _bVisibilityChanged$225785[ebp]
	push	0
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?setRevealed@CvCity@@QAE_NW4TeamTypes@@_N@Z ; CvCity::setRevealed
	movzx	edx, al
	or	ebx, edx
	mov	BYTE PTR _bVisibilityChanged$225785[ebp], bl
$LN5@setReveale@2:

; 9091 : 			}
; 9092 : 		}
; 9093 : 
; 9094 : 		if (!bVisbilityUpdated && (bVisibilityChanged || bImprovementVisibilityChanged))

	movzx	eax, BYTE PTR _bVisbilityUpdated$[ebp]
	test	eax, eax
	jne	SHORT $LN4@setReveale@2
	movzx	ecx, BYTE PTR _bVisibilityChanged$225785[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@setReveale@2
	movzx	edx, BYTE PTR _bImprovementVisibilityChanged$225786[ebp]
	test	edx, edx
	je	SHORT $LN4@setReveale@2
$LN3@setReveale@2:

; 9095 : 		{
; 9096 : 			if(eTeam == eActiveTeam)

	mov	eax, DWORD PTR _eTeam$[ebp]
	cmp	eax, DWORD PTR _eActiveTeam$[ebp]
	jne	SHORT $LN2@setReveale@2

; 9097 : 			{
; 9098 : 				if (!bImprovementVisibilityChanged)	// Don't bother sending again if the improvement change already sent the message

	movzx	ecx, BYTE PTR _bImprovementVisibilityChanged$225786[ebp]
	test	ecx, ecx
	jne	SHORT $LN1@setReveale@2

; 9099 : 					updateSymbols();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols
$LN1@setReveale@2:

; 9100 : 
; 9101 : 				updateFog(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog

; 9102 : 				updateVisibility();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
$LN2@setReveale@2:

; 9103 : 			}
; 9104 : 
; 9105 : 			bVisbilityUpdated = true;

	mov	BYTE PTR _bVisbilityUpdated$[ebp], 1
$LN4@setReveale@2:

; 9106 : 		}
; 9107 : 	}
; 9108 : 
; 9109 : 	return bVisbilityUpdated;

	mov	al, BYTE PTR _bVisbilityUpdated$[ebp]

; 9110 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$0:
	lea	ecx, DWORD PTR _args$225633[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$1:
	lea	ecx, DWORD PTR _strText$225636[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$2:
	lea	ecx, DWORD PTR _strSummary$225645[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$3:
	lea	ecx, DWORD PTR _strFeatureType$225747[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$4:
	mov	eax, DWORD PTR $T252381[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$5:
	lea	ecx, DWORD PTR _pDllPlot$225758[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$6:
	lea	ecx, DWORD PTR _strBuffer$225765[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z$7:
	lea	ecx, DWORD PTR _strSummary$225768[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1836]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ENDP	; CvPlot::setRevealed
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
$T252957 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T252957[ebp], 0

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 491  : 
; 492  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 494  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 495  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 496  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T252957[ebp]
	or	eax, 1
	mov	DWORD PTR $T252957[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2:
	mov	eax, DWORD PTR $T252957[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz
	and	DWORD PTR $T252957[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentRevealed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
_uiOffset$253202 = -108					; size = 4
$T252986 = -16						; size = 4
$T252982 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC	; CvPlot::isAdjacentRevealed, COMDAT
; _this$ = ecx

; 9114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 9115 : 	CvPlot* pAdjacentPlot;
; 9116 : 	int iI;
; 9117 : 
; 9118 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@11
$LN4@isAdjacent@11:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent@11:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent@11

; 9119 : 	{
; 9120 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T252982[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T252986[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T252982[ebp]
	push	eax
	mov	ecx, DWORD PTR $T252986[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 9121 : 
; 9122 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@11

; 9123 : 		{
; 9124 : 			if(pAdjacentPlot->isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$253202[ebp], edx
	mov	eax, DWORD PTR _uiOffset$253202[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$253202[ebp]
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@isAdjacent@11

; 9125 : 			{
; 9126 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@11
$LN2@isAdjacent@11:

; 9127 : 			}
; 9128 : 		}
; 9129 : 	}

	jmp	SHORT $LN4@isAdjacent@11
$LN3@isAdjacent@11:

; 9130 : 
; 9131 : 	return false;

	xor	al, al
$LN6@isAdjacent@11:

; 9132 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP	; CvPlot::isAdjacentRevealed
_TEXT	ENDS
PUBLIC	?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonrevealed
; Function compile flags: /Odtp
;	COMDAT ?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
_uiOffset$253429 = -108					; size = 4
$T253213 = -16						; size = 4
$T253209 = -12						; size = 4
_iI$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC ; CvPlot::isAdjacentNonrevealed, COMDAT
; _this$ = ecx

; 9136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 9137 : 	CvPlot* pAdjacentPlot;
; 9138 : 	int iI;
; 9139 : 
; 9140 : 	for(iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@isAdjacent@12
$LN4@isAdjacent@12:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN5@isAdjacent@12:
	cmp	DWORD PTR _iI$[ebp], 6
	jge	SHORT $LN3@isAdjacent@12

; 9141 : 	{
; 9142 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T253209[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T253213[ebp], ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	eax, DWORD PTR $T253209[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253213[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 9143 : 
; 9144 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@isAdjacent@12

; 9145 : 		{
; 9146 : 			if(!pAdjacentPlot->isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$253429[ebp], edx
	mov	eax, DWORD PTR _uiOffset$253429[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$253429[ebp]
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN2@isAdjacent@12

; 9147 : 			{
; 9148 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@isAdjacent@12
$LN2@isAdjacent@12:

; 9149 : 			}
; 9150 : 		}
; 9151 : 	}

	jmp	SHORT $LN4@isAdjacent@12
$LN3@isAdjacent@12:

; 9152 : 
; 9153 : 	return false;

	xor	al, al
$LN6@isAdjacent@12:

; 9154 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP ; CvPlot::isAdjacentNonrevealed
_TEXT	ENDS
PUBLIC	?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getNumAdjacentNonrevealed
; Function compile flags: /Odtp
;	COMDAT ?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -116						; size = 4
_uiOffset$253656 = -112					; size = 4
$T253440 = -20						; size = 4
$T253436 = -16						; size = 4
_i$225833 = -12						; size = 4
_iCount$ = -8						; size = 4
_pAdjacentPlot$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z PROC ; CvPlot::getNumAdjacentNonrevealed, COMDAT
; _this$ = ecx

; 9162 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 9163 : 	CvPlot* pAdjacentPlot;
; 9164 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 9165 : 
; 9166 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 9167 : 	int iMaxDX, iDX;
; 9168 : 	for (int iDY = -iRange; iDY <= iRange; iDY++)
; 9169 : 	{
; 9170 : 		iMaxDX = iRange - MAX(0, iDY);
; 9171 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 9172 : 		{
; 9173 : 			// No need for range check because loops are set up properly
; 9174 : 			pAdjacentPlot = plotXY(getX(), getY(), iDX, iDY);
; 9175 : #else
; 9176 : 	for(int i = 0; i < NUM_DIRECTION_TYPES; ++i)

	mov	DWORD PTR _i$225833[ebp], 0
	jmp	SHORT $LN5@getNumAdja@2
$LN4@getNumAdja@2:
	mov	eax, DWORD PTR _i$225833[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225833[ebp], eax
$LN5@getNumAdja@2:
	cmp	DWORD PTR _i$225833[ebp], 6
	jge	SHORT $LN3@getNumAdja@2

; 9177 : 	{
; 9178 : 		pAdjacentPlot = plotDirection(getX(), getY(), ((DirectionTypes)i));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T253436[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T253440[ebp], ecx
	mov	edx, DWORD PTR _i$225833[ebp]
	push	edx
	mov	eax, DWORD PTR $T253436[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253440[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 9179 : #endif
; 9180 : 
; 9181 : 		if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	SHORT $LN2@getNumAdja@2

; 9182 : 		{
; 9183 : 			if(!pAdjacentPlot->isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$253656[ebp], edx
	mov	eax, DWORD PTR _uiOffset$253656[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$253656[ebp]
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN2@getNumAdja@2

; 9184 : 			{
; 9185 : 				iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN2@getNumAdja@2:

; 9186 : 			}
; 9187 : 		}
; 9188 : 	}

	jmp	SHORT $LN4@getNumAdja@2
$LN3@getNumAdja@2:

; 9189 : #ifdef AUI_ASTAR_FIX_MAXIMIZE_EXPLORE_CONSIDER_2ND_RING_NONREVEALED
; 9190 : 	}
; 9191 : #endif
; 9192 : 
; 9193 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 9194 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumAdjacentNonrevealed@CvPlot@@QBEHW4TeamTypes@@@Z ENDP ; CvPlot::getNumAdjacentNonrevealed
_TEXT	ENDS
PUBLIC	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
; Function compile flags: /Odtp
;	COMDAT ?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T253663 = -4						; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::getRevealedImprovementType, COMDAT
; _this$ = ecx

; 9199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 9200 : 	if(bDebug && GC.getGame().isDebugMode())

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	je	SHORT $LN2@getReveale@4
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253663[ebp], ecx
	mov	ecx, DWORD PTR $T253663[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@getReveale@4

; 9201 : 	{
; 9202 : 		return getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	jmp	SHORT $LN3@getReveale@4

; 9203 : 	}
; 9204 : 	else

	jmp	SHORT $LN3@getReveale@4
$LN2@getReveale@4:

; 9205 : 	{
; 9206 : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9207 : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9208 : 
; 9209 : 		return (ImprovementTypes)m_aeRevealedImprovementType[eTeam];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
$LN3@getReveale@4:

; 9210 : 	}
; 9211 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::getRevealedImprovementType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getRevealedImprovementType, COMDAT
; _this$ = ecx

; 9215 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 9216 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9217 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9218 : 
; 9219 : 	return (ImprovementTypes)m_aeRevealedImprovementType[eTeam];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]

; 9220 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getRevealedImprovementType
_TEXT	ENDS
PUBLIC	??_C@_0CN@HPEKLIC@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ ; `string'
PUBLIC	??_C@_0CF@BPBIBDDF@TXT_KEY_NOTIFICATION_FOUND_BARB_@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvTeam::AddNotification
;	COMDAT ??_C@_0CN@HPEKLIC@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CN@HPEKLIC@TXT_KEY_NOTIFICATION_SUMMARY_FOU@ DB 'TXT_KEY_NOTIFICAT'
	DB	'ION_SUMMARY_FOUND_BARB_CAMP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BPBIBDDF@TXT_KEY_NOTIFICATION_FOUND_BARB_@
CONST	SEGMENT
??_C@_0CF@BPBIBDDF@TXT_KEY_NOTIFICATION_FOUND_BARB_@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_FOUND_BARB_CAMP', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$1
__ehfuncinfo$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T253694 = -100						; size = 4
$T253690 = -96						; size = 4
$T253686 = -92						; size = 4
$T253682 = -88						; size = 4
$T253678 = -84						; size = 4
$T253674 = -80						; size = 4
_strBuffer$225862 = -76					; size = 28
_strSummary$225865 = -48				; size = 28
__$ArrayPad$ = -20					; size = 4
_eOldImprovementType$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_eNewValue$ = 12					; size = 4
?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z PROC ; CvPlot::setRevealedImprovementType, COMDAT
; _this$ = ecx

; 9224 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 9225 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9226 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9227 : 
; 9228 : 	ImprovementTypes eOldImprovementType = getRevealedImprovementType(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	mov	DWORD PTR _eOldImprovementType$[ebp], eax

; 9229 : 	if(eOldImprovementType != eNewValue)

	mov	ecx, DWORD PTR _eOldImprovementType$[ebp]
	cmp	ecx, DWORD PTR _eNewValue$[ebp]
	je	$LN3@setReveale@3

; 9230 : 	{
; 9231 : 		m_aeRevealedImprovementType[eTeam] = eNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	mov	dx, WORD PTR _eNewValue$[ebp]
	mov	WORD PTR [eax+ecx*2], dx

; 9232 : 		if(eTeam == GC.getGame().getActiveTeam())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253674[ebp], eax
	mov	ecx, DWORD PTR $T253674[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN2@setReveale@3

; 9233 : 		{
; 9234 : 			updateSymbols();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateSymbols@CvPlot@@QAEXXZ		; CvPlot::updateSymbols

; 9235 : 			setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN2@setReveale@3:

; 9236 : 		}
; 9237 : 
; 9238 : 		// Found a Barbarian Camp
; 9239 : 		if(eNewValue == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	DWORD PTR $T253678[ebp], ecx
	mov	edx, DWORD PTR _eNewValue$[ebp]
	cmp	edx, DWORD PTR $T253678[ebp]
	jne	$LN1@setReveale@3

; 9240 : 		{
; 9241 : 			CvString strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_FOUND_BARB_CAMP");

	push	OFFSET ??_C@_0CF@BPBIBDDF@TXT_KEY_NOTIFICATION_FOUND_BARB_@
	lea	eax, DWORD PTR _strBuffer$225862[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 9242 : 			CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_FOUND_BARB_CAMP");

	push	OFFSET ??_C@_0CN@HPEKLIC@TXT_KEY_NOTIFICATION_SUMMARY_FOU@
	lea	ecx, DWORD PTR _strSummary$225865[ebp]
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 9243 : 			GET_TEAM(eTeam).AddNotification(NOTIFICATION_BARBARIAN, strBuffer, strSummary, getX(), getY());

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T253682[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T253686[ebp], edx
	lea	ecx, DWORD PTR _strSummary$225865[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T253690[ebp], eax
	lea	ecx, DWORD PTR _strBuffer$225862[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T253694[ebp], eax
	push	-1
	push	-1
	mov	eax, DWORD PTR $T253682[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253686[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253690[ebp]
	push	edx
	mov	eax, DWORD PTR $T253694[ebp]
	push	eax
	push	1892367718				; 70cb3d66H
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	call	?AddNotification@CvTeam@@QAEXW4NotificationTypes@@PBD1HHHH@Z ; CvTeam::AddNotification

; 9244 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$225865[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225862[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@setReveale@3:

; 9245 : 
; 9246 : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@setReveale@3
$LN3@setReveale@3:

; 9247 : 	}
; 9248 : 	return false;

	xor	al, al
$LN4@setReveale@3:

; 9249 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$225862[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z$1:
	lea	ecx, DWORD PTR _strSummary$225865[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setRevealedImprovementType@CvPlot@@QAE_NW4TeamTypes@@W4ImprovementTypes@@@Z ENDP ; CvPlot::setRevealedImprovementType
PUBLIC	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedRouteType
; Function compile flags: /Odtp
;	COMDAT ?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T253717 = -4						; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z PROC ; CvPlot::getRevealedRouteType, COMDAT
; _this$ = ecx

; 9254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 9255 : 	if(bDebug && GC.getGame().isDebugMode())

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	je	SHORT $LN2@getReveale@5
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253717[ebp], ecx
	mov	ecx, DWORD PTR $T253717[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@getReveale@5

; 9256 : 	{
; 9257 : 		return getRouteType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	jmp	SHORT $LN3@getReveale@5

; 9258 : 	}
; 9259 : 	else

	jmp	SHORT $LN3@getReveale@5
$LN2@getReveale@5:

; 9260 : 	{
; 9261 : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9262 : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9263 : 
; 9264 : 		return (RouteTypes)m_aeRevealedRouteType[eTeam];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
$LN3@getReveale@5:

; 9265 : 	}
; 9266 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ENDP ; CvPlot::getRevealedRouteType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z PROC ; CvPlot::getRevealedRouteType, COMDAT
; _this$ = ecx

; 9270 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 9271 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9272 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9273 : 
; 9274 : 	return (RouteTypes)m_aeRevealedRouteType[eTeam];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]

; 9275 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ENDP ; CvPlot::getRevealedRouteType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T253725 = -4						; size = 4
_eTeam$ = 8						; size = 4
_eNewValue$ = 12					; size = 4
?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z PROC ; CvPlot::setRevealedRouteType, COMDAT
; _this$ = ecx

; 9279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 9280 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9281 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9282 : 
; 9283 : 	if(getRevealedRouteType(eTeam, false) != eNewValue)

	push	0
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedRouteType
	cmp	eax, DWORD PTR _eNewValue$[ebp]
	je	SHORT $LN2@setReveale@4

; 9284 : 	{
; 9285 : 		if(eTeam == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253725[ebp], ecx
	mov	ecx, DWORD PTR $T253725[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR _eTeam$[ebp], eax
	jne	SHORT $LN1@setReveale@4

; 9286 : 		{
; 9287 : 			setLayoutDirty(true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN1@setReveale@4:

; 9288 : 		}
; 9289 : 		m_aeRevealedRouteType[eTeam] = eNewValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+168]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	mov	dx, WORD PTR _eNewValue$[ebp]
	mov	WORD PTR [eax+ecx*2], dx

; 9290 : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@setReveale@4
$LN2@setReveale@4:

; 9291 : 	}
; 9292 : 	return false;

	xor	al, al
$LN3@setReveale@4:

; 9293 : 
; 9294 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setRevealedRouteType@CvPlot@@QAE_NW4TeamTypes@@W4RouteTypes@@@Z ENDP ; CvPlot::setRevealedRouteType
_TEXT	ENDS
PUBLIC	?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ	; CvPlot::SilentlyResetAllBuildProgress
; Function compile flags: /Odtp
;	COMDAT ?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pkBuildInfo$225897 = -12				; size = 4
_iThisBuild$225893 = -8					; size = 4
_iNumBuildInfos$225892 = -4				; size = 4
?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ PROC	; CvPlot::SilentlyResetAllBuildProgress, COMDAT
; _this$ = ecx

; 9298 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 9299 : 	if(NULL != m_paiBuildProgress)  // if it doesn't exist no point in clearing it out

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 0
	je	SHORT $LN7@SilentlyRe

; 9300 : 	{
; 9301 : 		int iNumBuildInfos = GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	DWORD PTR _iNumBuildInfos$225892[ebp], eax

; 9302 : 		for(int iThisBuild = 0 ; iThisBuild < iNumBuildInfos; iThisBuild++)

	mov	DWORD PTR _iThisBuild$225893[ebp], 0
	jmp	SHORT $LN5@SilentlyRe
$LN4@SilentlyRe:
	mov	ecx, DWORD PTR _iThisBuild$225893[ebp]
	add	ecx, 1
	mov	DWORD PTR _iThisBuild$225893[ebp], ecx
$LN5@SilentlyRe:
	mov	edx, DWORD PTR _iThisBuild$225893[ebp]
	cmp	edx, DWORD PTR _iNumBuildInfos$225892[ebp]
	jge	SHORT $LN7@SilentlyRe

; 9303 : 		{
; 9304 : 			CvBuildInfo* pkBuildInfo = GC.getBuildInfo((BuildTypes) iThisBuild);

	mov	eax, DWORD PTR _iThisBuild$225893[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$225897[ebp], eax

; 9305 : 			if(!pkBuildInfo)

	cmp	DWORD PTR _pkBuildInfo$225897[ebp], 0
	jne	SHORT $LN2@SilentlyRe

; 9306 : 			{
; 9307 : 				continue;

	jmp	SHORT $LN4@SilentlyRe
$LN2@SilentlyRe:

; 9308 : 			}
; 9309 : 
; 9310 : 			// Is this an Improvement?
; 9311 : 			if(pkBuildInfo->getImprovement() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pkBuildInfo$225897[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, -1
	je	SHORT $LN1@SilentlyRe

; 9312 : 			{
; 9313 : 				m_paiBuildProgress[iThisBuild] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	xor	eax, eax
	mov	ecx, DWORD PTR _iThisBuild$225893[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN1@SilentlyRe:

; 9314 : 			}
; 9315 : 		}

	jmp	SHORT $LN4@SilentlyRe
$LN7@SilentlyRe:

; 9316 : 	}
; 9317 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ ENDP	; CvPlot::SilentlyResetAllBuildProgress
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBuild$ = 8						; size = 4
?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z PROC	; CvPlot::getBuildProgress, COMDAT
; _this$ = ecx

; 9322 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 9323 : 	if(NULL == m_paiBuildProgress)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 0
	jne	SHORT $LN1@getBuildPr

; 9324 : 	{
; 9325 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@getBuildPr
$LN1@getBuildPr:

; 9326 : 	}
; 9327 : 
; 9328 : 	return m_paiBuildProgress[eBuild];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	mov	eax, DWORD PTR _eBuild$[ebp]
	movsx	eax, WORD PTR [edx+eax*2]
$LN2@getBuildPr:

; 9329 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ENDP	; CvPlot::getBuildProgress
_TEXT	ENDS
PUBLIC	?getAnyBuildProgress@CvPlot@@QBE_NXZ		; CvPlot::getAnyBuildProgress
; Function compile flags: /Odtp
;	COMDAT ?getAnyBuildProgress@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getAnyBuildProgress@CvPlot@@QBE_NXZ PROC		; CvPlot::getAnyBuildProgress, COMDAT
; _this$ = ecx

; 9333 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 9334 : 	return (NULL != m_paiBuildProgress);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+184], 0
	setne	cl
	mov	al, cl

; 9335 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getAnyBuildProgress@CvPlot@@QBE_NXZ ENDP		; CvPlot::getAnyBuildProgress
_TEXT	ENDS
PUBLIC	??_C@_0O@IHECMGDD@BuildFinished?$AA@		; `string'
PUBLIC	??_C@_0CD@FMFKENPF@TXT_KEY_MISC_CLEARING_FEATURE_FO@ ; `string'
PUBLIC	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
PUBLIC	??_C@_0CH@CPADFGIA@TXT_KEY_MISC_CLEARING_FEATURE_RE@ ; `string'
PUBLIC	??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@	; `string'
PUBLIC	??_C@_0BF@JJGJCPKA@CIVILIZATION_GERMANY?$AA@	; `string'
PUBLIC	??_C@_0BD@JMLCBJAM@CIVILIZATION_EGYPT?$AA@	; `string'
PUBLIC	??_C@_0BF@NPPNHJNF@CIVILIZATION_AMERICA?$AA@	; `string'
PUBLIC	??_C@_0DA@HNOEPFPA@TXT_KEY_NOTIFICATION_SUMMARY_CHO@ ; `string'
PUBLIC	??_C@_0CI@DIFFJHJO@TXT_KEY_NOTIFICATION_CHOOSE_ARCH@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z ; CvPlot::changeBuildProgress
EXTRN	?changeFood@CvCity@@QAEXH@Z:PROC		; CvCity::changeFood
EXTRN	?changeFeatureProduction@CvCity@@QAEXH@Z:PROC	; CvCity::changeFeatureProduction
EXTRN	?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z:PROC ; CvPlayerCulture::DoArchaeologyChoice
EXTRN	?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z:PROC ; CvPlayerCulture::GetArchaeologyChoice
EXTRN	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getCivilizationTypeKey
EXTRN	__imp_??0String@Localization@@QAE@XZ:PROC
EXTRN	?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z:PROC ; CvPlayerCulture::AddDigCompletePlot
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?SetNumArchaeologyChoices@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::SetNumArchaeologyChoices
EXTRN	?GetNumArchaeologyChoices@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumArchaeologyChoices
EXTRN	?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsPromptWhenComplete
EXTRN	?IsRemovesResource@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsRemovesResource
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT ??_C@_0O@IHECMGDD@BuildFinished?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0O@IHECMGDD@BuildFinished?$AA@ DB 'BuildFinished', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FMFKENPF@TXT_KEY_MISC_CLEARING_FEATURE_FO@
CONST	SEGMENT
??_C@_0CD@FMFKENPF@TXT_KEY_MISC_CLEARING_FEATURE_FO@ DB 'TXT_KEY_MISC_CLE'
	DB	'ARING_FEATURE_FOOD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPADFGIA@TXT_KEY_MISC_CLEARING_FEATURE_RE@
CONST	SEGMENT
??_C@_0CH@CPADFGIA@TXT_KEY_MISC_CLEARING_FEATURE_RE@ DB 'TXT_KEY_MISC_CLE'
	DB	'ARING_FEATURE_RESOURCE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@
CONST	SEGMENT
??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@ DB 'UNIT_ARCHAEOLOGIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JJGJCPKA@CIVILIZATION_GERMANY?$AA@
CONST	SEGMENT
??_C@_0BF@JJGJCPKA@CIVILIZATION_GERMANY?$AA@ DB 'CIVILIZATION_GERMANY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMLCBJAM@CIVILIZATION_EGYPT?$AA@
CONST	SEGMENT
??_C@_0BD@JMLCBJAM@CIVILIZATION_EGYPT?$AA@ DB 'CIVILIZATION_EGYPT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NPPNHJNF@CIVILIZATION_AMERICA?$AA@
CONST	SEGMENT
??_C@_0BF@NPPNHJNF@CIVILIZATION_AMERICA?$AA@ DB 'CIVILIZATION_AMERICA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HNOEPFPA@TXT_KEY_NOTIFICATION_SUMMARY_CHO@
CONST	SEGMENT
??_C@_0DA@HNOEPFPA@TXT_KEY_NOTIFICATION_SUMMARY_CHO@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_CHOOSE_ARCHAEOLOGY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DIFFJHJO@TXT_KEY_NOTIFICATION_CHOOSE_ARCH@
CONST	SEGMENT
??_C@_0CI@DIFFJHJO@TXT_KEY_NOTIFICATION_CHOOSE_ARCH@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_CHOOSE_ARCHAEOLOGY', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv638 = -764						; size = 4
tv629 = -760						; size = 4
tv620 = -756						; size = 4
tv613 = -752						; size = 4
tv602 = -748						; size = 4
tv544 = -744						; size = 4
tv213 = -740						; size = 4
tv473 = -736						; size = 4
tv222 = -732						; size = 4
tv346 = -728						; size = 4
tv323 = -724						; size = 4
tv1013 = -720						; size = 4
tv1008 = -714						; size = 1
tv1001 = -713						; size = 1
tv997 = -712						; size = 4
tv998 = -708						; size = 4
tv301 = -704						; size = 4
tv985 = -700						; size = 4
tv980 = -694						; size = 1
tv973 = -693						; size = 1
tv968 = -692						; size = 4
tv970 = -688						; size = 4
tv279 = -684						; size = 4
tv956 = -680						; size = 4
tv951 = -674						; size = 1
tv944 = -673						; size = 1
tv939 = -672						; size = 4
tv941 = -668						; size = 4
tv264 = -664						; size = 4
tv931 = -660						; size = 4
tv926 = -654						; size = 1
tv919 = -653						; size = 1
tv914 = -652						; size = 4
tv916 = -648						; size = 4
tv216 = -644						; size = 4
_this$ = -640						; size = 4
$T254049 = -636						; size = 4
$T254045 = -632						; size = 4
$T254036 = -628						; size = 4
$T254032 = -624						; size = 4
$T254028 = -620						; size = 4
$T254020 = -616						; size = 4
_f$254016 = -609					; size = 1
$T254007 = -608						; size = 4
$T254003 = -604						; size = 4
$T253994 = -600						; size = 4
$T253985 = -596						; size = 4
$T253981 = -592						; size = 4
$T253977 = -588						; size = 4
$T253969 = -584						; size = 4
_f$253965 = -577					; size = 1
$T253956 = -576						; size = 4
$T253952 = -572						; size = 4
_f$253940 = -566					; size = 1
_f$253931 = -565					; size = 1
$T253922 = -564						; size = 4
$T253869 = -504						; size = 4
$T253860 = -500						; size = 4
$T253851 = -496						; size = 4
$T253847 = -492						; size = 4
$T253843 = -488						; size = 4
$T253839 = -481						; size = 1
$T253830 = -480						; size = 4
$T253815 = -476						; size = 4
$T253811 = -472						; size = 4
$T253797 = -468						; size = 4
$T253793 = -464						; size = 4
$T253789 = -460						; size = 4
$T253785 = -456						; size = 4
$T253772 = -452						; size = 4
$T253746 = -445						; size = 1
$T253745 = -444						; size = 8
$T253744 = -436						; size = 28
$T253743 = -408						; size = 4
$T253742 = -404						; size = 4
$T253741 = -400						; size = 8
$T253740 = -392						; size = 28
$T253739 = -364						; size = 4
$T253738 = -360						; size = 4
$T253737 = -356						; size = 28
$T253736 = -328						; size = 4
$T253735 = -322						; size = 1
_bResult$226019 = -321					; size = 1
_args$226018 = -320					; size = 4
_iFood$226003 = -316					; size = 4
_pkRouteInfo$225981 = -312				; size = 4
_eRoute$225979 = -308					; size = 4
_eChoice$225977 = -304					; size = 4
_pLoopUnit$225968 = -300				; size = 4
_iUnitLoop$225969 = -296				; size = 4
_kLoopPlayer$225963 = -292				; size = 4
_i$225959 = -288					; size = 4
_kPlotOwner$225956 = -284				; size = 4
_strSummary$225950 = -280				; size = 28
_pNotifications$225944 = -252				; size = 4
_szCivKey$225953 = -248					; size = 4
_locSummary$225946 = -244				; size = 80
_locString$225945 = -164				; size = 80
_newImprovementEntry$225939 = -80			; size = 4
_pkScriptSystem$226016 = -76				; size = 4
_iI$225927 = -72					; size = 4
_eImprovement$225931 = -68				; size = 4
_strBuffer$ = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_pCity$ = -32						; size = 4
_iProduction$ = -28					; size = 4
_pkBuildInfo$ = -24					; size = 4
_bFinished$ = -17					; size = 1
_kPlayer$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_eBuild$ = 8						; size = 4
_iChange$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z PROC ; CvPlot::changeBuildProgress, COMDAT
; _this$ = ecx

; 9341 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 752				; 000002f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 9342 : 	CvCity* pCity;
; 9343 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 9344 : 	int iProduction;
; 9345 : 	bool bFinished = false;

	mov	BYTE PTR _bFinished$[ebp], 0

; 9346 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], eax

; 9347 : 
; 9348 : 	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$[ebp], eax

; 9349 : 	CvAssert(pkBuildInfo);
; 9350 : 
; 9351 : 	//This shouldn't happen.
; 9352 : 	if(pkBuildInfo == NULL)

	cmp	DWORD PTR _pkBuildInfo$[ebp], 0
	jne	SHORT $LN46@changeBuil

; 9353 : 		return false;

	mov	BYTE PTR $T253735[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T253735[ebp]
	jmp	$LN47@changeBuil
$LN46@changeBuil:

; 9354 : 
; 9355 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN45@changeBuil

; 9356 : 	{
; 9357 : 		if(NULL == m_paiBuildProgress)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+184], 0
	jne	SHORT $LN44@changeBuil

; 9358 : 		{
; 9359 : #ifdef AUI_WARNING_FIXES
; 9360 : 			m_paiBuildProgress = FNEW(int[GC.getNumBuildInfos()], c_eCiv5GameplayDLL, 0);
; 9361 : 			for (uint iI = 0; iI < GC.getNumBuildInfos(); ++iI)
; 9362 : #else
; 9363 : 			m_paiBuildProgress = FNEW(short[GC.getNumBuildInfos()], c_eCiv5GameplayDLL, 0);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	xor	ecx, ecx
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T253736[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T253736[ebp]
	mov	DWORD PTR [eax+184], ecx

; 9364 : 			for(int iI = 0; iI < GC.getNumBuildInfos(); ++iI)

	mov	DWORD PTR _iI$225927[ebp], 0
	jmp	SHORT $LN43@changeBuil
$LN42@changeBuil:
	mov	edx, DWORD PTR _iI$225927[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225927[ebp], edx
$LN43@changeBuil:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iI$225927[ebp], eax
	jge	SHORT $LN44@changeBuil

; 9365 : #endif
; 9366 : 			{
; 9367 : 				m_paiBuildProgress[iI] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	xor	edx, edx
	mov	eax, DWORD PTR _iI$225927[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 9368 : 			}

	jmp	SHORT $LN42@changeBuil
$LN44@changeBuil:

; 9369 : 		}
; 9370 : 
; 9371 : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuildInfo->getImprovement();

	mov	ecx, DWORD PTR _pkBuildInfo$[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$225931[ebp], eax

; 9372 : 		if (eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$225931[ebp], -1
	je	SHORT $LN40@changeBuil

; 9373 : 		{
; 9374 : 			if (eImprovement != m_eImprovementTypeUnderConstruction)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+442]
	cmp	DWORD PTR _eImprovement$225931[ebp], edx
	je	SHORT $LN40@changeBuil

; 9375 : 			{
; 9376 : 				SilentlyResetAllBuildProgress();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SilentlyResetAllBuildProgress@CvPlot@@QAEXXZ ; CvPlot::SilentlyResetAllBuildProgress

; 9377 : 				m_eImprovementTypeUnderConstruction = eImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _eImprovement$225931[ebp]
	mov	BYTE PTR [eax+442], cl
$LN40@changeBuil:

; 9378 : 			}
; 9379 : 		}
; 9380 : 
; 9381 : 		m_paiBuildProgress[eBuild] += iChange;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	mov	ecx, DWORD PTR _eBuild$[ebp]
	movsx	edx, WORD PTR [eax+ecx*2]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	mov	eax, DWORD PTR _eBuild$[ebp]
	mov	WORD PTR [ecx+eax*2], dx

; 9382 : 		CvAssert(getBuildProgress(eBuild) >= 0);
; 9383 : 
; 9384 : 		if(getBuildProgress(eBuild) >= getBuildTime(eBuild, ePlayer))

	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress
	mov	esi, eax
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	cmp	esi, eax
	jl	$LN45@changeBuil

; 9385 : 		{
; 9386 : 			m_paiBuildProgress[eBuild] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+184]
	xor	eax, eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	mov	WORD PTR [edx+ecx*2], ax

; 9387 : 
; 9388 : 			// Constructed Improvement
; 9389 : 			if (eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$225931[ebp], -1
	je	$LN37@changeBuil

; 9390 : 			{
; 9391 : 				setImprovementType(eImprovement, ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eImprovement$225931[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType

; 9392 : 
; 9393 : 				// Unowned plot, someone has to foot the bill
; 9394 : 				if(getOwner() == NO_PLAYER)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	jne	SHORT $LN36@changeBuil

; 9395 : 				{
; 9396 : 					if(MustPayMaintenanceHere(ePlayer))

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@changeBuil

; 9397 : 					{
; 9398 : 						kPlayer.GetTreasury()->ChangeBaseImprovementGoldMaintenance(GC.getImprovementInfo(eImprovement)->GetGoldMaintenance());

	mov	edx, DWORD PTR _eImprovement$225931[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetGoldMaintenance@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN35@changeBuil:

; 9399 : 					}
; 9400 : 					SetPlayerResponsibleForImprovement(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerResponsibleForImprovement@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForImprovement
$LN36@changeBuil:

; 9401 : 				}
; 9402 : 
; 9403 : 				CvImprovementEntry& newImprovementEntry = *GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$225931[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _newImprovementEntry$225939[ebp], eax

; 9404 : 
; 9405 : 				// If this improvement removes the underlying resource, do that
; 9406 : 				if (newImprovementEntry.IsRemovesResource())

	mov	ecx, DWORD PTR _newImprovementEntry$225939[ebp]
	call	?IsRemovesResource@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsRemovesResource
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@changeBuil

; 9407 : 				{
; 9408 : 					if (getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN34@changeBuil

; 9409 : 					{
; 9410 : 						setResourceType(NO_RESOURCE, 0);

	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
$LN34@changeBuil:

; 9411 : 					}
; 9412 : 				}
; 9413 : 
; 9414 : 				// If we want to prompt the user about archaeology, let's record that
; 9415 : 				if (newImprovementEntry.IsPromptWhenComplete())

	mov	ecx, DWORD PTR _newImprovementEntry$225939[ebp]
	call	?IsPromptWhenComplete@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsPromptWhenComplete
	movzx	eax, al
	test	eax, eax
	je	$LN37@changeBuil

; 9416 : 				{
; 9417 : 					CvAssertMsg (GetArchaeologicalRecord().m_eArtifactType != NO_GREAT_WORK_ARTIFACT_CLASS, "Archaeological dig complete but no archeology data found!");
; 9418 : 
; 9419 : 					kPlayer.SetNumArchaeologyChoices(kPlayer.GetNumArchaeologyChoices() + 1);

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetNumArchaeologyChoices@CvPlayer@@QBEHXZ ; CvPlayer::GetNumArchaeologyChoices
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?SetNumArchaeologyChoices@CvPlayer@@QAEXH@Z ; CvPlayer::SetNumArchaeologyChoices

; 9420 : 					kPlayer.GetCulture()->AddDigCompletePlot(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?AddDigCompletePlot@CvPlayerCulture@@QAEXPAVCvPlot@@@Z ; CvPlayerCulture::AddDigCompletePlot

; 9421 : 
; 9422 : 					if(kPlayer.isHuman())

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	$LN31@changeBuil

; 9423 : 					{
; 9424 : 						CvNotifications* pNotifications;
; 9425 : 						Localization::String locString;

	lea	ecx, DWORD PTR _locString$225945[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 9426 : 						Localization::String locSummary;

	lea	ecx, DWORD PTR _locSummary$225946[ebp]
	call	DWORD PTR __imp_??0String@Localization@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 9427 : 						pNotifications = kPlayer.GetNotifications();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225944[ebp], eax

; 9428 : 						if(pNotifications)

	cmp	DWORD PTR _pNotifications$225944[ebp], 0
	je	$LN30@changeBuil

; 9429 : 						{
; 9430 : 							strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_CHOOSE_ARCHAEOLOGY");

	push	OFFSET ??_C@_0CI@DIFFJHJO@TXT_KEY_NOTIFICATION_CHOOSE_ARCH@
	lea	eax, DWORD PTR $T253737[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv216[ebp], eax
	mov	ecx, DWORD PTR tv216[ebp]
	mov	DWORD PTR $T253772[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR $T253772[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T253737[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9431 : 							CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_CHOOSE_ARCHAEOLOGY");

	push	OFFSET ??_C@_0DA@HNOEPFPA@TXT_KEY_NOTIFICATION_SUMMARY_CHO@
	lea	eax, DWORD PTR _strSummary$225950[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 9432 : 							pNotifications->Add(NOTIFICATION_CHOOSE_ARCHAEOLOGY, strBuffer, strSummary, getX(), getY(), kPlayer.GetID());

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T253785[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T253789[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T253793[ebp], eax
	lea	ecx, DWORD PTR _strSummary$225950[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T253797[ebp], eax
	push	-1
	mov	ecx, DWORD PTR $T253785[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253789[ebp]
	push	edx
	mov	eax, DWORD PTR $T253793[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253797[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-2068323322				; 84b7e406H
	mov	ecx, DWORD PTR _pNotifications$225944[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 9433 : 							CancelActivePlayerEndTurn();

	call	?CancelActivePlayerEndTurn@@YA_NXZ	; CancelActivePlayerEndTurn

; 9434 : 						}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strSummary$225950[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN30@changeBuil:

; 9435 : 
; 9436 : 						// Raiders of the Lost Ark achievement
; 9437 : 						const char* szCivKey = kPlayer.getCivilizationTypeKey();

	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR _szCivKey$225953[ebp], eax

; 9438 : 						if(getOwner() != NO_PLAYER && !GC.getGame().isNetworkMultiPlayer() && strcmp(szCivKey, "CIVILIZATION_AMERICA") == 0)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, -1
	je	$LN29@changeBuil
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253811[ebp], ecx
	mov	ecx, DWORD PTR $T253811[ebp]
	call	?isNetworkMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isNetworkMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	$LN29@changeBuil
	mov	DWORD PTR tv916[ebp], OFFSET ??_C@_0BF@NPPNHJNF@CIVILIZATION_AMERICA?$AA@
	mov	eax, DWORD PTR _szCivKey$225953[ebp]
	mov	DWORD PTR tv914[ebp], eax
$LL232@changeBuil:
	mov	ecx, DWORD PTR tv914[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv919[ebp], dl
	mov	eax, DWORD PTR tv916[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN233@changeBuil
	cmp	BYTE PTR tv919[ebp], 0
	je	SHORT $LN234@changeBuil
	mov	ecx, DWORD PTR tv914[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv926[ebp], dl
	mov	eax, DWORD PTR tv916[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN233@changeBuil
	add	DWORD PTR tv914[ebp], 2
	add	DWORD PTR tv916[ebp], 2
	cmp	BYTE PTR tv926[ebp], 0
	jne	SHORT $LL232@changeBuil
$LN234@changeBuil:
	mov	DWORD PTR tv931[ebp], 0
	jmp	SHORT $LN235@changeBuil
$LN233@changeBuil:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv931[ebp], ecx
$LN235@changeBuil:
	mov	edx, DWORD PTR tv931[ebp]
	mov	DWORD PTR tv264[ebp], edx
	cmp	DWORD PTR tv264[ebp], 0
	jne	$LN29@changeBuil

; 9439 : 						{
; 9440 : 							CvPlayer &kPlotOwner = GET_PLAYER(getOwner());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T253815[ebp], ecx
	mov	edx, DWORD PTR $T253815[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlotOwner$225956[ebp], edx

; 9441 : 							szCivKey = kPlotOwner.getCivilizationTypeKey();

	mov	ecx, DWORD PTR _kPlotOwner$225956[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR _szCivKey$225953[ebp], eax

; 9442 : 							if(strcmp(szCivKey, "CIVILIZATION_EGYPT") == 0)

	mov	DWORD PTR tv941[ebp], OFFSET ??_C@_0BD@JMLCBJAM@CIVILIZATION_EGYPT?$AA@
	mov	eax, DWORD PTR _szCivKey$225953[ebp]
	mov	DWORD PTR tv939[ebp], eax
$LL236@changeBuil:
	mov	ecx, DWORD PTR tv939[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv944[ebp], dl
	mov	eax, DWORD PTR tv941[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN237@changeBuil
	cmp	BYTE PTR tv944[ebp], 0
	je	SHORT $LN238@changeBuil
	mov	ecx, DWORD PTR tv939[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv951[ebp], dl
	mov	eax, DWORD PTR tv941[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN237@changeBuil
	add	DWORD PTR tv939[ebp], 2
	add	DWORD PTR tv941[ebp], 2
	cmp	BYTE PTR tv951[ebp], 0
	jne	SHORT $LL236@changeBuil
$LN238@changeBuil:
	mov	DWORD PTR tv956[ebp], 0
	jmp	SHORT $LN239@changeBuil
$LN237@changeBuil:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv956[ebp], ecx
$LN239@changeBuil:
	mov	edx, DWORD PTR tv956[ebp]
	mov	DWORD PTR tv279[ebp], edx
	cmp	DWORD PTR tv279[ebp], 0
	jne	$LN29@changeBuil

; 9443 : 							{
; 9444 : 								for (int i = 0; i < MAX_MAJOR_CIVS; i++)

	mov	DWORD PTR _i$225959[ebp], 0
	jmp	SHORT $LN27@changeBuil
$LN26@changeBuil:
	mov	eax, DWORD PTR _i$225959[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225959[ebp], eax
$LN27@changeBuil:
	cmp	DWORD PTR _i$225959[ebp], 22		; 00000016H
	jge	$LN29@changeBuil

; 9445 : 								{
; 9446 : 									CvPlayer &kLoopPlayer = GET_PLAYER((PlayerTypes)i);

	mov	ecx, DWORD PTR _i$225959[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kLoopPlayer$225963[ebp], ecx

; 9447 : 									if (kLoopPlayer.GetID() != NO_PLAYER && kLoopPlayer.isAlive())

	mov	edx, DWORD PTR _kLoopPlayer$225963[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T253830[ebp], eax
	cmp	DWORD PTR $T253830[ebp], -1
	je	$LN24@changeBuil
	mov	ecx, DWORD PTR _kLoopPlayer$225963[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T253839[ebp], dl
	movzx	eax, BYTE PTR $T253839[ebp]
	test	eax, eax
	je	$LN24@changeBuil

; 9448 : 									{
; 9449 : 										szCivKey = kLoopPlayer.getCivilizationTypeKey();

	mov	ecx, DWORD PTR _kLoopPlayer$225963[ebp]
	call	?getCivilizationTypeKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationTypeKey
	mov	DWORD PTR _szCivKey$225953[ebp], eax

; 9450 : 										if (strcmp(szCivKey, "CIVILIZATION_GERMANY"))

	mov	DWORD PTR tv970[ebp], OFFSET ??_C@_0BF@JJGJCPKA@CIVILIZATION_GERMANY?$AA@
	mov	ecx, DWORD PTR _szCivKey$225953[ebp]
	mov	DWORD PTR tv968[ebp], ecx
$LL240@changeBuil:
	mov	edx, DWORD PTR tv968[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv973[ebp], al
	mov	ecx, DWORD PTR tv970[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN241@changeBuil
	cmp	BYTE PTR tv973[ebp], 0
	je	SHORT $LN242@changeBuil
	mov	edx, DWORD PTR tv968[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv980[ebp], al
	mov	ecx, DWORD PTR tv970[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN241@changeBuil
	add	DWORD PTR tv968[ebp], 2
	add	DWORD PTR tv970[ebp], 2
	cmp	BYTE PTR tv980[ebp], 0
	jne	SHORT $LL240@changeBuil
$LN242@changeBuil:
	mov	DWORD PTR tv985[ebp], 0
	jmp	SHORT $LN243@changeBuil
$LN241@changeBuil:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv985[ebp], edx
$LN243@changeBuil:
	mov	eax, DWORD PTR tv985[ebp]
	mov	DWORD PTR tv301[ebp], eax
	cmp	DWORD PTR tv301[ebp], 0
	je	$LN24@changeBuil

; 9451 : 										{
; 9452 : 											CvUnit *pLoopUnit;
; 9453 : 											int iUnitLoop;
; 9454 : 											for(pLoopUnit = kLoopPlayer.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kLoopPlayer.nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$225969[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kLoopPlayer$225963[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$225968[ebp], eax
	jmp	SHORT $LN22@changeBuil
$LN21@changeBuil:
	push	0
	lea	edx, DWORD PTR _iUnitLoop$225969[ebp]
	push	edx
	mov	ecx, DWORD PTR _kLoopPlayer$225963[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$225968[ebp], eax
$LN22@changeBuil:
	cmp	DWORD PTR _pLoopUnit$225968[ebp], 0
	je	$LN24@changeBuil

; 9455 : 											{
; 9456 : 												if(strcmp(pLoopUnit->getUnitInfo().GetType(), "UNIT_ARCHAEOLOGIST") == 0)

	mov	ecx, DWORD PTR _pLoopUnit$225968[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR $T253843[ebp], eax
	mov	DWORD PTR tv998[ebp], OFFSET ??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@
	mov	ecx, DWORD PTR $T253843[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv997[ebp], eax
$LL244@changeBuil:
	mov	eax, DWORD PTR tv997[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv1001[ebp], cl
	mov	edx, DWORD PTR tv998[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN245@changeBuil
	cmp	BYTE PTR tv1001[ebp], 0
	je	SHORT $LN246@changeBuil
	mov	eax, DWORD PTR tv997[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv1008[ebp], cl
	mov	edx, DWORD PTR tv998[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN245@changeBuil
	add	DWORD PTR tv997[ebp], 2
	add	DWORD PTR tv998[ebp], 2
	cmp	BYTE PTR tv1008[ebp], 0
	jne	SHORT $LL244@changeBuil
$LN246@changeBuil:
	mov	DWORD PTR tv1013[ebp], 0
	jmp	SHORT $LN247@changeBuil
$LN245@changeBuil:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv1013[ebp], eax
$LN247@changeBuil:
	mov	ecx, DWORD PTR tv1013[ebp]
	mov	DWORD PTR tv323[ebp], ecx
	cmp	DWORD PTR tv323[ebp], 0
	jne	$LN19@changeBuil

; 9457 : 												{
; 9458 : 													if (plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), getX(), getY()) <= 2)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T253847[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T253851[ebp], edx
	mov	eax, DWORD PTR _pLoopUnit$225968[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T253860[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$225968[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T253869[ebp], eax
	mov	ecx, DWORD PTR $T253847[ebp]
	push	ecx
	mov	edx, DWORD PTR $T253851[ebp]
	push	edx
	mov	eax, DWORD PTR $T253860[ebp]
	push	eax
	mov	ecx, DWORD PTR $T253869[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jg	SHORT $LN19@changeBuil

; 9459 : 													{
; 9460 : 														gDLL->UnlockAchievement(ACHIEVEMENT_XP2_33);

	mov	edx, DWORD PTR $T253922[ebp]
	mov	DWORD PTR tv346[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv346[ebp], eax
	push	275					; 00000113H
	mov	ecx, DWORD PTR tv346[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv346[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN19@changeBuil:

; 9461 : 													}
; 9462 : 												}
; 9463 : 											}

	jmp	$LN21@changeBuil
$LN24@changeBuil:

; 9464 : 										}
; 9465 : 									}
; 9466 : 								}

	jmp	$LN26@changeBuil
$LN29@changeBuil:

; 9467 : 							}
; 9468 : 						}
; 9469 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _locSummary$225946[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _locString$225945[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 9470 : 					else

	jmp	SHORT $LN37@changeBuil
$LN31@changeBuil:

; 9471 : 					{	
; 9472 : 						ArchaeologyChoiceType eChoice = kPlayer.GetCulture()->GetArchaeologyChoice(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetArchaeologyChoice@CvPlayerCulture@@QAE?AW4ArchaeologyChoiceType@@PAVCvPlot@@@Z ; CvPlayerCulture::GetArchaeologyChoice
	mov	DWORD PTR _eChoice$225977[ebp], eax

; 9473 : 						kPlayer.GetCulture()->DoArchaeologyChoice (eChoice);

	mov	edx, DWORD PTR _eChoice$225977[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?DoArchaeologyChoice@CvPlayerCulture@@QAEXW4ArchaeologyChoiceType@@@Z ; CvPlayerCulture::DoArchaeologyChoice
$LN37@changeBuil:

; 9474 : 					}
; 9475 : 				}
; 9476 : 			}
; 9477 : 
; 9478 : 			// Constructed Route
; 9479 : 			if(pkBuildInfo->getRoute() != NO_ROUTE)

	mov	ecx, DWORD PTR _pkBuildInfo$[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, -1
	je	$LN157@changeBuil

; 9480 : 			{
; 9481 : 				const RouteTypes eRoute = (RouteTypes)pkBuildInfo->getRoute();

	mov	ecx, DWORD PTR _pkBuildInfo$[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eRoute$225979[ebp], eax

; 9482 : 				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(eRoute);

	mov	eax, DWORD PTR _eRoute$225979[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkRouteInfo$225981[ebp], eax

; 9483 : 				if(pkRouteInfo)

	cmp	DWORD PTR _pkRouteInfo$225981[ebp], 0
	je	SHORT $LN157@changeBuil

; 9484 : 				{
; 9485 : 					setRouteType(eRoute);

	mov	ecx, DWORD PTR _eRoute$225979[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType

; 9486 : 
; 9487 : 					// Unowned plot, someone has to foot the bill
; 9488 : 					if(getOwner() == NO_PLAYER)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, -1
	jne	SHORT $LN157@changeBuil

; 9489 : 					{
; 9490 : 						if(MustPayMaintenanceHere(ePlayer))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::MustPayMaintenanceHere
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@changeBuil

; 9491 : 						{
; 9492 : 							kPlayer.GetTreasury()->ChangeBaseImprovementGoldMaintenance(pkRouteInfo->GetGoldMaintenance());

	mov	ecx, DWORD PTR _pkRouteInfo$225981[ebp]
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	push	eax
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?ChangeBaseImprovementGoldMaintenance@CvTreasury@@QAEXH@Z ; CvTreasury::ChangeBaseImprovementGoldMaintenance
$LN13@changeBuil:

; 9493 : 						}
; 9494 : 						SetPlayerResponsibleForRoute(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPlayerResponsibleForRoute@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetPlayerResponsibleForRoute

; 9495 : 					}
; 9496 : 				}
; 9497 : 			}
; 9498 : 
; 9499 : 			// Remove Feature
; 9500 : 			if(getFeatureType() != NO_FEATURE)

$LN157@changeBuil:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$253931[ebp], dl
	movsx	eax, BYTE PTR _f$253931[ebp]
	cmp	eax, -1
	je	$LN12@changeBuil

; 9501 : 			{
; 9502 : 				if(pkBuildInfo->isFeatureRemove(getFeatureType()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$253940[ebp], dl
	movsx	eax, BYTE PTR _f$253940[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkBuildInfo$[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@changeBuil

; 9503 : 				{
; 9504 : 					CvAssertMsg(ePlayer != NO_PLAYER, "ePlayer should be valid");
; 9505 : 
; 9506 : 					iProduction = getFeatureProduction(eBuild, ePlayer, &pCity);

	lea	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
	mov	DWORD PTR _iProduction$[ebp], eax

; 9507 : 
; 9508 : 					if(iProduction > 0)

	cmp	DWORD PTR _iProduction$[ebp], 0
	jle	$LN10@changeBuil

; 9509 : 					{
; 9510 : 						pCity->changeFeatureProduction(iProduction);

	mov	edx, DWORD PTR _iProduction$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?changeFeatureProduction@CvCity@@QAEXH@Z ; CvCity::changeFeatureProduction

; 9511 : 						if(pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T253952[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T253956[ebp], edx
	mov	ecx, DWORD PTR $T253956[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T253952[ebp], eax
	jne	$LN10@changeBuil

; 9512 : 						{
; 9513 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_CLEARING_FEATURE_RESOURCE", GC.getFeatureInfo(getFeatureType())->GetTextKey(), iProduction, pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T253738[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$253965[ebp], cl
	movsx	edx, BYTE PTR _f$253965[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T253739[ebp], eax
	lea	eax, DWORD PTR $T253738[ebp]
	push	eax
	lea	ecx, DWORD PTR _iProduction$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T253739[ebp]
	push	edx
	push	OFFSET ??_C@_0CH@CPADFGIA@TXT_KEY_MISC_CLEARING_FEATURE_RE@
	lea	eax, DWORD PTR $T253740[ebp]
	push	eax
	call	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv222[ebp], eax
	mov	ecx, DWORD PTR tv222[ebp]
	mov	DWORD PTR $T253969[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR $T253969[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T253740[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9514 : 							GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	eax, DWORD PTR $T253977[ebp]
	mov	DWORD PTR tv473[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv473[ebp], ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T253981[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T253985[ebp], edx
	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T253994[ebp], ecx
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR $T253981[ebp]
	push	edx
	mov	eax, DWORD PTR $T253985[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR $T253994[ebp]
	push	ecx
	lea	edx, DWORD PTR $T253741[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	push	0
	mov	eax, DWORD PTR tv473[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv473[ebp]
	mov	eax, DWORD PTR [edx+172]
	call	eax
$LN10@changeBuil:

; 9515 : 						}
; 9516 : 					}
; 9517 : #ifdef NQ_FOOD_FROM_CHOPS
; 9518 : 					int iFood = getFeatureFood(eBuild, ePlayer, &pCity);

	lea	ecx, DWORD PTR _pCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureFood
	mov	DWORD PTR _iFood$226003[ebp], eax

; 9519 : 					if (iFood > 0)

	cmp	DWORD PTR _iFood$226003[ebp], 0
	jle	$LN8@changeBuil

; 9520 : 					{
; 9521 : 						pCity->changeFood(iFood);

	mov	ecx, DWORD PTR _iFood$226003[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?changeFood@CvCity@@QAEXH@Z		; CvCity::changeFood

; 9522 : 						if(pCity->getOwner() == GC.getGame().getActivePlayer())

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T254003[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T254007[ebp], ecx
	mov	ecx, DWORD PTR $T254007[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T254003[ebp], eax
	jne	$LN8@changeBuil

; 9523 : 						{
; 9524 : 							strBuffer = GetLocalizedText("TXT_KEY_MISC_CLEARING_FEATURE_FOOD", GC.getFeatureInfo(getFeatureType())->GetTextKey(), iFood, pCity->getNameKey());

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getNameKey@CvCity@@QBEPBDXZ		; CvCity::getNameKey
	mov	DWORD PTR $T253742[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$254016[ebp], al
	movsx	ecx, BYTE PTR _f$254016[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?GetTextKey@CvBaseInfo@@QBEPBDXZ	; CvBaseInfo::GetTextKey
	mov	DWORD PTR $T253743[ebp], eax
	lea	edx, DWORD PTR $T253742[ebp]
	push	edx
	lea	eax, DWORD PTR _iFood$226003[ebp]
	push	eax
	lea	ecx, DWORD PTR $T253743[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@FMFKENPF@TXT_KEY_MISC_CLEARING_FEATURE_FO@
	lea	edx, DWORD PTR $T253744[ebp]
	push	edx
	call	??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ; GetLocalizedText<char const *,int,char const *>
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv213[ebp], eax
	mov	eax, DWORD PTR tv213[ebp]
	mov	DWORD PTR $T254020[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T254020[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T253744[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 9525 : 							GC.GetEngineUserInterface()->AddCityMessage(0, pCity->GetIDInfo(), pCity->getOwner(), false, GC.getEVENT_MESSAGE_TIME(), strBuffer);

	mov	edx, DWORD PTR $T254028[ebp]
	mov	DWORD PTR tv544[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv544[ebp], eax
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T254032[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6176
	mov	DWORD PTR $T254036[ebp], ecx
	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T254045[ebp], eax
	push	0
	push	0
	push	-1
	push	-1
	push	-1
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T254032[ebp]
	push	ecx
	mov	edx, DWORD PTR $T254036[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR $T254045[ebp]
	push	eax
	lea	ecx, DWORD PTR $T253745[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	push	eax
	push	0
	mov	edx, DWORD PTR tv544[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv544[ebp]
	mov	edx, DWORD PTR [eax+172]
	call	edx
$LN8@changeBuil:

; 9526 : 						}
; 9527 : 					}
; 9528 : #endif
; 9529 : 					setFeatureType(NO_FEATURE);

	push	-1
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType
$LN12@changeBuil:

; 9530 : 				}
; 9531 : 			}
; 9532 : 
; 9533 : 			// Repairing a Pillaged Tile
; 9534 : 			if(pkBuildInfo->isRepair())

	mov	ecx, DWORD PTR _pkBuildInfo$[ebp]
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@changeBuil

; 9535 : 			{
; 9536 : 				if(IsImprovementPillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@changeBuil

; 9537 : 				{
; 9538 : 					SetImprovementPillaged(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged
	jmp	SHORT $LN6@changeBuil
$LN5@changeBuil:

; 9539 : 				}
; 9540 : 				else if(IsRoutePillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@changeBuil

; 9541 : 				{
; 9542 : 					SetRoutePillaged(false);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetRoutePillaged@CvPlot@@QAEX_N@Z	; CvPlot::SetRoutePillaged
$LN6@changeBuil:

; 9543 : 				}
; 9544 : 			}
; 9545 : 
; 9546 : 			if(pkBuildInfo->IsRemoveRoute())

	mov	ecx, DWORD PTR _pkBuildInfo$[ebp]
	call	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ	; CvBuildInfo::IsRemoveRoute
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@changeBuil

; 9547 : 			{
; 9548 : 				setRouteType(NO_ROUTE);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType
$LN2@changeBuil:

; 9549 : 			}
; 9550 : 
; 9551 : 			bFinished = true;

	mov	BYTE PTR _bFinished$[ebp], 1

; 9552 : 
; 9553 : 			ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T254049[ebp]
	mov	DWORD PTR tv602[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv602[ebp], edx
	mov	eax, DWORD PTR tv602[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv602[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$226016[ebp], eax

; 9554 : 			if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$226016[ebp], 0
	je	$LN45@changeBuil

; 9555 : 			{
; 9556 : 				CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$226018[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 9557 : 				args->Push(ePlayer);

	mov	ecx, DWORD PTR _args$226018[ebp]
	mov	DWORD PTR tv613[ebp], ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR tv613[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv613[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 9558 : 				args->Push(getX());

	mov	ecx, DWORD PTR _args$226018[ebp]
	mov	DWORD PTR tv620[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv620[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv620[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 9559 : 				args->Push(getY());

	mov	ecx, DWORD PTR _args$226018[ebp]
	mov	DWORD PTR tv629[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR tv629[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv629[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 9560 : 				args->Push(eImprovement);

	mov	ecx, DWORD PTR _args$226018[ebp]
	mov	DWORD PTR tv638[ebp], ecx
	mov	edx, DWORD PTR _eImprovement$225931[ebp]
	push	edx
	mov	eax, DWORD PTR tv638[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv638[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 9561 : 
; 9562 : 				bool bResult;
; 9563 : 				LuaSupport::CallHook(pkScriptSystem, "BuildFinished", args.get(), bResult);

	lea	ecx, DWORD PTR _bResult$226019[ebp]
	push	ecx
	mov	edx, DWORD PTR _args$226018[ebp]
	push	edx
	push	OFFSET ??_C@_0O@IHECMGDD@BuildFinished?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$226016[ebp]
	push	eax
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 9564 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _args$226018[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN45@changeBuil:

; 9565 : 		}
; 9566 : 	}
; 9567 : 
; 9568 : 	return bFinished;

	mov	cl, BYTE PTR _bFinished$[ebp]
	mov	BYTE PTR $T253746[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T253746[ebp]
$LN47@changeBuil:

; 9569 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR _locString$225945[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR _locSummary$225946[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR $T253737[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$4:
	lea	ecx, DWORD PTR _strSummary$225950[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$5:
	lea	ecx, DWORD PTR $T253740[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$6:
	lea	ecx, DWORD PTR $T253744[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z$7:
	lea	ecx, DWORD PTR _args$226018[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-760]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z ENDP ; CvPlot::changeBuildProgress
; Function compile flags: /Odtp
;	COMDAT ?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T254111 = -8						; size = 4
$T254100 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ PROC ; CvPlot::getCenterUnit, COMDAT
; _this$ = ecx

; 9574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T254100[ebp], 0

; 9575 : 	return m_pCenterUnit;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 188				; 000000bcH
	mov	DWORD PTR $T254111[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T254111[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T254111[ebp]
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR [ecx+4], al
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@getCenterU
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@getCenterU:
	mov	eax, DWORD PTR $T254100[ebp]
	or	eax, 1
	mov	DWORD PTR $T254100[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 9576 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ENDP ; CvPlot::getCenterUnit
_TEXT	ENDS
PUBLIC	?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
; Function compile flags: /Odtp
;	COMDAT ?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T254126 = -8						; size = 4
$T254115 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ PROC ; CvPlot::getCenterUnit, COMDAT
; _this$ = ecx

; 9580 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T254115[ebp], 0

; 9581 : 	return m_pCenterUnit;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 188				; 000000bcH
	mov	DWORD PTR $T254126[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T254126[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T254126[ebp]
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR [ecx+4], al
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@getCenterU@2
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@getCenterU@2:
	mov	eax, DWORD PTR $T254115[ebp]
	or	eax, 1
	mov	DWORD PTR $T254115[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 9582 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ ENDP ; CvPlot::getCenterUnit
_TEXT	ENDS
PUBLIC	?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ	; CvPlot::getDebugCenterUnit
; Function compile flags: /Odtp
;	COMDAT ?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ
_TEXT	SEGMENT
tv130 = -32						; size = 4
_this$ = -28						; size = 4
$T254147 = -24						; size = 4
$T254134 = -20						; size = 4
$T254129 = -16						; size = 8
_pUnitNode$226037 = -8					; size = 4
_pCenterUnit$ = -4					; size = 4
?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ PROC	; CvPlot::getDebugCenterUnit, COMDAT
; _this$ = ecx

; 9587 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 9588 : 	const CvUnit* pCenterUnit;
; 9589 : 
; 9590 : 	pCenterUnit = getCenterUnit().pointer();

	lea	eax, DWORD PTR $T254129[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenterUnit@CvPlot@@QBE?BV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	DWORD PTR $T254134[ebp], eax
	mov	ecx, DWORD PTR $T254134[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pCenterUnit$[ebp], edx
	cmp	DWORD PTR $T254129[ebp], 0
	je	SHORT $LN11@getDebugCe
	mov	ecx, DWORD PTR $T254129[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@getDebugCe:

; 9591 : 
; 9592 : 	if(pCenterUnit == NULL)

	cmp	DWORD PTR _pCenterUnit$[ebp], 0
	jne	SHORT $LN4@getDebugCe

; 9593 : 	{
; 9594 : 		if(GC.getGame().isDebugMode())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T254147[ebp], eax
	mov	ecx, DWORD PTR $T254147[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@getDebugCe

; 9595 : 		{
; 9596 : 			const IDInfo* pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$226037[ebp], eax

; 9597 : 			if(pUnitNode == NULL)

	cmp	DWORD PTR _pUnitNode$226037[ebp], 0
	jne	SHORT $LN2@getDebugCe

; 9598 : 				pCenterUnit = NULL;

	mov	DWORD PTR _pCenterUnit$[ebp], 0

; 9599 : 			else

	jmp	SHORT $LN4@getDebugCe
$LN2@getDebugCe:

; 9600 : 				pCenterUnit = GetPlayerUnit(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$226037[ebp]
	cmp	DWORD PTR [edx], 0
	jl	SHORT $LN17@getDebugCe
	mov	eax, DWORD PTR _pUnitNode$226037[ebp]
	cmp	DWORD PTR [eax], 64			; 00000040H
	jge	SHORT $LN17@getDebugCe
	mov	ecx, DWORD PTR _pUnitNode$226037[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [eax+edx+4472]
	mov	DWORD PTR tv130[ebp], ecx
	mov	edx, DWORD PTR _pUnitNode$226037[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR tv130[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pCenterUnit$[ebp], eax
	jmp	SHORT $LN4@getDebugCe
$LN17@getDebugCe:
	mov	DWORD PTR _pCenterUnit$[ebp], 0
$LN4@getDebugCe:

; 9601 : 		}
; 9602 : 	}
; 9603 : 
; 9604 : 	return pCenterUnit;

	mov	eax, DWORD PTR _pCenterUnit$[ebp]

; 9605 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getDebugCenterUnit@CvPlot@@QBEPBVCvUnit@@XZ ENDP	; CvPlot::getDebugCenterUnit
_TEXT	ENDS
EXTRN	?setInfoBarDirty@CvUnit@@QAEX_N@Z:PROC		; CvUnit::setInfoBarDirty
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3
__ehfuncinfo$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
tv137 = -56						; size = 4
_this$ = -52						; size = 4
$T254216 = -45						; size = 1
$T254209 = -44						; size = 4
$T254183 = -40						; size = 4
$T254159 = -36						; size = 8
_newCenterUnit$226047 = -28				; size = 8
_pOldValue$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_pNewValue$ = 8						; size = 8
?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z PROC ; CvPlot::setCenterUnit, COMDAT
; _this$ = ecx

; 9610 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 9611 : 	UnitHandle pOldValue;

	mov	DWORD PTR _pOldValue$[ebp], 0
	mov	BYTE PTR _pOldValue$[ebp+4], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 9612 : 
; 9613 : 	pOldValue = getCenterUnit();

	lea	eax, DWORD PTR $T254159[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	DWORD PTR tv137[ebp], eax
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T254183[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T254183[ebp]
	lea	eax, DWORD PTR _pOldValue$[ebp]
	cmp	edx, eax
	je	SHORT $LN14@setCenterU
	cmp	DWORD PTR _pOldValue$[ebp], 0
	je	SHORT $LN12@setCenterU
	mov	ecx, DWORD PTR _pOldValue$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN12@setCenterU:
	mov	ecx, DWORD PTR $T254183[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pOldValue$[ebp], edx
	cmp	DWORD PTR _pOldValue$[ebp], 0
	je	SHORT $LN14@setCenterU
	mov	ecx, DWORD PTR _pOldValue$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN14@setCenterU:
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T254159[ebp], 0
	je	SHORT $LN21@setCenterU
	mov	ecx, DWORD PTR $T254159[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN21@setCenterU:

; 9614 : 
; 9615 : 	m_pCenterUnit = pNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 188				; 000000bcH
	mov	DWORD PTR $T254209[ebp], eax
	lea	ecx, DWORD PTR _pNewValue$[ebp]
	cmp	ecx, DWORD PTR $T254209[ebp]
	je	SHORT $LN28@setCenterU
	mov	edx, DWORD PTR $T254209[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN26@setCenterU
	mov	eax, DWORD PTR $T254209[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN26@setCenterU:
	mov	ecx, DWORD PTR $T254209[ebp]
	mov	edx, DWORD PTR _pNewValue$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T254209[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN28@setCenterU
	mov	ecx, DWORD PTR $T254209[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN28@setCenterU:

; 9616 : 	m_pCenterUnit.ignoreDestruction(true);

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+192], 1

; 9617 : 
; 9618 : 	if(pOldValue != pNewValue)

	xor	eax, eax
	cmp	DWORD PTR _pOldValue$[ebp], 0
	setne	al
	mov	BYTE PTR $T254216[ebp], al
	movzx	ecx, BYTE PTR $T254216[ebp]
	xor	edx, edx
	cmp	DWORD PTR _pNewValue$[ebp], 0
	setne	dl
	movzx	eax, dl
	cmp	ecx, eax
	je	SHORT $LN2@setCenterU

; 9619 : 	{
; 9620 : 		UnitHandle newCenterUnit = getCenterUnit();

	lea	ecx, DWORD PTR _newCenterUnit$226047[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenterUnit@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvPlot::getCenterUnit
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 9621 : 		if(newCenterUnit)

	xor	edx, edx
	cmp	DWORD PTR _newCenterUnit$226047[ebp], 0
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@setCenterU

; 9622 : 		{
; 9623 : 			newCenterUnit->setInfoBarDirty(true);

	push	1
	mov	ecx, DWORD PTR _newCenterUnit$226047[ebp]
	call	?setInfoBarDirty@CvUnit@@QAEX_N@Z	; CvUnit::setInfoBarDirty
$LN1@setCenterU:

; 9624 : 		}
; 9625 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR _newCenterUnit$226047[ebp], 0
	je	SHORT $LN2@setCenterU
	mov	ecx, DWORD PTR _newCenterUnit$226047[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@setCenterU:

; 9626 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR _pOldValue$[ebp], 0
	je	SHORT $LN50@setCenterU
	mov	ecx, DWORD PTR _pOldValue$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN50@setCenterU:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pNewValue$[ebp], 0
	je	SHORT $LN3@setCenterU
	mov	ecx, DWORD PTR _pNewValue$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN3@setCenterU:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$0:
	lea	ecx, DWORD PTR _pNewValue$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$1:
	lea	ecx, DWORD PTR _pOldValue$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$2:
	lea	ecx, DWORD PTR $T254159[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z$3:
	lea	ecx, DWORD PTR _newCenterUnit$226047[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setCenterUnit@CvPlot@@QAEXV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; CvPlot::setCenterUnit
PUBLIC	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::getInvisibleVisibilityCount
; Function compile flags: /Odtp
;	COMDAT ?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_eInvisible$ = 12					; size = 4
?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z PROC ; CvPlot::getInvisibleVisibilityCount, COMDAT
; _this$ = ecx

; 9630 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 9631 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9632 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9633 : 	CvAssertMsg(eInvisible >= 0, "eInvisible is expected to be non-negative (invalid Index)");
; 9634 : 	CvAssertMsg(eInvisible < NUM_INVISIBLE_TYPES, "eInvisible is expected to be within maximum bounds (invalid Index)");
; 9635 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return 0;

	cmp	DWORD PTR _eTeam$[ebp], 0
	jl	SHORT $LN3@getInvisib
	cmp	DWORD PTR _eTeam$[ebp], 64		; 00000040H
	jl	SHORT $LN4@getInvisib
$LN3@getInvisib:
	xor	eax, eax
	jmp	SHORT $LN5@getInvisib
$LN4@getInvisib:

; 9636 : 	if(eInvisible < 0 || eInvisible >= NUM_INVISIBLE_TYPES) return 0;

	cmp	DWORD PTR _eInvisible$[ebp], 0
	jl	SHORT $LN1@getInvisib
	cmp	DWORD PTR _eInvisible$[ebp], 1
	jl	SHORT $LN2@getInvisib
$LN1@getInvisib:
	xor	eax, eax
	jmp	SHORT $LN5@getInvisib
$LN2@getInvisib:

; 9637 : 	return m_apaiInvisibleVisibilityCount[eTeam][eInvisible];

	mov	eax, DWORD PTR _eTeam$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2+196]
	mov	eax, DWORD PTR _eInvisible$[ebp]
	movsx	eax, WORD PTR [edx+eax*2]
$LN5@getInvisib:

; 9638 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ENDP ; CvPlot::getInvisibleVisibilityCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_eInvisible$ = 12					; size = 4
?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z PROC ; CvPlot::isInvisibleVisible, COMDAT
; _this$ = ecx

; 9643 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 9644 : 	return (getInvisibleVisibilityCount(eTeam, eInvisible) > 0);

	mov	eax, DWORD PTR _eInvisible$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::getInvisibleVisibilityCount
	xor	edx, edx
	test	eax, eax
	setg	dl
	mov	al, dl

; 9645 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ENDP ; CvPlot::isInvisibleVisible
_TEXT	ENDS
PUBLIC	__real@3f000000
;	COMDAT __real@3f000000
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$1
__ehfuncinfo$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
_TEXT	SEGMENT
tv168 = -76						; size = 4
tv158 = -72						; size = 4
tv194 = -68						; size = 4
_this$ = -64						; size = 4
_inst$254306 = -60					; size = 4
$T254302 = -56						; size = 4
$T254290 = -52						; size = 4
$T254274 = -48						; size = 4
$T254266 = -44						; size = 4
$T254265 = -40						; size = 4
_pDllUnit$226093 = -36					; size = 4
_pUnitNode$226082 = -32					; size = 4
_pLoopUnit$226083 = -28					; size = 4
_activeTeam$226080 = -24				; size = 4
_iNumInvisibleInfos$ = -20				; size = 4
_bOldInvisibleVisible$ = -14				; size = 1
_bNewInvisibleVisible$ = -13				; size = 1
__$EHRec$ = -12						; size = 12
_eTeam$ = 8						; size = 4
_eInvisible$ = 12					; size = 4
_iChange$ = 16						; size = 4
?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z PROC ; CvPlot::changeInvisibleVisibilityCount, COMDAT
; _this$ = ecx

; 9650 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 9651 : 	bool bOldInvisibleVisible;
; 9652 : 	bool bNewInvisibleVisible;
; 9653 : 	const int iNumInvisibleInfos = NUM_INVISIBLE_TYPES;

	mov	DWORD PTR _iNumInvisibleInfos$[ebp], 1

; 9654 : 	DEBUG_VARIABLE(iNumInvisibleInfos);
; 9655 : 
; 9656 : 	CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 9657 : 	CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 9658 : 	CvAssertMsg(eInvisible >= 0, "eInvisible is expected to be non-negative (invalid Index)");
; 9659 : 	CvAssertMsg(eInvisible < iNumInvisibleInfos, "eInvisible is expected to be within maximum bounds (invalid Index)");
; 9660 : 	if(eTeam < 0 || eTeam >= MAX_TEAMS) return;

	cmp	DWORD PTR _eTeam$[ebp], 0
	jl	SHORT $LN9@changeInvi
	cmp	DWORD PTR _eTeam$[ebp], 64		; 00000040H
	jl	SHORT $LN10@changeInvi
$LN9@changeInvi:
	jmp	$LN11@changeInvi
$LN10@changeInvi:

; 9661 : 	if(eInvisible < 0 || eInvisible >= NUM_INVISIBLE_TYPES) return;

	cmp	DWORD PTR _eInvisible$[ebp], 0
	jl	SHORT $LN7@changeInvi
	cmp	DWORD PTR _eInvisible$[ebp], 1
	jl	SHORT $LN8@changeInvi
$LN7@changeInvi:
	jmp	$LN11@changeInvi
$LN8@changeInvi:

; 9662 : 
; 9663 : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN4@changeInvi

; 9664 : 	{
; 9665 : 		bOldInvisibleVisible = isInvisibleVisible(eTeam, eInvisible);

	mov	eax, DWORD PTR _eInvisible$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
	mov	BYTE PTR _bOldInvisibleVisible$[ebp], al

; 9666 : 
; 9667 : 		m_apaiInvisibleVisibilityCount[eTeam][eInvisible] = (m_apaiInvisibleVisibilityCount[eTeam][eInvisible] + iChange);

	mov	edx, DWORD PTR _eTeam$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2+196]
	mov	edx, DWORD PTR _eInvisible$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _eTeam$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*2+196]
	mov	edx, DWORD PTR _eInvisible$[ebp]
	mov	WORD PTR [ecx+edx*2], ax

; 9668 : 
; 9669 : 		CvAssertFmt(m_apaiInvisibleVisibilityCount[eTeam][eInvisible] >= 0, "Invisible Visibility going negative for %d, %d", m_iX, m_iY);
; 9670 : 
; 9671 : 		bNewInvisibleVisible = isInvisibleVisible(eTeam, eInvisible);

	mov	eax, DWORD PTR _eInvisible$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
	mov	BYTE PTR _bNewInvisibleVisible$[ebp], al

; 9672 : 
; 9673 : 		if(bOldInvisibleVisible != bNewInvisibleVisible)

	movzx	edx, BYTE PTR _bOldInvisibleVisible$[ebp]
	movzx	eax, BYTE PTR _bNewInvisibleVisible$[ebp]
	cmp	edx, eax
	je	$LN4@changeInvi

; 9674 : 		{
; 9675 : 			TeamTypes activeTeam = GC.getGame().getActiveTeam();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T254274[ebp], ecx
	mov	ecx, DWORD PTR $T254274[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _activeTeam$226080[ebp], eax

; 9676 : 			if(eTeam == activeTeam)

	mov	edx, DWORD PTR _eTeam$[ebp]
	cmp	edx, DWORD PTR _activeTeam$226080[ebp]
	jne	$LN4@changeInvi

; 9677 : 			{
; 9678 : 				// for all (nominally invisible) units in this plot
; 9679 : 				// tell the engine to flip whether they are being drawn or not
; 9680 : 				IDInfo* pUnitNode;
; 9681 : 				CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$226083[ebp], 0

; 9682 : 				pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$226082[ebp], eax
$LN3@changeInvi:

; 9683 : 				while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$226082[ebp], 0
	je	$LN2@changeInvi

; 9684 : 				{
; 9685 : 					pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$226082[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN19@changeInvi
	mov	ecx, DWORD PTR _pUnitNode$226082[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN19@changeInvi
	mov	edx, DWORD PTR _pUnitNode$226082[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv194[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$226082[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv194[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv194[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$226083[ebp], eax
	jmp	SHORT $LN20@changeInvi
$LN19@changeInvi:
	mov	DWORD PTR _pLoopUnit$226083[ebp], 0
$LN20@changeInvi:

; 9686 : 					pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$226082[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$226082[ebp], eax

; 9687 : 
; 9688 : 					if(NULL != pLoopUnit && pLoopUnit->getTeam() != activeTeam && pLoopUnit->getInvisibleType() == eInvisible)

	cmp	DWORD PTR _pLoopUnit$226083[ebp], 0
	je	$LN30@changeInvi
	mov	ecx, DWORD PTR _pLoopUnit$226083[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _activeTeam$226080[ebp]
	je	$LN30@changeInvi
	mov	ecx, DWORD PTR _pLoopUnit$226083[ebp]
	call	?getInvisibleType@CvUnit@@QBE?BW4InvisibleTypes@@XZ ; CvUnit::getInvisibleType
	cmp	eax, DWORD PTR _eInvisible$[ebp]
	jne	$LN30@changeInvi

; 9689 : 					{
; 9690 : 						auto_ptr<ICvUnit1> pDllUnit(new CvDllUnit(pLoopUnit));

	push	12					; 0000000cH
	call	??2CvDllUnit@@SAPAXI@Z			; CvDllUnit::operator new
	add	esp, 4
	mov	DWORD PTR $T254266[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T254266[ebp], 0
	je	SHORT $LN13@changeInvi
	mov	ecx, DWORD PTR _pLoopUnit$226083[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T254266[ebp]
	call	??0CvDllUnit@@QAE@PAVCvUnit@@@Z		; CvDllUnit::CvDllUnit
	mov	DWORD PTR tv158[ebp], eax
	jmp	SHORT $LN14@changeInvi
$LN13@changeInvi:
	mov	DWORD PTR tv158[ebp], 0
$LN14@changeInvi:
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR $T254265[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T254265[ebp]
	mov	DWORD PTR _pDllUnit$226093[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 9691 : 						gDLL->GameplayUnitVisibility(pDllUnit.get(), bNewInvisibleVisible, true);

	mov	ecx, DWORD PTR $T254290[ebp]
	mov	DWORD PTR tv168[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv168[ebp], edx
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	push	1
	movzx	eax, BYTE PTR _bNewInvisibleVisible$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDllUnit$226093[ebp]
	push	ecx
	mov	edx, DWORD PTR tv168[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv168[ebp]
	mov	edx, DWORD PTR [eax+640]
	call	edx

; 9692 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _pDllUnit$226093[ebp]
	mov	DWORD PTR $T254302[ebp], eax
	cmp	DWORD PTR $T254302[ebp], 0
	je	SHORT $LN32@changeInvi
	mov	ecx, DWORD PTR $T254302[ebp]
	mov	DWORD PTR _inst$254306[ebp], ecx
	mov	edx, DWORD PTR _inst$254306[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _inst$254306[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
$LN32@changeInvi:
$LN30@changeInvi:

; 9693 : 				}

	jmp	$LN3@changeInvi
$LN2@changeInvi:

; 9694 : 
; 9695 : 				updateCenterUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN4@changeInvi:
$LN11@changeInvi:

; 9696 : 
; 9697 : 			}
; 9698 : 		}
; 9699 : 	}
; 9700 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$0:
	mov	eax, DWORD PTR $T254266[ebp]
	push	eax
	call	??3CvDllUnit@@SAXPAX@Z			; CvDllUnit::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z$1:
	lea	ecx, DWORD PTR _pDllUnit$226093[ebp]
	jmp	??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ	; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
__ehhandler$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ENDP ; CvPlot::changeInvisibleVisibilityCount
PUBLIC	?getNumLayerUnits@CvPlot@@QBEHH@Z		; CvPlot::getNumLayerUnits
EXTRN	?GetNumUnits@CvPlotManager@@QBEHHHI@Z:PROC	; CvPlotManager::GetNumUnits
EXTRN	?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z:PROC ; CvPlotManager::GetNumUnitsByIndex
; Function compile flags: /Odtp
;	COMDAT ?getNumLayerUnits@CvPlot@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T254346 = -32						; size = 4
$T254339 = -28						; size = 4
$T254331 = -24						; size = 4
$T254322 = -20						; size = 4
_iIndex$226104 = -16					; size = 4
_iCount$226101 = -12					; size = 4
_kManager$226102 = -8					; size = 4
_iNumLayers$226103 = -4					; size = 4
_iLayerID$ = 8						; size = 4
?getNumLayerUnits@CvPlot@@QBEHH@Z PROC			; CvPlot::getNumLayerUnits, COMDAT
; _this$ = ecx

; 9704 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 9705 : 	if (iLayerID == DEFAULT_UNIT_MAP_LAYER)

	cmp	DWORD PTR _iLayerID$[ebp], 0
	jne	SHORT $LN7@getNumLaye

; 9706 : 		// Base layer
; 9707 : 		return m_units.getLength();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T254322[ebp], ecx
	mov	eax, DWORD PTR $T254322[ebp]
	jmp	$LN8@getNumLaye

; 9708 : 	else

	jmp	$LN8@getNumLaye
$LN7@getNumLaye:

; 9709 : 		if (iLayerID == -1)

	cmp	DWORD PTR _iLayerID$[ebp], -1
	jne	SHORT $LN5@getNumLaye

; 9710 : 		{
; 9711 : 			// All layers
; 9712 : 			int iCount = m_units.getLength();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T254331[ebp], eax
	mov	ecx, DWORD PTR $T254331[ebp]
	mov	DWORD PTR _iCount$226101[ebp], ecx

; 9713 : 			const CvPlotManager& kManager = GC.getMap().plotManager();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T254339[ebp], edx
	mov	eax, DWORD PTR $T254339[ebp]
	add	eax, 4184				; 00001058H
	mov	DWORD PTR _kManager$226102[ebp], eax

; 9714 : 			int iNumLayers = kManager.GetNumLayers();

	mov	ecx, DWORD PTR _kManager$226102[ebp]
	call	?GetNumLayers@CvPlotManager@@QBEHXZ	; CvPlotManager::GetNumLayers
	mov	DWORD PTR _iNumLayers$226103[ebp], eax

; 9715 : 			for (int iIndex = 0; iIndex < iNumLayers; ++iIndex)

	mov	DWORD PTR _iIndex$226104[ebp], 0
	jmp	SHORT $LN4@getNumLaye
$LN3@getNumLaye:
	mov	ecx, DWORD PTR _iIndex$226104[ebp]
	add	ecx, 1
	mov	DWORD PTR _iIndex$226104[ebp], ecx
$LN4@getNumLaye:
	mov	edx, DWORD PTR _iIndex$226104[ebp]
	cmp	edx, DWORD PTR _iNumLayers$226103[ebp]
	jge	SHORT $LN2@getNumLaye

; 9716 : 			{		
; 9717 : 				iCount += kManager.GetNumUnitsByIndex(m_iX, m_iY, iIndex);

	mov	eax, DWORD PTR _iIndex$226104[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _kManager$226102[ebp]
	call	?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z ; CvPlotManager::GetNumUnitsByIndex
	add	eax, DWORD PTR _iCount$226101[ebp]
	mov	DWORD PTR _iCount$226101[ebp], eax

; 9718 : 			}

	jmp	SHORT $LN3@getNumLaye
$LN2@getNumLaye:

; 9719 : 			return iCount;

	mov	eax, DWORD PTR _iCount$226101[ebp]
	jmp	SHORT $LN8@getNumLaye

; 9720 : 		}
; 9721 : 		else

	jmp	SHORT $LN8@getNumLaye
$LN5@getNumLaye:

; 9722 : 		{
; 9723 : 			// Specific layer
; 9724 : 			return GC.getMap().plotManager().GetNumUnits(m_iX, m_iY, iLayerID);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T254346[ebp], edx
	mov	eax, DWORD PTR _iLayerID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T254346[ebp]
	add	ecx, 4184				; 00001058H
	call	?GetNumUnits@CvPlotManager@@QBEHHHI@Z	; CvPlotManager::GetNumUnits
$LN8@getNumLaye:

; 9725 : 		}
; 9726 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumLayerUnits@CvPlot@@QBEHH@Z ENDP			; CvPlot::getNumLayerUnits
_TEXT	ENDS
PUBLIC	?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z	; CvPlot::getLayerUnit
EXTRN	?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z:PROC ; CvPlotManager::GetUnits
; Function compile flags: /Odtp
;	COMDAT ?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T254394 = -56						; size = 4
$T254390 = -52						; size = 4
$T254383 = -48						; size = 4
$T254379 = -44						; size = 4
$T254375 = -40						; size = 4
$T254371 = -36						; size = 4
$T254364 = -32						; size = 4
$T254356 = -28						; size = 4
_kUnits$226132 = -24					; size = 4
_kUnits$226127 = -20					; size = 4
_iLayerIndex$226123 = -16				; size = 4
_kManager$226121 = -12					; size = 4
_iNumLayers$226122 = -8					; size = 4
_iCount$226118 = -4					; size = 4
_iIndex$ = 8						; size = 4
_iLayerID$ = 12						; size = 4
?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z PROC		; CvPlot::getLayerUnit, COMDAT
; _this$ = ecx

; 9730 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 9731 : 	if (iIndex >= 0)

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	$LN13@getLayerUn

; 9732 : 	{
; 9733 : 		if (iLayerID == DEFAULT_UNIT_MAP_LAYER)

	cmp	DWORD PTR _iLayerID$[ebp], 0
	jne	SHORT $LN12@getLayerUn

; 9734 : 			// The base layer
; 9735 : 			return getUnitByIndex(iIndex);

	mov	eax, DWORD PTR _iIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	jmp	$LN14@getLayerUn

; 9736 : 		else

	jmp	$LN13@getLayerUn
$LN12@getLayerUn:

; 9737 : 		if (iLayerID == -1)

	cmp	DWORD PTR _iLayerID$[ebp], -1
	jne	$LN10@getLayerUn

; 9738 : 		{
; 9739 : 			// All layers
; 9740 : 			int iCount = m_units.getLength();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T254356[ebp], edx
	mov	eax, DWORD PTR $T254356[ebp]
	mov	DWORD PTR _iCount$226118[ebp], eax

; 9741 : 			if (iIndex < iCount)

	mov	ecx, DWORD PTR _iIndex$[ebp]
	cmp	ecx, DWORD PTR _iCount$226118[ebp]
	jge	SHORT $LN9@getLayerUn

; 9742 : 				return getUnitByIndex(iIndex);

	mov	edx, DWORD PTR _iIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	jmp	$LN14@getLayerUn

; 9743 : 			else

	jmp	$LN8@getLayerUn
$LN9@getLayerUn:

; 9744 : 			{
; 9745 : 				const CvPlotManager& kManager = GC.getMap().plotManager();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T254364[ebp], eax
	mov	ecx, DWORD PTR $T254364[ebp]
	add	ecx, 4184				; 00001058H
	mov	DWORD PTR _kManager$226121[ebp], ecx

; 9746 : 				int iNumLayers = kManager.GetNumLayers();

	mov	ecx, DWORD PTR _kManager$226121[ebp]
	call	?GetNumLayers@CvPlotManager@@QBEHXZ	; CvPlotManager::GetNumLayers
	mov	DWORD PTR _iNumLayers$226122[ebp], eax

; 9747 : 				for (int iLayerIndex = 0; iLayerIndex < iNumLayers; ++iLayerIndex)

	mov	DWORD PTR _iLayerIndex$226123[ebp], 0
	jmp	SHORT $LN7@getLayerUn
$LN6@getLayerUn:
	mov	edx, DWORD PTR _iLayerIndex$226123[ebp]
	add	edx, 1
	mov	DWORD PTR _iLayerIndex$226123[ebp], edx
$LN7@getLayerUn:
	mov	eax, DWORD PTR _iLayerIndex$226123[ebp]
	cmp	eax, DWORD PTR _iNumLayers$226122[ebp]
	jge	SHORT $LN8@getLayerUn

; 9748 : 				{		
; 9749 : 					const CvIDInfoFixedVector& kUnits = kManager.GetUnitsByIndex(m_iX, m_iY, iLayerIndex);

	mov	ecx, DWORD PTR _iLayerIndex$226123[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _kManager$226121[ebp]
	call	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ; CvPlotManager::GetUnitsByIndex
	mov	DWORD PTR _kUnits$226127[ebp], eax

; 9750 : 					if (iIndex < (iCount + (int)kUnits.size()))

	mov	eax, DWORD PTR _kUnits$226127[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T254371[ebp], ecx
	mov	edx, DWORD PTR _iCount$226118[ebp]
	add	edx, DWORD PTR $T254371[ebp]
	cmp	DWORD PTR _iIndex$[ebp], edx
	jge	SHORT $LN4@getLayerUn

; 9751 : 						return ::getUnit( kUnits[iIndex - iCount] );

	mov	eax, DWORD PTR _iIndex$[ebp]
	sub	eax, DWORD PTR _iCount$226118[ebp]
	mov	ecx, DWORD PTR _kUnits$226127[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T254375[ebp], eax
	mov	ecx, DWORD PTR $T254375[ebp]
	push	ecx
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4
	jmp	SHORT $LN14@getLayerUn

; 9752 : 					else

	jmp	SHORT $LN3@getLayerUn
$LN4@getLayerUn:

; 9753 : 						iCount += kUnits.size();

	mov	edx, DWORD PTR _kUnits$226127[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T254379[ebp], eax
	mov	ecx, DWORD PTR _iCount$226118[ebp]
	add	ecx, DWORD PTR $T254379[ebp]
	mov	DWORD PTR _iCount$226118[ebp], ecx
$LN3@getLayerUn:

; 9754 : 				}				

	jmp	SHORT $LN6@getLayerUn
$LN8@getLayerUn:

; 9755 : 			}
; 9756 : 		}
; 9757 : 		else

	jmp	SHORT $LN13@getLayerUn
$LN10@getLayerUn:

; 9758 : 		{
; 9759 : 			// Specific layer
; 9760 : 			const CvIDInfoFixedVector& kUnits = GC.getMap().plotManager().GetUnits(m_iX, m_iY, iLayerID);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T254383[ebp], edx
	mov	eax, DWORD PTR _iLayerID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T254383[ebp]
	add	ecx, 4184				; 00001058H
	call	?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z ; CvPlotManager::GetUnits
	mov	DWORD PTR _kUnits$226132[ebp], eax

; 9761 : 			if (iIndex < (int)kUnits.size())

	mov	edx, DWORD PTR _kUnits$226132[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T254390[ebp], eax
	mov	ecx, DWORD PTR _iIndex$[ebp]
	cmp	ecx, DWORD PTR $T254390[ebp]
	jge	SHORT $LN13@getLayerUn

; 9762 : 				return ::getUnit( kUnits[iIndex] );

	mov	edx, DWORD PTR _kUnits$226132[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T254394[ebp], edx
	mov	eax, DWORD PTR $T254394[ebp]
	push	eax
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4
	jmp	SHORT $LN14@getLayerUn
$LN13@getLayerUn:

; 9763 : 		}
; 9764 : 	}
; 9765 : 
; 9766 : 	return NULL;

	xor	eax, eax
$LN14@getLayerUn:

; 9767 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z ENDP		; CvPlot::getLayerUnit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getNumUnits@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T254401 = -4						; size = 4
?getNumUnits@CvPlot@@QBEHXZ PROC			; CvPlot::getNumUnits, COMDAT
; _this$ = ecx

; 9775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 9776 : 	return m_units.getLength();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T254401[ebp], ecx
	mov	eax, DWORD PTR $T254401[ebp]

; 9777 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumUnits@CvPlot@@QBEHXZ ENDP			; CvPlot::getNumUnits
_TEXT	ENDS
PUBLIC	?GetNumCombatUnits@CvPlot@@QAEHXZ		; CvPlot::GetNumCombatUnits
; Function compile flags: /Odtp
;	COMDAT ?GetNumCombatUnits@CvPlot@@QAEHXZ
_TEXT	SEGMENT
tv92 = -20						; size = 4
_this$ = -16						; size = 4
_iCount$ = -12						; size = 4
_pUnitNode$ = -8					; size = 4
_pLoopUnit$ = -4					; size = 4
?GetNumCombatUnits@CvPlot@@QAEHXZ PROC			; CvPlot::GetNumCombatUnits, COMDAT
; _this$ = ecx

; 9789 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 9790 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 9791 : 
; 9792 : 	IDInfo* pUnitNode;
; 9793 : 	CvUnit* pLoopUnit;
; 9794 : #endif
; 9795 : 
; 9796 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN3@GetNumComb:

; 9797 : 
; 9798 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN2@GetNumComb

; 9799 : 	{
; 9800 : 		pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN6@GetNumComb
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN6@GetNumComb
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN7@GetNumComb
$LN6@GetNumComb:
	mov	DWORD PTR _pLoopUnit$[ebp], 0
$LN7@GetNumComb:

; 9801 : 
; 9802 : 		if(pLoopUnit && pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN1@GetNumComb
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@GetNumComb

; 9803 : 		{
; 9804 : 			iCount++;

	mov	eax, DWORD PTR _iCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCount$[ebp], eax
$LN1@GetNumComb:

; 9805 : 		}
; 9806 : 
; 9807 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 9808 : 	}

	jmp	$LN3@GetNumComb
$LN2@GetNumComb:

; 9809 : 
; 9810 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 9811 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCombatUnits@CvPlot@@QAEHXZ ENDP			; CvPlot::GetNumCombatUnits
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
_TEXT	ENDS
;	COMDAT ?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z
_TEXT	SEGMENT
tv130 = -28						; size = 4
_this$ = -24						; size = 4
$T254468 = -20						; size = 4
$T254458 = -16						; size = 4
$T254447 = -12						; size = 4
$T254435 = -8						; size = 4
_pUnitNode$ = -4					; size = 4
_iIndex$ = 8						; size = 4
?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z PROC		; CvPlot::getUnitByIndex, COMDAT
; _this$ = ecx

; 9820 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 9821 : 	const IDInfo* pUnitNode;
; 9822 : 
; 9823 : 	pUnitNode = m_units.nodeNum(iIndex);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254458[ebp], eax
	mov	ecx, DWORD PTR $T254458[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254435[ebp], edx
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR $T254435[ebp]
	jae	SHORT $LN8@getUnitByI
	mov	ecx, DWORD PTR $T254458[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _iIndex$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T254447[ebp], ecx
	jmp	SHORT $LN5@getUnitByI
	jmp	SHORT $LN5@getUnitByI
$LN8@getUnitByI:
	mov	DWORD PTR $T254447[ebp], 0
$LN5@getUnitByI:
	mov	edx, DWORD PTR $T254447[ebp]
	mov	DWORD PTR _pUnitNode$[ebp], edx

; 9824 : 
; 9825 : 	if(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	SHORT $LN2@getUnitByI

; 9826 : 	{
; 9827 : 		return (CvUnit*)GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN15@getUnitByI
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN15@getUnitByI
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv130[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv130[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv130[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR $T254468[ebp], eax
	jmp	SHORT $LN16@getUnitByI
$LN15@getUnitByI:
	mov	DWORD PTR $T254468[ebp], 0
$LN16@getUnitByI:
	mov	eax, DWORD PTR $T254468[ebp]
	jmp	SHORT $LN3@getUnitByI

; 9828 : 	}
; 9829 : 	else

	jmp	SHORT $LN3@getUnitByI
$LN2@getUnitByI:

; 9830 : 	{
; 9831 : 		return NULL;

	xor	eax, eax
$LN3@getUnitByI:

; 9832 : 	}
; 9833 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ENDP		; CvPlot::getUnitByIndex
_TEXT	ENDS
PUBLIC	?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z		; CvPlot::getUnitIndex
EXTRN	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ:PROC	; CvUnit::GetIDInfo
; Function compile flags: /Odtp
;	COMDAT ?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z
_TEXT	SEGMENT
tv83 = -24						; size = 4
_this$ = -20						; size = 4
_pUnitNode$226164 = -16					; size = 4
_kUnitInfo$226162 = -12					; size = 8
_iIndex$ = -4						; size = 4
_pUnit$ = 8						; size = 4
?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z PROC		; CvPlot::getUnitIndex, COMDAT
; _this$ = ecx

; 9838 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 9839 : 	int iIndex = 0;

	mov	DWORD PTR _iIndex$[ebp], 0

; 9840 : 	if(pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN4@getUnitInd

; 9841 : 	{
; 9842 : 		IDInfo kUnitInfo = pUnit->GetIDInfo();

	lea	eax, DWORD PTR _kUnitInfo$226162[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo

; 9843 : 
; 9844 : 		const IDInfo* pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$226164[ebp], eax
$LN3@getUnitInd:

; 9845 : 
; 9846 : 		while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$226164[ebp], 0
	je	SHORT $LN4@getUnitInd

; 9847 : 		{
; 9848 : 			if(*pUnitNode == kUnitInfo)

	mov	ecx, DWORD PTR _pUnitNode$226164[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _kUnitInfo$226162[ebp]
	jne	SHORT $LN9@getUnitInd
	mov	eax, DWORD PTR _pUnitNode$226164[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _kUnitInfo$226162[ebp+4]
	jne	SHORT $LN9@getUnitInd
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN7@getUnitInd
$LN9@getUnitInd:
	mov	DWORD PTR tv83[ebp], 0
$LN7@getUnitInd:
	movzx	edx, BYTE PTR tv83[ebp]
	test	edx, edx
	je	SHORT $LN1@getUnitInd

; 9849 : 				return iIndex;

	mov	eax, DWORD PTR _iIndex$[ebp]
	jmp	SHORT $LN5@getUnitInd
$LN1@getUnitInd:

; 9850 : 
; 9851 : 			++iIndex;

	mov	eax, DWORD PTR _iIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _iIndex$[ebp], eax

; 9852 : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$226164[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$226164[ebp], eax

; 9853 : 		}

	jmp	SHORT $LN3@getUnitInd
$LN4@getUnitInd:

; 9854 : 	}
; 9855 : 	return -1;

	or	eax, -1
$LN5@getUnitInd:

; 9856 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z ENDP		; CvPlot::getUnitIndex
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back
PUBLIC	?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z		; CvPlot::addUnit
EXTRN	?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z:PROC	; isBeforeUnitCycle
; Function compile flags: /Odtp
;	COMDAT ?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z
_TEXT	SEGMENT
tv139 = -96						; size = 4
_this$ = -92						; size = 4
$T254532 = -48						; size = 4
$T254504 = -44						; size = 4
$T254500 = -40						; size = 4
_iIdx$254528 = -36					; size = 4
_iIndex$254527 = -32					; size = 4
_uSize$254526 = -28					; size = 4
_unitIDInfo$226185 = -24				; size = 8
_unitIDInfo$226182 = -16				; size = 8
_pLoopUnit$226179 = -8					; size = 4
_pUnitNode$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_bUpdate$ = 12						; size = 1
?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z PROC		; CvPlot::addUnit, COMDAT
; _this$ = ecx

; 9860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 9861 : 	CvAssertMsg(pUnit, "pUnit is expected to be non-NULL");
; 9862 : 	if(pUnit == NULL)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN7@addUnit

; 9863 : 		return;

	jmp	$LN8@addUnit
$LN7@addUnit:

; 9864 : 
; 9865 : 	CvAssertMsg(pUnit->at(getX(), getY()), "pUnit is expected to be at getX_INLINE and getY_INLINE");
; 9866 : 
; 9867 : 	IDInfo* pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN6@addUnit:

; 9868 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	SHORT $LN5@addUnit

; 9869 : 	{
; 9870 : 		CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN10@addUnit
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN10@addUnit
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv139[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv139[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv139[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$226179[ebp], eax
	jmp	SHORT $LN11@addUnit
$LN10@addUnit:
	mov	DWORD PTR _pLoopUnit$226179[ebp], 0
$LN11@addUnit:

; 9871 : 		if(!isBeforeUnitCycle(pLoopUnit, pUnit))

	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopUnit$226179[ebp]
	push	ecx
	call	?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z	; isBeforeUnitCycle
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@addUnit

; 9872 : 		{
; 9873 : 			break;

	jmp	SHORT $LN5@addUnit
$LN4@addUnit:

; 9874 : 		}
; 9875 : 
; 9876 : 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 9877 : 	}

	jmp	SHORT $LN6@addUnit
$LN5@addUnit:

; 9878 : 
; 9879 : 	if(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN3@addUnit

; 9880 : 	{
; 9881 : 		IDInfo unitIDInfo = pUnit->GetIDInfo();

	lea	ecx, DWORD PTR _unitIDInfo$226182[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo

; 9882 : 		m_units.insertBefore(&unitIDInfo, pUnitNode);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T254532[ebp], edx
	mov	eax, DWORD PTR $T254532[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _uSize$254526[ebp], ecx
	xor	edx, edx
	shl	edx, 3
	mov	eax, DWORD PTR $T254532[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _iIndex$254527[ebp], edx
	mov	eax, DWORD PTR _uSize$254526[ebp]
	add	eax, 1
	mov	DWORD PTR $T254500[ebp], eax
	mov	ecx, DWORD PTR $T254532[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR $T254500[ebp]
	jae	SHORT $LN24@addUnit
	mov	eax, DWORD PTR $T254500[ebp]
	push	eax
	mov	ecx, DWORD PTR $T254532[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN24@addUnit:
	mov	ecx, DWORD PTR $T254532[ebp]
	mov	edx, DWORD PTR $T254500[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _uSize$254526[ebp]
	mov	DWORD PTR _iIdx$254528[ebp], eax
	jmp	SHORT $LN17@addUnit
$LN16@addUnit:
	mov	ecx, DWORD PTR _iIdx$254528[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iIdx$254528[ebp], ecx
$LN17@addUnit:
	mov	edx, DWORD PTR _iIdx$254528[ebp]
	cmp	edx, DWORD PTR _iIndex$254527[ebp]
	jle	SHORT $LN31@addUnit
	mov	eax, DWORD PTR $T254532[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _iIdx$254528[ebp]
	lea	eax, DWORD PTR [ecx+edx*8-8]
	mov	DWORD PTR $T254504[ebp], eax
	mov	ecx, DWORD PTR $T254504[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T254532[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _iIdx$254528[ebp]
	mov	DWORD PTR [ecx+esi*8], edx
	mov	DWORD PTR [ecx+esi*8+4], eax
	jmp	SHORT $LN16@addUnit
$LN31@addUnit:
	mov	edx, DWORD PTR _unitIDInfo$226182[ebp]
	mov	eax, DWORD PTR _unitIDInfo$226182[ebp+4]
	mov	ecx, DWORD PTR $T254532[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, DWORD PTR _iIndex$254527[ebp]
	mov	DWORD PTR [ecx+esi*8], edx
	mov	DWORD PTR [ecx+esi*8+4], eax

; 9883 : 	}
; 9884 : 	else

	jmp	SHORT $LN2@addUnit
$LN3@addUnit:

; 9885 : 	{
; 9886 : 		IDInfo unitIDInfo = pUnit->GetIDInfo();

	lea	edx, DWORD PTR _unitIDInfo$226185[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo

; 9887 : 		m_units.insertAtEnd(&unitIDInfo);

	lea	eax, DWORD PTR _unitIDInfo$226185[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back
$LN2@addUnit:

; 9888 : 	}
; 9889 : 
; 9890 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 9891 : 	if (pUnit->getTeam() != getTeam() && getWorkingCity())
; 9892 : 		getWorkingCity()->GetCityCitizens()->DoSelfConsistencyCheck();
; 9893 : #endif
; 9894 : 
; 9895 : 	if(bUpdate)

	movzx	ecx, BYTE PTR _bUpdate$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@addUnit

; 9896 : 	{
; 9897 : 		updateCenterUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN8@addUnit:

; 9898 : 	}
; 9899 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z ENDP		; CvPlot::addUnit
_TEXT	ENDS
PUBLIC	?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z		; CvPlot::removeUnit
EXTRN	?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z:PROC ; CvPlotManager::RemoveUnit
; Function compile flags: /Odtp
;	COMDAT ?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z
_TEXT	SEGMENT
tv140 = -60						; size = 4
_this$ = -56						; size = 4
$T254653 = -52						; size = 4
$T254649 = -48						; size = 4
$T254619 = -44						; size = 4
$T254615 = -40						; size = 4
$T254610 = -36						; size = 4
$T254603 = -32						; size = 4
$T254599 = -28						; size = 4
_uIdx$254643 = -24					; size = 4
_uDeletePos$254642 = -20				; size = 4
$T254591 = -16						; size = 4
$T254581 = -12						; size = 8
_pUnitNode$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_bUpdate$ = 12						; size = 1
?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z PROC		; CvPlot::removeUnit, COMDAT
; _this$ = ecx

; 9904 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 9905 : 	IDInfo* pUnitNode;
; 9906 : 
; 9907 : 	pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN5@removeUnit:

; 9908 : 
; 9909 : 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN4@removeUnit

; 9910 : 	{
; 9911 : 		if(GetPlayerUnit(*pUnitNode) == pUnit)

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN8@removeUnit
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN8@removeUnit
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv140[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR $T254591[ebp], eax
	jmp	SHORT $LN9@removeUnit
$LN8@removeUnit:
	mov	DWORD PTR $T254591[ebp], 0
$LN9@removeUnit:
	mov	eax, DWORD PTR $T254591[ebp]
	cmp	eax, DWORD PTR _pUnit$[ebp]
	jne	$LN3@removeUnit

; 9912 : 		{
; 9913 : 			CvAssertMsg(GetPlayerUnit(*pUnitNode)->at(getX(), getY()), "The current unit instance is expected to be at getX_INLINE and getY_INLINE");
; 9914 : 			m_units.deleteNode(pUnitNode);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T254649[ebp], ecx
	xor	edx, edx
	shl	edx, 3
	mov	eax, DWORD PTR $T254649[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, edx
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	sub	edx, ecx
	sar	edx, 3
	mov	DWORD PTR _uDeletePos$254642[ebp], edx
	mov	eax, DWORD PTR _uDeletePos$254642[ebp]
	mov	DWORD PTR _uIdx$254643[ebp], eax
	jmp	SHORT $LN17@removeUnit
$LN16@removeUnit:
	mov	ecx, DWORD PTR _uIdx$254643[ebp]
	add	ecx, 1
	mov	DWORD PTR _uIdx$254643[ebp], ecx
$LN17@removeUnit:
	mov	edx, DWORD PTR $T254649[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T254599[ebp], eax
	mov	ecx, DWORD PTR _uIdx$254643[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR $T254599[ebp]
	jae	SHORT $LN15@removeUnit
	mov	edx, DWORD PTR $T254649[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _uIdx$254643[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+8]
	mov	DWORD PTR $T254603[ebp], edx
	mov	eax, DWORD PTR $T254603[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T254649[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR _uIdx$254643[ebp]
	mov	DWORD PTR [eax+esi*8], ecx
	mov	DWORD PTR [eax+esi*8+4], edx
	jmp	SHORT $LN16@removeUnit
$LN15@removeUnit:
	mov	ecx, DWORD PTR $T254649[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254610[ebp], edx
	mov	eax, DWORD PTR $T254610[ebp]
	sub	eax, 1
	mov	DWORD PTR $T254615[ebp], eax
	mov	ecx, DWORD PTR $T254649[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR $T254615[ebp]
	jae	SHORT $LN30@removeUnit
	mov	eax, DWORD PTR $T254615[ebp]
	push	eax
	mov	ecx, DWORD PTR $T254649[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN30@removeUnit:
	mov	ecx, DWORD PTR $T254649[ebp]
	mov	edx, DWORD PTR $T254615[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR $T254649[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T254619[ebp], ecx

; 9915 : #ifdef AUI_CITIZENS_MID_TURN_ASSIGN_RUNS_SELF_CONSISTENCY
; 9916 : 			if (pUnit->getTeam() != getTeam() && getWorkingCity())
; 9917 : 				getWorkingCity()->GetCityCitizens()->DoSelfConsistencyCheck();
; 9918 : #endif
; 9919 : 			break;

	jmp	SHORT $LN4@removeUnit

; 9920 : 		}
; 9921 : 		else

	jmp	SHORT $LN2@removeUnit
$LN3@removeUnit:

; 9922 : 		{
; 9923 : 			pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN2@removeUnit:

; 9924 : 		}
; 9925 : 	}

	jmp	$LN5@removeUnit
$LN4@removeUnit:

; 9926 : 
; 9927 : #ifdef AUI_WARNING_FIXES
; 9928 : 	GC.getMap().plotManager().RemoveUnit(pUnit->GetIDInfo(), m_iX, m_iY, MAX_UNSIGNED_INT);
; 9929 : #else
; 9930 : 	GC.getMap().plotManager().RemoveUnit(pUnit->GetIDInfo(), m_iX, m_iY, -1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T254653[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR $T254581[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetIDInfo@CvUnit@@QBE?AUIDInfo@@XZ	; CvUnit::GetIDInfo
	push	eax
	mov	ecx, DWORD PTR $T254653[ebp]
	add	ecx, 4184				; 00001058H
	call	?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z ; CvPlotManager::RemoveUnit

; 9931 : #endif
; 9932 : 
; 9933 : 	if(bUpdate)

	movzx	ecx, BYTE PTR _bUpdate$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@removeUnit

; 9934 : 	{
; 9935 : 		updateCenterUnit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
$LN6@removeUnit:

; 9936 : 	}
; 9937 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?removeUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z ENDP		; CvPlot::removeUnit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T254693 = -16						; size = 4
$T254679 = -12						; size = 4
$T254667 = -8						; size = 4
_iIndex$254692 = -4					; size = 4
_pNode$ = 8						; size = 4
?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z PROC	; CvPlot::nextUnitNode, COMDAT
; _this$ = ecx

; 9941 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 9942 : 	return m_units.next(pNode);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254693[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	add	ecx, 8
	xor	edx, edx
	shl	edx, 3
	mov	eax, DWORD PTR $T254693[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	sub	ecx, eax
	sar	ecx, 3
	mov	DWORD PTR _iIndex$254692[ebp], ecx
	mov	ecx, DWORD PTR $T254693[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254667[ebp], edx
	mov	eax, DWORD PTR _iIndex$254692[ebp]
	cmp	eax, DWORD PTR $T254667[ebp]
	jae	SHORT $LN8@nextUnitNo
	mov	ecx, DWORD PTR $T254693[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _iIndex$254692[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T254679[ebp], ecx
	jmp	SHORT $LN3@nextUnitNo
	jmp	SHORT $LN3@nextUnitNo
$LN8@nextUnitNo:
	mov	DWORD PTR $T254679[ebp], 0
$LN3@nextUnitNo:
	mov	eax, DWORD PTR $T254679[ebp]

; 9943 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ENDP	; CvPlot::nextUnitNode
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T254730 = -16						; size = 4
$T254716 = -12						; size = 4
$T254704 = -8						; size = 4
_iIndex$254729 = -4					; size = 4
_pNode$ = 8						; size = 4
?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z PROC	; CvPlot::nextUnitNode, COMDAT
; _this$ = ecx

; 9947 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 9948 : 	return m_units.next(pNode);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254730[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	add	ecx, 8
	xor	edx, edx
	shl	edx, 3
	mov	eax, DWORD PTR $T254730[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	sub	ecx, eax
	sar	ecx, 3
	mov	DWORD PTR _iIndex$254729[ebp], ecx
	mov	ecx, DWORD PTR $T254730[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254704[ebp], edx
	mov	eax, DWORD PTR _iIndex$254729[ebp]
	cmp	eax, DWORD PTR $T254704[ebp]
	jae	SHORT $LN8@nextUnitNo@2
	mov	ecx, DWORD PTR $T254730[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _iIndex$254729[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T254716[ebp], ecx
	jmp	SHORT $LN3@nextUnitNo@2
	jmp	SHORT $LN3@nextUnitNo@2
$LN8@nextUnitNo@2:
	mov	DWORD PTR $T254716[ebp], 0
$LN3@nextUnitNo@2:
	mov	eax, DWORD PTR $T254716[ebp]

; 9949 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ENDP	; CvPlot::nextUnitNode
_TEXT	ENDS
PUBLIC	?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z	; CvPlot::prevUnitNode
; Function compile flags: /Odtp
;	COMDAT ?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T254767 = -16						; size = 4
$T254753 = -12						; size = 4
$T254741 = -8						; size = 4
_iIndex$254766 = -4					; size = 4
_pNode$ = 8						; size = 4
?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z PROC	; CvPlot::prevUnitNode, COMDAT
; _this$ = ecx

; 9953 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 9954 : 	return m_units.prev(pNode);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254767[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	sub	ecx, 8
	xor	edx, edx
	shl	edx, 3
	mov	eax, DWORD PTR $T254767[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	sub	ecx, eax
	sar	ecx, 3
	mov	DWORD PTR _iIndex$254766[ebp], ecx
	mov	ecx, DWORD PTR $T254767[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254741[ebp], edx
	mov	eax, DWORD PTR _iIndex$254766[ebp]
	cmp	eax, DWORD PTR $T254741[ebp]
	jae	SHORT $LN8@prevUnitNo
	mov	ecx, DWORD PTR $T254767[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _iIndex$254766[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T254753[ebp], ecx
	jmp	SHORT $LN3@prevUnitNo
	jmp	SHORT $LN3@prevUnitNo
$LN8@prevUnitNo:
	mov	DWORD PTR $T254753[ebp], 0
$LN3@prevUnitNo:
	mov	eax, DWORD PTR $T254753[ebp]

; 9955 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?prevUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ENDP	; CvPlot::prevUnitNode
_TEXT	ENDS
PUBLIC	?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z	; CvPlot::prevUnitNode
; Function compile flags: /Odtp
;	COMDAT ?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T254804 = -16						; size = 4
$T254790 = -12						; size = 4
$T254778 = -8						; size = 4
_iIndex$254792 = -4					; size = 4
_pNode$ = 8						; size = 4
?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z PROC	; CvPlot::prevUnitNode, COMDAT
; _this$ = ecx

; 9959 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 9960 : 	return m_units.prev(pNode);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254804[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	sub	ecx, 8
	xor	edx, edx
	shl	edx, 3
	mov	eax, DWORD PTR $T254804[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	sub	ecx, eax
	sar	ecx, 3
	mov	DWORD PTR _iIndex$254792[ebp], ecx
	mov	ecx, DWORD PTR $T254804[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T254778[ebp], edx
	mov	eax, DWORD PTR _iIndex$254792[ebp]
	cmp	eax, DWORD PTR $T254778[ebp]
	jae	SHORT $LN8@prevUnitNo@2
	mov	ecx, DWORD PTR $T254804[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _iIndex$254792[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T254790[ebp], ecx
	jmp	SHORT $LN3@prevUnitNo@2
	jmp	SHORT $LN3@prevUnitNo@2
$LN8@prevUnitNo@2:
	mov	DWORD PTR $T254790[ebp], 0
$LN3@prevUnitNo@2:
	mov	eax, DWORD PTR $T254790[ebp]

; 9961 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?prevUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ENDP	; CvPlot::prevUnitNode
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T254824 = -12						; size = 4
$T254823 = -8						; size = 4
_uSize$254815 = -4					; size = 4
?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ PROC		; CvPlot::headUnitNode, COMDAT
; _this$ = ecx

; 9965 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 9966 : 	return m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254823[ebp], eax
	mov	ecx, DWORD PTR $T254823[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$254815[ebp], edx
	cmp	DWORD PTR _uSize$254815[ebp], 0
	jbe	SHORT $LN4@headUnitNo
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T254823[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T254824[ebp], eax
	jmp	SHORT $LN5@headUnitNo
	jmp	SHORT $LN5@headUnitNo
$LN4@headUnitNo:
	mov	DWORD PTR $T254824[ebp], 0
$LN5@headUnitNo:
	mov	eax, DWORD PTR $T254824[ebp]

; 9967 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ ENDP		; CvPlot::headUnitNode
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T254844 = -12						; size = 4
$T254843 = -8						; size = 4
_uSize$254835 = -4					; size = 4
?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ PROC		; CvPlot::headUnitNode, COMDAT
; _this$ = ecx

; 9971 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 9972 : 	return m_units.head();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254843[ebp], eax
	mov	ecx, DWORD PTR $T254843[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$254835[ebp], edx
	cmp	DWORD PTR _uSize$254835[ebp], 0
	jbe	SHORT $LN4@headUnitNo@2
	xor	eax, eax
	shl	eax, 3
	mov	ecx, DWORD PTR $T254843[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T254844[ebp], eax
	jmp	SHORT $LN5@headUnitNo@2
	jmp	SHORT $LN5@headUnitNo@2
$LN4@headUnitNo@2:
	mov	DWORD PTR $T254844[ebp], 0
$LN5@headUnitNo@2:
	mov	eax, DWORD PTR $T254844[ebp]

; 9973 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ ENDP		; CvPlot::headUnitNode
_TEXT	ENDS
PUBLIC	?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ		; CvPlot::tailUnitNode
; Function compile flags: /Odtp
;	COMDAT ?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T254864 = -12						; size = 4
$T254863 = -8						; size = 4
_uSize$254855 = -4					; size = 4
?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ PROC		; CvPlot::tailUnitNode, COMDAT
; _this$ = ecx

; 9977 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 9978 : 	return m_units.tail();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254863[ebp], eax
	mov	ecx, DWORD PTR $T254863[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$254855[ebp], edx
	cmp	DWORD PTR _uSize$254855[ebp], 0
	jbe	SHORT $LN4@tailUnitNo
	mov	eax, DWORD PTR $T254863[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _uSize$254855[ebp]
	lea	eax, DWORD PTR [ecx+edx*8-8]
	mov	DWORD PTR $T254864[ebp], eax
	jmp	SHORT $LN5@tailUnitNo
	jmp	SHORT $LN5@tailUnitNo
$LN4@tailUnitNo:
	mov	DWORD PTR $T254864[ebp], 0
$LN5@tailUnitNo:
	mov	eax, DWORD PTR $T254864[ebp]

; 9979 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?tailUnitNode@CvPlot@@QBEPBUIDInfo@@XZ ENDP		; CvPlot::tailUnitNode
_TEXT	ENDS
PUBLIC	?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ		; CvPlot::tailUnitNode
; Function compile flags: /Odtp
;	COMDAT ?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T254884 = -12						; size = 4
$T254883 = -8						; size = 4
_uSize$254875 = -4					; size = 4
?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ PROC		; CvPlot::tailUnitNode, COMDAT
; _this$ = ecx

; 9983 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 9984 : 	return m_units.tail();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T254883[ebp], eax
	mov	ecx, DWORD PTR $T254883[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _uSize$254875[ebp], edx
	cmp	DWORD PTR _uSize$254875[ebp], 0
	jbe	SHORT $LN4@tailUnitNo@2
	mov	eax, DWORD PTR $T254883[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _uSize$254875[ebp]
	lea	eax, DWORD PTR [ecx+edx*8-8]
	mov	DWORD PTR $T254884[ebp], eax
	jmp	SHORT $LN5@tailUnitNo@2
	jmp	SHORT $LN5@tailUnitNo@2
$LN4@tailUnitNo@2:
	mov	DWORD PTR $T254884[ebp], 0
$LN5@tailUnitNo@2:
	mov	eax, DWORD PTR $T254884[ebp]

; 9985 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?tailUnitNode@CvPlot@@QAEPAUIDInfo@@XZ ENDP		; CvPlot::tailUnitNode
_TEXT	ENDS
PUBLIC	?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::push_back
PUBLIC	?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z ; CvPlot::getUnits
; Function compile flags: /Odtp
;	COMDAT ?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_i$254900 = -12						; size = 4
_pUnitNode$226301 = -8					; size = 4
_uiCount$ = -4						; size = 4
_pkInfoVector$ = 8					; size = 4
?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z PROC ; CvPlot::getUnits, COMDAT
; _this$ = ecx

; 9989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 9990 : 	uint uiCount = 0;

	mov	DWORD PTR _uiCount$[ebp], 0

; 9991 : 	if (pkInfoVector)

	cmp	DWORD PTR _pkInfoVector$[ebp], 0
	je	SHORT $LN3@getUnits

; 9992 : 	{
; 9993 : 		pkInfoVector->clear();

	xor	eax, eax
	je	SHORT $LN12@getUnits
	mov	DWORD PTR _i$254900[ebp], 0
	jmp	SHORT $LN10@getUnits
$LN9@getUnits:
	mov	ecx, DWORD PTR _i$254900[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$254900[ebp], ecx
$LN10@getUnits:
	mov	edx, DWORD PTR _pkInfoVector$[ebp]
	mov	eax, DWORD PTR _i$254900[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN12@getUnits
	jmp	SHORT $LN9@getUnits
$LN12@getUnits:
	mov	ecx, DWORD PTR _pkInfoVector$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 9994 : 	
; 9995 : 		const IDInfo* pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$226301[ebp], eax
$LN2@getUnits:

; 9996 : 
; 9997 : 		while (pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$226301[ebp], 0
	je	SHORT $LN3@getUnits

; 9998 : 		{
; 9999 : 			pkInfoVector->push_back(*pUnitNode);

	mov	edx, DWORD PTR _pUnitNode$226301[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkInfoVector$[ebp]
	call	?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::push_back

; 10000: 			pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$226301[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$226301[ebp], eax

; 10001: 			++uiCount;

	mov	ecx, DWORD PTR _uiCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiCount$[ebp], ecx

; 10002: 		}

	jmp	SHORT $LN2@getUnits
$LN3@getUnits:

; 10003: 	}
; 10004: 	return uiCount;

	mov	eax, DWORD PTR _uiCount$[ebp]

; 10005: }

	mov	esp, ebp
	pop	ebp
	ret	4
?getUnits@CvPlot@@QBEIPAV?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@@Z ENDP ; CvPlot::getUnits
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?getScriptData@CvPlot@@QBE?AVCvString@@XZ	; CvPlot::getScriptData
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?getScriptData@CvPlot@@QBE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getScriptData@CvPlot@@QBE?AVCvString@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?getScriptData@CvPlot@@QBE?AVCvString@@XZ$0
__ehfuncinfo$?getScriptData@CvPlot@@QBE?AVCvString@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getScriptData@CvPlot@@QBE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?getScriptData@CvPlot@@QBE?AVCvString@@XZ
_TEXT	SEGMENT
tv89 = -60						; size = 4
_this$ = -56						; size = 4
$T254973 = -52						; size = 4
$T254963 = -48						; size = 4
_scriptData$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getScriptData@CvPlot@@QBE?AVCvString@@XZ PROC		; CvPlot::getScriptData, COMDAT
; _this$ = ecx

; 10009: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getScriptData@CvPlot@@QBE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T254963[ebp], 0

; 10010: 	CvString scriptData = (m_szScriptData != NULL)? m_szScriptData : "";

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+180], 0
	je	SHORT $LN3@getScriptD
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR $T254973[ebp], edx
	jmp	SHORT $LN4@getScriptD
$LN3@getScriptD:
	mov	DWORD PTR $T254973[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@getScriptD:
	cmp	DWORD PTR $T254973[ebp], 0
	je	SHORT $LN10@getScriptD
	mov	eax, DWORD PTR $T254973[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN11@getScriptD
$LN10@getScriptD:
	mov	DWORD PTR tv89[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN11@getScriptD:
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	lea	ecx, DWORD PTR _scriptData$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 10011: 	return scriptData;

	lea	edx, DWORD PTR _scriptData$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T254963[ebp]
	or	eax, 1
	mov	DWORD PTR $T254963[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _scriptData$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 10012: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getScriptData@CvPlot@@QBE?AVCvString@@XZ$0:
	lea	ecx, DWORD PTR _scriptData$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?getScriptData@CvPlot@@QBE?AVCvString@@XZ$1:
	mov	eax, DWORD PTR $T254963[ebp]
	and	eax, 1
	je	$LN7@getScriptD
	and	DWORD PTR $T254963[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN7@getScriptD:
	ret	0
__ehhandler$?getScriptData@CvPlot@@QBE?AVCvString@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getScriptData@CvPlot@@QBE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getScriptData@CvPlot@@QBE?AVCvString@@XZ ENDP		; CvPlot::getScriptData
PUBLIC	?setScriptData@CvPlot@@QAEXPBD@Z		; CvPlot::setScriptData
EXTRN	__imp___strdup:PROC
; Function compile flags: /Odtp
;	COMDAT ?setScriptData@CvPlot@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T254995 = -8						; size = 4
$T254993 = -4						; size = 4
_szNewValue$ = 8					; size = 4
?setScriptData@CvPlot@@QAEXPBD@Z PROC			; CvPlot::setScriptData, COMDAT
; _this$ = ecx

; 10016: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 10017: 	SAFE_DELETE_ARRAY(m_szScriptData);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H
	mov	DWORD PTR $T254995[ebp], eax
	mov	ecx, DWORD PTR $T254995[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T254993[ebp], edx
	mov	eax, DWORD PTR $T254993[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T254995[ebp]
	mov	DWORD PTR [ecx], 0

; 10018: 	m_szScriptData = _strdup(szNewValue);

	mov	edx, DWORD PTR _szNewValue$[ebp]
	push	edx
	call	DWORD PTR __imp___strdup
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+180], eax

; 10019: }

	mov	esp, ebp
	pop	ebp
	ret	4
?setScriptData@CvPlot@@QAEXPBD@Z ENDP			; CvPlot::setScriptData
_TEXT	ENDS
EXTRN	?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z:PROC ; CvArea::setTargetCity
EXTRN	?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z:PROC ; CvArea::getTargetCity
EXTRN	?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z:PROC ; CvArea::changeYieldRateModifier
EXTRN	?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetAreaYieldModifier
EXTRN	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumActiveBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
EXTRN	?getNumBuildingInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildingInfos
EXTRN	?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z:PROC ; CvArea::changePopulationPerPlayer
EXTRN	?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z:PROC ; CvArea::changeCitiesPerPlayer
EXTRN	?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z:PROC ; CvArea::changeUnitsPerPlayer
EXTRN	?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z:PROC		; PUF_isPlayer
EXTRN	?changeNumStartingPlots@CvArea@@QAEXH@Z:PROC	; CvArea::changeNumStartingPlots
EXTRN	?changeNumTiles@CvArea@@QAEXH@Z:PROC		; CvArea::changeNumTiles
; Function compile flags: /Odtp
;	COMDAT ?processArea@CvPlot@@IAEXPAVCvArea@@H@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T255043 = -44						; size = 4
$T255034 = -40						; size = 4
$T255025 = -36						; size = 4
_uiOffset$255010 = -28					; size = 4
$T255001 = -24						; size = 4
_eBuilding$226344 = -20					; size = 4
_pkBuildingInfo$226346 = -16				; size = 4
_iJ$ = -12						; size = 4
_pCity$ = -8						; size = 4
_iI$ = -4						; size = 4
_pArea$ = 8						; size = 4
_iChange$ = 12						; size = 4
?processArea@CvPlot@@IAEXPAVCvArea@@H@Z PROC		; CvPlot::processArea, COMDAT
; _this$ = ecx

; 10025: {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 10026: 	CvCity* pCity;
; 10027: #ifdef AUI_WARNING_FIXES
; 10028: 	uint iI;
; 10029: 	int iJ;
; 10030: #else
; 10031: 	int iI, iJ;
; 10032: #endif
; 10033: 
; 10034: 	pArea->changeNumTiles(iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumTiles@CvArea@@QAEXH@Z		; CvArea::changeNumTiles

; 10035: 
; 10036: 	if(isOwned())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN27@processAre

; 10037: 	{
; 10038: 		pArea->changeNumOwnedTiles(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumOwnedTiles@CvArea@@QAEXH@Z	; CvArea::changeNumOwnedTiles
$LN27@processAre:

; 10039: 	}
; 10040: 
; 10041: 	if(isNEOfRiver())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNEOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNEOfRiver
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@processAre

; 10042: 	{
; 10043: 		pArea->changeNumRiverEdges(iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN26@processAre:

; 10044: 	}
; 10045: 	if(isNWOfRiver())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isNWOfRiver
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN25@processAre

; 10046: 	{
; 10047: 		pArea->changeNumRiverEdges(iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN25@processAre:

; 10048: 	}
; 10049: 	if(isWOfRiver())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isWOfRiver@CvPlot@@QBE_NXZ		; CvPlot::isWOfRiver
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@processAre

; 10050: 	{
; 10051: 		pArea->changeNumRiverEdges(iChange);

	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumRiverEdges@CvArea@@QAEXH@Z	; CvArea::changeNumRiverEdges
$LN24@processAre:

; 10052: 	}
; 10053: 
; 10054: 	if(getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN23@processAre

; 10055: 	{
; 10056: 		pArea->changeNumResources(getResourceType(), iChange);

	mov	eax, DWORD PTR _iChange$[ebp]
	push	eax
	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
$LN23@processAre:

; 10057: 	}
; 10058: 
; 10059: 	if(getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN22@processAre

; 10060: 	{
; 10061: 		pArea->changeNumImprovements(getImprovementType(), iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
$LN22@processAre:

; 10062: 	}
; 10063: 
; 10064: 	for(iI = 0; iI < MAX_PLAYERS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN21@processAre
$LN20@processAre:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN21@processAre:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN19@processAre

; 10065: 	{
; 10066: 		if(GET_PLAYER((PlayerTypes)iI).getStartingPlot() == this)

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255001[ebp], eax
	mov	ecx, DWORD PTR $T255001[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $LN18@processAre

; 10067: 		{
; 10068: 			pArea->changeNumStartingPlots(iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumStartingPlots@CvArea@@QAEXH@Z	; CvArea::changeNumStartingPlots
$LN18@processAre:

; 10069: 		}
; 10070: 
; 10071: 		pArea->changeUnitsPerPlayer(((PlayerTypes)iI), (plotCount(PUF_isPlayer, iI) * iChange));

	push	-1
	push	-1
	push	0
	push	-1
	push	-1
	push	-1
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	push	OFFSET ?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z ; PUF_isPlayer
	mov	ecx, DWORD PTR _this$[ebp]
	call	?plotCount@CvPlot@@QBEHP6A_NPBVCvUnit@@HH@ZHHW4PlayerTypes@@W4TeamTypes@@1HH@Z ; CvPlot::plotCount
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeUnitsPerPlayer

; 10072: 	}

	jmp	SHORT $LN20@processAre
$LN19@processAre:

; 10073: 
; 10074: 	for(iI = 0; iI < MAX_TEAMS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN17@processAre
$LN16@processAre:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN17@processAre:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN15@processAre

; 10075: 	{
; 10076: 		if(isRevealed(((TeamTypes)iI)))

	mov	edx, DWORD PTR _iI$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$255010[ebp], edx
	mov	eax, DWORD PTR _uiOffset$255010[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _iI$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$255010[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN14@processAre

; 10077: 		{
; 10078: 			pArea->changeNumRevealedTiles(((TeamTypes)iI), iChange);

	mov	ecx, DWORD PTR _iChange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ; CvArea::changeNumRevealedTiles
$LN14@processAre:

; 10079: 		}
; 10080: 	}

	jmp	SHORT $LN16@processAre
$LN15@processAre:

; 10081: 
; 10082: 	pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 10083: 
; 10084: 	if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	$LN28@processAre

; 10085: 	{
; 10086: 		// XXX make sure all of this syncs up...
; 10087: 		pArea->changeCitiesPerPlayer(pCity->getOwner(), iChange);

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T255025[ebp], ecx
	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	eax, DWORD PTR $T255025[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeCitiesPerPlayer

; 10088: 		pArea->changePopulationPerPlayer(pCity->getOwner(), (pCity->getPopulation() * iChange));

	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T255034[ebp], edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	imul	eax, DWORD PTR _iChange$[ebp]
	push	eax
	mov	eax, DWORD PTR $T255034[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changePopulationPerPlayer

; 10089: 
; 10090: 		for(iI = 0; iI < GC.getNumBuildingInfos(); ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@processAre
$LN11@processAre:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN12@processAre:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildingInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN10@processAre

; 10091: 		{
; 10092: 			const BuildingTypes eBuilding = static_cast<BuildingTypes>(iI);

	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _eBuilding$226344[ebp], edx

; 10093: 			CvBuildingEntry* pkBuildingInfo = GC.getBuildingInfo(eBuilding);

	mov	eax, DWORD PTR _eBuilding$226344[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuildingInfo$226346[ebp], eax

; 10094: 			if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$226346[ebp], 0
	je	SHORT $LN9@processAre

; 10095: 			{
; 10096: 				if(pCity->GetCityBuildings()->GetNumActiveBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$226344[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	test	eax, eax
	jle	SHORT $LN9@processAre

; 10097: 				{
; 10098: 					for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN7@processAre
$LN6@processAre:
	mov	edx, DWORD PTR _iJ$[ebp]
	add	edx, 1
	mov	DWORD PTR _iJ$[ebp], edx
$LN7@processAre:
	cmp	DWORD PTR _iJ$[ebp], 6
	jge	SHORT $LN9@processAre

; 10099: 					{
; 10100: 						pArea->changeYieldRateModifier(pCity->getOwner(), ((YieldTypes)iJ), (pkBuildingInfo->GetAreaYieldModifier(iJ) * iChange * pCity->GetCityBuildings()->GetNumActiveBuilding(eBuilding)));

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T255043[ebp], ecx
	mov	edx, DWORD PTR _iJ$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkBuildingInfo$226346[ebp]
	call	?GetAreaYieldModifier@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetAreaYieldModifier
	mov	esi, eax
	imul	esi, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _eBuilding$226344[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumActiveBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumActiveBuilding
	imul	esi, eax
	push	esi
	mov	ecx, DWORD PTR _iJ$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T255043[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z ; CvArea::changeYieldRateModifier

; 10101: 					}

	jmp	SHORT $LN6@processAre
$LN9@processAre:

; 10102: 				}
; 10103: 			}
; 10104: 		}

	jmp	$LN11@processAre
$LN10@processAre:

; 10105: 
; 10106: 		for(iI = 0; iI < MAX_PLAYERS; ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@processAre
$LN3@processAre:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@processAre:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN28@processAre

; 10107: 		{
; 10108: 			if(pArea->getTargetCity((PlayerTypes)iI) == pCity)

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvArea::getTargetCity
	cmp	eax, DWORD PTR _pCity$[ebp]
	jne	SHORT $LN1@processAre

; 10109: 			{
; 10110: 				pArea->setTargetCity(((PlayerTypes)iI), NULL);

	push	0
	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z ; CvArea::setTargetCity
$LN1@processAre:

; 10111: 			}
; 10112: 		}

	jmp	SHORT $LN3@processAre
$LN28@processAre:

; 10113: 	}
; 10114: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?processArea@CvPlot@@IAEXPAVCvArea@@H@Z ENDP		; CvPlot::processArea
_TEXT	ENDS
PUBLIC	??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z ; operator>><short [1],80>
PUBLIC	??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z ; operator>><char,CvPlot>
PUBLIC	__$ArrayPad$
PUBLIC	?read@CvPlot@@QAEXAAVFDataStream@@@Z		; CvPlot::read
EXTRN	?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z:PROC ; BuildArrayHelpers::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAK@Z:PROC		; FDataStream::Read
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4RouteTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAD@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAF@Z:PROC		; FDataStream::Read
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$?read@CvPlot@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@CvPlot@@QAEXAAVFDataStream@@@Z$0
__ehfuncinfo$?read@CvPlot@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?read@CvPlot@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?read@CvPlot@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -260						; size = 4
$T255310 = -216						; size = 4
$T255308 = -212						; size = 4
$T255301 = -208						; size = 4
$T255297 = -204						; size = 4
$T255293 = -200						; size = 4
$T255289 = -196						; size = 4
$T255279 = -192						; size = 4
$T255275 = -188						; size = 4
$T255271 = -184						; size = 4
$T255267 = -180						; size = 4
$T255263 = -176						; size = 4
$T255211 = -172						; size = 4
$T255193 = -168						; size = 4
$T255205 = -164						; size = 8
$T255204 = -156						; size = 4
$T255180 = -152						; size = 4
$T255162 = -148						; size = 4
$T255174 = -144						; size = 8
$T255173 = -136						; size = 4
$T255049 = -132						; size = 4
$T255048 = -126						; size = 1
$T255047 = -125						; size = 1
_Data$226482 = -124					; size = 8
_uIdx$226478 = -116					; size = 4
_iNumBuildInfos$226464 = -112				; size = 4
_scriptData$226459 = -108				; size = 28
__$ArrayPad$ = -80					; size = 4
_i$226453 = -76						; size = 4
_i$226449 = -72						; size = 4
_i$226442 = -68						; size = 4
_i$226436 = -64						; size = 4
_i$226431 = -60						; size = 4
_i$226424 = -56						; size = 4
_i$226420 = -52						; size = 4
_i$226415 = -48						; size = 4
_i$226411 = -44						; size = 4
_i$226407 = -40						; size = 4
_i$226403 = -36						; size = 4
_iCount$ = -32						; size = 4
_bitPackWorkaround$ = -25				; size = 1
_uLength$ = -24						; size = 4
_uiVersion$ = -20					; size = 4
_hasScriptData$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?read@CvPlot@@QAEXAAVFDataStream@@@Z PROC		; CvPlot::read, COMDAT
; _this$ = ecx

; 10122: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read@CvPlot@@QAEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 10123: 	int iCount;
; 10124: 
; 10125: 	// Init saved data
; 10126: 	reset();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvPlot@@QAEXHH_N@Z		; CvPlot::reset

; 10127: 
; 10128: 	// Version number to maintain backwards compatibility
; 10129: 	uint uiVersion;
; 10130: 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 10131: 	CvAssertMsg(uiVersion <= g_CurrentCvPlotVersion, "Unexpected Version.  This could be caused by serialization errors.");
; 10132: 
; 10133: 	kStream >> m_iX;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10134: 	kStream >> m_iY;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10135: 	kStream >> m_iArea;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 356				; 00000164H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10136: 	kStream >> m_iFeatureVariety;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 453				; 000001c5H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10137: 	kStream >> m_iOwnershipDuration;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10138: 	kStream >> m_iImprovementDuration;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 382				; 0000017eH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10139: 	kStream >> m_iUpgradeProgress;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 384				; 00000180H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10140: 	kStream >> m_iCulture;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 386				; 00000182H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10141: 	kStream >> m_iNumMajorCivsRevealed;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 454				; 000001c6H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10142: 	kStream >> m_iCityRadiusCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 455				; 000001c7H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10143: 	kStream >> m_iReconCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 456				; 000001c8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10144: 	kStream >> m_iRiverCrossingCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 457				; 000001c9H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10145: 	kStream >> m_iResourceNum;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 458				; 000001caH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10146: 	kStream >> m_cBuilderAIScratchPadPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 368				; 00000170H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10147: 	kStream >> m_sBuilderAIScratchPadTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 370				; 00000172H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10148: 	kStream >> m_sBuilderAIScratchPadValue;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10149: 	kStream >> m_eBuilderAIScratchPadRoute;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 376				; 00000178H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4RouteTypes@@@Z ; operator>>
	add	esp, 8

; 10150: 	kStream >> m_iLandmass;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10151: 	kStream >> m_uiTradeRouteBitFlags;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 388				; 00000184H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 10152: 
; 10153: 	// the following members specify bit packing and do not resolve to
; 10154: 	// any serializable type.
; 10155: 	bool bitPackWorkaround;
; 10156: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10157: 	m_bStartingPlot = bitPackWorkaround;

	mov	cl, BYTE PTR _bitPackWorkaround$[ebp]
	and	cl, 1
	shl	cl, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+461]
	and	al, 251					; 000000fbH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+461], al

; 10158: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10159: 	m_bHills = bitPackWorkaround;

	mov	al, BYTE PTR _bitPackWorkaround$[ebp]
	and	al, 1
	shl	al, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 247					; 000000f7H
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 10160: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10161: 	m_bNEOfRiver = bitPackWorkaround;

	mov	dl, BYTE PTR _bitPackWorkaround$[ebp]
	and	dl, 1
	shl	dl, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	and	cl, 239					; 000000efH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+461], cl

; 10162: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10163: 	m_bWOfRiver = bitPackWorkaround;

	mov	cl, BYTE PTR _bitPackWorkaround$[ebp]
	and	cl, 1
	shl	cl, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+461]
	and	al, 223					; 000000dfH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+461], al

; 10164: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10165: 	m_bNWOfRiver = bitPackWorkaround;

	mov	al, BYTE PTR _bitPackWorkaround$[ebp]
	and	al, 1
	shl	al, 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 191					; 000000bfH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 10166: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10167: 	m_bPotentialCityWork = bitPackWorkaround;

	mov	dl, BYTE PTR _bitPackWorkaround$[ebp]
	and	dl, 1
	shl	dl, 7
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	and	cl, 127					; 0000007fH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+461], cl

; 10168: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10169: 	m_bImprovementPillaged = bitPackWorkaround;

	mov	cl, BYTE PTR _bitPackWorkaround$[ebp]
	and	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+461]
	and	al, 254					; 000000feH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+461], al

; 10170: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10171: 	m_bRoutePillaged = bitPackWorkaround;

	mov	al, BYTE PTR _bitPackWorkaround$[ebp]
	and	al, 1
	shl	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+461]
	and	dl, 253					; 000000fdH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+461], dl

; 10172: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10173: 	m_bBarbCampNotConverting = bitPackWorkaround;

	mov	dl, BYTE PTR _bitPackWorkaround$[ebp]
	and	dl, 1
	shl	dl, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	and	cl, 251					; 000000fbH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+462], cl

; 10174: 	kStream >> bitPackWorkaround;

	lea	eax, DWORD PTR _bitPackWorkaround$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10175: 	m_bRoughFeature = bitPackWorkaround;

	mov	cl, BYTE PTR _bitPackWorkaround$[ebp]
	and	cl, 1
	shl	cl, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	and	al, 247					; 000000f7H
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+462], al

; 10176: 	kStream >> bitPackWorkaround;

	lea	edx, DWORD PTR _bitPackWorkaround$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10177: 	m_bResourceLinkedCityActive = bitPackWorkaround;

	mov	al, BYTE PTR _bitPackWorkaround$[ebp]
	and	al, 1
	shl	al, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 239					; 000000efH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 10178: 	kStream >> bitPackWorkaround;

	lea	ecx, DWORD PTR _bitPackWorkaround$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10179: 	m_bImprovedByGiftFromMajor = bitPackWorkaround;

	mov	dl, BYTE PTR _bitPackWorkaround$[ebp]
	and	dl, 1
	shl	dl, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	and	cl, 223					; 000000dfH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+462], cl

; 10180: 
; 10181: 	kStream >> m_eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10182: 	kStream >> m_ePlotType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10183: 	kStream >> m_eTerrainType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 6
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10184: 	if (uiVersion >= 3)

	cmp	DWORD PTR _uiVersion$[ebp], 3
	jb	$LN54@read

; 10185: 		m_eFeatureType = (FeatureTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	BYTE PTR $T255047[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 428				; 000001acH
	mov	DWORD PTR $T255180[ebp], ecx
	movsx	edx, BYTE PTR $T255047[ebp]
	mov	eax, DWORD PTR $T255180[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	edx, ecx
	je	SHORT $LN127@read
	mov	edx, DWORD PTR $T255180[ebp]
	movsx	eax, BYTE PTR [edx+4]
	movsx	ecx, BYTE PTR $T255047[ebp]
	cmp	eax, ecx
	je	SHORT $LN127@read
	mov	edx, DWORD PTR $T255180[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T255162[ebp], eax
	mov	ecx, DWORD PTR $T255180[ebp]
	mov	DWORD PTR $T255173[ebp], ecx
	lea	edx, DWORD PTR $T255173[ebp]
	push	edx
	lea	eax, DWORD PTR $T255174[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255162[ebp]
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	ecx, DWORD PTR $T255180[ebp]
	mov	dl, BYTE PTR $T255047[ebp]
	mov	BYTE PTR [ecx+4], dl
$LN127@read:

; 10186: 	else

	jmp	$LN53@read
$LN54@read:

; 10187: 	{
; 10188: 		kStream >> m_eFeatureType;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 428				; 000001acH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z ; operator>><char,CvPlot>
	add	esp, 8

; 10189: #ifdef AUI_WARNING_FIXES
; 10190: 		if ((uint)m_eFeatureType >= GC.getNumFeatureInfos())
; 10191: #else
; 10192: 		if ((int)m_eFeatureType >= GC.getNumFeatureInfos())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	esi, BYTE PTR [edx+432]
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	cmp	esi, eax
	jl	SHORT $LN53@read

; 10193: #endif
; 10194: 			m_eFeatureType = NO_FEATURE;

	mov	BYTE PTR $T255048[ebp], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 428				; 000001acH
	mov	DWORD PTR $T255211[ebp], eax
	movsx	ecx, BYTE PTR $T255048[ebp]
	mov	edx, DWORD PTR $T255211[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	ecx, eax
	je	SHORT $LN53@read
	mov	ecx, DWORD PTR $T255211[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	movsx	eax, BYTE PTR $T255048[ebp]
	cmp	edx, eax
	je	SHORT $LN53@read
	mov	ecx, DWORD PTR $T255211[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T255193[ebp], edx
	mov	eax, DWORD PTR $T255211[ebp]
	mov	DWORD PTR $T255204[ebp], eax
	lea	ecx, DWORD PTR $T255204[ebp]
	push	ecx
	lea	edx, DWORD PTR $T255205[ebp]
	push	edx
	mov	ecx, DWORD PTR $T255193[ebp]
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	eax, DWORD PTR $T255211[ebp]
	mov	cl, BYTE PTR $T255048[ebp]
	mov	BYTE PTR [eax+4], cl
$LN53@read:

; 10195: 	}
; 10196: 	m_eResourceType = (ResourceTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+440], al

; 10197: 
; 10198: 	if(uiVersion >= 5)

	cmp	DWORD PTR _uiVersion$[ebp], 5
	jb	SHORT $LN51@read

; 10199: 	{
; 10200: 		m_eImprovementType = (ImprovementTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+441], al

; 10201: 	}
; 10202: 	else

	jmp	SHORT $LN50@read
$LN51@read:

; 10203: 	{
; 10204: 		kStream >> m_eImprovementType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 441				; 000001b9H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10205: 		// Filter out improvements that have been removed
; 10206: 		if (m_eImprovementType != NO_IMPROVEMENT)

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+441]
	cmp	ecx, -1
	je	SHORT $LN50@read

; 10207: 			if (GC.getImprovementInfo((ImprovementTypes)m_eImprovementType) == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+441]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	test	eax, eax
	jne	SHORT $LN50@read

; 10208: 				m_eImprovementType = NO_IMPROVEMENT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+441], -1
$LN50@read:

; 10209: 	}
; 10210: 
; 10211: 	if (uiVersion >= 7)

	cmp	DWORD PTR _uiVersion$[ebp], 7
	jb	SHORT $LN47@read

; 10212: 	{
; 10213: 		m_eImprovementTypeUnderConstruction = (ImprovementTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+442], al

; 10214: 	}
; 10215: 	else

	jmp	SHORT $LN46@read
$LN47@read:

; 10216: 	{
; 10217: 		m_eImprovementTypeUnderConstruction = NO_IMPROVEMENT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+442], -1
$LN46@read:

; 10218: 	}
; 10219: 
; 10220: 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	SHORT $LN45@read

; 10221: 	{
; 10222: 		kStream >> m_ePlayerBuiltImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 443				; 000001bbH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10223: 	}
; 10224: 	else

	jmp	SHORT $LN44@read
$LN45@read:

; 10225: 	{
; 10226: 		m_ePlayerBuiltImprovement = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+443], -1
$LN44@read:

; 10227: 	}
; 10228: 	kStream >> m_ePlayerResponsibleForImprovement;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 444				; 000001bcH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10229: 	kStream >> m_ePlayerResponsibleForRoute;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 445				; 000001bdH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10230: 	kStream >> m_ePlayerThatClearedBarbCampHere;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 446				; 000001beH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10231: 	kStream >> m_eRouteType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 447				; 000001bfH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10232: 	kStream >> m_eWorldAnchor;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 448				; 000001c0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10233: 	kStream >> m_cWorldAnchorData;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 449				; 000001c1H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10234: 
; 10235: 	kStream >> m_eRiverEFlowDirection;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 450				; 000001c2H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10236: 	kStream >> m_eRiverSEFlowDirection;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 451				; 000001c3H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10237: 	kStream >> m_eRiverSWFlowDirection;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 452				; 000001c4H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10238: 
; 10239: 	kStream >> m_plotCity.eOwner;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 104				; 00000068H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10240: 	kStream >> m_plotCity.iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10241: 	kStream >> m_workingCity.eOwner;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10242: 	kStream >> m_workingCity.iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10243: 	kStream >> m_workingCityOverride.eOwner;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 120				; 00000078H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10244: 	kStream >> m_workingCityOverride.iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10245: 	kStream >> m_ResourceLinkedCity.eOwner;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 128				; 00000080H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10246: 	kStream >> m_ResourceLinkedCity.iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10247: 	kStream >> m_purchaseCity.eOwner;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10248: 	kStream >> m_purchaseCity.iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10249: 
; 10250: 	for(uint i = 0; i < NUM_YIELD_TYPES; i++)

	mov	DWORD PTR _i$226403[ebp], 0
	jmp	SHORT $LN43@read
$LN42@read:
	mov	edx, DWORD PTR _i$226403[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226403[ebp], edx
$LN43@read:
	cmp	DWORD PTR _i$226403[ebp], 6
	jae	SHORT $LN41@read

; 10251: 		kStream >> m_aiYield[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	edx, DWORD PTR _i$226403[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR $T255263[ebp], eax
	mov	ecx, DWORD PTR $T255263[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read
	jmp	SHORT $LN42@read
$LN41@read:

; 10252: 
; 10253: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	mov	DWORD PTR _i$226407[ebp], 0
	jmp	SHORT $LN40@read
$LN39@read:
	mov	edx, DWORD PTR _i$226407[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226407[ebp], edx
$LN40@read:
	cmp	DWORD PTR _i$226407[ebp], 80		; 00000050H
	jae	SHORT $LN38@read

; 10254: 		kStream >> m_aiFoundValue[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR _i$226407[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T255267[ebp], eax
	mov	ecx, DWORD PTR $T255267[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	jmp	SHORT $LN39@read
$LN38@read:

; 10255: 
; 10256: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	mov	DWORD PTR _i$226411[ebp], 0
	jmp	SHORT $LN37@read
$LN36@read:
	mov	edx, DWORD PTR _i$226411[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226411[ebp], edx
$LN37@read:
	cmp	DWORD PTR _i$226411[ebp], 80		; 00000050H
	jae	SHORT $LN35@read

; 10257: 		kStream >> m_aiPlayerCityRadiusCount[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+152]
	add	ecx, DWORD PTR _i$226411[ebp]
	mov	DWORD PTR $T255271[ebp], ecx
	mov	edx, DWORD PTR $T255271[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read
	jmp	SHORT $LN36@read
$LN35@read:

; 10258: 
; 10259: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226415[ebp], 0
	jmp	SHORT $LN34@read
$LN33@read:
	mov	eax, DWORD PTR _i$226415[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226415[ebp], eax
$LN34@read:
	cmp	DWORD PTR _i$226415[ebp], 80		; 00000050H
	jae	SHORT $LN32@read

; 10260: 	{
; 10261: 		kStream >> m_aiVisibilityCount[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _i$226415[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR $T255275[ebp], ecx
	mov	edx, DWORD PTR $T255275[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10262: 		if (m_aiVisibilityCount[i] < 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _i$226415[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	test	eax, eax
	jge	SHORT $LN31@read

; 10263: 			m_aiVisibilityCount[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	xor	eax, eax
	mov	ecx, DWORD PTR _i$226415[ebp]
	mov	WORD PTR [edx+ecx*2], ax
$LN31@read:

; 10264: 	}

	jmp	SHORT $LN33@read
$LN32@read:

; 10265: 
; 10266: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226420[ebp], 0
	jmp	SHORT $LN30@read
$LN29@read:
	mov	edx, DWORD PTR _i$226420[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226420[ebp], edx
$LN30@read:
	cmp	DWORD PTR _i$226420[ebp], 80		; 00000050H
	jae	SHORT $LN28@read

; 10267: 		kStream >> m_aiRevealedOwner[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	add	ecx, DWORD PTR _i$226420[ebp]
	mov	DWORD PTR $T255279[ebp], ecx
	mov	edx, DWORD PTR $T255279[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read
	jmp	SHORT $LN29@read
$LN28@read:

; 10268: 
; 10269: 	kStream >> m_cRiverCrossing;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 460				; 000001ccH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10270: 
; 10271: 	for(uint i = 0; i<PlotBoolField::eCount; ++i)

	mov	DWORD PTR _i$226424[ebp], 0
	jmp	SHORT $LN27@read
$LN26@read:
	mov	ecx, DWORD PTR _i$226424[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226424[ebp], ecx
$LN27@read:
	cmp	DWORD PTR _i$226424[ebp], 4
	jae	SHORT $LN25@read

; 10272: 	{
; 10273: 		kStream >> m_bfRevealed.m_dwBits[i];

	mov	edx, DWORD PTR _i$226424[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+8]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 10274: 	}

	jmp	SHORT $LN26@read
$LN25@read:

; 10275: 
; 10276: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226431[ebp], 0
	jmp	SHORT $LN24@read
$LN23@read:
	mov	edx, DWORD PTR _i$226431[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226431[ebp], edx
$LN24@read:
	cmp	DWORD PTR _i$226431[ebp], 80		; 00000050H
	jae	SHORT $LN22@read

; 10277: 		kStream >> m_abResourceForceReveal[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, DWORD PTR _i$226431[ebp]
	mov	DWORD PTR $T255289[ebp], ecx
	mov	edx, DWORD PTR $T255289[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	jmp	SHORT $LN23@read
$LN22@read:

; 10278: 
; 10279: 	if (uiVersion >= 6)

	cmp	DWORD PTR _uiVersion$[ebp], 6
	jb	SHORT $LN21@read

; 10280: 	{
; 10281: 		for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226436[ebp], 0
	jmp	SHORT $LN20@read
$LN19@read:
	mov	eax, DWORD PTR _i$226436[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226436[ebp], eax
$LN20@read:
	cmp	DWORD PTR _i$226436[ebp], 80		; 00000050H
	jae	SHORT $LN18@read

; 10282: 			m_aeRevealedImprovementType[i] = (ImprovementTypes) CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+164]
	mov	edx, DWORD PTR _i$226436[ebp]
	mov	WORD PTR [ecx+edx*2], ax
	jmp	SHORT $LN19@read
$LN18@read:

; 10283: 	}
; 10284: 	else

	jmp	$LN17@read
$LN21@read:

; 10285: 	{
; 10286: 		for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226442[ebp], 0
	jmp	SHORT $LN16@read
$LN15@read:
	mov	eax, DWORD PTR _i$226442[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226442[ebp], eax
$LN16@read:
	cmp	DWORD PTR _i$226442[ebp], 80		; 00000050H
	jae	SHORT $LN17@read

; 10287: 		{
; 10288: 			kStream >> m_aeRevealedImprovementType[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _i$226442[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR $T255293[ebp], ecx
	mov	edx, DWORD PTR $T255293[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 10289: 			if (m_aeRevealedImprovementType[i] != NO_IMPROVEMENT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR _i$226442[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	cmp	eax, -1
	je	SHORT $LN13@read

; 10290: 				if (GC.getImprovementInfo((ImprovementTypes)m_aeRevealedImprovementType[i]) == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _i$226442[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	test	eax, eax
	jne	SHORT $LN13@read

; 10291: 					m_aeRevealedImprovementType[i] = NO_IMPROVEMENT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+164]
	or	ecx, -1
	mov	edx, DWORD PTR _i$226442[ebp]
	mov	WORD PTR [eax+edx*2], cx
$LN13@read:

; 10292: 		}

	jmp	$LN15@read
$LN17@read:

; 10293: 	}
; 10294: 
; 10295: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226449[ebp], 0
	jmp	SHORT $LN11@read
$LN10@read:
	mov	eax, DWORD PTR _i$226449[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226449[ebp], eax
$LN11@read:
	cmp	DWORD PTR _i$226449[ebp], 80		; 00000050H
	jae	SHORT $LN9@read

; 10296: 		kStream >> m_aeRevealedRouteType[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	eax, DWORD PTR _i$226449[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR $T255297[ebp], ecx
	mov	edx, DWORD PTR $T255297[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read
	jmp	SHORT $LN10@read
$LN9@read:

; 10297: 
; 10298: 	for(uint i = 0; i < MAX_MAJOR_CIVS; i++)

	mov	DWORD PTR _i$226453[ebp], 0
	jmp	SHORT $LN8@read
$LN7@read:
	mov	eax, DWORD PTR _i$226453[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226453[ebp], eax
$LN8@read:
	cmp	DWORD PTR _i$226453[ebp], 22		; 00000016H
	jae	SHORT $LN6@read

; 10299: 		kStream >> m_abNoSettling[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	add	edx, DWORD PTR _i$226453[ebp]
	mov	DWORD PTR $T255301[ebp], edx
	mov	eax, DWORD PTR $T255301[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	jmp	SHORT $LN7@read
$LN6@read:

; 10300: 
; 10301: 	bool hasScriptData = false;

	mov	BYTE PTR _hasScriptData$[ebp], 0

; 10302: 	kStream >> hasScriptData;

	lea	ecx, DWORD PTR _hasScriptData$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 10303: 	if(hasScriptData)

	movzx	edx, BYTE PTR _hasScriptData$[ebp]
	test	edx, edx
	je	SHORT $LN5@read

; 10304: 	{
; 10305: 		std::string scriptData;

	lea	ecx, DWORD PTR _scriptData$226459[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 10306: 		kStream >> scriptData;

	lea	eax, DWORD PTR _scriptData$226459[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator>>
	add	esp, 8

; 10307: 		setScriptData(scriptData.c_str());

	lea	ecx, DWORD PTR _scriptData$226459[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setScriptData@CvPlot@@QAEXPBD@Z	; CvPlot::setScriptData

; 10308: 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _scriptData$226459[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@read:

; 10309: 
; 10310: 	SAFE_DELETE_ARRAY(m_paiBuildProgress);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 184				; 000000b8H
	mov	DWORD PTR $T255310[ebp], edx
	mov	eax, DWORD PTR $T255310[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T255308[ebp], ecx
	mov	edx, DWORD PTR $T255308[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T255310[ebp]
	mov	DWORD PTR [eax], 0

; 10311: 	kStream >> iCount;

	lea	ecx, DWORD PTR _iCount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10312: 	if(iCount > 0)

	cmp	DWORD PTR _iCount$[ebp], 0
	jle	SHORT $LN4@read

; 10313: 	{
; 10314: 		const int iNumBuildInfos = GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	DWORD PTR _iNumBuildInfos$226464[ebp], eax

; 10315: #ifdef AUI_WARNING_FIXES
; 10316: 		m_paiBuildProgress = FNEW(int[iNumBuildInfos], c_eCiv5GameplayDLL, 0);
; 10317: #else
; 10318: 		m_paiBuildProgress = FNEW(short[iNumBuildInfos], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumBuildInfos$226464[ebp]
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T255049[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T255049[ebp]
	mov	DWORD PTR [eax+184], ecx

; 10319: #endif
; 10320: 		ZeroMemory(m_paiBuildProgress, sizeof(short) * iNumBuildInfos);

	mov	edx, DWORD PTR _iNumBuildInfos$226464[ebp]
	shl	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 10321: 		
; 10322: 		BuildArrayHelpers::Read(kStream, m_paiBuildProgress);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+184]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?Read@BuildArrayHelpers@@YAXAAVFDataStream@@PAF@Z ; BuildArrayHelpers::Read
	add	esp, 8
$LN4@read:

; 10323: 	}
; 10324: 
; 10325: 	kStream >> m_apaiInvisibleVisibilityCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 196				; 000000c4H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z ; operator>><short [1],80>
	add	esp, 8

; 10326: 
; 10327: 	//m_units.Read(kStream);
; 10328: 	UINT uLength;
; 10329: 	kStream >> uLength;

	lea	ecx, DWORD PTR _uLength$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 10330: 	for(UINT uIdx = 0; uIdx < uLength; ++uIdx)

	mov	DWORD PTR _uIdx$226478[ebp], 0
	jmp	SHORT $LN3@read
$LN2@read:
	mov	edx, DWORD PTR _uIdx$226478[ebp]
	add	edx, 1
	mov	DWORD PTR _uIdx$226478[ebp], edx
$LN3@read:
	mov	eax, DWORD PTR _uIdx$226478[ebp]
	cmp	eax, DWORD PTR _uLength$[ebp]
	jae	SHORT $LN1@read

; 10331: 	{
; 10332: 		IDInfo  Data;

	mov	DWORD PTR _Data$226482[ebp], -1
	mov	DWORD PTR _Data$226482[ebp+4], -1

; 10333: 
; 10334: 		kStream >> Data.eOwner;

	lea	ecx, DWORD PTR _Data$226482[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 10335: 		kStream >> Data.iID;

	lea	eax, DWORD PTR _Data$226482[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 10336: 
; 10337: 		m_units.insertAtEnd(&Data);

	lea	ecx, DWORD PTR _Data$226482[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back

; 10338: 	}

	jmp	SHORT $LN2@read
$LN1@read:

; 10339: 
; 10340: 	kStream >> m_cContinentType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 459				; 000001cbH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 10341: 	kStream >> m_kArchaeologyData;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 464				; 000001d0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAUCvArchaeologyData@@@Z ; operator>>
	add	esp, 8

; 10342: 
; 10343: 	updateImpassable();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateImpassable@CvPlot@@IAEXXZ	; CvPlot::updateImpassable

; 10344: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@CvPlot@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _scriptData$226459[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?read@CvPlot@@QAEXAAVFDataStream@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read@CvPlot@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@CvPlot@@QAEXAAVFDataStream@@@Z ENDP		; CvPlot::read
PUBLIC	??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z ; operator<<<short const [1],80>
PUBLIC	__$ArrayPad$
PUBLIC	?write@CvPlot@@QBEXAAVFDataStream@@@Z		; CvPlot::write
EXTRN	?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z:PROC ; BuildArrayHelpers::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABK@Z:PROC		; FDataStream::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4FeatureTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4RouteTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABD@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABF@Z:PROC		; FDataStream::Write
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$?write@CvPlot@@QBEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?write@CvPlot@@QBEXAAVFDataStream@@@Z$0
__ehfuncinfo$?write@CvPlot@@QBEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?write@CvPlot@@QBEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?write@CvPlot@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -172						; size = 4
$T255621 = -168						; size = 4
$T255609 = -164						; size = 4
$T255597 = -160						; size = 4
$T255583 = -156						; size = 4
$T255579 = -152						; size = 4
$T255575 = -148						; size = 4
$T255565 = -144						; size = 4
$T255561 = -140						; size = 4
$T255557 = -136						; size = 4
$T255553 = -132						; size = 4
$T255549 = -128						; size = 4
$T255394 = -124						; size = 4
$T255393 = -120						; size = 4
$T255392 = -116						; size = 1
$T255391 = -115						; size = 1
$T255390 = -114						; size = 1
$T255389 = -113						; size = 1
$T255388 = -112						; size = 1
$T255387 = -111						; size = 1
$T255386 = -110						; size = 1
$T255385 = -109						; size = 1
$T255384 = -108						; size = 1
$T255383 = -107						; size = 1
$T255382 = -106						; size = 1
$T255381 = -105						; size = 1
_pData$226609 = -104					; size = 4
_uIdx$226605 = -100					; size = 4
_scriptData$226574 = -96				; size = 28
__$ArrayPad$ = -68					; size = 4
_i$226568 = -64						; size = 4
_i$226564 = -60						; size = 4
_i$226559 = -56						; size = 4
_i$226555 = -52						; size = 4
_i$226543 = -48						; size = 4
_i$226539 = -44						; size = 4
_i$226535 = -40						; size = 4
_i$226531 = -36						; size = 4
_i$226527 = -32						; size = 4
_i$226523 = -28						; size = 4
_uLength$ = -24						; size = 4
_uiVersion$ = -20					; size = 4
_hasScriptData$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?write@CvPlot@@QBEXAAVFDataStream@@@Z PROC		; CvPlot::write, COMDAT
; _this$ = ecx

; 10352: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?write@CvPlot@@QBEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 10353: 	// Current version number
; 10354: 	uint uiVersion = g_CurrentCvPlotVersion;

	mov	DWORD PTR _uiVersion$[ebp], 7

; 10355: 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 10356: 
; 10357: 	kStream << m_iX;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10358: 	kStream << m_iY;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10359: 	kStream << m_iArea;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 356				; 00000164H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10360: 	kStream << m_iFeatureVariety;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 453				; 000001c5H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10361: 	kStream << m_iOwnershipDuration;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10362: 	kStream << m_iImprovementDuration;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 382				; 0000017eH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10363: 	kStream << m_iUpgradeProgress;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 384				; 00000180H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10364: 	kStream << m_iCulture;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 386				; 00000182H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10365: 	kStream << m_iNumMajorCivsRevealed;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 454				; 000001c6H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10366: 	kStream << m_iCityRadiusCount;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 455				; 000001c7H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10367: 	kStream << m_iReconCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 456				; 000001c8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10368: 	kStream << m_iRiverCrossingCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 457				; 000001c9H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10369: 	kStream << m_iResourceNum;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 458				; 000001caH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10370: 	kStream << m_cBuilderAIScratchPadPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 368				; 00000170H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10371: 	kStream << m_sBuilderAIScratchPadTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 370				; 00000172H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10372: 	kStream << m_sBuilderAIScratchPadValue;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 10373: 	kStream << m_eBuilderAIScratchPadRoute;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 376				; 00000178H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4RouteTypes@@@Z ; operator<<
	add	esp, 8

; 10374: 	kStream << m_iLandmass;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10375: 	kStream << m_uiTradeRouteBitFlags;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 388				; 00000184H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 10376: 
; 10377: 	kStream << m_bStartingPlot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 2
	and	cl, 1
	mov	BYTE PTR $T255381[ebp], cl
	lea	edx, DWORD PTR $T255381[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10378: 	kStream << m_bHills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 3
	and	cl, 1
	mov	BYTE PTR $T255382[ebp], cl
	lea	edx, DWORD PTR $T255382[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10379: 	kStream << m_bNEOfRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 4
	and	cl, 1
	mov	BYTE PTR $T255383[ebp], cl
	lea	edx, DWORD PTR $T255383[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10380: 	kStream << m_bWOfRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 5
	and	cl, 1
	mov	BYTE PTR $T255384[ebp], cl
	lea	edx, DWORD PTR $T255384[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10381: 	kStream << m_bNWOfRiver;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 6
	and	cl, 1
	mov	BYTE PTR $T255385[ebp], cl
	lea	edx, DWORD PTR $T255385[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10382: 	kStream << m_bPotentialCityWork;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 7
	and	cl, 1
	mov	BYTE PTR $T255386[ebp], cl
	lea	edx, DWORD PTR $T255386[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10383: 	kStream << m_bImprovementPillaged;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	and	cl, 1
	mov	BYTE PTR $T255387[ebp], cl
	lea	edx, DWORD PTR $T255387[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10384: 	kStream << m_bRoutePillaged;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+461]
	shr	cl, 1
	and	cl, 1
	mov	BYTE PTR $T255388[ebp], cl
	lea	edx, DWORD PTR $T255388[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10385: 	kStream << m_bBarbCampNotConverting;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 2
	and	cl, 1
	mov	BYTE PTR $T255389[ebp], cl
	lea	edx, DWORD PTR $T255389[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10386: 	kStream << m_bRoughFeature;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 3
	and	cl, 1
	mov	BYTE PTR $T255390[ebp], cl
	lea	edx, DWORD PTR $T255390[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10387: 	kStream << m_bResourceLinkedCityActive;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 4
	and	cl, 1
	mov	BYTE PTR $T255391[ebp], cl
	lea	edx, DWORD PTR $T255391[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10388: 	kStream << m_bImprovedByGiftFromMajor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 5
	and	cl, 1
	mov	BYTE PTR $T255392[ebp], cl
	lea	edx, DWORD PTR $T255392[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10389: 	// m_bPlotLayoutDirty not saved
; 10390: 	// m_bLayoutStateWorked not saved
; 10391: 
; 10392: 	kStream << m_eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10393: 	kStream << m_ePlotType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10394: 	kStream << m_eTerrainType;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 6
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10395: 	CvInfosSerializationHelper::WriteHashed(kStream, (const FeatureTypes)m_eFeatureType.get());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+432]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4FeatureTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 10396: 	CvInfosSerializationHelper::WriteHashed(kStream, (const ResourceTypes)m_eResourceType);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+440]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 10397: 	CvInfosSerializationHelper::WriteHashed(kStream, (const ImprovementTypes)m_eImprovementType);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+441]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 10398: 	CvInfosSerializationHelper::WriteHashed(kStream, (const ImprovementTypes)m_eImprovementTypeUnderConstruction);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+442]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 10399: 	kStream << m_ePlayerBuiltImprovement;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 443				; 000001bbH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10400: 	kStream << m_ePlayerResponsibleForImprovement;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 444				; 000001bcH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10401: 	kStream << m_ePlayerResponsibleForRoute;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 445				; 000001bdH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10402: 	kStream << m_ePlayerThatClearedBarbCampHere;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 446				; 000001beH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10403: 	kStream << m_eRouteType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 447				; 000001bfH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10404: 	kStream << m_eWorldAnchor;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 448				; 000001c0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10405: 	kStream << m_cWorldAnchorData;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 449				; 000001c1H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10406: 	kStream << m_eRiverEFlowDirection;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 450				; 000001c2H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10407: 	kStream << m_eRiverSEFlowDirection;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 451				; 000001c3H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10408: 	kStream << m_eRiverSWFlowDirection;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 452				; 000001c4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10409: 
; 10410: 	kStream << m_plotCity.eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10411: 	kStream << m_plotCity.iID;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10412: 	kStream << m_workingCity.eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10413: 	kStream << m_workingCity.iID;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 116				; 00000074H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10414: 	kStream << m_workingCityOverride.eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10415: 	kStream << m_workingCityOverride.iID;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10416: 	kStream << m_ResourceLinkedCity.eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10417: 	kStream << m_ResourceLinkedCity.iID;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 132				; 00000084H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10418: 	kStream << m_purchaseCity.eOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10419: 	kStream << m_purchaseCity.iID;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10420: 
; 10421: 	for(uint i = 0; i < NUM_YIELD_TYPES; i++)

	mov	DWORD PTR _i$226523[ebp], 0
	jmp	SHORT $LN36@write
$LN35@write:
	mov	ecx, DWORD PTR _i$226523[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226523[ebp], ecx
$LN36@write:
	cmp	DWORD PTR _i$226523[ebp], 6
	jae	SHORT $LN34@write

; 10422: 		kStream << m_aiYield[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	ecx, DWORD PTR _i$226523[ebp]
	lea	edx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR $T255549[ebp], edx
	mov	eax, DWORD PTR $T255549[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	jmp	SHORT $LN35@write
$LN34@write:

; 10423: 
; 10424: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	mov	DWORD PTR _i$226527[ebp], 0
	jmp	SHORT $LN33@write
$LN32@write:
	mov	ecx, DWORD PTR _i$226527[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226527[ebp], ecx
$LN33@write:
	cmp	DWORD PTR _i$226527[ebp], 80		; 00000050H
	jae	SHORT $LN31@write

; 10425: 		kStream << m_aiFoundValue[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR _i$226527[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T255553[ebp], edx
	mov	eax, DWORD PTR $T255553[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	jmp	SHORT $LN32@write
$LN31@write:

; 10426: 
; 10427: 	for(uint i = 0; i < REALLY_MAX_PLAYERS; i++)

	mov	DWORD PTR _i$226531[ebp], 0
	jmp	SHORT $LN30@write
$LN29@write:
	mov	ecx, DWORD PTR _i$226531[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226531[ebp], ecx
$LN30@write:
	cmp	DWORD PTR _i$226531[ebp], 80		; 00000050H
	jae	SHORT $LN28@write

; 10428: 		kStream << m_aiPlayerCityRadiusCount[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+152]
	add	eax, DWORD PTR _i$226531[ebp]
	mov	DWORD PTR $T255557[ebp], eax
	mov	ecx, DWORD PTR $T255557[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write
	jmp	SHORT $LN29@write
$LN28@write:

; 10429: 
; 10430: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226535[ebp], 0
	jmp	SHORT $LN27@write
$LN26@write:
	mov	edx, DWORD PTR _i$226535[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226535[ebp], edx
$LN27@write:
	cmp	DWORD PTR _i$226535[ebp], 80		; 00000050H
	jae	SHORT $LN25@write

; 10431: 		kStream << m_aiVisibilityCount[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _i$226535[ebp]
	lea	eax, DWORD PTR [ecx+edx*2]
	mov	DWORD PTR $T255561[ebp], eax
	mov	ecx, DWORD PTR $T255561[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	jmp	SHORT $LN26@write
$LN25@write:

; 10432: 
; 10433: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226539[ebp], 0
	jmp	SHORT $LN24@write
$LN23@write:
	mov	edx, DWORD PTR _i$226539[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226539[ebp], edx
$LN24@write:
	cmp	DWORD PTR _i$226539[ebp], 80		; 00000050H
	jae	SHORT $LN22@write

; 10434: 		kStream << m_aiRevealedOwner[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+160]
	add	ecx, DWORD PTR _i$226539[ebp]
	mov	DWORD PTR $T255565[ebp], ecx
	mov	edx, DWORD PTR $T255565[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write
	jmp	SHORT $LN23@write
$LN22@write:

; 10435: 
; 10436: 	kStream << m_cRiverCrossing;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 460				; 000001ccH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10437: 
; 10438: 	//for(uint i = 0; i < REALLY_MAX_TEAMS;i++)
; 10439: 	//	kStream << m_abRevealed[i];
; 10440: 
; 10441: 	for(uint i = 0; i<PlotBoolField::eCount; ++i)

	mov	DWORD PTR _i$226543[ebp], 0
	jmp	SHORT $LN21@write
$LN20@write:
	mov	ecx, DWORD PTR _i$226543[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$226543[ebp], ecx
$LN21@write:
	cmp	DWORD PTR _i$226543[ebp], 4
	jae	SHORT $LN19@write

; 10442: 	{
; 10443: 		kStream << m_bfRevealed.m_dwBits[i];

	mov	edx, DWORD PTR _i$226543[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+8]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 10444: 	}

	jmp	SHORT $LN20@write
$LN19@write:

; 10445: 
; 10446: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226555[ebp], 0
	jmp	SHORT $LN18@write
$LN17@write:
	mov	edx, DWORD PTR _i$226555[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226555[ebp], edx
$LN18@write:
	cmp	DWORD PTR _i$226555[ebp], 80		; 00000050H
	jae	SHORT $LN16@write

; 10447: 		kStream << m_abResourceForceReveal[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	add	ecx, DWORD PTR _i$226555[ebp]
	mov	DWORD PTR $T255575[ebp], ecx
	mov	edx, DWORD PTR $T255575[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	jmp	SHORT $LN17@write
$LN16@write:

; 10448: 
; 10449: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226559[ebp], 0
	jmp	SHORT $LN15@write
$LN14@write:
	mov	eax, DWORD PTR _i$226559[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226559[ebp], eax
$LN15@write:
	cmp	DWORD PTR _i$226559[ebp], 80		; 00000050H
	jae	SHORT $LN13@write

; 10450: 	{
; 10451: 		CvInfosSerializationHelper::WriteHashed(kStream, (const ImprovementTypes)m_aeRevealedImprovementType[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	mov	eax, DWORD PTR _i$226559[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ImprovementTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 10452: 	}

	jmp	SHORT $LN14@write
$LN13@write:

; 10453: 
; 10454: 	for(uint i = 0; i < REALLY_MAX_TEAMS; i++)

	mov	DWORD PTR _i$226564[ebp], 0
	jmp	SHORT $LN12@write
$LN11@write:
	mov	eax, DWORD PTR _i$226564[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226564[ebp], eax
$LN12@write:
	cmp	DWORD PTR _i$226564[ebp], 80		; 00000050H
	jae	SHORT $LN10@write

; 10455: 		kStream << m_aeRevealedRouteType[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	eax, DWORD PTR _i$226564[ebp]
	lea	ecx, DWORD PTR [edx+eax*2]
	mov	DWORD PTR $T255579[ebp], ecx
	mov	edx, DWORD PTR $T255579[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write
	jmp	SHORT $LN11@write
$LN10@write:

; 10456: 
; 10457: 	for(uint i = 0; i < MAX_MAJOR_CIVS; i++)

	mov	DWORD PTR _i$226568[ebp], 0
	jmp	SHORT $LN9@write
$LN8@write:
	mov	eax, DWORD PTR _i$226568[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226568[ebp], eax
$LN9@write:
	cmp	DWORD PTR _i$226568[ebp], 22		; 00000016H
	jae	SHORT $LN7@write

; 10458: 		kStream << m_abNoSettling[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+172]
	add	edx, DWORD PTR _i$226568[ebp]
	mov	DWORD PTR $T255583[ebp], edx
	mov	eax, DWORD PTR $T255583[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	jmp	SHORT $LN8@write
$LN7@write:

; 10459: 
; 10460: 	// char * should have died in 1989...
; 10461: 	bool hasScriptData = (m_szScriptData != NULL);

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+180], 0
	setne	dl
	mov	BYTE PTR _hasScriptData$[ebp], dl

; 10462: 	kStream << hasScriptData;

	lea	eax, DWORD PTR _hasScriptData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 10463: 	if(hasScriptData)

	movzx	ecx, BYTE PTR _hasScriptData$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@write

; 10464: 	{
; 10465: 		const std::string scriptData(m_szScriptData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	lea	ecx, DWORD PTR _scriptData$226574[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 10466: 		kStream << scriptData;

	lea	ecx, DWORD PTR _scriptData$226574[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; operator<<
	add	esp, 8

; 10467: 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _scriptData$226574[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@write:

; 10468: 
; 10469: 	if(NULL == m_paiBuildProgress)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+184], 0
	jne	SHORT $LN5@write

; 10470: 	{
; 10471: 		kStream << (int)0;

	mov	DWORD PTR $T255393[ebp], 0
	lea	ecx, DWORD PTR $T255393[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10472: 	}
; 10473: 	else

	jmp	SHORT $LN4@write
$LN5@write:

; 10474: 	{
; 10475: 		kStream << (int)GC.getNumBuildInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	mov	DWORD PTR $T255394[ebp], eax
	lea	edx, DWORD PTR $T255394[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10476: 		BuildArrayHelpers::Write(kStream, m_paiBuildProgress, GC.getNumBuildInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Write@BuildArrayHelpers@@YAXAAVFDataStream@@PAFH@Z ; BuildArrayHelpers::Write
	add	esp, 12					; 0000000cH
$LN4@write:

; 10477: 	}
; 10478: 
; 10479: 	kStream << m_apaiInvisibleVisibilityCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 196				; 000000c4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z ; operator<<<short const [1],80>
	add	esp, 8

; 10480: 
; 10481: 	//  Write m_units.Write(kStream);
; 10482: 	UINT uLength = (UINT)m_units.getLength();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T255597[ebp], eax
	mov	ecx, DWORD PTR $T255597[ebp]
	mov	DWORD PTR _uLength$[ebp], ecx

; 10483: 	kStream << uLength;

	lea	edx, DWORD PTR _uLength$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 10484: 	for(UINT uIdx = 0; uIdx < uLength; ++uIdx)

	mov	DWORD PTR _uIdx$226605[ebp], 0
	jmp	SHORT $LN3@write
$LN2@write:
	mov	eax, DWORD PTR _uIdx$226605[ebp]
	add	eax, 1
	mov	DWORD PTR _uIdx$226605[ebp], eax
$LN3@write:
	mov	ecx, DWORD PTR _uIdx$226605[ebp]
	cmp	ecx, DWORD PTR _uLength$[ebp]
	jae	SHORT $LN1@write

; 10485: 	{
; 10486: 		const IDInfo* pData = m_units.getAt(uIdx);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T255621[ebp], edx
	mov	eax, DWORD PTR $T255621[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T255609[ebp], ecx
	mov	edx, DWORD PTR _uIdx$226605[ebp]
	cmp	edx, DWORD PTR $T255609[ebp]
	jae	SHORT $LN173@write
	mov	eax, DWORD PTR $T255621[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _uIdx$226605[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _pData$226609[ebp], eax
	jmp	SHORT $LN174@write
	jmp	SHORT $LN174@write
$LN173@write:
	mov	DWORD PTR _pData$226609[ebp], 0
$LN174@write:

; 10487: 
; 10488: 		kStream << pData->eOwner;

	mov	ecx, DWORD PTR _pData$226609[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 10489: 		kStream << pData->iID;

	mov	eax, DWORD PTR _pData$226609[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 10490: 	}

	jmp	SHORT $LN2@write
$LN1@write:

; 10491: 
; 10492: 	kStream << m_cContinentType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 459				; 000001cbH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 10493: 	kStream << m_kArchaeologyData;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 464				; 000001d0H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABUCvArchaeologyData@@@Z ; operator<<
	add	esp, 8

; 10494: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?write@CvPlot@@QBEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _scriptData$226574[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?write@CvPlot@@QBEXAAVFDataStream@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?write@CvPlot@@QBEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?write@CvPlot@@QBEXAAVFDataStream@@@Z ENDP		; CvPlot::write
; Function compile flags: /Odtp
;	COMDAT ?setLayoutDirty@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
$T255639 = -4						; size = 4
_bDirty$ = 8						; size = 1
?setLayoutDirty@CvPlot@@QAEX_N@Z PROC			; CvPlot::setLayoutDirty, COMDAT
; _this$ = ecx

; 10498: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 10499: 	if(bDirty == true)

	movzx	eax, BYTE PTR _bDirty$[ebp]
	cmp	eax, 1
	jne	SHORT $LN1@setLayoutD

; 10500: 	{
; 10501: 		GC.GetEngineUserInterface()->setDirty(PlotData_DIRTY_BIT,true);

	mov	ecx, DWORD PTR $T255639[ebp]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv73[ebp], edx
	push	1
	push	33					; 00000021H
	mov	eax, DWORD PTR tv73[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv73[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN1@setLayoutD:

; 10502: 	}
; 10503: 	m_bPlotLayoutDirty = bDirty;

	mov	cl, BYTE PTR _bDirty$[ebp]
	and	cl, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	and	al, 254					; 000000feH
	or	al, cl
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+462], al

; 10504: }

	mov	esp, ebp
	pop	ebp
	ret	4
?setLayoutDirty@CvPlot@@QAEX_N@Z ENDP			; CvPlot::setLayoutDirty
_TEXT	ENDS
PUBLIC	?isLayoutDirty@CvPlot@@QBE_NXZ			; CvPlot::isLayoutDirty
; Function compile flags: /Odtp
;	COMDAT ?isLayoutDirty@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isLayoutDirty@CvPlot@@QBE_NXZ PROC			; CvPlot::isLayoutDirty, COMDAT
; _this$ = ecx

; 10508: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 10509: 	return m_bPlotLayoutDirty;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	and	al, 1

; 10510: }

	mov	esp, ebp
	pop	ebp
	ret	0
?isLayoutDirty@CvPlot@@QBE_NXZ ENDP			; CvPlot::isLayoutDirty
_TEXT	ENDS
PUBLIC	?updateLayout@CvPlot@@QAEX_N@Z			; CvPlot::updateLayout
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
xdata$x	SEGMENT
__unwindtable$?updateLayout@CvPlot@@QAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$1
__ehfuncinfo$?updateLayout@CvPlot@@QAEX_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?updateLayout@CvPlot@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?updateLayout@CvPlot@@QAEX_N@Z
_TEXT	SEGMENT
tv218 = -140						; size = 4
tv208 = -136						; size = 4
tv192 = -132						; size = 4
tv148 = -128						; size = 4
tv78 = -124						; size = 4
_this$ = -120						; size = 4
_inst$255683 = -116					; size = 4
$T255679 = -112						; size = 4
$T255667 = -108						; size = 4
$T255655 = -100						; size = 4
$T255647 = -96						; size = 4
$T255646 = -92						; size = 4
_eInnerRoute$226690 = -88				; size = 4
_iProgress$226693 = -84					; size = 4
_eBuild$226686 = -80					; size = 4
_build$226688 = -76					; size = 4
_iBuildIndex$226682 = -72				; size = 4
_eInnerImprovement$226654 = -68				; size = 4
_iProgress$226657 = -64					; size = 4
_eBuild$226650 = -60					; size = 4
_build$226652 = -56					; size = 4
_iBuildIndex$226646 = -52				; size = 4
_eThisImprovement$ = -48				; size = 4
_eThisResource$ = -44					; size = 4
_eRoadTypeValue$ = -37					; size = 1
_eActiveTeam$ = -36					; size = 4
_eFOWMode$ = -32					; size = 4
_bShowHalfBuilt$ = -25					; size = 1
_eRoute$ = -24						; size = 4
_improvementState$ = -20				; size = 4
_pDllPlot$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bDebug$ = 8						; size = 1
?updateLayout@CvPlot@@QAEX_N@Z PROC			; CvPlot::updateLayout, COMDAT
; _this$ = ecx

; 10531: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?updateLayout@CvPlot@@QAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 10532: 	TeamTypes eActiveTeam = GC.getGame().getActiveTeam();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255655[ebp], eax
	mov	ecx, DWORD PTR $T255655[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR _eActiveTeam$[ebp], eax

; 10533: 
; 10534: 	FogOfWarModeTypes eFOWMode = GetActiveFogOfWarMode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode
	mov	DWORD PTR _eFOWMode$[ebp], eax

; 10535: 
; 10536: 	ResourceTypes eThisResource = (isCity() || eFOWMode == FOGOFWARMODE_UNEXPLORED) ? NO_RESOURCE : getResourceType(eActiveTeam);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN39@updateLayo
	cmp	DWORD PTR _eFOWMode$[ebp], 1
	je	SHORT $LN39@updateLayo
	mov	edx, DWORD PTR _eActiveTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN40@updateLayo
$LN39@updateLayo:
	mov	DWORD PTR tv78[ebp], -1
$LN40@updateLayo:
	mov	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR _eThisResource$[ebp], eax

; 10537: 
; 10538: 	ImprovementTypes eThisImprovement = getRevealedImprovementType(eActiveTeam, bDebug);

	movzx	ecx, BYTE PTR _bDebug$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eActiveTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
	mov	DWORD PTR _eThisImprovement$[ebp], eax

; 10539: 	bool bShowHalfBuilt = false;

	mov	BYTE PTR _bShowHalfBuilt$[ebp], 0

; 10540: 	if(eThisImprovement == NO_IMPROVEMENT && getAnyBuildProgress() && eFOWMode == FOGOFWARMODE_OFF)

	cmp	DWORD PTR _eThisImprovement$[ebp], -1
	jne	$LN36@updateLayo
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getAnyBuildProgress@CvPlot@@QBE_NXZ	; CvPlot::getAnyBuildProgress
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN36@updateLayo
	cmp	DWORD PTR _eFOWMode$[ebp], 0
	jne	SHORT $LN36@updateLayo

; 10541: 	{
; 10542: 		// see if we are improving the tile
; 10543: #ifdef AUI_WARNING_FIXES
; 10544: 		for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 10545: #else
; 10546: 		for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$226646[ebp], 0
	jmp	SHORT $LN35@updateLayo
$LN34@updateLayo:
	mov	ecx, DWORD PTR _iBuildIndex$226646[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBuildIndex$226646[ebp], ecx
$LN35@updateLayo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$226646[ebp], eax
	jge	SHORT $LN36@updateLayo

; 10547: #endif
; 10548: 		{
; 10549: 			BuildTypes eBuild = (BuildTypes)iBuildIndex;

	mov	edx, DWORD PTR _iBuildIndex$226646[ebp]
	mov	DWORD PTR _eBuild$226650[ebp], edx

; 10550: 			CvBuildInfo* build = GC.getBuildInfo(eBuild);

	mov	eax, DWORD PTR _eBuild$226650[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _build$226652[ebp], eax

; 10551: 			if(build)

	cmp	DWORD PTR _build$226652[ebp], 0
	je	SHORT $LN32@updateLayo

; 10552: 			{
; 10553: 				ImprovementTypes eInnerImprovement = (ImprovementTypes)build->getImprovement();

	mov	ecx, DWORD PTR _build$226652[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eInnerImprovement$226654[ebp], eax

; 10554: 				if(eInnerImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eInnerImprovement$226654[ebp], -1
	jne	SHORT $LN31@updateLayo

; 10555: 				{
; 10556: 					continue;

	jmp	SHORT $LN34@updateLayo
$LN31@updateLayo:

; 10557: 				}
; 10558: 
; 10559: 				int iProgress = getBuildProgress(eBuild);

	mov	ecx, DWORD PTR _eBuild$226650[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress
	mov	DWORD PTR _iProgress$226657[ebp], eax

; 10560: 				if(iProgress > 0)

	cmp	DWORD PTR _iProgress$226657[ebp], 0
	jle	SHORT $LN32@updateLayo

; 10561: 				{
; 10562: 					eThisImprovement = eInnerImprovement;

	mov	edx, DWORD PTR _eInnerImprovement$226654[ebp]
	mov	DWORD PTR _eThisImprovement$[ebp], edx

; 10563: 					bShowHalfBuilt = true;

	mov	BYTE PTR _bShowHalfBuilt$[ebp], 1

; 10564: 					break;

	jmp	SHORT $LN36@updateLayo
$LN32@updateLayo:

; 10565: 				}
; 10566: 			}
; 10567: 
; 10568: 		}

	jmp	SHORT $LN34@updateLayo
$LN36@updateLayo:

; 10569: 	}
; 10570: 
; 10571: 	int improvementState = 2; // half-built = 1, full built = 2, pillaged = 3

	mov	DWORD PTR _improvementState$[ebp], 2

; 10572: 	if(IsImprovementPillaged() && eFOWMode == FOGOFWARMODE_OFF)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@updateLayo
	cmp	DWORD PTR _eFOWMode$[ebp], 0
	jne	SHORT $LN29@updateLayo

; 10573: 	{
; 10574: 		improvementState = 3;

	mov	DWORD PTR _improvementState$[ebp], 3
	jmp	SHORT $LN28@updateLayo
$LN29@updateLayo:

; 10575: 	}
; 10576: 	else if(bShowHalfBuilt)

	movzx	ecx, BYTE PTR _bShowHalfBuilt$[ebp]
	test	ecx, ecx
	je	SHORT $LN28@updateLayo

; 10577: 	{
; 10578: 		improvementState = 1;

	mov	DWORD PTR _improvementState$[ebp], 1
$LN28@updateLayo:

; 10579: 	}
; 10580: 
; 10581: 	RouteTypes eRoute = getRevealedRouteType(eActiveTeam, bDebug);

	movzx	edx, BYTE PTR _bDebug$[ebp]
	push	edx
	mov	eax, DWORD PTR _eActiveTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedRouteType
	mov	DWORD PTR _eRoute$[ebp], eax

; 10582: 	byte eRoadTypeValue = NUM_ROAD_RR_TYPES;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 8

; 10583: 	if(eRoute != NO_ROUTE)

	cmp	DWORD PTR _eRoute$[ebp], -1
	je	SHORT $LN26@updateLayo

; 10584: 	{
; 10585: 		switch(eRoute)

	mov	ecx, DWORD PTR _eRoute$[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	cmp	DWORD PTR tv148[ebp], 0
	je	SHORT $LN23@updateLayo
	cmp	DWORD PTR tv148[ebp], 1
	je	SHORT $LN18@updateLayo
	jmp	SHORT $LN24@updateLayo
$LN23@updateLayo:

; 10586: 		{
; 10587: 		case ROUTE_ROAD:
; 10588: 			if(IsRoutePillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@updateLayo

; 10589: 			{
; 10590: 				eRoadTypeValue = ROAD_PILLAGED;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 2
	jmp	SHORT $LN21@updateLayo
$LN22@updateLayo:

; 10591: 			}
; 10592: 			else if(IsTradeRoute())

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@updateLayo

; 10593: 			{
; 10594: 				eRoadTypeValue = ROAD_TRADE_ROUTE;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 6

; 10595: 			}
; 10596: 			else

	jmp	SHORT $LN21@updateLayo
$LN20@updateLayo:

; 10597: 			{
; 10598: 				eRoadTypeValue = ROAD_REGULAR;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 0
$LN21@updateLayo:

; 10599: 			}
; 10600: 			break;

	jmp	SHORT $LN24@updateLayo
$LN18@updateLayo:

; 10601: 		case ROUTE_RAILROAD:
; 10602: 			if(IsRoutePillaged())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@updateLayo

; 10603: 			{
; 10604: 				eRoadTypeValue = RR_PILLAGED;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 3
	jmp	SHORT $LN24@updateLayo
$LN17@updateLayo:

; 10605: 			}
; 10606: 			else if(IsTradeRoute())

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@updateLayo

; 10607: 			{
; 10608: 				eRoadTypeValue = RR_TRADE_ROUTE;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 7

; 10609: 			}
; 10610: 			else

	jmp	SHORT $LN24@updateLayo
$LN15@updateLayo:

; 10611: 			{
; 10612: 				eRoadTypeValue = RR_REGULAR;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 1
$LN24@updateLayo:

; 10613: 			}
; 10614: 			break;
; 10615: 		}
; 10616: 	}
; 10617: 	else

	jmp	$LN13@updateLayo
$LN26@updateLayo:

; 10618: 	{
; 10619: 		bShowHalfBuilt = false;

	mov	BYTE PTR _bShowHalfBuilt$[ebp], 0

; 10620: #ifdef AUI_WARNING_FIXES
; 10621: 		if (getAnyBuildProgress() && eFOWMode == FOGOFWARMODE_OFF)
; 10622: 		{
; 10623: 			for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 10624: #else
; 10625: 		if(eRoute == NO_ROUTE && getAnyBuildProgress() && eFOWMode == FOGOFWARMODE_OFF)

	cmp	DWORD PTR _eRoute$[ebp], -1
	jne	$LN12@updateLayo
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getAnyBuildProgress@CvPlot@@QBE_NXZ	; CvPlot::getAnyBuildProgress
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@updateLayo
	cmp	DWORD PTR _eFOWMode$[ebp], 0
	jne	SHORT $LN12@updateLayo

; 10626: 		{
; 10627: 			// see if we are improving the tile
; 10628: 			for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$226682[ebp], 0
	jmp	SHORT $LN11@updateLayo
$LN10@updateLayo:
	mov	ecx, DWORD PTR _iBuildIndex$226682[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBuildIndex$226682[ebp], ecx
$LN11@updateLayo:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$226682[ebp], eax
	jge	SHORT $LN12@updateLayo

; 10629: #endif
; 10630: 			{
; 10631: 				BuildTypes eBuild = (BuildTypes)iBuildIndex;

	mov	edx, DWORD PTR _iBuildIndex$226682[ebp]
	mov	DWORD PTR _eBuild$226686[ebp], edx

; 10632: 				CvBuildInfo* build = GC.getBuildInfo(eBuild);

	mov	eax, DWORD PTR _eBuild$226686[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _build$226688[ebp], eax

; 10633: 				if(build)

	cmp	DWORD PTR _build$226688[ebp], 0
	je	SHORT $LN8@updateLayo

; 10634: 				{
; 10635: 					RouteTypes eInnerRoute = (RouteTypes)build->getRoute();

	mov	ecx, DWORD PTR _build$226688[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eInnerRoute$226690[ebp], eax

; 10636: 					if(eInnerRoute == NO_ROUTE)

	cmp	DWORD PTR _eInnerRoute$226690[ebp], -1
	jne	SHORT $LN7@updateLayo

; 10637: 					{
; 10638: 						continue;

	jmp	SHORT $LN10@updateLayo
$LN7@updateLayo:

; 10639: 					}
; 10640: 
; 10641: 					int iProgress = getBuildProgress(eBuild);

	mov	ecx, DWORD PTR _eBuild$226686[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress
	mov	DWORD PTR _iProgress$226693[ebp], eax

; 10642: 					if(iProgress > 0)

	cmp	DWORD PTR _iProgress$226693[ebp], 0
	jle	SHORT $LN8@updateLayo

; 10643: 					{
; 10644: 						eRoute = eInnerRoute;

	mov	edx, DWORD PTR _eInnerRoute$226690[ebp]
	mov	DWORD PTR _eRoute$[ebp], edx

; 10645: 						bShowHalfBuilt = true;

	mov	BYTE PTR _bShowHalfBuilt$[ebp], 1

; 10646: 						break;

	jmp	SHORT $LN12@updateLayo
$LN8@updateLayo:

; 10647: 					}
; 10648: 				}
; 10649: 
; 10650: 			}

	jmp	SHORT $LN10@updateLayo
$LN12@updateLayo:

; 10651: 		}
; 10652: 		if(bShowHalfBuilt)

	movzx	eax, BYTE PTR _bShowHalfBuilt$[ebp]
	test	eax, eax
	je	SHORT $LN13@updateLayo

; 10653: 		{
; 10654: 			switch(eRoute)

	mov	ecx, DWORD PTR _eRoute$[ebp]
	mov	DWORD PTR tv192[ebp], ecx
	cmp	DWORD PTR tv192[ebp], 0
	je	SHORT $LN2@updateLayo
	cmp	DWORD PTR tv192[ebp], 1
	je	SHORT $LN1@updateLayo
	jmp	SHORT $LN13@updateLayo
$LN2@updateLayo:

; 10655: 			{
; 10656: 			case ROUTE_ROAD:
; 10657: 				eRoadTypeValue = ROAD_UNDER_CONSTRUCTION;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 4

; 10658: 				break;

	jmp	SHORT $LN13@updateLayo
$LN1@updateLayo:

; 10659: 			case ROUTE_RAILROAD:
; 10660: 				eRoadTypeValue = RR_UNDER_CONSTRUCTION;

	mov	BYTE PTR _eRoadTypeValue$[ebp], 5
$LN13@updateLayo:

; 10661: 				break;
; 10662: 			}
; 10663: 		}
; 10664: 	}
; 10665: 
; 10666: 	auto_ptr<ICvPlot1> pDllPlot(new CvDllPlot(this));

	push	12					; 0000000cH
	call	??2CvDllPlot@@SAPAXI@Z			; CvDllPlot::operator new
	add	esp, 4
	mov	DWORD PTR $T255647[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T255647[ebp], 0
	je	SHORT $LN41@updateLayo
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T255647[ebp]
	call	??0CvDllPlot@@QAE@PAVCvPlot@@@Z		; CvDllPlot::CvDllPlot
	mov	DWORD PTR tv208[ebp], eax
	jmp	SHORT $LN42@updateLayo
$LN41@updateLayo:
	mov	DWORD PTR tv208[ebp], 0
$LN42@updateLayo:
	mov	eax, DWORD PTR tv208[ebp]
	mov	DWORD PTR $T255646[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T255646[ebp]
	mov	DWORD PTR _pDllPlot$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 10667: 	gDLL->GameplayPlotStateChange
; 10668: 	(
; 10669: 	    pDllPlot.get(),
; 10670: 	    eThisResource,
; 10671: 	    eThisImprovement,
; 10672: 	    improvementState,
; 10673: 	    eRoute,
; 10674: 	    eRoadTypeValue
; 10675: 	);

	mov	edx, DWORD PTR $T255667[ebp]
	mov	DWORD PTR tv218[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv218[ebp], eax
	movzx	ecx, BYTE PTR _eRoadTypeValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	eax, DWORD PTR _improvementState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eThisImprovement$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThisResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDllPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv218[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv218[ebp]
	mov	eax, DWORD PTR [edx+692]
	call	eax

; 10676: }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pDllPlot$[ebp]
	mov	DWORD PTR $T255679[ebp], ecx
	cmp	DWORD PTR $T255679[ebp], 0
	je	SHORT $LN37@updateLayo
	mov	edx, DWORD PTR $T255679[ebp]
	mov	DWORD PTR _inst$255683[ebp], edx
	mov	eax, DWORD PTR _inst$255683[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$255683[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN37@updateLayo:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$0:
	mov	eax, DWORD PTR $T255647[ebp]
	push	eax
	call	??3CvDllPlot@@SAXPAX@Z			; CvDllPlot::operator delete
	pop	ecx
	ret	0
__unwindfunclet$?updateLayout@CvPlot@@QAEX_N@Z$1:
	lea	ecx, DWORD PTR _pDllPlot$[ebp]
	jmp	??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ	; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
__ehhandler$?updateLayout@CvPlot@@QAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?updateLayout@CvPlot@@QAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?updateLayout@CvPlot@@QAEX_N@Z ENDP			; CvPlot::updateLayout
PUBLIC	?isLayoutStateDifferent@CvPlot@@QBE_NXZ		; CvPlot::isLayoutStateDifferent
; Function compile flags: /Odtp
;	COMDAT ?isLayoutStateDifferent@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isLayoutStateDifferent@CvPlot@@QBE_NXZ PROC		; CvPlot::isLayoutStateDifferent, COMDAT
; _this$ = ecx

; 10680: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 10681: 	return (m_bLayoutStateWorked != isBeingWorked());

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 1
	and	cl, 1
	movzx	esi, cl
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	movzx	edx, al
	xor	eax, eax
	cmp	esi, edx
	setne	al

; 10682: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?isLayoutStateDifferent@CvPlot@@QBE_NXZ ENDP		; CvPlot::isLayoutStateDifferent
_TEXT	ENDS
PUBLIC	?setLayoutStateToCurrent@CvPlot@@QAEXXZ		; CvPlot::setLayoutStateToCurrent
; Function compile flags: /Odtp
;	COMDAT ?setLayoutStateToCurrent@CvPlot@@QAEXXZ
_TEXT	SEGMENT
tv67 = -5						; size = 1
_this$ = -4						; size = 4
?setLayoutStateToCurrent@CvPlot@@QAEXXZ PROC		; CvPlot::setLayoutStateToCurrent, COMDAT
; _this$ = ecx

; 10686: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 10687: 	m_bLayoutStateWorked = isBeingWorked();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	mov	BYTE PTR tv67[ebp], al
	mov	al, BYTE PTR tv67[ebp]
	and	al, 1
	shl	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 253					; 000000fdH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl

; 10688: }

	mov	esp, ebp
	pop	ebp
	ret	0
?setLayoutStateToCurrent@CvPlot@@QAEXXZ ENDP		; CvPlot::setLayoutStateToCurrent
_TEXT	ENDS
PUBLIC	?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z ; CvPlot::getVisibleImprovementState
; Function compile flags: /Odtp
;	COMDAT ?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T255704 = -8						; size = 4
$T255700 = -4						; size = 4
_eType$ = 8						; size = 4
_bWorked$ = 12						; size = 4
?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z PROC ; CvPlot::getVisibleImprovementState, COMDAT
; _this$ = ecx

; 10693: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 10694: 	eType = NO_IMPROVEMENT;

	mov	eax, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [eax], -1

; 10695: 	bWorked = false;

	mov	ecx, DWORD PTR _bWorked$[ebp]
	mov	BYTE PTR [ecx], 0

; 10696: 
; 10697: 	if(GC.getGame().getActiveTeam() == NO_TEAM)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255700[ebp], edx
	mov	ecx, DWORD PTR $T255700[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, -1
	jne	SHORT $LN2@getVisible@2

; 10698: 	{
; 10699: 		return;

	jmp	SHORT $LN3@getVisible@2
$LN2@getVisible@2:

; 10700: 	}
; 10701: 
; 10702: 	eType = getRevealedImprovementType(GC.getGame().getActiveTeam(), true);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255704[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T255704[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
	mov	ecx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [ecx], eax

; 10703: 
; 10704: 	// worked state
; 10705: 	if(isActiveVisible(false) && isBeingWorked())

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@getVisible@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@getVisible@2

; 10706: 	{
; 10707: 		bWorked = true;

	mov	ecx, DWORD PTR _bWorked$[ebp]
	mov	BYTE PTR [ecx], 1
$LN3@getVisible@2:

; 10708: 	}
; 10709: }

	mov	esp, ebp
	pop	ebp
	ret	8
?getVisibleImprovementState@CvPlot@@QAEXAAW4ImprovementTypes@@AA_N@Z ENDP ; CvPlot::getVisibleImprovementState
_TEXT	ENDS
PUBLIC	?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z ; CvPlot::getVisibleResourceState
; Function compile flags: /Odtp
;	COMDAT ?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T255737 = -32						; size = 4
$T255733 = -28						; size = 4
$T255729 = -24						; size = 4
_uiOffset$255727 = -20					; size = 4
$T255718 = -16						; size = 4
$T255714 = -12						; size = 4
$T255710 = -8						; size = 4
_eRevealedImprovement$226732 = -4			; size = 4
_eType$ = 8						; size = 4
_bImproved$ = 12					; size = 4
_bWorked$ = 16						; size = 4
?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z PROC ; CvPlot::getVisibleResourceState, COMDAT
; _this$ = ecx

; 10713: {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 10714: 	eType = NO_RESOURCE;

	mov	eax, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [eax], -1

; 10715: 	bImproved = false;

	mov	ecx, DWORD PTR _bImproved$[ebp]
	mov	BYTE PTR [ecx], 0

; 10716: 	bWorked = false;

	mov	edx, DWORD PTR _bWorked$[ebp]
	mov	BYTE PTR [edx], 0

; 10717: 
; 10718: 	if(GC.getGame().getActiveTeam() == NO_TEAM)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255710[ebp], eax
	mov	ecx, DWORD PTR $T255710[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	eax, -1
	jne	SHORT $LN6@getVisible@3

; 10719: 	{
; 10720: 		return;

	jmp	$LN7@getVisible@3
$LN6@getVisible@3:

; 10721: 	}
; 10722: 
; 10723: 	if(GC.getGame().isDebugMode())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255714[ebp], ecx
	mov	ecx, DWORD PTR $T255714[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@getVisible@3

; 10724: 	{
; 10725: 		eType = getResourceType();

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	ecx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN4@getVisible@3
$LN5@getVisible@3:

; 10726: 	}
; 10727: 	else if(isRevealed(GC.getGame().getActiveTeam()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255718[ebp], edx
	mov	ecx, DWORD PTR $T255718[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	DWORD PTR $T255729[ebp], eax
	mov	eax, DWORD PTR $T255729[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$255727[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$255727[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T255729[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$255727[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@getVisible@3

; 10728: 	{
; 10729: 		eType = getResourceType(GC.getGame().getActiveTeam());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255733[ebp], edx
	mov	ecx, DWORD PTR $T255733[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	ecx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@getVisible@3:

; 10730: 	}
; 10731: 
; 10732: 	// improved and worked states ...
; 10733: 	if(eType != NO_RESOURCE)

	mov	edx, DWORD PTR _eType$[ebp]
	cmp	DWORD PTR [edx], -1
	je	SHORT $LN7@getVisible@3

; 10734: 	{
; 10735: 		ImprovementTypes eRevealedImprovement = getRevealedImprovementType(GC.getGame().getActiveTeam(), true);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255737[ebp], eax
	push	1
	mov	ecx, DWORD PTR $T255737[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
	mov	DWORD PTR _eRevealedImprovement$226732[ebp], eax

; 10736: 
; 10737: 		if((eRevealedImprovement != NO_IMPROVEMENT) && GC.getImprovementInfo(eRevealedImprovement)->IsImprovementResourceTrade(eType))

	cmp	DWORD PTR _eRevealedImprovement$226732[ebp], -1
	je	SHORT $LN7@getVisible@3
	mov	ecx, DWORD PTR _eType$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _eRevealedImprovement$226732[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@getVisible@3

; 10738: 		{
; 10739: 			bImproved = true;

	mov	edx, DWORD PTR _bImproved$[ebp]
	mov	BYTE PTR [edx], 1

; 10740: 			bWorked = isBeingWorked();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	mov	ecx, DWORD PTR _bWorked$[ebp]
	mov	BYTE PTR [ecx], al
$LN7@getVisible@3:

; 10741: 		}
; 10742: 	}
; 10743: }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getVisibleResourceState@CvPlot@@QAEXAAW4ResourceTypes@@AA_N1@Z ENDP ; CvPlot::getVisibleResourceState
_TEXT	ENDS
PUBLIC	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
; Function compile flags: /Odtp
;	COMDAT ?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
tv791 = -268						; size = 4
tv513 = -264						; size = 4
_this$ = -260						; size = 4
$T256006 = -256						; size = 4
$T255997 = -252						; size = 4
$T255996 = -248						; size = 4
$T255992 = -244						; size = 4
$T255988 = -240						; size = 4
$T255984 = -236						; size = 4
$T255980 = -232						; size = 4
$T255976 = -228						; size = 4
$T255972 = -224						; size = 4
$T255968 = -220						; size = 4
$T255964 = -216						; size = 4
$T255960 = -212						; size = 4
$T255956 = -208						; size = 4
$T255952 = -204						; size = 4
$T255948 = -200						; size = 4
$T255944 = -196						; size = 4
$T255940 = -192						; size = 4
$T255934 = -188						; size = 4
$T255927 = -184						; size = 4
$T255926 = -180						; size = 4
$T255922 = -176						; size = 4
$T255918 = -172						; size = 4
$T255917 = -168						; size = 4
$T255913 = -164						; size = 4
$T255909 = -160						; size = 4
$T255905 = -156						; size = 4
$T255901 = -152						; size = 4
$T255892 = -148						; size = 4
$T255888 = -144						; size = 4
_f$255872 = -138					; size = 1
_f$255863 = -137					; size = 1
$T255845 = -136						; size = 4
$T255836 = -132						; size = 4
$T255832 = -128						; size = 4
$T255814 = -120						; size = 4
$T255810 = -116						; size = 4
$T255806 = -112						; size = 4
$T255802 = -108						; size = 4
$T255795 = -104						; size = 4
$T255791 = -100						; size = 4
_playerID$255783 = -96					; size = 4
_f$255771 = -90						; size = 1
_f$255762 = -89						; size = 1
$T255745 = -88						; size = 4
$T255741 = -84						; size = 4
$T255740 = -80						; size = 4
_iPerPopYield$226826 = -76				; size = 4
_iTemp$226823 = -72					; size = 4
_pkResourceInfo$226811 = -68				; size = 4
_iCityYield$226793 = -64				; size = 4
_pWorkingCity$226788 = -60				; size = 4
_eResource$226809 = -56					; size = 4
_iI$226778 = -52					; size = 4
_iAdjacentCulture$226769 = -48				; size = 4
_pImprovement$226767 = -44				; size = 4
_eUpgradeImprovement2$226762 = -40			; size = 4
_eUpgradeImprovement$226757 = -36			; size = 4
_eImprovement$ = -32					; size = 4
_kYield$ = -28						; size = 4
_eRoute$ = -24						; size = 4
_bCity$ = -17						; size = 1
_iYield$ = -16						; size = 4
_pCity$ = -12						; size = 4
_bIgnoreFeature$ = -5					; size = 1
_eTeam$ = -4						; size = 4
_eBuild$ = 8						; size = 4
_eYield$ = 12						; size = 4
_bWithUpgrade$ = 16					; size = 1
_ePlayer$ = 20						; size = 4
?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z PROC ; CvPlot::getYieldWithBuild, COMDAT
; _this$ = ecx

; 10747: {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 10748: 	int iYield;
; 10749: 
; 10750: 	const CvYieldInfo& kYield = *GC.getYieldInfo(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getYieldInfo@CvGlobals@@QAEPAVCvYieldInfo@@W4YieldTypes@@@Z ; CvGlobals::getYieldInfo
	mov	DWORD PTR _kYield$[ebp], eax

; 10751: 	TeamTypes eTeam = GET_PLAYER(ePlayer).getTeam();

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255745[ebp], ecx
	mov	edx, DWORD PTR $T255745[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 10752: 
; 10753: 	if(getTerrainType() == NO_TERRAIN)

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	cmp	edx, -1
	jne	SHORT $LN66@getYieldWi

; 10754: 		return 0;

	xor	eax, eax
	jmp	$LN67@getYieldWi
$LN66@getYieldWi:

; 10755: 
; 10756: 	if(!isPotentialCityWork())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPotentialCityWork@CvPlot@@QBE_NXZ	; CvPlot::isPotentialCityWork
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN65@getYieldWi

; 10757: 		return 0;

	xor	eax, eax
	jmp	$LN67@getYieldWi
$LN65@getYieldWi:

; 10758: 
; 10759: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IGNORE_FEATURE_EXTENDS_TO_CITY
; 10760: 	CvCity* pCity = getPlotCity();
; 10761: 	bool bCity = pCity != NULL;
; 10762: 
; 10763: 	// Will the build remove the feature?
; 10764: 	bool bIgnoreFeature = bCity;
; 10765: #else
; 10766: 	bool bCity = false;

	mov	BYTE PTR _bCity$[ebp], 0

; 10767: 
; 10768: 	// Will the build remove the feature?
; 10769: 	bool bIgnoreFeature = false;

	mov	BYTE PTR _bIgnoreFeature$[ebp], 0

; 10770: #endif
; 10771: 	if(getFeatureType() != NO_FEATURE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$255762[ebp], dl
	movsx	eax, BYTE PTR _f$255762[ebp]
	cmp	eax, -1
	je	SHORT $LN89@getYieldWi

; 10772: 	{
; 10773: 		if(GC.getBuildInfo(eBuild)->isFeatureRemove(getFeatureType()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$255771[ebp], dl
	movsx	eax, BYTE PTR _f$255771[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN89@getYieldWi

; 10774: 			bIgnoreFeature = true;

	mov	BYTE PTR _bIgnoreFeature$[ebp], 1

; 10775: 	}
; 10776: 
; 10777: 	// Nature yield
; 10778: 	iYield = calculateNatureYield(eYield, getTeam(), bIgnoreFeature);

$LN89@getYieldWi:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$255783[ebp], ecx
	cmp	DWORD PTR _playerID$255783[ebp], -1
	je	SHORT $LN86@getYieldWi
	mov	edx, DWORD PTR _playerID$255783[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T255791[ebp], eax
	jmp	SHORT $LN87@getYieldWi
	jmp	SHORT $LN87@getYieldWi
$LN86@getYieldWi:
	mov	DWORD PTR $T255791[ebp], -1
$LN87@getYieldWi:
	movzx	eax, BYTE PTR _bIgnoreFeature$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255791[ebp]
	push	ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR _iYield$[ebp], eax

; 10779: 
; 10780: 	ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$[ebp], eax

; 10781: 
; 10782: 	// If we're not changing the improvement that's here, use the improvement that's here already
; 10783: 	if(eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	jne	SHORT $LN62@getYieldWi

; 10784: 	{
; 10785: 		if(!IsImprovementPillaged() || GC.getBuildInfo(eBuild)->isRepair())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN60@getYieldWi
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN62@getYieldWi
$LN60@getYieldWi:

; 10786: 		{
; 10787: 			eImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax
$LN62@getYieldWi:

; 10788: 		}
; 10789: 	}
; 10790: 
; 10791: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IMPROVEMENT_WITH_ROUTE
; 10792: 	RouteTypes eRoute = (RouteTypes)GC.getBuildInfo(eBuild)->getRoute();
; 10793: 
; 10794: 	// If we're not changing the route that's here, use the route that's here already
; 10795: 	if (eRoute == NO_ROUTE)
; 10796: 	{
; 10797: 		if (!IsRoutePillaged() || GC.getBuildInfo(eBuild)->isRepair())
; 10798: 		{
; 10799: 			eRoute = getRouteType();
; 10800: 		}
; 10801: 	}
; 10802: 
; 10803: 	if (eRoute != NO_ROUTE)
; 10804: 	{
; 10805: 		CvRouteInfo* pRouteInfo = GC.getRouteInfo(eRoute);
; 10806: 		if (pRouteInfo)
; 10807: 			iYield += pRouteInfo->getYieldChange(eYield);
; 10808: 	}
; 10809: #endif
; 10810: 
; 10811: 	if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	$LN59@getYieldWi

; 10812: 	{
; 10813: 		if(bWithUpgrade)

	movzx	ecx, BYTE PTR _bWithUpgrade$[ebp]
	test	ecx, ecx
	je	SHORT $LN58@getYieldWi

; 10814: 		{
; 10815: 			//in the case that improvements upgrade, use 2 upgrade levels higher for the
; 10816: 			//yield calculations.
; 10817: 			ImprovementTypes eUpgradeImprovement = (ImprovementTypes)GC.getImprovementInfo(eImprovement)->GetImprovementUpgrade();

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	mov	DWORD PTR _eUpgradeImprovement$226757[ebp], eax

; 10818: 			if(eUpgradeImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eUpgradeImprovement$226757[ebp], -1
	je	SHORT $LN57@getYieldWi

; 10819: 			{
; 10820: 				//unless it's trade on a low food tile, in which case only use 1 level higher
; 10821: 				if((eYield != YIELD_GOLD) || (getYield(YIELD_FOOD) >= GC.getFOOD_CONSUMPTION_PER_POPULATION()))

	cmp	DWORD PTR _eYield$[ebp], 2
	jne	SHORT $LN55@getYieldWi
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6328
	mov	DWORD PTR $T255795[ebp], eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	cmp	eax, DWORD PTR $T255795[ebp]
	jl	SHORT $LN57@getYieldWi
$LN55@getYieldWi:

; 10822: 				{
; 10823: 					ImprovementTypes eUpgradeImprovement2 = (ImprovementTypes)GC.getImprovementInfo(eUpgradeImprovement)->GetImprovementUpgrade();

	mov	ecx, DWORD PTR _eUpgradeImprovement$226757[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	mov	DWORD PTR _eUpgradeImprovement2$226762[ebp], eax

; 10824: 					if(eUpgradeImprovement2 != NO_IMPROVEMENT)

	cmp	DWORD PTR _eUpgradeImprovement2$226762[ebp], -1
	je	SHORT $LN57@getYieldWi

; 10825: 					{
; 10826: 						eUpgradeImprovement = eUpgradeImprovement2;

	mov	edx, DWORD PTR _eUpgradeImprovement2$226762[ebp]
	mov	DWORD PTR _eUpgradeImprovement$226757[ebp], edx
$LN57@getYieldWi:

; 10827: 					}
; 10828: 				}
; 10829: 			}
; 10830: 
; 10831: 			if((eUpgradeImprovement != NO_IMPROVEMENT) && (eUpgradeImprovement != eImprovement))

	cmp	DWORD PTR _eUpgradeImprovement$226757[ebp], -1
	je	SHORT $LN58@getYieldWi
	mov	eax, DWORD PTR _eUpgradeImprovement$226757[ebp]
	cmp	eax, DWORD PTR _eImprovement$[ebp]
	je	SHORT $LN58@getYieldWi

; 10832: 			{
; 10833: 				eImprovement = eUpgradeImprovement;

	mov	ecx, DWORD PTR _eUpgradeImprovement$226757[ebp]
	mov	DWORD PTR _eImprovement$[ebp], ecx
$LN58@getYieldWi:

; 10834: 			}
; 10835: 		}
; 10836: 
; 10837: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IMPROVEMENT_WITH_ROUTE
; 10838: 		iYield += calculateImprovementYieldChange(eImprovement, eYield, ePlayer, false, eRoute);
; 10839: #else
; 10840: 		iYield += calculateImprovementYieldChange(eImprovement, eYield, ePlayer, false);

	push	2
	push	0
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10841: #endif
; 10842: 
; 10843: 		if (eYield == YIELD_CULTURE && getOwner() != NO_PLAYER)

	cmp	DWORD PTR _eYield$[ebp], 4
	jne	$LN59@getYieldWi
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, -1
	je	$LN59@getYieldWi

; 10844: 		{
; 10845: 			CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovement$226767[ebp], eax

; 10846: 			if(pImprovement && pImprovement->GetYieldChange(YIELD_CULTURE) > 0)

	cmp	DWORD PTR _pImprovement$226767[ebp], 0
	je	SHORT $LN51@getYieldWi
	push	4
	mov	ecx, DWORD PTR _pImprovement$226767[ebp]
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN51@getYieldWi

; 10847: 			{
; 10848: 				int iAdjacentCulture = pImprovement->GetCultureAdjacentSameType();

	mov	ecx, DWORD PTR _pImprovement$226767[ebp]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	mov	DWORD PTR _iAdjacentCulture$226769[ebp], eax

; 10849: 				if(iAdjacentCulture > 0)

	cmp	DWORD PTR _iAdjacentCulture$226769[ebp], 0
	jle	SHORT $LN51@getYieldWi

; 10850: 				{
; 10851: 					iYield += ComputeCultureFromAdjacentImprovement(*pImprovement, eImprovement);

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	eax, DWORD PTR _pImprovement$226767[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN51@getYieldWi:

; 10852: 				}
; 10853: 			}
; 10854: 
; 10855: 			iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetNumericModifier(POLICYMOD_EXTRA_CULTURE_FROM_IMPROVEMENTS);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T255802[ebp], edx
	mov	eax, DWORD PTR $T255802[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255806[ebp], eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T255806[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10856: 			iYield += GET_PLAYER(getOwner()).GetPlayerPolicies()->GetImprovementCultureChange(eImprovement);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T255810[ebp], edx
	mov	eax, DWORD PTR $T255810[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255814[ebp], eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T255814[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ; CvPlayerPolicies::GetImprovementCultureChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN59@getYieldWi:

; 10857: 		}
; 10858: 	}
; 10859: 
; 10860: #ifndef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IMPROVEMENT_WITH_ROUTE
; 10861: 	RouteTypes eRoute = (RouteTypes)GC.getBuildInfo(eBuild)->getRoute();

	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eRoute$[ebp], eax

; 10862: 
; 10863: 	// If we're not changing the route that's here, use the route that's here already
; 10864: 	if(eRoute == NO_ROUTE)

	cmp	DWORD PTR _eRoute$[ebp], -1
	jne	SHORT $LN49@getYieldWi

; 10865: 	{
; 10866: 		if(!IsRoutePillaged() || GC.getBuildInfo(eBuild)->isRepair())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN47@getYieldWi
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN49@getYieldWi
$LN47@getYieldWi:

; 10867: 		{
; 10868: 			eRoute = getRouteType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	DWORD PTR _eRoute$[ebp], eax
$LN49@getYieldWi:

; 10869: 		}
; 10870: 	}
; 10871: 
; 10872: 	if(eRoute != NO_ROUTE)

	cmp	DWORD PTR _eRoute$[ebp], -1
	je	$LN46@getYieldWi

; 10873: 	{
; 10874: 		eImprovement = getImprovementType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 10875: 		if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN46@getYieldWi

; 10876: 		{
; 10877: 			for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)

	mov	DWORD PTR _iI$226778[ebp], 0
	jmp	SHORT $LN44@getYieldWi
$LN43@getYieldWi:
	mov	eax, DWORD PTR _iI$226778[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226778[ebp], eax
$LN44@getYieldWi:
	cmp	DWORD PTR _iI$226778[ebp], 6
	jge	SHORT $LN46@getYieldWi

; 10878: 			{
; 10879: 				iYield += GC.getImprovementInfo(eImprovement)->GetRouteYieldChanges(eRoute, iI);

	mov	ecx, DWORD PTR _iI$226778[ebp]
	push	ecx
	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10880: 				if(getRouteType() != NO_ROUTE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN41@getYieldWi

; 10881: 				{
; 10882: 					iYield -= GC.getImprovementInfo(eImprovement)->GetRouteYieldChanges(getRouteType(), iI);

	mov	ecx, DWORD PTR _iI$226778[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetRouteYieldChanges@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetRouteYieldChanges
	mov	ecx, DWORD PTR _iYield$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iYield$[ebp], ecx
$LN41@getYieldWi:

; 10883: 				}
; 10884: 			}

	jmp	SHORT $LN43@getYieldWi
$LN46@getYieldWi:

; 10885: 		}
; 10886: 	}
; 10887: #endif
; 10888: 
; 10889: #ifndef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IGNORE_FEATURE_EXTENDS_TO_CITY
; 10890: 	CvCity* pCity = getPlotCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$[ebp], eax

; 10891: #endif
; 10892: 
; 10893: 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	$LN40@getYieldWi

; 10894: 	{
; 10895: 		// City plot yield
; 10896: 		if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN39@getYieldWi

; 10897: 		{
; 10898: 			if(pCity->isRevealed(eTeam, false))

	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN39@getYieldWi

; 10899: 			{
; 10900: 				iYield += kYield.getCityChange();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getCityChange@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getCityChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10901: 
; 10902: 				if(kYield.getPopulationChangeDivisor() != 0)

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	test	eax, eax
	je	SHORT $LN37@getYieldWi

; 10903: 					iYield += (pCity->getPopulation() + kYield.getPopulationChangeOffset()) / kYield.getPopulationChangeDivisor();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	esi, eax
	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getPopulationChangeOffset@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeOffset
	add	esi, eax
	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getPopulationChangeDivisor@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getPopulationChangeDivisor
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN37@getYieldWi:

; 10904: 
; 10905: 				bCity = true;

	mov	BYTE PTR _bCity$[ebp], 1
$LN39@getYieldWi:

; 10906: 			}
; 10907: 		}
; 10908: 
; 10909: 		CvCity* pWorkingCity = getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pWorkingCity$226788[ebp], eax

; 10910: 
; 10911: 		// Water plots
; 10912: 		if(isWater())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN124@getYieldWi

; 10913: 		{
; 10914: 			if(!isImpassable() && !isMountain())

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN124@getYieldWi
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN124@getYieldWi

; 10915: 			{
; 10916: 				// Player sea plot yield
; 10917: 				iYield += GET_PLAYER(ePlayer).getSeaPlotYield(eYield);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255832[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T255832[ebp]
	call	?getSeaPlotYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getSeaPlotYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10918: 
; 10919: 				if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$226788[ebp], 0
	je	SHORT $LN34@getYieldWi

; 10920: 				{
; 10921: 					if(pWorkingCity->isRevealed(eTeam, false))

	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN34@getYieldWi

; 10922: 					{
; 10923: 						int iCityYield;
; 10924: 
; 10925: 						// Worked lake plot
; 10926: 						if(pWorkingCity->getLakePlotYield(eYield) > 0 && isLake())

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield
	test	eax, eax
	jle	SHORT $LN32@getYieldWi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN32@getYieldWi

; 10927: 							iCityYield = pWorkingCity->getLakePlotYield(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?getLakePlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getLakePlotYield
	mov	DWORD PTR _iCityYield$226793[ebp], eax

; 10928: 						// Worked sea plot
; 10929: 						else

	jmp	SHORT $LN31@getYieldWi
$LN32@getYieldWi:

; 10930: 							iCityYield = pWorkingCity->getSeaPlotYield(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?getSeaPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaPlotYield
	mov	DWORD PTR _iCityYield$226793[ebp], eax
$LN31@getYieldWi:

; 10931: 
; 10932: 						iYield += iCityYield;

	mov	edx, DWORD PTR _iYield$[ebp]
	add	edx, DWORD PTR _iCityYield$226793[ebp]
	mov	DWORD PTR _iYield$[ebp], edx
$LN34@getYieldWi:

; 10933: 					}
; 10934: 				}
; 10935: 
; 10936: 				// Worked water resources
; 10937: 				if(getResourceType(GET_PLAYER(ePlayer).getTeam()) != NO_RESOURCE)

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255836[ebp], eax
	mov	ecx, DWORD PTR $T255836[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T255845[ebp], eax
	mov	eax, DWORD PTR $T255845[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN124@getYieldWi

; 10938: 				{
; 10939: 					if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$226788[ebp], 0
	je	SHORT $LN124@getYieldWi

; 10940: 					{
; 10941: 						if(pWorkingCity->isRevealed(eTeam, false))

	push	0
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN124@getYieldWi

; 10942: 							iYield += pWorkingCity->getSeaResourceYield(eYield);

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?getSeaResourceYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getSeaResourceYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10943: 					}
; 10944: 				}
; 10945: 
; 10946: 			}
; 10947: 		}
; 10948: 
; 10949: 		// Worked river plot
; 10950: 		if(isRiver())

$LN124@getYieldWi:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+457]
	xor	eax, eax
	test	edx, edx
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN130@getYieldWi

; 10951: 		{
; 10952: 			if(!isImpassable() && !isMountain())

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	shr	al, 7
	and	al, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN130@getYieldWi
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN130@getYieldWi

; 10953: 			{
; 10954: 				if(NULL != pWorkingCity)

	cmp	DWORD PTR _pWorkingCity$226788[ebp], 0
	je	SHORT $LN130@getYieldWi

; 10955: 				{
; 10956: 					if(pWorkingCity->isRevealed(eTeam, false))

	push	0
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN130@getYieldWi

; 10957: 					{
; 10958: 						iYield += pWorkingCity->getRiverPlotYield(eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?getRiverPlotYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getRiverPlotYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10959: 					}
; 10960: 				}
; 10961: 			}
; 10962: 		}
; 10963: 
; 10964: #ifdef NQ_ALLOW_BUILDING_HILL_YIELD_CHANGES
; 10965: 		if (isHills())

$LN130@getYieldWi:
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN134@getYieldWi

; 10966: 		{
; 10967: 			if (NULL != pWorkingCity)

	cmp	DWORD PTR _pWorkingCity$226788[ebp], 0
	je	SHORT $LN134@getYieldWi

; 10968: 			{
; 10969: 				iYield += pWorkingCity->getHillYieldChangesFromBuildings(eYield);

	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?getHillYieldChangesFromBuildings@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getHillYieldChangesFromBuildings
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10970: 			}
; 10971: 		}
; 10972: #endif
; 10973: 
; 10974: 		// Worked Feature extra yield (e.g. University bonus)
; 10975: #ifdef AUI_PLOT_FIX_GET_YIELD_WITH_BUILD_IGNORE_FEATURE_EXTENDS_TO_CITY
; 10976: 		if (getFeatureType() != NO_FEATURE && !bIgnoreFeature)
; 10977: #else
; 10978: 		if(getFeatureType() != NO_FEATURE)

$LN134@getYieldWi:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$255863[ebp], cl
	movsx	edx, BYTE PTR _f$255863[ebp]
	cmp	edx, -1
	je	SHORT $LN140@getYieldWi

; 10979: #endif
; 10980: 		{
; 10981: 			if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$226788[ebp], 0
	je	SHORT $LN140@getYieldWi

; 10982: 				iYield += pWorkingCity->GetFeatureExtraYield(getFeatureType(), eYield);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$255872[ebp], cl
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	movsx	eax, BYTE PTR _f$255872[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?GetFeatureExtraYield@CvCity@@QBEHW4FeatureTypes@@W4YieldTypes@@@Z ; CvCity::GetFeatureExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 10983: 		}
; 10984: 
; 10985: 
; 10986: 		// Extra yield for terrain
; 10987: 		if(getTerrainType() != NO_TERRAIN)

$LN140@getYieldWi:
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	cmp	edx, -1
	je	SHORT $LN19@getYieldWi

; 10988: 		{
; 10989: 			if(pWorkingCity != NULL && !isImpassable() && !isMountain())

	cmp	DWORD PTR _pWorkingCity$226788[ebp], 0
	je	SHORT $LN19@getYieldWi
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN19@getYieldWi
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN19@getYieldWi

; 10990: 			{
; 10991: 				iYield += pWorkingCity->GetTerrainExtraYield(getTerrainType(), eYield);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR $T255888[ebp], ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR $T255888[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?GetTerrainExtraYield@CvCity@@QBEHW4TerrainTypes@@W4YieldTypes@@@Z ; CvCity::GetTerrainExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN19@getYieldWi:

; 10992: 			}
; 10993: 		}
; 10994: 
; 10995: 		ResourceTypes eResource = getResourceType(GET_PLAYER(ePlayer).getTeam());

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255892[ebp], ecx
	mov	edx, DWORD PTR $T255892[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T255901[ebp], eax
	mov	ecx, DWORD PTR $T255901[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$226809[ebp], eax

; 10996: 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$226809[ebp], -1
	je	$LN40@getYieldWi

; 10997: 		{
; 10998: 			const CvResourceInfo* pkResourceInfo = GC.getResourceInfo(eResource);

	mov	edx, DWORD PTR _eResource$226809[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$226811[ebp], eax

; 10999: 			if(pkResourceInfo != NULL && eTeam != NO_TEAM && GET_TEAM(eTeam).GetTeamTechs()->HasTech((TechTypes) pkResourceInfo->getTechReveal()))

	cmp	DWORD PTR _pkResourceInfo$226811[ebp], 0
	je	$LN40@getYieldWi
	cmp	DWORD PTR _eTeam$[ebp], -1
	je	$LN40@getYieldWi
	mov	eax, DWORD PTR _eTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T255905[ebp], eax
	mov	ecx, DWORD PTR _pkResourceInfo$226811[ebp]
	call	?getTechReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getTechReveal
	push	eax
	mov	ecx, DWORD PTR $T255905[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	$LN40@getYieldWi

; 11000: 			{
; 11001: 				if (pkResourceInfo->getPolicyReveal() == NO_POLICY || GET_PLAYER(ePlayer).GetPlayerPolicies()->HasPolicy((PolicyTypes)pkResourceInfo->getPolicyReveal()))

	mov	ecx, DWORD PTR _pkResourceInfo$226811[ebp]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	cmp	eax, -1
	je	SHORT $LN14@getYieldWi
	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255909[ebp], edx
	mov	ecx, DWORD PTR _pkResourceInfo$226811[ebp]
	call	?getPolicyReveal@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getPolicyReveal
	push	eax
	mov	ecx, DWORD PTR $T255909[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	eax, al
	test	eax, eax
	je	$LN40@getYieldWi
$LN14@getYieldWi:

; 11002: 				{
; 11003: 					// Extra yield from resources
; 11004: 					if(pWorkingCity != NULL)

	cmp	DWORD PTR _pWorkingCity$226788[ebp], 0
	je	SHORT $LN13@getYieldWi

; 11005: 						iYield += pWorkingCity->GetResourceExtraYield(eResource, eYield);

	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$226809[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWorkingCity$226788[ebp]
	call	?GetResourceExtraYield@CvCity@@QBEHW4ResourceTypes@@W4YieldTypes@@@Z ; CvCity::GetResourceExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN13@getYieldWi:

; 11006: 
; 11007: 					// Extra yield from Resources with Trait
; 11008: 					if(pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_STRATEGIC)

	mov	ecx, DWORD PTR _pkResourceInfo$226811[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	SHORT $LN12@getYieldWi

; 11009: 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeStrategicResources(eYield);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255913[ebp], eax
	mov	ecx, DWORD PTR $T255913[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T255917[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR $T255917[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+432]
	mov	DWORD PTR $T255918[ebp], eax
	mov	ecx, DWORD PTR _iYield$[ebp]
	add	ecx, DWORD PTR $T255918[ebp]
	mov	DWORD PTR _iYield$[ebp], ecx
	jmp	SHORT $LN40@getYieldWi
$LN12@getYieldWi:

; 11010: 					// NQMP GJS - New Netherlands UA BEGIN
; 11011: 					else if (pkResourceInfo->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _pkResourceInfo$226811[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN40@getYieldWi

; 11012: 					{
; 11013: 						iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetYieldChangeLuxuryResources(eYield);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255922[ebp], edx
	mov	ecx, DWORD PTR $T255922[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T255926[ebp], eax
	mov	eax, DWORD PTR _eYield$[ebp]
	mov	ecx, DWORD PTR $T255926[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+456]
	mov	DWORD PTR $T255927[ebp], edx
	mov	eax, DWORD PTR _iYield$[ebp]
	add	eax, DWORD PTR $T255927[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN40@getYieldWi:

; 11014: 					}
; 11015: 					// NQMP GJS - New Netherlands UA END
; 11016: 				}
; 11017: 			}
; 11018: 		}
; 11019: 	}
; 11020: 
; 11021: 	if(bCity)

	movzx	ecx, BYTE PTR _bCity$[ebp]
	test	ecx, ecx
	je	$LN9@getYieldWi

; 11022: 	{
; 11023: #ifdef AUI_PLOT_FIX_CITY_YIELD_CHANGE_RELOCATED
; 11024: 		iYield = MAX(iYield, kYield.getMinCity());
; 11025: #else
; 11026: 		iYield = std::max(iYield, kYield.getMinCity());

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getMinCity@CvYieldInfo@@QBEHXZ		; CvYieldInfo::getMinCity
	mov	DWORD PTR $T255740[ebp], eax
	mov	edx, DWORD PTR _iYield$[ebp]
	cmp	edx, DWORD PTR $T255740[ebp]
	jge	SHORT $LN168@getYieldWi
	lea	eax, DWORD PTR $T255740[ebp]
	mov	DWORD PTR tv513[ebp], eax
	jmp	SHORT $LN169@getYieldWi
$LN168@getYieldWi:
	lea	ecx, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR tv513[ebp], ecx
$LN169@getYieldWi:
	mov	edx, DWORD PTR tv513[ebp]
	mov	DWORD PTR $T255934[ebp], edx
	mov	eax, DWORD PTR $T255934[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iYield$[ebp], ecx

; 11027: 
; 11028: 		// Mod for Player; used for Policies and such
; 11029: 		int iTemp = GET_PLAYER(getOwner()).GetCityYieldChange(eYield);	// In hundreds - will be added to capitalYieldChange below

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T255940[ebp], eax
	mov	ecx, DWORD PTR $T255940[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255944[ebp], ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T255944[ebp]
	call	?GetCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCityYieldChange
	mov	DWORD PTR _iTemp$226823[ebp], eax

; 11030: 
; 11031: 		// Coastal City Mod
; 11032: 		if(pCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@getYieldWi

; 11033: 		{
; 11034: 			iYield += GET_PLAYER(getOwner()).GetCoastalCityYieldChange(eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T255948[ebp], edx
	mov	eax, DWORD PTR $T255948[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255952[ebp], eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T255952[ebp]
	call	?GetCoastalCityYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCoastalCityYieldChange
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN8@getYieldWi:

; 11035: 		}
; 11036: 
; 11037: 		// Capital Mod
; 11038: 		if(pCity->isCapital())

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	je	$LN7@getYieldWi

; 11039: 		{
; 11040: 			iTemp += GET_PLAYER(getOwner()).GetCapitalYieldChange(eYield);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T255956[ebp], ecx
	mov	edx, DWORD PTR $T255956[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255960[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255960[ebp]
	call	?GetCapitalYieldChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldChange
	add	eax, DWORD PTR _iTemp$226823[ebp]
	mov	DWORD PTR _iTemp$226823[ebp], eax

; 11041: 
; 11042: 			int iPerPopYield = pCity->getPopulation() * GET_PLAYER(getOwner()).GetCapitalYieldPerPopChange(eYield);

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T255964[ebp], edx
	mov	eax, DWORD PTR $T255964[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255968[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	esi, eax
	mov	ecx, DWORD PTR _eYield$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T255968[ebp]
	call	?GetCapitalYieldPerPopChange@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::GetCapitalYieldPerPopChange
	imul	esi, eax
	mov	DWORD PTR _iPerPopYield$226826[ebp], esi

; 11043: 			iPerPopYield /= 100;

	mov	eax, DWORD PTR _iPerPopYield$226826[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iPerPopYield$226826[ebp], eax

; 11044: 			iYield += iPerPopYield;

	mov	edx, DWORD PTR _iYield$[ebp]
	add	edx, DWORD PTR _iPerPopYield$226826[ebp]
	mov	DWORD PTR _iYield$[ebp], edx
$LN7@getYieldWi:

; 11045: 		}
; 11046: 
; 11047: 		iYield += (iTemp / 100);

	mov	eax, DWORD PTR _iTemp$226823[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN9@getYieldWi:

; 11048: #endif
; 11049: 	}
; 11050: 
; 11051: 	iYield += GC.getGame().getPlotExtraYield(m_iX, m_iY, eYield);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T255972[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T255972[ebp]
	call	?getPlotExtraYield@CvGame@@QBEHHHW4YieldTypes@@@Z ; CvGame::getPlotExtraYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax

; 11052: 
; 11053: 	if(ePlayer != NO_PLAYER)

	cmp	DWORD PTR _ePlayer$[ebp], -1
	je	$LN6@getYieldWi

; 11054: 	{
; 11055: 		if(GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield) > 0)

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255976[ebp], edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T255976[ebp]
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	test	eax, eax
	jle	SHORT $LN5@getYieldWi

; 11056: 		{
; 11057: 			if(iYield >= GET_PLAYER(ePlayer).getExtraYieldThreshold(eYield))

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255980[ebp], ecx
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T255980[ebp]
	call	?getExtraYieldThreshold@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::getExtraYieldThreshold
	cmp	DWORD PTR _iYield$[ebp], eax
	jl	SHORT $LN5@getYieldWi

; 11058: 			{
; 11059: 				iYield += GC.getEXTRA_YIELD();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6608
	mov	DWORD PTR $T255984[ebp], eax
	mov	ecx, DWORD PTR _iYield$[ebp]
	add	ecx, DWORD PTR $T255984[ebp]
	mov	DWORD PTR _iYield$[ebp], ecx
$LN5@getYieldWi:

; 11060: 			}
; 11061: 		}
; 11062: 
; 11063: 		if(GET_PLAYER(ePlayer).isGoldenAge())

	mov	edx, DWORD PTR _ePlayer$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255988[ebp], edx
	mov	ecx, DWORD PTR $T255988[ebp]
	call	?isGoldenAge@CvPlayer@@QBE_NXZ		; CvPlayer::isGoldenAge
	movzx	eax, al
	test	eax, eax
	je	$LN6@getYieldWi

; 11064: 		{
; 11065: 			if(iYield >= kYield.getGoldenAgeYieldThreshold())

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getGoldenAgeYieldThreshold@CvYieldInfo@@QBEHXZ ; CvYieldInfo::getGoldenAgeYieldThreshold
	cmp	DWORD PTR _iYield$[ebp], eax
	jl	SHORT $LN2@getYieldWi

; 11066: 			{
; 11067: 				iYield += kYield.getGoldenAgeYield();

	mov	ecx, DWORD PTR _kYield$[ebp]
	call	?getGoldenAgeYield@CvYieldInfo@@QBEHXZ	; CvYieldInfo::getGoldenAgeYield
	add	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR _iYield$[ebp], eax
$LN2@getYieldWi:

; 11068: 			}
; 11069: #ifdef NQ_GOLDEN_PILGRIMAGE
; 11070: 			// this is super hacky, I am a bad person and I should feel bad...
; 11071: 			if (eYield == YIELD_FAITH && getYieldWithBuild(eBuild, YIELD_GOLD, bWithUpgrade, ePlayer) > 0)

	cmp	DWORD PTR _eYield$[ebp], 5
	jne	SHORT $LN6@getYieldWi
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bWithUpgrade$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
	test	eax, eax
	jle	SHORT $LN6@getYieldWi

; 11072: 			{
; 11073: 				iYield += GET_PLAYER(ePlayer).GetPlayerTraits()->GetGoldenAgeTileBonusFaith();

	mov	ecx, DWORD PTR _ePlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T255992[ebp], ecx
	mov	ecx, DWORD PTR $T255992[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T255996[ebp], eax
	mov	edx, DWORD PTR $T255996[ebp]
	mov	eax, DWORD PTR [edx+132]
	mov	DWORD PTR $T255997[ebp], eax
	mov	ecx, DWORD PTR _iYield$[ebp]
	add	ecx, DWORD PTR $T255997[ebp]
	mov	DWORD PTR _iYield$[ebp], ecx
$LN6@getYieldWi:

; 11074: 			}
; 11075: //int CvPlot::getYieldWithBuild(BuildTypes eBuild, YieldTypes eYield, bool bWithUpgrade, PlayerTypes ePlayer) const
; 11076: #endif
; 11077: 		}
; 11078: 	}
; 11079: 
; 11080: 	return std::max(0, iYield);

	mov	DWORD PTR $T255741[ebp], 0
	mov	edx, DWORD PTR $T255741[ebp]
	cmp	edx, DWORD PTR _iYield$[ebp]
	jge	SHORT $LN202@getYieldWi
	lea	eax, DWORD PTR _iYield$[ebp]
	mov	DWORD PTR tv791[ebp], eax
	jmp	SHORT $LN203@getYieldWi
$LN202@getYieldWi:
	lea	ecx, DWORD PTR $T255741[ebp]
	mov	DWORD PTR tv791[ebp], ecx
$LN203@getYieldWi:
	mov	edx, DWORD PTR tv791[ebp]
	mov	DWORD PTR $T256006[ebp], edx
	mov	eax, DWORD PTR $T256006[ebp]
	mov	eax, DWORD PTR [eax]
$LN67@getYieldWi:

; 11081: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ENDP ; CvPlot::getYieldWithBuild
_TEXT	ENDS
PUBLIC	?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z	; CvPlot::canTrain
EXTRN	?GetMinAreaSize@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetMinAreaSize
EXTRN	?getNumTotalResources@CvArea@@QBEHXZ:PROC	; CvArea::getNumTotalResources
EXTRN	?IsPrereqResources@CvUnitEntry@@QBE_NXZ:PROC	; CvUnitEntry::IsPrereqResources
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
; Function compile flags: /Odtp
;	COMDAT ?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T256016 = -32						; size = 4
$T256012 = -28						; size = 4
_pLoopPlot$226852 = -24					; size = 4
_iI$226848 = -20					; size = 4
_bValid$226847 = -13					; size = 1
_thisUnitEntry$ = -12					; size = 4
_thisUnitDomain$ = -8					; size = 4
_pkUnitInfo$ = -4					; size = 4
_eUnit$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z PROC		; CvPlot::canTrain, COMDAT
; _this$ = ecx

; 11085: {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 11086: 	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$[ebp], eax

; 11087: 	if(pkUnitInfo == NULL)

	cmp	DWORD PTR _pkUnitInfo$[ebp], 0
	jne	SHORT $LN25@canTrain

; 11088: 	{
; 11089: 		return false;

	xor	al, al
	jmp	$LN26@canTrain
$LN25@canTrain:

; 11090: 	}
; 11091: 
; 11092: 	CvUnitEntry& thisUnitEntry = *pkUnitInfo;

	mov	ecx, DWORD PTR _pkUnitInfo$[ebp]
	mov	DWORD PTR _thisUnitEntry$[ebp], ecx

; 11093: 	DomainTypes thisUnitDomain = (DomainTypes) thisUnitEntry.GetDomainType();

	mov	ecx, DWORD PTR _thisUnitEntry$[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	mov	DWORD PTR _thisUnitDomain$[ebp], eax

; 11094: 
; 11095: 	if(thisUnitEntry.IsPrereqResources())

	mov	ecx, DWORD PTR _thisUnitEntry$[ebp]
	call	?IsPrereqResources@CvUnitEntry@@QBE_NXZ	; CvUnitEntry::IsPrereqResources
	movzx	edx, al
	test	edx, edx
	je	$LN24@canTrain

; 11096: 	{
; 11097: 		if(thisUnitDomain == DOMAIN_SEA)

	cmp	DWORD PTR _thisUnitDomain$[ebp], 0
	jne	$LN23@canTrain

; 11098: 		{
; 11099: 			bool bValid = false;

	mov	BYTE PTR _bValid$226847[ebp], 0

; 11100: 
; 11101: 			for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$226848[ebp], 0
	jmp	SHORT $LN22@canTrain
$LN21@canTrain:
	mov	eax, DWORD PTR _iI$226848[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226848[ebp], eax
$LN22@canTrain:
	cmp	DWORD PTR _iI$226848[ebp], 6
	jge	SHORT $LN20@canTrain

; 11102: 			{
; 11103: 				CvPlot* pLoopPlot = plotDirection(getX(), getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T256012[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T256016[ebp], ecx
	mov	edx, DWORD PTR _iI$226848[ebp]
	push	edx
	mov	eax, DWORD PTR $T256012[ebp]
	push	eax
	mov	ecx, DWORD PTR $T256016[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$226852[ebp], eax

; 11104: 
; 11105: 				if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$226852[ebp], 0
	je	SHORT $LN19@canTrain

; 11106: 				{
; 11107: 					if(pLoopPlot->isWater())

	mov	edx, DWORD PTR _pLoopPlot$226852[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN19@canTrain

; 11108: 					{
; 11109: 						if(pLoopPlot->area()->getNumTotalResources() > 0)

	mov	ecx, DWORD PTR _pLoopPlot$226852[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTotalResources@CvArea@@QBEHXZ	; CvArea::getNumTotalResources
	test	eax, eax
	jle	SHORT $LN19@canTrain

; 11110: 						{
; 11111: 							bValid = true;

	mov	BYTE PTR _bValid$226847[ebp], 1

; 11112: 							break;

	jmp	SHORT $LN20@canTrain
$LN19@canTrain:

; 11113: 						}
; 11114: 					}
; 11115: 				}
; 11116: 			}

	jmp	SHORT $LN21@canTrain
$LN20@canTrain:

; 11117: 
; 11118: 			if(!bValid)

	movzx	eax, BYTE PTR _bValid$226847[ebp]
	test	eax, eax
	jne	SHORT $LN16@canTrain

; 11119: 			{
; 11120: 				return false;

	xor	al, al
	jmp	$LN26@canTrain
$LN16@canTrain:

; 11121: 			}
; 11122: 		}
; 11123: 		else

	jmp	SHORT $LN24@canTrain
$LN23@canTrain:

; 11124: 		{
; 11125: 			if(area()->getNumTotalResources() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTotalResources@CvArea@@QBEHXZ	; CvArea::getNumTotalResources
	test	eax, eax
	jle	SHORT $LN24@canTrain

; 11126: 			{
; 11127: 				return false;

	xor	al, al
	jmp	$LN26@canTrain
$LN24@canTrain:

; 11128: 			}
; 11129: 		}
; 11130: 	}
; 11131: 
; 11132: 	if(isCity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@canTrain

; 11133: 	{
; 11134: 		if(thisUnitDomain == DOMAIN_SEA)

	cmp	DWORD PTR _thisUnitDomain$[ebp], 0
	jne	SHORT $LN12@canTrain

; 11135: 		{
; 11136: 			if(!isWater() && !isCoastalLand(thisUnitEntry.GetMinAreaSize()))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN11@canTrain
	mov	ecx, DWORD PTR _thisUnitEntry$[ebp]
	call	?GetMinAreaSize@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetMinAreaSize
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@canTrain

; 11137: 			{
; 11138: 				return false;

	xor	al, al
	jmp	$LN26@canTrain
$LN11@canTrain:

; 11139: 			}
; 11140: 		}
; 11141: 		else

	jmp	SHORT $LN10@canTrain
$LN12@canTrain:

; 11142: 		{
; 11143: 			if(area()->getNumTiles() < thisUnitEntry.GetMinAreaSize())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	esi, eax
	mov	ecx, DWORD PTR _thisUnitEntry$[ebp]
	call	?GetMinAreaSize@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetMinAreaSize
	cmp	esi, eax
	jge	SHORT $LN10@canTrain

; 11144: 			{
; 11145: 				return false;

	xor	al, al
	jmp	SHORT $LN26@canTrain
$LN10@canTrain:

; 11146: 			}
; 11147: 		}
; 11148: 	}
; 11149: 	else

	jmp	SHORT $LN8@canTrain
$LN13@canTrain:

; 11150: 	{
; 11151: 		if(area()->getNumTiles() < thisUnitEntry.GetMinAreaSize())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	esi, eax
	mov	ecx, DWORD PTR _thisUnitEntry$[ebp]
	call	?GetMinAreaSize@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetMinAreaSize
	cmp	esi, eax
	jge	SHORT $LN7@canTrain

; 11152: 		{
; 11153: 			return false;

	xor	al, al
	jmp	SHORT $LN26@canTrain
$LN7@canTrain:

; 11154: 		}
; 11155: 
; 11156: 		if(thisUnitDomain == DOMAIN_SEA)

	cmp	DWORD PTR _thisUnitDomain$[ebp], 0
	jne	SHORT $LN6@canTrain

; 11157: 		{
; 11158: 			if(!isWater())

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@canTrain

; 11159: 			{
; 11160: 				return false;

	xor	al, al
	jmp	SHORT $LN26@canTrain
$LN5@canTrain:

; 11161: 			}
; 11162: 		}

	jmp	SHORT $LN8@canTrain
$LN6@canTrain:

; 11163: 		else if(thisUnitDomain == DOMAIN_LAND)

	cmp	DWORD PTR _thisUnitDomain$[ebp], 2
	jne	SHORT $LN3@canTrain

; 11164: 		{
; 11165: 			if(isWater())

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@canTrain

; 11166: 			{
; 11167: 				return false;

	xor	al, al
	jmp	SHORT $LN26@canTrain
$LN2@canTrain:

; 11168: 			}
; 11169: 		}
; 11170: 		else

	jmp	SHORT $LN8@canTrain
$LN3@canTrain:

; 11171: 		{
; 11172: 			return false;

	xor	al, al
	jmp	SHORT $LN26@canTrain
$LN8@canTrain:

; 11173: 		}
; 11174: 	}
; 11175: 
; 11176: 	return true;

	mov	al, 1
$LN26@canTrain:

; 11177: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?canTrain@CvPlot@@QBE_NW4UnitTypes@@_N1@Z ENDP		; CvPlot::canTrain
_TEXT	ENDS
PUBLIC	?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::countNumAirUnits
EXTRN	?GetAirUnitCap@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetAirUnitCap
; Function compile flags: /Odtp
;	COMDAT ?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
tv134 = -20						; size = 4
_this$ = -16						; size = 4
_pLoopUnit$226882 = -12					; size = 4
_iCount$ = -8						; size = 4
_pUnitNode$ = -4					; size = 4
_eTeam$ = 8						; size = 4
?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::countNumAirUnits, COMDAT
; _this$ = ecx

; 11181: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 11182: 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 11183: 
; 11184: 	const IDInfo* pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QBEPBUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN3@countNumAi:

; 11185: 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN2@countNumAi

; 11186: 	{
; 11187: 		const CvUnit* pLoopUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN6@countNumAi
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN6@countNumAi
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pLoopUnit$226882[ebp], eax
	jmp	SHORT $LN7@countNumAi
$LN6@countNumAi:
	mov	DWORD PTR _pLoopUnit$226882[ebp], 0
$LN7@countNumAi:

; 11188: 		pUnitNode = nextUnitNode(pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 11189: 
; 11190: 		if(pLoopUnit && DOMAIN_AIR == pLoopUnit->getDomainType() && !pLoopUnit->isCargo() && pLoopUnit->getTeam() == eTeam)

	cmp	DWORD PTR _pLoopUnit$226882[ebp], 0
	je	SHORT $LN1@countNumAi
	mov	ecx, DWORD PTR _pLoopUnit$226882[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN1@countNumAi
	mov	ecx, DWORD PTR _pLoopUnit$226882[ebp]
	call	?isCargo@CvUnit@@QBE_NXZ		; CvUnit::isCargo
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@countNumAi
	mov	ecx, DWORD PTR _pLoopUnit$226882[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	SHORT $LN1@countNumAi

; 11191: 		{
; 11192: 			iCount += pLoopUnit->getUnitInfo().GetAirUnitCap();

	mov	ecx, DWORD PTR _pLoopUnit$226882[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetAirUnitCap@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetAirUnitCap
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN1@countNumAi:

; 11193: 		}
; 11194: 	}

	jmp	$LN3@countNumAi
$LN2@countNumAi:

; 11195: 
; 11196: 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 11197: }

	mov	esp, ebp
	pop	ebp
	ret	4
?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::countNumAirUnits
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC ; CvPlot::GetBuilderAIScratchPadPlayer, COMDAT
; _this$ = ecx

; 11201: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11202: 	return (PlayerTypes)m_cBuilderAIScratchPadPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+368]

; 11203: }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP ; CvPlot::GetBuilderAIScratchPadPlayer
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetBuilderAIScratchPadPlayer
; Function compile flags: /Odtp
;	COMDAT ?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z PROC ; CvPlot::SetBuilderAIScratchPadPlayer, COMDAT
; _this$ = ecx

; 11207: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11208: 	m_cBuilderAIScratchPadPlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _ePlayer$[ebp]
	mov	BYTE PTR [eax+368], cl

; 11209: }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ENDP ; CvPlot::SetBuilderAIScratchPadPlayer
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ	; CvPlot::GetBuilderAIScratchPadTurn
; Function compile flags: /Odtp
;	COMDAT ?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ PROC		; CvPlot::GetBuilderAIScratchPadTurn, COMDAT
; _this$ = ecx

; 11217: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11218: 	return m_sBuilderAIScratchPadTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+370]

; 11219: }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ENDP		; CvPlot::GetBuilderAIScratchPadTurn
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z	; CvPlot::SetBuilderAIScratchPadTurn
; Function compile flags: /Odtp
;	COMDAT ?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sNewTurnValue$ = 8					; size = 2
?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z PROC	; CvPlot::SetBuilderAIScratchPadTurn, COMDAT
; _this$ = ecx

; 11227: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11228: 	m_sBuilderAIScratchPadTurn = sNewTurnValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _sNewTurnValue$[ebp]
	mov	WORD PTR [eax+370], cx

; 11229: }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z ENDP	; CvPlot::SetBuilderAIScratchPadTurn
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::GetBuilderAIScratchPadRoute
; Function compile flags: /Odtp
;	COMDAT ?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ PROC ; CvPlot::GetBuilderAIScratchPadRoute, COMDAT
; _this$ = ecx

; 11233: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11234: 	return m_eBuilderAIScratchPadRoute;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+376]

; 11235: }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ ENDP ; CvPlot::GetBuilderAIScratchPadRoute
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute
; Function compile flags: /Odtp
;	COMDAT ?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eRoute$ = 8						; size = 4
?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z PROC ; CvPlot::SetBuilderAIScratchPadRoute, COMDAT
; _this$ = ecx

; 11239: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11240: 	m_eBuilderAIScratchPadRoute = eRoute;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eRoute$[ebp]
	mov	DWORD PTR [eax+376], ecx

; 11241: }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ENDP ; CvPlot::SetBuilderAIScratchPadRoute
_TEXT	ENDS
PUBLIC	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ	; CvPlot::GetBuilderAIScratchPadValue
; Function compile flags: /Odtp
;	COMDAT ?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ PROC	; CvPlot::GetBuilderAIScratchPadValue, COMDAT
; _this$ = ecx

; 11249: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11250: 	return m_sBuilderAIScratchPadValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [eax+372]

; 11251: }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ ENDP	; CvPlot::GetBuilderAIScratchPadValue
_TEXT	ENDS
PUBLIC	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z	; CvPlot::SetBuilderAIScratchPadValue
; Function compile flags: /Odtp
;	COMDAT ?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sNewValue$ = 8						; size = 2
?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z PROC	; CvPlot::SetBuilderAIScratchPadValue, COMDAT
; _this$ = ecx

; 11259: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11260: 	m_sBuilderAIScratchPadValue = sNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _sNewValue$[ebp]
	mov	WORD PTR [eax+372], cx

; 11261: }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ENDP	; CvPlot::SetBuilderAIScratchPadValue
_TEXT	ENDS
PUBLIC	?GetPlotIndex@CvPlot@@QBEHXZ			; CvPlot::GetPlotIndex
; Function compile flags: /Odtp
;	COMDAT ?GetPlotIndex@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T256232 = -16						; size = 4
$T256227 = -12						; size = 4
$T256223 = -8						; size = 4
$T256219 = -4						; size = 4
?GetPlotIndex@CvPlot@@QBEHXZ PROC			; CvPlot::GetPlotIndex, COMDAT
; _this$ = ecx

; 11269: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 11270: 	return GC.getMap().plotNum(getX(),getY());

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T256219[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T256223[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T256227[ebp], ecx
	mov	edx, DWORD PTR $T256227[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T256232[ebp], eax
	mov	eax, DWORD PTR $T256219[ebp]
	imul	eax, DWORD PTR $T256232[ebp]
	add	eax, DWORD PTR $T256223[ebp]

; 11271: }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotIndex@CvPlot@@QBEHXZ ENDP			; CvPlot::GetPlotIndex
_TEXT	ENDS
PUBLIC	?GetContinentType@CvPlot@@QBEDXZ		; CvPlot::GetContinentType
; Function compile flags: /Odtp
;	COMDAT ?GetContinentType@CvPlot@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetContinentType@CvPlot@@QBEDXZ PROC			; CvPlot::GetContinentType, COMDAT
; _this$ = ecx

; 11279: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11280: 	return m_cContinentType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+459]

; 11281: }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetContinentType@CvPlot@@QBEDXZ ENDP			; CvPlot::GetContinentType
_TEXT	ENDS
PUBLIC	?SetContinentType@CvPlot@@QAEXD@Z		; CvPlot::SetContinentType
; Function compile flags: /Odtp
;	COMDAT ?SetContinentType@CvPlot@@QAEXD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cContinent$ = 8					; size = 1
?SetContinentType@CvPlot@@QAEXD@Z PROC			; CvPlot::SetContinentType, COMDAT
; _this$ = ecx

; 11289: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11290: 	m_cContinentType = cContinent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _cContinent$[ebp]
	mov	BYTE PTR [eax+459], cl

; 11291: }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetContinentType@CvPlot@@QAEXD@Z ENDP			; CvPlot::SetContinentType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ PROC	; CvPlot::getSyncArchive, COMDAT
; _this$ = ecx

; 11295: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11296: 	return m_syncArchive;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 392				; 00000188H

; 11297: }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSyncArchive@CvPlot@@QAEAAVFAutoArchive@@XZ ENDP	; CvPlot::getSyncArchive
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ PROC	; CvPlot::getSyncArchive, COMDAT
; _this$ = ecx

; 11301: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11302: 	return m_syncArchive;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 392				; 00000188H

; 11303: }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSyncArchive@CvPlot@@QBEABVFAutoArchive@@XZ ENDP	; CvPlot::getSyncArchive
_TEXT	ENDS
PUBLIC	??$sprintf_s@$07@@YAHAAY07DPBDZZ		; sprintf_s<8>
PUBLIC	??_C@_03GIJBMBD@?$CFd?$AA?$AA@			; `string'
PUBLIC	??_C@_0N@LOGDBEMN@Game?5Turn?5?3?5?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::debugDump
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
;	COMDAT ??_C@_03GIJBMBD@?$CFd?$AA?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_03GIJBMBD@?$CFd?$AA?$AA@ DB '%d', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LOGDBEMN@Game?5Turn?5?3?5?$AA@
CONST	SEGMENT
??_C@_0N@LOGDBEMN@Game?5Turn?5?3?5?$AA@ DB 'Game Turn : ', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0
__ehfuncinfo$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
xdata$x	ENDS
;	COMDAT ?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T256255 = -64						; size = 4
$T256250 = -60						; size = 4
_gameTurn$ = -56					; size = 4
_result$ = -52						; size = 28
_gameTurnBuffer$ = -24					; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; CvPlot::debugDump, COMDAT
; _this$ = ecx

; 11307: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T256250[ebp], 0

; 11308: 	std::string result = "Game Turn : ";

	push	OFFSET ??_C@_0N@LOGDBEMN@Game?5Turn?5?3?5?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 11309: 	char gameTurnBuffer[8] = {0};

	mov	BYTE PTR _gameTurnBuffer$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _gameTurnBuffer$[ebp+1], eax
	mov	WORD PTR _gameTurnBuffer$[ebp+5], ax
	mov	BYTE PTR _gameTurnBuffer$[ebp+7], al

; 11310: 	int gameTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T256255[ebp], ecx
	mov	ecx, DWORD PTR $T256255[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _gameTurn$[ebp], eax

; 11311: 	sprintf_s(gameTurnBuffer, "%d\0", gameTurn);

	mov	edx, DWORD PTR _gameTurn$[ebp]
	push	edx
	push	OFFSET ??_C@_03GIJBMBD@?$CFd?$AA?$AA@
	lea	eax, DWORD PTR _gameTurnBuffer$[ebp]
	push	eax
	call	??$sprintf_s@$07@@YAHAAY07DPBDZZ	; sprintf_s<8>
	add	esp, 12					; 0000000cH

; 11312: 	result += gameTurnBuffer;

	lea	ecx, DWORD PTR _gameTurnBuffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 11313: 	return result;

	lea	edx, DWORD PTR _result$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T256250[ebp]
	or	eax, 1
	mov	DWORD PTR $T256250[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 11314: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$1:
	mov	eax, DWORD PTR $T256250[ebp]
	and	eax, 1
	je	$LN5@debugDump
	and	DWORD PTR $T256250[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@debugDump:
	ret	0
__ehhandler$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; CvPlot::debugDump
PUBLIC	?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::stackTraceRemark
; Function compile flags: /Odtp
;	COMDAT ?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T256265 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_var$ = 12						; size = 4
?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; CvPlot::stackTraceRemark, COMDAT
; _this$ = ecx

; 11318: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T256265[ebp], 0

; 11319: 	return debugDump(var);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::debugDump
	mov	edx, DWORD PTR $T256265[ebp]
	or	edx, 1
	mov	DWORD PTR $T256265[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 11320: }

	mov	esp, ebp
	pop	ebp
	ret	8
?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; CvPlot::stackTraceRemark
_TEXT	ENDS
PUBLIC	?Validate@CvPlot@@QAEHAAVCvMap@@@Z		; CvPlot::Validate
; Function compile flags: /Odtp
;	COMDAT ?Validate@CvPlot@@QAEHAAVCvMap@@@Z
_TEXT	SEGMENT
tv328 = -148						; size = 4
tv343 = -144						; size = 4
tv157 = -140						; size = 4
_this$ = -136						; size = 4
$T256486 = -132						; size = 4
$T256473 = -128						; size = 4
$T256469 = -124						; size = 4
$T256455 = -120						; size = 4
$T256451 = -113						; size = 1
$T256440 = -112						; size = 4
$T256436 = -105						; size = 1
_iMapY$256530 = -104					; size = 4
_iMapX$256529 = -100					; size = 4
$T256429 = -96						; size = 4
$T256420 = -92						; size = 4
$T256411 = -88						; size = 4
$T256381 = -84						; size = 4
$T256377 = -80						; size = 4
$T256372 = -76						; size = 4
$T256365 = -72						; size = 4
$T256361 = -68						; size = 4
_uIdx$256405 = -64					; size = 4
_uDeletePos$256404 = -60				; size = 4
$T256353 = -56						; size = 4
$T256344 = -52						; size = 4
$T256335 = -48						; size = 4
$T256305 = -44						; size = 4
$T256301 = -40						; size = 4
$T256296 = -36						; size = 4
$T256289 = -32						; size = 4
$T256285 = -28						; size = 4
_uIdx$256329 = -24					; size = 4
_uDeletePos$256328 = -20				; size = 4
_pkCorrectPlot$226964 = -16				; size = 4
_pkUnit$226959 = -12					; size = 4
_pUnitNode$ = -8					; size = 4
_iError$ = -4						; size = 4
_kParentMap$ = 8					; size = 4
?Validate@CvPlot@@QAEHAAVCvMap@@@Z PROC			; CvPlot::Validate, COMDAT
; _this$ = ecx

; 11328: {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 11329: 	int iError = 0;

	mov	DWORD PTR _iError$[ebp], 0

; 11330: 	IDInfo* pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN10@Validate:

; 11331: 
; 11332: 	while(pUnitNode != NULL)

	cmp	DWORD PTR _pUnitNode$[ebp], 0
	je	$LN9@Validate

; 11333: 	{
; 11334: 		CvUnit* pkUnit = GetPlayerUnit(*pUnitNode);

	mov	eax, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN13@Validate
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN13@Validate
	mov	edx, DWORD PTR _pUnitNode$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR [ecx+eax+4472]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _pUnitNode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv157[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv157[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pkUnit$226959[ebp], eax
	jmp	SHORT $LN14@Validate
$LN13@Validate:
	mov	DWORD PTR _pkUnit$226959[ebp], 0
$LN14@Validate:

; 11335: 		if(pkUnit == NULL)

	cmp	DWORD PTR _pkUnit$226959[ebp], 0
	jne	$LN44@Validate

; 11336: 		{
; 11337: 			m_units.deleteNode(pUnitNode);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T256335[ebp], eax
	xor	ecx, ecx
	shl	ecx, 3
	mov	edx, DWORD PTR $T256335[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	sub	ecx, eax
	sar	ecx, 3
	mov	DWORD PTR _uDeletePos$256328[ebp], ecx
	mov	edx, DWORD PTR _uDeletePos$256328[ebp]
	mov	DWORD PTR _uIdx$256329[ebp], edx
	jmp	SHORT $LN22@Validate
$LN21@Validate:
	mov	eax, DWORD PTR _uIdx$256329[ebp]
	add	eax, 1
	mov	DWORD PTR _uIdx$256329[ebp], eax
$LN22@Validate:
	mov	ecx, DWORD PTR $T256335[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T256285[ebp], edx
	mov	eax, DWORD PTR _uIdx$256329[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR $T256285[ebp]
	jae	SHORT $LN20@Validate
	mov	ecx, DWORD PTR $T256335[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _uIdx$256329[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+8]
	mov	DWORD PTR $T256289[ebp], ecx
	mov	edx, DWORD PTR $T256289[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T256335[ebp]
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR _uIdx$256329[ebp]
	mov	DWORD PTR [edx+esi*8], eax
	mov	DWORD PTR [edx+esi*8+4], ecx
	jmp	SHORT $LN21@Validate
$LN20@Validate:
	mov	eax, DWORD PTR $T256335[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256296[ebp], ecx
	mov	edx, DWORD PTR $T256296[ebp]
	sub	edx, 1
	mov	DWORD PTR $T256301[ebp], edx
	mov	eax, DWORD PTR $T256335[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR $T256301[ebp]
	jae	SHORT $LN35@Validate
	mov	edx, DWORD PTR $T256301[ebp]
	push	edx
	mov	ecx, DWORD PTR $T256335[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN35@Validate:
	mov	eax, DWORD PTR $T256335[ebp]
	mov	ecx, DWORD PTR $T256301[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T256335[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256305[ebp], eax

; 11338: 			pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 11339: 			iError |= 1;

	mov	edx, DWORD PTR _iError$[ebp]
	or	edx, 1
	mov	DWORD PTR _iError$[ebp], edx

; 11340: 		}
; 11341: 		else

	jmp	$LN7@Validate

; 11342: 		{
; 11343: 			if(pkUnit->getX() != m_iX || pkUnit->getY() != m_iY)

$LN44@Validate:
	mov	eax, DWORD PTR _pkUnit$226959[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T256344[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	DWORD PTR $T256344[ebp], eax
	jne	SHORT $LN5@Validate
	mov	ecx, DWORD PTR _pkUnit$226959[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T256353[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	cmp	DWORD PTR $T256353[ebp], ecx
	je	$LN6@Validate
$LN5@Validate:

; 11344: 			{
; 11345: 				iError |= 1;

	mov	edx, DWORD PTR _iError$[ebp]
	or	edx, 1
	mov	DWORD PTR _iError$[ebp], edx

; 11346: 				// Unit thinks it is in another plot.  Unit wins.
; 11347: 				m_units.deleteNode(pUnitNode);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T256411[ebp], eax
	xor	ecx, ecx
	shl	ecx, 3
	mov	edx, DWORD PTR $T256411[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	sub	ecx, eax
	sar	ecx, 3
	mov	DWORD PTR _uDeletePos$256404[ebp], ecx
	mov	edx, DWORD PTR _uDeletePos$256404[ebp]
	mov	DWORD PTR _uIdx$256405[ebp], edx
	jmp	SHORT $LN54@Validate
$LN53@Validate:
	mov	eax, DWORD PTR _uIdx$256405[ebp]
	add	eax, 1
	mov	DWORD PTR _uIdx$256405[ebp], eax
$LN54@Validate:
	mov	ecx, DWORD PTR $T256411[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T256361[ebp], edx
	mov	eax, DWORD PTR _uIdx$256405[ebp]
	add	eax, 1
	cmp	eax, DWORD PTR $T256361[ebp]
	jae	SHORT $LN52@Validate
	mov	ecx, DWORD PTR $T256411[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _uIdx$256405[ebp]
	lea	ecx, DWORD PTR [edx+eax*8+8]
	mov	DWORD PTR $T256365[ebp], ecx
	mov	edx, DWORD PTR $T256365[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T256411[ebp]
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR _uIdx$256405[ebp]
	mov	DWORD PTR [edx+esi*8], eax
	mov	DWORD PTR [edx+esi*8+4], ecx
	jmp	SHORT $LN53@Validate
$LN52@Validate:
	mov	eax, DWORD PTR $T256411[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256372[ebp], ecx
	mov	edx, DWORD PTR $T256372[ebp]
	sub	edx, 1
	mov	DWORD PTR $T256377[ebp], edx
	mov	eax, DWORD PTR $T256411[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR $T256377[ebp]
	jae	SHORT $LN67@Validate
	mov	edx, DWORD PTR $T256377[ebp]
	push	edx
	mov	ecx, DWORD PTR $T256411[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN67@Validate:
	mov	eax, DWORD PTR $T256411[ebp]
	mov	ecx, DWORD PTR $T256377[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T256411[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T256381[ebp], eax

; 11348: 
; 11349: 				CvPlot* pkCorrectPlot = kParentMap.plot(pkUnit->getX(), pkUnit->getY());

	mov	edx, DWORD PTR _pkUnit$226959[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T256420[ebp], eax
	mov	ecx, DWORD PTR _pkUnit$226959[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T256429[ebp], edx
	cmp	DWORD PTR $T256429[ebp], -2147483647	; 80000001H
	je	SHORT $LN82@Validate
	cmp	DWORD PTR $T256420[ebp], -2147483647	; 80000001H
	jne	SHORT $LN83@Validate
$LN82@Validate:
	mov	DWORD PTR _pkCorrectPlot$226964[ebp], 0
	jmp	$LN84@Validate
$LN83@Validate:
	mov	eax, DWORD PTR _kParentMap$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T256436[ebp], cl
	mov	edx, DWORD PTR _kParentMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T256440[ebp], eax
	movzx	ecx, BYTE PTR $T256436[ebp]
	test	ecx, ecx
	je	SHORT $LN95@Validate
	cmp	DWORD PTR $T256429[ebp], 0
	jge	SHORT $LN94@Validate
	mov	eax, DWORD PTR $T256429[ebp]
	cdq
	idiv	DWORD PTR $T256440[ebp]
	add	edx, DWORD PTR $T256440[ebp]
	mov	DWORD PTR _iMapX$256529[ebp], edx
	jmp	SHORT $LN96@Validate
	jmp	SHORT $LN95@Validate
$LN94@Validate:
	mov	edx, DWORD PTR $T256429[ebp]
	cmp	edx, DWORD PTR $T256440[ebp]
	jl	SHORT $LN95@Validate
	mov	eax, DWORD PTR $T256429[ebp]
	cdq
	idiv	DWORD PTR $T256440[ebp]
	mov	DWORD PTR _iMapX$256529[ebp], edx
	jmp	SHORT $LN96@Validate
$LN95@Validate:
	mov	eax, DWORD PTR $T256429[ebp]
	mov	DWORD PTR _iMapX$256529[ebp], eax
$LN96@Validate:
	mov	ecx, DWORD PTR _kParentMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T256451[ebp], dl
	mov	eax, DWORD PTR _kParentMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T256455[ebp], ecx
	movzx	edx, BYTE PTR $T256451[ebp]
	test	edx, edx
	je	SHORT $LN105@Validate
	cmp	DWORD PTR $T256420[ebp], 0
	jge	SHORT $LN104@Validate
	mov	eax, DWORD PTR $T256420[ebp]
	cdq
	idiv	DWORD PTR $T256455[ebp]
	add	edx, DWORD PTR $T256455[ebp]
	mov	DWORD PTR _iMapY$256530[ebp], edx
	jmp	SHORT $LN106@Validate
	jmp	SHORT $LN105@Validate
$LN104@Validate:
	mov	eax, DWORD PTR $T256420[ebp]
	cmp	eax, DWORD PTR $T256455[ebp]
	jl	SHORT $LN105@Validate
	mov	eax, DWORD PTR $T256420[ebp]
	cdq
	idiv	DWORD PTR $T256455[ebp]
	mov	DWORD PTR _iMapY$256530[ebp], edx
	jmp	SHORT $LN106@Validate
$LN105@Validate:
	mov	ecx, DWORD PTR $T256420[ebp]
	mov	DWORD PTR _iMapY$256530[ebp], ecx
$LN106@Validate:
	cmp	DWORD PTR _iMapX$256529[ebp], 0
	jl	SHORT $LN110@Validate
	mov	edx, DWORD PTR _kParentMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T256469[ebp], eax
	mov	ecx, DWORD PTR _iMapX$256529[ebp]
	cmp	ecx, DWORD PTR $T256469[ebp]
	jge	SHORT $LN110@Validate
	cmp	DWORD PTR _iMapY$256530[ebp], 0
	jl	SHORT $LN110@Validate
	mov	edx, DWORD PTR _kParentMap$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T256473[ebp], eax
	mov	ecx, DWORD PTR _iMapY$256530[ebp]
	cmp	ecx, DWORD PTR $T256473[ebp]
	jge	SHORT $LN110@Validate
	mov	DWORD PTR tv343[ebp], 1
	jmp	SHORT $LN108@Validate
$LN110@Validate:
	mov	DWORD PTR tv343[ebp], 0
$LN108@Validate:
	cmp	DWORD PTR tv343[ebp], 0
	je	SHORT $LN86@Validate
	mov	edx, DWORD PTR _kParentMap$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T256486[ebp], eax
	mov	ecx, DWORD PTR _iMapY$256530[ebp]
	imul	ecx, DWORD PTR $T256486[ebp]
	add	ecx, DWORD PTR _iMapX$256529[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _kParentMap$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv328[ebp], ecx
	jmp	SHORT $LN87@Validate
$LN86@Validate:
	mov	DWORD PTR tv328[ebp], 0
$LN87@Validate:
	mov	eax, DWORD PTR tv328[ebp]
	mov	DWORD PTR _pkCorrectPlot$226964[ebp], eax
$LN84@Validate:

; 11350: 				if(pkCorrectPlot)

	cmp	DWORD PTR _pkCorrectPlot$226964[ebp], 0
	je	SHORT $LN4@Validate

; 11351: 				{
; 11352: 					if(pkCorrectPlot->getUnitIndex(pkUnit) < 0)	// Already in there?

	mov	ecx, DWORD PTR _pkUnit$226959[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkCorrectPlot$226964[ebp]
	call	?getUnitIndex@CvPlot@@QBEHPAVCvUnit@@@Z	; CvPlot::getUnitIndex
	test	eax, eax
	jge	SHORT $LN3@Validate

; 11353: 						pkCorrectPlot->addUnit(pkUnit, false);		// Nope, add it.

	push	0
	mov	edx, DWORD PTR _pkUnit$226959[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkCorrectPlot$226964[ebp]
	call	?addUnit@CvPlot@@QAEXPAVCvUnit@@_N@Z	; CvPlot::addUnit
$LN3@Validate:

; 11354: 				}
; 11355: 				else

	jmp	SHORT $LN2@Validate
$LN4@Validate:

; 11356: 				{
; 11357: 					// Drat, that plot does not exist.
; 11358: 					iError |= 2;

	mov	eax, DWORD PTR _iError$[ebp]
	or	eax, 2
	mov	DWORD PTR _iError$[ebp], eax
$LN2@Validate:

; 11359: 				}
; 11360: 
; 11361: 				pUnitNode = headUnitNode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax

; 11362: 			}
; 11363: 			else

	jmp	SHORT $LN7@Validate
$LN6@Validate:

; 11364: 				pUnitNode = nextUnitNode(pUnitNode);

	mov	ecx, DWORD PTR _pUnitNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextUnitNode@CvPlot@@QAEPAUIDInfo@@PAU2@@Z ; CvPlot::nextUnitNode
	mov	DWORD PTR _pUnitNode$[ebp], eax
$LN7@Validate:

; 11365: 		}
; 11366: 	}

	jmp	$LN10@Validate
$LN9@Validate:

; 11367: 
; 11368: 	return iError;

	mov	eax, DWORD PTR _iError$[ebp]

; 11369: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?Validate@CvPlot@@QAEHAAVCvMap@@@Z ENDP			; CvPlot::Validate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T256544 = -9						; size = 1
$T256543 = -8						; size = 4
$T256539 = -4						; size = 4
_ePlayer$ = 8						; size = 4
?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z PROC ; CvPlot::MustPayMaintenanceHere, COMDAT
; _this$ = ecx

; 11374: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 11375: 	if(isHills() && GET_PLAYER(ePlayer).GetPlayerTraits()->IsNoHillsImprovementMaintenance())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@MustPayMai
	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T256539[ebp], eax
	mov	ecx, DWORD PTR $T256539[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T256543[ebp], eax
	mov	ecx, DWORD PTR $T256543[ebp]
	mov	dl, BYTE PTR [ecx+338]
	mov	BYTE PTR $T256544[ebp], dl
	movzx	eax, BYTE PTR $T256544[ebp]
	test	eax, eax
	je	SHORT $LN1@MustPayMai

; 11376: 	{
; 11377: 		return false;

	xor	al, al
	jmp	SHORT $LN2@MustPayMai
$LN1@MustPayMai:

; 11378: 	}
; 11379: 
; 11380: 	return true;

	mov	al, 1
$LN2@MustPayMai:

; 11381: }

	mov	esp, ebp
	pop	ebp
	ret	4
?MustPayMaintenanceHere@CvPlot@@QBE_NW4PlayerTypes@@@Z ENDP ; CvPlot::MustPayMaintenanceHere
_TEXT	ENDS
PUBLIC	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z ; CvPlot::AddArchaeologicalRecord
EXTRN	?IsArchaeologyTriggered@CvGame@@QBE_NXZ:PROC	; CvGame::IsArchaeologyTriggered
; Function compile flags: /Odtp
;	COMDAT ?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T256554 = -8						; size = 4
$T256550 = -4						; size = 4
_eType$ = 8						; size = 4
_ePlayer1$ = 12						; size = 4
_ePlayer2$ = 16						; size = 4
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z PROC ; CvPlot::AddArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11385: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 11386: 	// Make sure the new record is more significant
; 11387: 	if (!GC.getGame().IsArchaeologyTriggered() && eType > m_kArchaeologyData.m_eArtifactType)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T256550[ebp], eax
	mov	ecx, DWORD PTR $T256550[ebp]
	call	?IsArchaeologyTriggered@CvGame@@QBE_NXZ	; CvGame::IsArchaeologyTriggered
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@AddArchaeo
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eType$[ebp]
	cmp	eax, DWORD PTR [edx+464]
	jle	SHORT $LN3@AddArchaeo

; 11388: 	{
; 11389: 		if (ePlayer1 != NO_PLAYER)

	cmp	DWORD PTR _ePlayer1$[ebp], -1
	je	SHORT $LN3@AddArchaeo

; 11390: 		{
; 11391: 			m_kArchaeologyData.m_eArtifactType = eType;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [ecx+464], edx

; 11392: 			m_kArchaeologyData.m_ePlayer1 = ePlayer1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer1$[ebp]
	mov	DWORD PTR [eax+472], ecx

; 11393: 			m_kArchaeologyData.m_ePlayer2 = ePlayer2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ePlayer2$[ebp]
	mov	DWORD PTR [edx+476], eax

; 11394: 			m_kArchaeologyData.m_eEra = GET_PLAYER(ePlayer1).GetCurrentEra();

	mov	ecx, DWORD PTR _ePlayer1$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T256554[ebp], ecx
	mov	ecx, DWORD PTR $T256554[ebp]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], eax
$LN3@AddArchaeo:

; 11395: 		}
; 11396: 	}
; 11397: }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4PlayerTypes@@1@Z ENDP ; CvPlot::AddArchaeologicalRecord
_TEXT	ENDS
PUBLIC	?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z ; CvPlot::AddArchaeologicalRecord
; Function compile flags: /Odtp
;	COMDAT ?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T256560 = -4						; size = 4
_eType$ = 8						; size = 4
_eEra$ = 12						; size = 4
_ePlayer1$ = 16						; size = 4
_ePlayer2$ = 20						; size = 4
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z PROC ; CvPlot::AddArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11401: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 11402: 	// Make sure the new record is more significant
; 11403: 	if (!GC.getGame().IsArchaeologyTriggered() && eType > m_kArchaeologyData.m_eArtifactType)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T256560[ebp], eax
	mov	ecx, DWORD PTR $T256560[ebp]
	call	?IsArchaeologyTriggered@CvGame@@QBE_NXZ	; CvGame::IsArchaeologyTriggered
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@AddArchaeo@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _eType$[ebp]
	cmp	eax, DWORD PTR [edx+464]
	jle	SHORT $LN3@AddArchaeo@2

; 11404: 	{
; 11405: 		if (ePlayer1 != NO_PLAYER)

	cmp	DWORD PTR _ePlayer1$[ebp], -1
	je	SHORT $LN3@AddArchaeo@2

; 11406: 		{
; 11407: 			m_kArchaeologyData.m_eArtifactType = eType;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [ecx+464], edx

; 11408: 			m_kArchaeologyData.m_ePlayer1 = ePlayer1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer1$[ebp]
	mov	DWORD PTR [eax+472], ecx

; 11409: 			m_kArchaeologyData.m_ePlayer2 = ePlayer2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ePlayer2$[ebp]
	mov	DWORD PTR [edx+476], eax

; 11410: 			m_kArchaeologyData.m_eEra = eEra;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eEra$[ebp]
	mov	DWORD PTR [ecx+468], edx
$LN3@AddArchaeo@2:

; 11411: 		}
; 11412: 	}
; 11413: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddArchaeologicalRecord@CvPlot@@QAEXW4GreatWorkArtifactClass@@W4EraTypes@@W4PlayerTypes@@2@Z ENDP ; CvPlot::AddArchaeologicalRecord
_TEXT	ENDS
PUBLIC	?ClearArchaeologicalRecord@CvPlot@@QAEXXZ	; CvPlot::ClearArchaeologicalRecord
; Function compile flags: /Odtp
;	COMDAT ?ClearArchaeologicalRecord@CvPlot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearArchaeologicalRecord@CvPlot@@QAEXXZ PROC		; CvPlot::ClearArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11417: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11418: 	m_kArchaeologyData.m_eArtifactType = NO_GREAT_WORK_ARTIFACT_CLASS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+464], 0

; 11419: 	m_kArchaeologyData.m_ePlayer1 = NO_PLAYER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+472], -1

; 11420: 	m_kArchaeologyData.m_ePlayer2 = NO_PLAYER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+476], -1

; 11421: 	m_kArchaeologyData.m_eEra = NO_ERA;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+468], -1

; 11422: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearArchaeologicalRecord@CvPlot@@QAEXXZ ENDP		; CvPlot::ClearArchaeologicalRecord
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ PROC ; CvPlot::GetArchaeologicalRecord, COMDAT
; _this$ = ecx

; 11426: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11427: 	return m_kArchaeologyData; // return a copy of the record

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 464				; 000001d0H
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 11428: }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ENDP ; CvPlot::GetArchaeologicalRecord
_TEXT	ENDS
PUBLIC	?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z ; CvPlot::SetArtifactType
; Function compile flags: /Odtp
;	COMDAT ?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eType$ = 8						; size = 4
?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z PROC ; CvPlot::SetArtifactType, COMDAT
; _this$ = ecx

; 11432: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11433: 	m_kArchaeologyData.m_eArtifactType = eType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [eax+464], ecx

; 11434: }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetArtifactType@CvPlot@@QAEXW4GreatWorkArtifactClass@@@Z ENDP ; CvPlot::SetArtifactType
_TEXT	ENDS
PUBLIC	?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z ; CvPlot::SetArtifactGreatWork
; Function compile flags: /Odtp
;	COMDAT ?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eWork$ = 8						; size = 4
?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z PROC ; CvPlot::SetArtifactGreatWork, COMDAT
; _this$ = ecx

; 11438: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11439: 	m_kArchaeologyData.m_eWork = eWork;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eWork$[ebp]
	mov	DWORD PTR [eax+480], ecx

; 11440: }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetArtifactGreatWork@CvPlot@@QAEXW4GreatWorkType@@@Z ENDP ; CvPlot::SetArtifactGreatWork
_TEXT	ENDS
PUBLIC	?HasWrittenArtifact@CvPlot@@QBE_NXZ		; CvPlot::HasWrittenArtifact
EXTRN	?getARTIFACT_WRITING@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ:PROC ; CvTypes::getARTIFACT_WRITING
; Function compile flags: /Odtp
;	COMDAT ?HasWrittenArtifact@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_bRtnValue$ = -5					; size = 1
_eArtifactClass$ = -4					; size = 4
?HasWrittenArtifact@CvPlot@@QBE_NXZ PROC		; CvPlot::HasWrittenArtifact, COMDAT
; _this$ = ecx

; 11444: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 11445: 	bool bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[ebp], 0

; 11446: 	GreatWorkArtifactClass eArtifactClass = m_kArchaeologyData.m_eArtifactType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+464]
	mov	DWORD PTR _eArtifactClass$[ebp], ecx

; 11447: 	if (eArtifactClass == CvTypes::getARTIFACT_WRITING())

	call	?getARTIFACT_WRITING@CvTypes@@YA?BW4GreatWorkArtifactClass@@XZ ; CvTypes::getARTIFACT_WRITING
	cmp	DWORD PTR _eArtifactClass$[ebp], eax
	jne	SHORT $LN1@HasWritten

; 11448: 	{
; 11449: 		bRtnValue = true;

	mov	BYTE PTR _bRtnValue$[ebp], 1
$LN1@HasWritten:

; 11450: 	}
; 11451: 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[ebp]

; 11452: }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasWrittenArtifact@CvPlot@@QBE_NXZ ENDP		; CvPlot::HasWrittenArtifact
_TEXT	ENDS
EXTRN	?isImpassable@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isImpassable
EXTRN	?isImpassable@CvTerrainInfo@@QBE_NXZ:PROC	; CvTerrainInfo::isImpassable
; Function compile flags: /Odtp
;	COMDAT ?updateImpassable@CvPlot@@IAEXXZ
_TEXT	SEGMENT
tv93 = -26						; size = 1
tv80 = -25						; size = 1
_this$ = -24						; size = 4
_f$256581 = -17						; size = 1
_pkFeatureInfo$227022 = -16				; size = 4
_pkTerrainInfo$227019 = -12				; size = 4
_eTerrain$ = -8						; size = 4
_eFeature$ = -4						; size = 4
?updateImpassable@CvPlot@@IAEXXZ PROC			; CvPlot::updateImpassable, COMDAT
; _this$ = ecx

; 11456: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 11457: 	const TerrainTypes eTerrain = getTerrainType();

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	mov	DWORD PTR _eTerrain$[ebp], ecx

; 11458: 	const FeatureTypes eFeature = getFeatureType();

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$256581[ebp], al
	movsx	ecx, BYTE PTR _f$256581[ebp]
	mov	DWORD PTR _eFeature$[ebp], ecx

; 11459: 
; 11460: 	m_bIsImpassable = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+462]
	and	al, 127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+462], al

; 11461: 
; 11462: 	if(eTerrain != NO_TERRAIN)

	cmp	DWORD PTR _eTerrain$[ebp], -1
	je	$LN6@updateImpa

; 11463: 	{
; 11464: 		if(eFeature == NO_FEATURE)

	cmp	DWORD PTR _eFeature$[ebp], -1
	jne	SHORT $LN4@updateImpa

; 11465: 		{
; 11466: 			CvTerrainInfo* pkTerrainInfo = GC.getTerrainInfo(eTerrain);

	mov	edx, DWORD PTR _eTerrain$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	DWORD PTR _pkTerrainInfo$227019[ebp], eax

; 11467: 			if(pkTerrainInfo)

	cmp	DWORD PTR _pkTerrainInfo$227019[ebp], 0
	je	SHORT $LN3@updateImpa

; 11468: 				m_bIsImpassable = pkTerrainInfo->isImpassable();

	mov	ecx, DWORD PTR _pkTerrainInfo$227019[ebp]
	call	?isImpassable@CvTerrainInfo@@QBE_NXZ	; CvTerrainInfo::isImpassable
	mov	BYTE PTR tv80[ebp], al
	mov	al, BYTE PTR tv80[ebp]
	and	al, 1
	shl	al, 7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 127					; 0000007fH
	or	dl, al
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+462], dl
$LN3@updateImpa:

; 11469: 		}
; 11470: 		else

	jmp	SHORT $LN6@updateImpa
$LN4@updateImpa:

; 11471: 		{
; 11472: 			CvFeatureInfo* pkFeatureInfo = GC.getFeatureInfo(eFeature);

	mov	ecx, DWORD PTR _eFeature$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _pkFeatureInfo$227022[ebp], eax

; 11473: 			if(pkFeatureInfo)

	cmp	DWORD PTR _pkFeatureInfo$227022[ebp], 0
	je	SHORT $LN6@updateImpa

; 11474: 				m_bIsImpassable = pkFeatureInfo->isImpassable();

	mov	ecx, DWORD PTR _pkFeatureInfo$227022[ebp]
	call	?isImpassable@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isImpassable
	mov	BYTE PTR tv93[ebp], al
	mov	dl, BYTE PTR tv93[ebp]
	and	dl, 1
	shl	dl, 7
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+462]
	and	cl, 127					; 0000007fH
	or	cl, dl
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+462], cl
$LN6@updateImpa:

; 11475: 		}
; 11476: 	}
; 11477: }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateImpassable@CvPlot@@IAEXXZ ENDP			; CvPlot::updateImpassable
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T256592 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4012], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T256592[ebp], ecx
	cmp	DWORD PTR $T256592[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T256592[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T256592[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAEIABQAVCvPlot@@@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::push_back
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T256769 = -148						; size = 4
$T256749 = -144						; size = 4
$T256734 = -140						; size = 4
$T256717 = -136						; size = 4
$T256704 = -132						; size = 4
$T256690 = -128						; size = 4
$T256645 = -45						; size = 1
$T256644 = -44						; size = 4
$T256643 = -37						; size = 1
$T256642 = -36						; size = 4
$T256641 = -29						; size = 1
$T256640 = -28						; size = 4
$T256639 = -24						; size = 4
$T256638 = -17						; size = 1
__Where$227194 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN9@insert

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert
$LN33@insert:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert
$LN9@insert:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T256638[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T256639[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
	mov	DWORD PTR $T256690[ebp], eax
	mov	edx, DWORD PTR $T256690[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T256638[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 644  : 		else

	jmp	$LN11@insert
$LN8@insert:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$227194[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert
	jmp	$LN79@insert
$LN6@insert:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T256704[ebp], ecx
	mov	edx, DWORD PTR $T256704[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T256717[ebp], eax
	mov	ecx, DWORD PTR $T256717[ebp]
	mov	DWORD PTR $T256640[ebp], ecx
	mov	edx, DWORD PTR __Where$227194[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T256640[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T256641[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T256642[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
	mov	DWORD PTR $T256734[ebp], eax
	mov	edx, DWORD PTR $T256734[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T256641[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 651  : 			else

	jmp	SHORT $LN79@insert
$LN4@insert:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$227194[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert:
	mov	ecx, DWORD PTR __Where$227194[ebp]
	mov	DWORD PTR $T256749[ebp], ecx
	mov	edx, DWORD PTR $T256749[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T256643[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T256644[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
	mov	DWORD PTR $T256769[ebp], eax
	mov	edx, DWORD PTR $T256769[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T256643[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert

; 657  : 			else

	jmp	SHORT $LN11@insert
$LN2@insert:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T256645[ebp], 0
	mov	ecx, DWORD PTR __Where$227194[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T256645[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@_N@2@ABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
PUBLIC	?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T256977 = -80						; size = 4
$T256976 = -76						; size = 4
$T256956 = -69						; size = 1
$T256955 = -68						; size = 4
$T256954 = -64						; size = 4
$T256959 = -45						; size = 1
$T256777 = -24						; size = 4
$T256776 = -20						; size = 4
$T256775 = -16						; size = 4
__Where$ = -12						; size = 8
__Num$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase, COMDAT
; _this$ = ecx

; 949  : 		{	// erase and count all that match _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 950  : 		_Pairii _Where = equal_range(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange

; 951  : 		size_type _Num = 0;

	mov	DWORD PTR __Num$[ebp], 0

; 952  : 		_Distance(_Where.first, _Where.second, _Num);

	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR $T256977[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256976[ebp], eax
	mov	cl, BYTE PTR $T256959[ebp]
	mov	BYTE PTR $T256956[ebp], cl
	mov	edx, DWORD PTR $T256977[ebp]
	mov	DWORD PTR $T256955[ebp], edx
	mov	eax, DWORD PTR $T256976[ebp]
	mov	DWORD PTR $T256954[ebp], eax
	jmp	SHORT $LN113@erase@2
$LN83@erase@2:
	lea	ecx, DWORD PTR $T256954[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
$LN113@erase@2:
	mov	ecx, DWORD PTR $T256954[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T256955[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN78@erase@2
	mov	edx, DWORD PTR __Num$[ebp]
	add	edx, 1
	mov	DWORD PTR __Num$[ebp], edx
	jmp	SHORT $LN83@erase@2
$LN78@erase@2:

; 953  : 		erase(_Where.first, _Where.second);

	mov	eax, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR $T256775[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T256776[ebp], ecx
	mov	edx, DWORD PTR $T256775[ebp]
	push	edx
	mov	eax, DWORD PTR $T256776[ebp]
	push	eax
	lea	ecx, DWORD PTR $T256777[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase

; 954  : 		return (_Num);

	mov	eax, DWORD PTR __Num$[ebp]

; 955  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEIABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T257162 = -30						; size = 1
$T257149 = -29						; size = 1
$T257145 = -28						; size = 4
$T257138 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T257162[ebp]
	mov	DWORD PTR $T257138[ebp], eax
	lea	ecx, DWORD PTR $T257149[ebp]
	mov	DWORD PTR $T257145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T257333 = -24						; size = 4
$T257332 = -20						; size = 4
_i$257328 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T257333[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T257332[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec
	xor	edx, edx
	je	SHORT $LN5@FStaticVec
	mov	DWORD PTR _i$257328[ebp], 0
	jmp	SHORT $LN10@FStaticVec
$LN9@FStaticVec:
	mov	eax, DWORD PTR _i$257328[ebp]
	add	eax, 1
	mov	DWORD PTR _i$257328[ebp], eax
$LN10@FStaticVec:
	mov	ecx, DWORD PTR _i$257328[ebp]
	cmp	ecx, DWORD PTR $T257333[ebp]
	jae	SHORT $LN5@FStaticVec
	jmp	SHORT $LN9@FStaticVec
$LN5@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T257332[ebp], edx
	je	SHORT $LN1@FStaticVec
	mov	eax, DWORD PTR $T257332[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,25,1,297,0>::~FStaticVector<IDInfo,25,1,297,0>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$257350 = -8					; size = 4
$T257345 = -4						; size = 4
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T257345[ebp], ecx
	cmp	DWORD PTR $T257345[ebp], 0
	je	SHORT $LN1@auto_ptr
	mov	edx, DWORD PTR $T257345[ebp]
	mov	DWORD PTR _inst$257350[ebp], edx
	mov	eax, DWORD PTR _inst$257350[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$257350[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvUnit1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvUnit1>::~auto_ptr<ICvUnit1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$257358 = -8					; size = 4
$T257353 = -4						; size = 4
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T257353[ebp], ecx
	cmp	DWORD PTR $T257353[ebp], 0
	je	SHORT $LN1@auto_ptr@2
	mov	edx, DWORD PTR $T257353[ebp]
	mov	DWORD PTR _inst$257358[ebp], edx
	mov	eax, DWORD PTR _inst$257358[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$257358[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvPlot1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvPlot1>::~auto_ptr<ICvPlot1>
_TEXT	ENDS
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T257371 = -20						; size = 4
_pRet$257367 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,50,1,297,0>::FStaticVector<IDInfo,50,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 50			; 00000032H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257371[ebp], edx
	cmp	DWORD PTR $T257371[ebp], 50		; 00000032H
	jbe	SHORT $LN7@FStaticVec@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T257371[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$257367[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T257371[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@2
$LN7@FStaticVec@2:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$257367[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 50			; 00000032H
$LN8@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$257367[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,50,1,297,0>::FStaticVector<IDInfo,50,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T257402 = -24						; size = 4
$T257401 = -20						; size = 4
_i$257397 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T257402[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T257401[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@3
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@3
	mov	DWORD PTR _i$257397[ebp], 0
	jmp	SHORT $LN10@FStaticVec@3
$LN9@FStaticVec@3:
	mov	eax, DWORD PTR _i$257397[ebp]
	add	eax, 1
	mov	DWORD PTR _i$257397[ebp], eax
$LN10@FStaticVec@3:
	mov	ecx, DWORD PTR _i$257397[ebp]
	cmp	ecx, DWORD PTR $T257402[ebp]
	jae	SHORT $LN5@FStaticVec@3
	jmp	SHORT $LN9@FStaticVec@3
$LN5@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T257401[ebp], edx
	je	SHORT $LN1@FStaticVec@3
	mov	eax, DWORD PTR $T257401[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@3:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,50,1,297,0>::~FStaticVector<IDInfo,50,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,50,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T257414 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,50,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+412], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,50,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T257414[ebp], ecx
	cmp	DWORD PTR $T257414[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T257414[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T257414[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,50,1,297,0>::push_back
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_inst$257463 = -8					; size = 4
$T257458 = -4						; size = 4
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ PROC		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>, COMDAT
; _this$ = ecx

; 720  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 721  : 		delete _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T257458[ebp], ecx
	cmp	DWORD PTR $T257458[ebp], 0
	je	SHORT $LN1@auto_ptr@3
	mov	edx, DWORD PTR $T257458[ebp]
	mov	DWORD PTR _inst$257463[ebp], edx
	mov	eax, DWORD PTR _inst$257463[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _inst$257463[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+4]
	call	eax
$LN1@auto_ptr@3:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$auto_ptr@VICvCity1@@@std@@QAE@XZ ENDP		; std::auto_ptr<ICvCity1>::~auto_ptr<ICvCity1>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
tv140 = -56						; size = 4
tv131 = -52						; size = 4
_this$ = -48						; size = 4
$T257466 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z PROC ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back@3

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T257466[ebp], eax
	cmp	DWORD PTR $T257466[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	ecx, DWORD PTR _element$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T257466[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T257466[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@3:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 381  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@QAEIABUIDInfo@@@Z ENDP ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_G?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z PROC ; FAutoArchiveClassContainer<CvPlot>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FAutoArchive@@UAE@XZ			; FAutoArchive::~FAutoArchive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$FAutoArchiveClassContainer@VCvPlot@@@@UAEPAXI@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~_Vector_val<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T257540 = -20						; size = 4
_pRet$257536 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 8

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T257540[ebp], edx
	cmp	DWORD PTR $T257540[ebp], 8
	jbe	SHORT $LN7@FStaticVec@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T257540[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$257536[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T257540[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@4
$LN7@FStaticVec@4:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$257536[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 8
$LN8@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$257536[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T257583 = -36						; size = 4
$T257582 = -32						; size = 4
_i$257578 = -28						; size = 4
$T257558 = -24						; size = 4
_pRet$257554 = -20					; size = 4
$T257549 = -16						; size = 4
_i$227391 = -12						; size = 4
_uiNewSize$227383 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z PROC ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$227383[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227383[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$227383[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T257558[ebp], ecx
	cmp	DWORD PTR $T257558[ebp], 1000		; 000003e8H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T257558[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$257554[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T257558[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$257554[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1000			; 000003e8H
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$257554[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227391[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$227391[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227391[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227391[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227391[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T257549[ebp], ecx
	cmp	DWORD PTR $T257549[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T257549[ebp]
	mov	edx, DWORD PTR _i$227391[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T257549[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257583[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T257582[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$257578[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	edx, DWORD PTR _i$257578[ebp]
	add	edx, 1
	mov	DWORD PTR _i$257578[ebp], edx
$LN26@GrowSize:
	mov	eax, DWORD PTR _i$257578[ebp]
	cmp	eax, DWORD PTR $T257583[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T257582[ebp], ecx
	je	SHORT $LN22@GrowSize
	mov	edx, DWORD PTR $T257582[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4012], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@IAEXI@Z ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::GrowSize
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T257805 = -72						; size = 4
$T257800 = -68						; size = 4
__Tmp$257784 = -48					; size = 4
$T257715 = -44						; size = 4
$T257702 = -40						; size = 4
$T257632 = -28						; size = 4
$T257609 = -24						; size = 4
$T257596 = -20						; size = 4
$T257590 = -16						; size = 4
$T257589 = -12						; size = 4
$T257588 = -8						; size = 4
$T257587 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T257596[ebp], ecx
	mov	edx, DWORD PTR $T257596[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T257609[ebp], eax
	mov	ecx, DWORD PTR $T257609[ebp]
	mov	DWORD PTR $T257587[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T257587[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257632[ebp], eax
	mov	ecx, DWORD PTR $T257632[ebp]
	mov	DWORD PTR $T257588[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T257588[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257702[ebp], eax
	mov	ecx, DWORD PTR $T257702[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T257715[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T257715[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@3

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@3

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN72@erase@3:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@3

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$257784[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$257784[ebp]
	mov	DWORD PTR $T257589[ebp], ecx
	mov	edx, DWORD PTR $T257589[ebp]
	push	edx
	lea	eax, DWORD PTR $T257590[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
	jmp	SHORT $LN72@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T257805[ebp], ecx
	mov	edx, DWORD PTR $T257805[ebp]
	mov	DWORD PTR $T257800[ebp], edx
	mov	eax, DWORD PTR $T257800[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@3:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T258342 = -188						; size = 4
$T258254 = -172						; size = 4
$T258169 = -160						; size = 4
$T258153 = -156						; size = 4
$T258134 = -152						; size = 4
$T258130 = -148						; size = 4
$T258045 = -136						; size = 4
$T257944 = -120						; size = 4
$T257922 = -116						; size = 4
$T257915 = -112						; size = 4
$T257911 = -108						; size = 4
$T257872 = -104						; size = 4
$T257863 = -100						; size = 4
$T257843 = -96						; size = 4
__Count$257823 = -92					; size = 4
$T257809 = -88						; size = 28
$T257808 = -60						; size = 40
__Pnode$227468 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$257823[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$257823[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$257823[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T257809[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T257809[ebp]
	push	eax
	lea	ecx, DWORD PTR $T257808[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T257808[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T257808[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T257809[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T257843[ebp], edx
	mov	eax, DWORD PTR $T257843[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T257863[ebp], eax
	mov	ecx, DWORD PTR $T257863[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T257872[ebp], ecx
	mov	edx, DWORD PTR $T257872[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$227468[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+16]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T257911[ebp], edx
	mov	eax, DWORD PTR $T257911[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T257915[ebp], ecx
	mov	edx, DWORD PTR __Pnode$227468[ebp]
	mov	eax, DWORD PTR $T257915[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$227468[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T257922[ebp], eax
	mov	ecx, DWORD PTR $T257922[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$227468[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$227468[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T257944[ebp], ecx
	mov	edx, DWORD PTR $T257944[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227468[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$227468[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$227468[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$227468[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$227468[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T258045[ebp], ecx
	mov	edx, DWORD PTR $T258045[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T258130[ebp], edx
	mov	eax, DWORD PTR $T258130[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T258134[ebp], ecx
	mov	edx, DWORD PTR $T258134[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$227468[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$227468[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T258153[ebp], ecx
	mov	edx, DWORD PTR $T258153[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227468[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T258169[ebp], edx
	mov	eax, DWORD PTR $T258169[ebp]
	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$227468[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227468[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$227468[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+16], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$227468[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T258254[ebp], edx
	mov	eax, DWORD PTR $T258254[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$227468[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T258342[ebp], eax
	mov	ecx, DWORD PTR $T258342[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+16], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR $T257809[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@ABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Insert
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_7logic_error@std@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T258438 = -16						; size = 4
$T258417 = -12						; size = 4
$T258410 = -8						; size = 4
__Pnode$227503 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN6@Inc
	jmp	$LN7@Inc
$LN6@Inc:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T258410[ebp], ecx
	mov	edx, DWORD PTR $T258410[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN27@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T258417[ebp], eax
	mov	ecx, DWORD PTR $T258417[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T258438[ebp], edx
$LN23@Inc:
	mov	eax, DWORD PTR $T258438[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN19@Inc
	mov	eax, DWORD PTR $T258438[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T258438[ebp], ecx
	jmp	SHORT $LN23@Inc
$LN19@Inc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T258438[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227503[ebp], eax
	mov	ecx, DWORD PTR __Pnode$227503[ebp]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN1@Inc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$227503[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$227503[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$227503[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$258464 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$258464[ebp], 76695844	; 04924924H
	cmp	DWORD PTR __Count$258464[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$258464[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T258571 = -28						; size = 4
$T258570 = -24						; size = 4
?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 56					; 00000038H
	idiv	ecx
	mov	DWORD PTR $T258571[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T258570[ebp], eax
	mov	ecx, DWORD PTR $T258570[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T258584 = -20						; size = 4
_pRet$258580 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 25			; 00000019H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T258584[ebp], edx
	cmp	DWORD PTR $T258584[ebp], 25		; 00000019H
	jbe	SHORT $LN7@FStaticVec@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T258584[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$258580[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T258584[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@5
$LN7@FStaticVec@5:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$258580[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 25			; 00000019H
$LN8@FStaticVec@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$258580[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,25,1,297,0>::FStaticVector<IDInfo,25,1,297,0>
; Function compile flags: /Odtp
;	COMDAT ?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
_uiNewSize$ = 8						; size = 4
?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::resize, COMDAT
; _this$ = ecx

; 666  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 667  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _uiNewSize$[ebp]
	jae	SHORT $LN1@resize

; 668  : 			GrowSize(uiNewSize);

	mov	edx, DWORD PTR _uiNewSize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
$LN1@resize:

; 669  : 		}
; 670  : 		m_uiCurrSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 671  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T258631 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+212], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,25,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T258631[ebp], ecx
	cmp	DWORD PTR $T258631[ebp], 0
	je	SHORT $LN4@push_back@4
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T258631[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T258631[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@4
$LN4@push_back@4:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T258709 = -36						; size = 4
$T258708 = -32						; size = 4
_i$258703 = -28						; size = 4
$T258684 = -24						; size = 4
_pRet$258680 = -20					; size = 4
$T258675 = -16						; size = 4
_i$227599 = -12						; size = 4
_uiNewSize$227591 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,50,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$227591[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227591[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$227591[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T258684[ebp], ecx
	cmp	DWORD PTR $T258684[ebp], 50		; 00000032H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T258684[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$258680[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T258684[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@2
$LN15@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$258680[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 50			; 00000032H
$LN16@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$258680[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227599[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$227599[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227599[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227599[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227599[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T258675[ebp], ecx
	cmp	DWORD PTR $T258675[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$227599[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T258675[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T258675[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@2:
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T258709[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T258708[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@2
	xor	edx, edx
	je	SHORT $LN21@GrowSize@2
	mov	DWORD PTR _i$258703[ebp], 0
	jmp	SHORT $LN26@GrowSize@2
$LN25@GrowSize@2:
	mov	eax, DWORD PTR _i$258703[ebp]
	add	eax, 1
	mov	DWORD PTR _i$258703[ebp], eax
$LN26@GrowSize@2:
	mov	ecx, DWORD PTR _i$258703[ebp]
	cmp	ecx, DWORD PTR $T258709[ebp]
	jae	SHORT $LN21@GrowSize@2
	jmp	SHORT $LN25@GrowSize@2
$LN21@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T258708[ebp], edx
	je	SHORT $LN22@GrowSize@2
	mov	eax, DWORD PTR $T258708[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+412], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$0DC@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,50,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z
_TEXT	SEGMENT
tv185 = -48						; size = 4
_this$ = -44						; size = 4
$T258754 = -40						; size = 4
$T258753 = -36						; size = 4
_i$258746 = -32						; size = 4
$T258725 = -28						; size = 4
_pRet$258721 = -24					; size = 4
$T258712 = -20						; size = 4
_i$227637 = -16						; size = 4
_uiNewSize$227628 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z PROC ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize@3:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize@3

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$227628[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$227628[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize@3

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize@3
$LN8@GrowSize@3:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227628[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize@3
$LN9@GrowSize@3:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T258725[ebp], eax
	cmp	DWORD PTR $T258725[ebp], 0
	jbe	SHORT $LN16@GrowSize@3
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T258725[ebp]
	shl	ecx, 3
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$258721[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T258725[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$258721[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize@3:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize@3

; 442  : 		{
; 443  : 			if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN6@GrowSize@3

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize@3
$LN6@GrowSize@3:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227637[ebp], 0
	jmp	SHORT $LN4@GrowSize@3
$LN3@GrowSize@3:
	mov	edx, DWORD PTR _i$227637[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227637[ebp], edx
$LN4@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227637[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize@3

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227637[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T258712[ebp], ecx
	cmp	DWORD PTR $T258712[ebp], 0
	je	SHORT $LN14@GrowSize@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$227637[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T258712[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T258712[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $LN15@GrowSize@3
$LN14@GrowSize@3:
	mov	DWORD PTR tv185[ebp], 0
$LN15@GrowSize@3:
	jmp	SHORT $LN3@GrowSize@3
$LN5@GrowSize@3:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T258754[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T258753[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN23@GrowSize@3
	xor	edx, edx
	je	SHORT $LN23@GrowSize@3
	mov	DWORD PTR _i$258746[ebp], 0
	jmp	SHORT $LN28@GrowSize@3
$LN27@GrowSize@3:
	mov	eax, DWORD PTR _i$258746[ebp]
	add	eax, 1
	mov	DWORD PTR _i$258746[ebp], eax
$LN28@GrowSize@3:
	mov	ecx, DWORD PTR _i$258746[ebp]
	cmp	ecx, DWORD PTR $T258754[ebp]
	jae	SHORT $LN23@GrowSize@3
	jmp	SHORT $LN27@GrowSize@3
$LN23@GrowSize@3:
	mov	edx, DWORD PTR $T258753[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize@3
$LN7@GrowSize@3:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN12@GrowSize@3:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@UIDInfo@@$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UIDInfo@@$00@@@@IAEXI@Z ENDP ; FFastVector<IDInfo,1,297,0,BaseVector<IDInfo,1>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R0?AVout_of_range@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -216						; size = 4
tv165 = -212						; size = 4
_this$ = -208						; size = 4
$T259615 = -204						; size = 4
$T259610 = -200						; size = 4
$T259014 = -136						; size = 4
$T259013 = -132						; size = 4
__Tmp$259011 = -125					; size = 1
$T258989 = -124						; size = 4
$T258982 = -120						; size = 4
$T258912 = -116						; size = 4
$T258876 = -112						; size = 4
$T258871 = -108						; size = 4
$T258843 = -104						; size = 4
$T258767 = -100						; size = 4
$T258758 = -96						; size = 28
$T258757 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T258767[ebp], eax
	mov	ecx, DWORD PTR $T258767[ebp]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN55@erase@4

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T258758[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T258758[ebp]
	push	eax
	lea	ecx, DWORD PTR $T258757[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T258757[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T258757[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T258758[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@4:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN67@erase@4

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@4

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@4:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN71@erase@4

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@4

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@4:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@4:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@4

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN81@erase@4

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@4

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@4

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@4:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@4

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@4

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@4:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@4:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T258843[ebp], ecx
	mov	edx, DWORD PTR $T258843[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@4

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN43@erase@4
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@4
$LN43@erase@4:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T258871[ebp], ecx
$LN107@erase@4:
	mov	edx, DWORD PTR $T258871[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN103@erase@4
	mov	edx, DWORD PTR $T258871[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T258871[ebp], eax
	jmp	SHORT $LN107@erase@4
$LN103@erase@4:
	mov	ecx, DWORD PTR $T258871[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T258876[ebp], eax
	mov	ecx, DWORD PTR $T258876[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@4

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	je	SHORT $LN45@erase@4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@4
$LN45@erase@4:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T258912[ebp], eax
$LN127@erase@4:
	mov	ecx, DWORD PTR $T258912[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN123@erase@4
	mov	ecx, DWORD PTR $T258912[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T258912[ebp], edx
	jmp	SHORT $LN127@erase@4
$LN123@erase@4:
	mov	eax, DWORD PTR $T258912[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@4:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@4

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@4:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@4

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@4

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN151@erase@4

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@4:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@4

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@4

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@4:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T258982[ebp], ecx
	mov	edx, DWORD PTR $T258982[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@4

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T258989[ebp], edx
	mov	eax, DWORD PTR $T258989[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@4

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@4:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T259014[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T259013[ebp], eax
	mov	ecx, DWORD PTR $T259013[ebp]
	cmp	ecx, DWORD PTR $T259014[ebp]
	je	SHORT $LN192@erase@4
	mov	edx, DWORD PTR $T259013[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$259011[ebp], al
	mov	ecx, DWORD PTR $T259013[ebp]
	mov	edx, DWORD PTR $T259014[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T259014[ebp]
	mov	dl, BYTE PTR __Tmp$259011[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@4:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 1
	jne	$LN588@erase@4

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@4
$LN194@erase@4:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	cmp	edx, 1
	jne	$LN586@erase@4

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@4

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN263@erase@4

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+16], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+16], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN267@erase@4

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@4

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@4
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@4

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+16], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@4

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+16]
	cmp	eax, 1
	jne	SHORT $LN338@erase@4

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+16], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+16], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+16]
	mov	BYTE PTR [ecx+16], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+16], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+16], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@4
$LN12@erase@4:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@4

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@4:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN454@erase@4

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+16], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+16], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN458@erase@4

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@4

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@4
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+16]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@4

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+16], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@4

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+16]
	cmp	eax, 1
	jne	SHORT $LN529@erase@4

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+16], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+16], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+16]
	mov	BYTE PTR [ecx+16], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+16], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@4
$LN8@erase@4:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@4

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@4:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN588@erase@4:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@4

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@4:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T259615[ebp], edx
	mov	eax, DWORD PTR $T259615[ebp]
	mov	DWORD PTR $T259610[ebp], eax
	mov	ecx, DWORD PTR $T259610[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@4:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T258758[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 134  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
PUBLIC	?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T259694 = -8						; size = 4
?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T259694[ebp], eax
	mov	ecx, DWORD PTR $T259694[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z
_TEXT	SEGMENT
tv146 = -28						; size = 4
_this$ = -24						; size = 4
__Hinode$ = -20						; size = 4
__Last$ = -16						; size = 4
__Lonode$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange, COMDAT
; _this$ = ecx

; 1132 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1133 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1134 : 		_Nodeptr _Lonode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Lonode$[ebp], ecx

; 1135 : 		_Nodeptr _Hinode = _Myhead;	// end() if search fails

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Hinode$[ebp], eax

; 1136 : 
; 1137 : 		while (!_Isnil(_Pnode))

$LN18@Eqrange:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN42@Eqrange

; 1138 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Keyval$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN30@Eqrange

; 1139 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1140 : 			else

	jmp	SHORT $LN6@Eqrange

; 1141 : 				{	// _Pnode not less than _Keyval, remember it
; 1142 : 				if (_Isnil(_Hinode)
; 1143 : 						&& _DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

$LN30@Eqrange:
	mov	ecx, DWORD PTR __Hinode$[ebp]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN5@Eqrange
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Eqrange

; 1144 : 					_Hinode = _Pnode;	// _Pnode greater, remember it

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Hinode$[ebp], edx
$LN5@Eqrange:

; 1145 : 				_Lonode = _Pnode;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Lonode$[ebp], eax

; 1146 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN6@Eqrange:

; 1147 : 				}

	jmp	SHORT $LN18@Eqrange

; 1148 : 
; 1149 : 		_Pnode = _Isnil(_Hinode) ? _Root()
; 1150 : 			: _Left(_Hinode);	// continue scan for upper bound

$LN42@Eqrange:
	mov	eax, DWORD PTR __Hinode$[ebp]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	je	SHORT $LN48@Eqrange
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv146[ebp], ecx
	jmp	SHORT $LN13@Eqrange
$LN48@Eqrange:
	mov	edx, DWORD PTR __Hinode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv146[ebp], eax
$LN13@Eqrange:
	mov	ecx, DWORD PTR tv146[ebp]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1151 : 		while (!_Isnil(_Pnode))

$LN50@Eqrange:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN3@Eqrange

; 1152 : 			if (_DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	mov	ecx, DWORD PTR __Keyval$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+12]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN62@Eqrange

; 1153 : 				{	// _Pnode greater than _Keyval, remember it
; 1154 : 				_Hinode = _Pnode;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Hinode$[ebp], eax

; 1155 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1156 : 				}
; 1157 : 			else

	jmp	SHORT $LN1@Eqrange

; 1158 : 				_Pnode = _Right(_Pnode);	// descend right subtree

$LN62@Eqrange:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Eqrange:
	jmp	SHORT $LN50@Eqrange
$LN3@Eqrange:

; 1159 : 
; 1160 : 		iterator _First = _TREE_ITERATOR(_Lonode);

	mov	edx, DWORD PTR __Lonode$[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 1161 : 		iterator _Last = _TREE_ITERATOR(_Hinode);

	mov	eax, DWORD PTR __Hinode$[ebp]
	mov	DWORD PTR __Last$[ebp], eax

; 1162 : 		return (_Pairii(_First, _Last));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1163 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Eqrange@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@V123@@2@ABQAVCvPlot@@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Eqrange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T259879 = -12						; size = 4
$T259872 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T259872[ebp], eax
	mov	ecx, DWORD PTR $T259872[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T259879[ebp], ecx
	mov	edx, DWORD PTR $T259879[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T259955 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T259955[ebp], eax
	mov	ecx, DWORD PTR $T259955[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T259965 = -28						; size = 4
$T259964 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T259965[ebp], eax
	cmp	DWORD PTR $T259965[ebp], 0
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR $T259965[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T259965[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T259965[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T259965[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T259965[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+16], dl
	mov	eax, DWORD PTR $T259965[ebp]
	mov	BYTE PTR [eax+17], 0
	mov	ecx, DWORD PTR $T259965[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN5@Buynode
$LN4@Buynode:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T259964[ebp], edx
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@PAU342@00ABQAVCvPlot@@D@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z$0
__ehfuncinfo$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T260075 = -32						; size = 4
$T260074 = -28						; size = 4
$T260053 = -24						; size = 4
$T260052 = -20						; size = 4
__Cat$260059 = -14					; size = 1
$T260056 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T260075[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T260074[ebp], ecx
	mov	dl, BYTE PTR __Cat$260059[ebp]
	mov	BYTE PTR $T260056[ebp], dl
	mov	eax, DWORD PTR $T260075[ebp]
	mov	DWORD PTR $T260053[ebp], eax
	mov	ecx, DWORD PTR $T260074[ebp]
	mov	DWORD PTR $T260052[ebp], ecx
	jmp	SHORT $LN9@Destroy
$LN8@Destroy:
	mov	edx, DWORD PTR $T260052[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR $T260052[ebp], edx
$LN9@Destroy:
	mov	eax, DWORD PTR $T260052[ebp]
	cmp	eax, DWORD PTR $T260053[ebp]
	je	SHORT $LN1@Destroy
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T260052[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T260052[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN12@Destroy
	mov	edx, DWORD PTR $T260052[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Destroy:
	jmp	SHORT $LN8@Destroy
$LN1@Destroy:

; 1120 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z$0:
	mov	ecx, DWORD PTR $T260052[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Destroy@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@IAEXPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@0@Z ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Destroy
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T260085 = -80						; size = 28
$T260084 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T260085[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T260084[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T260084[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T260085[ebp]
	push	eax
	lea	ecx, DWORD PTR $T260084[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T260084[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T260084[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T260085[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T260085[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T260084[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Xlen
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T260140 = -36						; size = 4
$T260139 = -32						; size = 4
_i$260132 = -28						; size = 4
$T260115 = -24						; size = 4
_pRet$260112 = -20					; size = 4
$T260106 = -16						; size = 4
_i$227843 = -12						; size = 4
_uiNewSize$227835 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,25,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@4

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$227835[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227835[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@4

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@4
$LN6@GrowSize@4:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$227835[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@4
$LN7@GrowSize@4:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T260115[ebp], ecx
	cmp	DWORD PTR $T260115[ebp], 25		; 00000019H
	jbe	SHORT $LN15@GrowSize@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T260115[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$260112[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T260115[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@4
$LN15@GrowSize@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$260112[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 25			; 00000019H
$LN16@GrowSize@4:
	mov	ecx, DWORD PTR _pRet$260112[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@4

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@4
$LN5@GrowSize@4:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227843[ebp], 0
	jmp	SHORT $LN3@GrowSize@4
$LN2@GrowSize@4:
	mov	edx, DWORD PTR _i$227843[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227843[ebp], edx
$LN3@GrowSize@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227843[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@4

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227843[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T260106[ebp], ecx
	cmp	DWORD PTR $T260106[ebp], 0
	je	SHORT $LN12@GrowSize@4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$227843[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T260106[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T260106[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize@4
$LN12@GrowSize@4:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@4:
	jmp	SHORT $LN2@GrowSize@4
$LN4@GrowSize@4:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T260140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T260139[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@4
	xor	edx, edx
	je	SHORT $LN21@GrowSize@4
	mov	DWORD PTR _i$260132[ebp], 0
	jmp	SHORT $LN26@GrowSize@4
$LN25@GrowSize@4:
	mov	eax, DWORD PTR _i$260132[ebp]
	add	eax, 1
	mov	DWORD PTR _i$260132[ebp], eax
$LN26@GrowSize@4:
	mov	ecx, DWORD PTR _i$260132[ebp]
	cmp	ecx, DWORD PTR $T260140[ebp]
	jae	SHORT $LN21@GrowSize@4
	jmp	SHORT $LN25@GrowSize@4
$LN21@GrowSize@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T260139[ebp], edx
	je	SHORT $LN22@GrowSize@4
	mov	eax, DWORD PTR $T260139[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+212], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$0BJ@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,25,1,297,0>::GrowSize
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$227897 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$227897[ebp], eax
	jmp	SHORT $LN6@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$227897[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase:
	mov	edx, DWORD PTR __Pnode$227897[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$227897[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$227897[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$227897[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T260205 = -16						; size = 4
$T260184 = -12						; size = 4
$T260177 = -8						; size = 4
__Pnode$227945 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T260177[ebp], edx
	mov	eax, DWORD PTR $T260177[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T260184[ebp], ecx
	mov	edx, DWORD PTR $T260184[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T260205[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T260205[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T260205[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T260205[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T260205[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$227945[ebp], ecx
	mov	edx, DWORD PTR __Pnode$227945[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$227945[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$227945[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$227945[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??_7?$FAutoVariable@DVCvPlot@@@@6B@		; FAutoVariable<char,CvPlot>::`vftable'
PUBLIC	?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::load
PUBLIC	?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::loadDelta
PUBLIC	?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::save
PUBLIC	?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::saveDelta
PUBLIC	?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ	; FAutoVariable<char,CvPlot>::clearDelta
PUBLIC	?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z ; FAutoVariable<char,CvPlot>::compare
PUBLIC	?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ	; FAutoVariable<char,CvPlot>::reset
PUBLIC	?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; FAutoVariable<char,CvPlot>::name
PUBLIC	?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ; FAutoVariable<char,CvPlot>::setStackTraceRemark
PUBLIC	?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z ; FAutoVariable<char,CvPlot>::debugDump
PUBLIC	?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; FAutoVariable<char,CvPlot>::toString
EXTRN	??0FAutoVariableBase@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVFAutoArchive@@_N@Z:PROC ; FAutoVariableBase::FAutoVariableBase
EXTRN	??_E?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z:PROC	; FAutoVariable<char,CvPlot>::`vector deleting destructor'
;	COMDAT ??_7?$FAutoVariable@DVCvPlot@@@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
CONST	SEGMENT
??_7?$FAutoVariable@DVCvPlot@@@@6B@ DD FLAT:??_E?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z ; FAutoVariable<char,CvPlot>::`vftable'
	DD	FLAT:?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
	DD	FLAT:?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z
	DD	FLAT:?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
	DD	FLAT:?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
	DD	FLAT:?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	DD	FLAT:?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_name$ = 8						; size = 4
_owner$ = 12						; size = 4
_callStackTracking$ = 16				; size = 1
??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z PROC ; FAutoVariable<char,CvPlot>::FAutoVariable<char,CvPlot>, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _callStackTracking$[ebp]
	push	eax
	mov	ecx, DWORD PTR _owner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0FAutoVariableBase@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVFAutoArchive@@_N@Z ; FAutoVariableBase::FAutoVariableBase
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FAutoVariable@DVCvPlot@@@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _owner$[ebp]
	mov	DWORD PTR [edx+8], eax

; 148  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$FAutoVariable@DVCvPlot@@@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV?$FAutoArchiveClassContainer@VCvPlot@@@@_N@Z ENDP ; FAutoVariable<char,CvPlot>::FAutoVariable<char,CvPlot>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
$T260227 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T260227[ebp], 0

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 503  : 	text << arg1;

	lea	edx, DWORD PTR _arg1$[ebp]
	push	edx
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 504  : 
; 505  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 507  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 508  : 	str.assign(szComposedString, bytes);

	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _szComposedString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 509  : 	return str;

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T260227[ebp]
	or	edx, 1
	mov	DWORD PTR $T260227[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2:
	mov	eax, DWORD PTR $T260227[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@2
	and	DWORD PTR $T260227[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
$T260253 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T260253[ebp], 0

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 517  : 
; 518  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 520  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 521  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 522  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T260253[ebp]
	or	eax, 1
	mov	DWORD PTR $T260253[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2:
	mov	eax, DWORD PTR $T260253[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@3
	and	DWORD PTR $T260253[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NH@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z PROC	; operator<<<int>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NH@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ENDP	; operator<<<int>
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ PROC		; sprintf_s<256>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	256					; 00000100H
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
??$sprintf_s@$0BAA@@@YAHAAY0BAA@DPBDZZ ENDP		; sprintf_s<256>
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$1
__ehfuncinfo$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
_TEXT	SEGMENT
$T260285 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
_arg3$ = 24						; size = 4
??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z PROC ; GetLocalizedText<char const *,int,char const *>, COMDAT

; 527  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T260285[ebp], 0

; 528  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 529  : 	text << arg1 << arg2 << arg3;

	mov	edx, DWORD PTR _arg3$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _arg1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _text$[ebp]
	push	edx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6H@@YAAAVString@Localization@@AAV01@ABH@Z ; operator<<<int>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 530  : 
; 531  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 532  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	eax, DWORD PTR _bytes$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 533  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 534  : 	str.assign(szComposedString, bytes);

	mov	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szComposedString$[ebp]
	push	edx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 535  : 	return str;

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T260285[ebp]
	or	ecx, 1
	mov	DWORD PTR $T260285[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z$2:
	mov	eax, DWORD PTR $T260285[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@4
	and	DWORD PTR $T260285[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@4:
	ret	0
__ehhandler$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDHPBD@@YA?AVCvString@@PBDABQBDABH1@Z ENDP ; GetLocalizedText<char const *,int,char const *>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z
_TEXT	SEGMENT
_archive$ = 8						; size = 4
_object$ = 12						; size = 4
??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z PROC ; operator>><char,CvPlot>, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp

; 106  : 	object.load(archive);

	mov	eax, DWORD PTR _archive$[ebp]
	push	eax
	mov	ecx, DWORD PTR _object$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _object$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 107  : 	return archive;

	mov	eax, DWORD PTR _archive$[ebp]

; 108  : }

	pop	ebp
	ret	0
??$?5DVCvPlot@@@@YAAAVFDataStream@@AAV0@AAV?$FAutoVariable@DVCvPlot@@@@@Z ENDP ; operator>><char,CvPlot>
_TEXT	ENDS
PUBLIC	??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z	; operator>><short,1>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z PROC ; operator>><short [1],80>, COMDAT

; 234  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 235  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 236  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator@2:
	cmp	DWORD PTR _i$[ebp], 80			; 00000050H
	jae	SHORT $LN1@operator@2

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z ; operator>><short,1>
	add	esp, 8

; 239  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 240  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5$$BY00F$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0F@Z ENDP ; operator>><short [1],80>
_TEXT	ENDS
PUBLIC	??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z	; operator<<<short,1>
; Function compile flags: /Odtp
;	COMDAT ??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z PROC ; operator<<<short const [1],80>, COMDAT

; 223  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 224  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 225  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator@3:
	cmp	DWORD PTR _i$[ebp], 80			; 00000050H
	jae	SHORT $LN1@operator@3

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _readFrom$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	push	ecx
	call	??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z ; operator<<<short,1>
	add	esp, 8

; 228  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 229  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6$$BY00$$CBF$0FA@@@YAAAVFDataStream@@AAV0@AAY1FA@0$$CBF@Z ENDP ; operator<<<short const [1],80>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
_TEXT	ENDS
;	COMDAT ??$sprintf_s@$07@@YAHAAY07DPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$07@@YAHAAY07DPBDZZ PROC			; sprintf_s<8>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
??$sprintf_s@$07@@YAHAAY07DPBDZZ ENDP			; sprintf_s<8>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z
_TEXT	SEGMENT
$T260319 = -16						; size = 4
$T260315 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 56					; 00000038H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T260319[ebp], 0
	lea	eax, DWORD PTR $T260319[ebp]
	push	eax
	lea	ecx, DWORD PTR $T260315[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T260315[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T260315[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 56					; 00000038H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T260333 = -16						; size = 4
$T260329 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T260333[ebp], 0
	lea	eax, DWORD PTR $T260333[ebp]
	push	eax
	lea	ecx, DWORD PTR $T260329[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T260329[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T260329[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z PROC		; operator>><short,1>, COMDAT

; 234  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 235  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 236  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator@4:
	cmp	DWORD PTR _i$[ebp], 1
	jae	SHORT $LN1@operator@4

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 239  : 	}

	jmp	SHORT $LN2@operator@4
$LN1@operator@4:

; 240  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5F$00@@YAAAVFDataStream@@AAV0@AAY00F@Z ENDP		; operator>><short,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z PROC	; operator<<<short,1>, COMDAT

; 223  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 224  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 225  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@5
$LN2@operator@5:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator@5:
	cmp	DWORD PTR _i$[ebp], 1
	jae	SHORT $LN1@operator@5

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _readFrom$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 228  : 	}

	jmp	SHORT $LN2@operator@5
$LN1@operator@5:

; 229  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6F$00@@YAAAVFDataStream@@AAV0@AAY00$$CBF@Z ENDP	; operator<<<short,1>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T260354 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T260354[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T260354[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T260360 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T260360[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T260360[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiOffset$260370 = -8					; size = 4
$T260366 = -4						; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 611  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		if(bDebug && GC.getGame().isDebugMode())

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	je	SHORT $LN1@isRevealed@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T260366[ebp], ecx
	mov	ecx, DWORD PTR $T260366[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@isRevealed@2

; 613  : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isRevealed@2
$LN1@isRevealed@2:

; 614  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 615  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 616  : 		return m_bfRevealed.GetBit(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$260370[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$260370[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$260370[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
$LN2@isRevealed@2:

; 617  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isRevealed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T260382 = -8						; size = 4
$T260378 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T260378[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T260378[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T260382[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T260382[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T260517 = -148						; size = 4
$T260497 = -144						; size = 4
$T260482 = -140						; size = 4
$T260465 = -136						; size = 4
$T260452 = -132						; size = 4
$T260438 = -128						; size = 4
$T260394 = -45						; size = 1
$T260393 = -44						; size = 4
$T260392 = -37						; size = 1
$T260391 = -36						; size = 4
$T260390 = -29						; size = 1
$T260389 = -28						; size = 4
$T260388 = -24						; size = 4
$T260387 = -17						; size = 1
__Where$198767 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@2:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN9@insert@2

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@2
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@2
$LN33@insert@2:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@2:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@2
$LN9@insert@2:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@2

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T260387[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T260388[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T260438[ebp], eax
	mov	edx, DWORD PTR $T260438[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T260387[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@2

; 644  : 		else

	jmp	$LN11@insert@2
$LN8@insert@2:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$198767[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@2
	jmp	$LN79@insert@2
$LN6@insert@2:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T260452[ebp], ecx
	mov	edx, DWORD PTR $T260452[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T260465[ebp], eax
	mov	ecx, DWORD PTR $T260465[ebp]
	mov	DWORD PTR $T260389[ebp], ecx
	mov	edx, DWORD PTR __Where$198767[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T260389[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@2

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T260390[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T260391[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T260482[ebp], eax
	mov	edx, DWORD PTR $T260482[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T260390[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@2

; 651  : 			else

	jmp	SHORT $LN79@insert@2
$LN4@insert@2:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$198767[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@2:
	mov	ecx, DWORD PTR __Where$198767[ebp]
	mov	DWORD PTR $T260497[ebp], ecx
	mov	edx, DWORD PTR $T260497[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@2

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T260392[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T260393[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	DWORD PTR $T260517[ebp], eax
	mov	edx, DWORD PTR $T260517[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T260392[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@2

; 657  : 			else

	jmp	SHORT $LN11@insert@2
$LN2@insert@2:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T260394[ebp], 0
	mov	ecx, DWORD PTR __Where$198767[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T260394[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@2:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T260523 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+76], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@5

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T260523[ebp], ecx
	cmp	DWORD PTR $T260523[ebp], 0
	je	SHORT $LN4@push_back@5
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T260523[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T260523[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back@5
$LN4@push_back@5:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@5:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
PUBLIC	?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ; FAutoArchiveClassContainer<CvPlot>::getNames
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautoarchiveclasscontainer.h
;	COMDAT ?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T260766 = -128						; size = 4
$T260679 = -92						; size = 4
$T260667 = -88						; size = 4
$T260666 = -84						; size = 4
__Off$260669 = -76					; size = 4
$T260647 = -72						; size = 4
$T260642 = -68						; size = 4
$T260624 = -64						; size = 4
$T260623 = -60						; size = 4
$T260627 = -56						; size = 4
$T260587 = -52						; size = 4
$T260578 = -48						; size = 4
$T260573 = -44						; size = 4
$T260572 = -40						; size = 4
$T260571 = -36						; size = 4
$T260570 = -32						; size = 4
$T260569 = -28						; size = 4
$T260568 = -24						; size = 4
$T260567 = -20						; size = 4
_result$ = -16						; size = 4
_key$ = -12						; size = 4
_names$ = -8						; size = 4
_f$ = -4						; size = 4
_var$ = 8						; size = 4
?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::getVariableName, COMDAT
; _this$ = ecx

; 48   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 		const std::string * result = 0;

	mov	DWORD PTR _result$[ebp], 0

; 50   : 
; 51   : 		size_t key = std::distance(m_contents.begin(), std::find(m_contents.begin(), m_contents.end(), &var));

	mov	eax, DWORD PTR _var$[ebp]
	mov	DWORD PTR $T260567[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T260578[ebp], edx
	mov	eax, DWORD PTR $T260578[ebp]
	mov	DWORD PTR $T260568[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T260587[ebp], edx
	mov	eax, DWORD PTR $T260587[ebp]
	mov	DWORD PTR $T260569[ebp], eax
	mov	ecx, DWORD PTR $T260569[ebp]
	mov	DWORD PTR $T260642[ebp], ecx
	mov	edx, DWORD PTR $T260568[ebp]
	mov	DWORD PTR $T260624[ebp], edx
	mov	eax, DWORD PTR $T260642[ebp]
	mov	DWORD PTR $T260623[ebp], eax
	jmp	SHORT $LN22@getVariabl
$LN16@getVariabl:
	mov	ecx, DWORD PTR $T260623[ebp]
	add	ecx, 4
	mov	DWORD PTR $T260623[ebp], ecx
$LN22@getVariabl:
	mov	edx, DWORD PTR $T260623[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T260624[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN15@getVariabl
	mov	eax, DWORD PTR $T260623[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T260567[ebp]
	jne	SHORT $LN14@getVariabl
	jmp	SHORT $LN15@getVariabl
$LN14@getVariabl:
	jmp	SHORT $LN16@getVariabl
$LN15@getVariabl:
	mov	edx, DWORD PTR $T260623[ebp]
	mov	DWORD PTR $T260627[ebp], edx
	mov	eax, DWORD PTR $T260627[ebp]
	mov	DWORD PTR $T260642[ebp], eax
	mov	ecx, DWORD PTR $T260642[ebp]
	mov	DWORD PTR $T260570[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T260647[ebp], eax
	mov	ecx, DWORD PTR $T260647[ebp]
	mov	DWORD PTR $T260571[ebp], ecx
	mov	edx, DWORD PTR $T260571[ebp]
	mov	DWORD PTR $T260679[ebp], edx
	mov	DWORD PTR __Off$260669[ebp], 0
	mov	eax, DWORD PTR $T260570[ebp]
	mov	DWORD PTR $T260667[ebp], eax
	mov	ecx, DWORD PTR $T260679[ebp]
	mov	DWORD PTR $T260666[ebp], ecx
	mov	edx, DWORD PTR $T260667[ebp]
	sub	edx, DWORD PTR $T260666[ebp]
	sar	edx, 2
	add	edx, DWORD PTR __Off$260669[ebp]
	mov	DWORD PTR __Off$260669[ebp], edx
	mov	eax, DWORD PTR __Off$260669[ebp]
	mov	DWORD PTR _key$[ebp], eax

; 52   : 		std::map<size_t, std::string> & names = getNames();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ; FAutoArchiveClassContainer<CvPlot>::getNames
	mov	DWORD PTR _names$[ebp], eax

; 53   : 		std::map<size_t, std::string>::const_iterator f = names.find(key);

	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T260572[ebp]
	push	edx
	mov	ecx, DWORD PTR _names$[ebp]
	call	?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _f$[ebp], eax

; 54   : 		
; 55   : 		if(f != names.end())

	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T260766[ebp], edx
	mov	eax, DWORD PTR $T260766[ebp]
	mov	DWORD PTR $T260573[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T260573[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@getVariabl

; 56   : 		{
; 57   : 			result = &f->second;

	mov	edx, DWORD PTR _f$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _result$[ebp], edx
$LN1@getVariabl:

; 58   : 		}
; 59   : 		return result;

	mov	eax, DWORD PTR _result$[ebp]

; 60   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?getVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::getVariableName
_TEXT	ENDS
PUBLIC	??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
; Function compile flags: /Odtp
;	COMDAT ?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -220						; size = 4
$T260997 = -124						; size = 4
$T260910 = -88						; size = 4
$T260898 = -84						; size = 4
$T260897 = -80						; size = 4
__Off$260900 = -72					; size = 4
$T260878 = -68						; size = 4
$T260873 = -64						; size = 4
$T260855 = -60						; size = 4
$T260854 = -56						; size = 4
$T260858 = -52						; size = 4
$T260818 = -48						; size = 4
$T260809 = -44						; size = 4
$T260804 = -40						; size = 4
$T260803 = -36						; size = 4
$T260802 = -32						; size = 4
$T260801 = -28						; size = 4
$T260800 = -24						; size = 4
$T260799 = -20						; size = 4
$T260798 = -16						; size = 4
_offset$ = -12						; size = 4
_names$ = -8						; size = 4
_f$ = -4						; size = 4
_var$ = 8						; size = 4
_name$ = 12						; size = 4
?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::setVariableName, COMDAT
; _this$ = ecx

; 63   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 		std::map<size_t, std::string> & names = getNames();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ; FAutoArchiveClassContainer<CvPlot>::getNames
	mov	DWORD PTR _names$[ebp], eax

; 65   : 
; 66   : 		size_t offset = std::distance(m_contents.begin(), std::find(m_contents.begin(), m_contents.end(), &var));

	mov	eax, DWORD PTR _var$[ebp]
	mov	DWORD PTR $T260798[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T260809[ebp], edx
	mov	eax, DWORD PTR $T260809[ebp]
	mov	DWORD PTR $T260799[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T260818[ebp], edx
	mov	eax, DWORD PTR $T260818[ebp]
	mov	DWORD PTR $T260800[ebp], eax
	mov	ecx, DWORD PTR $T260800[ebp]
	mov	DWORD PTR $T260873[ebp], ecx
	mov	edx, DWORD PTR $T260799[ebp]
	mov	DWORD PTR $T260855[ebp], edx
	mov	eax, DWORD PTR $T260873[ebp]
	mov	DWORD PTR $T260854[ebp], eax
	jmp	SHORT $LN22@setVariabl
$LN16@setVariabl:
	mov	ecx, DWORD PTR $T260854[ebp]
	add	ecx, 4
	mov	DWORD PTR $T260854[ebp], ecx
$LN22@setVariabl:
	mov	edx, DWORD PTR $T260854[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T260855[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN15@setVariabl
	mov	eax, DWORD PTR $T260854[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T260798[ebp]
	jne	SHORT $LN14@setVariabl
	jmp	SHORT $LN15@setVariabl
$LN14@setVariabl:
	jmp	SHORT $LN16@setVariabl
$LN15@setVariabl:
	mov	edx, DWORD PTR $T260854[ebp]
	mov	DWORD PTR $T260858[ebp], edx
	mov	eax, DWORD PTR $T260858[ebp]
	mov	DWORD PTR $T260873[ebp], eax
	mov	ecx, DWORD PTR $T260873[ebp]
	mov	DWORD PTR $T260801[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T260878[ebp], eax
	mov	ecx, DWORD PTR $T260878[ebp]
	mov	DWORD PTR $T260802[ebp], ecx
	mov	edx, DWORD PTR $T260802[ebp]
	mov	DWORD PTR $T260910[ebp], edx
	mov	DWORD PTR __Off$260900[ebp], 0
	mov	eax, DWORD PTR $T260801[ebp]
	mov	DWORD PTR $T260898[ebp], eax
	mov	ecx, DWORD PTR $T260910[ebp]
	mov	DWORD PTR $T260897[ebp], ecx
	mov	edx, DWORD PTR $T260898[ebp]
	sub	edx, DWORD PTR $T260897[ebp]
	sar	edx, 2
	add	edx, DWORD PTR __Off$260900[ebp]
	mov	DWORD PTR __Off$260900[ebp], edx
	mov	eax, DWORD PTR __Off$260900[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 67   : 		std::map<size_t, std::string>::const_iterator f = names.find(offset);

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T260803[ebp]
	push	edx
	mov	ecx, DWORD PTR _names$[ebp]
	call	?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _f$[ebp], eax

; 68   : 		if(f == names.end())

	mov	ecx, DWORD PTR _names$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T260997[ebp], edx
	mov	eax, DWORD PTR $T260997[ebp]
	mov	DWORD PTR $T260804[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T260804[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@setVariabl

; 69   : 		{
; 70   : 			names[offset] = name;

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	mov	ecx, DWORD PTR _names$[ebp]
	call	??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN2@setVariabl:

; 71   : 		}
; 72   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setVariableName@?$FAutoArchiveClassContainer@VCvPlot@@@@UBEXABVFAutoVariableBase@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::setVariableName
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$1
__ehfuncinfo$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
tv84 = -92						; size = 4
tv90 = -88						; size = 4
tv82 = -84						; size = 4
tv89 = -80						; size = 4
_this$ = -76						; size = 4
$T261101 = -72						; size = 4
$T261097 = -68						; size = 28
$T261096 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_var$ = 12						; size = 4
?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::debugDump, COMDAT
; _this$ = ecx

; 75   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T261101[ebp], 0

; 76   : 		return std::string("\n") + m_classInstance.debugDump(var);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T261096[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?debugDump@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::debugDump
	mov	DWORD PTR tv89[ebp], eax
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR tv82[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	lea	ecx, DWORD PTR $T261097[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR tv90[ebp], eax
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv82[ebp]
	push	edx
	mov	eax, DWORD PTR tv84[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR $T261101[ebp]
	or	edx, 1
	mov	DWORD PTR $T261101[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T261097[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T261096[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 77   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T261096[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$1:
	lea	ecx, DWORD PTR $T261097[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z$2:
	mov	eax, DWORD PTR $T261101[ebp]
	and	eax, 1
	je	$LN6@debugDump@2
	and	DWORD PTR $T261101[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@debugDump@2:
	ret	0
__ehhandler$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?debugDump@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::debugDump
; Function compile flags: /Odtp
;	COMDAT ?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T261112 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_var$ = 12						; size = 4
?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z PROC ; FAutoArchiveClassContainer<CvPlot>::stackTraceRemark, COMDAT
; _this$ = ecx

; 80   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T261112[ebp], 0

; 81   : 		return m_classInstance.stackTraceRemark(var);

	mov	eax, DWORD PTR _var$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	call	?stackTraceRemark@CvPlot@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ; CvPlot::stackTraceRemark
	mov	eax, DWORD PTR $T261112[ebp]
	or	eax, 1
	mov	DWORD PTR $T261112[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 82   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?stackTraceRemark@?$FAutoArchiveClassContainer@VCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVFAutoVariableBase@@@Z ENDP ; FAutoArchiveClassContainer<CvPlot>::stackTraceRemark
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T261650 = -188						; size = 4
$T261562 = -172						; size = 4
$T261477 = -160						; size = 4
$T261461 = -156						; size = 4
$T261442 = -152						; size = 4
$T261438 = -148						; size = 4
$T261353 = -136						; size = 4
$T261252 = -120						; size = 4
$T261230 = -116						; size = 4
$T261223 = -112						; size = 4
$T261219 = -108						; size = 4
$T261180 = -104						; size = 4
$T261171 = -100						; size = 4
$T261151 = -96						; size = 4
__Count$261132 = -92					; size = 4
$T261117 = -88						; size = 28
$T261116 = -60						; size = 40
__Pnode$201484 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$261132[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$261132[ebp], 0
	jbe	SHORT $LN25@Insert@2
	mov	eax, DWORD PTR __Count$261132[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert@2
$LN25@Insert@2:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert@2:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert@2

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T261117[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T261117[ebp]
	push	eax
	lea	ecx, DWORD PTR $T261116[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T261116[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T261116[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T261117[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert@2:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert@2

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T261151[ebp], edx
	mov	eax, DWORD PTR $T261151[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert@2
$LN16@Insert@2:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert@2

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261171[ebp], eax
	mov	ecx, DWORD PTR $T261171[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert@2

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261180[ebp], ecx
	mov	edx, DWORD PTR $T261180[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert@2:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert@2

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert@2:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert@2

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert@2:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$201484[ebp], eax
$LN64@Insert@2:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+16]
	test	eax, eax
	jne	$LN360@Insert@2

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T261219[ebp], edx
	mov	eax, DWORD PTR $T261219[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T261223[ebp], ecx
	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR $T261223[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert@2

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T261230[ebp], eax
	mov	ecx, DWORD PTR $T261230[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN100@Insert@2

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T261252[ebp], ecx
	mov	edx, DWORD PTR $T261252[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert@2

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert@2:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$201484[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert@2

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$201484[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert@2:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T261353[ebp], ecx
	mov	edx, DWORD PTR $T261353[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
$LN6@Insert@2:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert@2

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert@2:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T261438[ebp], edx
	mov	eax, DWORD PTR $T261438[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T261442[ebp], ecx
	mov	edx, DWORD PTR $T261442[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+16]
	test	edx, edx
	jne	SHORT $LN240@Insert@2

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+16], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$201484[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T261461[ebp], ecx
	mov	edx, DWORD PTR $T261461[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert@2

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert@2:
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T261477[ebp], edx
	mov	eax, DWORD PTR $T261477[ebp]
	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert@2

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$201484[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert@2:
	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+16], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$201484[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T261562[ebp], edx
	mov	eax, DWORD PTR $T261562[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$201484[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
$LN4@Insert@2:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert@2

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T261650[ebp], eax
	mov	ecx, DWORD PTR $T261650[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+16], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@2:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T261117[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T261704 = -36						; size = 4
$T261703 = -32						; size = 4
_i$261698 = -28						; size = 4
$T261679 = -24						; size = 4
_pRet$261675 = -20					; size = 4
$T261670 = -16						; size = 4
_i$201554 = -12						; size = 4
_uiNewSize$201546 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@5
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@5:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@5

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$201546[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$201546[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@5

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@5
$LN6@GrowSize@5:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$201546[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@5
$LN7@GrowSize@5:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T261679[ebp], ecx
	cmp	DWORD PTR $T261679[ebp], 8
	jbe	SHORT $LN15@GrowSize@5
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T261679[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$261675[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T261679[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@5
$LN15@GrowSize@5:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$261675[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 8
$LN16@GrowSize@5:
	mov	ecx, DWORD PTR _pRet$261675[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@5

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@5
$LN5@GrowSize@5:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$201554[ebp], 0
	jmp	SHORT $LN3@GrowSize@5
$LN2@GrowSize@5:
	mov	edx, DWORD PTR _i$201554[ebp]
	add	edx, 1
	mov	DWORD PTR _i$201554[ebp], edx
$LN3@GrowSize@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$201554[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@5

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$201554[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T261670[ebp], ecx
	cmp	DWORD PTR $T261670[ebp], 0
	je	SHORT $LN12@GrowSize@5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$201554[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T261670[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T261670[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize@5
$LN12@GrowSize@5:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@5:
	jmp	SHORT $LN2@GrowSize@5
$LN4@GrowSize@5:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261704[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T261703[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@5
	xor	edx, edx
	je	SHORT $LN21@GrowSize@5
	mov	DWORD PTR _i$261698[ebp], 0
	jmp	SHORT $LN26@GrowSize@5
$LN25@GrowSize@5:
	mov	eax, DWORD PTR _i$261698[ebp]
	add	eax, 1
	mov	DWORD PTR _i$261698[ebp], eax
$LN26@GrowSize@5:
	mov	ecx, DWORD PTR _i$261698[ebp]
	cmp	ecx, DWORD PTR $T261704[ebp]
	jae	SHORT $LN21@GrowSize@5
	jmp	SHORT $LN25@GrowSize@5
$LN21@GrowSize@5:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T261703[ebp], edx
	je	SHORT $LN22@GrowSize@5
	mov	eax, DWORD PTR $T261703[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@5:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+76], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$1
__ehfuncinfo$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	ENDS
;	COMDAT ??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
_TEXT	SEGMENT
tv172 = -116						; size = 4
tv128 = -112						; size = 4
_this$ = -108						; size = 4
$T261773 = -104						; size = 4
$T261752 = -100						; size = 4
$T261739 = -96						; size = 4
$T261723 = -92						; size = 4
$T261711 = -88						; size = 4
$T261710 = -84						; size = 4
$T261709 = -80						; size = 28
$T261708 = -52						; size = 32
$T261707 = -20						; size = 4
__Where$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z PROC ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
	mov	DWORD PTR $T261723[ebp], eax
	mov	ecx, DWORD PTR $T261723[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261739[ebp], eax
	mov	ecx, DWORD PTR $T261739[ebp]
	mov	DWORD PTR $T261707[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T261707[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@operator@6
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261752[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T261752[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN37@operator@6
$LN1@operator@6:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261710[ebp], edx
	lea	ecx, DWORD PTR $T261709[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR tv128[ebp], eax
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T261773[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR __Keyval$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T261708[ebp], edx
	mov	eax, DWORD PTR $T261773[ebp]
	push	eax
	lea	ecx, DWORD PTR $T261708[ebp+4]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	lea	ecx, DWORD PTR $T261708[ebp]
	mov	DWORD PTR tv172[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv172[ebp]
	push	edx
	mov	eax, DWORD PTR $T261710[ebp]
	push	eax
	lea	ecx, DWORD PTR $T261711[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T261708[ebp+4]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T261709[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 174  : 		return ((*_Where).second);

$LN37@operator@6:
	mov	eax, DWORD PTR __Where$[ebp]
	add	eax, 16					; 00000010H

; 175  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$0:
	lea	ecx, DWORD PTR $T261709[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z$1:
	lea	ecx, DWORD PTR $T261708[ebp]
	jmp	??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
__ehhandler$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??A?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABI@Z ENDP ; std::map<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator[]
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
tv137 = -48						; size = 4
_this$ = -44						; size = 4
$T261904 = -40						; size = 4
$T261878 = -36						; size = 4
$T261865 = -32						; size = 4
$T261849 = -28						; size = 4
$T261804 = -16						; size = 4
$T261802 = -12						; size = 4
$T261801 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find, COMDAT
; _this$ = ecx

; 977  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
	mov	DWORD PTR $T261849[ebp], eax
	mov	ecx, DWORD PTR $T261849[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261865[ebp], eax
	mov	ecx, DWORD PTR $T261865[ebp]
	mov	DWORD PTR $T261802[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T261802[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T261878[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T261878[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	jmp	SHORT $LN4@find
$LN3@find:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261904[ebp], ecx
	mov	edx, DWORD PTR $T261904[ebp]
	mov	DWORD PTR $T261804[ebp], edx
	lea	eax, DWORD PTR $T261804[ebp]
	mov	DWORD PTR tv137[ebp], eax
$LN4@find:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T261801[ebp], ecx
	mov	edx, DWORD PTR $T261801[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T261986 = -12						; size = 4
$T261979 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate@2

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T261979[ebp], eax
	mov	ecx, DWORD PTR $T261979[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T261986[ebp], ecx
	mov	edx, DWORD PTR $T261986[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate@2

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate@2:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate@2:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T262062 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+17]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate@2:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate@2

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate@2

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate@2:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262062[ebp], eax
	mov	ecx, DWORD PTR $T262062[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate@2:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T262072 = -28						; size = 4
$T262071 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T262072[ebp], eax
	cmp	DWORD PTR $T262072[ebp], 0
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR $T262072[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T262072[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T262072[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T262072[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR $T262072[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+16], dl
	mov	eax, DWORD PTR $T262072[ebp]
	mov	BYTE PTR [eax+17], 0
	mov	ecx, DWORD PTR $T262072[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T262071[ebp], edx
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T262648 = -372						; size = 4
$T262625 = -368						; size = 4
$T262609 = -364						; size = 4
$T262583 = -360						; size = 4
$T262564 = -356						; size = 4
$T262544 = -352						; size = 4
$T262515 = -348						; size = 4
$T262500 = -344						; size = 4
$T262486 = -340						; size = 4
$T262465 = -336						; size = 4
$T262433 = -332						; size = 4
$T262416 = -328						; size = 4
$T262403 = -324						; size = 4
$T262385 = -320						; size = 4
$T262365 = -316						; size = 4
$T262346 = -312						; size = 4
$T262317 = -308						; size = 4
$T262301 = -304						; size = 4
$T262278 = -300						; size = 4
$T262255 = -296						; size = 4
$T262230 = -216						; size = 4
$T262216 = -212						; size = 4
$T262198 = -208						; size = 4
$T262165 = -128						; size = 4
$T262145 = -124						; size = 4
$T262132 = -120						; size = 4
$T262122 = -40						; size = 4
$T262115 = -36						; size = 8
$T262114 = -28						; size = 4
$T262113 = -24						; size = 4
$T262112 = -20						; size = 4
$T262111 = -16						; size = 4
$T262110 = -12						; size = 4
$T262109 = -8						; size = 4
__Next$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	mov	DWORD PTR __Next$[ebp], 0

; 672  : 
; 673  : 		if (size() == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T262122[ebp], ecx
	cmp	DWORD PTR $T262122[ebp], 0
	jne	SHORT $LN32@insert@3

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
	jmp	$LN31@insert@3
$LN32@insert@3:

; 675  : 		else if (this->_Multi)

	xor	eax, eax
	je	$LN30@insert@3

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T262132[ebp], edx
	mov	eax, DWORD PTR $T262132[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T262145[ebp], ecx
	mov	edx, DWORD PTR $T262145[ebp]
	mov	DWORD PTR $T262109[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T262109[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN29@insert@3

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262165[ebp], eax
	mov	ecx, DWORD PTR $T262165[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN28@insert@3

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
$LN28@insert@3:

; 682  : 				}

	jmp	$LN27@insert@3
$LN29@insert@3:

; 683  : 			else if (_Where == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262198[ebp], ecx
	mov	edx, DWORD PTR $T262198[ebp]
	mov	DWORD PTR $T262110[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T262110[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN151@insert@3

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	mov	DWORD PTR $T262216[ebp], ecx
	mov	edx, DWORD PTR $T262216[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T262230[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T262230[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN25@insert@3

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
$LN25@insert@3:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@3

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

$LN151@insert@3:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262255[ebp], edx
	mov	eax, DWORD PTR $T262255[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN23@insert@3
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T262278[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T262278[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx+12]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN23@insert@3

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	eax, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T262301[ebp], eax
	mov	ecx, DWORD PTR $T262301[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	je	SHORT $LN185@insert@3

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3

; 696  : 				else

	jmp	SHORT $LN21@insert@3

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN185@insert@3:
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
$LN21@insert@3:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@3
$LN23@insert@3:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262317[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T262317[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	$LN27@insert@3
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262346[ebp], eax
	mov	ecx, DWORD PTR $T262346[ebp]
	mov	DWORD PTR $T262111[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
	mov	edx, DWORD PTR __Next$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T262111[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@insert@3
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T262365[ebp], edx
	mov	eax, DWORD PTR $T262365[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@insert@3
$LN18@insert@3:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262385[ebp], edx
	mov	eax, DWORD PTR $T262385[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN229@insert@3

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3

; 707  : 				else

	jmp	SHORT $LN27@insert@3

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN229@insert@3:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
$LN27@insert@3:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert@3
$LN30@insert@3:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262403[ebp], ecx
	mov	edx, DWORD PTR $T262403[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262416[ebp], eax
	mov	ecx, DWORD PTR $T262416[ebp]
	mov	DWORD PTR $T262112[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T262112[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert@3

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262433[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T262433[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@insert@3

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
$LN13@insert@3:

; 718  : 				}

	jmp	$LN31@insert@3
$LN14@insert@3:

; 719  : 			else if (_Where == end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262465[ebp], eax
	mov	ecx, DWORD PTR $T262465[ebp]
	mov	DWORD PTR $T262113[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T262113[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert@3

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	mov	DWORD PTR $T262486[ebp], eax
	mov	ecx, DWORD PTR $T262486[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T262500[ebp], edx
	mov	eax, DWORD PTR $T262500[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert@3

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
$LN10@insert@3:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@3
$LN11@insert@3:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262515[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T262515[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN319@insert@3
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T262544[ebp], edx
	mov	eax, DWORD PTR $T262544[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN319@insert@3

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T262564[ebp], edx
	mov	eax, DWORD PTR $T262564[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN317@insert@3

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3

; 732  : 				else

	jmp	SHORT $LN6@insert@3

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

$LN317@insert@3:
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@3
$LN6@insert@3:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@3

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

$LN319@insert@3:
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262583[ebp], eax
	mov	ecx, DWORD PTR $T262583[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	$LN31@insert@3
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T262609[ebp], edx
	mov	eax, DWORD PTR $T262609[ebp]
	mov	DWORD PTR $T262114[ebp], eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Next$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T262114[ebp]
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@insert@3
	mov	ecx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR $T262625[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T262625[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN31@insert@3
$LN3@insert@3:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T262648[ebp], ecx
	mov	edx, DWORD PTR $T262648[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	je	SHORT $LN361@insert@3

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@3

; 743  : 				else

	jmp	SHORT $LN31@insert@3

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

$LN361@insert@3:
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@3
$LN31@insert@3:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T262115[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert@3:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T262703 = -16						; size = 4
$T262682 = -12						; size = 4
$T262675 = -8						; size = 4
__Pnode$202260 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN9@Dec@2

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	je	SHORT $LN8@Dec@2

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec@2
$LN8@Dec@2:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec@2
$LN9@Dec@2:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T262675[ebp], edx
	mov	eax, DWORD PTR $T262675[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	jne	SHORT $LN34@Dec@2

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T262682[ebp], ecx
	mov	edx, DWORD PTR $T262682[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262703[ebp], eax
$LN30@Dec@2:
	mov	ecx, DWORD PTR $T262703[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN26@Dec@2
	mov	ecx, DWORD PTR $T262703[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T262703[ebp], edx
	jmp	SHORT $LN30@Dec@2
$LN26@Dec@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T262703[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec@2

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$202260[ebp], ecx
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	movsx	eax, BYTE PTR [edx+17]
	test	eax, eax
	jne	SHORT $LN40@Dec@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec@2

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202260[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec@2

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+17]
	test	edx, edx
	je	SHORT $LN2@Dec@2

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec@2

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec@2
$LN2@Dec@2:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$202260[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec@2:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T262850 = -148						; size = 4
$T262830 = -144						; size = 4
$T262815 = -140						; size = 4
$T262798 = -136						; size = 4
$T262785 = -132						; size = 4
$T262771 = -128						; size = 4
$T262727 = -45						; size = 1
$T262726 = -44						; size = 4
$T262725 = -37						; size = 1
$T262724 = -36						; size = 4
$T262723 = -29						; size = 1
$T262722 = -28						; size = 4
$T262721 = -24						; size = 4
$T262720 = -17						; size = 1
__Where$202376 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert@4:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	jne	SHORT $LN9@insert@4

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	sbb	edx, edx
	neg	edx
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert@4
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert@4
$LN33@insert@4:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert@4:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert@4
$LN9@insert@4:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	eax, eax
	je	SHORT $LN8@insert@4

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T262720[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262721[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	DWORD PTR $T262771[ebp], eax
	mov	edx, DWORD PTR $T262771[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T262720[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@4

; 644  : 		else

	jmp	$LN11@insert@4
$LN8@insert@4:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$202376[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert@4
	jmp	$LN79@insert@4
$LN6@insert@4:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262785[ebp], ecx
	mov	edx, DWORD PTR $T262785[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T262798[ebp], eax
	mov	ecx, DWORD PTR $T262798[ebp]
	mov	DWORD PTR $T262722[ebp], ecx
	mov	edx, DWORD PTR __Where$202376[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T262722[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert@4

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T262723[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T262724[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	DWORD PTR $T262815[ebp], eax
	mov	edx, DWORD PTR $T262815[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T262723[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@4

; 651  : 			else

	jmp	SHORT $LN79@insert@4
$LN4@insert@4:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$202376[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert@4:
	mov	ecx, DWORD PTR __Where$202376[ebp]
	mov	DWORD PTR $T262830[ebp], ecx
	mov	edx, DWORD PTR $T262830[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax]
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert@4

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T262725[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262726[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
	mov	DWORD PTR $T262850[ebp], eax
	mov	edx, DWORD PTR $T262850[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T262725[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@4

; 657  : 			else

	jmp	SHORT $LN11@insert@4
$LN2@insert@4:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T262727[ebp], 0
	mov	ecx, DWORD PTR __Where$202376[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T262727[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@4:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T263390 = -188						; size = 4
$T263302 = -172						; size = 4
$T263217 = -160						; size = 4
$T263201 = -156						; size = 4
$T263182 = -152						; size = 4
$T263178 = -148						; size = 4
$T263093 = -136						; size = 4
$T262992 = -120						; size = 4
$T262970 = -116						; size = 4
$T262963 = -112						; size = 4
$T262959 = -108						; size = 4
$T262920 = -104						; size = 4
$T262911 = -100						; size = 4
$T262891 = -96						; size = 4
__Count$262873 = -92					; size = 4
$T262857 = -88						; size = 28
$T262856 = -60						; size = 40
__Pnode$202407 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$262873[ebp], 134217727 ; 07ffffffH
	cmp	DWORD PTR __Count$262873[ebp], 0
	jbe	SHORT $LN25@Insert@3
	mov	eax, DWORD PTR __Count$262873[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert@3
$LN25@Insert@3:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert@3:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert@3

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T262857[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T262857[ebp]
	push	eax
	lea	ecx, DWORD PTR $T262856[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T262856[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T262856[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T262857[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert@3:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert@3

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T262891[ebp], edx
	mov	eax, DWORD PTR $T262891[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert@3
$LN16@Insert@3:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert@3

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T262911[ebp], eax
	mov	ecx, DWORD PTR $T262911[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert@3

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T262920[ebp], ecx
	mov	edx, DWORD PTR $T262920[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert@3:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert@3

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert@3:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert@3

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert@3:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$202407[ebp], eax
$LN64@Insert@3:
	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+44]
	test	eax, eax
	jne	$LN360@Insert@3

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T262959[ebp], edx
	mov	eax, DWORD PTR $T262959[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T262963[ebp], ecx
	mov	edx, DWORD PTR __Pnode$202407[ebp]
	mov	eax, DWORD PTR $T262963[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert@3

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$202407[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T262970[ebp], eax
	mov	ecx, DWORD PTR $T262970[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+44]
	test	edx, edx
	jne	SHORT $LN100@Insert@3

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$202407[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+44], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+44], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$202407[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T262992[ebp], ecx
	mov	edx, DWORD PTR $T262992[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+44], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$202407[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert@3

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert@3:
	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$202407[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert@3

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$202407[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$202407[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert@3:
	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+44], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$202407[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T263093[ebp], ecx
	mov	edx, DWORD PTR $T263093[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+44], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
$LN6@Insert@3:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert@3

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert@3:
	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T263178[ebp], edx
	mov	eax, DWORD PTR $T263178[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T263182[ebp], ecx
	mov	edx, DWORD PTR $T263182[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+44]
	test	edx, edx
	jne	SHORT $LN240@Insert@3

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$202407[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+44], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+44], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$202407[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T263201[ebp], ecx
	mov	edx, DWORD PTR $T263201[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+44], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$202407[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert@3

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert@3:
	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T263217[ebp], edx
	mov	eax, DWORD PTR $T263217[ebp]
	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert@3

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$202407[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$202407[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert@3:
	mov	edx, DWORD PTR __Pnode$202407[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+44], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$202407[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T263302[ebp], edx
	mov	eax, DWORD PTR $T263302[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+44], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$202407[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
$LN4@Insert@3:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert@3

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T263390[ebp], eax
	mov	ecx, DWORD PTR $T263390[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+44], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert@3:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR $T262857[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	jne	SHORT $LN3@Lbound

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx]
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound
$LN3@Lbound:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T263501 = -12						; size = 4
$T263494 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate@3

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate@3:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate@3

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate@3

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate@3:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263494[ebp], eax
	mov	ecx, DWORD PTR $T263494[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate@3

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263501[ebp], ecx
	mov	edx, DWORD PTR $T263501[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate@3

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate@3:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate@3:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T263577 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate@3

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate@3:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate@3

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate@3

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate@3:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate@3

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate@3

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate@3:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T263577[ebp], eax
	mov	ecx, DWORD PTR $T263577[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate@3:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$5
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
_TEXT	SEGMENT
tv86 = -56						; size = 4
_this$ = -52						; size = 4
$T263613 = -48						; size = 4
$T263587 = -28						; size = 4
$T263586 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T263587[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T263587[ebp], 0
	je	SHORT $LN4@Buynode@3
	mov	ecx, DWORD PTR $T263587[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T263587[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T263587[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR $T263587[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T263613[ebp], ecx
	mov	edx, DWORD PTR $T263613[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR $T263613[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T263587[ebp]
	mov	cl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [eax+44], cl
	mov	edx, DWORD PTR $T263587[ebp]
	mov	BYTE PTR [edx+45], 0
	mov	eax, DWORD PTR $T263587[ebp]
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@3
$LN4@Buynode@3:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@3:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T263586[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@3
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$1
	ret	0
$LN6@Buynode@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@3:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T263587[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T263674 = -16						; size = 4
$T263653 = -12						; size = 4
$T263646 = -8						; size = 4
__Pnode$202538 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN9@Dec@3

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	je	SHORT $LN8@Dec@3

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec@3
$LN8@Dec@3:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec@3
$LN9@Dec@3:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T263646[ebp], edx
	mov	eax, DWORD PTR $T263646[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	jne	SHORT $LN34@Dec@3

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T263653[ebp], ecx
	mov	edx, DWORD PTR $T263653[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T263674[ebp], eax
$LN30@Dec@3:
	mov	ecx, DWORD PTR $T263674[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	jne	SHORT $LN26@Dec@3
	mov	ecx, DWORD PTR $T263674[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T263674[ebp], edx
	jmp	SHORT $LN30@Dec@3
$LN26@Dec@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T263674[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec@3

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$202538[ebp], ecx
	mov	edx, DWORD PTR __Pnode$202538[ebp]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	jne	SHORT $LN40@Dec@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202538[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec@3

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$202538[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec@3

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN2@Dec@3

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec@3

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec@3
$LN2@Dec@3:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$202538[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec@3:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T263723 = -16						; size = 4
$T263702 = -12						; size = 4
$T263695 = -8						; size = 4
__Pnode$202550 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN6@Inc@2
	jmp	$LN7@Inc@2
$LN6@Inc@2:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T263695[ebp], ecx
	mov	edx, DWORD PTR $T263695[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	jne	SHORT $LN27@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T263702[ebp], eax
	mov	ecx, DWORD PTR $T263702[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T263723[ebp], edx
$LN23@Inc@2:
	mov	eax, DWORD PTR $T263723[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	jne	SHORT $LN19@Inc@2
	mov	eax, DWORD PTR $T263723[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T263723[ebp], ecx
	jmp	SHORT $LN23@Inc@2
$LN19@Inc@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T263723[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc@2

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$202550[ebp], eax
	mov	ecx, DWORD PTR __Pnode$202550[ebp]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	jne	SHORT $LN1@Inc@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$202550[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$202550[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$202550[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc@2:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names
PUBLIC	??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51 ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`local static guard'
EXTRN	_atexit:PROC
;	COMDAT ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A
_BSS	SEGMENT
?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A DB 0cH DUP (?) ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names
_BSS	ENDS
;	COMDAT ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51
_BSS	SEGMENT
??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51 DD 01H DUP (?) ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`local static guard'
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ$0
__ehfuncinfo$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautoarchiveclasscontainer.h
xdata$x	ENDS
;	COMDAT ?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T263857 = -14						; size = 1
$T263856 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ PROC ; FAutoArchiveClassContainer<CvPlot>::getNames, COMDAT
; _this$ = ecx

; 98   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 	static std::map<size_t, std::string> names;

	mov	eax, DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51
	and	eax, 1
	jne	SHORT $LN1@getNames
	mov	ecx, DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51
	or	ecx, 1
	mov	DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T263856[ebp]
	push	edx
	lea	eax, DWORD PTR $T263857[ebp]
	push	eax
	mov	ecx, OFFSET ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names
	call	??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
	push	OFFSET ??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`dynamic atexit destructor for 'names''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@getNames:

; 100  : 	return names;

	mov	eax, OFFSET ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::names

; 101  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ$0:
	mov	eax, DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ??_B?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@51, eax
	ret	0
__ehhandler$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ ENDP ; FAutoArchiveClassContainer<CvPlot>::getNames
EXTRN	??1FAutoVariableBase@@UAE@XZ:PROC		; FAutoVariableBase::~FAutoVariableBase
EXTRN	?remove@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z:PROC ; FAutoArchive::remove
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
xdata$x	SEGMENT
__unwindtable$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ$0
__ehfuncinfo$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ PROC		; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>, COMDAT
; _this$ = ecx

; 168  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FAutoVariable@DVCvPlot@@@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 169  : 	m_owner.remove(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?remove@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ; FAutoArchive::remove

; 170  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FAutoVariableBase@@UAE@XZ		; FAutoVariableBase::~FAutoVariableBase
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1FAutoVariableBase@@UAE@XZ		; FAutoVariableBase::~FAutoVariableBase
__ehhandler$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ ENDP		; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
; Function compile flags: /Odtp
;	COMDAT ?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::load, COMDAT
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 	loadFrom >> m_value;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 281  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?load@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::load
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::loadDelta, COMDAT
; _this$ = ecx

; 295  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 	load(loadFrom);

	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?loadDelta@?$FAutoVariable@DVCvPlot@@@@UAEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::loadDelta
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_saveTo$ = 8						; size = 4
?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::save, COMDAT
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	saveTo << m_value;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?save@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::save
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_saveTo$ = 8						; size = 4
?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::saveDelta, COMDAT
; _this$ = ecx

; 319  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 	save(saveTo);

	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 321  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?saveDelta@?$FAutoVariable@DVCvPlot@@@@UBEXAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::saveDelta
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ PROC	; FAutoVariable<char,CvPlot>::clearDelta, COMDAT
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	// nothing to do for this type
; 305  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clearDelta@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ENDP	; FAutoVariable<char,CvPlot>::clearDelta
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_compareWith$ = -1					; size = 1
_otherValue$ = 8					; size = 4
?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z PROC ; FAutoVariable<char,CvPlot>::compare, COMDAT
; _this$ = ecx

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 336  : 	ObjectType compareWith;
; 337  : 	otherValue >> compareWith;

	lea	eax, DWORD PTR _compareWith$[ebp]
	push	eax
	mov	ecx, DWORD PTR _otherValue$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 338  : #if !defined(FINAL_RELEASE)
; 339  : 	m_remoteValue = compareWith;
; 340  : #endif
; 341  : 
; 342  : 	return m_value == compareWith;

	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	movsx	eax, BYTE PTR _compareWith$[ebp]
	xor	ecx, ecx
	cmp	edx, eax
	sete	cl
	mov	al, cl

; 343  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?compare@?$FAutoVariable@DVCvPlot@@@@UBE_NAAVFDataStream@@@Z ENDP ; FAutoVariable<char,CvPlot>::compare
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ PROC		; FAutoVariable<char,CvPlot>::reset, COMDAT
; _this$ = ecx

; 311  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 	m_value = ObjectType();

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4], 0

; 313  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?reset@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ENDP		; FAutoVariable<char,CvPlot>::reset
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; FAutoVariable<char,CvPlot>::name, COMDAT
; _this$ = ecx

; 349  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 	// dereferenced because if this variable exists, it MUST be in the map
; 351  : 	// (or it could never have been constructed in the first place)
; 352  : 	return *(m_owner.getVariableName(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 353  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?name@?$FAutoVariable@DVCvPlot@@@@UBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; FAutoVariable<char,CvPlot>::name
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?debugDump@FAutoVariableBase@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z:PROC ; FAutoVariableBase::debugDump
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$3
	DD	04H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
_TEXT	SEGMENT
tv163 = -232						; size = 4
tv172 = -228						; size = 4
tv161 = -224						; size = 4
tv171 = -220						; size = 4
tv159 = -216						; size = 4
tv170 = -212						; size = 4
tv157 = -208						; size = 4
tv169 = -204						; size = 4
tv155 = -200						; size = 4
tv69 = -196						; size = 4
_this$ = -192						; size = 4
$T263915 = -188						; size = 4
$T263907 = -184						; size = 28
$T263906 = -156						; size = 28
$T263905 = -128						; size = 28
$T263904 = -100						; size = 28
$T263903 = -72						; size = 28
_result$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_callStacks$ = 12					; size = 4
?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z PROC ; FAutoVariable<char,CvPlot>::debugDump, COMDAT
; _this$ = ecx

; 358  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T263915[ebp], 0

; 359  : 	std::string result = FAutoVariableBase::debugDump(callStacks);

	mov	eax, DWORD PTR _callStacks$[ebp]
	push	eax
	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?debugDump@FAutoVariableBase@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z ; FAutoVariableBase::debugDump
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 360  : 	result += std::string("\n") + m_owner.debugDump(*this) + std::string("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	lea	ecx, DWORD PTR $T263903[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR tv69[ebp], eax
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv155[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T263904[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR tv169[ebp], eax
	mov	ecx, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv157[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	lea	ecx, DWORD PTR $T263905[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR tv170[ebp], eax
	mov	edx, DWORD PTR tv170[ebp]
	mov	DWORD PTR tv159[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR tv157[ebp]
	push	eax
	mov	ecx, DWORD PTR tv159[ebp]
	push	ecx
	lea	edx, DWORD PTR $T263906[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv171[ebp], eax
	mov	eax, DWORD PTR tv171[ebp]
	mov	DWORD PTR tv161[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR tv155[ebp]
	push	ecx
	mov	edx, DWORD PTR tv161[ebp]
	push	edx
	lea	eax, DWORD PTR $T263907[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv172[ebp], eax
	mov	ecx, DWORD PTR tv172[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv163[ebp]
	push	edx
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T263907[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T263906[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T263905[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T263904[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T263903[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 361  : #if !defined(FINAL_RELEASE)
; 362  : 	result += std::string("local value=") + FSerialization::toString(m_value) + "\n";
; 363  : 	result += std::string("remote value=") + FSerialization::toString(m_remoteValue) + "\n";
; 364  : #endif
; 365  : 	return result;

	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T263915[ebp]
	or	ecx, 1
	mov	DWORD PTR $T263915[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 366  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$1:
	lea	ecx, DWORD PTR $T263903[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$2:
	lea	ecx, DWORD PTR $T263904[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$3:
	lea	ecx, DWORD PTR $T263905[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$4:
	lea	ecx, DWORD PTR $T263906[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$5:
	lea	ecx, DWORD PTR $T263907[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z$6:
	mov	eax, DWORD PTR $T263915[ebp]
	and	eax, 1
	je	$LN10@debugDump@3
	and	DWORD PTR $T263915[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@debugDump@3:
	ret	0
__ehhandler$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-224]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?debugDump@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@V?$allocator@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@3@@Z ENDP ; FAutoVariable<char,CvPlot>::debugDump
EXTRN	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABD@Z:PROC ; FSerialization::toString
; Function compile flags: /Odtp
;	COMDAT ?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T263926 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; FAutoVariable<char,CvPlot>::toString, COMDAT
; _this$ = ecx

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T263926[ebp], 0

; 328  : 	return FSerialization::toString(m_value);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABD@Z ; FSerialization::toString
	add	esp, 8
	mov	edx, DWORD PTR $T263926[ebp]
	or	edx, 1
	mov	DWORD PTR $T263926[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 329  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?toString@?$FAutoVariable@DVCvPlot@@@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; FAutoVariable<char,CvPlot>::toString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ PROC ; FAutoVariable<char,CvPlot>::setStackTraceRemark, COMDAT
; _this$ = ecx

; 372  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 373  : #ifndef FINAL_RELEASE
; 374  : 	m_callStackRemark = m_owner.stackTraceRemark(*this);
; 375  : #endif
; 376  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?setStackTraceRemark@?$FAutoVariable@DVCvPlot@@@@UAEXXZ ENDP ; FAutoVariable<char,CvPlot>::setStackTraceRemark
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T263936 = -16						; size = 4
$T263932 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T263936[ebp], 0
	lea	eax, DWORD PTR $T263936[ebp]
	push	eax
	lea	ecx, DWORD PTR $T263932[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T263932[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T263932[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T263943 = -16						; size = 4
$T263939 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T263943[ebp], 0
	lea	eax, DWORD PTR $T263943[ebp]
	push	eax
	lea	ecx, DWORD PTR $T263939[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T263939[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T263939[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 48					; 00000030H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_G?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z PROC		; FAutoVariable<char,CvPlot>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FAutoVariable@DVCvPlot@@@@UAE@XZ	; FAutoVariable<char,CvPlot>::~FAutoVariable<char,CvPlot>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$FAutoVariable@DVCvPlot@@@@UAEPAXI@Z ENDP		; FAutoVariable<char,CvPlot>::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T263973 = -24						; size = 4
$T263972 = -20						; size = 4
_i$263967 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T263973[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T263972[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@6
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@6
	mov	DWORD PTR _i$263967[ebp], 0
	jmp	SHORT $LN10@FStaticVec@6
$LN9@FStaticVec@6:
	mov	eax, DWORD PTR _i$263967[ebp]
	add	eax, 1
	mov	DWORD PTR _i$263967[ebp], eax
$LN10@FStaticVec@6:
	mov	ecx, DWORD PTR _i$263967[ebp]
	cmp	ecx, DWORD PTR $T263973[ebp]
	jae	SHORT $LN5@FStaticVec@6
	jmp	SHORT $LN9@FStaticVec@6
$LN5@FStaticVec@6:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T263972[ebp], edx
	je	SHORT $LN1@FStaticVec@6
	mov	eax, DWORD PTR $T263972[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@6:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ	; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
__ehhandler$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@UIDInfo@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ PROC		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ ENDP		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Init
PUBLIC	??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T264067 = -47						; size = 1
$T264042 = -46						; size = 1
$T264024 = -45						; size = 1
$T264013 = -44						; size = 4
$T264058 = -40						; size = 4
$T264006 = -36						; size = 4
$T263999 = -28						; size = 4
$T263992 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T264067[ebp]
	mov	DWORD PTR $T263992[ebp], eax
	lea	ecx, DWORD PTR $T264042[ebp]
	mov	DWORD PTR $T263999[ebp], ecx
	lea	edx, DWORD PTR $T264024[ebp]
	mov	DWORD PTR $T264006[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T264058[ebp], esp
	mov	DWORD PTR $T264013[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T264150 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+45], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T264150[ebp], eax
	mov	ecx, DWORD PTR $T264150[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Init
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T264262 = -80						; size = 4
__Vptr$264268 = -76					; size = 4
$T264233 = -72						; size = 4
__Vptr$264239 = -68					; size = 4
$T264207 = -64						; size = 4
__Vptr$264205 = -60					; size = 4
$T264167 = -36						; size = 4
$T264166 = -32						; size = 4
$T264165 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T264165[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$264205[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264205[ebp]
	mov	DWORD PTR $T264207[ebp], ecx
	cmp	DWORD PTR $T264207[ebp], 0
	je	SHORT $LN23@Buynode@4
	mov	edx, DWORD PTR $T264207[ebp]
	mov	eax, DWORD PTR $T264165[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264207[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode@4
$LN23@Buynode@4:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode@4:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T264166[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$264239[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264239[ebp]
	mov	DWORD PTR $T264233[ebp], ecx
	cmp	DWORD PTR $T264233[ebp], 0
	je	SHORT $LN33@Buynode@4
	mov	edx, DWORD PTR $T264233[ebp]
	mov	eax, DWORD PTR $T264166[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264233[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode@4
$LN33@Buynode@4:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode@4:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T264167[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$264268[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264268[ebp]
	mov	DWORD PTR $T264262[ebp], ecx
	cmp	DWORD PTR $T264262[ebp], 0
	je	SHORT $LN43@Buynode@4
	mov	edx, DWORD PTR $T264262[ebp]
	mov	eax, DWORD PTR $T264167[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264262[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode@4
$LN43@Buynode@4:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode@4:
	jmp	SHORT $LN6@Buynode@4
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode@4
	ret	0
$LN6@Buynode@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode@4:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+44], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+45], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@4:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Node>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T264329 = -9						; size = 1
$T264325 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T264329[ebp]
	mov	DWORD PTR $T264325[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.cpp
;	COMDAT ??__EplotsToCheck@FSerialization@@YAXXZ
text$yc	SEGMENT
$T264453 = -2						; size = 1
$T264452 = -1						; size = 1
??__EplotsToCheck@FSerialization@@YAXXZ PROC		; FSerialization::`dynamic initializer for 'plotsToCheck'', COMDAT

; 58   : std::set<CvPlot*> plotsToCheck;

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	lea	eax, DWORD PTR $T264452[ebp]
	push	eax
	lea	ecx, DWORD PTR $T264453[ebp]
	push	ecx
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	call	??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
	push	OFFSET ??__FplotsToCheck@FSerialization@@YAXXZ ; FSerialization::`dynamic atexit destructor for 'plotsToCheck''
	call	_atexit
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
??__EplotsToCheck@FSerialization@@YAXXZ ENDP		; FSerialization::`dynamic initializer for 'plotsToCheck''
text$yc	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
PUBLIC	?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Init
PUBLIC	??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T264539 = -47						; size = 1
$T264514 = -46						; size = 1
$T264496 = -45						; size = 1
$T264485 = -44						; size = 4
$T264527 = -40						; size = 4
$T264478 = -36						; size = 4
$T264471 = -28						; size = 4
$T264464 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T264539[ebp]
	mov	DWORD PTR $T264464[ebp], eax
	lea	ecx, DWORD PTR $T264514[ebp]
	mov	DWORD PTR $T264471[ebp], ecx
	lea	edx, DWORD PTR $T264496[ebp]
	mov	DWORD PTR $T264478[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T264527[ebp], esp
	mov	DWORD PTR $T264485[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCvPlot@@@1@ABV?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::~_Tree_val<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T264622 = -4						; size = 4
?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+17], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T264622[ebp], eax
	mov	ecx, DWORD PTR $T264622[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Init
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T264734 = -80						; size = 4
__Vptr$264740 = -76					; size = 4
$T264705 = -72						; size = 4
__Vptr$264711 = -68					; size = 4
$T264676 = -64						; size = 4
__Vptr$264682 = -60					; size = 4
$T264639 = -36						; size = 4
$T264638 = -32						; size = 4
$T264637 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T264637[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$264682[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264682[ebp]
	mov	DWORD PTR $T264676[ebp], ecx
	cmp	DWORD PTR $T264676[ebp], 0
	je	SHORT $LN23@Buynode@5
	mov	edx, DWORD PTR $T264676[ebp]
	mov	eax, DWORD PTR $T264637[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264676[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode@5
$LN23@Buynode@5:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode@5:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T264638[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$264711[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264711[ebp]
	mov	DWORD PTR $T264705[ebp], ecx
	cmp	DWORD PTR $T264705[ebp], 0
	je	SHORT $LN33@Buynode@5
	mov	edx, DWORD PTR $T264705[ebp]
	mov	eax, DWORD PTR $T264638[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264705[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode@5
$LN33@Buynode@5:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode@5:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T264639[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$264740[ebp], eax
	mov	ecx, DWORD PTR __Vptr$264740[ebp]
	mov	DWORD PTR $T264734[ebp], ecx
	cmp	DWORD PTR $T264734[ebp], 0
	je	SHORT $LN43@Buynode@5
	mov	edx, DWORD PTR $T264734[ebp]
	mov	eax, DWORD PTR $T264639[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T264734[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode@5
$LN43@Buynode@5:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode@5:
	jmp	SHORT $LN6@Buynode@5
__catch$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode@5
	ret	0
$LN6@Buynode@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode@5:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+16], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+17], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@5:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Node>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
_TEXT	ENDS
;	COMDAT ??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T264801 = -9						; size = 1
$T264797 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z PROC ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T264801[ebp]
	mov	DWORD PTR $T264797[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 39   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@QAE@U?$less@PAVCvPlot@@@1@V?$allocator@PAVCvPlot@@@1@@Z ENDP ; std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0>
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__FplotsToCheck@FSerialization@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__FplotsToCheck@FSerialization@@YAXXZ$1
__ehfuncinfo$??__FplotsToCheck@FSerialization@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__FplotsToCheck@FSerialization@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??__FplotsToCheck@FSerialization@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__FplotsToCheck@FSerialization@@YAXXZ PROC		; FSerialization::`dynamic atexit destructor for 'plotsToCheck'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__FplotsToCheck@FSerialization@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	call	?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__FplotsToCheck@FSerialization@@YAXXZ$1:
	mov	ecx, OFFSET ?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
	jmp	??1?$_Tree_val@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE@XZ
__ehhandler$??__FplotsToCheck@FSerialization@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__FplotsToCheck@FSerialization@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__FplotsToCheck@FSerialization@@YAXXZ ENDP		; FSerialization::`dynamic atexit destructor for 'plotsToCheck''
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T265330 = -88						; size = 4
$T265296 = -84						; size = 4
$T265129 = -32						; size = 4
$T265116 = -28						; size = 4
$T265104 = -24						; size = 4
$T265094 = -20						; size = 4
$T265093 = -16						; size = 4
$T265092 = -12						; size = 4
$T265091 = -8						; size = 4
$T265090 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265104[ebp], ecx
	mov	edx, DWORD PTR $T265104[ebp]
	mov	DWORD PTR $T265091[ebp], edx
	mov	eax, DWORD PTR $T265091[ebp]
	mov	DWORD PTR $T265090[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265116[ebp], edx
	mov	eax, DWORD PTR $T265116[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T265129[ebp], ecx
	mov	edx, DWORD PTR $T265129[ebp]
	mov	DWORD PTR $T265093[ebp], edx
	mov	eax, DWORD PTR $T265093[ebp]
	mov	DWORD PTR $T265092[ebp], eax
	mov	ecx, DWORD PTR $T265090[ebp]
	push	ecx
	mov	edx, DWORD PTR $T265092[ebp]
	push	edx
	lea	eax, DWORD PTR $T265094[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265296[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265330[ebp], ecx
	mov	edx, DWORD PTR $T265330[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tset_traits@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CvPlot *,std::less<CvPlot *>,std::allocator<CvPlot *>,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ$1
__ehfuncinfo$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ PROC ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`dynamic atexit destructor for 'names'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ$1:
	mov	ecx, OFFSET ?names@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@4V34@A
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE@XZ
__ehhandler$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Fnames@?1??getNames@?$FAutoArchiveClassContainer@VCvPlot@@@@IBEAAV?$map@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@@std@@XZ@YAXXZ ENDP ; `FAutoArchiveClassContainer<CvPlot>::getNames'::`2'::`dynamic atexit destructor for 'names''
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T265858 = -88						; size = 4
$T265824 = -84						; size = 4
$T265657 = -32						; size = 4
$T265644 = -28						; size = 4
$T265632 = -24						; size = 4
$T265622 = -20						; size = 4
$T265621 = -16						; size = 4
$T265620 = -12						; size = 4
$T265619 = -8						; size = 4
$T265618 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265632[ebp], ecx
	mov	edx, DWORD PTR $T265632[ebp]
	mov	DWORD PTR $T265619[ebp], edx
	mov	eax, DWORD PTR $T265619[ebp]
	mov	DWORD PTR $T265618[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265644[ebp], edx
	mov	eax, DWORD PTR $T265644[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T265657[ebp], ecx
	mov	edx, DWORD PTR $T265657[ebp]
	mov	DWORD PTR $T265621[ebp], edx
	mov	eax, DWORD PTR $T265621[ebp]
	mov	DWORD PTR $T265620[ebp], eax
	mov	ecx, DWORD PTR $T265618[ebp]
	push	ecx
	mov	edx, DWORD PTR $T265620[ebp]
	push	edx
	lea	eax, DWORD PTR $T265622[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T265824[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265858[ebp], ecx
	mov	edx, DWORD PTR $T265858[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T266112 = -76						; size = 4
$T266107 = -72						; size = 4
__Tmp$266091 = -52					; size = 4
$T266022 = -48						; size = 4
$T266009 = -44						; size = 4
$T265906 = -28						; size = 4
$T265883 = -24						; size = 4
$T265870 = -20						; size = 4
$T265864 = -16						; size = 4
$T265863 = -12						; size = 4
$T265862 = -8						; size = 4
$T265861 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T265870[ebp], ecx
	mov	edx, DWORD PTR $T265870[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T265883[ebp], eax
	mov	ecx, DWORD PTR $T265883[ebp]
	mov	DWORD PTR $T265861[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T265861[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN81@erase@5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T265906[ebp], eax
	mov	ecx, DWORD PTR $T265906[ebp]
	mov	DWORD PTR $T265862[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T265862[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN81@erase@5

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T266009[ebp], eax
	mov	ecx, DWORD PTR $T266009[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T266022[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T266022[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@5

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@5

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN81@erase@5:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@5

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$266091[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$266091[ebp]
	mov	DWORD PTR $T265863[ebp], ecx
	mov	edx, DWORD PTR $T265863[ebp]
	push	edx
	lea	eax, DWORD PTR $T265864[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
	jmp	SHORT $LN81@erase@5
$LN1@erase@5:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T266112[ebp], ecx
	mov	edx, DWORD PTR $T266112[ebp]
	mov	DWORD PTR $T266107[ebp], edx
	mov	eax, DWORD PTR $T266107[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@5:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -220						; size = 4
tv165 = -216						; size = 4
_this$ = -212						; size = 4
$T267006 = -208						; size = 4
$T267001 = -204						; size = 4
$T266954 = -200						; size = 4
$T266372 = -136						; size = 4
$T266371 = -132						; size = 4
__Tmp$266370 = -125					; size = 1
$T266347 = -124						; size = 4
$T266340 = -120						; size = 4
$T266270 = -116						; size = 4
$T266234 = -112						; size = 4
$T266229 = -108						; size = 4
$T266201 = -104						; size = 4
$T266125 = -100						; size = 4
$T266116 = -96						; size = 28
$T266115 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T266125[ebp], eax
	mov	ecx, DWORD PTR $T266125[ebp]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN55@erase@6

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T266116[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T266116[ebp]
	push	eax
	lea	ecx, DWORD PTR $T266115[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T266115[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T266115[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T266116[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@6:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	je	SHORT $LN67@erase@6

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@6

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@6:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN71@erase@6

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@6

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@6:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@6:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@6

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	jne	SHORT $LN81@erase@6

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@6

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@6

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@6:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@6

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@6

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@6:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@6:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T266201[ebp], ecx
	mov	edx, DWORD PTR $T266201[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@6

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+45]
	test	edx, edx
	je	SHORT $LN43@erase@6
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@6
$LN43@erase@6:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T266229[ebp], ecx
$LN107@erase@6:
	mov	edx, DWORD PTR $T266229[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	jne	SHORT $LN103@erase@6
	mov	edx, DWORD PTR $T266229[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T266229[ebp], eax
	jmp	SHORT $LN107@erase@6
$LN103@erase@6:
	mov	ecx, DWORD PTR $T266229[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@6:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T266234[ebp], eax
	mov	ecx, DWORD PTR $T266234[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@6

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	je	SHORT $LN45@erase@6
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@6
$LN45@erase@6:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T266270[ebp], eax
$LN127@erase@6:
	mov	ecx, DWORD PTR $T266270[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	jne	SHORT $LN123@erase@6
	mov	ecx, DWORD PTR $T266270[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T266270[ebp], edx
	jmp	SHORT $LN127@erase@6
$LN123@erase@6:
	mov	eax, DWORD PTR $T266270[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@6:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@6

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@6:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@6

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@6

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+45]
	test	ecx, ecx
	jne	SHORT $LN151@erase@6

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@6:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@6

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@6

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@6:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T266340[ebp], ecx
	mov	edx, DWORD PTR $T266340[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@6

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T266347[ebp], edx
	mov	eax, DWORD PTR $T266347[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@6

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@6:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 44					; 0000002cH
	mov	DWORD PTR $T266372[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T266371[ebp], eax
	mov	ecx, DWORD PTR $T266371[ebp]
	cmp	ecx, DWORD PTR $T266372[ebp]
	je	SHORT $LN192@erase@6
	mov	edx, DWORD PTR $T266371[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$266370[ebp], al
	mov	ecx, DWORD PTR $T266371[ebp]
	mov	edx, DWORD PTR $T266372[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T266372[ebp]
	mov	dl, BYTE PTR __Tmp$266370[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@6:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	$LN595@erase@6

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@6
$LN194@erase@6:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@6
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+44]
	cmp	edx, 1
	jne	$LN586@erase@6

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@6

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+44]
	test	edx, edx
	jne	SHORT $LN263@erase@6

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+44], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+44], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	je	SHORT $LN267@erase@6

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@6

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@6
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@6

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+44], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@6

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+44]
	cmp	eax, 1
	jne	SHORT $LN338@erase@6

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+44], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+44], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+44]
	mov	BYTE PTR [ecx+44], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+44], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+44], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@6
$LN12@erase@6:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@6

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@6:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+44]
	test	edx, edx
	jne	SHORT $LN454@erase@6

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+44], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+44], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	je	SHORT $LN458@erase@6

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@6

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@6:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@6
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@6

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+44], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@6

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+44]
	cmp	eax, 1
	jne	SHORT $LN529@erase@6

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+44], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+44], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@6:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+44]
	mov	BYTE PTR [ecx+44], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+44], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+44], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@6
$LN8@erase@6:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@6

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@6:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+44], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN595@erase@6:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T266954[ebp], eax
	mov	ecx, DWORD PTR $T266954[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	ecx, ecx
	and	ecx, 1
	je	SHORT $LN588@erase@6
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN588@erase@6:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@6

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@6:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T267006[ebp], edx
	mov	eax, DWORD PTR $T267006[ebp]
	mov	DWORD PTR $T267001[ebp], eax
	mov	ecx, DWORD PTR $T267001[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@6:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T266116[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T267089 = -12						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T267089[ebp], eax
	mov	ecx, DWORD PTR $T267089[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T267122 = -8						; size = 4
__Pnode$211276 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$211276[ebp], eax
	jmp	SHORT $LN6@Erase@2
$LN2@Erase@2:
	mov	ecx, DWORD PTR __Pnode$211276[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase@2:
	mov	edx, DWORD PTR __Pnode$211276[ebp]
	movsx	eax, BYTE PTR [edx+45]
	test	eax, eax
	jne	SHORT $LN4@Erase@2

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$211276[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$211276[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$211276[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T267122[ebp], edx
	mov	ecx, DWORD PTR $T267122[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN12@Erase@2
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@Erase@2:

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase@2
$LN4@Erase@2:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U?$less@I@2@V?$allocator@U?$pair@$$CBIV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@2@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A ; FSerialization::plotsToCheck
_BSS	SEGMENT
?plotsToCheck@FSerialization@@3V?$set@PAVCvPlot@@U?$less@PAVCvPlot@@@std@@V?$allocator@PAVCvPlot@@@3@@std@@A DB 0cH DUP (?) ; FSerialization::plotsToCheck
_BSS	ENDS
CRT$XCU	SEGMENT
_plotsToCheck$initializer$ DD FLAT:??__EplotsToCheck@FSerialization@@YAXXZ
CRT$XCU	ENDS
END
