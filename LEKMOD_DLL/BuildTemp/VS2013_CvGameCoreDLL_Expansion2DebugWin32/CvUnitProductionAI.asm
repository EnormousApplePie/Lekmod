; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvUnitProductionAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ		; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
PUBLIC	??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z ; CvUnitProductionAI::CvUnitProductionAI
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z$0
__ehfuncinfo$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunitproductionai.cpp
xdata$x	ENDS
;	COMDAT ??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T218425 = -36						; size = 4
$T218408 = -24						; size = 4
__$EHRec$ = -12						; size = 12
_pCity$ = 8						; size = 4
_pUnits$ = 12						; size = 4
??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z PROC ; CvUnitProductionAI::CvUnitProductionAI, COMDAT
; _this$ = ecx

; 21   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pUnits$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T218408[ebp], ecx
	mov	ecx, DWORD PTR $T218408[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 744				; 000002e8H
	mov	DWORD PTR $T218425[ebp], edx
	mov	ecx, DWORD PTR $T218425[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>

; 22   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ	; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>
__ehhandler$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvUnitProductionAI@@QAE@PAVCvCity@@PAVCvUnitXMLEntries@@@Z ENDP ; CvUnitProductionAI::CvUnitProductionAI
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
PUBLIC	??1CvUnitProductionAI@@QAE@XZ			; CvUnitProductionAI::~CvUnitProductionAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvUnitProductionAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvUnitProductionAI@@QAE@XZ$0
__ehfuncinfo$??1CvUnitProductionAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvUnitProductionAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunitproductionai.cpp
xdata$x	ENDS
;	COMDAT ??1CvUnitProductionAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T218504 = -44						; size = 4
$T218472 = -28						; size = 4
__$EHRec$ = -12						; size = 12
??1CvUnitProductionAI@@QAE@XZ PROC			; CvUnitProductionAI::~CvUnitProductionAI, COMDAT
; _this$ = ecx

; 26   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvUnitProductionAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 27   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 744				; 000002e8H
	mov	DWORD PTR $T218472[ebp], eax
	mov	ecx, DWORD PTR $T218472[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T218504[ebp], ecx
	mov	ecx, DWORD PTR $T218504[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvUnitProductionAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ	; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>
__ehhandler$??1CvUnitProductionAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvUnitProductionAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvUnitProductionAI@@QAE@XZ ENDP			; CvUnitProductionAI::~CvUnitProductionAI
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back
PUBLIC	?Reset@CvUnitProductionAI@@QAEXXZ		; CvUnitProductionAI::Reset
EXTRN	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ:PROC	; CvUnitXMLEntries::GetNumUnits
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvUnitProductionAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
_weightedElem$218584 = -20				; size = 8
$T218543 = -12						; size = 4
_i$218537 = -8						; size = 4
_i$217508 = -4						; size = 4
?Reset@CvUnitProductionAI@@QAEXXZ PROC			; CvUnitProductionAI::Reset, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 32   : 	CvAssertMsg(m_pUnits != NULL, "Unit Production AI init failure: unit entries are NULL");
; 33   : 
; 34   : 	m_UnitAIWeights.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T218543[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN15@Reset
	mov	DWORD PTR _i$218537[ebp], 0
	jmp	SHORT $LN13@Reset
$LN12@Reset:
	mov	edx, DWORD PTR _i$218537[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218537[ebp], edx
$LN13@Reset:
	mov	eax, DWORD PTR $T218543[ebp]
	mov	ecx, DWORD PTR _i$218537[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN15@Reset
	jmp	SHORT $LN12@Reset
$LN15@Reset:
	mov	edx, DWORD PTR $T218543[ebp]
	mov	DWORD PTR [edx+4], 0

; 35   : 
; 36   : 	// Loop through reading each one and add an entry with 0 weight to our vector
; 37   : 	if(m_pUnits)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@Reset

; 38   : 	{
; 39   : #ifdef AUI_WARNING_FIXES
; 40   : 		for (uint i = 0; i < m_pUnits->GetNumUnits(); i++)
; 41   : #else
; 42   : 		for(int i = 0; i < m_pUnits->GetNumUnits(); i++)

	mov	DWORD PTR _i$217508[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	ecx, DWORD PTR _i$217508[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$217508[ebp], ecx
$LN3@Reset:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	cmp	DWORD PTR _i$217508[ebp], eax
	jge	SHORT $LN5@Reset

; 43   : #endif
; 44   : 		{
; 45   : 			m_UnitAIWeights.push_back(i, 0);

	mov	DWORD PTR _weightedElem$218584[ebp], 0
	mov	DWORD PTR _weightedElem$218584[ebp+4], 0
	mov	eax, DWORD PTR _i$217508[ebp]
	mov	DWORD PTR _weightedElem$218584[ebp], eax
	mov	DWORD PTR _weightedElem$218584[ebp+4], 0
	lea	ecx, DWORD PTR _weightedElem$218584[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back

; 46   : 		}

	jmp	SHORT $LN2@Reset
$LN5@Reset:

; 47   : 	}
; 48   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvUnitProductionAI@@QAEXXZ ENDP			; CvUnitProductionAI::Reset
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0CA@GJBFFAJH@LOAD?5ERROR?3?5Unit?5Type?5not?5found?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z ; CvUnitProductionAI::Read
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?LogMessage@CvGlobals@@QAEXPBD@Z:PROC		; CvGlobals::LogMessage
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
;	COMDAT ??_C@_0CA@GJBFFAJH@LOAD?5ERROR?3?5Unit?5Type?5not?5found?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CA@GJBFFAJH@LOAD?5ERROR?3?5Unit?5Type?5not?5found?$AA@ DB 'LOAD ER'
	DB	'ROR: Unit Type not found', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z$0
__ehfuncinfo$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunitproductionai.cpp
xdata$x	ENDS
;	COMDAT ?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv154 = -100						; size = 4
_this$ = -96						; size = 4
$T218646 = -92						; size = 4
_weightedElem$218631 = -88				; size = 8
$T218622 = -80						; size = 4
_i$218616 = -76						; size = 4
_szError$217534 = -72					; size = 28
__$ArrayPad$ = -44					; size = 4
_bValid$217529 = -37					; size = 1
_iI$217525 = -36					; size = 4
_i$217519 = -32						; size = 4
_iType$217524 = -28					; size = 4
_iNumEntries$217523 = -24				; size = 4
_uiVersion$ = -20					; size = 4
_iWeight$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z PROC	; CvUnitProductionAI::Read, COMDAT
; _this$ = ecx

; 52   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 	// Version number to maintain backwards compatibility
; 54   : 	uint uiVersion;
; 55   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 56   : 
; 57   : 	int iWeight;
; 58   : 
; 59   : 	// Reset vector
; 60   : 	m_UnitAIWeights.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T218622[ebp], ecx
	xor	edx, edx
	je	SHORT $LN26@Read
	mov	DWORD PTR _i$218616[ebp], 0
	jmp	SHORT $LN24@Read
$LN23@Read:
	mov	eax, DWORD PTR _i$218616[ebp]
	add	eax, 1
	mov	DWORD PTR _i$218616[ebp], eax
$LN24@Read:
	mov	ecx, DWORD PTR $T218622[ebp]
	mov	edx, DWORD PTR _i$218616[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN26@Read
	jmp	SHORT $LN23@Read
$LN26@Read:
	mov	eax, DWORD PTR $T218622[ebp]
	mov	DWORD PTR [eax+4], 0

; 61   : 
; 62   : 	// Loop through reading each one and adding it to our vector
; 63   : 	if(m_pUnits)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$LN13@Read

; 64   : 	{
; 65   : #ifdef AUI_WARNING_FIXES
; 66   : 		for (uint i = 0; i < m_pUnits->GetNumUnits(); i++)
; 67   : #else
; 68   : 		for(int i = 0; i < m_pUnits->GetNumUnits(); i++)

	mov	DWORD PTR _i$217519[ebp], 0
	jmp	SHORT $LN11@Read
$LN10@Read:
	mov	edx, DWORD PTR _i$217519[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217519[ebp], edx
$LN11@Read:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	cmp	DWORD PTR _i$217519[ebp], eax
	jge	SHORT $LN9@Read

; 69   : #endif
; 70   : 		{
; 71   : 			m_UnitAIWeights.push_back(i, 0);

	mov	DWORD PTR _weightedElem$218631[ebp], 0
	mov	DWORD PTR _weightedElem$218631[ebp+4], 0
	mov	ecx, DWORD PTR _i$217519[ebp]
	mov	DWORD PTR _weightedElem$218631[ebp], ecx
	mov	DWORD PTR _weightedElem$218631[ebp+4], 0
	lea	edx, DWORD PTR _weightedElem$218631[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back

; 72   : 		}

	jmp	SHORT $LN10@Read
$LN9@Read:

; 73   : 
; 74   : #ifdef AUI_WARNING_FIXES
; 75   : 		uint iNumEntries;
; 76   : 		int iType;
; 77   : 
; 78   : 		kStream >> iNumEntries;
; 79   : 
; 80   : 		for (uint iI = 0; iI < iNumEntries; iI++)
; 81   : #else
; 82   : 		int iNumEntries;
; 83   : 		int iType;
; 84   : 
; 85   : 		kStream >> iNumEntries;

	lea	eax, DWORD PTR _iNumEntries$217523[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 86   : 
; 87   : 		for(int iI = 0; iI < iNumEntries; iI++)

	mov	DWORD PTR _iI$217525[ebp], 0
	jmp	SHORT $LN8@Read
$LN7@Read:
	mov	ecx, DWORD PTR _iI$217525[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$217525[ebp], ecx
$LN8@Read:
	mov	edx, DWORD PTR _iI$217525[ebp]
	cmp	edx, DWORD PTR _iNumEntries$217523[ebp]
	jge	$LN13@Read

; 88   : #endif
; 89   : 		{
; 90   : 			bool bValid = true;

	mov	BYTE PTR _bValid$217529[ebp], 1

; 91   : 			iType = CvInfosSerializationHelper::ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$217529[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$217524[ebp], eax

; 92   : 			if(iType != -1 || !bValid)

	cmp	DWORD PTR _iType$217524[ebp], -1
	jne	SHORT $LN4@Read
	movzx	edx, BYTE PTR _bValid$217529[ebp]
	test	edx, edx
	jne	SHORT $LN5@Read
$LN4@Read:

; 93   : 			{
; 94   : 				kStream >> iWeight;

	lea	eax, DWORD PTR _iWeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 95   : 				if(iType != -1)

	cmp	DWORD PTR _iType$217524[ebp], -1
	je	SHORT $LN3@Read

; 96   : 				{
; 97   : 					m_UnitAIWeights.IncreaseWeight(iType, iWeight);

	mov	ecx, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR $T218646[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _iType$217524[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR tv154[ebp], edx
	mov	eax, DWORD PTR tv154[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR $T218646[ebp]
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR [edx], ecx

; 98   : 				}
; 99   : 				else

	jmp	SHORT $LN5@Read
$LN3@Read:

; 100  : 				{
; 101  : 					CvString szError;

	lea	ecx, DWORD PTR _szError$217534[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 102  : 					szError.Format("LOAD ERROR: Unit Type not found");

	push	OFFSET ??_C@_0CA@GJBFFAJH@LOAD?5ERROR?3?5Unit?5Type?5not?5found?$AA@
	lea	eax, DWORD PTR _szError$217534[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 103  : 					GC.LogMessage(szError.GetCString());

	lea	ecx, DWORD PTR _szError$217534[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?LogMessage@CvGlobals@@QAEXPBD@Z	; CvGlobals::LogMessage

; 104  : 					CvAssertMsg(false, szError);
; 105  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szError$217534[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@Read:

; 106  : 			}
; 107  : 		}

	jmp	$LN7@Read
$LN13@Read:

; 108  : 	}
; 109  : 	else
; 110  : 	{
; 111  : 		CvAssertMsg(m_pUnits != NULL, "Unit Production AI init failure: unit entries are NULL");
; 112  : 	}
; 113  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _szError$217534[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Read@CvUnitProductionAI@@QAEXAAVFDataStream@@@Z ENDP	; CvUnitProductionAI::Read
PUBLIC	??1FStringA@@QAE@XZ				; FStringA::~FStringA
PUBLIC	?Release@FStringA@@QAEXXZ			; FStringA::Release
PUBLIC	??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>
PUBLIC	__$ArrayPad$
PUBLIC	?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z ; CvUnitProductionAI::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
EXTRN	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ:PROC ; FStringA_GetStringInitData
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstringa.inl
xdata$x	SEGMENT
__unwindtable$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z$0
__ehfuncinfo$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunitproductionai.cpp
xdata$x	ENDS
;	COMDAT ?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -164						; size = 4
_elem$218723 = -148					; size = 8
$T218675 = -136						; size = 4
$T218668 = -132						; size = 4
$T218667 = -128						; size = 4
_eUnit$217563 = -124					; size = 4
_pkUnitInfo$217565 = -120				; size = 4
_iI$217559 = -116					; size = 4
_iNumUnits$217558 = -112				; size = 4
_uiVersion$ = -108					; size = 4
_sTemp$ = -104						; size = 4
_FStringFixedBuffer_sTemp$ = -100			; size = 76
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z PROC	; CvUnitProductionAI::Write, COMDAT
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	FStringFixedBuffer(sTemp, 64);

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	mov	DWORD PTR $T218675[ebp], eax
	mov	eax, DWORD PTR $T218675[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _sTemp$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _sTemp$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _FStringFixedBuffer_sTemp$[ebp]
	call	??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>

; 119  : 
; 120  : 	// Current version number
; 121  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 122  : 	kStream << uiVersion;

	lea	edx, DWORD PTR _uiVersion$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 123  : 
; 124  : 	if(m_pUnits)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Write

; 125  : 	{
; 126  : #ifdef AUI_WARNING_FIXES
; 127  : 		uint iNumUnits = m_pUnits->GetNumUnits();
; 128  : 		kStream << iNumUnits;
; 129  : 
; 130  : 		// Loop through writing each entry
; 131  : 		for (uint iI = 0; iI < iNumUnits; iI++)
; 132  : #else
; 133  : 		int iNumUnits = m_pUnits->GetNumUnits();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	mov	DWORD PTR _iNumUnits$217558[ebp], eax

; 134  : 		kStream << iNumUnits;

	lea	edx, DWORD PTR _iNumUnits$217558[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 135  : 
; 136  : 		// Loop through writing each entry
; 137  : 		for(int iI = 0; iI < iNumUnits; iI++)

	mov	DWORD PTR _iI$217559[ebp], 0
	jmp	SHORT $LN6@Write
$LN5@Write:
	mov	eax, DWORD PTR _iI$217559[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$217559[ebp], eax
$LN6@Write:
	mov	ecx, DWORD PTR _iI$217559[ebp]
	cmp	ecx, DWORD PTR _iNumUnits$217558[ebp]
	jge	$LN1@Write

; 138  : #endif
; 139  : 		{
; 140  : 			const UnitTypes eUnit = static_cast<UnitTypes>(iI);

	mov	edx, DWORD PTR _iI$217559[ebp]
	mov	DWORD PTR _eUnit$217563[ebp], edx

; 141  : 			CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$217563[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$217565[ebp], eax

; 142  : 			if(pkUnitInfo)

	cmp	DWORD PTR _pkUnitInfo$217565[ebp], 0
	je	SHORT $LN3@Write

; 143  : 			{
; 144  : 				CvInfosSerializationHelper::WriteHashed(kStream, pkUnitInfo);

	mov	ecx, DWORD PTR _pkUnitInfo$217565[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 145  : 				kStream << m_UnitAIWeights.GetWeight(iI);

	mov	DWORD PTR _elem$218723[ebp], 0
	mov	DWORD PTR _elem$218723[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _iI$217559[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _elem$218723[ebp], eax
	mov	DWORD PTR _elem$218723[ebp+4], ecx
	mov	edx, DWORD PTR _elem$218723[ebp+4]
	mov	DWORD PTR $T218667[ebp], edx
	lea	eax, DWORD PTR $T218667[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 146  : 			}
; 147  : 			else

	jmp	SHORT $LN2@Write
$LN3@Write:

; 148  : 			{
; 149  : 				kStream << (int)0;

	mov	DWORD PTR $T218668[ebp], 0
	lea	ecx, DWORD PTR $T218668[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN2@Write:

; 150  : 			}
; 151  : 		}

	jmp	$LN5@Write
$LN1@Write:

; 152  : 	}
; 153  : 	else
; 154  : 	{
; 155  : 		CvAssertMsg(m_pUnits != NULL, "Unit Production AI init failure: unit entries are NULL");
; 156  : 	}
; 157  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sTemp$[ebp]
	call	?Release@FStringA@@QAEXXZ		; FStringA::Release
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _sTemp$[ebp]
	jmp	??1FStringA@@QAE@XZ			; FStringA::~FStringA
__ehhandler$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Write@CvUnitProductionAI@@QBEXAAVFDataStream@@@Z ENDP	; CvUnitProductionAI::Write
PUBLIC	?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z ; CvUnitProductionAI::AddFlavorWeights
EXTRN	?GetFlavorValue@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetFlavorValue
EXTRN	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z:PROC ; CvUnitXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z
_TEXT	SEGMENT
tv90 = -20						; size = 4
_this$ = -16						; size = 4
$T218774 = -12						; size = 4
_entry$217581 = -8					; size = 4
_iUnit$217577 = -4					; size = 4
_eFlavor$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z PROC ; CvUnitProductionAI::AddFlavorWeights, COMDAT
; _this$ = ecx

; 161  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 	// Loop through all units
; 163  : #ifdef AUI_WARNING_FIXES
; 164  : 	for (uint iUnit = 0; iUnit < m_pUnits->GetNumUnits(); iUnit++)
; 165  : #else
; 166  : 	for(int iUnit = 0; iUnit < m_pUnits->GetNumUnits(); iUnit++)

	mov	DWORD PTR _iUnit$217577[ebp], 0
	jmp	SHORT $LN4@AddFlavorW
$LN3@AddFlavorW:
	mov	eax, DWORD PTR _iUnit$217577[ebp]
	add	eax, 1
	mov	DWORD PTR _iUnit$217577[ebp], eax
$LN4@AddFlavorW:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	cmp	DWORD PTR _iUnit$217577[ebp], eax
	jge	SHORT $LN5@AddFlavorW

; 167  : #endif
; 168  : 	{
; 169  : 		CvUnitEntry* entry = m_pUnits->GetEntry(iUnit);

	mov	edx, DWORD PTR _iUnit$217577[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _entry$217581[ebp], eax

; 170  : 		if(entry)

	cmp	DWORD PTR _entry$217581[ebp], 0
	je	SHORT $LN1@AddFlavorW

; 171  : 		{
; 172  : 			// Set its weight by looking at unit's weight for this flavor and using iWeight multiplier passed in
; 173  : 			m_UnitAIWeights.IncreaseWeight(iUnit, entry->GetFlavorValue(eFlavor) * iWeight);

	mov	ecx, DWORD PTR _eFlavor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _entry$217581[ebp]
	call	?GetFlavorValue@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetFlavorValue
	imul	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR $T218774[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _iUnit$217577[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR tv90[ebp], edx
	mov	eax, DWORD PTR tv90[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR $T218774[ebp]
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@AddFlavorW:

; 174  : 		}

	jmp	SHORT $LN3@AddFlavorW
$LN5@AddFlavorW:

; 175  : 	}
; 176  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddFlavorWeights@CvUnitProductionAI@@QAEXW4FlavorTypes@@H@Z ENDP ; CvUnitProductionAI::AddFlavorWeights
_TEXT	ENDS
PUBLIC	?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ; CvUnitProductionAI::GetWeight
; Function compile flags: /Odtp
;	COMDAT ?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_elem$218785 = -8					; size = 8
_eUnit$ = 8						; size = 4
?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z PROC	; CvUnitProductionAI::GetWeight, COMDAT
; _this$ = ecx

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 181  : 	return m_UnitAIWeights.GetWeight(eUnit);

	mov	DWORD PTR _elem$218785[ebp], 0
	mov	DWORD PTR _elem$218785[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _eUnit$[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _elem$218785[ebp], eax
	mov	DWORD PTR _elem$218785[ebp+4], ecx
	mov	eax, DWORD PTR _elem$218785[ebp+4]

; 182  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetWeight@CvUnitProductionAI@@QAEHW4UnitTypes@@@Z ENDP	; CvUnitProductionAI::GetWeight
_TEXT	ENDS
PUBLIC	?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z ; CvUnitProductionAI::LogPossibleBuilds
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
PUBLIC	?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ; CvUnitProductionAI::RecommendUnit
EXTRN	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z:PROC ; CityStrategyAIHelpers::ReweightByTurnsLeft
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z:PROC ; CvCity::getProductionTurnsLeft
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?canTrain@CvCity@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z:PROC ; CvCity::canTrain
EXTRN	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ:PROC ; CvGlobals::GetGameUnits
; Function compile flags: /Odtp
;	COMDAT ?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T218927 = -88						; size = 4
$T218877 = -68						; size = 4
$T218873 = -64						; size = 4
$T218864 = -60						; size = 4
_weightedElem$218856 = -48				; size = 8
$T218838 = -40						; size = 4
_elem$218832 = -36					; size = 8
$T218823 = -28						; size = 4
_i$218818 = -24						; size = 4
_eUnit$217598 = -20					; size = 4
_pkUnitInfo$217600 = -16				; size = 4
_iTurnsLeft$ = -12					; size = 4
_iWeight$ = -8						; size = 4
_iUnitLoop$ = -4					; size = 4
_eUnitAIType$ = 8					; size = 4
?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z PROC ; CvUnitProductionAI::RecommendUnit, COMDAT
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 187  : #ifdef AUI_WARNING_FIXES
; 188  : 	uint iUnitLoop;
; 189  : #else
; 190  : 	int iUnitLoop;
; 191  : #endif
; 192  : 	int iWeight;
; 193  : 	int iTurnsLeft;
; 194  : 
; 195  : 	if(eUnitAIType <= NO_UNITAI)

	cmp	DWORD PTR _eUnitAIType$[ebp], -1
	jg	SHORT $LN10@RecommendU

; 196  : 	{
; 197  : 		return NO_UNIT;

	or	eax, -1
	jmp	$LN11@RecommendU
$LN10@RecommendU:

; 198  : 	}
; 199  : 
; 200  : 	// Reset list of all the possible units
; 201  : 	m_Buildables.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 744				; 000002e8H
	mov	DWORD PTR $T218823[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@RecommendU
	mov	DWORD PTR _i$218818[ebp], 0
	jmp	SHORT $LN19@RecommendU
$LN18@RecommendU:
	mov	edx, DWORD PTR _i$218818[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218818[ebp], edx
$LN19@RecommendU:
	mov	eax, DWORD PTR $T218823[ebp]
	mov	ecx, DWORD PTR _i$218818[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN21@RecommendU
	jmp	SHORT $LN18@RecommendU
$LN21@RecommendU:
	mov	edx, DWORD PTR $T218823[ebp]
	mov	DWORD PTR [edx+4], 0

; 202  : 
; 203  : 	// Loop through adding the available units
; 204  : 	for(iUnitLoop = 0; iUnitLoop < GC.GetGameUnits()->GetNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$[ebp], 0
	jmp	SHORT $LN9@RecommendU
$LN8@RecommendU:
	mov	eax, DWORD PTR _iUnitLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iUnitLoop$[ebp], eax
$LN9@RecommendU:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetNumUnits@CvUnitXMLEntries@@QAEHXZ	; CvUnitXMLEntries::GetNumUnits
	cmp	DWORD PTR _iUnitLoop$[ebp], eax
	jge	$LN7@RecommendU

; 205  : 	{
; 206  : 		const UnitTypes eUnit = static_cast<UnitTypes>(iUnitLoop);

	mov	ecx, DWORD PTR _iUnitLoop$[ebp]
	mov	DWORD PTR _eUnit$217598[ebp], ecx

; 207  : 		CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);

	mov	edx, DWORD PTR _eUnit$217598[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$217600[ebp], eax

; 208  : 		if(pkUnitInfo)

	cmp	DWORD PTR _pkUnitInfo$217600[ebp], 0
	je	$LN6@RecommendU

; 209  : 		{
; 210  : 			// Make sure this unit can be built now
; 211  : 			if(m_pCity->canTrain(eUnit))

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _eUnit$217598[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?canTrain@CvCity@@QBE_NW4UnitTypes@@_N111PAVCvString@@@Z ; CvCity::canTrain
	movzx	edx, al
	test	edx, edx
	je	$LN6@RecommendU

; 212  : 			{
; 213  : 				// Make sure it matches the requested unit AI type
; 214  : 				if(eUnitAIType == NO_UNITAI || pkUnitInfo->GetUnitAIType(eUnitAIType))

	cmp	DWORD PTR _eUnitAIType$[ebp], -1
	je	SHORT $LN3@RecommendU
	mov	eax, DWORD PTR _eUnitAIType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkUnitInfo$217600[ebp]
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@RecommendU
$LN3@RecommendU:

; 215  : 				{
; 216  : 					// Update weight based on turns to construct
; 217  : 					iTurnsLeft = m_pCity->getProductionTurnsLeft(eUnit, 0);

	push	0
	mov	edx, DWORD PTR _eUnit$217598[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getProductionTurnsLeft@CvCity@@QBEHW4UnitTypes@@H@Z ; CvCity::getProductionTurnsLeft
	mov	DWORD PTR _iTurnsLeft$[ebp], eax

; 218  : 					iWeight = CityStrategyAIHelpers::ReweightByTurnsLeft(m_UnitAIWeights.GetWeight(eUnit), iTurnsLeft);

	mov	DWORD PTR _elem$218832[ebp], 0
	mov	DWORD PTR _elem$218832[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _eUnit$217598[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$218832[ebp], ecx
	mov	DWORD PTR _elem$218832[ebp+4], edx
	mov	eax, DWORD PTR _elem$218832[ebp+4]
	mov	DWORD PTR $T218838[ebp], eax
	mov	ecx, DWORD PTR _iTurnsLeft$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T218838[ebp]
	push	edx
	call	?ReweightByTurnsLeft@CityStrategyAIHelpers@@YAHHH@Z ; CityStrategyAIHelpers::ReweightByTurnsLeft
	add	esp, 8
	mov	DWORD PTR _iWeight$[ebp], eax

; 219  : 					m_Buildables.push_back(iUnitLoop, iWeight);

	mov	DWORD PTR _weightedElem$218856[ebp], 0
	mov	DWORD PTR _weightedElem$218856[ebp+4], 0
	mov	eax, DWORD PTR _iUnitLoop$[ebp]
	mov	DWORD PTR _weightedElem$218856[ebp], eax
	mov	ecx, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _weightedElem$218856[ebp+4], ecx
	lea	edx, DWORD PTR _weightedElem$218856[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 744				; 000002e8H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back
$LN6@RecommendU:

; 220  : 				}
; 221  : 			}
; 222  : 		}
; 223  : 
; 224  : 	}

	jmp	$LN8@RecommendU
$LN7@RecommendU:

; 225  : 
; 226  : 	// Sort items and grab the first one
; 227  : 	if(m_Buildables.size() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	mov	DWORD PTR $T218864[ebp], ecx
	cmp	DWORD PTR $T218864[ebp], 0
	jle	SHORT $LN2@RecommendU

; 228  : 	{
; 229  : 		m_Buildables.SortItems();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 744				; 000002e8H
	mov	DWORD PTR $T218927[ebp], edx
	mov	eax, DWORD PTR $T218927[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T218927[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T218873[ebp], ecx
	mov	edx, DWORD PTR $T218927[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T218877[ebp], eax
	mov	ecx, DWORD PTR $T218873[ebp]
	sub	ecx, DWORD PTR $T218877[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T218873[ebp]
	push	edx
	mov	eax, DWORD PTR $T218877[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 230  : 		LogPossibleBuilds(eUnitAIType);

	mov	ecx, DWORD PTR _eUnitAIType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z ; CvUnitProductionAI::LogPossibleBuilds

; 231  : 		return (UnitTypes)m_Buildables.GetElement(0);

	xor	edx, edx
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+744]
	mov	eax, DWORD PTR [edx+ecx]
	jmp	SHORT $LN11@RecommendU

; 232  : 	}
; 233  : 
; 234  : 	// Unless we didn't find any
; 235  : 	else

	jmp	SHORT $LN11@RecommendU
$LN2@RecommendU:

; 236  : 	{
; 237  : 		return NO_UNIT;

	or	eax, -1
$LN11@RecommendU:

; 238  : 	}
; 239  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RecommendUnit@CvUnitProductionAI@@QAE?AW4UnitTypes@@W4UnitAITypes@@@Z ENDP ; CvUnitProductionAI::RecommendUnit
_TEXT	ENDS
PUBLIC	??_C@_0CN@DHMOLJNG@Special?5request?5for?5unit?5of?5type@ ; `string'
PUBLIC	??_C@_0N@OHOCDCHA@Unit?0?5?$CFs?0?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0N@EHKDMPBC@Unknown?5Unit?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z:PROC ; getUnitAIString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z:PROC ; CvCityStrategyAI::GetLogFileName
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_0CN@DHMOLJNG@Special?5request?5for?5unit?5of?5type@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CN@DHMOLJNG@Special?5request?5for?5unit?5of?5type@ DB 'Special req'
	DB	'uest for unit of type: %s, %s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OHOCDCHA@Unit?0?5?$CFs?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0N@OHOCDCHA@Unit?0?5?$CFs?0?5?$CFd?$AA@ DB 'Unit, %s, %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHKDMPBC@Unknown?5Unit?$AA@
CONST	SEGMENT
??_C@_0N@EHKDMPBC@Unknown?5Unit?$AA@ DB 'Unknown Unit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$6
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$11
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvunitproductionai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z
_TEXT	SEGMENT
tv366 = -476						; size = 4
tv285 = -472						; size = 4
tv377 = -468						; size = 4
tv283 = -464						; size = 4
tv405 = -460						; size = 4
tv281 = -456						; size = 4
tv448 = -452						; size = 4
tv87 = -448						; size = 4
tv92 = -444						; size = 4
tv301 = -440						; size = 4
_this$ = -436						; size = 4
$T219097 = -432						; size = 4
$T219082 = -428						; size = 4
$T219078 = -424						; size = 4
_elem$219072 = -420					; size = 8
$T219048 = -412						; size = 4
_elem$219042 = -408					; size = 8
$T219029 = -400						; size = 4
$T219017 = -396						; size = 4
$T219000 = -392						; size = 4
$T218995 = -388						; size = 4
$T218983 = -384						; size = 4
$T218982 = -380						; size = 4
$T218978 = -376						; size = 4
$T218969 = -372						; size = 4
$T218965 = -368						; size = 4
$T218942 = -364						; size = 28
$T218941 = -336						; size = 28
$T218940 = -308						; size = 28
$T218939 = -280						; size = 28
_strTempString$217636 = -252				; size = 28
_strTemp$217637 = -224					; size = 28
_strTemp$217633 = -196					; size = 28
_strOutBuf$217628 = -168				; size = 28
_strDesc$217630 = -140					; size = 28
_pUnitEntry$217629 = -112				; size = 4
_iI$217624 = -108					; size = 4
_playerName$217613 = -104				; size = 28
_cityName$217614 = -76					; size = 28
_pLog$217616 = -48					; size = 4
_strBaseString$217618 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eUnitAIType$ = 8					; size = 4
?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z PROC ; CvUnitProductionAI::LogPossibleBuilds, COMDAT
; _this$ = ecx

; 243  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 464				; 000001d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@LogPossibl

; 245  : 	{
; 246  : 		// Find the name of this civ and city
; 247  : 		CvString playerName = GET_PLAYER(m_pCity->getOwner()).getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T218965[ebp], ecx
	mov	edx, DWORD PTR $T218965[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218969[ebp], edx
	mov	ecx, DWORD PTR $T218969[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T218978[ebp], eax
	cmp	DWORD PTR $T218978[ebp], 0
	je	SHORT $LN31@LogPossibl
	mov	eax, DWORD PTR $T218978[ebp]
	mov	DWORD PTR tv301[ebp], eax
	jmp	SHORT $LN32@LogPossibl
$LN31@LogPossibl:
	mov	DWORD PTR tv301[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@LogPossibl:
	mov	ecx, DWORD PTR tv301[ebp]
	push	ecx
	lea	ecx, DWORD PTR _playerName$217613[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 248  : 		CvString cityName = m_pCity->getName();

	lea	edx, DWORD PTR _cityName$217614[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 249  : 
; 250  : 		// Open the log file
; 251  : 		FILogFile* pLog = LOGFILEMGR.GetLog(m_pCity->GetCityStrategyAI()->GetLogFileName(playerName, cityName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv92[ebp], eax
	lea	ecx, DWORD PTR _cityName$217614[ebp]
	push	ecx
	lea	edx, DWORD PTR _playerName$217613[ebp]
	push	edx
	lea	eax, DWORD PTR $T218939[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetLogFileName@CvCityStrategyAI@@QBE?AVCvString@@AAV2@0@Z ; CvCityStrategyAI::GetLogFileName
	mov	DWORD PTR tv87[ebp], eax
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T218982[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T218982[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T218983[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T218983[ebp]
	push	eax
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$217616[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T218939[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 252  : 
; 253  : 		// Get the leading info for this line
; 254  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$217618[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 255  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T218995[ebp], ecx
	mov	ecx, DWORD PTR $T218995[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	edx, DWORD PTR _strBaseString$217618[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 256  : 		strBaseString += playerName + ", " + cityName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	eax, DWORD PTR _playerName$217613[ebp]
	push	eax
	lea	ecx, DWORD PTR $T218940[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv448[ebp], eax
	mov	edx, DWORD PTR tv448[ebp]
	mov	DWORD PTR tv281[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	eax, DWORD PTR _cityName$217614[ebp]
	push	eax
	mov	ecx, DWORD PTR tv281[ebp]
	push	ecx
	lea	edx, DWORD PTR $T218941[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv405[ebp], eax
	mov	eax, DWORD PTR tv405[ebp]
	mov	DWORD PTR tv283[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR tv283[ebp]
	push	ecx
	lea	edx, DWORD PTR $T218942[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv377[ebp], eax
	mov	eax, DWORD PTR tv377[ebp]
	mov	DWORD PTR tv285[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR tv285[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBaseString$217618[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T218942[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T218941[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T218940[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 257  : 
; 258  : 
; 259  : 		// Dump out the weight of each buildable item
; 260  : 		for(int iI = 0; iI < m_Buildables.size(); iI++)

	mov	DWORD PTR _iI$217624[ebp], 0
	jmp	SHORT $LN5@LogPossibl
$LN4@LogPossibl:
	mov	edx, DWORD PTR _iI$217624[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$217624[ebp], edx
$LN5@LogPossibl:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+748]
	mov	DWORD PTR $T219000[ebp], ecx
	mov	edx, DWORD PTR _iI$217624[ebp]
	cmp	edx, DWORD PTR $T219000[ebp]
	jge	$LN3@LogPossibl

; 261  : 		{
; 262  : 			CvString strOutBuf = strBaseString;

	lea	eax, DWORD PTR _strBaseString$217618[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$217628[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 263  : 
; 264  : 			CvUnitEntry* pUnitEntry = GC.GetGameUnits()->GetEntry(m_Buildables.GetElement(iI));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+744]
	mov	eax, DWORD PTR _iI$217624[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T219017[ebp], ecx
	mov	edx, DWORD PTR $T219017[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameUnits@CvGlobals@@QBEPAVCvUnitXMLEntries@@XZ ; CvGlobals::GetGameUnits
	mov	ecx, eax
	call	?GetEntry@CvUnitXMLEntries@@QAEPAVCvUnitEntry@@H@Z ; CvUnitXMLEntries::GetEntry
	mov	DWORD PTR _pUnitEntry$217629[ebp], eax

; 265  : 
; 266  : 			CvString strDesc = (pUnitEntry != NULL)? pUnitEntry->GetDescription() : "Unknown Unit";

	cmp	DWORD PTR _pUnitEntry$217629[ebp], 0
	je	SHORT $LN9@LogPossibl
	mov	ecx, DWORD PTR _pUnitEntry$217629[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T219029[ebp], eax
	jmp	SHORT $LN10@LogPossibl
$LN9@LogPossibl:
	mov	DWORD PTR $T219029[ebp], OFFSET ??_C@_0N@EHKDMPBC@Unknown?5Unit?$AA@
$LN10@LogPossibl:
	cmp	DWORD PTR $T219029[ebp], 0
	je	SHORT $LN59@LogPossibl
	mov	ecx, DWORD PTR $T219029[ebp]
	mov	DWORD PTR tv366[ebp], ecx
	jmp	SHORT $LN60@LogPossibl
$LN59@LogPossibl:
	mov	DWORD PTR tv366[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN60@LogPossibl:
	mov	edx, DWORD PTR tv366[ebp]
	push	edx
	lea	ecx, DWORD PTR _strDesc$217630[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 267  : 			if(eUnitAIType == NO_UNITAI)

	cmp	DWORD PTR _eUnitAIType$[ebp], -1
	jne	$LN2@LogPossibl

; 268  : 			{
; 269  : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217633[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 270  : 				strTemp.Format("Unit, %s, %d", strDesc.GetCString(), m_Buildables.GetWeight(iI));

	mov	DWORD PTR _elem$219042[ebp], 0
	mov	DWORD PTR _elem$219042[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+744]
	mov	edx, DWORD PTR _iI$217624[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _elem$219042[ebp], eax
	mov	DWORD PTR _elem$219042[ebp+4], ecx
	mov	edx, DWORD PTR _elem$219042[ebp+4]
	mov	DWORD PTR $T219048[ebp], edx
	mov	eax, DWORD PTR $T219048[ebp]
	push	eax
	lea	ecx, DWORD PTR _strDesc$217630[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0N@OHOCDCHA@Unit?0?5?$CFs?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$217633[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 271  : 				strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$217633[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$217628[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 272  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _strTemp$217633[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 273  : 			else

	jmp	$LN1@LogPossibl
$LN2@LogPossibl:

; 274  : 			{
; 275  : 				CvString strTempString;

	lea	ecx, DWORD PTR _strTempString$217636[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 276  : 				getUnitAIString(strTempString, eUnitAIType);

	mov	eax, DWORD PTR _eUnitAIType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTempString$217636[ebp]
	push	ecx
	call	?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z ; getUnitAIString
	add	esp, 8

; 277  : 
; 278  : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217637[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 279  : 				strTemp.Format("Special request for unit of type: %s, %s, %d", strTempString.GetCString(), strDesc.GetCString(), m_Buildables.GetWeight(iI));

	mov	DWORD PTR _elem$219072[ebp], 0
	mov	DWORD PTR _elem$219072[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+744]
	mov	ecx, DWORD PTR _iI$217624[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$219072[ebp], edx
	mov	DWORD PTR _elem$219072[ebp+4], eax
	mov	ecx, DWORD PTR _elem$219072[ebp+4]
	mov	DWORD PTR $T219078[ebp], ecx
	lea	ecx, DWORD PTR _strDesc$217630[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T219082[ebp], eax
	mov	edx, DWORD PTR $T219078[ebp]
	push	edx
	mov	eax, DWORD PTR $T219082[ebp]
	push	eax
	lea	ecx, DWORD PTR _strTempString$217636[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CN@DHMOLJNG@Special?5request?5for?5unit?5of?5type@
	lea	ecx, DWORD PTR _strTemp$217637[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 280  : 				strOutBuf += strTemp;

	lea	edx, DWORD PTR _strTemp$217637[ebp]
	push	edx
	lea	ecx, DWORD PTR _strOutBuf$217628[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 281  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR _strTemp$217637[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR _strTempString$217636[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@LogPossibl:

; 282  : 
; 283  : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$217628[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T219097[ebp], eax
	mov	eax, DWORD PTR $T219097[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$217616[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$217616[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 284  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _strDesc$217630[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strOutBuf$217628[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN4@LogPossibl
$LN3@LogPossibl:

; 285  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strBaseString$217618[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cityName$217614[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _playerName$217613[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogPossibl:

; 286  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$0:
	lea	ecx, DWORD PTR _playerName$217613[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$1:
	lea	ecx, DWORD PTR _cityName$217614[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$2:
	lea	ecx, DWORD PTR $T218939[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$3:
	lea	ecx, DWORD PTR _strBaseString$217618[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$4:
	lea	ecx, DWORD PTR $T218940[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$5:
	lea	ecx, DWORD PTR $T218941[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$6:
	lea	ecx, DWORD PTR $T218942[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$7:
	lea	ecx, DWORD PTR _strOutBuf$217628[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$8:
	lea	ecx, DWORD PTR _strDesc$217630[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$9:
	lea	ecx, DWORD PTR _strTemp$217633[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$10:
	lea	ecx, DWORD PTR _strTempString$217636[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z$11:
	lea	ecx, DWORD PTR _strTemp$217637[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-468]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossibleBuilds@CvUnitProductionAI@@QAEXW4UnitAITypes@@@Z ENDP ; CvUnitProductionAI::LogPossibleBuilds
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ PROC		; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@H$0FK@$00@@QAE@XZ ENDP		; CvWeightedVector<int,90,1>::~CvWeightedVector<int,90,1>
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T219166 = -20						; size = 4
_pRet$219163 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 90			; 0000005aH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219166[ebp], edx
	cmp	DWORD PTR $T219166[ebp], 90		; 0000005aH
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T219166[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$219163[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T219166[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$219163[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 90			; 0000005aH
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$219163[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T219197 = -24						; size = 4
$T219196 = -20						; size = 4
_i$219189 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T219197[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T219196[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$219189[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$219189[ebp]
	add	eax, 1
	mov	DWORD PTR _i$219189[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$219189[ebp]
	cmp	ecx, DWORD PTR $T219197[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T219196[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T219196[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::~FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T219210 = -8						; size = 4
$T219209 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+732], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T219210[ebp], ecx
	cmp	DWORD PTR $T219210[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T219210[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T219210[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T219210[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T219209[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::push_back
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T219304 = -44						; size = 4
$T219303 = -40						; size = 4
_i$219296 = -36						; size = 4
$T219282 = -32						; size = 4
$T219275 = -28						; size = 4
_pRet$219272 = -24					; size = 4
$T219265 = -20						; size = 4
$T219264 = -16						; size = 4
_i$217707 = -12						; size = 4
_uiNewSize$217699 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$217699[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$217699[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$217699[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T219275[ebp], ecx
	cmp	DWORD PTR $T219275[ebp], 90		; 0000005aH
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T219275[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$219272[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T219275[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$219272[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 90			; 0000005aH
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$219272[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$217707[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$217707[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217707[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$217707[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$217707[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T219265[ebp], ecx
	cmp	DWORD PTR $T219265[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$217707[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T219282[ebp], edx
	mov	eax, DWORD PTR $T219265[ebp]
	mov	ecx, DWORD PTR $T219282[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T219265[ebp]
	mov	ecx, DWORD PTR $T219282[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T219265[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T219264[ebp], ecx
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219304[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T219303[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize
	mov	DWORD PTR _i$219296[ebp], 0
	jmp	SHORT $LN29@GrowSize
$LN28@GrowSize:
	mov	edx, DWORD PTR _i$219296[ebp]
	add	edx, 1
	mov	DWORD PTR _i$219296[ebp], edx
$LN29@GrowSize:
	mov	eax, DWORD PTR _i$219296[ebp]
	cmp	eax, DWORD PTR $T219304[ebp]
	jae	SHORT $LN24@GrowSize
	jmp	SHORT $LN28@GrowSize
$LN24@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T219303[ebp], ecx
	je	SHORT $LN25@GrowSize
	mov	edx, DWORD PTR $T219303[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+732], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$0FK@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,90,1>::WeightedElement,90,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FK@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,90,1>::WeightedElement,1>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstringa.inl
_TEXT	ENDS
;	COMDAT ??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_str$ = 8						; size = 4
??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z PROC ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>, COMDAT
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	assert( nLENGTH > 0 );
; 60   : 	m_kStringData.m_bLocked = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+8], ax

; 61   : 	m_kStringData.m_bFixed = 1;

	mov	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+10], dx

; 62   : 	m_kStringData.m_iAllocLength = nLENGTH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 64			; 00000040H

; 63   : 	m_kStringData.m_iDataLength = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 64   : 	m_szStringBuffer[ 0 ] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+12], 0

; 65   : 	str.SetFixedBuffer( &m_kStringData );

	cmp	DWORD PTR _this$[ebp], 0
	jne	SHORT $LN3@FStringAFi
	jmp	SHORT $LN1@FStringAFi
$LN3@FStringAFi:
	mov	ecx, DWORD PTR _str$[ebp]
	call	?Release@FStringA@@QAEXXZ		; FStringA::Release
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _str$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@FStringAFi:

; 66   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$FStringAFixedBuffer@$0EA@@FStringA@@QAE@AAV1@@Z ENDP ; FStringA::FStringAFixedBuffer<64>::FStringAFixedBuffer<64>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z
_TEXT	SEGMENT
$T219465 = -128						; size = 4
__Mid$217796 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$217796[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$217796[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$217796[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$217796[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$217796[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$217796[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$217796[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T219465[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T219465[ebp]
	sub	eax, 8
	mov	DWORD PTR $T219465[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T219465[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T219465[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T219465[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,90,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z
_TEXT	SEGMENT
$T219708 = -124						; size = 4
__Tmp$219706 = -120					; size = 8
$T219688 = -112						; size = 4
$T219687 = -108						; size = 4
__Tmp$219685 = -104					; size = 8
$T219667 = -96						; size = 4
__Tmp$219665 = -92					; size = 8
$T219647 = -84						; size = 4
$T219646 = -80						; size = 4
__Tmp$219644 = -76					; size = 8
$T219626 = -68						; size = 4
$T219625 = -64						; size = 4
__Tmp$219623 = -60					; size = 8
$T219602 = -52						; size = 4
$T219601 = -48						; size = 4
__Tmp$219599 = -44					; size = 8
$T219575 = -36						; size = 4
__Tmp$219573 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T219575[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T219575[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T219575[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$219573[ebp], edx
	mov	eax, DWORD PTR $T219575[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$219573[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T219575[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$219573[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$219573[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T219602[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T219601[ebp], edx
	mov	eax, DWORD PTR $T219601[ebp]
	cmp	eax, DWORD PTR $T219602[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T219601[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$219599[ebp], edx
	mov	eax, DWORD PTR $T219601[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$219599[ebp+4], ecx
	mov	edx, DWORD PTR $T219602[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T219601[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T219602[ebp]
	mov	ecx, DWORD PTR __Tmp$219599[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$219599[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T219626[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T219625[ebp], eax
	mov	ecx, DWORD PTR $T219625[ebp]
	cmp	ecx, DWORD PTR $T219626[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T219625[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$219623[ebp], eax
	mov	ecx, DWORD PTR $T219625[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$219623[ebp+4], edx
	mov	eax, DWORD PTR $T219626[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T219625[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T219626[ebp]
	mov	edx, DWORD PTR __Tmp$219623[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$219623[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T219647[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T219646[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T219646[ebp]
	cmp	eax, DWORD PTR $T219647[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T219646[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$219644[ebp], edx
	mov	eax, DWORD PTR $T219646[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$219644[ebp+4], ecx
	mov	edx, DWORD PTR $T219647[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T219646[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T219647[ebp]
	mov	ecx, DWORD PTR __Tmp$219644[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$219644[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T219667[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T219667[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$219665[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$219665[ebp+4], eax
	mov	ecx, DWORD PTR $T219667[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T219667[ebp]
	mov	eax, DWORD PTR __Tmp$219665[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$219665[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T219688[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T219687[ebp], ecx
	mov	edx, DWORD PTR $T219687[ebp]
	cmp	edx, DWORD PTR $T219688[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T219687[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$219685[ebp], ecx
	mov	edx, DWORD PTR $T219687[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$219685[ebp+4], eax
	mov	ecx, DWORD PTR $T219688[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T219687[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T219688[ebp]
	mov	eax, DWORD PTR __Tmp$219685[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$219685[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T219708[ebp], eax
	mov	ecx, DWORD PTR $T219708[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T219708[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$219706[ebp], eax
	mov	ecx, DWORD PTR $T219708[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$219706[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T219708[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$219706[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$219706[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,90,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
__Step$217940 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$217940[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$217940[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$217940[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$217940[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$217940[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$217940[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$217940[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$217940[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$217940[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,90,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z
_TEXT	SEGMENT
$T220021 = -20						; size = 4
$T220020 = -16						; size = 4
__Hole$217958 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$217958[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$217958[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$217958[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$217958[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$217958[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T220021[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T220020[ebp], esp
	mov	edx, DWORD PTR $T220020[ebp]
	mov	eax, DWORD PTR $T220021[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T220020[ebp]
	mov	eax, DWORD PTR $T220021[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$217958[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
$T220091 = -52						; size = 4
$T220090 = -48						; size = 4
$T220074 = -42						; size = 1
$T220073 = -41						; size = 1
$T220072 = -40						; size = 4
$T220071 = -36						; size = 4
$T220070 = -32						; size = 4
__Cat$220080 = -24					; size = 1
$T220078 = -23						; size = 1
$T220077 = -22						; size = 1
$T220076 = -21						; size = 1
__First1$217999 = -20					; size = 4
__Val$217989 = -16					; size = 8
__Next1$217988 = -8					; size = 4
__Next$217984 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$217984[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$217984[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$217984[ebp], edx
	mov	eax, DWORD PTR __Next$217984[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$217984[ebp]
	mov	DWORD PTR __Next1$217988[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$217984[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$217989[ebp], eax
	mov	ecx, DWORD PTR __Next$217984[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$217989[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$217989[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$217988[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$217988[ebp], ecx
	mov	edx, DWORD PTR __Next1$217988[ebp]
	mov	DWORD PTR $T220091[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220090[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220076[ebp], cl
	mov	dl, BYTE PTR __Cat$220080[ebp]
	mov	BYTE PTR $T220077[ebp], dl
	mov	al, BYTE PTR $T220076[ebp]
	mov	BYTE PTR $T220074[ebp], al
	mov	cl, BYTE PTR $T220078[ebp]
	mov	BYTE PTR $T220073[ebp], cl
	mov	edx, DWORD PTR $T220091[ebp]
	mov	DWORD PTR $T220072[ebp], edx
	mov	eax, DWORD PTR __Next$217984[ebp]
	mov	DWORD PTR $T220071[ebp], eax
	mov	ecx, DWORD PTR $T220090[ebp]
	mov	DWORD PTR $T220070[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T220070[ebp]
	cmp	edx, DWORD PTR $T220071[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T220071[ebp]
	sub	eax, 8
	mov	DWORD PTR $T220071[ebp], eax
	mov	ecx, DWORD PTR $T220072[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T220072[ebp], ecx
	mov	edx, DWORD PTR $T220071[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T220072[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$217989[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$217989[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$217988[ebp]
	mov	DWORD PTR __First1$217999[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$217999[ebp]
	mov	DWORD PTR __Next1$217988[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$217999[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$217999[ebp], edx
	mov	eax, DWORD PTR __First1$217999[ebp]
	mov	ecx, DWORD PTR __Val$217989[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$217999[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$217988[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$217988[ebp]
	mov	eax, DWORD PTR __Val$217989[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$217989[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
__Tmp$220159 = -24					; size = 8
__Tmp$220137 = -16					; size = 8
__Tmp$220115 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$220115[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$220115[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$220115[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$220115[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$220137[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$220137[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$220137[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$220137[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$220159[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$220159[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$220159[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$220159[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,90,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z
_TEXT	SEGMENT
$T220186 = -32						; size = 4
$T220185 = -28						; size = 8
__Idx$220181 = -20					; size = 4
$T220172 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T220185[ebp]
	mov	DWORD PTR $T220172[ebp], edx
	mov	eax, DWORD PTR $T220172[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T220172[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T220186[ebp], ecx
	mov	eax, DWORD PTR $T220186[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$220181[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T220186[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$220181[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T220186[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$220181[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T220185[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$220181[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T220186[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$220181[ebp]
	mov	DWORD PTR $T220186[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T220186[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T220185[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T220185[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z
_TEXT	SEGMENT
$T220232 = -60						; size = 8
$T220203 = -20						; size = 4
$T220197 = -12						; size = 4
$T220196 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T220197[ebp], eax
	lea	ecx, DWORD PTR $T220232[ebp]
	mov	DWORD PTR $T220196[ebp], ecx
	mov	edx, DWORD PTR $T220196[ebp]
	mov	eax, DWORD PTR $T220197[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T220196[ebp]
	mov	eax, DWORD PTR $T220197[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T220203[ebp], esp
	mov	eax, DWORD PTR $T220203[ebp]
	mov	ecx, DWORD PTR $T220232[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T220203[ebp]
	mov	eax, DWORD PTR $T220232[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,90,1>::WeightedElement *,int,CvWeightedVector<int,90,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FK@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,90,1>::WeightedElement *,CvWeightedVector<int,90,1>::WeightedElement>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstringa.inl
_TEXT	ENDS
;	COMDAT ??1FStringA@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1FStringA@@QAE@XZ PROC				; FStringA::~FStringA, COMDAT
; _this$ = ecx

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 	Release();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Release@FStringA@@QAEXXZ		; FStringA::Release

; 153  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1FStringA@@QAE@XZ ENDP				; FStringA::~FStringA
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ?Release@FStringA@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T220271 = -12						; size = 4
$T220266 = -8						; size = 4
$T220263 = -4						; size = 4
?Release@FStringA@@QAEXXZ PROC				; FStringA::Release, COMDAT
; _this$ = ecx

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1097 : 	Release( GetData() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T220266[ebp], ecx
	je	SHORT $LN6@Release
	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	cmp	DWORD PTR $T220266[ebp], eax
	je	SHORT $LN6@Release
	mov	edx, DWORD PTR $T220266[ebp]
	movzx	eax, WORD PTR [edx+10]
	test	eax, eax
	jne	SHORT $LN6@Release
	mov	ecx, DWORD PTR $T220266[ebp]
	mov	DWORD PTR $T220263[ebp], ecx
	mov	edx, DWORD PTR $T220263[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@Release:

; 1098 : 	m_pszString = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1099 : 	Init();

	call	?FStringA_GetStringInitData@@YAPAUFStringAData@FStringA@@XZ ; FStringA_GetStringInitData
	mov	DWORD PTR $T220271[ebp], eax
	mov	ecx, DWORD PTR $T220271[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 1100 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Release@FStringA@@QAEXXZ ENDP				; FStringA::Release
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T220306 = -2092					; size = 4
$T220305 = -2088					; size = 4
$T220304 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220304[ebp], eax
	mov	ecx, DWORD PTR $T220304[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220305[ebp], eax
	mov	eax, DWORD PTR $T220305[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220306[ebp], eax
	mov	ecx, DWORD PTR $T220306[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
END
