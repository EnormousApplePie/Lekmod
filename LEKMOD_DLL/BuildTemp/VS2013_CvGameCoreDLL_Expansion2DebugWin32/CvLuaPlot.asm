; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\Lua\CvLuaPlot.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@JKDJOJEA@SetCityPurchaseID?$AA@	; `string'
PUBLIC	?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetCityPurchaseID
PUBLIC	??_C@_0BC@LPDCGCFO@GetCityPurchaseID?$AA@	; `string'
PUBLIC	?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityPurchaseID
PUBLIC	??_C@_0BD@NANOFFBN@HasWrittenArtifact?$AA@	; `string'
PUBLIC	?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasWrittenArtifact
PUBLIC	??_C@_0BL@OCKBDMDN@GetArchaeologyArtifactWork?$AA@ ; `string'
PUBLIC	?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactWork
PUBLIC	??_C@_0BO@OMCDNEIN@GetArchaeologyArtifactPlayer2?$AA@ ; `string'
PUBLIC	?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer2
PUBLIC	??_C@_0BO@MHAOIHEO@GetArchaeologyArtifactPlayer1?$AA@ ; `string'
PUBLIC	?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer1
PUBLIC	??_C@_0BK@EMCHHPLM@GetArchaeologyArtifactEra?$AA@ ; `string'
PUBLIC	?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactEra
PUBLIC	??_C@_0BL@ENHELHEO@GetArchaeologyArtifactType?$AA@ ; `string'
PUBLIC	?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactType
PUBLIC	??_C@_0BG@PCIABHEK@IsBuildRemovesFeature?$AA@	; `string'
PUBLIC	?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBuildRemovesFeature
PUBLIC	??_C@_0CB@KPLFICMP@IsResourceConnectedByImprovement@ ; `string'
PUBLIC	?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsResourceConnectedByImprovement
PUBLIC	??_C@_0BE@GKMJANIP@SetContinentArtType?$AA@	; `string'
PUBLIC	?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetContinentArtType
PUBLIC	??_C@_0BE@MEOCENPD@GetContinentArtType?$AA@	; `string'
PUBLIC	?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetContinentArtType
PUBLIC	??_C@_0L@GKHDLKJE@CanSeePlot?$AA@		; `string'
PUBLIC	?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCanSeePlot
PUBLIC	??_C@_0BG@NEIGEDBJ@IsImprovementPillaged?$AA@	; `string'
PUBLIC	?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsImprovementPillaged
PUBLIC	??_C@_0BG@BKOPMAI@GetActiveFogOfWarMode?$AA@	; `string'
PUBLIC	?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetActiveFogOfWarMode
PUBLIC	??_C@_0O@PGOPIEFE@SetScriptData?$AA@		; `string'
PUBLIC	?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetScriptData
PUBLIC	??_C@_0O@IJPBDHCD@GetScriptData?$AA@		; `string'
PUBLIC	?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetScriptData
PUBLIC	??_C@_0N@KMFKPML@GetLayerUnit?$AA@		; `string'
PUBLIC	?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetLayerUnit
PUBLIC	??_C@_0BB@CJPGAEMO@GetNumLayerUnits?$AA@	; `string'
PUBLIC	?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumLayerUnits
PUBLIC	??_C@_07NHOHELCB@GetUnit?$AA@			; `string'
PUBLIC	?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetUnit
PUBLIC	??_C@_0M@GNPEBAGL@GetNumUnits?$AA@		; `string'
PUBLIC	?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetNumUnits
PUBLIC	??_C@_0BP@LBNFAPK@ChangeInvisibleVisibilityCount?$AA@ ; `string'
PUBLIC	?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeInvisibleVisibilityCount
PUBLIC	??_C@_0BD@INIFKIEI@IsInvisibleVisible?$AA@	; `string'
PUBLIC	?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsInvisibleVisible
PUBLIC	??_C@_0BM@FGJPJMNO@GetInvisibleVisibilityCount?$AA@ ; `string'
PUBLIC	?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInvisibleVisibilityCount
PUBLIC	??_C@_0BE@JOFNMHNE@ChangeBuildProgress?$AA@	; `string'
PUBLIC	?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeBuildProgress
PUBLIC	??_C@_0BB@JNKOGOND@GetBuildProgress?$AA@	; `string'
PUBLIC	?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildProgress
PUBLIC	??_C@_0BF@IFAHMPDF@GetRevealedRouteType?$AA@	; `string'
PUBLIC	?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedRouteType
PUBLIC	??_C@_0BL@PNNIAODD@GetRevealedImprovementType?$AA@ ; `string'
PUBLIC	?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedImprovementType
PUBLIC	??_C@_0M@JIOPKDAN@SetRevealed?$AA@		; `string'
PUBLIC	?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetRevealed
PUBLIC	??_C@_0L@KNACFKBL@IsRevealed?$AA@		; `string'
PUBLIC	?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRevealed
PUBLIC	??_C@_0BG@BDOILNLO@IsRiverCrossingToPlot?$AA@	; `string'
PUBLIC	?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingToPlot
PUBLIC	??_C@_0BA@MJKALLIG@IsRiverCrossing?$AA@		; `string'
PUBLIC	?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossing
PUBLIC	??_C@_0BA@GEFNGHGP@GetRevealedTeam?$AA@		; `string'
PUBLIC	?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedTeam
PUBLIC	??_C@_0BB@OFCBENIO@GetRevealedOwner?$AA@	; `string'
PUBLIC	?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedOwner
PUBLIC	??_C@_0BG@CELPDLDF@ChangeVisibilityCount?$AA@	; `string'
PUBLIC	?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeVisibilityCount
PUBLIC	??_C@_0BD@MEPELFEN@GetVisibilityCount?$AA@	; `string'
PUBLIC	?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetVisibilityCount
PUBLIC	??_C@_0BD@FCCJINHM@IsPlayerCityRadius?$AA@	; `string'
PUBLIC	?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPlayerCityRadius
PUBLIC	??_C@_0BJ@FHECNEHC@GetPlayerCityRadiusCount?$AA@ ; `string'
PUBLIC	?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlayerCityRadiusCount
PUBLIC	??_C@_0BE@MJJBFBHH@IsBestAdjacentFound?$AA@	; `string'
PUBLIC	?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBestAdjacentFound
PUBLIC	??_C@_0O@GFNIBAIO@GetFoundValue?$AA@		; `string'
PUBLIC	?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetFoundValue
PUBLIC	??_C@_0BB@ODLGAIAC@CountNumAirUnits?$AA@	; `string'
PUBLIC	?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCountNumAirUnits
PUBLIC	??_C@_0BC@FCJPHHA@GetYieldWithBuild?$AA@	; `string'
PUBLIC	?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetYieldWithBuild
PUBLIC	??_C@_08EOHKPHAI@HasYield?$AA@			; `string'
PUBLIC	?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lHasYield
PUBLIC	??_C@_0P@CENIPKEL@CalculateYield?$AA@		; `string'
PUBLIC	?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCalculateYield
PUBLIC	??_C@_0CA@FIAOIPPH@CalculateImprovementYieldChange?$AA@ ; `string'
PUBLIC	?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateImprovementYieldChange
PUBLIC	??_C@_0BO@EHFPFGPL@CalculateTotalBestNatureYield?$AA@ ; `string'
PUBLIC	?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateTotalBestNatureYield
PUBLIC	??_C@_0BJ@OAMDIALM@CalculateBestNatureYield?$AA@ ; `string'
PUBLIC	?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateBestNatureYield
PUBLIC	??_C@_0BF@CBKOLKOI@CalculateNatureYield?$AA@	; `string'
PUBLIC	?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateNatureYield
PUBLIC	??_C@_08NACOAIKN@GetYield?$AA@			; `string'
PUBLIC	?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetYield
PUBLIC	??_C@_0BG@PHPNMIIM@GetRiverCrossingCount?$AA@	; `string'
PUBLIC	?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverCrossingCount
PUBLIC	??_C@_0O@FJEFAJPI@GetReconCount?$AA@		; `string'
PUBLIC	?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetReconCount
PUBLIC	??_C@_0BH@OOJOMMJK@GetWorkingCityOverride?$AA@	; `string'
PUBLIC	?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetWorkingCityOverride
PUBLIC	??_C@_0P@FJAEMPGB@GetWorkingCity?$AA@		; `string'
PUBLIC	?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetWorkingCity
PUBLIC	??_C@_0M@PCNDGHAN@GetPlotCity?$AA@		; `string'
PUBLIC	?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetPlotCity
PUBLIC	??_C@_0BA@BOKCMBNI@IsRoutePillaged?$AA@		; `string'
PUBLIC	?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoutePillaged
PUBLIC	??_C@_0N@LHILEECB@SetRouteType?$AA@		; `string'
PUBLIC	?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetRouteType
PUBLIC	??_C@_0N@MDDFIIGN@GetRouteType?$AA@		; `string'
PUBLIC	?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetRouteType
PUBLIC	??_C@_0BH@HIMINBGH@SetImprovementPillaged?$AA@	; `string'
PUBLIC	?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementPillaged
PUBLIC	??_C@_0BD@CDMJPHEA@SetImprovementType?$AA@	; `string'
PUBLIC	?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementType
PUBLIC	??_C@_0BD@NJODMBKI@GetImprovementType?$AA@	; `string'
PUBLIC	?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementType
PUBLIC	??_C@_0BC@KPBOMALO@ChangeNumResource?$AA@	; `string'
PUBLIC	?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeNumResource
PUBLIC	??_C@_0P@PFFHMNLP@SetNumResource?$AA@		; `string'
PUBLIC	?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetNumResource
PUBLIC	??_C@_0P@DLEJDHJD@GetNumResource?$AA@		; `string'
PUBLIC	?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetNumResource
PUBLIC	??_C@_0BA@MPFNFEGO@SetResourceType?$AA@		; `string'
PUBLIC	?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetResourceType
PUBLIC	??_C@_0BL@OCHONID@GetNonObsoleteResourceType?$AA@ ; `string'
PUBLIC	?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNonObsoleteResourceType
PUBLIC	??_C@_0BA@PNELCGHH@GetResourceType?$AA@		; `string'
PUBLIC	?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetResourceType
PUBLIC	??_C@_0M@JOGKFIAC@SetPlotType?$AA@		; `string'
PUBLIC	?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetPlotType
PUBLIC	??_C@_0L@LNALPAOM@IsMountain?$AA@		; `string'
PUBLIC	?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsMountain
PUBLIC	??_C@_0O@DNIIDOJH@IsRoughGround?$AA@		; `string'
PUBLIC	?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRoughGround
PUBLIC	??_C@_0N@DKDGHAGP@IsOpenGround?$AA@		; `string'
PUBLIC	?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsOpenGround
PUBLIC	??_C@_07DCIJPOBB@IsHills?$AA@			; `string'
PUBLIC	?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsHills
PUBLIC	??_C@_0M@CIOEIJGM@IsFlatlands?$AA@		; `string'
PUBLIC	?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFlatlands
PUBLIC	??_C@_0M@JBHEIOIB@GetPlotType?$AA@		; `string'
PUBLIC	?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetPlotType
PUBLIC	??_C@_08OPBFNKOM@SetOwner?$AA@			; `string'
PUBLIC	?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetOwner
PUBLIC	??_C@_08BODJMJJB@GetOwner?$AA@			; `string'
PUBLIC	?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetOwner
PUBLIC	??_C@_0BL@FNJICPCN@IsPotentialCityWorkForArea?$AA@ ; `string'
PUBLIC	?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWorkForArea
PUBLIC	??_C@_0BE@ELJLKDMB@IsPotentialCityWork?$AA@	; `string'
PUBLIC	?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWork
PUBLIC	??_C@_0BI@MCMIAAIB@GetRiverSWFlowDirection?$AA@	; `string'
PUBLIC	?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSWFlowDirection
PUBLIC	??_C@_0BI@COCMCOFP@GetRiverSEFlowDirection?$AA@	; `string'
PUBLIC	?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSEFlowDirection
PUBLIC	??_C@_0BH@KPEJPCF@GetRiverEFlowDirection?$AA@	; `string'
PUBLIC	?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverEFlowDirection
PUBLIC	??_C@_0N@PMHPDLKG@SetNWOfRiver?$AA@		; `string'
PUBLIC	?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetNWOfRiver
PUBLIC	??_C@_0M@IJOGDAO@IsNWOfRiver?$AA@		; `string'
PUBLIC	?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsNWOfRiver
PUBLIC	??_C@_0M@NHCDHKOK@SetWOfRiver?$AA@		; `string'
PUBLIC	?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetWOfRiver
PUBLIC	??_C@_0L@OCMOIDPM@IsWOfRiver?$AA@		; `string'
PUBLIC	?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsWOfRiver
PUBLIC	??_C@_0N@HOEJFBFB@SetNEOfRiver?$AA@		; `string'
PUBLIC	?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetNEOfRiver
PUBLIC	??_C@_0M@IKKIAJPJ@IsNEOfRiver?$AA@		; `string'
PUBLIC	?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsNEOfRiver
PUBLIC	??_C@_0BA@GNONGEOP@SetStartingPlot?$AA@		; `string'
PUBLIC	?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetStartingPlot
PUBLIC	??_C@_0P@BPOJGNHB@IsStartingPlot?$AA@		; `string'
PUBLIC	?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsStartingPlot
PUBLIC	??_C@_0N@OOBJPEOH@IsCityRadius?$AA@		; `string'
PUBLIC	?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsCityRadius
PUBLIC	??_C@_0BD@FMKHJCLK@GetCityRadiusCount?$AA@	; `string'
PUBLIC	?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityRadiusCount
PUBLIC	??_C@_0BG@BMLACKEG@ChangeUpgradeProgress?$AA@	; `string'
PUBLIC	?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeUpgradeProgress
PUBLIC	??_C@_0BD@GNBJCNG@SetUpgradeProgress?$AA@	; `string'
PUBLIC	?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetUpgradeProgress
PUBLIC	??_C@_0BD@BBCMJJNG@GetUpgradeTimeLeft?$AA@	; `string'
PUBLIC	?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeTimeLeft
PUBLIC	??_C@_0BD@PMPLKEDO@GetUpgradeProgress?$AA@	; `string'
PUBLIC	?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeProgress
PUBLIC	??_C@_0BK@GBKBPNDO@ChangeImprovementDuration?$AA@ ; `string'
PUBLIC	?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeImprovementDuration
PUBLIC	??_C@_0BH@JGCIBAKO@SetImprovementDuration?$AA@	; `string'
PUBLIC	?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementDuration
PUBLIC	??_C@_0BH@JHAGDHHB@GetImprovementDuration?$AA@	; `string'
PUBLIC	?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementDuration
PUBLIC	??_C@_0BI@OJDEJCCM@ChangeOwnershipDuration?$AA@	; `string'
PUBLIC	?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeOwnershipDuration
PUBLIC	??_C@_0BF@FNMPDJOJ@SetOwnershipDuration?$AA@	; `string'
PUBLIC	?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetOwnershipDuration
PUBLIC	??_C@_0BB@KOAOKKPA@IsOwnershipScore?$AA@	; `string'
PUBLIC	?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOwnershipScore
PUBLIC	??_C@_0BF@ENCCPLO@GetOwnershipDuration?$AA@	; `string'
PUBLIC	?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetOwnershipDuration
PUBLIC	??_C@_0BC@PNINJHCK@GetFeatureVariety?$AA@	; `string'
PUBLIC	?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureVariety
PUBLIC	??_C@_07JOBGLCOF@SetArea?$AA@			; `string'
PUBLIC	?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetArea
PUBLIC	??_C@_07GGOHINDE@GetArea?$AA@			; `string'
PUBLIC	?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetArea
PUBLIC	??_C@_09CNIEIFHO@WaterArea?$AA@			; `string'
PUBLIC	?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lWaterArea
PUBLIC	??_C@_04KPICECCB@Area?$AA@			; `string'
PUBLIC	?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lArea
PUBLIC	??_C@_0M@KCMGIFE@GetLatitude?$AA@		; `string'
PUBLIC	?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetLatitude
PUBLIC	??_C@_0N@MPDLKONJ@GetPlotIndex?$AA@		; `string'
PUBLIC	?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetPlotIndex
PUBLIC	??_C@_02DKLFHNOI@At?$AA@			; `string'
PUBLIC	?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lAt
PUBLIC	??_C@_04OHHHKNBL@GetY?$AA@			; `string'
PUBLIC	?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lGetY
PUBLIC	??_C@_04POGMJMFK@GetX?$AA@			; `string'
PUBLIC	?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lGetX
PUBLIC	??_C@_0N@MALFMDGK@IsImpassable?$AA@		; `string'
PUBLIC	?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsImpassable
PUBLIC	??_C@_0BH@IFEGDFCC@IsValidDomainForAction?$AA@	; `string'
PUBLIC	?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForAction
PUBLIC	??_C@_0BJ@CLNJIBGO@IsValidDomainForLocation?$AA@ ; `string'
PUBLIC	?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForLocation
PUBLIC	??_C@_0N@CIBMJEHN@IsTradeRoute?$AA@		; `string'
PUBLIC	?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsTradeRoute
PUBLIC	??_C@_07DMDIHFEG@IsRoute?$AA@			; `string'
PUBLIC	?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRoute
PUBLIC	??_C@_0L@MOBAIMGP@IsFighting?$AA@		; `string'
PUBLIC	?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFighting
PUBLIC	??_C@_0BK@MEHFJEJD@GetNumFriendlyUnitsOfType?$AA@ ; `string'
PUBLIC	?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumFriendlyUnitsOfType
PUBLIC	??_C@_0BD@LCFOEEGJ@IsVisibleOtherUnit?$AA@	; `string'
PUBLIC	?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleOtherUnit
PUBLIC	??_C@_0BD@FOLPLHDK@IsVisibleEnemyUnit?$AA@	; `string'
PUBLIC	?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyUnit
PUBLIC	??_C@_0CF@KKFDFPEO@GetNumVisiblePotentialEnemyDefen@ ; `string'
PUBLIC	?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders
PUBLIC	??_C@_0BM@GIKOKOLI@GetNumVisibleEnemyDefenders?$AA@ ; `string'
PUBLIC	?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisibleEnemyDefenders
PUBLIC	??_C@_0BA@GNAHEKAB@GetNumDefenders?$AA@		; `string'
PUBLIC	?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumDefenders
PUBLIC	??_C@_0BH@KJEJGOKA@IsVisibleEnemyDefender?$AA@	; `string'
PUBLIC	?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyDefender
PUBLIC	??_C@_06BJOJODJC@IsUnit?$AA@			; `string'
PUBLIC	?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsUnit
PUBLIC	??_C@_0O@GHFLFPIL@IsBeingWorked?$AA@		; `string'
PUBLIC	?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsBeingWorked
PUBLIC	??_C@_0M@ICNFBAB@IsEnemyCity?$AA@		; `string'
PUBLIC	?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsEnemyCity
PUBLIC	??_C@_0P@JPKGCGMM@IsFriendlyCity?$AA@		; `string'
PUBLIC	?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFriendlyCity
PUBLIC	??_C@_06MKMOPHGH@IsCity?$AA@			; `string'
PUBLIC	?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsCity
PUBLIC	??_C@_0BE@IMNKPHIO@IsFriendlyTerritory?$AA@	; `string'
PUBLIC	?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFriendlyTerritory
PUBLIC	??_C@_0BA@HAPEMDMB@IsRevealedGoody?$AA@		; `string'
PUBLIC	?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedGoody
PUBLIC	??_C@_07KKNGKPLI@IsGoody?$AA@			; `string'
PUBLIC	?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsGoody
PUBLIC	??_C@_0M@LKMCGBMH@RemoveGoody?$AA@		; `string'
PUBLIC	?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lRemoveGoody
PUBLIC	??_C@_0BG@DBMNPJAN@IsAdjacentNonrevealed?$AA@	; `string'
PUBLIC	?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonrevealed
PUBLIC	??_C@_0BD@OBOIAPPP@IsAdjacentRevealed?$AA@	; `string'
PUBLIC	?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentRevealed
PUBLIC	??_C@_0BF@CNMKPADN@IsAdjacentNonvisible?$AA@	; `string'
PUBLIC	?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonvisible
PUBLIC	??_C@_0BC@GICKPFNI@IsAdjacentVisible?$AA@	; `string'
PUBLIC	?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentVisible
PUBLIC	??_C@_0BJ@FMJJGAJM@IsVisibleToWatchingHuman?$AA@ ; `string'
PUBLIC	?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleToWatchingHuman
PUBLIC	??_C@_0BA@CFACHEEE@IsActiveVisible?$AA@		; `string'
PUBLIC	?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsActiveVisible
PUBLIC	??_C@_09OLGPEPPJ@IsVisible?$AA@			; `string'
PUBLIC	?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsVisible
PUBLIC	??_C@_0BB@HNCHANHC@HasBarbarianCamp?$AA@	; `string'
PUBLIC	?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasBarbarianCamp
PUBLIC	??_C@_0BE@EPJKJJAH@IsRevealedBarbarian?$AA@	; `string'
PUBLIC	?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedBarbarian
PUBLIC	??_C@_0M@NJNEDJLP@IsBarbarian?$AA@		; `string'
PUBLIC	?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsBarbarian
PUBLIC	??_C@_07FAAHJANI@IsOwned?$AA@			; `string'
PUBLIC	?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsOwned
PUBLIC	??_C@_0P@CLEIAJCJ@IsAdjacentTeam?$AA@		; `string'
PUBLIC	?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsAdjacentTeam
PUBLIC	??_C@_0BB@GCLEKLKL@IsAdjacentPlayer?$AA@	; `string'
PUBLIC	?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentPlayer
PUBLIC	??_C@_0BA@GGEJAJJC@IsAdjacentOwned?$AA@		; `string'
PUBLIC	?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentOwned
PUBLIC	??_C@_0BI@EBOAMIEM@ChangeExtraMovePathCost?$AA@	; `string'
PUBLIC	?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeExtraMovePathCost
PUBLIC	??_C@_0BF@KMAGHFNO@GetExtraMovePathCost?$AA@	; `string'
PUBLIC	?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetExtraMovePathCost
PUBLIC	??_C@_0N@GOFKPDCB@MovementCost?$AA@		; `string'
PUBLIC	?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lMovementCost
PUBLIC	??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@		; `string'
PUBLIC	?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lDefenseModifier
PUBLIC	??_C@_0N@GAHBCOIE@GetUnitPower?$AA@		; `string'
PUBLIC	?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetUnitPower
PUBLIC	??_C@_0BA@LEIHGKM@GetSelectedUnit?$AA@		; `string'
PUBLIC	?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetSelectedUnit
PUBLIC	??_C@_0BA@NNICPDNO@GetBestDefender?$AA@		; `string'
PUBLIC	?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBestDefender
PUBLIC	??_C@_0P@FHMAACMJ@GetFeatureFood?$AA@		; `string'
PUBLIC	?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetFeatureFood
PUBLIC	??_C@_0BF@FDDHIDF@GetFeatureProduction?$AA@	; `string'
PUBLIC	?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureProduction
PUBLIC	??_C@_0BD@MBBBIJOB@GetBuildTurnsTotal?$AA@	; `string'
PUBLIC	?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsTotal
PUBLIC	??_C@_0BC@CDKKMKGA@GetBuildTurnsLeft?$AA@	; `string'
PUBLIC	?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsLeft
PUBLIC	??_C@_0N@CNOLIDLO@GetBuildTime?$AA@		; `string'
PUBLIC	?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetBuildTime
PUBLIC	??_C@_08EMPBKDLI@CanBuild?$AA@			; `string'
PUBLIC	?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCanBuild
PUBLIC	??_C@_0BD@PCLEPEFH@CanHaveImprovement?$AA@	; `string'
PUBLIC	?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveImprovement
PUBLIC	??_C@_0BA@JPMDNKAA@CanHaveResource?$AA@		; `string'
PUBLIC	?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveResource
PUBLIC	??_C@_0BA@NCNGOMHO@SeeThroughLevel?$AA@		; `string'
PUBLIC	?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSeeThroughLevel
PUBLIC	??_C@_0BD@IHNANKAE@GetNearestLandPlot?$AA@	; `string'
PUBLIC	?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandPlot
PUBLIC	??_C@_0N@JLKKCACM@SeeFromLevel?$AA@		; `string'
PUBLIC	?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSeeFromLevel
PUBLIC	??_C@_0BD@FALECHFI@GetNearestLandArea?$AA@	; `string'
PUBLIC	?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandArea
PUBLIC	??_C@_0BN@INFEOLLA@IsRiverCrossingFlowClockwise?$AA@ ; `string'
PUBLIC	?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingFlowClockwise
PUBLIC	??_C@_0BC@MEBABODO@IsRiverConnection?$AA@	; `string'
PUBLIC	?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverConnection
PUBLIC	??_C@_0M@JIJDEHJK@IsRiverSide?$AA@		; `string'
PUBLIC	?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRiverSide
PUBLIC	??_C@_0N@NLOFOEOP@IsFreshWater?$AA@		; `string'
PUBLIC	?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsFreshWater
PUBLIC	??_C@_06HMCHPBEJ@IsLake?$AA@			; `string'
PUBLIC	?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsLake
PUBLIC	??_C@_0BH@LEKKBAFC@IsWithinTeamCityRadius?$AA@	; `string'
PUBLIC	?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWithinTeamCityRadius
PUBLIC	??_C@_0O@JCODHDNO@IsCoastalLand?$AA@		; `string'
PUBLIC	?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsCoastalLand
PUBLIC	??_C@_0BJ@MHNLBPFC@IsAdjacentToShallowWater?$AA@ ; `string'
PUBLIC	?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToShallowWater
PUBLIC	??_C@_0BB@KMFODDOF@IsAdjacentToLand?$AA@	; `string'
PUBLIC	?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToLand
PUBLIC	??_C@_0BC@KFKFNAOO@ShareAdjacentArea?$AA@	; `string'
PUBLIC	?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lShareAdjacentArea
PUBLIC	??_C@_0BB@GHEABEIB@IsAdjacentToArea?$AA@	; `string'
PUBLIC	?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToArea
PUBLIC	??_C@_0BB@HLKLLBHO@UpdateVisibility?$AA@	; `string'
PUBLIC	?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lUpdateVisibility
PUBLIC	??_C@_09NMKCDBDG@UpdateFog?$AA@			; `string'
PUBLIC	?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lUpdateFog
PUBLIC	??_C@_0BA@JKJGDFML@GetInlandCorner?$AA@		; `string'
PUBLIC	?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInlandCorner
PUBLIC	??_C@_0O@BBFLFGKH@NukeExplosion?$AA@		; `string'
PUBLIC	?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lNukeExplosion
PUBLIC	??_C@_07KIJFBNDA@GetTeam?$AA@			; `string'
PUBLIC	?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetTeam
PUBLIC	??_C@_05FPBNKPKB@Erase?$AA@			; `string'
PUBLIC	?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lErase
PUBLIC	??_C@_06OAPDBHPB@IsNone?$AA@			; `string'
PUBLIC	?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z		; CvLuaPlot::lIsNone
PUBLIC	??_C@_0P@FAKCNGGM@SetTerrainType?$AA@		; `string'
PUBLIC	?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetTerrainType
PUBLIC	??_C@_0P@PIONOBEI@SetFeatureType?$AA@		; `string'
PUBLIC	?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lSetFeatureType
PUBLIC	??_C@_07HDBOHACA@IsWater?$AA@			; `string'
PUBLIC	?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsWater
PUBLIC	??_C@_07LJKKGCNJ@IsRiver?$AA@			; `string'
PUBLIC	?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lIsRiver
PUBLIC	??_C@_0P@JOLMCMEA@GetTerrainType?$AA@		; `string'
PUBLIC	?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetTerrainType
PUBLIC	??_C@_0P@DGPDBLGE@GetFeatureType?$AA@		; `string'
PUBLIC	?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lGetFeatureType
PUBLIC	??_C@_0P@LGGDKNMF@CanHaveFeature?$AA@		; `string'
PUBLIC	?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z	; CvLuaPlot::lCanHaveFeature
PUBLIC	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z	; CvLuaPlot::PushMethods
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushcclosure:PROC
;	COMDAT ??_C@_0BC@JKDJOJEA@SetCityPurchaseID?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
CONST	SEGMENT
??_C@_0BC@JKDJOJEA@SetCityPurchaseID?$AA@ DB 'SetCityPurchaseID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LPDCGCFO@GetCityPurchaseID?$AA@
CONST	SEGMENT
??_C@_0BC@LPDCGCFO@GetCityPurchaseID?$AA@ DB 'GetCityPurchaseID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NANOFFBN@HasWrittenArtifact?$AA@
CONST	SEGMENT
??_C@_0BD@NANOFFBN@HasWrittenArtifact?$AA@ DB 'HasWrittenArtifact', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OCKBDMDN@GetArchaeologyArtifactWork?$AA@
CONST	SEGMENT
??_C@_0BL@OCKBDMDN@GetArchaeologyArtifactWork?$AA@ DB 'GetArchaeologyArti'
	DB	'factWork', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OMCDNEIN@GetArchaeologyArtifactPlayer2?$AA@
CONST	SEGMENT
??_C@_0BO@OMCDNEIN@GetArchaeologyArtifactPlayer2?$AA@ DB 'GetArchaeologyA'
	DB	'rtifactPlayer2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MHAOIHEO@GetArchaeologyArtifactPlayer1?$AA@
CONST	SEGMENT
??_C@_0BO@MHAOIHEO@GetArchaeologyArtifactPlayer1?$AA@ DB 'GetArchaeologyA'
	DB	'rtifactPlayer1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EMCHHPLM@GetArchaeologyArtifactEra?$AA@
CONST	SEGMENT
??_C@_0BK@EMCHHPLM@GetArchaeologyArtifactEra?$AA@ DB 'GetArchaeologyArtif'
	DB	'actEra', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ENHELHEO@GetArchaeologyArtifactType?$AA@
CONST	SEGMENT
??_C@_0BL@ENHELHEO@GetArchaeologyArtifactType?$AA@ DB 'GetArchaeologyArti'
	DB	'factType', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PCIABHEK@IsBuildRemovesFeature?$AA@
CONST	SEGMENT
??_C@_0BG@PCIABHEK@IsBuildRemovesFeature?$AA@ DB 'IsBuildRemovesFeature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KPLFICMP@IsResourceConnectedByImprovement@
CONST	SEGMENT
??_C@_0CB@KPLFICMP@IsResourceConnectedByImprovement@ DB 'IsResourceConnec'
	DB	'tedByImprovement', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GKMJANIP@SetContinentArtType?$AA@
CONST	SEGMENT
??_C@_0BE@GKMJANIP@SetContinentArtType?$AA@ DB 'SetContinentArtType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MEOCENPD@GetContinentArtType?$AA@
CONST	SEGMENT
??_C@_0BE@MEOCENPD@GetContinentArtType?$AA@ DB 'GetContinentArtType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKHDLKJE@CanSeePlot?$AA@
CONST	SEGMENT
??_C@_0L@GKHDLKJE@CanSeePlot?$AA@ DB 'CanSeePlot', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NEIGEDBJ@IsImprovementPillaged?$AA@
CONST	SEGMENT
??_C@_0BG@NEIGEDBJ@IsImprovementPillaged?$AA@ DB 'IsImprovementPillaged', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BKOPMAI@GetActiveFogOfWarMode?$AA@
CONST	SEGMENT
??_C@_0BG@BKOPMAI@GetActiveFogOfWarMode?$AA@ DB 'GetActiveFogOfWarMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PGOPIEFE@SetScriptData?$AA@
CONST	SEGMENT
??_C@_0O@PGOPIEFE@SetScriptData?$AA@ DB 'SetScriptData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IJPBDHCD@GetScriptData?$AA@
CONST	SEGMENT
??_C@_0O@IJPBDHCD@GetScriptData?$AA@ DB 'GetScriptData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMFKPML@GetLayerUnit?$AA@
CONST	SEGMENT
??_C@_0N@KMFKPML@GetLayerUnit?$AA@ DB 'GetLayerUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CJPGAEMO@GetNumLayerUnits?$AA@
CONST	SEGMENT
??_C@_0BB@CJPGAEMO@GetNumLayerUnits?$AA@ DB 'GetNumLayerUnits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NHOHELCB@GetUnit?$AA@
CONST	SEGMENT
??_C@_07NHOHELCB@GetUnit?$AA@ DB 'GetUnit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNPEBAGL@GetNumUnits?$AA@
CONST	SEGMENT
??_C@_0M@GNPEBAGL@GetNumUnits?$AA@ DB 'GetNumUnits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LBNFAPK@ChangeInvisibleVisibilityCount?$AA@
CONST	SEGMENT
??_C@_0BP@LBNFAPK@ChangeInvisibleVisibilityCount?$AA@ DB 'ChangeInvisible'
	DB	'VisibilityCount', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@INIFKIEI@IsInvisibleVisible?$AA@
CONST	SEGMENT
??_C@_0BD@INIFKIEI@IsInvisibleVisible?$AA@ DB 'IsInvisibleVisible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FGJPJMNO@GetInvisibleVisibilityCount?$AA@
CONST	SEGMENT
??_C@_0BM@FGJPJMNO@GetInvisibleVisibilityCount?$AA@ DB 'GetInvisibleVisib'
	DB	'ilityCount', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JOFNMHNE@ChangeBuildProgress?$AA@
CONST	SEGMENT
??_C@_0BE@JOFNMHNE@ChangeBuildProgress?$AA@ DB 'ChangeBuildProgress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JNKOGOND@GetBuildProgress?$AA@
CONST	SEGMENT
??_C@_0BB@JNKOGOND@GetBuildProgress?$AA@ DB 'GetBuildProgress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IFAHMPDF@GetRevealedRouteType?$AA@
CONST	SEGMENT
??_C@_0BF@IFAHMPDF@GetRevealedRouteType?$AA@ DB 'GetRevealedRouteType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PNNIAODD@GetRevealedImprovementType?$AA@
CONST	SEGMENT
??_C@_0BL@PNNIAODD@GetRevealedImprovementType?$AA@ DB 'GetRevealedImprove'
	DB	'mentType', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIOPKDAN@SetRevealed?$AA@
CONST	SEGMENT
??_C@_0M@JIOPKDAN@SetRevealed?$AA@ DB 'SetRevealed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNACFKBL@IsRevealed?$AA@
CONST	SEGMENT
??_C@_0L@KNACFKBL@IsRevealed?$AA@ DB 'IsRevealed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BDOILNLO@IsRiverCrossingToPlot?$AA@
CONST	SEGMENT
??_C@_0BG@BDOILNLO@IsRiverCrossingToPlot?$AA@ DB 'IsRiverCrossingToPlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJKALLIG@IsRiverCrossing?$AA@
CONST	SEGMENT
??_C@_0BA@MJKALLIG@IsRiverCrossing?$AA@ DB 'IsRiverCrossing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GEFNGHGP@GetRevealedTeam?$AA@
CONST	SEGMENT
??_C@_0BA@GEFNGHGP@GetRevealedTeam?$AA@ DB 'GetRevealedTeam', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OFCBENIO@GetRevealedOwner?$AA@
CONST	SEGMENT
??_C@_0BB@OFCBENIO@GetRevealedOwner?$AA@ DB 'GetRevealedOwner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CELPDLDF@ChangeVisibilityCount?$AA@
CONST	SEGMENT
??_C@_0BG@CELPDLDF@ChangeVisibilityCount?$AA@ DB 'ChangeVisibilityCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MEPELFEN@GetVisibilityCount?$AA@
CONST	SEGMENT
??_C@_0BD@MEPELFEN@GetVisibilityCount?$AA@ DB 'GetVisibilityCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FCCJINHM@IsPlayerCityRadius?$AA@
CONST	SEGMENT
??_C@_0BD@FCCJINHM@IsPlayerCityRadius?$AA@ DB 'IsPlayerCityRadius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FHECNEHC@GetPlayerCityRadiusCount?$AA@
CONST	SEGMENT
??_C@_0BJ@FHECNEHC@GetPlayerCityRadiusCount?$AA@ DB 'GetPlayerCityRadiusC'
	DB	'ount', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MJJBFBHH@IsBestAdjacentFound?$AA@
CONST	SEGMENT
??_C@_0BE@MJJBFBHH@IsBestAdjacentFound?$AA@ DB 'IsBestAdjacentFound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GFNIBAIO@GetFoundValue?$AA@
CONST	SEGMENT
??_C@_0O@GFNIBAIO@GetFoundValue?$AA@ DB 'GetFoundValue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ODLGAIAC@CountNumAirUnits?$AA@
CONST	SEGMENT
??_C@_0BB@ODLGAIAC@CountNumAirUnits?$AA@ DB 'CountNumAirUnits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FCJPHHA@GetYieldWithBuild?$AA@
CONST	SEGMENT
??_C@_0BC@FCJPHHA@GetYieldWithBuild?$AA@ DB 'GetYieldWithBuild', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EOHKPHAI@HasYield?$AA@
CONST	SEGMENT
??_C@_08EOHKPHAI@HasYield?$AA@ DB 'HasYield', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CENIPKEL@CalculateYield?$AA@
CONST	SEGMENT
??_C@_0P@CENIPKEL@CalculateYield?$AA@ DB 'CalculateYield', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FIAOIPPH@CalculateImprovementYieldChange?$AA@
CONST	SEGMENT
??_C@_0CA@FIAOIPPH@CalculateImprovementYieldChange?$AA@ DB 'CalculateImpr'
	DB	'ovementYieldChange', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EHFPFGPL@CalculateTotalBestNatureYield?$AA@
CONST	SEGMENT
??_C@_0BO@EHFPFGPL@CalculateTotalBestNatureYield?$AA@ DB 'CalculateTotalB'
	DB	'estNatureYield', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OAMDIALM@CalculateBestNatureYield?$AA@
CONST	SEGMENT
??_C@_0BJ@OAMDIALM@CalculateBestNatureYield?$AA@ DB 'CalculateBestNatureY'
	DB	'ield', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBKOLKOI@CalculateNatureYield?$AA@
CONST	SEGMENT
??_C@_0BF@CBKOLKOI@CalculateNatureYield?$AA@ DB 'CalculateNatureYield', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NACOAIKN@GetYield?$AA@
CONST	SEGMENT
??_C@_08NACOAIKN@GetYield?$AA@ DB 'GetYield', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PHPNMIIM@GetRiverCrossingCount?$AA@
CONST	SEGMENT
??_C@_0BG@PHPNMIIM@GetRiverCrossingCount?$AA@ DB 'GetRiverCrossingCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FJEFAJPI@GetReconCount?$AA@
CONST	SEGMENT
??_C@_0O@FJEFAJPI@GetReconCount?$AA@ DB 'GetReconCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OOJOMMJK@GetWorkingCityOverride?$AA@
CONST	SEGMENT
??_C@_0BH@OOJOMMJK@GetWorkingCityOverride?$AA@ DB 'GetWorkingCityOverride'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FJAEMPGB@GetWorkingCity?$AA@
CONST	SEGMENT
??_C@_0P@FJAEMPGB@GetWorkingCity?$AA@ DB 'GetWorkingCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCNDGHAN@GetPlotCity?$AA@
CONST	SEGMENT
??_C@_0M@PCNDGHAN@GetPlotCity?$AA@ DB 'GetPlotCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BOKCMBNI@IsRoutePillaged?$AA@
CONST	SEGMENT
??_C@_0BA@BOKCMBNI@IsRoutePillaged?$AA@ DB 'IsRoutePillaged', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHILEECB@SetRouteType?$AA@
CONST	SEGMENT
??_C@_0N@LHILEECB@SetRouteType?$AA@ DB 'SetRouteType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDDFIIGN@GetRouteType?$AA@
CONST	SEGMENT
??_C@_0N@MDDFIIGN@GetRouteType?$AA@ DB 'GetRouteType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HIMINBGH@SetImprovementPillaged?$AA@
CONST	SEGMENT
??_C@_0BH@HIMINBGH@SetImprovementPillaged?$AA@ DB 'SetImprovementPillaged'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CDMJPHEA@SetImprovementType?$AA@
CONST	SEGMENT
??_C@_0BD@CDMJPHEA@SetImprovementType?$AA@ DB 'SetImprovementType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NJODMBKI@GetImprovementType?$AA@
CONST	SEGMENT
??_C@_0BD@NJODMBKI@GetImprovementType?$AA@ DB 'GetImprovementType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KPBOMALO@ChangeNumResource?$AA@
CONST	SEGMENT
??_C@_0BC@KPBOMALO@ChangeNumResource?$AA@ DB 'ChangeNumResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PFFHMNLP@SetNumResource?$AA@
CONST	SEGMENT
??_C@_0P@PFFHMNLP@SetNumResource?$AA@ DB 'SetNumResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLEJDHJD@GetNumResource?$AA@
CONST	SEGMENT
??_C@_0P@DLEJDHJD@GetNumResource?$AA@ DB 'GetNumResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MPFNFEGO@SetResourceType?$AA@
CONST	SEGMENT
??_C@_0BA@MPFNFEGO@SetResourceType?$AA@ DB 'SetResourceType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OCHONID@GetNonObsoleteResourceType?$AA@
CONST	SEGMENT
??_C@_0BL@OCHONID@GetNonObsoleteResourceType?$AA@ DB 'GetNonObsoleteResou'
	DB	'rceType', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PNELCGHH@GetResourceType?$AA@
CONST	SEGMENT
??_C@_0BA@PNELCGHH@GetResourceType?$AA@ DB 'GetResourceType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JOGKFIAC@SetPlotType?$AA@
CONST	SEGMENT
??_C@_0M@JOGKFIAC@SetPlotType?$AA@ DB 'SetPlotType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNALPAOM@IsMountain?$AA@
CONST	SEGMENT
??_C@_0L@LNALPAOM@IsMountain?$AA@ DB 'IsMountain', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNIIDOJH@IsRoughGround?$AA@
CONST	SEGMENT
??_C@_0O@DNIIDOJH@IsRoughGround?$AA@ DB 'IsRoughGround', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKDGHAGP@IsOpenGround?$AA@
CONST	SEGMENT
??_C@_0N@DKDGHAGP@IsOpenGround?$AA@ DB 'IsOpenGround', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCIJPOBB@IsHills?$AA@
CONST	SEGMENT
??_C@_07DCIJPOBB@IsHills?$AA@ DB 'IsHills', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CIOEIJGM@IsFlatlands?$AA@
CONST	SEGMENT
??_C@_0M@CIOEIJGM@IsFlatlands?$AA@ DB 'IsFlatlands', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JBHEIOIB@GetPlotType?$AA@
CONST	SEGMENT
??_C@_0M@JBHEIOIB@GetPlotType?$AA@ DB 'GetPlotType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OPBFNKOM@SetOwner?$AA@
CONST	SEGMENT
??_C@_08OPBFNKOM@SetOwner?$AA@ DB 'SetOwner', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BODJMJJB@GetOwner?$AA@
CONST	SEGMENT
??_C@_08BODJMJJB@GetOwner?$AA@ DB 'GetOwner', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FNJICPCN@IsPotentialCityWorkForArea?$AA@
CONST	SEGMENT
??_C@_0BL@FNJICPCN@IsPotentialCityWorkForArea?$AA@ DB 'IsPotentialCityWor'
	DB	'kForArea', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ELJLKDMB@IsPotentialCityWork?$AA@
CONST	SEGMENT
??_C@_0BE@ELJLKDMB@IsPotentialCityWork?$AA@ DB 'IsPotentialCityWork', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCMIAAIB@GetRiverSWFlowDirection?$AA@
CONST	SEGMENT
??_C@_0BI@MCMIAAIB@GetRiverSWFlowDirection?$AA@ DB 'GetRiverSWFlowDirecti'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@COCMCOFP@GetRiverSEFlowDirection?$AA@
CONST	SEGMENT
??_C@_0BI@COCMCOFP@GetRiverSEFlowDirection?$AA@ DB 'GetRiverSEFlowDirecti'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KPEJPCF@GetRiverEFlowDirection?$AA@
CONST	SEGMENT
??_C@_0BH@KPEJPCF@GetRiverEFlowDirection?$AA@ DB 'GetRiverEFlowDirection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PMHPDLKG@SetNWOfRiver?$AA@
CONST	SEGMENT
??_C@_0N@PMHPDLKG@SetNWOfRiver?$AA@ DB 'SetNWOfRiver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJOGDAO@IsNWOfRiver?$AA@
CONST	SEGMENT
??_C@_0M@IJOGDAO@IsNWOfRiver?$AA@ DB 'IsNWOfRiver', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHCDHKOK@SetWOfRiver?$AA@
CONST	SEGMENT
??_C@_0M@NHCDHKOK@SetWOfRiver?$AA@ DB 'SetWOfRiver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCMOIDPM@IsWOfRiver?$AA@
CONST	SEGMENT
??_C@_0L@OCMOIDPM@IsWOfRiver?$AA@ DB 'IsWOfRiver', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HOEJFBFB@SetNEOfRiver?$AA@
CONST	SEGMENT
??_C@_0N@HOEJFBFB@SetNEOfRiver?$AA@ DB 'SetNEOfRiver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IKKIAJPJ@IsNEOfRiver?$AA@
CONST	SEGMENT
??_C@_0M@IKKIAJPJ@IsNEOfRiver?$AA@ DB 'IsNEOfRiver', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNONGEOP@SetStartingPlot?$AA@
CONST	SEGMENT
??_C@_0BA@GNONGEOP@SetStartingPlot?$AA@ DB 'SetStartingPlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BPOJGNHB@IsStartingPlot?$AA@
CONST	SEGMENT
??_C@_0P@BPOJGNHB@IsStartingPlot?$AA@ DB 'IsStartingPlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOBJPEOH@IsCityRadius?$AA@
CONST	SEGMENT
??_C@_0N@OOBJPEOH@IsCityRadius?$AA@ DB 'IsCityRadius', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FMKHJCLK@GetCityRadiusCount?$AA@
CONST	SEGMENT
??_C@_0BD@FMKHJCLK@GetCityRadiusCount?$AA@ DB 'GetCityRadiusCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BMLACKEG@ChangeUpgradeProgress?$AA@
CONST	SEGMENT
??_C@_0BG@BMLACKEG@ChangeUpgradeProgress?$AA@ DB 'ChangeUpgradeProgress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNBJCNG@SetUpgradeProgress?$AA@
CONST	SEGMENT
??_C@_0BD@GNBJCNG@SetUpgradeProgress?$AA@ DB 'SetUpgradeProgress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BBCMJJNG@GetUpgradeTimeLeft?$AA@
CONST	SEGMENT
??_C@_0BD@BBCMJJNG@GetUpgradeTimeLeft?$AA@ DB 'GetUpgradeTimeLeft', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PMPLKEDO@GetUpgradeProgress?$AA@
CONST	SEGMENT
??_C@_0BD@PMPLKEDO@GetUpgradeProgress?$AA@ DB 'GetUpgradeProgress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GBKBPNDO@ChangeImprovementDuration?$AA@
CONST	SEGMENT
??_C@_0BK@GBKBPNDO@ChangeImprovementDuration?$AA@ DB 'ChangeImprovementDu'
	DB	'ration', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JGCIBAKO@SetImprovementDuration?$AA@
CONST	SEGMENT
??_C@_0BH@JGCIBAKO@SetImprovementDuration?$AA@ DB 'SetImprovementDuration'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JHAGDHHB@GetImprovementDuration?$AA@
CONST	SEGMENT
??_C@_0BH@JHAGDHHB@GetImprovementDuration?$AA@ DB 'GetImprovementDuration'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OJDEJCCM@ChangeOwnershipDuration?$AA@
CONST	SEGMENT
??_C@_0BI@OJDEJCCM@ChangeOwnershipDuration?$AA@ DB 'ChangeOwnershipDurati'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FNMPDJOJ@SetOwnershipDuration?$AA@
CONST	SEGMENT
??_C@_0BF@FNMPDJOJ@SetOwnershipDuration?$AA@ DB 'SetOwnershipDuration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KOAOKKPA@IsOwnershipScore?$AA@
CONST	SEGMENT
??_C@_0BB@KOAOKKPA@IsOwnershipScore?$AA@ DB 'IsOwnershipScore', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ENCCPLO@GetOwnershipDuration?$AA@
CONST	SEGMENT
??_C@_0BF@ENCCPLO@GetOwnershipDuration?$AA@ DB 'GetOwnershipDuration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PNINJHCK@GetFeatureVariety?$AA@
CONST	SEGMENT
??_C@_0BC@PNINJHCK@GetFeatureVariety?$AA@ DB 'GetFeatureVariety', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JOBGLCOF@SetArea?$AA@
CONST	SEGMENT
??_C@_07JOBGLCOF@SetArea?$AA@ DB 'SetArea', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GGOHINDE@GetArea?$AA@
CONST	SEGMENT
??_C@_07GGOHINDE@GetArea?$AA@ DB 'GetArea', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNIEIFHO@WaterArea?$AA@
CONST	SEGMENT
??_C@_09CNIEIFHO@WaterArea?$AA@ DB 'WaterArea', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KPICECCB@Area?$AA@
CONST	SEGMENT
??_C@_04KPICECCB@Area?$AA@ DB 'Area', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KCMGIFE@GetLatitude?$AA@
CONST	SEGMENT
??_C@_0M@KCMGIFE@GetLatitude?$AA@ DB 'GetLatitude', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MPDLKONJ@GetPlotIndex?$AA@
CONST	SEGMENT
??_C@_0N@MPDLKONJ@GetPlotIndex?$AA@ DB 'GetPlotIndex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKLFHNOI@At?$AA@
CONST	SEGMENT
??_C@_02DKLFHNOI@At?$AA@ DB 'At', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHHHKNBL@GetY?$AA@
CONST	SEGMENT
??_C@_04OHHHKNBL@GetY?$AA@ DB 'GetY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POGMJMFK@GetX?$AA@
CONST	SEGMENT
??_C@_04POGMJMFK@GetX?$AA@ DB 'GetX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MALFMDGK@IsImpassable?$AA@
CONST	SEGMENT
??_C@_0N@MALFMDGK@IsImpassable?$AA@ DB 'IsImpassable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IFEGDFCC@IsValidDomainForAction?$AA@
CONST	SEGMENT
??_C@_0BH@IFEGDFCC@IsValidDomainForAction?$AA@ DB 'IsValidDomainForAction'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CLNJIBGO@IsValidDomainForLocation?$AA@
CONST	SEGMENT
??_C@_0BJ@CLNJIBGO@IsValidDomainForLocation?$AA@ DB 'IsValidDomainForLoca'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIBMJEHN@IsTradeRoute?$AA@
CONST	SEGMENT
??_C@_0N@CIBMJEHN@IsTradeRoute?$AA@ DB 'IsTradeRoute', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DMDIHFEG@IsRoute?$AA@
CONST	SEGMENT
??_C@_07DMDIHFEG@IsRoute?$AA@ DB 'IsRoute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOBAIMGP@IsFighting?$AA@
CONST	SEGMENT
??_C@_0L@MOBAIMGP@IsFighting?$AA@ DB 'IsFighting', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MEHFJEJD@GetNumFriendlyUnitsOfType?$AA@
CONST	SEGMENT
??_C@_0BK@MEHFJEJD@GetNumFriendlyUnitsOfType?$AA@ DB 'GetNumFriendlyUnits'
	DB	'OfType', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LCFOEEGJ@IsVisibleOtherUnit?$AA@
CONST	SEGMENT
??_C@_0BD@LCFOEEGJ@IsVisibleOtherUnit?$AA@ DB 'IsVisibleOtherUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FOLPLHDK@IsVisibleEnemyUnit?$AA@
CONST	SEGMENT
??_C@_0BD@FOLPLHDK@IsVisibleEnemyUnit?$AA@ DB 'IsVisibleEnemyUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KKFDFPEO@GetNumVisiblePotentialEnemyDefen@
CONST	SEGMENT
??_C@_0CF@KKFDFPEO@GetNumVisiblePotentialEnemyDefen@ DB 'GetNumVisiblePot'
	DB	'entialEnemyDefenders', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GIKOKOLI@GetNumVisibleEnemyDefenders?$AA@
CONST	SEGMENT
??_C@_0BM@GIKOKOLI@GetNumVisibleEnemyDefenders?$AA@ DB 'GetNumVisibleEnem'
	DB	'yDefenders', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNAHEKAB@GetNumDefenders?$AA@
CONST	SEGMENT
??_C@_0BA@GNAHEKAB@GetNumDefenders?$AA@ DB 'GetNumDefenders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KJEJGOKA@IsVisibleEnemyDefender?$AA@
CONST	SEGMENT
??_C@_0BH@KJEJGOKA@IsVisibleEnemyDefender?$AA@ DB 'IsVisibleEnemyDefender'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJOJODJC@IsUnit?$AA@
CONST	SEGMENT
??_C@_06BJOJODJC@IsUnit?$AA@ DB 'IsUnit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GHFLFPIL@IsBeingWorked?$AA@
CONST	SEGMENT
??_C@_0O@GHFLFPIL@IsBeingWorked?$AA@ DB 'IsBeingWorked', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICNFBAB@IsEnemyCity?$AA@
CONST	SEGMENT
??_C@_0M@ICNFBAB@IsEnemyCity?$AA@ DB 'IsEnemyCity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JPKGCGMM@IsFriendlyCity?$AA@
CONST	SEGMENT
??_C@_0P@JPKGCGMM@IsFriendlyCity?$AA@ DB 'IsFriendlyCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MKMOPHGH@IsCity?$AA@
CONST	SEGMENT
??_C@_06MKMOPHGH@IsCity?$AA@ DB 'IsCity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IMNKPHIO@IsFriendlyTerritory?$AA@
CONST	SEGMENT
??_C@_0BE@IMNKPHIO@IsFriendlyTerritory?$AA@ DB 'IsFriendlyTerritory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HAPEMDMB@IsRevealedGoody?$AA@
CONST	SEGMENT
??_C@_0BA@HAPEMDMB@IsRevealedGoody?$AA@ DB 'IsRevealedGoody', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KKNGKPLI@IsGoody?$AA@
CONST	SEGMENT
??_C@_07KKNGKPLI@IsGoody?$AA@ DB 'IsGoody', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LKMCGBMH@RemoveGoody?$AA@
CONST	SEGMENT
??_C@_0M@LKMCGBMH@RemoveGoody?$AA@ DB 'RemoveGoody', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DBMNPJAN@IsAdjacentNonrevealed?$AA@
CONST	SEGMENT
??_C@_0BG@DBMNPJAN@IsAdjacentNonrevealed?$AA@ DB 'IsAdjacentNonrevealed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OBOIAPPP@IsAdjacentRevealed?$AA@
CONST	SEGMENT
??_C@_0BD@OBOIAPPP@IsAdjacentRevealed?$AA@ DB 'IsAdjacentRevealed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CNMKPADN@IsAdjacentNonvisible?$AA@
CONST	SEGMENT
??_C@_0BF@CNMKPADN@IsAdjacentNonvisible?$AA@ DB 'IsAdjacentNonvisible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GICKPFNI@IsAdjacentVisible?$AA@
CONST	SEGMENT
??_C@_0BC@GICKPFNI@IsAdjacentVisible?$AA@ DB 'IsAdjacentVisible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FMJJGAJM@IsVisibleToWatchingHuman?$AA@
CONST	SEGMENT
??_C@_0BJ@FMJJGAJM@IsVisibleToWatchingHuman?$AA@ DB 'IsVisibleToWatchingH'
	DB	'uman', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CFACHEEE@IsActiveVisible?$AA@
CONST	SEGMENT
??_C@_0BA@CFACHEEE@IsActiveVisible?$AA@ DB 'IsActiveVisible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OLGPEPPJ@IsVisible?$AA@
CONST	SEGMENT
??_C@_09OLGPEPPJ@IsVisible?$AA@ DB 'IsVisible', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNCHANHC@HasBarbarianCamp?$AA@
CONST	SEGMENT
??_C@_0BB@HNCHANHC@HasBarbarianCamp?$AA@ DB 'HasBarbarianCamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EPJKJJAH@IsRevealedBarbarian?$AA@
CONST	SEGMENT
??_C@_0BE@EPJKJJAH@IsRevealedBarbarian?$AA@ DB 'IsRevealedBarbarian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJNEDJLP@IsBarbarian?$AA@
CONST	SEGMENT
??_C@_0M@NJNEDJLP@IsBarbarian?$AA@ DB 'IsBarbarian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FAAHJANI@IsOwned?$AA@
CONST	SEGMENT
??_C@_07FAAHJANI@IsOwned?$AA@ DB 'IsOwned', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CLEIAJCJ@IsAdjacentTeam?$AA@
CONST	SEGMENT
??_C@_0P@CLEIAJCJ@IsAdjacentTeam?$AA@ DB 'IsAdjacentTeam', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCLEKLKL@IsAdjacentPlayer?$AA@
CONST	SEGMENT
??_C@_0BB@GCLEKLKL@IsAdjacentPlayer?$AA@ DB 'IsAdjacentPlayer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGEJAJJC@IsAdjacentOwned?$AA@
CONST	SEGMENT
??_C@_0BA@GGEJAJJC@IsAdjacentOwned?$AA@ DB 'IsAdjacentOwned', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EBOAMIEM@ChangeExtraMovePathCost?$AA@
CONST	SEGMENT
??_C@_0BI@EBOAMIEM@ChangeExtraMovePathCost?$AA@ DB 'ChangeExtraMovePathCo'
	DB	'st', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KMAGHFNO@GetExtraMovePathCost?$AA@
CONST	SEGMENT
??_C@_0BF@KMAGHFNO@GetExtraMovePathCost?$AA@ DB 'GetExtraMovePathCost', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GOFKPDCB@MovementCost?$AA@
CONST	SEGMENT
??_C@_0N@GOFKPDCB@MovementCost?$AA@ DB 'MovementCost', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@
CONST	SEGMENT
??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@ DB 'DefenseModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GAHBCOIE@GetUnitPower?$AA@
CONST	SEGMENT
??_C@_0N@GAHBCOIE@GetUnitPower?$AA@ DB 'GetUnitPower', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LEIHGKM@GetSelectedUnit?$AA@
CONST	SEGMENT
??_C@_0BA@LEIHGKM@GetSelectedUnit?$AA@ DB 'GetSelectedUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNICPDNO@GetBestDefender?$AA@
CONST	SEGMENT
??_C@_0BA@NNICPDNO@GetBestDefender?$AA@ DB 'GetBestDefender', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FHMAACMJ@GetFeatureFood?$AA@
CONST	SEGMENT
??_C@_0P@FHMAACMJ@GetFeatureFood?$AA@ DB 'GetFeatureFood', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FDDHIDF@GetFeatureProduction?$AA@
CONST	SEGMENT
??_C@_0BF@FDDHIDF@GetFeatureProduction?$AA@ DB 'GetFeatureProduction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MBBBIJOB@GetBuildTurnsTotal?$AA@
CONST	SEGMENT
??_C@_0BD@MBBBIJOB@GetBuildTurnsTotal?$AA@ DB 'GetBuildTurnsTotal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CDKKMKGA@GetBuildTurnsLeft?$AA@
CONST	SEGMENT
??_C@_0BC@CDKKMKGA@GetBuildTurnsLeft?$AA@ DB 'GetBuildTurnsLeft', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CNOLIDLO@GetBuildTime?$AA@
CONST	SEGMENT
??_C@_0N@CNOLIDLO@GetBuildTime?$AA@ DB 'GetBuildTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMPBKDLI@CanBuild?$AA@
CONST	SEGMENT
??_C@_08EMPBKDLI@CanBuild?$AA@ DB 'CanBuild', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCLEPEFH@CanHaveImprovement?$AA@
CONST	SEGMENT
??_C@_0BD@PCLEPEFH@CanHaveImprovement?$AA@ DB 'CanHaveImprovement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JPMDNKAA@CanHaveResource?$AA@
CONST	SEGMENT
??_C@_0BA@JPMDNKAA@CanHaveResource?$AA@ DB 'CanHaveResource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NCNGOMHO@SeeThroughLevel?$AA@
CONST	SEGMENT
??_C@_0BA@NCNGOMHO@SeeThroughLevel?$AA@ DB 'SeeThroughLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IHNANKAE@GetNearestLandPlot?$AA@
CONST	SEGMENT
??_C@_0BD@IHNANKAE@GetNearestLandPlot?$AA@ DB 'GetNearestLandPlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JLKKCACM@SeeFromLevel?$AA@
CONST	SEGMENT
??_C@_0N@JLKKCACM@SeeFromLevel?$AA@ DB 'SeeFromLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FALECHFI@GetNearestLandArea?$AA@
CONST	SEGMENT
??_C@_0BD@FALECHFI@GetNearestLandArea?$AA@ DB 'GetNearestLandArea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@INFEOLLA@IsRiverCrossingFlowClockwise?$AA@
CONST	SEGMENT
??_C@_0BN@INFEOLLA@IsRiverCrossingFlowClockwise?$AA@ DB 'IsRiverCrossingF'
	DB	'lowClockwise', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MEBABODO@IsRiverConnection?$AA@
CONST	SEGMENT
??_C@_0BC@MEBABODO@IsRiverConnection?$AA@ DB 'IsRiverConnection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIJDEHJK@IsRiverSide?$AA@
CONST	SEGMENT
??_C@_0M@JIJDEHJK@IsRiverSide?$AA@ DB 'IsRiverSide', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NLOFOEOP@IsFreshWater?$AA@
CONST	SEGMENT
??_C@_0N@NLOFOEOP@IsFreshWater?$AA@ DB 'IsFreshWater', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HMCHPBEJ@IsLake?$AA@
CONST	SEGMENT
??_C@_06HMCHPBEJ@IsLake?$AA@ DB 'IsLake', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LEKKBAFC@IsWithinTeamCityRadius?$AA@
CONST	SEGMENT
??_C@_0BH@LEKKBAFC@IsWithinTeamCityRadius?$AA@ DB 'IsWithinTeamCityRadius'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JCODHDNO@IsCoastalLand?$AA@
CONST	SEGMENT
??_C@_0O@JCODHDNO@IsCoastalLand?$AA@ DB 'IsCoastalLand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MHNLBPFC@IsAdjacentToShallowWater?$AA@
CONST	SEGMENT
??_C@_0BJ@MHNLBPFC@IsAdjacentToShallowWater?$AA@ DB 'IsAdjacentToShallowW'
	DB	'ater', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KMFODDOF@IsAdjacentToLand?$AA@
CONST	SEGMENT
??_C@_0BB@KMFODDOF@IsAdjacentToLand?$AA@ DB 'IsAdjacentToLand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KFKFNAOO@ShareAdjacentArea?$AA@
CONST	SEGMENT
??_C@_0BC@KFKFNAOO@ShareAdjacentArea?$AA@ DB 'ShareAdjacentArea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GHEABEIB@IsAdjacentToArea?$AA@
CONST	SEGMENT
??_C@_0BB@GHEABEIB@IsAdjacentToArea?$AA@ DB 'IsAdjacentToArea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HLKLLBHO@UpdateVisibility?$AA@
CONST	SEGMENT
??_C@_0BB@HLKLLBHO@UpdateVisibility?$AA@ DB 'UpdateVisibility', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMKCDBDG@UpdateFog?$AA@
CONST	SEGMENT
??_C@_09NMKCDBDG@UpdateFog?$AA@ DB 'UpdateFog', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JKJGDFML@GetInlandCorner?$AA@
CONST	SEGMENT
??_C@_0BA@JKJGDFML@GetInlandCorner?$AA@ DB 'GetInlandCorner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BBFLFGKH@NukeExplosion?$AA@
CONST	SEGMENT
??_C@_0O@BBFLFGKH@NukeExplosion?$AA@ DB 'NukeExplosion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIJFBNDA@GetTeam?$AA@
CONST	SEGMENT
??_C@_07KIJFBNDA@GetTeam?$AA@ DB 'GetTeam', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FPBNKPKB@Erase?$AA@
CONST	SEGMENT
??_C@_05FPBNKPKB@Erase?$AA@ DB 'Erase', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAPDBHPB@IsNone?$AA@
CONST	SEGMENT
??_C@_06OAPDBHPB@IsNone?$AA@ DB 'IsNone', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FAKCNGGM@SetTerrainType?$AA@
CONST	SEGMENT
??_C@_0P@FAKCNGGM@SetTerrainType?$AA@ DB 'SetTerrainType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PIONOBEI@SetFeatureType?$AA@
CONST	SEGMENT
??_C@_0P@PIONOBEI@SetFeatureType?$AA@ DB 'SetFeatureType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDBOHACA@IsWater?$AA@
CONST	SEGMENT
??_C@_07HDBOHACA@IsWater?$AA@ DB 'IsWater', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LJKKGCNJ@IsRiver?$AA@
CONST	SEGMENT
??_C@_07LJKKGCNJ@IsRiver?$AA@ DB 'IsRiver', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JOLMCMEA@GetTerrainType?$AA@
CONST	SEGMENT
??_C@_0P@JOLMCMEA@GetTerrainType?$AA@ DB 'GetTerrainType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGPDBLGE@GetFeatureType?$AA@
CONST	SEGMENT
??_C@_0P@DGPDBLGE@GetFeatureType?$AA@ DB 'GetFeatureType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LGGDKNMF@CanHaveFeature?$AA@
CONST	SEGMENT
??_C@_0P@LGGDKNMF@CanHaveFeature?$AA@ DB 'CanHaveFeature', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z PROC	; CvLuaPlot::PushMethods, COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp

; 31   : 	Method(CanHaveFeature);

	push	0
	push	OFFSET ?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveFeature
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@LGGDKNMF@CanHaveFeature?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 32   : 	Method(GetFeatureType);

	push	0
	push	OFFSET ?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@DGPDBLGE@GetFeatureType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 33   : 	Method(GetTerrainType);

	push	0
	push	OFFSET ?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetTerrainType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@JOLMCMEA@GetTerrainType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 34   : 	Method(IsRiver);

	push	0
	push	OFFSET ?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07LJKKGCNJ@IsRiver?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 35   : 	Method(IsWater);

	push	0
	push	OFFSET ?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWater
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07HDBOHACA@IsWater?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 36   : 	Method(SetFeatureType);

	push	0
	push	OFFSET ?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetFeatureType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@PIONOBEI@SetFeatureType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 37   : 	Method(SetTerrainType);

	push	0
	push	OFFSET ?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetTerrainType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@FAKCNGGM@SetTerrainType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 38   : 
; 39   : 	Method(IsNone);

	push	0
	push	OFFSET ?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsNone
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_06OAPDBHPB@IsNone?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 40   : 	Method(Erase);

	push	0
	push	OFFSET ?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lErase
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_05FPBNKPKB@Erase?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 41   : 	Method(GetTeam);

	push	0
	push	OFFSET ?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetTeam
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07KIJFBNDA@GetTeam?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 42   : 
; 43   : 	Method(NukeExplosion);

	push	0
	push	OFFSET ?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lNukeExplosion
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@BBFLFGKH@NukeExplosion?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 44   : 
; 45   : 	Method(GetInlandCorner);

	push	0
	push	OFFSET ?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInlandCorner
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@JKJGDFML@GetInlandCorner?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 46   : 
; 47   : 	Method(UpdateFog);

	push	0
	push	OFFSET ?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lUpdateFog
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_09NMKCDBDG@UpdateFog?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 48   : 	Method(UpdateVisibility);

	push	0
	push	OFFSET ?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lUpdateVisibility
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@HLKLLBHO@UpdateVisibility?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 49   : 	Method(IsAdjacentToArea);

	push	0
	push	OFFSET ?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@GHEABEIB@IsAdjacentToArea?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 50   : 	Method(ShareAdjacentArea);

	push	0
	push	OFFSET ?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lShareAdjacentArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@KFKFNAOO@ShareAdjacentArea?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 51   : 	Method(IsAdjacentToLand);

	push	0
	push	OFFSET ?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToLand
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@KMFODDOF@IsAdjacentToLand?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 52   : 	Method(IsAdjacentToShallowWater);

	push	0
	push	OFFSET ?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentToShallowWater
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BJ@MHNLBPFC@IsAdjacentToShallowWater?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 53   : 	Method(IsCoastalLand);

	push	0
	push	OFFSET ?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsCoastalLand
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@JCODHDNO@IsCoastalLand?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 54   : 
; 55   : 	Method(IsWithinTeamCityRadius);

	push	0
	push	OFFSET ?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWithinTeamCityRadius
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@LEKKBAFC@IsWithinTeamCityRadius?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 56   : 
; 57   : 	Method(IsLake);

	push	0
	push	OFFSET ?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsLake
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_06HMCHPBEJ@IsLake?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 58   : 	Method(IsFreshWater);

	push	0
	push	OFFSET ?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFreshWater
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@NLOFOEOP@IsFreshWater?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 59   : 
; 60   : 	Method(IsRiverSide);

	push	0
	push	OFFSET ?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverSide
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@JIJDEHJK@IsRiverSide?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 61   : 	Method(IsRiverConnection);

	push	0
	push	OFFSET ?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverConnection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@MEBABODO@IsRiverConnection?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 62   : 	Method(IsRiverCrossingFlowClockwise);

	push	0
	push	OFFSET ?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingFlowClockwise
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BN@INFEOLLA@IsRiverCrossingFlowClockwise?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 63   : 
; 64   : 	Method(GetNearestLandArea);

	push	0
	push	OFFSET ?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@FALECHFI@GetNearestLandArea?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 65   : 	Method(SeeFromLevel);

	push	0
	push	OFFSET ?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSeeFromLevel
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@JLKKCACM@SeeFromLevel?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 66   : 	Method(GetNearestLandPlot);

	push	0
	push	OFFSET ?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNearestLandPlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@IHNANKAE@GetNearestLandPlot?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 67   : 	Method(SeeThroughLevel);

	push	0
	push	OFFSET ?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSeeThroughLevel
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@NCNGOMHO@SeeThroughLevel?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 68   : 	Method(CanHaveResource);

	push	0
	push	OFFSET ?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@JPMDNKAA@CanHaveResource?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 69   : 	Method(CanHaveImprovement);

	push	0
	push	OFFSET ?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanHaveImprovement
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@PCLEPEFH@CanHaveImprovement?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 70   : 	Method(CanBuild);

	push	0
	push	OFFSET ?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanBuild
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_08EMPBKDLI@CanBuild?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 71   : 	Method(GetBuildTime);

	push	0
	push	OFFSET ?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTime
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@CNOLIDLO@GetBuildTime?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 72   : 	Method(GetBuildTurnsLeft);

	push	0
	push	OFFSET ?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsLeft
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@CDKKMKGA@GetBuildTurnsLeft?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 73   : 	Method(GetBuildTurnsTotal);

	push	0
	push	OFFSET ?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildTurnsTotal
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@MBBBIJOB@GetBuildTurnsTotal?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 74   : 	Method(GetFeatureProduction);

	push	0
	push	OFFSET ?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureProduction
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BF@FDDHIDF@GetFeatureProduction?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 75   : #ifdef NQ_FOOD_FROM_CHOPS
; 76   : 	Method(GetFeatureFood);

	push	0
	push	OFFSET ?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureFood
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@FHMAACMJ@GetFeatureFood?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 77   : #endif
; 78   : 
; 79   : 	Method(GetBestDefender);

	push	0
	push	OFFSET ?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBestDefender
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@NNICPDNO@GetBestDefender?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 80   : 	Method(GetSelectedUnit);

	push	0
	push	OFFSET ?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetSelectedUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@LEIHGKM@GetSelectedUnit?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 81   : 	Method(GetUnitPower);

	push	0
	push	OFFSET ?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUnitPower
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@GAHBCOIE@GetUnitPower?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 82   : 
; 83   : 	Method(DefenseModifier);

	push	0
	push	OFFSET ?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lDefenseModifier
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@BLEBFEEF@DefenseModifier?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 84   : 	Method(MovementCost);

	push	0
	push	OFFSET ?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lMovementCost
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@GOFKPDCB@MovementCost?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 85   : 
; 86   : 	Method(GetExtraMovePathCost);

	push	0
	push	OFFSET ?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetExtraMovePathCost
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BF@KMAGHFNO@GetExtraMovePathCost?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 87   : 	Method(ChangeExtraMovePathCost);

	push	0
	push	OFFSET ?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeExtraMovePathCost
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BI@EBOAMIEM@ChangeExtraMovePathCost?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 88   : 
; 89   : 	Method(IsAdjacentOwned);

	push	0
	push	OFFSET ?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentOwned
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@GGEJAJJC@IsAdjacentOwned?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 90   : 	Method(IsAdjacentPlayer);

	push	0
	push	OFFSET ?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentPlayer
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@GCLEKLKL@IsAdjacentPlayer?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 91   : 	Method(IsAdjacentTeam);

	push	0
	push	OFFSET ?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentTeam
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@CLEIAJCJ@IsAdjacentTeam?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 92   : 
; 93   : 	Method(IsOwned);

	push	0
	push	OFFSET ?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOwned
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07FAAHJANI@IsOwned?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 94   : 	Method(IsBarbarian);

	push	0
	push	OFFSET ?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBarbarian
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@NJNEDJLP@IsBarbarian?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 95   : 	Method(IsRevealedBarbarian);

	push	0
	push	OFFSET ?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedBarbarian
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BE@EPJKJJAH@IsRevealedBarbarian?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 96   : 	Method(HasBarbarianCamp);

	push	0
	push	OFFSET ?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasBarbarianCamp
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@HNCHANHC@HasBarbarianCamp?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 97   : 	Method(IsVisible);

	push	0
	push	OFFSET ?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisible
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_09OLGPEPPJ@IsVisible?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 98   : 	Method(IsActiveVisible);

	push	0
	push	OFFSET ?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsActiveVisible
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@CFACHEEE@IsActiveVisible?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 99   : 	Method(IsVisibleToWatchingHuman);

	push	0
	push	OFFSET ?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleToWatchingHuman
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BJ@FMJJGAJM@IsVisibleToWatchingHuman?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 100  : 	Method(IsAdjacentVisible);

	push	0
	push	OFFSET ?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentVisible
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@GICKPFNI@IsAdjacentVisible?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 101  : 	Method(IsAdjacentNonvisible);

	push	0
	push	OFFSET ?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonvisible
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BF@CNMKPADN@IsAdjacentNonvisible?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 102  : 	Method(IsAdjacentRevealed);

	push	0
	push	OFFSET ?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentRevealed
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@OBOIAPPP@IsAdjacentRevealed?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 103  : 	Method(IsAdjacentNonrevealed);

	push	0
	push	OFFSET ?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsAdjacentNonrevealed
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@DBMNPJAN@IsAdjacentNonrevealed?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 104  : 
; 105  : 	Method(RemoveGoody);

	push	0
	push	OFFSET ?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lRemoveGoody
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@LKMCGBMH@RemoveGoody?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 106  : 	Method(IsGoody);

	push	0
	push	OFFSET ?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsGoody
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07KKNGKPLI@IsGoody?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 107  : 	Method(IsRevealedGoody);

	push	0
	push	OFFSET ?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealedGoody
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@HAPEMDMB@IsRevealedGoody?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 108  : 
; 109  : 	Method(IsFriendlyTerritory);

	push	0
	push	OFFSET ?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFriendlyTerritory
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BE@IMNKPHIO@IsFriendlyTerritory?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 110  : 
; 111  : 	Method(IsCity);

	push	0
	push	OFFSET ?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsCity
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_06MKMOPHGH@IsCity?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 112  : 	Method(IsFriendlyCity);

	push	0
	push	OFFSET ?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFriendlyCity
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@JPKGCGMM@IsFriendlyCity?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 113  : 	Method(IsEnemyCity);

	push	0
	push	OFFSET ?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsEnemyCity
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@ICNFBAB@IsEnemyCity?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 114  : 	Method(IsBeingWorked);

	push	0
	push	OFFSET ?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBeingWorked
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@GHFLFPIL@IsBeingWorked?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 115  : 
; 116  : 	Method(IsUnit);

	push	0
	push	OFFSET ?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_06BJOJODJC@IsUnit?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 117  : 	Method(IsVisibleEnemyDefender);

	push	0
	push	OFFSET ?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyDefender
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@KJEJGOKA@IsVisibleEnemyDefender?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 118  : 	Method(GetNumDefenders);

	push	0
	push	OFFSET ?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumDefenders
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@GNAHEKAB@GetNumDefenders?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 119  : 	Method(GetNumVisibleEnemyDefenders);

	push	0
	push	OFFSET ?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisibleEnemyDefenders
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BM@GIKOKOLI@GetNumVisibleEnemyDefenders?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 120  : 	Method(GetNumVisiblePotentialEnemyDefenders);

	push	0
	push	OFFSET ?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0CF@KKFDFPEO@GetNumVisiblePotentialEnemyDefen@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 121  : 	Method(IsVisibleEnemyUnit);

	push	0
	push	OFFSET ?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleEnemyUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@FOLPLHDK@IsVisibleEnemyUnit?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 122  : 	Method(IsVisibleOtherUnit);

	push	0
	push	OFFSET ?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsVisibleOtherUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@LCFOEEGJ@IsVisibleOtherUnit?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 123  : 	Method(GetNumFriendlyUnitsOfType);

	push	0
	push	OFFSET ?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumFriendlyUnitsOfType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BK@MEHFJEJD@GetNumFriendlyUnitsOfType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 124  : 	Method(IsFighting);

	push	0
	push	OFFSET ?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFighting
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0L@MOBAIMGP@IsFighting?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 125  : 
; 126  : 	Method(IsRoute);

	push	0
	push	OFFSET ?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoute
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07DMDIHFEG@IsRoute?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 127  : 	Method(IsTradeRoute);

	push	0
	push	OFFSET ?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsTradeRoute
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@CIBMJEHN@IsTradeRoute?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 128  : 
; 129  : 	Method(IsValidDomainForLocation);

	push	0
	push	OFFSET ?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForLocation
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BJ@CLNJIBGO@IsValidDomainForLocation?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 130  : 	Method(IsValidDomainForAction);

	push	0
	push	OFFSET ?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsValidDomainForAction
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@IFEGDFCC@IsValidDomainForAction?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 131  : 	Method(IsImpassable);

	push	0
	push	OFFSET ?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsImpassable
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@MALFMDGK@IsImpassable?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 132  : 
; 133  : 	Method(GetX);

	push	0
	push	OFFSET ?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetX
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_04POGMJMFK@GetX?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 134  : 	Method(GetY);

	push	0
	push	OFFSET ?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetY
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_04OHHHKNBL@GetY?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 135  : 	Method(At);

	push	0
	push	OFFSET ?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lAt
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_02DKLFHNOI@At?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 136  : 	Method(GetPlotIndex);

	push	0
	push	OFFSET ?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlotIndex
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@MPDLKONJ@GetPlotIndex?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 137  : 	Method(GetLatitude);

	push	0
	push	OFFSET ?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetLatitude
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@KCMGIFE@GetLatitude?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 138  : 	Method(Area);

	push	0
	push	OFFSET ?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_04KPICECCB@Area?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 139  : 	Method(WaterArea);

	push	0
	push	OFFSET ?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lWaterArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_09CNIEIFHO@WaterArea?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 140  : 	Method(GetArea);

	push	0
	push	OFFSET ?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07GGOHINDE@GetArea?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 141  : 	Method(SetArea);

	push	0
	push	OFFSET ?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07JOBGLCOF@SetArea?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 142  : 	Method(GetFeatureVariety);

	push	0
	push	OFFSET ?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFeatureVariety
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@PNINJHCK@GetFeatureVariety?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 143  : 
; 144  : 	Method(GetOwnershipDuration);

	push	0
	push	OFFSET ?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetOwnershipDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BF@ENCCPLO@GetOwnershipDuration?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 145  : 	Method(IsOwnershipScore);

	push	0
	push	OFFSET ?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOwnershipScore
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@KOAOKKPA@IsOwnershipScore?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 146  : 	Method(SetOwnershipDuration);

	push	0
	push	OFFSET ?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetOwnershipDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BF@FNMPDJOJ@SetOwnershipDuration?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 147  : 	Method(ChangeOwnershipDuration);

	push	0
	push	OFFSET ?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeOwnershipDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BI@OJDEJCCM@ChangeOwnershipDuration?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 148  : 
; 149  : 	Method(GetImprovementDuration);

	push	0
	push	OFFSET ?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@JHAGDHHB@GetImprovementDuration?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 150  : 	Method(SetImprovementDuration);

	push	0
	push	OFFSET ?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@JGCIBAKO@SetImprovementDuration?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 151  : 	Method(ChangeImprovementDuration);

	push	0
	push	OFFSET ?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeImprovementDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BK@GBKBPNDO@ChangeImprovementDuration?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 152  : 
; 153  : 	Method(GetUpgradeProgress);

	push	0
	push	OFFSET ?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@PMPLKEDO@GetUpgradeProgress?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 154  : 	Method(GetUpgradeTimeLeft);

	push	0
	push	OFFSET ?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUpgradeTimeLeft
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@BBCMJJNG@GetUpgradeTimeLeft?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 155  : 
; 156  : 	Method(SetUpgradeProgress);

	push	0
	push	OFFSET ?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetUpgradeProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@GNBJCNG@SetUpgradeProgress?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 157  : 	Method(ChangeUpgradeProgress);

	push	0
	push	OFFSET ?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeUpgradeProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@BMLACKEG@ChangeUpgradeProgress?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 158  : 
; 159  : 	Method(GetCityRadiusCount);

	push	0
	push	OFFSET ?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityRadiusCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@FMKHJCLK@GetCityRadiusCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 160  : 	Method(IsCityRadius);

	push	0
	push	OFFSET ?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsCityRadius
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@OOBJPEOH@IsCityRadius?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 161  : 
; 162  : 	Method(IsStartingPlot);

	push	0
	push	OFFSET ?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsStartingPlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@BPOJGNHB@IsStartingPlot?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 163  : 	Method(SetStartingPlot);

	push	0
	push	OFFSET ?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetStartingPlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@GNONGEOP@SetStartingPlot?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 164  : 	Method(IsNEOfRiver);

	push	0
	push	OFFSET ?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsNEOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@IKKIAJPJ@IsNEOfRiver?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 165  : 	Method(SetNEOfRiver);

	push	0
	push	OFFSET ?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetNEOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@HOEJFBFB@SetNEOfRiver?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 166  : 	Method(IsWOfRiver);

	push	0
	push	OFFSET ?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0L@OCMOIDPM@IsWOfRiver?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 167  : 	Method(SetWOfRiver);

	push	0
	push	OFFSET ?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@NHCDHKOK@SetWOfRiver?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 168  : 	Method(IsNWOfRiver);

	push	0
	push	OFFSET ?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsNWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@IJOGDAO@IsNWOfRiver?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 169  : 	Method(SetNWOfRiver);

	push	0
	push	OFFSET ?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetNWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@PMHPDLKG@SetNWOfRiver?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 170  : 	Method(GetRiverEFlowDirection);

	push	0
	push	OFFSET ?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverEFlowDirection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@KPEJPCF@GetRiverEFlowDirection?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 171  : 	Method(GetRiverSEFlowDirection);

	push	0
	push	OFFSET ?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSEFlowDirection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BI@COCMCOFP@GetRiverSEFlowDirection?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 172  : 	Method(GetRiverSWFlowDirection);

	push	0
	push	OFFSET ?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverSWFlowDirection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BI@MCMIAAIB@GetRiverSWFlowDirection?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 173  : 
; 174  : 	Method(IsPotentialCityWork);

	push	0
	push	OFFSET ?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWork
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BE@ELJLKDMB@IsPotentialCityWork?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 175  : 	Method(IsPotentialCityWorkForArea);

	push	0
	push	OFFSET ?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPotentialCityWorkForArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BL@FNJICPCN@IsPotentialCityWorkForArea?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 176  : 
; 177  : 	Method(GetOwner);

	push	0
	push	OFFSET ?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetOwner
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_08BODJMJJB@GetOwner?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 178  : 	Method(SetOwner);

	push	0
	push	OFFSET ?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetOwner
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_08OPBFNKOM@SetOwner?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 179  : 	Method(GetPlotType);

	push	0
	push	OFFSET ?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlotType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@JBHEIOIB@GetPlotType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 180  : 	Method(IsFlatlands);

	push	0
	push	OFFSET ?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsFlatlands
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@CIOEIJGM@IsFlatlands?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 181  : 	Method(IsHills);

	push	0
	push	OFFSET ?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsHills
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07DCIJPOBB@IsHills?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 182  : 	Method(IsOpenGround);

	push	0
	push	OFFSET ?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsOpenGround
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@DKDGHAGP@IsOpenGround?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 183  : 	Method(IsRoughGround);

	push	0
	push	OFFSET ?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoughGround
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@DNIIDOJH@IsRoughGround?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 184  : 	Method(IsMountain);

	push	0
	push	OFFSET ?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsMountain
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0L@LNALPAOM@IsMountain?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 185  : 
; 186  : 	Method(SetPlotType);

	push	0
	push	OFFSET ?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetPlotType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@JOGKFIAC@SetPlotType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 187  : 	Method(GetResourceType);

	push	0
	push	OFFSET ?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetResourceType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@PNELCGHH@GetResourceType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 188  : 	Method(GetNonObsoleteResourceType);

	push	0
	push	OFFSET ?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNonObsoleteResourceType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BL@OCHONID@GetNonObsoleteResourceType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 189  : 	Method(SetResourceType);

	push	0
	push	OFFSET ?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetResourceType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@MPFNFEGO@SetResourceType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 190  : 	Method(GetNumResource);

	push	0
	push	OFFSET ?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@DLEJDHJD@GetNumResource?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 191  : 	Method(SetNumResource);

	push	0
	push	OFFSET ?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetNumResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@PFFHMNLP@SetNumResource?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 192  : 	Method(ChangeNumResource);

	push	0
	push	OFFSET ?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeNumResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@KPBOMALO@ChangeNumResource?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 193  : 
; 194  : 	Method(GetImprovementType);

	push	0
	push	OFFSET ?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetImprovementType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@NJODMBKI@GetImprovementType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 195  : 	Method(SetImprovementType);

	push	0
	push	OFFSET ?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@CDMJPHEA@SetImprovementType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 196  : 	Method(SetImprovementPillaged);

	push	0
	push	OFFSET ?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetImprovementPillaged
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@HIMINBGH@SetImprovementPillaged?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 197  : 	Method(GetRouteType);

	push	0
	push	OFFSET ?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRouteType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@MDDFIIGN@GetRouteType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 198  : 	Method(SetRouteType);

	push	0
	push	OFFSET ?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetRouteType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@LHILEECB@SetRouteType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 199  : 	Method(IsRoutePillaged);

	push	0
	push	OFFSET ?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRoutePillaged
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@BOKCMBNI@IsRoutePillaged?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 200  : 
; 201  : 	Method(GetPlotCity);

	push	0
	push	OFFSET ?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlotCity
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@PCNDGHAN@GetPlotCity?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 202  : 	Method(GetWorkingCity);

	push	0
	push	OFFSET ?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetWorkingCity
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@FJAEMPGB@GetWorkingCity?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 203  : 	Method(GetWorkingCityOverride);

	push	0
	push	OFFSET ?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetWorkingCityOverride
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BH@OOJOMMJK@GetWorkingCityOverride?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 204  : 	Method(GetReconCount);

	push	0
	push	OFFSET ?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetReconCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@FJEFAJPI@GetReconCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 205  : 	Method(GetRiverCrossingCount);

	push	0
	push	OFFSET ?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRiverCrossingCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@PHPNMIIM@GetRiverCrossingCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 206  : 	Method(GetYield);

	push	0
	push	OFFSET ?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_08NACOAIKN@GetYield?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 207  : 	Method(CalculateNatureYield);

	push	0
	push	OFFSET ?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateNatureYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BF@CBKOLKOI@CalculateNatureYield?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 208  : 	Method(CalculateBestNatureYield);

	push	0
	push	OFFSET ?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateBestNatureYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BJ@OAMDIALM@CalculateBestNatureYield?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 209  : 	Method(CalculateTotalBestNatureYield);

	push	0
	push	OFFSET ?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateTotalBestNatureYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BO@EHFPFGPL@CalculateTotalBestNatureYield?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 210  : 	Method(CalculateImprovementYieldChange);

	push	0
	push	OFFSET ?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateImprovementYieldChange
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0CA@FIAOIPPH@CalculateImprovementYieldChange?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 211  : 	Method(CalculateYield);

	push	0
	push	OFFSET ?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCalculateYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0P@CENIPKEL@CalculateYield?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 212  : 	Method(HasYield);

	push	0
	push	OFFSET ?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_08EOHKPHAI@HasYield?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 213  : 	Method(GetYieldWithBuild);

	push	0
	push	OFFSET ?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetYieldWithBuild
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@FCJPHHA@GetYieldWithBuild?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 214  : 
; 215  : 	Method(CountNumAirUnits);

	push	0
	push	OFFSET ?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCountNumAirUnits
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@ODLGAIAC@CountNumAirUnits?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 216  : 
; 217  : 	Method(GetFoundValue);

	push	0
	push	OFFSET ?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetFoundValue
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@GFNIBAIO@GetFoundValue?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 218  : 	Method(IsBestAdjacentFound);

	push	0
	push	OFFSET ?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBestAdjacentFound
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BE@MJJBFBHH@IsBestAdjacentFound?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 219  : 
; 220  : 	Method(GetPlayerCityRadiusCount);

	push	0
	push	OFFSET ?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetPlayerCityRadiusCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BJ@FHECNEHC@GetPlayerCityRadiusCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 221  : 	Method(IsPlayerCityRadius);

	push	0
	push	OFFSET ?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsPlayerCityRadius
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@FCCJINHM@IsPlayerCityRadius?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 222  : 
; 223  : 	Method(GetVisibilityCount);

	push	0
	push	OFFSET ?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetVisibilityCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@MEPELFEN@GetVisibilityCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 224  : 	Method(ChangeVisibilityCount);

	push	0
	push	OFFSET ?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeVisibilityCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@CELPDLDF@ChangeVisibilityCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 225  : 
; 226  : 	Method(GetRevealedOwner);

	push	0
	push	OFFSET ?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedOwner
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@OFCBENIO@GetRevealedOwner?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 227  : 	Method(GetRevealedTeam);

	push	0
	push	OFFSET ?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedTeam
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@GEFNGHGP@GetRevealedTeam?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 228  : 
; 229  : 	Method(IsRiverCrossing);

	push	0
	push	OFFSET ?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossing
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BA@MJKALLIG@IsRiverCrossing?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 230  : 	Method(IsRiverCrossingToPlot);

	push	0
	push	OFFSET ?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRiverCrossingToPlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@BDOILNLO@IsRiverCrossingToPlot?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 231  : 
; 232  : 	Method(IsRevealed);

	push	0
	push	OFFSET ?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsRevealed
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0L@KNACFKBL@IsRevealed?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 233  : 	Method(SetRevealed);

	push	0
	push	OFFSET ?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetRevealed
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@JIOPKDAN@SetRevealed?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 234  : 	Method(GetRevealedImprovementType);

	push	0
	push	OFFSET ?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedImprovementType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BL@PNNIAODD@GetRevealedImprovementType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 235  : 	Method(GetRevealedRouteType);

	push	0
	push	OFFSET ?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetRevealedRouteType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BF@IFAHMPDF@GetRevealedRouteType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 236  : 	Method(GetBuildProgress);

	push	0
	push	OFFSET ?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetBuildProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@JNKOGOND@GetBuildProgress?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 237  : 	Method(ChangeBuildProgress);

	push	0
	push	OFFSET ?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeBuildProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BE@JOFNMHNE@ChangeBuildProgress?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 238  : 
; 239  : 	Method(GetInvisibleVisibilityCount);

	push	0
	push	OFFSET ?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetInvisibleVisibilityCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BM@FGJPJMNO@GetInvisibleVisibilityCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 240  : 	Method(IsInvisibleVisible);

	push	0
	push	OFFSET ?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsInvisibleVisible
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@INIFKIEI@IsInvisibleVisible?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 241  : 	Method(ChangeInvisibleVisibilityCount);

	push	0
	push	OFFSET ?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lChangeInvisibleVisibilityCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BP@LBNFAPK@ChangeInvisibleVisibilityCount?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 242  : 
; 243  : 	Method(GetNumUnits);

	push	0
	push	OFFSET ?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumUnits
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0M@GNPEBAGL@GetNumUnits?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 244  : 	Method(GetUnit);

	push	0
	push	OFFSET ?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_07NHOHELCB@GetUnit?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 245  : 
; 246  : 	Method(GetNumLayerUnits);

	push	0
	push	OFFSET ?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetNumLayerUnits
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BB@CJPGAEMO@GetNumLayerUnits?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 247  : 	Method(GetLayerUnit);

	push	0
	push	OFFSET ?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetLayerUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0N@KMFKPML@GetLayerUnit?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 248  : 
; 249  : 	Method(GetScriptData);

	push	0
	push	OFFSET ?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetScriptData
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@IJPBDHCD@GetScriptData?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 250  : 	Method(SetScriptData);

	push	0
	push	OFFSET ?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetScriptData
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0O@PGOPIEFE@SetScriptData?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 251  : 
; 252  : 	Method(GetActiveFogOfWarMode);

	push	0
	push	OFFSET ?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetActiveFogOfWarMode
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@BKOPMAI@GetActiveFogOfWarMode?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 253  : 
; 254  : 	Method(IsImprovementPillaged);

	push	0
	push	OFFSET ?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsImprovementPillaged
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@NEIGEDBJ@IsImprovementPillaged?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 255  : 
; 256  : 	Method(CanSeePlot);

	push	0
	push	OFFSET ?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lCanSeePlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0L@GKHDLKJE@CanSeePlot?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 257  : 
; 258  : 	Method(GetContinentArtType);

	push	0
	push	OFFSET ?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetContinentArtType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BE@MEOCENPD@GetContinentArtType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 259  : 	Method(SetContinentArtType);

	push	0
	push	OFFSET ?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetContinentArtType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BE@GKMJANIP@SetContinentArtType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 260  : 
; 261  : 	Method(IsResourceConnectedByImprovement);

	push	0
	push	OFFSET ?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsResourceConnectedByImprovement
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0CB@KPLFICMP@IsResourceConnectedByImprovement@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 262  : 
; 263  : 	Method(IsBuildRemovesFeature);

	push	0
	push	OFFSET ?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lIsBuildRemovesFeature
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BG@PCIABHEK@IsBuildRemovesFeature?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 264  : 
; 265  : 	Method(GetArchaeologyArtifactType);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BL@ENHELHEO@GetArchaeologyArtifactType?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 266  : 	Method(GetArchaeologyArtifactEra);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactEra
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BK@EMCHHPLM@GetArchaeologyArtifactEra?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 267  : 	Method(GetArchaeologyArtifactPlayer1);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BO@MHAOIHEO@GetArchaeologyArtifactPlayer1?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 268  : 	Method(GetArchaeologyArtifactPlayer2);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactPlayer2
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BO@OMCDNEIN@GetArchaeologyArtifactPlayer2?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 269  : 	Method(GetArchaeologyArtifactWork);

	push	0
	push	OFFSET ?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetArchaeologyArtifactWork
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BL@OCKBDMDN@GetArchaeologyArtifactWork?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 270  : 	Method(HasWrittenArtifact);

	push	0
	push	OFFSET ?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lHasWrittenArtifact
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BD@NANOFFBN@HasWrittenArtifact?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 271  : 
; 272  : 	Method(GetCityPurchaseID);

	push	0
	push	OFFSET ?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lGetCityPurchaseID
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@LPDCGCFO@GetCityPurchaseID?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 273  : 	Method(SetCityPurchaseID);

	push	0
	push	OFFSET ?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ; CvLuaPlot::lSetCityPurchaseID
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH
	push	OFFSET ??_C@_0BC@JKDJOJEA@SetCityPurchaseID?$AA@
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 274  : }

	pop	ebp
	ret	0
?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z ENDP	; CvLuaPlot::PushMethods
_TEXT	ENDS
PUBLIC	?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::DefaultHandleMissingInstance
PUBLIC	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ; CvLuaPlot::HandleMissingInstance
; Function compile flags: /Odtp
;	COMDAT ?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z PROC ; CvLuaPlot::HandleMissingInstance, COMDAT

; 277  : {

	push	ebp
	mov	ebp, esp

; 278  : 	DefaultHandleMissingInstance(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::DefaultHandleMissingInstance
	add	esp, 4

; 279  : }

	pop	ebp
	ret	0
?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ENDP ; CvLuaPlot::HandleMissingInstance
_TEXT	ENDS
PUBLIC	??_C@_04HIOGLPHN@Plot?$AA@			; `string'
PUBLIC	?GetTypeName@CvLuaPlot@@SAPBDXZ			; CvLuaPlot::GetTypeName
;	COMDAT ??_C@_04HIOGLPHN@Plot?$AA@
CONST	SEGMENT
??_C@_04HIOGLPHN@Plot?$AA@ DB 'Plot', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GetTypeName@CvLuaPlot@@SAPBDXZ
_TEXT	SEGMENT
?GetTypeName@CvLuaPlot@@SAPBDXZ PROC			; CvLuaPlot::GetTypeName, COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp

; 283  : 	return "Plot";

	mov	eax, OFFSET ??_C@_04HIOGLPHN@Plot?$AA@

; 284  : }

	pop	ebp
	ret	0
?GetTypeName@CvLuaPlot@@SAPBDXZ ENDP			; CvLuaPlot::GetTypeName
_TEXT	ENDS
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
EXTRN	_lua_pushboolean:PROC
EXTRN	?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z:PROC ; CvPlot::canHaveFeature
EXTRN	_lua_tointeger:PROC
; Function compile flags: /Odtp
;	COMDAT ?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_featureType$ = -12					; size = 4
_canHasFeature$ = -5					; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCanHaveFeature, COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 292  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 293  : 
; 294  : 	const int featureType = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _featureType$[ebp], eax

; 295  : 	const bool canHasFeature = pkPlot->canHaveFeature((FeatureTypes)featureType);

	mov	edx, DWORD PTR _featureType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?canHaveFeature@CvPlot@@QBE_NW4FeatureTypes@@@Z ; CvPlot::canHaveFeature
	mov	BYTE PTR _canHasFeature$[ebp], al

; 296  : 
; 297  : 	lua_pushboolean(L, canHasFeature);

	movzx	eax, BYTE PTR _canHasFeature$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 298  : 
; 299  : 	return 1;

	mov	eax, 1

; 300  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lCanHaveFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCanHaveFeature
_TEXT	ENDS
EXTRN	_lua_pushinteger:PROC
; Function compile flags: /Odtp
;	COMDAT ?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_f$223660 = -9						; size = 1
_featureType$ = -8					; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFeatureType, COMDAT

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 304  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 305  : 
; 306  : 	const int featureType = (int)pkPlot->getFeatureType();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$223660[ebp], dl
	movsx	eax, BYTE PTR _f$223660[ebp]
	mov	DWORD PTR _featureType$[ebp], eax

; 307  : 	lua_pushinteger(L, featureType);

	mov	ecx, DWORD PTR _featureType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 308  : 
; 309  : 	return 1;

	mov	eax, 1

; 310  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFeatureType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetTerrainType, COMDAT

; 313  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 314  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 315  : 
; 316  : 	lua_pushinteger(L, pkPlot->getTerrainType());

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 317  : 
; 318  : 	return 1;

	mov	eax, 1

; 319  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetTerrainType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsRiver, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 323  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 324  : 
; 325  : 	lua_pushboolean(L, pkPlot->isRiver());

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+457]
	xor	eax, eax
	test	edx, edx
	setg	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 326  : 
; 327  : 	return 1;

	mov	eax, 1

; 328  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsRiver
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsWater, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 332  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 333  : 
; 334  : 	lua_pushboolean(L, pkPlot->isWater());

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 335  : 
; 336  : 	return 1;

	mov	eax, 1

; 337  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsWater@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsWater
_TEXT	ENDS
EXTRN	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:PROC ; CvPlot::setFeatureType
EXTRN	_luaL_optinteger:PROC
; Function compile flags: /Odtp
;	COMDAT ?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_featureType$ = -12					; size = 4
_variety$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetFeatureType, COMDAT

; 340  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 341  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 342  : 
; 343  : 	const int featureType = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _featureType$[ebp], eax

; 344  : 	const int variety = luaL_optinteger(L, 3, -1);

	push	-1
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _variety$[ebp], eax

; 345  : 
; 346  : 
; 347  : 	pkPlot->setFeatureType((FeatureTypes)featureType, variety);

	mov	eax, DWORD PTR _variety$[ebp]
	push	eax
	mov	ecx, DWORD PTR _featureType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 348  : 
; 349  : 	return 0;

	xor	eax, eax

; 350  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lSetFeatureType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetFeatureType
_TEXT	ENDS
EXTRN	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z:PROC ; CvPlot::setTerrainType
EXTRN	_lua_toboolean:PROC
; Function compile flags: /Odtp
;	COMDAT ?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_terrainType$ = -16					; size = 4
_bRebuildGraphics$ = -9					; size = 1
_pkPlot$ = -8						; size = 4
_bRecalculate$ = -1					; size = 1
_L$ = 8							; size = 4
?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetTerrainType, COMDAT

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 354  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 355  : 
; 356  : 	const int terrainType = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _terrainType$[ebp], eax

; 357  : 	const bool bRecalculate = lua_toboolean(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR _bRecalculate$[ebp], al

; 358  : 	const bool bRebuildGraphics = lua_toboolean(L, 4);

	push	4
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bRebuildGraphics$[ebp], dl

; 359  : 
; 360  : 	pkPlot->setTerrainType((TerrainTypes)terrainType, bRecalculate, bRebuildGraphics);

	movzx	eax, BYTE PTR _bRebuildGraphics$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bRecalculate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _terrainType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType

; 361  : 
; 362  : 	return 0;

	xor	eax, eax

; 363  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lSetTerrainType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetTerrainType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bDoesNotExist$ = -1					; size = 1
_L$ = 8							; size = 4
?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsNone, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 375  : #ifdef AUI_WARNING_FIXES
; 376  : 	const bool bDoesNotExist = (GetInstance(L, 1, false) == NULL);
; 377  : 	lua_pushboolean(L, bDoesNotExist ? 1 : 0);
; 378  : #else
; 379  : 	const bool bDoesNotExist = (GetInstance(L, false) == NULL);

	push	1
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	test	eax, eax
	sete	cl
	mov	BYTE PTR _bDoesNotExist$[ebp], cl

; 380  : 	lua_pushboolean(L, bDoesNotExist);

	movzx	edx, BYTE PTR _bDoesNotExist$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 381  : #endif
; 382  : 
; 383  : 	return 1;

	mov	eax, 1

; 384  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsNone@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsNone
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
EXTRN	?erase@CvPlot@@QAEX_N@Z:PROC			; CvPlot::erase
; Function compile flags: /Odtp
;	COMDAT ?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lErase, COMDAT

; 388  : {

	push	ebp
	mov	ebp, esp

; 389  : 	return BasicLuaMethod(L, &CvPlot::erase);

	push	OFFSET ?erase@CvPlot@@QAEX_N@Z		; CvPlot::erase
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 390  : }

	pop	ebp
	ret	0
?lErase@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lErase
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Odtp
;	COMDAT ?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetTeam, COMDAT

; 395  : {

	push	ebp
	mov	ebp, esp

; 396  : 	return BasicLuaMethod(L, &CvPlot::getTeam);

	push	OFFSET ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ; CvPlot::getTeam
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>
	add	esp, 8

; 397  : }

	pop	ebp
	ret	0
?lGetTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetTeam
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>
EXTRN	?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z:PROC	; CvPlot::nukeExplosion
; Function compile flags: /Odtp
;	COMDAT ?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lNukeExplosion, COMDAT

; 402  : {

	push	ebp
	mov	ebp, esp

; 403  : 	return BasicLuaMethod(L, &CvPlot::nukeExplosion);

	push	OFFSET ?nukeExplosion@CvPlot@@QAEXHPAVCvUnit@@@Z ; CvPlot::nukeExplosion
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>
	add	esp, 8

; 404  : }

	pop	ebp
	ret	0
?lNukeExplosion@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lNukeExplosion
_TEXT	ENDS
EXTRN	?updateFog@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateFog
; Function compile flags: /Odtp
;	COMDAT ?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lUpdateFog, COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp

; 410  : 	return BasicLuaMethod(L, &CvPlot::updateFog);

	push	OFFSET ?updateFog@CvPlot@@QAEX_N@Z	; CvPlot::updateFog
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 411  : }

	pop	ebp
	ret	0
?lUpdateFog@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lUpdateFog
_TEXT	ENDS
PUBLIC	?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
EXTRN	?updateVisibility@CvPlot@@QAEXXZ:PROC		; CvPlot::updateVisibility
; Function compile flags: /Odtp
;	COMDAT ?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lUpdateVisibility, COMDAT

; 416  : {

	push	ebp
	mov	ebp, esp

; 417  : 	return BasicLuaMethod(L, &CvPlot::updateVisibility);

	push	OFFSET ?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
	add	esp, 8

; 418  : }

	pop	ebp
	ret	0
?lUpdateVisibility@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lUpdateVisibility
_TEXT	ENDS
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::GetInstance
EXTRN	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z:PROC ; CvPlot::isAdjacentToArea
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bResult$ = -9						; size = 1
_pkArea$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentToArea, COMDAT

; 422  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 423  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 424  : 	CvArea* pkArea = CvLuaArea::GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkArea$[ebp], eax

; 425  : 
; 426  : 	const bool bResult = pkPlot->isAdjacentToArea(pkArea);

	mov	edx, DWORD PTR _pkArea$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z ; CvPlot::isAdjacentToArea
	mov	BYTE PTR _bResult$[ebp], al

; 427  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 428  : 
; 429  : 	return 1;

	mov	eax, 1

; 430  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsAdjacentToArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentToArea
_TEXT	ENDS
EXTRN	?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z:PROC	; CvPlot::shareAdjacentArea
; Function compile flags: /Odtp
;	COMDAT ?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bResult$ = -9						; size = 1
_pkPlot2$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lShareAdjacentArea, COMDAT

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 435  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 436  : 	CvPlot* pkPlot2 = GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot2$[ebp], eax

; 437  : 
; 438  : 	const bool bResult = pkPlot->shareAdjacentArea(pkPlot2);

	mov	edx, DWORD PTR _pkPlot2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?shareAdjacentArea@CvPlot@@QBE_NPBV1@@Z	; CvPlot::shareAdjacentArea
	mov	BYTE PTR _bResult$[ebp], al

; 439  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 440  : 
; 441  : 	return 1;

	mov	eax, 1

; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lShareAdjacentArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lShareAdjacentArea
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentToLand, COMDAT

; 446  : {

	push	ebp
	mov	ebp, esp

; 447  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentToLand);

	push	OFFSET ?isAdjacentToLand@CvPlot@@QBE_NXZ ; CvPlot::isAdjacentToLand
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 448  : }

	pop	ebp
	ret	0
?lIsAdjacentToLand@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentToLand
_TEXT	ENDS
EXTRN	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ:PROC	; CvPlot::isAdjacentToShallowWater
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentToShallowWater, COMDAT

; 452  : {

	push	ebp
	mov	ebp, esp

; 453  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentToShallowWater);

	push	OFFSET ?isAdjacentToShallowWater@CvPlot@@QBE_NXZ ; CvPlot::isAdjacentToShallowWater
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 454  : }

	pop	ebp
	ret	0
?lIsAdjacentToShallowWater@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentToShallowWater
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
; Function compile flags: /Odtp
;	COMDAT ?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsCoastalLand, COMDAT

; 458  : {

	push	ebp
	mov	ebp, esp

; 459  : 	return BasicLuaMethod(L, &CvPlot::isCoastalLand);

	push	OFFSET ?isCoastalLand@CvPlot@@QBE_NH@Z	; CvPlot::isCoastalLand
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>
	add	esp, 8

; 460  : }

	pop	ebp
	ret	0
?lIsCoastalLand@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsCoastalLand
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>
EXTRN	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::isWithinTeamCityRadius
; Function compile flags: /Odtp
;	COMDAT ?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsWithinTeamCityRadius, COMDAT

; 465  : {

	push	ebp
	mov	ebp, esp

; 466  : 	return BasicLuaMethod(L, &CvPlot::isWithinTeamCityRadius);

	push	OFFSET ?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>
	add	esp, 8

; 467  : }

	pop	ebp
	ret	0
?lIsWithinTeamCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsWithinTeamCityRadius
_TEXT	ENDS
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
; Function compile flags: /Odtp
;	COMDAT ?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsLake, COMDAT

; 471  : {

	push	ebp
	mov	ebp, esp

; 472  : 	return BasicLuaMethod(L, &CvPlot::isLake);

	push	OFFSET ?isLake@CvPlot@@QBE_NXZ		; CvPlot::isLake
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 473  : }

	pop	ebp
	ret	0
?lIsLake@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsLake
_TEXT	ENDS
EXTRN	?isFreshWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFreshWater
; Function compile flags: /Odtp
;	COMDAT ?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFreshWater, COMDAT

; 477  : {

	push	ebp
	mov	ebp, esp

; 478  : 	return BasicLuaMethod(L, &CvPlot::isFreshWater);

	push	OFFSET ?isFreshWater@CvPlot@@QBE_NXZ	; CvPlot::isFreshWater
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 479  : }

	pop	ebp
	ret	0
?lIsFreshWater@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFreshWater
_TEXT	ENDS
EXTRN	?isRiverSide@CvPlot@@QBE_NXZ:PROC		; CvPlot::isRiverSide
; Function compile flags: /Odtp
;	COMDAT ?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRiverSide, COMDAT

; 484  : {

	push	ebp
	mov	ebp, esp

; 485  : 	return BasicLuaMethod(L, &CvPlot::isRiverSide);

	push	OFFSET ?isRiverSide@CvPlot@@QBE_NXZ	; CvPlot::isRiverSide
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 486  : }

	pop	ebp
	ret	0
?lIsRiverSide@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRiverSide
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
EXTRN	?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverConnection
; Function compile flags: /Odtp
;	COMDAT ?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRiverConnection, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	return BasicLuaMethod(L, &CvPlot::isRiverConnection);

	push	OFFSET ?isRiverConnection@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverConnection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
	add	esp, 8

; 492  : }

	pop	ebp
	ret	0
?lIsRiverConnection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRiverConnection
_TEXT	ENDS
EXTRN	?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossingFlowClockwise
; Function compile flags: /Odtp
;	COMDAT ?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bResult$ = -9						; size = 1
_eDirection$ = -8					; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsRiverCrossingFlowClockwise, COMDAT

; 495  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 496  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 497  : 	const DirectionTypes eDirection = (DirectionTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eDirection$[ebp], eax

; 498  : 	const bool bResult = pkPlot->isRiverCrossingFlowClockwise(eDirection);

	mov	edx, DWORD PTR _eDirection$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isRiverCrossingFlowClockwise@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossingFlowClockwise
	mov	BYTE PTR _bResult$[ebp], al

; 499  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 500  : 	return 1;

	mov	eax, 1

; 501  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsRiverCrossingFlowClockwise@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsRiverCrossingFlowClockwise
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
EXTRN	?getNearestLandArea@CvPlot@@QBEHXZ:PROC		; CvPlot::getNearestLandArea
; Function compile flags: /Odtp
;	COMDAT ?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNearestLandArea, COMDAT

; 505  : {

	push	ebp
	mov	ebp, esp

; 506  : 	return BasicLuaMethod(L, &CvPlot::getNearestLandArea);

	push	OFFSET ?getNearestLandArea@CvPlot@@QBEHXZ ; CvPlot::getNearestLandArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 507  : }

	pop	ebp
	ret	0
?lGetNearestLandArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNearestLandArea
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
EXTRN	?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z:PROC	; CvPlot::seeFromLevel
; Function compile flags: /Odtp
;	COMDAT ?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSeeFromLevel, COMDAT

; 511  : {

	push	ebp
	mov	ebp, esp

; 512  : 	return BasicLuaMethod(L, &CvPlot::seeFromLevel);

	push	OFFSET ?seeFromLevel@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::seeFromLevel
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 513  : }

	pop	ebp
	ret	0
?lSeeFromLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSeeFromLevel
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
EXTRN	?getNearestLandPlot@CvPlot@@QBEPAV1@XZ:PROC	; CvPlot::getNearestLandPlot
; Function compile flags: /Odtp
;	COMDAT ?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkNearestPlot$ = -8					; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNearestLandPlot, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 518  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 519  : 	CvPlot* pkNearestPlot = pkPlot->getNearestLandPlot();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getNearestLandPlot@CvPlot@@QBEPAV1@XZ	; CvPlot::getNearestLandPlot
	mov	DWORD PTR _pkNearestPlot$[ebp], eax

; 520  : 	CvLuaPlot::Push(L, pkNearestPlot);

	mov	ecx, DWORD PTR _pkNearestPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 521  : 	return 1;

	mov	eax, 1

; 522  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNearestLandPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNearestLandPlot
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>
EXTRN	?seeThroughLevel@CvPlot@@QBEH_N@Z:PROC		; CvPlot::seeThroughLevel
; Function compile flags: /Odtp
;	COMDAT ?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSeeThroughLevel, COMDAT

; 526  : {

	push	ebp
	mov	ebp, esp

; 527  : 	return BasicLuaMethod(L, &CvPlot::seeThroughLevel);

	push	OFFSET ?seeThroughLevel@CvPlot@@QBEH_N@Z ; CvPlot::seeThroughLevel
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>
	add	esp, 8

; 528  : }

	pop	ebp
	ret	0
?lSeeThroughLevel@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSeeThroughLevel
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>
EXTRN	?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z:PROC ; CvPlot::canHaveResource
; Function compile flags: /Odtp
;	COMDAT ?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCanHaveResource, COMDAT

; 532  : {

	push	ebp
	mov	ebp, esp

; 533  : 	return BasicLuaMethod(L, &CvPlot::canHaveResource);

	push	OFFSET ?canHaveResource@CvPlot@@QBE_NW4ResourceTypes@@_N@Z ; CvPlot::canHaveResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>
	add	esp, 8

; 534  : }

	pop	ebp
	ret	0
?lCanHaveResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCanHaveResource
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>
EXTRN	?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::canHaveImprovement
; Function compile flags: /Odtp
;	COMDAT ?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCanHaveImprovement, COMDAT

; 538  : {

	push	ebp
	mov	ebp, esp

; 539  : 	return BasicLuaMethod(L, &CvPlot::canHaveImprovement);

	push	OFFSET ?canHaveImprovement@CvPlot@@QBE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::canHaveImprovement
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>
	add	esp, 8

; 540  : }

	pop	ebp
	ret	0
?lCanHaveImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCanHaveImprovement
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>
EXTRN	?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z:PROC ; CvPlot::canBuild
; Function compile flags: /Odtp
;	COMDAT ?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lCanBuild, COMDAT

; 544  : {

	push	ebp
	mov	ebp, esp

; 545  : 	return BasicLuaMethod(L, &CvPlot::canBuild);

	push	OFFSET ?canBuild@CvPlot@@QBE_NW4BuildTypes@@W4PlayerTypes@@_N2@Z ; CvPlot::canBuild
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>
	add	esp, 8

; 546  : }

	pop	ebp
	ret	0
?lCanBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lCanBuild
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
EXTRN	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getBuildTime
; Function compile flags: /Odtp
;	COMDAT ?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBuildTime, COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp

; 551  : 	return BasicLuaMethod(L, &CvPlot::getBuildTime);

	push	OFFSET ?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
	add	esp, 8

; 552  : }

	pop	ebp
	ret	0
?lGetBuildTime@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBuildTime
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>
EXTRN	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z:PROC ; CvPlot::getBuildTurnsLeft
; Function compile flags: /Odtp
;	COMDAT ?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBuildTurnsLeft, COMDAT

; 556  : {

	push	ebp
	mov	ebp, esp

; 557  : 	return BasicLuaMethod(L, &CvPlot::getBuildTurnsLeft);

	push	OFFSET ?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ; CvPlot::getBuildTurnsLeft
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>
	add	esp, 8

; 558  : }

	pop	ebp
	ret	0
?lGetBuildTurnsLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBuildTurnsLeft
_TEXT	ENDS
EXTRN	?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getBuildTurnsTotal
; Function compile flags: /Odtp
;	COMDAT ?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetBuildTurnsTotal, COMDAT

; 562  : {

	push	ebp
	mov	ebp, esp

; 563  : 	return BasicLuaMethod(L, &CvPlot::getBuildTurnsTotal);

	push	OFFSET ?getBuildTurnsTotal@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTurnsTotal
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
	add	esp, 8

; 564  : }

	pop	ebp
	ret	0
?lGetBuildTurnsTotal@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetBuildTurnsTotal
_TEXT	ENDS
EXTRN	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z:PROC ; CvPlot::getFeatureProduction
; Function compile flags: /Odtp
;	COMDAT ?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_ePlayer$ = -20						; size = 4
_eBuild$ = -16						; size = 4
_pCity$ = -12						; size = 4
_iResult$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetFeatureProduction, COMDAT

; 568  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 569  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 570  : 	const BuildTypes eBuild = (BuildTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eBuild$[ebp], eax

; 571  : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$[ebp], eax

; 572  : 	CvCity* pCity;
; 573  : 
; 574  : 	const int iResult = pkPlot->getFeatureProduction(eBuild, ePlayer, &pCity);

	lea	eax, DWORD PTR _pCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
	mov	DWORD PTR _iResult$[ebp], eax

; 575  : 
; 576  : 	lua_pushinteger(L, iResult);

	mov	eax, DWORD PTR _iResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 577  : 	return 1;

	mov	eax, 1

; 578  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetFeatureProduction@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetFeatureProduction
_TEXT	ENDS
EXTRN	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z:PROC ; CvPlot::getFeatureFood
; Function compile flags: /Odtp
;	COMDAT ?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_ePlayer$ = -20						; size = 4
_eBuild$ = -16						; size = 4
_pCity$ = -12						; size = 4
_iResult$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFeatureFood, COMDAT

; 583  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 584  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 585  : 	const BuildTypes eBuild = (BuildTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eBuild$[ebp], eax

; 586  : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$[ebp], eax

; 587  : 	CvCity* pCity;
; 588  : 
; 589  : 	const int iResult = pkPlot->getFeatureFood(eBuild, ePlayer, &pCity);

	lea	eax, DWORD PTR _pCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getFeatureFood@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureFood
	mov	DWORD PTR _iResult$[ebp], eax

; 590  : 
; 591  : 	lua_pushinteger(L, iResult);

	mov	eax, DWORD PTR _iResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 592  : 	return 1;

	mov	eax, 1

; 593  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetFeatureFood@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFeatureFood
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
xdata$x	ENDS
;	COMDAT ?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T223740 = -48						; size = 4
_bTestCanMove$ = -41					; size = 1
_pkUnit$ = -40						; size = 8
_eOwner$ = -32						; size = 4
_bTestAtWar$ = -26					; size = 1
_bTestPotentialEnemy$ = -25				; size = 1
_eAttackingPlayer$ = -24				; size = 4
_pkAttacker$ = -20					; size = 4
_pkPlot$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBestDefender, COMDAT

; 598  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 599  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 600  : 	const PlayerTypes eOwner = (PlayerTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eOwner$[ebp], eax

; 601  : 	const PlayerTypes eAttackingPlayer = (PlayerTypes)lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eAttackingPlayer$[ebp], eax

; 602  : 	CvUnit* pkAttacker = CvLuaUnit::GetInstance(L, 4, false);

	push	0
	push	4
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkAttacker$[ebp], eax

; 603  : 	const bool bTestAtWar = luaL_optint(L, 5, 0);

	push	0
	push	5
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bTestAtWar$[ebp], dl

; 604  : 	const bool bTestPotentialEnemy = luaL_optint(L, 6, 0);

	push	0
	push	6
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	test	eax, eax
	setne	cl
	mov	BYTE PTR _bTestPotentialEnemy$[ebp], cl

; 605  : 	const bool bTestCanMove = luaL_optint(L, 7, 0);

	push	0
	push	7
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	test	eax, eax
	setne	al
	mov	BYTE PTR _bTestCanMove$[ebp], al

; 606  : 	UnitHandle pkUnit = pkPlot->getBestDefender(eOwner, eAttackingPlayer, pkAttacker, bTestAtWar, bTestPotentialEnemy, bTestCanMove);

	push	0
	movzx	ecx, BYTE PTR _bTestCanMove$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bTestPotentialEnemy$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bTestAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eAttackingPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOwner$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pkUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 607  : 	CvLuaUnit::Push(L, pkUnit.pointer());

	mov	edx, DWORD PTR _pkUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
	add	esp, 8

; 608  : 	return 1;

	mov	DWORD PTR $T223740[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pkUnit$[ebp], 0
	je	SHORT $LN7@lGetBestDe
	mov	ecx, DWORD PTR _pkUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN7@lGetBestDe:
	mov	eax, DWORD PTR $T223740[ebp]

; 609  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _pkUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?lGetBestDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBestDefender
EXTRN	?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ:PROC	; CvPlot::getSelectedUnit
; Function compile flags: /Odtp
;	COMDAT ?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetSelectedUnit, COMDAT

; 613  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 614  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 615  : 	CvUnit* pkUnit = pkPlot->getSelectedUnit();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getSelectedUnit@CvPlot@@QAEPAVCvUnit@@XZ ; CvPlot::getSelectedUnit
	mov	DWORD PTR _pkUnit$[ebp], eax

; 616  : 	CvLuaUnit::Push(L, pkUnit);

	mov	ecx, DWORD PTR _pkUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
	add	esp, 8

; 617  : 	return 1;

	mov	eax, 1

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetSelectedUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetSelectedUnit
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
EXTRN	?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getUnitPower
; Function compile flags: /Odtp
;	COMDAT ?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetUnitPower, COMDAT

; 622  : {

	push	ebp
	mov	ebp, esp

; 623  : 	return BasicLuaMethod(L, &CvPlot::getUnitPower);

	push	OFFSET ?getUnitPower@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getUnitPower
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 624  : }

	pop	ebp
	ret	0
?lGetUnitPower@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetUnitPower
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
; Function compile flags: /Odtp
;	COMDAT ?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lDefenseModifier, COMDAT

; 629  : {

	push	ebp
	mov	ebp, esp

; 630  : 	return BasicLuaMethod(L, &CvPlot::defenseModifier);

	push	OFFSET ?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>
	add	esp, 8

; 631  : }

	pop	ebp
	ret	0
?lDefenseModifier@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lDefenseModifier
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>
EXTRN	?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z:PROC ; CvPlot::movementCost
; Function compile flags: /Odtp
;	COMDAT ?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lMovementCost, COMDAT

; 635  : {

	push	ebp
	mov	ebp, esp

; 636  : 	return BasicLuaMethod(L, &CvPlot::movementCost);

	push	OFFSET ?movementCost@CvPlot@@QBEHPBVCvUnit@@PBV1@H@Z ; CvPlot::movementCost
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>
	add	esp, 8

; 637  : }

	pop	ebp
	ret	0
?lMovementCost@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lMovementCost
_TEXT	ENDS
EXTRN	?getExtraMovePathCost@CvPlot@@QBEHXZ:PROC	; CvPlot::getExtraMovePathCost
; Function compile flags: /Odtp
;	COMDAT ?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetExtraMovePathCost, COMDAT

; 642  : {

	push	ebp
	mov	ebp, esp

; 643  : 	return BasicLuaMethod(L, &CvPlot::getExtraMovePathCost);

	push	OFFSET ?getExtraMovePathCost@CvPlot@@QBEHXZ ; CvPlot::getExtraMovePathCost
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 644  : }

	pop	ebp
	ret	0
?lGetExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetExtraMovePathCost
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
EXTRN	?changeExtraMovePathCost@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeExtraMovePathCost
; Function compile flags: /Odtp
;	COMDAT ?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeExtraMovePathCost, COMDAT

; 648  : {

	push	ebp
	mov	ebp, esp

; 649  : 	return BasicLuaMethod(L, &CvPlot::changeExtraMovePathCost);

	push	OFFSET ?changeExtraMovePathCost@CvPlot@@QAEXH@Z ; CvPlot::changeExtraMovePathCost
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 650  : }

	pop	ebp
	ret	0
?lChangeExtraMovePathCost@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeExtraMovePathCost
_TEXT	ENDS
EXTRN	?isAdjacentOwned@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentOwned
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentOwned, COMDAT

; 655  : {

	push	ebp
	mov	ebp, esp

; 656  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentOwned);

	push	OFFSET ?isAdjacentOwned@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentOwned
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 657  : }

	pop	ebp
	ret	0
?lIsAdjacentOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentOwned
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>
EXTRN	?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z:PROC ; CvPlot::isAdjacentPlayer
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentPlayer, COMDAT

; 661  : {

	push	ebp
	mov	ebp, esp

; 662  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentPlayer);

	push	OFFSET ?isAdjacentPlayer@CvPlot@@QBE_NW4PlayerTypes@@_N@Z ; CvPlot::isAdjacentPlayer
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>
	add	esp, 8

; 663  : }

	pop	ebp
	ret	0
?lIsAdjacentPlayer@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentPlayer
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>
EXTRN	?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentTeam
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentTeam, COMDAT

; 667  : {

	push	ebp
	mov	ebp, esp

; 668  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentTeam);

	push	OFFSET ?isAdjacentTeam@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentTeam
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>
	add	esp, 8

; 669  : }

	pop	ebp
	ret	0
?lIsAdjacentTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentTeam
_TEXT	ENDS
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
; Function compile flags: /Odtp
;	COMDAT ?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsOwned, COMDAT

; 673  : {

	push	ebp
	mov	ebp, esp

; 674  : 	return BasicLuaMethod(L, &CvPlot::isOwned);

	push	OFFSET ?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 675  : }

	pop	ebp
	ret	0
?lIsOwned@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsOwned
_TEXT	ENDS
EXTRN	?isBarbarian@CvPlot@@QBE_NXZ:PROC		; CvPlot::isBarbarian
; Function compile flags: /Odtp
;	COMDAT ?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsBarbarian, COMDAT

; 679  : {

	push	ebp
	mov	ebp, esp

; 680  : 	return BasicLuaMethod(L, &CvPlot::isBarbarian);

	push	OFFSET ?isBarbarian@CvPlot@@QBE_NXZ	; CvPlot::isBarbarian
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 681  : }

	pop	ebp
	ret	0
?lIsBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsBarbarian
_TEXT	ENDS
EXTRN	?isRevealedBarbarian@CvPlot@@QBE_NXZ:PROC	; CvPlot::isRevealedBarbarian
; Function compile flags: /Odtp
;	COMDAT ?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsRevealedBarbarian, COMDAT

; 685  : {

	push	ebp
	mov	ebp, esp

; 686  : 	return BasicLuaMethod(L, &CvPlot::isRevealedBarbarian);

	push	OFFSET ?isRevealedBarbarian@CvPlot@@QBE_NXZ ; CvPlot::isRevealedBarbarian
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 687  : }

	pop	ebp
	ret	0
?lIsRevealedBarbarian@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsRevealedBarbarian
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
EXTRN	?HasBarbarianCamp@CvPlot@@QAE_NXZ:PROC		; CvPlot::HasBarbarianCamp
; Function compile flags: /Odtp
;	COMDAT ?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lHasBarbarianCamp, COMDAT

; 690  : {

	push	ebp
	mov	ebp, esp

; 691  : 	return BasicLuaMethod(L, &CvPlot::HasBarbarianCamp);

	push	OFFSET ?HasBarbarianCamp@CvPlot@@QAE_NXZ ; CvPlot::HasBarbarianCamp
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 692  : }

	pop	ebp
	ret	0
?lHasBarbarianCamp@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lHasBarbarianCamp
_TEXT	ENDS
EXTRN	?isDebugMode@CvGame@@QBE_NXZ:PROC		; CvGame::isDebugMode
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z:PROC	; luaL_optbool
; Function compile flags: /Odtp
;	COMDAT ?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T223810 = -17						; size = 1
$T223797 = -16						; size = 4
_bDebug$ = -9						; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsVisible, COMDAT

; 696  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 697  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 698  : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 699  : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 700  : 
; 701  : 	lua_pushboolean(L, pkPlot->isVisible(eTeam, bDebug));

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	je	SHORT $LN5@lIsVisible
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223797[ebp], ecx
	mov	ecx, DWORD PTR $T223797[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@lIsVisible
	mov	BYTE PTR $T223810[ebp], 1
	jmp	SHORT $LN6@lIsVisible
	jmp	SHORT $LN6@lIsVisible
$LN5@lIsVisible:
	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN10@lIsVisible
	mov	BYTE PTR $T223810[ebp], 0
	jmp	SHORT $LN6@lIsVisible
$LN10@lIsVisible:
	mov	eax, DWORD PTR _pkPlot$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T223810[ebp], cl
$LN6@lIsVisible:
	movzx	edx, BYTE PTR $T223810[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 702  : 	return 1;

	mov	eax, 1

; 703  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsVisible
_TEXT	ENDS
EXTRN	?isActiveVisible@CvPlot@@QBE_N_N@Z:PROC		; CvPlot::isActiveVisible
EXTRN	?isActiveVisible@CvPlot@@QBE_NXZ:PROC		; CvPlot::isActiveVisible
; Function compile flags: /Odtp
;	COMDAT ?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bDebug$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsActiveVisible, COMDAT

; 707  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 708  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 709  : 	const bool bDebug = luaL_optbool(L, 2, false);

	push	0
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 710  : 
; 711  : 	if (!bDebug)

	movzx	edx, BYTE PTR _bDebug$[ebp]
	test	edx, edx
	jne	SHORT $LN2@lIsActiveV

; 712  : 		lua_pushboolean(L, pkPlot->isActiveVisible());

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isActiveVisible@CvPlot@@QBE_NXZ	; CvPlot::isActiveVisible
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 713  : 	else

	jmp	SHORT $LN1@lIsActiveV
$LN2@lIsActiveV:

; 714  : 		lua_pushboolean(L, pkPlot->isActiveVisible(true));

	push	1
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isActiveVisible@CvPlot@@QBE_N_N@Z	; CvPlot::isActiveVisible
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8
$LN1@lIsActiveV:

; 715  : 
; 716  : 	return 1;

	mov	eax, 1

; 717  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsActiveVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsActiveVisible
_TEXT	ENDS
EXTRN	?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ:PROC	; CvPlot::isVisibleToWatchingHuman
; Function compile flags: /Odtp
;	COMDAT ?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleToWatchingHuman, COMDAT

; 721  : {

	push	ebp
	mov	ebp, esp

; 722  : 	return BasicLuaMethod(L, &CvPlot::isVisibleToWatchingHuman);

	push	OFFSET ?isVisibleToWatchingHuman@CvPlot@@QBE_NXZ ; CvPlot::isVisibleToWatchingHuman
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 723  : }

	pop	ebp
	ret	0
?lIsVisibleToWatchingHuman@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleToWatchingHuman
_TEXT	ENDS
EXTRN	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentVisible
EXTRN	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentVisible
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bDebug$ = -9						; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsAdjacentVisible, COMDAT

; 727  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 728  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 729  : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 730  : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 731  : 
; 732  : 	if (!bDebug)

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	jne	SHORT $LN2@lIsAdjacen

; 733  : 		lua_pushboolean(L, pkPlot->isAdjacentVisible(eTeam));

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentVisible
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 734  : 	else

	jmp	SHORT $LN1@lIsAdjacen
$LN2@lIsAdjacen:

; 735  : 		lua_pushboolean(L, pkPlot->isAdjacentVisible(eTeam, true));

	push	1
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentVisible
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8
$LN1@lIsAdjacen:

; 736  : 
; 737  : 	return 1;

	mov	eax, 1

; 738  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsAdjacentVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsAdjacentVisible
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
EXTRN	?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentNonvisible
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentNonvisible, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp

; 743  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentNonvisible);

	push	OFFSET ?isAdjacentNonvisible@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonvisible
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 744  : }

	pop	ebp
	ret	0
?lIsAdjacentNonvisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentNonvisible
_TEXT	ENDS
EXTRN	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentRevealed
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentRevealed, COMDAT

; 748  : {

	push	ebp
	mov	ebp, esp

; 749  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentRevealed);

	push	OFFSET ?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentRevealed
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 750  : }

	pop	ebp
	ret	0
?lIsAdjacentRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentRevealed
_TEXT	ENDS
EXTRN	?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentNonrevealed
; Function compile flags: /Odtp
;	COMDAT ?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsAdjacentNonrevealed, COMDAT

; 754  : {

	push	ebp
	mov	ebp, esp

; 755  : 	return BasicLuaMethod(L, &CvPlot::isAdjacentNonrevealed);

	push	OFFSET ?isAdjacentNonrevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentNonrevealed
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 756  : }

	pop	ebp
	ret	0
?lIsAdjacentNonrevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsAdjacentNonrevealed
_TEXT	ENDS
EXTRN	?removeGoody@CvPlot@@QAEXXZ:PROC		; CvPlot::removeGoody
; Function compile flags: /Odtp
;	COMDAT ?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lRemoveGoody, COMDAT

; 761  : {

	push	ebp
	mov	ebp, esp

; 762  : 	return BasicLuaMethod(L, &CvPlot::removeGoody);

	push	OFFSET ?removeGoody@CvPlot@@QAEXXZ	; CvPlot::removeGoody
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
	add	esp, 8

; 763  : }

	pop	ebp
	ret	0
?lRemoveGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lRemoveGoody
_TEXT	ENDS
EXTRN	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC	; CvPlot::isGoody
; Function compile flags: /Odtp
;	COMDAT ?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsGoody, COMDAT

; 767  : {

	push	ebp
	mov	ebp, esp

; 768  : 	return BasicLuaMethod(L, &CvPlot::isGoody);

	push	OFFSET ?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isGoody
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 769  : }

	pop	ebp
	ret	0
?lIsGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsGoody
_TEXT	ENDS
EXTRN	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isRevealedGoody
; Function compile flags: /Odtp
;	COMDAT ?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRevealedGoody, COMDAT

; 773  : {

	push	ebp
	mov	ebp, esp

; 774  : 	return BasicLuaMethod(L, &CvPlot::isRevealedGoody);

	push	OFFSET ?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isRevealedGoody
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
	add	esp, 8

; 775  : }

	pop	ebp
	ret	0
?lIsRevealedGoody@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRevealedGoody
_TEXT	ENDS
EXTRN	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsFriendlyTerritory
; Function compile flags: /Odtp
;	COMDAT ?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_ePlayer$ = -12						; size = 4
_bResult$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsFriendlyTerritory, COMDAT

; 779  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 780  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 781  : 	const PlayerTypes ePlayer = (PlayerTypes) lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$[ebp], eax

; 782  : 
; 783  : 	const bool bResult = pkPlot->IsFriendlyTerritory(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?IsFriendlyTerritory@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsFriendlyTerritory
	mov	BYTE PTR _bResult$[ebp], al

; 784  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 785  : 	return 1;

	mov	eax, 1

; 786  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsFriendlyTerritory@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsFriendlyTerritory
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
; Function compile flags: /Odtp
;	COMDAT ?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsCity, COMDAT

; 791  : {

	push	ebp
	mov	ebp, esp

; 792  : 	return BasicLuaMethod(L, &CvPlot::isCity);

	push	OFFSET ?isCity@CvPlot@@QBE_NXZ		; CvPlot::isCity
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 793  : }

	pop	ebp
	ret	0
?lIsCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsCity
_TEXT	ENDS
EXTRN	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z:PROC ; CvPlot::isFriendlyCity
; Function compile flags: /Odtp
;	COMDAT ?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -12						; size = 4
_bResult$ = -6						; size = 1
_bCheckImprovement$ = -5				; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFriendlyCity, COMDAT

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 798  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 799  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkUnit$[ebp], eax

; 800  : 	const bool bCheckImprovement = lua_toboolean(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR _bCheckImprovement$[ebp], al

; 801  : 
; 802  : 	const bool bResult = pkPlot->isFriendlyCity(*pkUnit, bCheckImprovement);

	movzx	ecx, BYTE PTR _bCheckImprovement$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isFriendlyCity@CvPlot@@QBE_NABVCvUnit@@_N@Z ; CvPlot::isFriendlyCity
	mov	BYTE PTR _bResult$[ebp], al

; 803  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 804  : 	return 1;

	mov	eax, 1

; 805  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsFriendlyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFriendlyCity
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
; Function compile flags: /Odtp
;	COMDAT ?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pCity$223844 = -16					; size = 4
_pkUnit$ = -12						; size = 4
_bResult$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsEnemyCity, COMDAT

; 809  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 810  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 811  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkUnit$[ebp], eax

; 812  : 	const bool bResult = pkPlot->isEnemyCity(*pkUnit);

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$223844[ebp], eax
	cmp	DWORD PTR _pCity$223844[ebp], 0
	je	SHORT $LN3@lIsEnemyCi
	mov	edx, DWORD PTR _pkPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$223844[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, DWORD PTR _pkUnit$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	mov	BYTE PTR _bResult$[ebp], al
	jmp	SHORT $LN4@lIsEnemyCi
$LN3@lIsEnemyCi:
	mov	BYTE PTR _bResult$[ebp], 0
$LN4@lIsEnemyCi:

; 813  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 814  : 	return 1;

	mov	eax, 1

; 815  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsEnemyCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsEnemyCity
_TEXT	ENDS
EXTRN	?isBeingWorked@CvPlot@@QBE_NXZ:PROC		; CvPlot::isBeingWorked
; Function compile flags: /Odtp
;	COMDAT ?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsBeingWorked, COMDAT

; 819  : {

	push	ebp
	mov	ebp, esp

; 820  : 	return BasicLuaMethod(L, &CvPlot::isBeingWorked);

	push	OFFSET ?isBeingWorked@CvPlot@@QBE_NXZ	; CvPlot::isBeingWorked
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 821  : }

	pop	ebp
	ret	0
?lIsBeingWorked@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsBeingWorked
_TEXT	ENDS
EXTRN	?isUnit@CvPlot@@QBE_NXZ:PROC			; CvPlot::isUnit
; Function compile flags: /Odtp
;	COMDAT ?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsUnit, COMDAT

; 826  : {

	push	ebp
	mov	ebp, esp

; 827  : 	return BasicLuaMethod(L, &CvPlot::isUnit);

	push	OFFSET ?isUnit@CvPlot@@QBE_NXZ		; CvPlot::isUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 828  : }

	pop	ebp
	ret	0
?lIsUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsUnit
_TEXT	ENDS
EXTRN	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z:PROC ; CvPlot::isVisibleEnemyDefender
; Function compile flags: /Odtp
;	COMDAT ?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -12						; size = 4
_bResult$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleEnemyDefender, COMDAT

; 832  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 833  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 834  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkUnit$[ebp], eax

; 835  : 	const bool bResult = pkPlot->isVisibleEnemyDefender(pkUnit);

	mov	edx, DWORD PTR _pkUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isVisibleEnemyDefender@CvPlot@@QBE_NPBVCvUnit@@@Z ; CvPlot::isVisibleEnemyDefender
	mov	BYTE PTR _bResult$[ebp], al

; 836  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 837  : 
; 838  : 	return 1;

	mov	eax, 1

; 839  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsVisibleEnemyDefender@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleEnemyDefender
_TEXT	ENDS
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
; Function compile flags: /Odtp
;	COMDAT ?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumDefenders, COMDAT

; 843  : {

	push	ebp
	mov	ebp, esp

; 844  : 	return BasicLuaMethod(L, &CvPlot::getNumDefenders);

	push	OFFSET ?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 845  : }

	pop	ebp
	ret	0
?lGetNumDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumDefenders
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
EXTRN	?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z:PROC ; CvPlot::getNumVisibleEnemyDefenders
; Function compile flags: /Odtp
;	COMDAT ?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNumVisibleEnemyDefenders, COMDAT

; 849  : {

	push	ebp
	mov	ebp, esp

; 850  : 	return BasicLuaMethod(L, &CvPlot::getNumVisibleEnemyDefenders);

	push	OFFSET ?getNumVisibleEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisibleEnemyDefenders
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
	add	esp, 8

; 851  : }

	pop	ebp
	ret	0
?lGetNumVisibleEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNumVisibleEnemyDefenders
_TEXT	ENDS
EXTRN	?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z:PROC ; CvPlot::getNumVisiblePotentialEnemyDefenders
; Function compile flags: /Odtp
;	COMDAT ?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders, COMDAT

; 855  : {

	push	ebp
	mov	ebp, esp

; 856  : 	return BasicLuaMethod(L, &CvPlot::getNumVisiblePotentialEnemyDefenders);

	push	OFFSET ?getNumVisiblePotentialEnemyDefenders@CvPlot@@QBEHPBVCvUnit@@@Z ; CvPlot::getNumVisiblePotentialEnemyDefenders
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
	add	esp, 8

; 857  : }

	pop	ebp
	ret	0
?lGetNumVisiblePotentialEnemyDefenders@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNumVisiblePotentialEnemyDefenders
_TEXT	ENDS
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
; Function compile flags: /Odtp
;	COMDAT ?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_ePlayer$ = -12						; size = 4
_bResult$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleEnemyUnit, COMDAT

; 861  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 862  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 863  : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$[ebp], eax

; 864  : 	const bool bResult = pkPlot->isVisibleEnemyUnit(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit
	mov	BYTE PTR _bResult$[ebp], al

; 865  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 866  : 	return 1;

	mov	eax, 1

; 867  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsVisibleEnemyUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleEnemyUnit
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
EXTRN	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleOtherUnit
; Function compile flags: /Odtp
;	COMDAT ?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsVisibleOtherUnit, COMDAT

; 871  : {

	push	ebp
	mov	ebp, esp

; 872  : 	return BasicLuaMethod(L, &CvPlot::isVisibleOtherUnit);

	push	OFFSET ?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
	add	esp, 8

; 873  : }

	pop	ebp
	ret	0
?lIsVisibleOtherUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsVisibleOtherUnit
_TEXT	ENDS
EXTRN	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z:PROC ; CvPlot::getNumFriendlyUnitsOfType
; Function compile flags: /Odtp
;	COMDAT ?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -16						; size = 4
_bBreakOnUnitLimit$ = -9				; size = 1
_iResult$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNumFriendlyUnitsOfType, COMDAT

; 877  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 878  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 879  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkUnit$[ebp], eax

; 880  : 
; 881  : 	bool bBreakOnUnitLimit = luaL_optbool(L, 3, true);

	push	1
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bBreakOnUnitLimit$[ebp], al

; 882  : 	int iResult = pkPlot->getNumFriendlyUnitsOfType(pkUnit, bBreakOnUnitLimit);

	movzx	eax, BYTE PTR _bBreakOnUnitLimit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	mov	DWORD PTR _iResult$[ebp], eax

; 883  : 
; 884  : 	lua_pushinteger(L, iResult);

	mov	edx, DWORD PTR _iResult$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 885  : 	return 1;

	mov	eax, 1

; 886  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNumFriendlyUnitsOfType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNumFriendlyUnitsOfType
_TEXT	ENDS
EXTRN	?isFighting@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFighting
; Function compile flags: /Odtp
;	COMDAT ?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFighting, COMDAT

; 890  : {

	push	ebp
	mov	ebp, esp

; 891  : 	return BasicLuaMethod(L, &CvPlot::isFighting);

	push	OFFSET ?isFighting@CvPlot@@QBE_NXZ	; CvPlot::isFighting
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 892  : }

	pop	ebp
	ret	0
?lIsFighting@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFighting
_TEXT	ENDS
EXTRN	?isRoute@CvPlot@@QBE_NXZ:PROC			; CvPlot::isRoute
; Function compile flags: /Odtp
;	COMDAT ?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsRoute, COMDAT

; 896  : {

	push	ebp
	mov	ebp, esp

; 897  : 	return BasicLuaMethod(L, &CvPlot::isRoute);

	push	OFFSET ?isRoute@CvPlot@@QBE_NXZ		; CvPlot::isRoute
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 898  : }

	pop	ebp
	ret	0
?lIsRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsRoute
_TEXT	ENDS
EXTRN	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_ePlayer$ = -12						; size = 4
_bResult$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsTradeRoute, COMDAT

; 901  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 902  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 903  : 	PlayerTypes ePlayer = (PlayerTypes)luaL_optint(L, 2, -1);

	push	-1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ePlayer$[ebp], eax

; 904  : 	bool bResult = pkPlot->IsTradeRoute(ePlayer);

	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	mov	BYTE PTR _bResult$[ebp], al

; 905  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 906  : 	return 1;

	mov	eax, 1

; 907  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsTradeRoute@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsTradeRoute
_TEXT	ENDS
EXTRN	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForLocation
; Function compile flags: /Odtp
;	COMDAT ?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -12						; size = 4
_bResult$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsValidDomainForLocation, COMDAT

; 911  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 912  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 913  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkUnit$[ebp], eax

; 914  : 
; 915  : 	const bool bResult = pkPlot->isValidDomainForLocation(*pkUnit);

	mov	edx, DWORD PTR _pkUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isValidDomainForLocation@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForLocation
	mov	BYTE PTR _bResult$[ebp], al

; 916  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 917  : 	return 1;

	mov	eax, 1

; 918  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsValidDomainForLocation@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsValidDomainForLocation
_TEXT	ENDS
EXTRN	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z:PROC ; CvPlot::isValidDomainForAction
; Function compile flags: /Odtp
;	COMDAT ?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -12						; size = 4
_bResult$ = -5						; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsValidDomainForAction, COMDAT

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 923  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 924  : 	CvUnit* pkUnit = CvLuaUnit::GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkUnit$[ebp], eax

; 925  : 
; 926  : 	const bool bResult = pkPlot->isValidDomainForAction(*pkUnit);

	mov	edx, DWORD PTR _pkUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isValidDomainForAction@CvPlot@@QBE_NABVCvUnit@@@Z ; CvPlot::isValidDomainForAction
	mov	BYTE PTR _bResult$[ebp], al

; 927  : 	lua_pushboolean(L, bResult);

	movzx	eax, BYTE PTR _bResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 928  : 	return 1;

	mov	eax, 1

; 929  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsValidDomainForAction@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsValidDomainForAction
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Odtp
;	COMDAT ?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsImpassable, COMDAT

; 933  : {

	push	ebp
	mov	ebp, esp

; 934  : 	return BasicLuaMethod(L, &CvPlot::isImpassable);

	push	OFFSET ?isImpassable@CvPlot@@QBE_NXZ	; CvPlot::isImpassable
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 935  : }

	pop	ebp
	ret	0
?lIsImpassable@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsImpassable
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Odtp
;	COMDAT ?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetX, COMDAT

; 940  : {

	push	ebp
	mov	ebp, esp

; 941  : 	return BasicLuaMethod(L, &CvPlot::getX);

	push	OFFSET ?getX@CvPlot@@QBEHXZ		; CvPlot::getX
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 942  : }

	pop	ebp
	ret	0
?lGetX@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Odtp
;	COMDAT ?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetY, COMDAT

; 946  : {

	push	ebp
	mov	ebp, esp

; 947  : 	return BasicLuaMethod(L, &CvPlot::getY);

	push	OFFSET ?getY@CvPlot@@QBEHXZ		; CvPlot::getY
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 948  : }

	pop	ebp
	ret	0
?lGetY@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetY
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>
EXTRN	?at@CvPlot@@QBE_NHH@Z:PROC			; CvPlot::at
; Function compile flags: /Odtp
;	COMDAT ?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lAt, COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp

; 953  : 	return BasicLuaMethod(L, &CvPlot::at);

	push	OFFSET ?at@CvPlot@@QBE_NHH@Z		; CvPlot::at
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>
	add	esp, 8

; 954  : }

	pop	ebp
	ret	0
?lAt@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lAt
_TEXT	ENDS
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
; Function compile flags: /Odtp
;	COMDAT ?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetPlotIndex, COMDAT

; 958  : {

	push	ebp
	mov	ebp, esp

; 959  : 	return BasicLuaMethod(L, &CvPlot::GetPlotIndex);

	push	OFFSET ?GetPlotIndex@CvPlot@@QBEHXZ	; CvPlot::GetPlotIndex
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 960  : }

	pop	ebp
	ret	0
?lGetPlotIndex@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetPlotIndex
_TEXT	ENDS
EXTRN	?getLatitude@CvPlot@@QBEHXZ:PROC		; CvPlot::getLatitude
; Function compile flags: /Odtp
;	COMDAT ?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetLatitude, COMDAT

; 964  : {

	push	ebp
	mov	ebp, esp

; 965  : 	return BasicLuaMethod(L, &CvPlot::getLatitude);

	push	OFFSET ?getLatitude@CvPlot@@QBEHXZ	; CvPlot::getLatitude
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 966  : }

	pop	ebp
	ret	0
?lGetLatitude@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetLatitude
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
; Function compile flags: /Odtp
;	COMDAT ?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkArea$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lArea, COMDAT

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 971  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 972  : 	CvArea* pkArea = pkPlot->area();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pkArea$[ebp], eax

; 973  : 	CvLuaArea::Push(L, pkArea);

	mov	ecx, DWORD PTR _pkArea$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8

; 974  : 	return 1;

	mov	eax, 1

; 975  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lArea
_TEXT	ENDS
EXTRN	?waterArea@CvPlot@@QBEPAVCvArea@@XZ:PROC	; CvPlot::waterArea
; Function compile flags: /Odtp
;	COMDAT ?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkArea$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lWaterArea, COMDAT

; 979  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 980  : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 981  : 	CvArea* pkArea = pkPlot->waterArea();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?waterArea@CvPlot@@QBEPAVCvArea@@XZ	; CvPlot::waterArea
	mov	DWORD PTR _pkArea$[ebp], eax

; 982  : 	CvLuaArea::Push(L, pkArea);

	mov	ecx, DWORD PTR _pkArea$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8

; 983  : 	return 1;

	mov	eax, 1

; 984  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lWaterArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lWaterArea
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Odtp
;	COMDAT ?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetArea, COMDAT

; 988  : {

	push	ebp
	mov	ebp, esp

; 989  : 	return BasicLuaMethod(L, &CvPlot::getArea);

	push	OFFSET ?getArea@CvPlot@@QBEHXZ		; CvPlot::getArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 990  : }

	pop	ebp
	ret	0
?lGetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetArea
_TEXT	ENDS
EXTRN	?setArea@CvPlot@@QAEXH@Z:PROC			; CvPlot::setArea
; Function compile flags: /Odtp
;	COMDAT ?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lSetArea, COMDAT

; 994  : {

	push	ebp
	mov	ebp, esp

; 995  : 	return BasicLuaMethod(L, &CvPlot::setArea);

	push	OFFSET ?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 996  : }

	pop	ebp
	ret	0
?lSetArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lSetArea
_TEXT	ENDS
EXTRN	?getFeatureVariety@CvPlot@@QBEHXZ:PROC		; CvPlot::getFeatureVariety
; Function compile flags: /Odtp
;	COMDAT ?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFeatureVariety, COMDAT

; 1000 : {

	push	ebp
	mov	ebp, esp

; 1001 : 	return BasicLuaMethod(L, &CvPlot::getFeatureVariety);

	push	OFFSET ?getFeatureVariety@CvPlot@@QBEHXZ ; CvPlot::getFeatureVariety
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1002 : }

	pop	ebp
	ret	0
?lGetFeatureVariety@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFeatureVariety
_TEXT	ENDS
EXTRN	?getOwnershipDuration@CvPlot@@QBEHXZ:PROC	; CvPlot::getOwnershipDuration
; Function compile flags: /Odtp
;	COMDAT ?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetOwnershipDuration, COMDAT

; 1007 : {

	push	ebp
	mov	ebp, esp

; 1008 : 	return BasicLuaMethod(L, &CvPlot::getOwnershipDuration);

	push	OFFSET ?getOwnershipDuration@CvPlot@@QBEHXZ ; CvPlot::getOwnershipDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1009 : }

	pop	ebp
	ret	0
?lGetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetOwnershipDuration
_TEXT	ENDS
EXTRN	?isOwnershipScore@CvPlot@@QBE_NXZ:PROC		; CvPlot::isOwnershipScore
; Function compile flags: /Odtp
;	COMDAT ?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsOwnershipScore, COMDAT

; 1013 : {

	push	ebp
	mov	ebp, esp

; 1014 : 	return BasicLuaMethod(L, &CvPlot::isOwnershipScore);

	push	OFFSET ?isOwnershipScore@CvPlot@@QBE_NXZ ; CvPlot::isOwnershipScore
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1015 : }

	pop	ebp
	ret	0
?lIsOwnershipScore@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsOwnershipScore
_TEXT	ENDS
EXTRN	?setOwnershipDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::setOwnershipDuration
; Function compile flags: /Odtp
;	COMDAT ?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetOwnershipDuration, COMDAT

; 1019 : {

	push	ebp
	mov	ebp, esp

; 1020 : 	return BasicLuaMethod(L, &CvPlot::setOwnershipDuration);

	push	OFFSET ?setOwnershipDuration@CvPlot@@QAEXH@Z ; CvPlot::setOwnershipDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1021 : }

	pop	ebp
	ret	0
?lSetOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetOwnershipDuration
_TEXT	ENDS
EXTRN	?changeOwnershipDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeOwnershipDuration
; Function compile flags: /Odtp
;	COMDAT ?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeOwnershipDuration, COMDAT

; 1025 : {

	push	ebp
	mov	ebp, esp

; 1026 : 	return BasicLuaMethod(L, &CvPlot::changeOwnershipDuration);

	push	OFFSET ?changeOwnershipDuration@CvPlot@@QAEXH@Z ; CvPlot::changeOwnershipDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1027 : }

	pop	ebp
	ret	0
?lChangeOwnershipDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeOwnershipDuration
_TEXT	ENDS
EXTRN	?getInlandCorner@CvPlot@@QBEPAV1@XZ:PROC	; CvPlot::getInlandCorner
; Function compile flags: /Odtp
;	COMDAT ?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkInlandCorner$ = -8					; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetInlandCorner, COMDAT

; 1031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1032 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1033 : 	CvPlot* pkInlandCorner = pkPlot->getInlandCorner();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getInlandCorner@CvPlot@@QBEPAV1@XZ	; CvPlot::getInlandCorner
	mov	DWORD PTR _pkInlandCorner$[ebp], eax

; 1034 : 
; 1035 : 	CvLuaPlot::Push(L, pkInlandCorner);

	mov	ecx, DWORD PTR _pkInlandCorner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 1036 : 	return 1;

	mov	eax, 1

; 1037 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetInlandCorner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetInlandCorner
_TEXT	ENDS
EXTRN	?getImprovementDuration@CvPlot@@QBEHXZ:PROC	; CvPlot::getImprovementDuration
; Function compile flags: /Odtp
;	COMDAT ?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetImprovementDuration, COMDAT

; 1041 : {

	push	ebp
	mov	ebp, esp

; 1042 : 	return BasicLuaMethod(L, &CvPlot::getImprovementDuration);

	push	OFFSET ?getImprovementDuration@CvPlot@@QBEHXZ ; CvPlot::getImprovementDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1043 : }

	pop	ebp
	ret	0
?lGetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetImprovementDuration
_TEXT	ENDS
EXTRN	?setImprovementDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::setImprovementDuration
; Function compile flags: /Odtp
;	COMDAT ?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetImprovementDuration, COMDAT

; 1047 : {

	push	ebp
	mov	ebp, esp

; 1048 : 	return BasicLuaMethod(L, &CvPlot::setImprovementDuration);

	push	OFFSET ?setImprovementDuration@CvPlot@@QAEXH@Z ; CvPlot::setImprovementDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1049 : }

	pop	ebp
	ret	0
?lSetImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetImprovementDuration
_TEXT	ENDS
EXTRN	?changeImprovementDuration@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeImprovementDuration
; Function compile flags: /Odtp
;	COMDAT ?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeImprovementDuration, COMDAT

; 1053 : {

	push	ebp
	mov	ebp, esp

; 1054 : 	return BasicLuaMethod(L, &CvPlot::changeImprovementDuration);

	push	OFFSET ?changeImprovementDuration@CvPlot@@QAEXH@Z ; CvPlot::changeImprovementDuration
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1055 : }

	pop	ebp
	ret	0
?lChangeImprovementDuration@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeImprovementDuration
_TEXT	ENDS
EXTRN	?getUpgradeProgress@CvPlot@@QBEHXZ:PROC		; CvPlot::getUpgradeProgress
; Function compile flags: /Odtp
;	COMDAT ?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetUpgradeProgress, COMDAT

; 1060 : {

	push	ebp
	mov	ebp, esp

; 1061 : 	return BasicLuaMethod(L, &CvPlot::getUpgradeProgress);

	push	OFFSET ?getUpgradeProgress@CvPlot@@QBEHXZ ; CvPlot::getUpgradeProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1062 : }

	pop	ebp
	ret	0
?lGetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetUpgradeProgress
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>
EXTRN	?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getUpgradeTimeLeft
; Function compile flags: /Odtp
;	COMDAT ?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetUpgradeTimeLeft, COMDAT

; 1066 : {

	push	ebp
	mov	ebp, esp

; 1067 : 	return BasicLuaMethod(L, &CvPlot::getUpgradeTimeLeft);

	push	OFFSET ?getUpgradeTimeLeft@CvPlot@@QBEHW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::getUpgradeTimeLeft
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>
	add	esp, 8

; 1068 : }

	pop	ebp
	ret	0
?lGetUpgradeTimeLeft@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetUpgradeTimeLeft
_TEXT	ENDS
EXTRN	?setUpgradeProgress@CvPlot@@QAEXH@Z:PROC	; CvPlot::setUpgradeProgress
; Function compile flags: /Odtp
;	COMDAT ?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetUpgradeProgress, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp

; 1074 : 	return BasicLuaMethod(L, &CvPlot::setUpgradeProgress);

	push	OFFSET ?setUpgradeProgress@CvPlot@@QAEXH@Z ; CvPlot::setUpgradeProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1075 : }

	pop	ebp
	ret	0
?lSetUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetUpgradeProgress
_TEXT	ENDS
EXTRN	?changeUpgradeProgress@CvPlot@@QAEXH@Z:PROC	; CvPlot::changeUpgradeProgress
; Function compile flags: /Odtp
;	COMDAT ?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeUpgradeProgress, COMDAT

; 1079 : {

	push	ebp
	mov	ebp, esp

; 1080 : 	return BasicLuaMethod(L, &CvPlot::changeUpgradeProgress);

	push	OFFSET ?changeUpgradeProgress@CvPlot@@QAEXH@Z ; CvPlot::changeUpgradeProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1081 : }

	pop	ebp
	ret	0
?lChangeUpgradeProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeUpgradeProgress
_TEXT	ENDS
EXTRN	?getCityRadiusCount@CvPlot@@QBEHXZ:PROC		; CvPlot::getCityRadiusCount
; Function compile flags: /Odtp
;	COMDAT ?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetCityRadiusCount, COMDAT

; 1085 : {

	push	ebp
	mov	ebp, esp

; 1086 : 	return BasicLuaMethod(L, &CvPlot::getCityRadiusCount);

	push	OFFSET ?getCityRadiusCount@CvPlot@@QBEHXZ ; CvPlot::getCityRadiusCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1087 : }

	pop	ebp
	ret	0
?lGetCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetCityRadiusCount
_TEXT	ENDS
EXTRN	?isCityRadius@CvPlot@@QBEHXZ:PROC		; CvPlot::isCityRadius
; Function compile flags: /Odtp
;	COMDAT ?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsCityRadius, COMDAT

; 1091 : {

	push	ebp
	mov	ebp, esp

; 1092 : 	return BasicLuaMethod(L, &CvPlot::isCityRadius);

	push	OFFSET ?isCityRadius@CvPlot@@QBEHXZ	; CvPlot::isCityRadius
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1093 : }

	pop	ebp
	ret	0
?lIsCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsCityRadius
_TEXT	ENDS
EXTRN	?isStartingPlot@CvPlot@@QBE_NXZ:PROC		; CvPlot::isStartingPlot
; Function compile flags: /Odtp
;	COMDAT ?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsStartingPlot, COMDAT

; 1098 : {

	push	ebp
	mov	ebp, esp

; 1099 : 	return BasicLuaMethod(L, &CvPlot::isStartingPlot);

	push	OFFSET ?isStartingPlot@CvPlot@@QBE_NXZ	; CvPlot::isStartingPlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1100 : }

	pop	ebp
	ret	0
?lIsStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsStartingPlot
_TEXT	ENDS
EXTRN	?setStartingPlot@CvPlot@@QAEX_N@Z:PROC		; CvPlot::setStartingPlot
; Function compile flags: /Odtp
;	COMDAT ?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetStartingPlot, COMDAT

; 1104 : {

	push	ebp
	mov	ebp, esp

; 1105 : 	return BasicLuaMethod(L, &CvPlot::setStartingPlot);

	push	OFFSET ?setStartingPlot@CvPlot@@QAEX_N@Z ; CvPlot::setStartingPlot
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1106 : }

	pop	ebp
	ret	0
?lSetStartingPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetStartingPlot
_TEXT	ENDS
EXTRN	?isNEOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNEOfRiver
; Function compile flags: /Odtp
;	COMDAT ?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsNEOfRiver, COMDAT

; 1110 : {

	push	ebp
	mov	ebp, esp

; 1111 : 	return BasicLuaMethod(L, &CvPlot::isNEOfRiver);

	push	OFFSET ?isNEOfRiver@CvPlot@@QBE_NXZ	; CvPlot::isNEOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1112 : }

	pop	ebp
	ret	0
?lIsNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsNEOfRiver
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
EXTRN	?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNEOfRiver
; Function compile flags: /Odtp
;	COMDAT ?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetNEOfRiver, COMDAT

; 1116 : {

	push	ebp
	mov	ebp, esp

; 1117 : 	return BasicLuaMethod(L, &CvPlot::setNEOfRiver);

	push	OFFSET ?setNEOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNEOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
	add	esp, 8

; 1118 : }

	pop	ebp
	ret	0
?lSetNEOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetNEOfRiver
_TEXT	ENDS
EXTRN	?isWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isWOfRiver
; Function compile flags: /Odtp
;	COMDAT ?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsWOfRiver, COMDAT

; 1122 : {

	push	ebp
	mov	ebp, esp

; 1123 : 	return BasicLuaMethod(L, &CvPlot::isWOfRiver);

	push	OFFSET ?isWOfRiver@CvPlot@@QBE_NXZ	; CvPlot::isWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1124 : }

	pop	ebp
	ret	0
?lIsWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsWOfRiver
_TEXT	ENDS
EXTRN	?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setWOfRiver
; Function compile flags: /Odtp
;	COMDAT ?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetWOfRiver, COMDAT

; 1128 : {

	push	ebp
	mov	ebp, esp

; 1129 : 	return BasicLuaMethod(L, &CvPlot::setWOfRiver);

	push	OFFSET ?setWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
	add	esp, 8

; 1130 : }

	pop	ebp
	ret	0
?lSetWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetWOfRiver
_TEXT	ENDS
EXTRN	?isNWOfRiver@CvPlot@@QBE_NXZ:PROC		; CvPlot::isNWOfRiver
; Function compile flags: /Odtp
;	COMDAT ?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsNWOfRiver, COMDAT

; 1134 : {

	push	ebp
	mov	ebp, esp

; 1135 : 	return BasicLuaMethod(L, &CvPlot::isNWOfRiver);

	push	OFFSET ?isNWOfRiver@CvPlot@@QBE_NXZ	; CvPlot::isNWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1136 : }

	pop	ebp
	ret	0
?lIsNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsNWOfRiver
_TEXT	ENDS
EXTRN	?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z:PROC ; CvPlot::setNWOfRiver
; Function compile flags: /Odtp
;	COMDAT ?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetNWOfRiver, COMDAT

; 1140 : {

	push	ebp
	mov	ebp, esp

; 1141 : 	return BasicLuaMethod(L, &CvPlot::setNWOfRiver);

	push	OFFSET ?setNWOfRiver@CvPlot@@QAEX_NW4FlowDirectionTypes@@@Z ; CvPlot::setNWOfRiver
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
	add	esp, 8

; 1142 : }

	pop	ebp
	ret	0
?lSetNWOfRiver@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetNWOfRiver
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
EXTRN	?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverEFlowDirection
; Function compile flags: /Odtp
;	COMDAT ?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverEFlowDirection, COMDAT

; 1146 : {

	push	ebp
	mov	ebp, esp

; 1147 : 	return BasicLuaMethod(L, &CvPlot::getRiverEFlowDirection);

	push	OFFSET ?getRiverEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverEFlowDirection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
	add	esp, 8

; 1148 : }

	pop	ebp
	ret	0
?lGetRiverEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverEFlowDirection
_TEXT	ENDS
EXTRN	?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSEFlowDirection
; Function compile flags: /Odtp
;	COMDAT ?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverSEFlowDirection, COMDAT

; 1152 : {

	push	ebp
	mov	ebp, esp

; 1153 : 	return BasicLuaMethod(L, &CvPlot::getRiverSEFlowDirection);

	push	OFFSET ?getRiverSEFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSEFlowDirection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
	add	esp, 8

; 1154 : }

	pop	ebp
	ret	0
?lGetRiverSEFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverSEFlowDirection
_TEXT	ENDS
EXTRN	?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ:PROC ; CvPlot::getRiverSWFlowDirection
; Function compile flags: /Odtp
;	COMDAT ?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverSWFlowDirection, COMDAT

; 1158 : {

	push	ebp
	mov	ebp, esp

; 1159 : 	return BasicLuaMethod(L, &CvPlot::getRiverSWFlowDirection);

	push	OFFSET ?getRiverSWFlowDirection@CvPlot@@QBE?AW4FlowDirectionTypes@@XZ ; CvPlot::getRiverSWFlowDirection
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
	add	esp, 8

; 1160 : }

	pop	ebp
	ret	0
?lGetRiverSWFlowDirection@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverSWFlowDirection
_TEXT	ENDS
EXTRN	?isPotentialCityWork@CvPlot@@QBE_NXZ:PROC	; CvPlot::isPotentialCityWork
; Function compile flags: /Odtp
;	COMDAT ?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsPotentialCityWork, COMDAT

; 1165 : {

	push	ebp
	mov	ebp, esp

; 1166 : 	return BasicLuaMethod(L, &CvPlot::isPotentialCityWork);

	push	OFFSET ?isPotentialCityWork@CvPlot@@QBE_NXZ ; CvPlot::isPotentialCityWork
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1167 : }

	pop	ebp
	ret	0
?lIsPotentialCityWork@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsPotentialCityWork
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>
EXTRN	?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z:PROC ; CvPlot::isPotentialCityWorkForArea
; Function compile flags: /Odtp
;	COMDAT ?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsPotentialCityWorkForArea, COMDAT

; 1171 : {

	push	ebp
	mov	ebp, esp

; 1172 : 	return BasicLuaMethod(L, &CvPlot::isPotentialCityWorkForArea);

	push	OFFSET ?isPotentialCityWorkForArea@CvPlot@@QBE_NPAVCvArea@@@Z ; CvPlot::isPotentialCityWorkForArea
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>
	add	esp, 8

; 1173 : }

	pop	ebp
	ret	0
?lIsPotentialCityWorkForArea@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsPotentialCityWorkForArea
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Odtp
;	COMDAT ?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetOwner, COMDAT

; 1178 : {

	push	ebp
	mov	ebp, esp

; 1179 : 	return BasicLuaMethod(L, &CvPlot::getOwner);

	push	OFFSET ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::getOwner
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>
	add	esp, 8

; 1180 : }

	pop	ebp
	ret	0
?lGetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetOwner
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>
EXTRN	?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z:PROC ; CvPlot::setOwner
; Function compile flags: /Odtp
;	COMDAT ?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lSetOwner, COMDAT

; 1184 : {

	push	ebp
	mov	ebp, esp

; 1185 : 	return BasicLuaMethod(L, &CvPlot::setOwner);

	push	OFFSET ?setOwner@CvPlot@@QAEXW4PlayerTypes@@H_N1@Z ; CvPlot::setOwner
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>
	add	esp, 8

; 1186 : }

	pop	ebp
	ret	0
?lSetOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lSetOwner
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>
PUBLIC	?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ	; CvPlot::getPlotType
; Function compile flags: /Odtp
;	COMDAT ?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetPlotType, COMDAT

; 1190 : {

	push	ebp
	mov	ebp, esp

; 1191 : 	return BasicLuaMethod(L, &CvPlot::getPlotType);

	push	OFFSET ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ; CvPlot::getPlotType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>
	add	esp, 8

; 1192 : }

	pop	ebp
	ret	0
?lGetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetPlotType
_TEXT	ENDS
EXTRN	?isFlatlands@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFlatlands
; Function compile flags: /Odtp
;	COMDAT ?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsFlatlands, COMDAT

; 1196 : {

	push	ebp
	mov	ebp, esp

; 1197 : 	return BasicLuaMethod(L, &CvPlot::isFlatlands);

	push	OFFSET ?isFlatlands@CvPlot@@QBE_NXZ	; CvPlot::isFlatlands
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1198 : }

	pop	ebp
	ret	0
?lIsFlatlands@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsFlatlands
_TEXT	ENDS
PUBLIC	?isHills@CvPlot@@QBE_NXZ			; CvPlot::isHills
; Function compile flags: /Odtp
;	COMDAT ?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lIsHills, COMDAT

; 1202 : {

	push	ebp
	mov	ebp, esp

; 1203 : 	return BasicLuaMethod(L, &CvPlot::isHills);

	push	OFFSET ?isHills@CvPlot@@QBE_NXZ		; CvPlot::isHills
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1204 : }

	pop	ebp
	ret	0
?lIsHills@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lIsHills
_TEXT	ENDS
PUBLIC	?isOpenGround@CvPlot@@QBE_NXZ			; CvPlot::isOpenGround
; Function compile flags: /Odtp
;	COMDAT ?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsOpenGround, COMDAT

; 1208 : {

	push	ebp
	mov	ebp, esp

; 1209 : 	return BasicLuaMethod(L, &CvPlot::isOpenGround);

	push	OFFSET ?isOpenGround@CvPlot@@QBE_NXZ	; CvPlot::isOpenGround
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1210 : }

	pop	ebp
	ret	0
?lIsOpenGround@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsOpenGround
_TEXT	ENDS
PUBLIC	?isRoughGround@CvPlot@@QBE_NXZ			; CvPlot::isRoughGround
; Function compile flags: /Odtp
;	COMDAT ?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRoughGround, COMDAT

; 1214 : {

	push	ebp
	mov	ebp, esp

; 1215 : 	return BasicLuaMethod(L, &CvPlot::isRoughGround);

	push	OFFSET ?isRoughGround@CvPlot@@QBE_NXZ	; CvPlot::isRoughGround
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1216 : }

	pop	ebp
	ret	0
?lIsRoughGround@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRoughGround
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Odtp
;	COMDAT ?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsMountain, COMDAT

; 1220 : {

	push	ebp
	mov	ebp, esp

; 1221 : 	return BasicLuaMethod(L, &CvPlot::isMountain);

	push	OFFSET ?isMountain@CvPlot@@QBE_NXZ	; CvPlot::isMountain
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1222 : }

	pop	ebp
	ret	0
?lIsMountain@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsMountain
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>
EXTRN	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z:PROC ; CvPlot::setPlotType
; Function compile flags: /Odtp
;	COMDAT ?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetPlotType, COMDAT

; 1227 : {

	push	ebp
	mov	ebp, esp

; 1228 : 	return BasicLuaMethod(L, &CvPlot::setPlotType);

	push	OFFSET ?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>
	add	esp, 8

; 1229 : }

	pop	ebp
	ret	0
?lSetPlotType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetPlotType
_TEXT	ENDS
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	_lua_gettop:PROC
; Function compile flags: /Odtp
;	COMDAT ?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_eResource$221628 = -16					; size = 4
_eTeam$221624 = -12					; size = 4
_eResource$221626 = -8					; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetResourceType, COMDAT

; 1233 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1234 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1235 : 	if(pkPlot != NULL)

	cmp	DWORD PTR _pkPlot$[ebp], 0
	je	SHORT $LN4@lGetResour

; 1236 : 	{
; 1237 : 		if(lua_gettop(L) >= 2)

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	cmp	eax, 2
	jl	SHORT $LN3@lGetResour

; 1238 : 		{
; 1239 : 			TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$221624[ebp], eax

; 1240 : 			ResourceTypes eResource = pkPlot->getResourceType(eTeam);

	mov	eax, DWORD PTR _eTeam$221624[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$221626[ebp], eax

; 1241 : 			lua_pushinteger(L, eResource);

	mov	ecx, DWORD PTR _eResource$221626[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1242 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN5@lGetResour

; 1243 : 		}
; 1244 : 		else

	jmp	SHORT $LN2@lGetResour
$LN3@lGetResour:

; 1245 : 		{
; 1246 : 			ResourceTypes eResource = pkPlot->getResourceType(NO_TEAM);

	push	-1
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$221628[ebp], eax

; 1247 : 			lua_pushinteger(L, eResource);

	mov	eax, DWORD PTR _eResource$221628[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 1248 : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN5@lGetResour
$LN2@lGetResour:

; 1249 : 		}
; 1250 : 	}
; 1251 : 	else

	jmp	SHORT $LN5@lGetResour
$LN4@lGetResour:

; 1252 : 	{
; 1253 : 		lua_pushinteger(L, -1);

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1254 : 		return 1;

	mov	eax, 1
$LN5@lGetResour:

; 1255 : 	}
; 1256 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetResourceType
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>
EXTRN	?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getNonObsoleteResourceType
; Function compile flags: /Odtp
;	COMDAT ?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetNonObsoleteResourceType, COMDAT

; 1260 : {

	push	ebp
	mov	ebp, esp

; 1261 : 	return BasicLuaMethod(L, &CvPlot::getNonObsoleteResourceType);

	push	OFFSET ?getNonObsoleteResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getNonObsoleteResourceType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>
	add	esp, 8

; 1262 : }

	pop	ebp
	ret	0
?lGetNonObsoleteResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetNonObsoleteResourceType
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>
EXTRN	?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z:PROC ; CvPlot::setResourceType
; Function compile flags: /Odtp
;	COMDAT ?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetResourceType, COMDAT

; 1266 : {

	push	ebp
	mov	ebp, esp

; 1267 : 	return BasicLuaMethod(L, &CvPlot::setResourceType);

	push	OFFSET ?setResourceType@CvPlot@@QAEXW4ResourceTypes@@H_N@Z ; CvPlot::setResourceType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>
	add	esp, 8

; 1268 : }

	pop	ebp
	ret	0
?lSetResourceType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetResourceType
_TEXT	ENDS
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
; Function compile flags: /Odtp
;	COMDAT ?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumResource, COMDAT

; 1272 : {

	push	ebp
	mov	ebp, esp

; 1273 : 	return BasicLuaMethod(L, &CvPlot::getNumResource);

	push	OFFSET ?getNumResource@CvPlot@@QBEHXZ	; CvPlot::getNumResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1274 : }

	pop	ebp
	ret	0
?lGetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumResource
_TEXT	ENDS
EXTRN	?setNumResource@CvPlot@@QAEXH@Z:PROC		; CvPlot::setNumResource
; Function compile flags: /Odtp
;	COMDAT ?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetNumResource, COMDAT

; 1278 : {

	push	ebp
	mov	ebp, esp

; 1279 : 	return BasicLuaMethod(L, &CvPlot::setNumResource);

	push	OFFSET ?setNumResource@CvPlot@@QAEXH@Z	; CvPlot::setNumResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1280 : }

	pop	ebp
	ret	0
?lSetNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetNumResource
_TEXT	ENDS
EXTRN	?changeNumResource@CvPlot@@QAEXH@Z:PROC		; CvPlot::changeNumResource
; Function compile flags: /Odtp
;	COMDAT ?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lChangeNumResource, COMDAT

; 1284 : {

	push	ebp
	mov	ebp, esp

; 1285 : 	return BasicLuaMethod(L, &CvPlot::changeNumResource);

	push	OFFSET ?changeNumResource@CvPlot@@QAEXH@Z ; CvPlot::changeNumResource
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1286 : }

	pop	ebp
	ret	0
?lChangeNumResource@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lChangeNumResource
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
; Function compile flags: /Odtp
;	COMDAT ?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetImprovementType, COMDAT

; 1291 : {

	push	ebp
	mov	ebp, esp

; 1292 : 	return BasicLuaMethod(L, &CvPlot::getImprovementType);

	push	OFFSET ?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>
	add	esp, 8

; 1293 : }

	pop	ebp
	ret	0
?lGetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetImprovementType
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>
EXTRN	?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::setImprovementType
; Function compile flags: /Odtp
;	COMDAT ?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetImprovementType, COMDAT

; 1297 : {

	push	ebp
	mov	ebp, esp

; 1298 : 	return BasicLuaMethod(L, &CvPlot::setImprovementType);

	push	OFFSET ?setImprovementType@CvPlot@@QAEXW4ImprovementTypes@@W4PlayerTypes@@@Z ; CvPlot::setImprovementType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>
	add	esp, 8

; 1299 : }

	pop	ebp
	ret	0
?lSetImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetImprovementType
_TEXT	ENDS
EXTRN	?SetImprovementPillaged@CvPlot@@QAEX_N@Z:PROC	; CvPlot::SetImprovementPillaged
; Function compile flags: /Odtp
;	COMDAT ?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetImprovementPillaged, COMDAT

; 1303 : {

	push	ebp
	mov	ebp, esp

; 1304 : 	return BasicLuaMethod(L, &CvPlot::SetImprovementPillaged);

	push	OFFSET ?SetImprovementPillaged@CvPlot@@QAEX_N@Z ; CvPlot::SetImprovementPillaged
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1305 : }

	pop	ebp
	ret	0
?lSetImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetImprovementPillaged
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
; Function compile flags: /Odtp
;	COMDAT ?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetRouteType, COMDAT

; 1309 : {

	push	ebp
	mov	ebp, esp

; 1310 : 	return BasicLuaMethod(L, &CvPlot::getRouteType);

	push	OFFSET ?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
	add	esp, 8

; 1311 : }

	pop	ebp
	ret	0
?lGetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetRouteType
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
EXTRN	?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z:PROC	; CvPlot::setRouteType
; Function compile flags: /Odtp
;	COMDAT ?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetRouteType, COMDAT

; 1315 : {

	push	ebp
	mov	ebp, esp

; 1316 : 	return BasicLuaMethod(L, &CvPlot::setRouteType);

	push	OFFSET ?setRouteType@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::setRouteType
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
	add	esp, 8

; 1317 : }

	pop	ebp
	ret	0
?lSetRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetRouteType
_TEXT	ENDS
EXTRN	?IsRoutePillaged@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsRoutePillaged
; Function compile flags: /Odtp
;	COMDAT ?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRoutePillaged, COMDAT

; 1320 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1321 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1322 : 	lua_pushboolean(L, pkPlot->IsRoutePillaged());

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 1323 : 	return 1;

	mov	eax, 1

; 1324 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsRoutePillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRoutePillaged
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
; Function compile flags: /Odtp
;	COMDAT ?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkCity$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetPlotCity, COMDAT

; 1328 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1329 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1330 : 	CvCity* pkCity = pkPlot->getPlotCity();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pkCity$[ebp], eax

; 1331 : 	CvLuaCity::Push(L, pkCity);

	mov	ecx, DWORD PTR _pkCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
	add	esp, 8

; 1332 : 	return 1;

	mov	eax, 1

; 1333 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetPlotCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetPlotCity
_TEXT	ENDS
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
; Function compile flags: /Odtp
;	COMDAT ?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkCity$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetWorkingCity, COMDAT

; 1337 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1338 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1339 : 	CvCity* pkCity = pkPlot->getWorkingCity();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pkCity$[ebp], eax

; 1340 : 	CvLuaCity::Push(L, pkCity);

	mov	ecx, DWORD PTR _pkCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
	add	esp, 8

; 1341 : 	return 1;

	mov	eax, 1

; 1342 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetWorkingCity@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetWorkingCity
_TEXT	ENDS
EXTRN	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ:PROC ; CvPlot::getWorkingCityOverride
; Function compile flags: /Odtp
;	COMDAT ?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkCity$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetWorkingCityOverride, COMDAT

; 1346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1347 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1348 : 	CvCity* pkCity = pkPlot->getWorkingCityOverride();

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getWorkingCityOverride@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCityOverride
	mov	DWORD PTR _pkCity$[ebp], eax

; 1349 : 	CvLuaCity::Push(L, pkCity);

	mov	ecx, DWORD PTR _pkCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
	add	esp, 8

; 1350 : 	return 1;

	mov	eax, 1

; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetWorkingCityOverride@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetWorkingCityOverride
_TEXT	ENDS
EXTRN	?getReconCount@CvPlot@@QBEHXZ:PROC		; CvPlot::getReconCount
; Function compile flags: /Odtp
;	COMDAT ?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetReconCount, COMDAT

; 1355 : {

	push	ebp
	mov	ebp, esp

; 1356 : 	return BasicLuaMethod(L, &CvPlot::getReconCount);

	push	OFFSET ?getReconCount@CvPlot@@QBEHXZ	; CvPlot::getReconCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1357 : }

	pop	ebp
	ret	0
?lGetReconCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetReconCount
_TEXT	ENDS
EXTRN	?getRiverCrossingCount@CvPlot@@QBEHXZ:PROC	; CvPlot::getRiverCrossingCount
; Function compile flags: /Odtp
;	COMDAT ?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRiverCrossingCount, COMDAT

; 1361 : {

	push	ebp
	mov	ebp, esp

; 1362 : 	return BasicLuaMethod(L, &CvPlot::getRiverCrossingCount);

	push	OFFSET ?getRiverCrossingCount@CvPlot@@QBEHXZ ; CvPlot::getRiverCrossingCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1363 : }

	pop	ebp
	ret	0
?lGetRiverCrossingCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRiverCrossingCount
_TEXT	ENDS
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
; Function compile flags: /Odtp
;	COMDAT ?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_eIndex$ = -12						; size = 4
_iResult$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetYield, COMDAT

; 1367 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1368 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1369 : 	const YieldTypes eIndex = (YieldTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eIndex$[ebp], eax

; 1370 : 	const int iResult = pkPlot->getYield(eIndex);

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	mov	DWORD PTR _iResult$[ebp], eax

; 1371 : 	lua_pushinteger(L, iResult);

	mov	eax, DWORD PTR _iResult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 1372 : 	return 1;

	mov	eax, 1

; 1373 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetYield
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>
EXTRN	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::calculateNatureYield
; Function compile flags: /Odtp
;	COMDAT ?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateNatureYield, COMDAT

; 1377 : {

	push	ebp
	mov	ebp, esp

; 1378 : 	return BasicLuaMethod(L, &CvPlot::calculateNatureYield);

	push	OFFSET ?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>
	add	esp, 8

; 1379 : }

	pop	ebp
	ret	0
?lCalculateNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateNatureYield
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>
EXTRN	?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::calculateBestNatureYield
; Function compile flags: /Odtp
;	COMDAT ?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateBestNatureYield, COMDAT

; 1383 : {

	push	ebp
	mov	ebp, esp

; 1384 : 	return BasicLuaMethod(L, &CvPlot::calculateBestNatureYield);

	push	OFFSET ?calculateBestNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@@Z ; CvPlot::calculateBestNatureYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>
	add	esp, 8

; 1385 : }

	pop	ebp
	ret	0
?lCalculateBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateBestNatureYield
_TEXT	ENDS
EXTRN	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::calculateTotalBestNatureYield
; Function compile flags: /Odtp
;	COMDAT ?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateTotalBestNatureYield, COMDAT

; 1389 : {

	push	ebp
	mov	ebp, esp

; 1390 : 	return BasicLuaMethod(L, &CvPlot::calculateTotalBestNatureYield);

	push	OFFSET ?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::calculateTotalBestNatureYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 1391 : }

	pop	ebp
	ret	0
?lCalculateTotalBestNatureYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateTotalBestNatureYield
_TEXT	ENDS
EXTRN	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z:PROC ; CvPlot::calculateImprovementYieldChange
; Function compile flags: /Odtp
;	COMDAT ?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_eYield$ = -28						; size = 4
_ePlayer$ = -24						; size = 4
_eImprovement$ = -20					; size = 4
_eRoute$ = -16						; size = 4
_iResult$ = -12						; size = 4
_bOptional$ = -5					; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lCalculateImprovementYieldChange, COMDAT

; 1395 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1396 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1397 : 	const ImprovementTypes eImprovement = (ImprovementTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eImprovement$[ebp], eax

; 1398 : 	const YieldTypes eYield = (YieldTypes)lua_tointeger(L,3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eYield$[ebp], eax

; 1399 : 	const PlayerTypes ePlayer = (PlayerTypes)lua_tointeger(L, 4);

	push	4
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$[ebp], eax

; 1400 : 	const bool bOptional = luaL_optbool(L, 5, false);

	push	0
	push	5
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bOptional$[ebp], al

; 1401 : 	const RouteTypes eRoute = (RouteTypes)luaL_optint(L, 5, NUM_ROUTE_TYPES);

	push	2
	push	5
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _eRoute$[ebp], eax

; 1402 : 
; 1403 : 	const int iResult = pkPlot->calculateImprovementYieldChange(eImprovement, eYield, ePlayer, bOptional, eRoute);

	mov	eax, DWORD PTR _eRoute$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bOptional$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
	mov	DWORD PTR _iResult$[ebp], eax

; 1404 : 	lua_pushinteger(L, iResult);

	mov	edx, DWORD PTR _iResult$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 1405 : 	return 1;

	mov	eax, 1

; 1406 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lCalculateImprovementYieldChange@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lCalculateImprovementYieldChange
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>
EXTRN	?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z:PROC ; CvPlot::calculateYield
; Function compile flags: /Odtp
;	COMDAT ?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCalculateYield, COMDAT

; 1410 : {

	push	ebp
	mov	ebp, esp

; 1411 : 	return BasicLuaMethod(L, &CvPlot::calculateYield);

	push	OFFSET ?calculateYield@CvPlot@@QAEHW4YieldTypes@@_N@Z ; CvPlot::calculateYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>
	add	esp, 8

; 1412 : }

	pop	ebp
	ret	0
?lCalculateYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCalculateYield
_TEXT	ENDS
EXTRN	?hasYield@CvPlot@@QBE_NXZ:PROC			; CvPlot::hasYield
; Function compile flags: /Odtp
;	COMDAT ?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lHasYield, COMDAT

; 1416 : {

	push	ebp
	mov	ebp, esp

; 1417 : 	return BasicLuaMethod(L, &CvPlot::hasYield);

	push	OFFSET ?hasYield@CvPlot@@QBE_NXZ	; CvPlot::hasYield
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1418 : }

	pop	ebp
	ret	0
?lHasYield@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lHasYield
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>
EXTRN	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z:PROC ; CvPlot::getYieldWithBuild
; Function compile flags: /Odtp
;	COMDAT ?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetYieldWithBuild, COMDAT

; 1422 : {

	push	ebp
	mov	ebp, esp

; 1423 : 	return BasicLuaMethod(L, &CvPlot::getYieldWithBuild);

	push	OFFSET ?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>
	add	esp, 8

; 1424 : }

	pop	ebp
	ret	0
?lGetYieldWithBuild@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetYieldWithBuild
_TEXT	ENDS
EXTRN	?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::countNumAirUnits
; Function compile flags: /Odtp
;	COMDAT ?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCountNumAirUnits, COMDAT

; 1428 : {

	push	ebp
	mov	ebp, esp

; 1429 : 	return BasicLuaMethod(L, &CvPlot::countNumAirUnits);

	push	OFFSET ?countNumAirUnits@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::countNumAirUnits
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 1430 : }

	pop	ebp
	ret	0
?lCountNumAirUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCountNumAirUnits
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
EXTRN	?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z:PROC ; CvPlot::getFoundValue
; Function compile flags: /Odtp
;	COMDAT ?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetFoundValue, COMDAT

; 1434 : {

	push	ebp
	mov	ebp, esp

; 1435 : 	return BasicLuaMethod(L, &CvPlot::getFoundValue);

	push	OFFSET ?getFoundValue@CvPlot@@QAEHW4PlayerTypes@@@Z ; CvPlot::getFoundValue
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 1436 : }

	pop	ebp
	ret	0
?lGetFoundValue@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetFoundValue
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
EXTRN	?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isBestAdjacentFound
; Function compile flags: /Odtp
;	COMDAT ?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsBestAdjacentFound, COMDAT

; 1440 : {

	push	ebp
	mov	ebp, esp

; 1441 : 	return BasicLuaMethod(L, &CvPlot::isBestAdjacentFound);

	push	OFFSET ?isBestAdjacentFound@CvPlot@@QAE_NW4PlayerTypes@@@Z ; CvPlot::isBestAdjacentFound
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
	add	esp, 8

; 1442 : }

	pop	ebp
	ret	0
?lIsBestAdjacentFound@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsBestAdjacentFound
_TEXT	ENDS
EXTRN	?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getPlayerCityRadiusCount
; Function compile flags: /Odtp
;	COMDAT ?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetPlayerCityRadiusCount, COMDAT

; 1446 : {

	push	ebp
	mov	ebp, esp

; 1447 : 	return BasicLuaMethod(L, &CvPlot::getPlayerCityRadiusCount);

	push	OFFSET ?getPlayerCityRadiusCount@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getPlayerCityRadiusCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
	add	esp, 8

; 1448 : }

	pop	ebp
	ret	0
?lGetPlayerCityRadiusCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetPlayerCityRadiusCount
_TEXT	ENDS
EXTRN	?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isPlayerCityRadius
; Function compile flags: /Odtp
;	COMDAT ?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsPlayerCityRadius, COMDAT

; 1452 : {

	push	ebp
	mov	ebp, esp

; 1453 : 	return BasicLuaMethod(L, &CvPlot::isPlayerCityRadius);

	push	OFFSET ?isPlayerCityRadius@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isPlayerCityRadius
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
	add	esp, 8

; 1454 : }

	pop	ebp
	ret	0
?lIsPlayerCityRadius@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsPlayerCityRadius
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Odtp
;	COMDAT ?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetVisibilityCount, COMDAT

; 1458 : {

	push	ebp
	mov	ebp, esp

; 1459 : 	return BasicLuaMethod(L, &CvPlot::getVisibilityCount);

	push	OFFSET ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::getVisibilityCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
	add	esp, 8

; 1460 : }

	pop	ebp
	ret	0
?lGetVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetVisibilityCount
_TEXT	ENDS
EXTRN	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z:PROC ; CvPlot::changeVisibilityCount
; Function compile flags: /Odtp
;	COMDAT ?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_eSeeInvisible$ = -24					; size = 4
_bAlwaysSeeInvisible$ = -17				; size = 1
_iChange$ = -16						; size = 4
_eTeam$ = -12						; size = 4
_bInformExplorationTracking$ = -5			; size = 1
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeVisibilityCount, COMDAT

; 1464 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1465 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1466 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1467 : 	const int iChange = lua_toboolean(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_toboolean
	add	esp, 8
	mov	DWORD PTR _iChange$[ebp], eax

; 1468 : 	const int eSeeInvisible = lua_tointeger(L, 4);

	push	4
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eSeeInvisible$[ebp], eax

; 1469 : 	const bool bInformExplorationTracking = lua_toboolean(L, 5);

	push	5
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bInformExplorationTracking$[ebp], dl

; 1470 : 	const bool bAlwaysSeeInvisible = lua_toboolean(L, 6);

	push	6
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	cl
	mov	BYTE PTR _bAlwaysSeeInvisible$[ebp], cl

; 1471 : 
; 1472 : 	pkPlot->changeVisibilityCount(eTeam, iChange, static_cast<InvisibleTypes>(eSeeInvisible), bInformExplorationTracking, bAlwaysSeeInvisible);

	movzx	edx, BYTE PTR _bAlwaysSeeInvisible$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bInformExplorationTracking$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eSeeInvisible$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iChange$[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?changeVisibilityCount@CvPlot@@QAE?AW4PlotVisibilityChangeResult@@W4TeamTypes@@HW4InvisibleTypes@@_N2@Z ; CvPlot::changeVisibilityCount

; 1473 : 
; 1474 : 	return 0;

	xor	eax, eax

; 1475 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lChangeVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeVisibilityCount
_TEXT	ENDS
EXTRN	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedOwner
EXTRN	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedOwner
; Function compile flags: /Odtp
;	COMDAT ?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bDebug$ = -9						; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetRevealedOwner, COMDAT

; 1479 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1480 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1481 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1482 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 1483 : 
; 1484 : 	if (!bDebug)

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	jne	SHORT $LN2@lGetReveal

; 1485 : 		lua_pushinteger(L, pkPlot->getRevealedOwner(eTeam));

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedOwner
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1486 : 	else

	jmp	SHORT $LN1@lGetReveal
$LN2@lGetReveal:

; 1487 : 		lua_pushinteger(L, pkPlot->getRevealedOwner(eTeam, true));

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedOwner@CvPlot@@QBE?AW4PlayerTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedOwner
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8
$LN1@lGetReveal:

; 1488 : 
; 1489 : 	return 1;

	mov	eax, 1

; 1490 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetRevealedOwner@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetRevealedOwner
_TEXT	ENDS
EXTRN	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z:PROC ; CvPlot::getRevealedTeam
EXTRN	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z:PROC ; CvPlot::getRevealedTeam
; Function compile flags: /Odtp
;	COMDAT ?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bDebug$ = -9						; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetRevealedTeam, COMDAT

; 1494 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1495 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1496 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1497 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 1498 : 
; 1499 : 	if (!bDebug)

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	jne	SHORT $LN2@lGetReveal@2

; 1500 : 		lua_pushinteger(L, pkPlot->getRevealedTeam(eTeam));

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@@Z ; CvPlot::getRevealedTeam
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1501 : 	else

	jmp	SHORT $LN1@lGetReveal@2
$LN2@lGetReveal@2:

; 1502 : 		lua_pushinteger(L, pkPlot->getRevealedTeam(eTeam, true));

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedTeam@CvPlot@@QBE?AW4TeamTypes@@W42@_N@Z ; CvPlot::getRevealedTeam
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8
$LN1@lGetReveal@2:

; 1503 : 
; 1504 : 	return 1;

	mov	eax, 1

; 1505 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetRevealedTeam@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetRevealedTeam
_TEXT	ENDS
EXTRN	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z:PROC ; CvPlot::isRiverCrossing
; Function compile flags: /Odtp
;	COMDAT ?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRiverCrossing, COMDAT

; 1509 : {

	push	ebp
	mov	ebp, esp

; 1510 : 	return BasicLuaMethod(L, &CvPlot::isRiverCrossing);

	push	OFFSET ?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
	add	esp, 8

; 1511 : }

	pop	ebp
	ret	0
?lIsRiverCrossing@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRiverCrossing
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
; Function compile flags: /Odtp
;	COMDAT ?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bIsCrossingRiver$ = -9					; size = 1
_pkMyPlot$ = -8						; size = 4
_pkOtherPlot$ = -4					; size = 4
_L$ = 8							; size = 4
?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsRiverCrossingToPlot, COMDAT

; 1515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 1516 : 	bool bIsCrossingRiver = false;

	mov	BYTE PTR _bIsCrossingRiver$[ebp], 0

; 1517 : 	CvPlot* pkMyPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkMyPlot$[ebp], eax

; 1518 : 	CvPlot* pkOtherPlot = GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkOtherPlot$[ebp], eax

; 1519 : 
; 1520 : 	if(pkMyPlot->isRiverCrossing(directionXY(pkMyPlot, pkOtherPlot)))

	mov	edx, DWORD PTR _pkOtherPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pkMyPlot$[ebp]
	push	eax
	call	?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ; directionXY
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkMyPlot$[ebp]
	call	?isRiverCrossing@CvPlot@@QBE_NW4DirectionTypes@@@Z ; CvPlot::isRiverCrossing
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@lIsRiverCr

; 1521 : 	{
; 1522 : 		bIsCrossingRiver = true;

	mov	BYTE PTR _bIsCrossingRiver$[ebp], 1
$LN1@lIsRiverCr:

; 1523 : 	}
; 1524 : 
; 1525 : 	lua_pushboolean(L, bIsCrossingRiver);

	movzx	edx, BYTE PTR _bIsCrossingRiver$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushboolean
	add	esp, 8

; 1526 : 	return 1;

	mov	eax, 1

; 1527 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsRiverCrossingToPlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsRiverCrossingToPlot
_TEXT	ENDS
PUBLIC	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z	; directionXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z
_TEXT	SEGMENT
$T224135 = -16						; size = 4
$T224131 = -12						; size = 4
$T224127 = -8						; size = 4
$T224123 = -4						; size = 4
_pFromPlot$ = 8						; size = 4
_pToPlot$ = 12						; size = 4
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z PROC	; directionXY, COMDAT

; 311  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 312  : 	return directionXY(pFromPlot->getX(), pFromPlot->getY(),
; 313  : 	                   pToPlot->getX(), pToPlot->getY());

	mov	eax, DWORD PTR _pToPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224123[ebp], ecx
	mov	edx, DWORD PTR _pToPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224127[ebp], eax
	mov	ecx, DWORD PTR _pFromPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T224131[ebp], edx
	mov	eax, DWORD PTR _pFromPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T224135[ebp], ecx
	mov	edx, DWORD PTR $T224123[ebp]
	push	edx
	mov	eax, DWORD PTR $T224127[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224131[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224135[ebp]
	push	edx
	call	?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ; directionXY
	add	esp, 16					; 00000010H

; 314  : 
; 315  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@PBVCvPlot@@0@Z ENDP	; directionXY
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
;	COMDAT ?directionXY@@YA?AW4DirectionTypes@@HHHH@Z
_TEXT	SEGMENT
tv90 = -56						; size = 4
tv86 = -52						; size = 4
_iDestHexX$ = -16					; size = 4
_iWrappedXOffset$ = -12					; size = 4
_iSourceHexX$ = -8					; size = 4
_iWrappedYOffset$ = -4					; size = 4
_iSourceX$ = 8						; size = 4
_iSourceY$ = 12						; size = 4
_iDestX$ = 16						; size = 4
_iDestY$ = 20						; size = 4
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z PROC		; directionXY, COMDAT

; 264  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 265  : 	int iSourceHexX = xToHexspaceX(iSourceX, iSourceY);

	cmp	DWORD PTR _iSourceY$[ebp], 0
	jl	SHORT $LN17@directionX
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN15@directionX
$LN17@directionX:
	mov	eax, DWORD PTR _iSourceY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN15@directionX:
	mov	ecx, DWORD PTR _iSourceX$[ebp]
	sub	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iSourceHexX$[ebp], ecx

; 266  : 	int iDestHexX = xToHexspaceX(iDestX, iDestY);

	cmp	DWORD PTR _iDestY$[ebp], 0
	jl	SHORT $LN21@directionX
	mov	edx, DWORD PTR _iDestY$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN19@directionX
$LN21@directionX:
	mov	eax, DWORD PTR _iDestY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv90[ebp], eax
$LN19@directionX:
	mov	eax, DWORD PTR _iDestX$[ebp]
	sub	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR _iDestHexX$[ebp], eax

; 267  : 
; 268  : 	int iWrappedXOffset = dxWrap(iDestHexX - iSourceHexX);

	mov	ecx, DWORD PTR _iDestHexX$[ebp]
	sub	ecx, DWORD PTR _iSourceHexX$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedXOffset$[ebp], eax

; 269  : 	int iWrappedYOffset = dyWrap(iDestY - iSourceY);

	mov	edx, DWORD PTR _iDestY$[ebp]
	sub	edx, DWORD PTR _iSourceY$[ebp]
	push	edx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedYOffset$[ebp], eax

; 270  : 
; 271  : 	if(iWrappedYOffset > 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jle	SHORT $LN12@directionX

; 272  : 	{
; 273  : 		if(iWrappedXOffset >= 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jl	SHORT $LN11@directionX

; 274  : 		{
; 275  : 			return DIRECTION_NORTHEAST;

	xor	eax, eax
	jmp	SHORT $LN13@directionX

; 276  : 		}
; 277  : 		else

	jmp	SHORT $LN10@directionX
$LN11@directionX:

; 278  : 		{
; 279  : 			return DIRECTION_NORTHWEST;

	mov	eax, 5
	jmp	SHORT $LN13@directionX
$LN10@directionX:

; 280  : 		}

	jmp	SHORT $LN13@directionX
$LN12@directionX:

; 281  : 	}
; 282  : 	else if(iWrappedYOffset == 0)

	cmp	DWORD PTR _iWrappedYOffset$[ebp], 0
	jne	SHORT $LN8@directionX

; 283  : 	{
; 284  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN7@directionX

; 285  : 		{
; 286  : 			return DIRECTION_EAST;

	mov	eax, 1
	jmp	SHORT $LN13@directionX
	jmp	SHORT $LN6@directionX
$LN7@directionX:

; 287  : 		}
; 288  : 		else if(iWrappedXOffset == 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jne	SHORT $LN5@directionX

; 289  : 		{
; 290  : 			return NO_DIRECTION;

	or	eax, -1
	jmp	SHORT $LN13@directionX

; 291  : 		}
; 292  : 		else

	jmp	SHORT $LN6@directionX
$LN5@directionX:

; 293  : 		{
; 294  : 			return DIRECTION_WEST;

	mov	eax, 4
	jmp	SHORT $LN13@directionX
$LN6@directionX:

; 295  : 		}
; 296  : 	}
; 297  : 	else// if (iWrappedYOffset < 0)

	jmp	SHORT $LN13@directionX
$LN8@directionX:

; 298  : 	{
; 299  : 		if(iWrappedXOffset > 0)

	cmp	DWORD PTR _iWrappedXOffset$[ebp], 0
	jle	SHORT $LN2@directionX

; 300  : 		{
; 301  : 			return DIRECTION_SOUTHEAST;

	mov	eax, 2
	jmp	SHORT $LN13@directionX

; 302  : 		}
; 303  : 		else

	jmp	SHORT $LN13@directionX
$LN2@directionX:

; 304  : 		{
; 305  : 			return DIRECTION_SOUTHWEST;

	mov	eax, 3
$LN13@directionX:

; 306  : 		}
; 307  : 	}
; 308  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?directionXY@@YA?AW4DirectionTypes@@HHHH@Z ENDP		; directionXY
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T224267 = -16						; size = 4
$T224259 = -12						; size = 4
$T224255 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T224255[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224259[ebp], ecx
	movzx	edx, BYTE PTR $T224255[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T224259[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T224259[ebp]
	mov	DWORD PTR $T224267[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T224259[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T224259[ebp]
	mov	DWORD PTR $T224267[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T224267[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T224267[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T224288 = -16						; size = 4
$T224280 = -12						; size = 4
$T224276 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T224276[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T224280[ebp], ecx
	movzx	edx, BYTE PTR $T224276[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T224280[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T224280[ebp]
	mov	DWORD PTR $T224288[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T224280[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T224280[ebp]
	mov	DWORD PTR $T224288[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T224288[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T224288[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z	; CvPlot::isRevealed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
;	COMDAT ?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_uiOffset$224299 = -16					; size = 4
_bDebug$ = -9						; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lIsRevealed, COMDAT

; 1531 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1532 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1533 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1534 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 1535 : 
; 1536 : 	if (!bDebug)

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	jne	SHORT $LN2@lIsReveale

; 1537 : 		lua_pushboolean(L, pkPlot->isRevealed(eTeam));

	mov	ecx, DWORD PTR _eTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$224299[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$224299[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$224299[ebp]
	mov	edx, DWORD PTR _pkPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 1538 : 	else

	jmp	SHORT $LN1@lIsReveale
$LN2@lIsReveale:

; 1539 : 		lua_pushboolean(L, pkPlot->isRevealed(eTeam, true));

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isRevealed
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushboolean
	add	esp, 8
$LN1@lIsReveale:

; 1540 : 
; 1541 : 	return 1;

	mov	eax, 1

; 1542 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lIsRevealed
_TEXT	ENDS
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
; Function compile flags: /Odtp
;	COMDAT ?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bNewValue$ = -17					; size = 1
_eFromTeam$ = -16					; size = 4
_bTerrainOnly$ = -9					; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetRevealed, COMDAT

; 1546 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1547 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1548 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1549 : 	const bool bNewValue = lua_toboolean(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR _bNewValue$[ebp], al

; 1550 : 	const bool bTerrainOnly = luaL_optint(L, 4, 0);

	push	0
	push	4
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bTerrainOnly$[ebp], dl

; 1551 : 	const TeamTypes eFromTeam = (TeamTypes)luaL_optint(L, 5, NO_TEAM);

	push	-1
	push	5
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _eFromTeam$[ebp], eax

; 1552 : 	pkPlot->setRevealed(eTeam, bNewValue, bTerrainOnly, eFromTeam);

	mov	ecx, DWORD PTR _eFromTeam$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bTerrainOnly$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bNewValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed

; 1553 : 
; 1554 : 	return 0;

	xor	eax, eax

; 1555 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lSetRevealed@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetRevealed
_TEXT	ENDS
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedImprovementType
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedImprovementType
; Function compile flags: /Odtp
;	COMDAT ?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bDebug$ = -9						; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRevealedImprovementType, COMDAT

; 1559 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1560 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1561 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1562 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 1563 : 
; 1564 : 	if (!bDebug)

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	jne	SHORT $LN2@lGetReveal@3

; 1565 : 		lua_pushinteger(L, pkPlot->getRevealedImprovementType(eTeam));

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1566 : 	else

	jmp	SHORT $LN1@lGetReveal@3
$LN2@lGetReveal@3:

; 1567 : 		lua_pushinteger(L, pkPlot->getRevealedImprovementType(eTeam, true));

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedImprovementType
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8
$LN1@lGetReveal@3:

; 1568 : 
; 1569 : 	return 1;

	mov	eax, 1

; 1570 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetRevealedImprovementType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRevealedImprovementType
_TEXT	ENDS
EXTRN	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::getRevealedRouteType
EXTRN	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedRouteType
; Function compile flags: /Odtp
;	COMDAT ?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bDebug$ = -9						; size = 1
_eTeam$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetRevealedRouteType, COMDAT

; 1574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1575 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1576 : 	const TeamTypes eTeam = (TeamTypes)lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1577 : 	const bool bDebug = luaL_optbool(L, 3, false);

	push	0
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	?luaL_optbool@@YA_NPAUlua_State@@H_N@Z	; luaL_optbool
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _bDebug$[ebp], al

; 1578 : 
; 1579 : 	if (!bDebug)

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	jne	SHORT $LN2@lGetReveal@4

; 1580 : 		lua_pushinteger(L, pkPlot->getRevealedRouteType(eTeam));

	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedRouteType
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1581 : 	else

	jmp	SHORT $LN1@lGetReveal@4
$LN2@lGetReveal@4:

; 1582 : 		lua_pushinteger(L, pkPlot->getRevealedRouteType(eTeam, true));

	push	1
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getRevealedRouteType@CvPlot@@QBE?AW4RouteTypes@@W4TeamTypes@@_N@Z ; CvPlot::getRevealedRouteType
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8
$LN1@lGetReveal@4:

; 1583 : 
; 1584 : 	return 1;

	mov	eax, 1

; 1585 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetRevealedRouteType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetRevealedRouteType
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>
EXTRN	?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z:PROC ; CvPlot::getBuildProgress
; Function compile flags: /Odtp
;	COMDAT ?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetBuildProgress, COMDAT

; 1589 : {

	push	ebp
	mov	ebp, esp

; 1590 : 	return BasicLuaMethod(L, &CvPlot::getBuildProgress);

	push	OFFSET ?getBuildProgress@CvPlot@@QBEHW4BuildTypes@@@Z ; CvPlot::getBuildProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>
	add	esp, 8

; 1591 : }

	pop	ebp
	ret	0
?lGetBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetBuildProgress
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>
EXTRN	?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z:PROC ; CvPlot::changeBuildProgress
; Function compile flags: /Odtp
;	COMDAT ?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeBuildProgress, COMDAT

; 1595 : {

	push	ebp
	mov	ebp, esp

; 1596 : 	return BasicLuaMethod(L, &CvPlot::changeBuildProgress);

	push	OFFSET ?changeBuildProgress@CvPlot@@QAE_NW4BuildTypes@@HW4PlayerTypes@@@Z ; CvPlot::changeBuildProgress
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>
	add	esp, 8

; 1597 : }

	pop	ebp
	ret	0
?lChangeBuildProgress@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeBuildProgress
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>
EXTRN	?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z:PROC ; CvPlot::getInvisibleVisibilityCount
; Function compile flags: /Odtp
;	COMDAT ?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetInvisibleVisibilityCount, COMDAT

; 1601 : {

	push	ebp
	mov	ebp, esp

; 1602 : 	return BasicLuaMethod(L, &CvPlot::getInvisibleVisibilityCount);

	push	OFFSET ?getInvisibleVisibilityCount@CvPlot@@QBEHW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::getInvisibleVisibilityCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>
	add	esp, 8

; 1603 : }

	pop	ebp
	ret	0
?lGetInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetInvisibleVisibilityCount
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>
EXTRN	?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z:PROC ; CvPlot::isInvisibleVisible
; Function compile flags: /Odtp
;	COMDAT ?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsInvisibleVisible, COMDAT

; 1607 : {

	push	ebp
	mov	ebp, esp

; 1608 : 	return BasicLuaMethod(L, &CvPlot::isInvisibleVisible);

	push	OFFSET ?isInvisibleVisible@CvPlot@@QBE_NW4TeamTypes@@W4InvisibleTypes@@@Z ; CvPlot::isInvisibleVisible
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>
	add	esp, 8

; 1609 : }

	pop	ebp
	ret	0
?lIsInvisibleVisible@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsInvisibleVisible
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>
EXTRN	?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z:PROC ; CvPlot::changeInvisibleVisibilityCount
; Function compile flags: /Odtp
;	COMDAT ?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lChangeInvisibleVisibilityCount, COMDAT

; 1613 : {

	push	ebp
	mov	ebp, esp

; 1614 : 	return BasicLuaMethod(L, &CvPlot::changeInvisibleVisibilityCount);

	push	OFFSET ?changeInvisibleVisibilityCount@CvPlot@@QAEXW4TeamTypes@@W4InvisibleTypes@@H@Z ; CvPlot::changeInvisibleVisibilityCount
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>
	add	esp, 8

; 1615 : }

	pop	ebp
	ret	0
?lChangeInvisibleVisibilityCount@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lChangeInvisibleVisibilityCount
_TEXT	ENDS
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
; Function compile flags: /Odtp
;	COMDAT ?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumUnits, COMDAT

; 1619 : {

	push	ebp
	mov	ebp, esp

; 1620 : 	return BasicLuaMethod(L, &CvPlot::getNumUnits);

	push	OFFSET ?getNumUnits@CvPlot@@QBEHXZ	; CvPlot::getNumUnits
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1621 : }

	pop	ebp
	ret	0
?lGetNumUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumUnits
_TEXT	ENDS
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
; Function compile flags: /Odtp
;	COMDAT ?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -12						; size = 4
_iIndex$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC		; CvLuaPlot::lGetUnit, COMDAT

; 1625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1626 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1627 : 	const int iIndex = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iIndex$[ebp], eax

; 1628 : 
; 1629 : 	CvUnit* pkUnit = pkPlot->getUnitByIndex(iIndex);

	mov	edx, DWORD PTR _iIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pkUnit$[ebp], eax

; 1630 : 	CvLuaUnit::Push(L, pkUnit);

	mov	eax, DWORD PTR _pkUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
	add	esp, 8

; 1631 : 	return 1;

	mov	eax, 1

; 1632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP		; CvLuaPlot::lGetUnit
_TEXT	ENDS
EXTRN	?getNumLayerUnits@CvPlot@@QBEHH@Z:PROC		; CvPlot::getNumLayerUnits
; Function compile flags: /Odtp
;	COMDAT ?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iLayerID$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetNumLayerUnits, COMDAT

; 1636 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1637 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1638 : 	const int iLayerID = luaL_optinteger(L, 2, -1);

	push	-1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iLayerID$[ebp], eax

; 1639 : 
; 1640 : 	lua_pushinteger(L, pkPlot->getNumLayerUnits(iLayerID));

	mov	edx, DWORD PTR _iLayerID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getNumLayerUnits@CvPlot@@QBEHH@Z	; CvPlot::getNumLayerUnits
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 1641 : 	return 1;

	mov	eax, 1

; 1642 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetNumLayerUnits@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetNumLayerUnits
_TEXT	ENDS
EXTRN	?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z:PROC	; CvPlot::getLayerUnit
; Function compile flags: /Odtp
;	COMDAT ?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkUnit$ = -16						; size = 4
_iIndex$ = -12						; size = 4
_iLayerID$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetLayerUnit, COMDAT

; 1646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1647 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1648 : 	const int iIndex = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iIndex$[ebp], eax

; 1649 : 	const int iLayerID = luaL_optinteger(L, 3, -1);

	push	-1
	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_optinteger
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iLayerID$[ebp], eax

; 1650 : 
; 1651 : 	CvUnit* pkUnit = pkPlot->getLayerUnit(iIndex, iLayerID);

	mov	eax, DWORD PTR _iLayerID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getLayerUnit@CvPlot@@QBEPAVCvUnit@@HH@Z ; CvPlot::getLayerUnit
	mov	DWORD PTR _pkUnit$[ebp], eax

; 1652 : 	CvLuaUnit::Push(L, pkUnit);

	mov	edx, DWORD PTR _pkUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
	add	esp, 8

; 1653 : 	return 1;

	mov	eax, 1

; 1654 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetLayerUnit@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetLayerUnit
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	__$ArrayPad$
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getScriptData@CvPlot@@QBE?AVCvString@@XZ:PROC	; CvPlot::getScriptData
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaplot.cpp
xdata$x	ENDS
;	COMDAT ?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T224337 = -52						; size = 4
_strResult$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_pkPlot$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetScriptData, COMDAT

; 1658 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1659 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1660 : 	const CvString strResult = pkPlot->getScriptData();

	lea	ecx, DWORD PTR _strResult$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?getScriptData@CvPlot@@QBE?AVCvString@@XZ ; CvPlot::getScriptData
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1661 : 	lua_pushstring(L, strResult.c_str());

	lea	ecx, DWORD PTR _strResult$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 1662 : 	return 1;

	mov	DWORD PTR $T224337[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strResult$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR $T224337[ebp]

; 1663 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _strResult$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?lGetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetScriptData
EXTRN	?setScriptData@CvPlot@@QAEXPBD@Z:PROC		; CvPlot::setScriptData
EXTRN	_lua_tolstring:PROC
; Function compile flags: /Odtp
;	COMDAT ?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_strNewValue$ = -8					; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetScriptData, COMDAT

; 1667 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1668 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1669 : 	const char* strNewValue = lua_tostring(L, 2);

	push	0
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tolstring
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _strNewValue$[ebp], eax

; 1670 : 
; 1671 : 	pkPlot->setScriptData(strNewValue);

	mov	edx, DWORD PTR _strNewValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?setScriptData@CvPlot@@QAEXPBD@Z	; CvPlot::setScriptData

; 1672 : 	return 0;

	xor	eax, eax

; 1673 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lSetScriptData@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetScriptData
_TEXT	ENDS
EXTRN	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ:PROC ; CvPlot::GetActiveFogOfWarMode
; Function compile flags: /Odtp
;	COMDAT ?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
_fow$ = -8						; size = 4
_pkPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetActiveFogOfWarMode, COMDAT

; 1677 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1678 : 	CvPlot* pkPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkPlot$[ebp], eax

; 1679 : 
; 1680 : 	int fow = 0;

	mov	DWORD PTR _fow$[ebp], 0

; 1681 : 	// convert from game fog of war defines to engine fog of war defines
; 1682 : 	switch(pkPlot->GetActiveFogOfWarMode())

	mov	ecx, DWORD PTR _pkPlot$[ebp]
	call	?GetActiveFogOfWarMode@CvPlot@@QBE?AW4FogOfWarModeTypes@@XZ ; CvPlot::GetActiveFogOfWarMode
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 0
	je	SHORT $LN3@lGetActive
	cmp	DWORD PTR tv70[ebp], 1
	je	SHORT $LN2@lGetActive
	cmp	DWORD PTR tv70[ebp], 2
	je	SHORT $LN1@lGetActive
	jmp	SHORT $LN4@lGetActive
$LN3@lGetActive:

; 1683 : 	{
; 1684 : 	case FOGOFWARMODE_OFF:
; 1685 : 		fow = 2;

	mov	DWORD PTR _fow$[ebp], 2
$LN2@lGetActive:

; 1686 : #ifdef AUI_WARNING_FIXES
; 1687 : 		break;
; 1688 : #else
; 1689 : 	case FOGOFWARMODE_UNEXPLORED:
; 1690 : 		fow = 0;

	mov	DWORD PTR _fow$[ebp], 0
$LN1@lGetActive:

; 1691 : #endif
; 1692 : 	case FOGOFWARMODE_NOVIS:
; 1693 : 		fow = 1;

	mov	DWORD PTR _fow$[ebp], 1
$LN4@lGetActive:

; 1694 : #ifdef AUI_WARNING_FIXES
; 1695 : 		break;
; 1696 : #endif
; 1697 : 	}
; 1698 : 
; 1699 : 	lua_pushinteger(L, fow);

	mov	ecx, DWORD PTR _fow$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1700 : 	return 1;

	mov	eax, 1

; 1701 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetActiveFogOfWarMode@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetActiveFogOfWarMode
_TEXT	ENDS
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
; Function compile flags: /Odtp
;	COMDAT ?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsImprovementPillaged, COMDAT

; 1705 : {

	push	ebp
	mov	ebp, esp

; 1706 : 	return BasicLuaMethod(L, &CvPlot::IsImprovementPillaged);

	push	OFFSET ?IsImprovementPillaged@CvPlot@@QBE_NXZ ; CvPlot::IsImprovementPillaged
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1707 : }

	pop	ebp
	ret	0
?lIsImprovementPillaged@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsImprovementPillaged
_TEXT	ENDS
EXTRN	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z:PROC ; CvPlot::canSeePlot
; Function compile flags: /Odtp
;	COMDAT ?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iRange$ = -24						; size = 4
_eFacingDirection$ = -20				; size = 4
_pkThatPlot$ = -16					; size = 4
_pkThisPlot$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_bCanSee$ = -1						; size = 1
_L$ = 8							; size = 4
?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lCanSeePlot, COMDAT

; 1712 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1713 : 	CvPlot* pkThisPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkThisPlot$[ebp], eax

; 1714 : 	CvPlot* pkThatPlot = GetInstance(L, 2);

	push	1
	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkThatPlot$[ebp], eax

; 1715 : 	TeamTypes eTeam = (TeamTypes) lua_tointeger(L, 3);

	push	3
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$[ebp], eax

; 1716 : 	int iRange = lua_tointeger(L, 4);

	push	4
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iRange$[ebp], eax

; 1717 : 	DirectionTypes eFacingDirection = (DirectionTypes) lua_tointeger(L, 5);

	push	5
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eFacingDirection$[ebp], eax

; 1718 : 
; 1719 : 	bool bCanSee = false;

	mov	BYTE PTR _bCanSee$[ebp], 0

; 1720 : 	if(pkThisPlot)

	cmp	DWORD PTR _pkThisPlot$[ebp], 0
	je	SHORT $LN1@lCanSeePlo

; 1721 : 	{
; 1722 : 		bCanSee = pkThisPlot->canSeePlot(pkThatPlot, eTeam, iRange, eFacingDirection);

	mov	edx, DWORD PTR _eFacingDirection$[ebp]
	push	edx
	mov	eax, DWORD PTR _iRange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkThatPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkThisPlot$[ebp]
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
	mov	BYTE PTR _bCanSee$[ebp], al
$LN1@lCanSeePlo:

; 1723 : 	}
; 1724 : 
; 1725 : 	lua_pushboolean(L, bCanSee);

	movzx	eax, BYTE PTR _bCanSee$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 1726 : 	return 1;

	mov	eax, 1

; 1727 : 
; 1728 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lCanSeePlot@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lCanSeePlot
_TEXT	ENDS
EXTRN	?GetContinentType@CvPlot@@QBEDXZ:PROC		; CvPlot::GetContinentType
; Function compile flags: /Odtp
;	COMDAT ?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_pkThisPlot$ = -4					; size = 4
_L$ = 8							; size = 4
?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetContinentArtType, COMDAT

; 1732 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1733 : 	CvPlot* pkThisPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkThisPlot$[ebp], eax

; 1734 : 	if(pkThisPlot)

	cmp	DWORD PTR _pkThisPlot$[ebp], 0
	je	SHORT $LN2@lGetContin

; 1735 : 	{
; 1736 : 		lua_pushinteger(L, pkThisPlot->GetContinentType());

	mov	ecx, DWORD PTR _pkThisPlot$[ebp]
	call	?GetContinentType@CvPlot@@QBEDXZ	; CvPlot::GetContinentType
	movsx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 1737 : 	}
; 1738 : 	else

	jmp	SHORT $LN1@lGetContin
$LN2@lGetContin:

; 1739 : 	{
; 1740 : 		lua_pushinteger(L, 0);

	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8
$LN1@lGetContin:

; 1741 : 	}
; 1742 : 	return 1;

	mov	eax, 1

; 1743 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetContinentArtType
_TEXT	ENDS
EXTRN	?SetContinentType@CvPlot@@QAEXD@Z:PROC		; CvPlot::SetContinentType
; Function compile flags: /Odtp
;	COMDAT ?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iContinentType$222389 = -8				; size = 4
_pkThisPlot$ = -4					; size = 4
_L$ = 8							; size = 4
?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lSetContinentArtType, COMDAT

; 1747 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1748 : 	CvPlot* pkThisPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkThisPlot$[ebp], eax

; 1749 : 	if(pkThisPlot)

	cmp	DWORD PTR _pkThisPlot$[ebp], 0
	je	SHORT $LN1@lSetContin

; 1750 : 	{
; 1751 : 		const int iContinentType = lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _iContinentType$222389[ebp], eax

; 1752 : 		pkThisPlot->SetContinentType((char) iContinentType);

	movzx	edx, BYTE PTR _iContinentType$222389[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkThisPlot$[ebp]
	call	?SetContinentType@CvPlot@@QAEXD@Z	; CvPlot::SetContinentType
$LN1@lSetContin:

; 1753 : 	}
; 1754 : 	return 0;

	xor	eax, eax

; 1755 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lSetContinentArtType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lSetContinentArtType
_TEXT	ENDS
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
; Function compile flags: /Odtp
;	COMDAT ?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T224366 = -20						; size = 4
_pkImprovementInfo$ = -16				; size = 4
_bResult$ = -9						; size = 1
_eImprovement$ = -8					; size = 4
_kPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsResourceConnectedByImprovement, COMDAT

; 1760 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1761 : 	bool bResult = false;

	mov	BYTE PTR _bResult$[ebp], 0

; 1762 : 	CvPlot* kPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _kPlot$[ebp], eax

; 1763 : 	const ImprovementTypes eImprovement = (ImprovementTypes) lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eImprovement$[ebp], eax

; 1764 : 	CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$[ebp], eax

; 1765 : 	if(pkImprovementInfo)

	cmp	DWORD PTR _pkImprovementInfo$[ebp], 0
	je	SHORT $LN1@lIsResourc

; 1766 : 	{
; 1767 : 		bResult = pkImprovementInfo->IsImprovementResourceTrade(kPlot->getResourceType(GC.getGame().getActiveTeam()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224366[ebp], eax
	mov	ecx, DWORD PTR $T224366[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	push	eax
	mov	ecx, DWORD PTR _kPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	push	eax
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	mov	BYTE PTR _bResult$[ebp], al
$LN1@lIsResourc:

; 1768 : 	}
; 1769 : 
; 1770 : 	lua_pushboolean(L, bResult);

	movzx	ecx, BYTE PTR _bResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 1771 : 	return 1;

	mov	eax, 1

; 1772 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsResourceConnectedByImprovement@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsResourceConnectedByImprovement
_TEXT	ENDS
EXTRN	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z:PROC	; CvBuildInfo::isFeatureRemove
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
; Function compile flags: /Odtp
;	COMDAT ?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_f$224386 = -15						; size = 1
_f$224377 = -14						; size = 1
_bFeatureRemoved$ = -13					; size = 1
_eBuild$ = -12						; size = 4
_kPlot$ = -8						; size = 4
_pkBuildInfo$ = -4					; size = 4
_L$ = 8							; size = 4
?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lIsBuildRemovesFeature, COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1777 : 	CvPlot* kPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _kPlot$[ebp], eax

; 1778 : 	const BuildTypes eBuild = (BuildTypes) lua_tointeger(L, 2);

	push	2
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eBuild$[ebp], eax

; 1779 : 	bool bFeatureRemoved = false;

	mov	BYTE PTR _bFeatureRemoved$[ebp], 0

; 1780 : 
; 1781 : 	CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$[ebp], eax

; 1782 : 	if(NULL != pkBuildInfo && kPlot->getFeatureType() != NO_FEATURE)

	cmp	DWORD PTR _pkBuildInfo$[ebp], 0
	je	SHORT $LN1@lIsBuildRe
	mov	eax, DWORD PTR _kPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$224377[ebp], cl
	movsx	edx, BYTE PTR _f$224377[ebp]
	cmp	edx, -1
	je	SHORT $LN1@lIsBuildRe

; 1783 : 		bFeatureRemoved = pkBuildInfo->isFeatureRemove(kPlot->getFeatureType());

	mov	eax, DWORD PTR _kPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$224386[ebp], cl
	movsx	edx, BYTE PTR _f$224386[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkBuildInfo$[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	mov	BYTE PTR _bFeatureRemoved$[ebp], al
$LN1@lIsBuildRe:

; 1784 : 
; 1785 : 	lua_pushboolean(L, bFeatureRemoved);

	movzx	eax, BYTE PTR _bFeatureRemoved$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 1786 : 	return 1;

	mov	eax, 1

; 1787 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lIsBuildRemovesFeature@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lIsBuildRemovesFeature
_TEXT	ENDS
EXTRN	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ:PROC ; CvPlot::GetArchaeologicalRecord
; Function compile flags: /Odtp
;	COMDAT ?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T224389 = -28						; size = 20
_iType$ = -8						; size = 4
_kPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactType, COMDAT

; 1791 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1792 : 	CvPlot* kPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _kPlot$[ebp], eax

; 1793 : 	int iType = kPlot->GetArchaeologicalRecord().m_eArtifactType;

	lea	ecx, DWORD PTR $T224389[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlot$[ebp]
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _iType$[ebp], edx

; 1794 : 	lua_pushinteger(L, iType);

	mov	eax, DWORD PTR _iType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 1795 : 	return 1;

	mov	eax, 1

; 1796 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetArchaeologyArtifactType@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T224392 = -28						; size = 20
_kPlot$ = -8						; size = 4
_iEra$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactEra, COMDAT

; 1800 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1801 : 	CvPlot* kPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _kPlot$[ebp], eax

; 1802 : 	int iEra = kPlot->GetArchaeologicalRecord().m_eEra;

	lea	ecx, DWORD PTR $T224392[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlot$[ebp]
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _iEra$[ebp], edx

; 1803 : 	lua_pushinteger(L, iEra);

	mov	eax, DWORD PTR _iEra$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 1804 : 	return 1;

	mov	eax, 1

; 1805 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetArchaeologyArtifactEra@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactEra
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T224395 = -28						; size = 20
_iPlayer$ = -8						; size = 4
_kPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactPlayer1, COMDAT

; 1809 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1810 : 	CvPlot* kPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _kPlot$[ebp], eax

; 1811 : 	int iPlayer = kPlot->GetArchaeologicalRecord().m_ePlayer1;

	lea	ecx, DWORD PTR $T224395[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlot$[ebp]
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _iPlayer$[ebp], edx

; 1812 : 	lua_pushinteger(L, iPlayer);

	mov	eax, DWORD PTR _iPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 1813 : 	return 1;

	mov	eax, 1

; 1814 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetArchaeologyArtifactPlayer1@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactPlayer1
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T224398 = -28						; size = 20
_iPlayer$ = -8						; size = 4
_kPlot$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactPlayer2, COMDAT

; 1818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1819 : 	CvPlot* kPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _kPlot$[ebp], eax

; 1820 : 	int iPlayer = kPlot->GetArchaeologicalRecord().m_ePlayer2;

	lea	ecx, DWORD PTR $T224398[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlot$[ebp]
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _iPlayer$[ebp], edx

; 1821 : 	lua_pushinteger(L, iPlayer);

	mov	eax, DWORD PTR _iPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 1822 : 	return 1;

	mov	eax, 1

; 1823 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetArchaeologyArtifactPlayer2@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactPlayer2
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T224401 = -28						; size = 20
_kPlot$ = -8						; size = 4
_iWork$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lGetArchaeologyArtifactWork, COMDAT

; 1827 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1828 : 	CvPlot* kPlot = GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _kPlot$[ebp], eax

; 1829 : 	int iWork = (int)kPlot->GetArchaeologicalRecord().m_eWork;

	lea	ecx, DWORD PTR $T224401[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlot$[ebp]
	call	?GetArchaeologicalRecord@CvPlot@@QBE?AUCvArchaeologyData@@XZ ; CvPlot::GetArchaeologicalRecord
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _iWork$[ebp], edx

; 1830 : 	lua_pushinteger(L, iWork);

	mov	eax, DWORD PTR _iWork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 1831 : 	return 1;

	mov	eax, 1

; 1832 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?lGetArchaeologyArtifactWork@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lGetArchaeologyArtifactWork
_TEXT	ENDS
EXTRN	?HasWrittenArtifact@CvPlot@@QBE_NXZ:PROC	; CvPlot::HasWrittenArtifact
; Function compile flags: /Odtp
;	COMDAT ?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z PROC ; CvLuaPlot::lHasWrittenArtifact, COMDAT

; 1837 : {

	push	ebp
	mov	ebp, esp

; 1838 : 	return BasicLuaMethod(L, &CvPlot::HasWrittenArtifact);

	push	OFFSET ?HasWrittenArtifact@CvPlot@@QBE_NXZ ; CvPlot::HasWrittenArtifact
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
	add	esp, 8

; 1839 : }

	pop	ebp
	ret	0
?lHasWrittenArtifact@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP ; CvLuaPlot::lHasWrittenArtifact
_TEXT	ENDS
PUBLIC	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
EXTRN	?GetCityPurchaseID@CvPlot@@QAEHXZ:PROC		; CvPlot::GetCityPurchaseID
; Function compile flags: /Odtp
;	COMDAT ?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lGetCityPurchaseID, COMDAT

; 1844 : {

	push	ebp
	mov	ebp, esp

; 1845 : 	return BasicLuaMethod(L, &CvPlot::GetCityPurchaseID);

	push	OFFSET ?GetCityPurchaseID@CvPlot@@QAEHXZ ; CvPlot::GetCityPurchaseID
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1846 : }

	pop	ebp
	ret	0
?lGetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lGetCityPurchaseID
_TEXT	ENDS
EXTRN	?SetCityPurchaseID@CvPlot@@QAEXH@Z:PROC		; CvPlot::SetCityPurchaseID
; Function compile flags: /Odtp
;	COMDAT ?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z PROC	; CvLuaPlot::lSetCityPurchaseID, COMDAT

; 1851 : {

	push	ebp
	mov	ebp, esp

; 1852 : 	return BasicLuaMethod(L, &CvPlot::SetCityPurchaseID);

	push	OFFSET ?SetCityPurchaseID@CvPlot@@QAEXH@Z ; CvPlot::SetCityPurchaseID
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
	add	esp, 8

; 1853 : }

	pop	ebp
	ret	0
?lSetCityPurchaseID@CvLuaPlot@@KAHPAUlua_State@@@Z ENDP	; CvLuaPlot::lSetCityPurchaseID
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??_C@_07NHABFFHN@__index?$AA@			; `string'
PUBLIC	??_C@_0L@GCADIOHF@__instance?$AA@		; `string'
PUBLIC	??_C@_01MHEDDDHA@v?$AA@				; `string'
PUBLIC	??_C@_06BPGFKLEK@__mode?$AA@			; `string'
PUBLIC	??_C@_0M@CEBPKMAI@__instances?$AA@		; `string'
EXTRN	_lua_pushnil:PROC
EXTRN	_lua_remove:PROC
EXTRN	_lua_pushlightuserdata:PROC
EXTRN	_lua_rawget:PROC
EXTRN	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z:PROC ; CvLuaArea::PushMethods
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_setmetatable:PROC
EXTRN	_lua_rawset:PROC
EXTRN	_lua_createtable:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
EXTRN	?GetTypeName@CvLuaArea@@SAPBDXZ:PROC		; CvLuaArea::GetTypeName
;	COMDAT ??_C@_07NHABFFHN@__index?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
CONST	SEGMENT
??_C@_07NHABFFHN@__index?$AA@ DB '__index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GCADIOHF@__instance?$AA@
CONST	SEGMENT
??_C@_0L@GCADIOHF@__instance?$AA@ DB '__instance', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01MHEDDDHA@v?$AA@
CONST	SEGMENT
??_C@_01MHEDDDHA@v?$AA@ DB 'v', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPGFKLEK@__mode?$AA@
CONST	SEGMENT
??_C@_06BPGFKLEK@__mode?$AA@ DB '__mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CEBPKMAI@__instances?$AA@
CONST	SEGMENT
??_C@_0M@CEBPKMAI@__instances?$AA@ DB '__instances', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z
_TEXT	SEGMENT
_instances_index$222470 = -8				; size = 4
_type_index$222469 = -4					; size = 4
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z PROC ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	cmp	DWORD PTR _pkType$[ebp], 0
	je	$LN4@Push

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN3@Push

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 59   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 63   : 			lua_newtable(L);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET ??_C@_06BPGFKLEK@__mode?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET ??_C@_01MHEDDDHA@v?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushvalue
	add	esp, 8

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_gettop
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z ; CvLuaArea::PushMethods
	add	esp, 8
$LN3@Push:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _type_index$222469[ebp], eax

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawget
	add	esp, 8

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _instances_index$222470[ebp], eax

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawget
	add	esp, 8

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN2@Push

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 97   : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET ??_C@_07NHABFFHN@__index?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 102  : 			lua_pushvalue(L, type_index);

	mov	ecx, DWORD PTR _type_index$222469[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	mov	edx, DWORD PTR _instances_index$222470[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8
$LN2@Push:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	mov	ecx, DWORD PTR _instances_index$222470[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_remove
	add	esp, 8

; 114  : 		lua_remove(L, type_index);

	mov	eax, DWORD PTR _type_index$222469[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_remove
	add	esp, 8

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else

	jmp	SHORT $LN5@Push
$LN4@Push:

; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN5@Push:

; 122  : 	}
; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ENDP ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
_TEXT	ENDS
PUBLIC	??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@ ; `string'
EXTRN	?HandleMissingInstance@CvLuaArea@@SAXPAUlua_State@@@Z:PROC ; CvLuaArea::HandleMissingInstance
EXTRN	_luaL_error:PROC
EXTRN	_lua_touserdata:PROC
;	COMDAT ??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@
CONST	SEGMENT
??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@ DB 'Not a val'
	DB	'id instance.  Either the instance is NULL or you used ''.'' i'
	DB	'nstead of '':''.', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_stack_size$ = -12					; size = 4
_pkInstance$ = -8					; size = 4
_bFail$ = -1						; size = 1
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaArea,CvArea>::GetInstance, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 128  : 	const int stack_size = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _stack_size$[ebp], eax

; 129  : 	bool bFail = true;

	mov	BYTE PTR _bFail$[ebp], 1

; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;

	mov	DWORD PTR _pkInstance$[ebp], 0

; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN5@GetInstanc

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 2
	jne	SHORT $LN5@GetInstanc

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$[ebp], eax

; 138  : 			if(pkInstance)

	cmp	DWORD PTR _pkInstance$[ebp], 0
	je	SHORT $LN5@GetInstanc

; 139  : 			{
; 140  : 				bFail = false;

	mov	BYTE PTR _bFail$[ebp], 0
$LN5@GetInstanc:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	mov	ecx, DWORD PTR _stack_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	movzx	eax, BYTE PTR _bFail$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetInstanc
	movzx	ecx, BYTE PTR _bErrorOnFail$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetInstanc

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[ebp], 1
	jne	SHORT $LN1@GetInstanc

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET ??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc:

; 151  : 		Derived::HandleMissingInstance(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?HandleMissingInstance@CvLuaArea@@SAXPAUlua_State@@@Z ; CvLuaArea::HandleMissingInstance
	add	esp, 4
$LN2@GetInstanc:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, DWORD PTR _pkInstance$[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAPAVCvArea@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaArea,CvArea>::GetInstance
_TEXT	ENDS
EXTRN	?PushMethods@CvLuaCity@@SAXPAUlua_State@@H@Z:PROC ; CvLuaCity::PushMethods
EXTRN	?GetTypeName@CvLuaCity@@SAPBDXZ:PROC		; CvLuaCity::GetTypeName
; Function compile flags: /Odtp
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z
_TEXT	SEGMENT
_instances_index$222505 = -8				; size = 4
_type_index$222504 = -4					; size = 4
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z PROC ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	cmp	DWORD PTR _pkType$[ebp], 0
	je	$LN4@Push@2

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaCity@@SAPBDXZ		; CvLuaCity::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN3@Push@2

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 59   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 63   : 			lua_newtable(L);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET ??_C@_06BPGFKLEK@__mode?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET ??_C@_01MHEDDDHA@v?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushvalue
	add	esp, 8

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaCity@@SAPBDXZ		; CvLuaCity::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_gettop
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?PushMethods@CvLuaCity@@SAXPAUlua_State@@H@Z ; CvLuaCity::PushMethods
	add	esp, 8
$LN3@Push@2:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _type_index$222504[ebp], eax

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawget
	add	esp, 8

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _instances_index$222505[ebp], eax

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawget
	add	esp, 8

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN2@Push@2

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 97   : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET ??_C@_07NHABFFHN@__index?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 102  : 			lua_pushvalue(L, type_index);

	mov	ecx, DWORD PTR _type_index$222504[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	mov	edx, DWORD PTR _instances_index$222505[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8
$LN2@Push@2:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	mov	ecx, DWORD PTR _instances_index$222505[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_remove
	add	esp, 8

; 114  : 		lua_remove(L, type_index);

	mov	eax, DWORD PTR _type_index$222504[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_remove
	add	esp, 8

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else

	jmp	SHORT $LN5@Push@2
$LN4@Push@2:

; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN5@Push@2:

; 122  : 	}
; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaCity@@VCvCity@@@@SAXPAUlua_State@@PAVCvCity@@@Z ENDP ; CvLuaScopedInstance<CvLuaCity,CvCity>::Push
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
_TEXT	ENDS
;	COMDAT ?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod, COMDAT

; 222  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 223  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 224  : 	(pkType->*func)();

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 225  : 	return 0;

	xor	eax, eax

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BasicLuaMethod@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
_TEXT	ENDS
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_instances_index$222528 = -8				; size = 4
_type_index$222527 = -4					; size = 4
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	cmp	DWORD PTR _pkType$[ebp], 0
	je	$LN4@Push@3

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaPlot@@SAPBDXZ		; CvLuaPlot::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN3@Push@3

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 59   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 63   : 			lua_newtable(L);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET ??_C@_06BPGFKLEK@__mode?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET ??_C@_01MHEDDDHA@v?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushvalue
	add	esp, 8

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaPlot@@SAPBDXZ		; CvLuaPlot::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_gettop
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z ; CvLuaPlot::PushMethods
	add	esp, 8
$LN3@Push@3:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _type_index$222527[ebp], eax

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawget
	add	esp, 8

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _instances_index$222528[ebp], eax

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawget
	add	esp, 8

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN2@Push@3

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 97   : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET ??_C@_07NHABFFHN@__index?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 102  : 			lua_pushvalue(L, type_index);

	mov	ecx, DWORD PTR _type_index$222527[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	mov	edx, DWORD PTR _instances_index$222528[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8
$LN2@Push@3:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	mov	ecx, DWORD PTR _instances_index$222528[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_remove
	add	esp, 8

; 114  : 		lua_remove(L, type_index);

	mov	eax, DWORD PTR _type_index$222527[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_remove
	add	esp, 8

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else

	jmp	SHORT $LN5@Push@3
$LN4@Push@3:

; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN5@Push@3:

; 122  : 	}
; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_stack_size$ = -12					; size = 4
_pkInstance$ = -8					; size = 4
_bFail$ = -1						; size = 1
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 128  : 	const int stack_size = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _stack_size$[ebp], eax

; 129  : 	bool bFail = true;

	mov	BYTE PTR _bFail$[ebp], 1

; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;

	mov	DWORD PTR _pkInstance$[ebp], 0

; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN5@GetInstanc@2

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 2
	jne	SHORT $LN5@GetInstanc@2

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$[ebp], eax

; 138  : 			if(pkInstance)

	cmp	DWORD PTR _pkInstance$[ebp], 0
	je	SHORT $LN5@GetInstanc@2

; 139  : 			{
; 140  : 				bFail = false;

	mov	BYTE PTR _bFail$[ebp], 0
$LN5@GetInstanc@2:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	mov	ecx, DWORD PTR _stack_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	movzx	eax, BYTE PTR _bFail$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetInstanc@2
	movzx	ecx, BYTE PTR _bErrorOnFail$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetInstanc@2

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[ebp], 1
	jne	SHORT $LN1@GetInstanc@2

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET ??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc@2:

; 151  : 		Derived::HandleMissingInstance(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ; CvLuaPlot::HandleMissingInstance
	add	esp, 4
$LN2@GetInstanc@2:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, DWORD PTR _pkInstance$[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GHLHFGFM@Instance?5does?5not?5exist?4?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@GHLHFGFM@Instance?5does?5not?5exist?4?$AA@
CONST	SEGMENT
??_C@_0BJ@GHLHFGFM@Instance?5does?5not?5exist?4?$AA@ DB 'Instance does no'
	DB	't exist.', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::DefaultHandleMissingInstance, COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp

; 165  : 	luaL_error(L, "Instance does not exist.");

	push	OFFSET ??_C@_0BJ@GHLHFGFM@Instance?5does?5not?5exist?4?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_error
	add	esp, 8

; 166  : }

	pop	ebp
	ret	0
?DefaultHandleMissingInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@KAXPAUlua_State@@@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::DefaultHandleMissingInstance
_TEXT	ENDS
EXTRN	?PushMethods@CvLuaUnit@@SAXPAUlua_State@@H@Z:PROC ; CvLuaUnit::PushMethods
EXTRN	?GetTypeName@CvLuaUnit@@SAPBDXZ:PROC		; CvLuaUnit::GetTypeName
; Function compile flags: /Odtp
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_instances_index$222568 = -8				; size = 4
_type_index$222567 = -4					; size = 4
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z PROC ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push, COMDAT

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	cmp	DWORD PTR _pkType$[ebp], 0
	je	$LN4@Push@4

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaUnit@@SAPBDXZ		; CvLuaUnit::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN3@Push@4

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 59   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 63   : 			lua_newtable(L);

	push	0
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET ??_C@_06BPGFKLEK@__mode?$AA@
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushstring
	add	esp, 8

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET ??_C@_01MHEDDDHA@v?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_rawset
	add	esp, 8

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushvalue
	add	esp, 8

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaUnit@@SAPBDXZ		; CvLuaUnit::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_gettop
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?PushMethods@CvLuaUnit@@SAXPAUlua_State@@H@Z ; CvLuaUnit::PushMethods
	add	esp, 8
$LN3@Push@4:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _type_index$222567[ebp], eax

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET ??_C@_0M@CEBPKMAI@__instances?$AA@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushstring
	add	esp, 8

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawget
	add	esp, 8

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _instances_index$222568[ebp], eax

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_rawget
	add	esp, 8

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	$LN2@Push@4

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 97   : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setfield
	add	esp, 12					; 0000000cH

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET ??_C@_07NHABFFHN@__index?$AA@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushstring
	add	esp, 8

; 102  : 			lua_pushvalue(L, type_index);

	mov	ecx, DWORD PTR _type_index$222567[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushvalue
	add	esp, 8

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_setmetatable
	add	esp, 8

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	mov	edx, DWORD PTR _pkType$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushlightuserdata
	add	esp, 8

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushvalue
	add	esp, 8

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	mov	edx, DWORD PTR _instances_index$222568[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_rawset
	add	esp, 8
$LN2@Push@4:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	mov	ecx, DWORD PTR _instances_index$222568[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_remove
	add	esp, 8

; 114  : 		lua_remove(L, type_index);

	mov	eax, DWORD PTR _type_index$222567[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_remove
	add	esp, 8

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else

	jmp	SHORT $LN5@Push@4
$LN4@Push@4:

; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN5@Push@4:

; 122  : 	}
; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAXPAUlua_State@@PAVCvUnit@@@Z ENDP ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::Push
_TEXT	ENDS
EXTRN	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z:PROC ; CvLuaUnit::HandleMissingInstance
; Function compile flags: /Odtp
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_stack_size$ = -12					; size = 4
_pkInstance$ = -8					; size = 4
_bFail$ = -1						; size = 1
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 128  : 	const int stack_size = lua_gettop(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _stack_size$[ebp], eax

; 129  : 	bool bFail = true;

	mov	BYTE PTR _bFail$[ebp], 1

; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;

	mov	DWORD PTR _pkInstance$[ebp], 0

; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	SHORT $LN5@GetInstanc@3

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	push	OFFSET ??_C@_0L@GCADIOHF@__instance?$AA@
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 2
	jne	SHORT $LN5@GetInstanc@3

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkInstance$[ebp], eax

; 138  : 			if(pkInstance)

	cmp	DWORD PTR _pkInstance$[ebp], 0
	je	SHORT $LN5@GetInstanc@3

; 139  : 			{
; 140  : 				bFail = false;

	mov	BYTE PTR _bFail$[ebp], 0
$LN5@GetInstanc@3:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	mov	ecx, DWORD PTR _stack_size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	movzx	eax, BYTE PTR _bFail$[ebp]
	test	eax, eax
	je	SHORT $LN2@GetInstanc@3
	movzx	ecx, BYTE PTR _bErrorOnFail$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetInstanc@3

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[ebp], 1
	jne	SHORT $LN1@GetInstanc@3

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET ??_C@_0FD@PKCLFCLD@Not?5a?5valid?5instance?4?5?5Either?5th@
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc@3:

; 151  : 		Derived::HandleMissingInstance(L);

	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?HandleMissingInstance@CvLuaUnit@@SAXPAUlua_State@@@Z ; CvLuaUnit::HandleMissingInstance
	add	esp, 4
$LN2@GetInstanc@3:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, DWORD PTR _pkInstance$[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaUnit@@VCvUnit@@@@SAPAVCvUnit@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaUnit,CvUnit>::GetInstance
_TEXT	ENDS
PUBLIC	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
;	COMDAT ??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>, COMDAT

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 231  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 232  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 233  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 234  : 	return 0;

	xor	eax, eax

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluaargtemplates.h
_TEXT	ENDS
;	COMDAT ??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z PROC	; CvLuaArgs::toValue<bool>, COMDAT

; 23   : 	{

	push	ebp
	mov	ebp, esp

; 24   : 		return lua_toboolean(L, idx) != 0;

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	neg	eax
	sbb	eax, eax
	neg	eax

; 25   : 	}

	pop	ebp
	ret	0
??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ENDP	; CvLuaArgs::toValue<bool>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@W4TeamTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4TeamTypes@@@Z ; CvLuaArgs::pushValue<enum TeamTypes>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4TeamTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 240  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 241  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 242  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@PAVCvUnit@@@CvLuaArgs@@YAPAVCvUnit@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<CvUnit *>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 243  : 	return 0;

	xor	eax, eax

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HPAVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXHPAVCvUnit@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit *>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluaargtemplates.h
_TEXT	ENDS
;	COMDAT ??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z PROC	; CvLuaArgs::toValue<int>, COMDAT

; 18   : 	{

	push	ebp
	mov	ebp, esp

; 19   : 		return lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 20   : 	}

	pop	ebp
	ret	0
??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ENDP	; CvLuaArgs::toValue<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluaargtemplates.h
_TEXT	ENDS
;	COMDAT ??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 1
??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z PROC	; CvLuaArgs::pushValue<bool>, COMDAT

; 44   : 	{

	push	ebp
	mov	ebp, esp

; 45   : 		lua_pushboolean(L, t);

	movzx	eax, BYTE PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushboolean
	add	esp, 8

; 46   : 	}

	pop	ebp
	ret	0
??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ENDP	; CvLuaArgs::pushValue<bool>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4DirectionTypes@@@CvLuaArgs@@YA?AW4DirectionTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum DirectionTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4DirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4DirectionTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum DirectionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluaargtemplates.h
_TEXT	ENDS
;	COMDAT ??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z PROC	; CvLuaArgs::pushValue<int>, COMDAT

; 38   : 	{

	push	ebp
	mov	ebp, esp

; 39   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 40   : 	}

	pop	ebp
	ret	0
??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ENDP	; CvLuaArgs::pushValue<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluamethodwrapper.h
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEH_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum ResourceTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4ResourceTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ResourceTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ResourceTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 99   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum ImprovementTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 102  : 
; 103  : 	return 1;

	mov	eax, 1

; 104  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4ImprovementTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4ImprovementTypes@@W4TeamTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum ImprovementTypes,enum TeamTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 109  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 110  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 111  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum BuildTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 112  : 
; 113  : 	return 1;

	mov	eax, 1

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4BuildTypes@@W4PlayerTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4BuildTypes@@W4PlayerTypes@@_N3@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,enum PlayerTypes,bool,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum BuildTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 109  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 110  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 111  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _idx$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum BuildTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 112  : 
; 113  : 	return 1;

	mov	eax, 1

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4BuildTypes@@W4PlayerTypes@@HH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4PlayerTypes@@HH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum PlayerTypes,int,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 99   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 102  : 
; 103  : 	return 1;

	mov	eax, 1

; 104  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4TeamTypes@@_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@_N2@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,bool,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 99   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@PBVCvPlot@@@CvLuaArgs@@YAPBVCvPlot@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<CvPlot const *>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _idx$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<CvUnit const *>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 102  : 
; 103  : 	return 1;

	mov	eax, 1

; 104  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HPBVCvUnit@@PBVCvPlot@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@PBV2@H@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *,CvPlot const *,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>, COMDAT

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 231  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 232  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 233  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 234  : 	return 0;

	xor	eax, eax

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4PlayerTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>, COMDAT

; 121  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 122  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 123  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 124  : 
; 125  : 	return 1;

	mov	eax, 1

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<CvUnit const *>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HPBVCvUnit@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHPBVCvUnit@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,CvUnit const *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NHH@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NHH@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,int,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum ImprovementTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum ImprovementTypes,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 240  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 241  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 242  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4FlowDirectionTypes@@@CvLuaArgs@@YA?AW4FlowDirectionTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum FlowDirectionTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	edx, al
	push	edx
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 243  : 	return 0;

	xor	eax, eax

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEX_NW4FlowDirectionTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum FlowDirectionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@W4FlowDirectionTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4FlowDirectionTypes@@@Z ; CvLuaArgs::pushValue<enum FlowDirectionTypes>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4FlowDirectionTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4FlowDirectionTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum FlowDirectionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@PAVCvArea@@@CvLuaArgs@@YAPAVCvArea@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<CvArea *>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NPAVCvArea@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NPAVCvArea@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,CvArea *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@W4PlayerTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlayerTypes@@@Z ; CvLuaArgs::pushValue<enum PlayerTypes>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlayerTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>, COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 260  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 261  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 262  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 263  : 	return 0;

	xor	eax, eax

; 264  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4PlayerTypes@@H_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlayerTypes@@H_N2@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlayerTypes,int,bool,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@W4PlotTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlotTypes@@@Z ; CvLuaArgs::pushValue<enum PlotTypes>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4PlotTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4PlotTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>, COMDAT

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 260  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 261  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 262  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlotTypes@@@CvLuaArgs@@YA?AW4PlotTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlotTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 263  : 	return 0;

	xor	eax, eax

; 264  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4PlotTypes@@_N_N_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4PlotTypes@@_N22@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum PlotTypes,bool,bool,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@W4ResourceTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ResourceTypes@@@Z ; CvLuaArgs::pushValue<enum ResourceTypes>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4ResourceTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ResourceTypes@@W4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,enum TeamTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>, COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 250  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 251  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 252  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum ResourceTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 253  : 	return 0;

	xor	eax, eax

; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4ResourceTypes@@H_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ResourceTypes@@H_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ResourceTypes,int,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@W4ImprovementTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ImprovementTypes@@@Z ; CvLuaArgs::pushValue<enum ImprovementTypes>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4ImprovementTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4ImprovementTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 240  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 241  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 242  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum ImprovementTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 243  : 	return 0;

	xor	eax, eax

; 244  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4ImprovementTypes@@W4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4ImprovementTypes@@W4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum ImprovementTypes,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 70   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 71   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@W4RouteTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4RouteTypes@@@Z ; CvLuaArgs::pushValue<enum RouteTypes>
	add	esp, 8

; 72   : 
; 73   : 	return 1;

	mov	eax, 1

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE?AW4RouteTypes@@XZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>, COMDAT

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 231  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 232  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 233  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4RouteTypes@@@CvLuaArgs@@YA?AW4RouteTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum RouteTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 234  : 	return 0;

	xor	eax, eax

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4RouteTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4RouteTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum RouteTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>, COMDAT

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 99   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 100  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 101  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum YieldTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 102  : 
; 103  : 	return 1;

	mov	eax, 1

; 104  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum YieldTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4YieldTypes@@W4TeamTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4YieldTypes@@W4TeamTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,enum TeamTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>, COMDAT

; 140  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 141  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 142  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 143  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum YieldTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 144  : 
; 145  : 	return 1;

	mov	eax, 1

; 146  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4YieldTypes@@_N@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4YieldTypes@@_N@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum YieldTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>, COMDAT

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 109  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 110  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 111  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2), CvLuaArgs::toValue<arg4>(L, idx + 3)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@_N@CvLuaArgs@@YA_NPAUlua_State@@H@Z ; CvLuaArgs::toValue<bool>
	add	esp, 8
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum YieldTypes>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _idx$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum BuildTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 112  : 
; 113  : 	return 1;

	mov	eax, 1

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes,enum YieldTypes,bool,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>, COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 131  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 132  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 133  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 134  : 
; 135  : 	return 1;

	mov	eax, 1

; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>, COMDAT

; 130  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 131  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 132  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 133  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 134  : 
; 135  : 	return 1;

	mov	eax, 1

; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>, COMDAT

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 79   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 80   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 81   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx)));

	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum BuildTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 82   : 
; 83   : 	return 1;

	mov	eax, 1

; 84   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4BuildTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4BuildTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum BuildTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 151  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 152  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 153  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum PlayerTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _idx$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum BuildTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 154  : 
; 155  : 	return 1;

	mov	eax, 1

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4BuildTypes@@HW4PlayerTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AE_NW4BuildTypes@@HW4PlayerTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum BuildTypes,int,enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum InvisibleTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@HW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BEHW4TeamTypes@@W4InvisibleTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int,enum TeamTypes,enum InvisibleTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>, COMDAT

; 88   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 89   : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 90   : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 91   : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1)));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum InvisibleTypes>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$pushValue@_N@CvLuaArgs@@YAXPAUlua_State@@_N@Z ; CvLuaArgs::pushValue<bool>
	add	esp, 8

; 92   : 
; 93   : 	return 1;

	mov	eax, 1

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@_NW4TeamTypes@@W4InvisibleTypes@@@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@BE_NW4TeamTypes@@W4InvisibleTypes@@@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<bool,enum TeamTypes,enum InvisibleTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z
_TEXT	SEGMENT
_idx$ = -8						; size = 4
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>, COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 250  : 	const int idx = Derived::GetStartingArgIndex();

	call	?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
	mov	DWORD PTR _idx$[ebp], eax

; 251  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 252  : 	(pkType->*func)(CvLuaArgs::toValue<arg1>(L, idx), CvLuaArgs::toValue<arg2>(L, idx + 1), CvLuaArgs::toValue<arg3>(L, idx + 2));

	mov	ecx, DWORD PTR _idx$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	??$toValue@H@CvLuaArgs@@YAHPAUlua_State@@H@Z ; CvLuaArgs::toValue<int>
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _idx$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum InvisibleTypes>
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _idx$[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ; CvLuaArgs::toValue<enum TeamTypes>
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]

; 253  : 	return 0;

	xor	eax, eax

; 254  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@W4TeamTypes@@W4InvisibleTypes@@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEXW4TeamTypes@@W4InvisibleTypes@@H@Z@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<enum TeamTypes,enum InvisibleTypes,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z
_TEXT	SEGMENT
_pkType$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z PROC ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>, COMDAT

; 121  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 122  : 	InstanceType* pkType = Derived::GetInstance(L);

	push	1
	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pkType$[ebp], eax

; 123  : 	CvLuaArgs::pushValue<ret>(L, (pkType->*func)());

	mov	ecx, DWORD PTR _pkType$[ebp]
	call	DWORD PTR _func$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	??$pushValue@H@CvLuaArgs@@YAXPAUlua_State@@H@Z ; CvLuaArgs::pushValue<int>
	add	esp, 8

; 124  : 
; 125  : 	return 1;

	mov	eax, 1

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$BasicLuaMethod@H@?$CvLuaMethodWrapper@VCvLuaPlot@@VCvPlot@@@@KAHPAUlua_State@@P8CvPlot@@AEHXZ@Z ENDP ; CvLuaMethodWrapper<CvLuaPlot,CvPlot>::BasicLuaMethod<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
_TEXT	ENDS
;	COMDAT ?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ
_TEXT	SEGMENT
?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex, COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp

; 159  : 	return 2;

	mov	eax, 2

; 160  : }

	pop	ebp
	ret	0
?GetStartingArgIndex@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SA?BHXZ ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetStartingArgIndex
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvluaargtemplates.h
_TEXT	ENDS
;	COMDAT ??$pushValue@W4TeamTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4TeamTypes@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@W4TeamTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4TeamTypes@@@Z PROC ; CvLuaArgs::pushValue<enum TeamTypes>, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	pop	ebp
	ret	0
??$pushValue@W4TeamTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4TeamTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum TeamTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@PAVCvUnit@@@CvLuaArgs@@YAPAVCvUnit@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@PAVCvUnit@@@CvLuaArgs@@YAPAVCvUnit@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvUnit *>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@PAVCvUnit@@@CvLuaArgs@@YAPAVCvUnit@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvUnit *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum TeamTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4TeamTypes@@@CvLuaArgs@@YA?AW4TeamTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum TeamTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum PlayerTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4PlayerTypes@@@CvLuaArgs@@YA?AW4PlayerTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4DirectionTypes@@@CvLuaArgs@@YA?AW4DirectionTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4DirectionTypes@@@CvLuaArgs@@YA?AW4DirectionTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum DirectionTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4DirectionTypes@@@CvLuaArgs@@YA?AW4DirectionTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum DirectionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum ResourceTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4ResourceTypes@@@CvLuaArgs@@YA?AW4ResourceTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum ResourceTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum ImprovementTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4ImprovementTypes@@@CvLuaArgs@@YA?AW4ImprovementTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum ImprovementTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum BuildTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4BuildTypes@@@CvLuaArgs@@YA?AW4BuildTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum BuildTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvUnit const *>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@PBVCvUnit@@@CvLuaArgs@@YAPBVCvUnit@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvUnit const *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@PBVCvPlot@@@CvLuaArgs@@YAPBVCvPlot@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@PBVCvPlot@@@CvLuaArgs@@YAPBVCvPlot@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvPlot const *>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@PBVCvPlot@@@CvLuaArgs@@YAPBVCvPlot@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvPlot const *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4FlowDirectionTypes@@@CvLuaArgs@@YA?AW4FlowDirectionTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4FlowDirectionTypes@@@CvLuaArgs@@YA?AW4FlowDirectionTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum FlowDirectionTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4FlowDirectionTypes@@@CvLuaArgs@@YA?AW4FlowDirectionTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum FlowDirectionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$pushValue@W4FlowDirectionTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4FlowDirectionTypes@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@W4FlowDirectionTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4FlowDirectionTypes@@@Z PROC ; CvLuaArgs::pushValue<enum FlowDirectionTypes>, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	pop	ebp
	ret	0
??$pushValue@W4FlowDirectionTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4FlowDirectionTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum FlowDirectionTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@PAVCvArea@@@CvLuaArgs@@YAPAVCvArea@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@PAVCvArea@@@CvLuaArgs@@YAPAVCvArea@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<CvArea *>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@PAVCvArea@@@CvLuaArgs@@YAPAVCvArea@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<CvArea *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$pushValue@W4PlayerTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@W4PlayerTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlayerTypes@@@Z PROC ; CvLuaArgs::pushValue<enum PlayerTypes>, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	pop	ebp
	ret	0
??$pushValue@W4PlayerTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlayerTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum PlayerTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$pushValue@W4PlotTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlotTypes@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@W4PlotTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlotTypes@@@Z PROC ; CvLuaArgs::pushValue<enum PlotTypes>, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	pop	ebp
	ret	0
??$pushValue@W4PlotTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4PlotTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum PlotTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4PlotTypes@@@CvLuaArgs@@YA?AW4PlotTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4PlotTypes@@@CvLuaArgs@@YA?AW4PlotTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum PlotTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4PlotTypes@@@CvLuaArgs@@YA?AW4PlotTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum PlotTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$pushValue@W4ResourceTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ResourceTypes@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@W4ResourceTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ResourceTypes@@@Z PROC ; CvLuaArgs::pushValue<enum ResourceTypes>, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	pop	ebp
	ret	0
??$pushValue@W4ResourceTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ResourceTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum ResourceTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$pushValue@W4ImprovementTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@W4ImprovementTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ImprovementTypes@@@Z PROC ; CvLuaArgs::pushValue<enum ImprovementTypes>, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	pop	ebp
	ret	0
??$pushValue@W4ImprovementTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4ImprovementTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum ImprovementTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$pushValue@W4RouteTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4RouteTypes@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_t$ = 12						; size = 4
??$pushValue@W4RouteTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4RouteTypes@@@Z PROC ; CvLuaArgs::pushValue<enum RouteTypes>, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		//This is pretty unsafe, but common.
; 32   : 		//Assume T is a poorly designed enum =(
; 33   : 		lua_pushinteger(L, t);

	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushinteger
	add	esp, 8

; 34   : 	}

	pop	ebp
	ret	0
??$pushValue@W4RouteTypes@@@CvLuaArgs@@YAXPAUlua_State@@W4RouteTypes@@@Z ENDP ; CvLuaArgs::pushValue<enum RouteTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4RouteTypes@@@CvLuaArgs@@YA?AW4RouteTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4RouteTypes@@@CvLuaArgs@@YA?AW4RouteTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum RouteTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4RouteTypes@@@CvLuaArgs@@YA?AW4RouteTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum RouteTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum YieldTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4YieldTypes@@@CvLuaArgs@@YA?AW4YieldTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum YieldTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z PROC ; CvLuaArgs::toValue<enum InvisibleTypes>, COMDAT

; 11   : 	{

	push	ebp
	mov	ebp, esp

; 12   : 		//This is pretty unsafe, but common.
; 13   : 		//Assume T is a poorly designed enum =(
; 14   : 		return (T)lua_tointeger(L, idx);

	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8

; 15   : 	}

	pop	ebp
	ret	0
??$toValue@W4InvisibleTypes@@@CvLuaArgs@@YA?AW4InvisibleTypes@@PAUlua_State@@H@Z ENDP ; CvLuaArgs::toValue<enum InvisibleTypes>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
_TEXT	ENDS
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_playerID$ = -4						; size = 4
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 231  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 		PlayerTypes playerID = getOwner();

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$[ebp], ecx

; 233  : 		if(playerID != NO_PLAYER)

	cmp	DWORD PTR _playerID$[ebp], -1
	je	SHORT $LN2@getTeam

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	mov	edx, DWORD PTR _playerID$[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	jmp	SHORT $LN3@getTeam

; 236  : 		}
; 237  : 		else

	jmp	SHORT $LN3@getTeam
$LN2@getTeam:

; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1
$LN3@getTeam:

; 240  : 		}
; 241  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T224610 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224610[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T224610[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 306  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 		return m_iX;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax]

; 308  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 311  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 		return m_iY;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [eax+2]

; 313  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 323  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+356]

; 325  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 386  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+4]

; 388  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ PROC		; CvPlot::getPlotType, COMDAT
; _this$ = ecx

; 404  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 405  : 		return (PlotTypes)m_ePlotType;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+5]

; 406  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotType@CvPlot@@QBE?AW4PlotTypes@@XZ ENDP		; CvPlot::getPlotType
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isHills@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isHills@CvPlot@@QBE_NXZ PROC				; CvPlot::isHills, COMDAT
; _this$ = ecx

; 412  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 		return (PlotTypes)m_ePlotType == PLOT_HILLS;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 414  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?isHills@CvPlot@@QBE_NXZ ENDP				; CvPlot::isHills
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isOpenGround@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isOpenGround@CvPlot@@QBE_NXZ PROC			; CvPlot::isOpenGround, COMDAT
; _this$ = ecx

; 416  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 417  : 		if((PlotTypes)m_ePlotType == PLOT_HILLS || (PlotTypes)m_ePlotType == PLOT_MOUNTAIN || m_bRoughFeature) return false;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	cmp	ecx, 1
	je	SHORT $LN1@isOpenGrou
	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	test	eax, eax
	je	SHORT $LN1@isOpenGrou
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 3
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@isOpenGrou
$LN1@isOpenGrou:
	xor	al, al
	jmp	SHORT $LN3@isOpenGrou
$LN2@isOpenGrou:

; 418  : 		return true;

	mov	al, 1
$LN3@isOpenGrou:

; 419  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isOpenGround@CvPlot@@QBE_NXZ ENDP			; CvPlot::isOpenGround
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 421  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	mov	eax, DWORD PTR _this$[ebp]
	movsx	eax, BYTE PTR [eax+5]
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 423  : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 443  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 444  : 		return m_bIsImpassable;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	shr	al, 7
	and	al, 1

; 445  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isRoughGround@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isRoughGround@CvPlot@@QBE_NXZ PROC			; CvPlot::isRoughGround, COMDAT
; _this$ = ecx

; 452  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		if(isHills())

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN7@isRoughGro

; 454  : 		{
; 455  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isRoughGro

; 456  : 		}
; 457  : 		if(isMountain())

$LN7@isRoughGro:
	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@isRoughGro

; 458  : 		{
; 459  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isRoughGro
$LN1@isRoughGro:

; 460  : 		}
; 461  : 
; 462  : 		return m_bRoughFeature;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+462]
	shr	al, 3
	and	al, 1
$LN3@isRoughGro:

; 463  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isRoughGround@CvPlot@@QBE_NXZ ENDP			; CvPlot::isRoughGround
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T224642 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224642[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T224642[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 587  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _eTeam$[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]

; 592  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiOffset$224654 = -8					; size = 4
$T224650 = -4						; size = 4
_eTeam$ = 8						; size = 4
_bDebug$ = 12						; size = 1
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 611  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		if(bDebug && GC.getGame().isDebugMode())

	movzx	eax, BYTE PTR _bDebug$[ebp]
	test	eax, eax
	je	SHORT $LN1@isRevealed
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224650[ebp], ecx
	mov	ecx, DWORD PTR $T224650[ebp]
	call	?isDebugMode@CvGame@@QBE_NXZ		; CvGame::isDebugMode
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@isRevealed

; 613  : 			return true;

	mov	al, 1
	jmp	SHORT $LN2@isRevealed
$LN1@isRevealed:

; 614  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 615  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 616  : 		return m_bfRevealed.GetBit(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$224654[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$224654[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _eTeam$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$224654[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
$LN2@isRevealed:

; 617  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@_N@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
END
