; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvBuilderTaskingAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>
PUBLIC	?Uninit@CvBuilderTaskingAI@@QAEXXZ		; CvBuilderTaskingAI::Uninit
PUBLIC	??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::FStaticVector<int,14592,1,297,0>
PUBLIC	??0CvBuilderTaskingAI@@QAE@XZ			; CvBuilderTaskingAI::CvBuilderTaskingAI
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvBuilderTaskingAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvBuilderTaskingAI@@QAE@XZ$0
__ehfuncinfo$??0CvBuilderTaskingAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvBuilderTaskingAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ??0CvBuilderTaskingAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
__$EHRec$ = -12						; size = 12
??0CvBuilderTaskingAI@@QAE@XZ PROC			; CvBuilderTaskingAI::CvBuilderTaskingAI, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvBuilderTaskingAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::FStaticVector<int,14592,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 32   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvBuilderTaskingAI@@QAEXXZ	; CvBuilderTaskingAI::Uninit

; 33   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvBuilderTaskingAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>
__ehhandler$??0CvBuilderTaskingAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvBuilderTaskingAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvBuilderTaskingAI@@QAE@XZ ENDP			; CvBuilderTaskingAI::CvBuilderTaskingAI
PUBLIC	??1CvBuilderTaskingAI@@QAE@XZ			; CvBuilderTaskingAI::~CvBuilderTaskingAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvBuilderTaskingAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBuilderTaskingAI@@QAE@XZ$0
__ehfuncinfo$??1CvBuilderTaskingAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvBuilderTaskingAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ??1CvBuilderTaskingAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBuilderTaskingAI@@QAE@XZ PROC			; CvBuilderTaskingAI::~CvBuilderTaskingAI, COMDAT
; _this$ = ecx

; 37   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBuilderTaskingAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 38   : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvBuilderTaskingAI@@QAEXXZ	; CvBuilderTaskingAI::Uninit

; 39   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBuilderTaskingAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>
__ehhandler$??1CvBuilderTaskingAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBuilderTaskingAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBuilderTaskingAI@@QAE@XZ ENDP			; CvBuilderTaskingAI::~CvBuilderTaskingAI
PUBLIC	?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetFalloutRemove
PUBLIC	?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ ; CvBuilderTaskingAI::GetFalloutFeature
PUBLIC	?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetRepairBuild
PUBLIC	?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z	; CvBuilderTaskingAI::Init
EXTRN	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::GetFeatureMakesValid
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvImprovementEntry::GetRequiredCivilization
EXTRN	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsSpecificCivRequired
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?GetBuilderAILogging@CvGlobals@@QAE_NXZ:PROC	; CvGlobals::GetBuilderAILogging
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv91 = -36						; size = 4
_this$ = -32						; size = 4
_i$220142 = -28						; size = 4
_eCiv$217164 = -24					; size = 4
_pkBuild$217156 = -20					; size = 4
_pkImprovementInfo$217161 = -16				; size = 4
_eImprovement$217158 = -12				; size = 4
_eBuild$217154 = -8					; size = 4
_i$217150 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z PROC	; CvBuilderTaskingAI::Init, COMDAT
; _this$ = ecx

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax], ecx

; 45   : 	m_eRepairBuild = GetRepairBuild();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetRepairBuild
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 46   : 	m_eFalloutFeature = GetFalloutFeature();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ ; CvBuilderTaskingAI::GetFalloutFeature
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+58452], eax

; 47   : 	m_eFalloutRemove = GetFalloutRemove();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ; CvBuilderTaskingAI::GetFalloutRemove
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+58456], eax

; 48   : 
; 49   : 	m_aiNonTerritoryPlots.clear();

	xor	eax, eax
	je	SHORT $LN22@Init
	mov	DWORD PTR _i$220142[ebp], 0
	jmp	SHORT $LN20@Init
$LN19@Init:
	mov	ecx, DWORD PTR _i$220142[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$220142[ebp], ecx
$LN20@Init:
	mov	edx, DWORD PTR _i$220142[ebp]
	cmp	edx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	jae	SHORT $LN22@Init
	jmp	SHORT $LN19@Init
$LN22@Init:
	mov	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, 0

; 50   : 	m_bLogging = GC.getLogging() && GC.getAILogging() && GC.GetBuilderAILogging();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@Init
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@Init
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@Init
	mov	DWORD PTR tv91[ebp], 1
	jmp	SHORT $LN15@Init
$LN14@Init:
	mov	DWORD PTR tv91[ebp], 0
$LN15@Init:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR tv91[ebp]
	mov	BYTE PTR [eax+58392], cl

; 51   : 	m_iNumCities = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+58396], -1

; 52   : 	m_pTargetPlot = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+58400], 0

; 53   : 
; 54   : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 55   : 	// special case code so the Dutch don't remove marshes
; 56   : 	m_bKeepMarshes = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+58460], 0

; 57   : 	// special case code so Brazil doesn't remove jungle
; 58   : 	m_bKeepJungle = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+58461], 0

; 59   : 
; 60   : #ifdef AUI_WARNING_FIXES
; 61   : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 62   : #else
; 63   : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	DWORD PTR _i$217150[ebp], 0
	jmp	SHORT $LN11@Init
$LN10@Init:
	mov	eax, DWORD PTR _i$217150[ebp]
	add	eax, 1
	mov	DWORD PTR _i$217150[ebp], eax
$LN11@Init:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _i$217150[ebp], eax
	jge	$LN12@Init

; 64   : #endif
; 65   : 	{
; 66   : 		BuildTypes eBuild = (BuildTypes)i;

	mov	ecx, DWORD PTR _i$217150[ebp]
	mov	DWORD PTR _eBuild$217154[ebp], ecx

; 67   : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$217154[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217156[ebp], eax

; 68   : 		if(!pkBuild)

	cmp	DWORD PTR _pkBuild$217156[ebp], 0
	jne	SHORT $LN8@Init

; 69   : 		{
; 70   : 			continue;

	jmp	SHORT $LN10@Init
$LN8@Init:

; 71   : 		}
; 72   : 		
; 73   : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();

	mov	ecx, DWORD PTR _pkBuild$217156[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$217158[ebp], eax

; 74   : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$217158[ebp], -1
	jne	SHORT $LN7@Init

; 75   : 		{
; 76   : 			continue;

	jmp	SHORT $LN10@Init
$LN7@Init:

; 77   : 		}
; 78   : 
; 79   : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$217158[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$217161[ebp], eax

; 80   : 		if(pkImprovementInfo == NULL)

	cmp	DWORD PTR _pkImprovementInfo$217161[ebp], 0
	jne	SHORT $LN6@Init

; 81   : 		{
; 82   : 			continue;

	jmp	SHORT $LN10@Init
$LN6@Init:

; 83   : 		}
; 84   : 
; 85   : 		if(pkImprovementInfo->IsSpecificCivRequired())

	mov	ecx, DWORD PTR _pkImprovementInfo$217161[ebp]
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Init

; 86   : 		{
; 87   : 			CivilizationTypes eCiv = pkImprovementInfo->GetRequiredCivilization();

	mov	ecx, DWORD PTR _pkImprovementInfo$217161[ebp]
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
	mov	DWORD PTR _eCiv$217164[ebp], eax

; 88   : 			if(eCiv == pPlayer->getCivilizationType())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	DWORD PTR _eCiv$217164[ebp], eax
	jne	SHORT $LN5@Init

; 89   : 			{
; 90   : 				if(pkImprovementInfo->GetFeatureMakesValid(FEATURE_MARSH))

	push	2
	mov	ecx, DWORD PTR _pkImprovementInfo$217161[ebp]
	call	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@Init

; 91   : 				{
; 92   : 					m_bKeepMarshes = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+58460], 1
	jmp	SHORT $LN5@Init
$LN3@Init:

; 93   : 				}
; 94   : 				else if (pkImprovementInfo->GetFeatureMakesValid(FEATURE_JUNGLE))

	push	1
	mov	ecx, DWORD PTR _pkImprovementInfo$217161[ebp]
	call	?GetFeatureMakesValid@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::GetFeatureMakesValid
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@Init

; 95   : 				{
; 96   : 					m_bKeepJungle = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+58461], 1
$LN5@Init:

; 97   : 				}
; 98   : 			}
; 99   : 		}

	jmp	$LN10@Init
$LN12@Init:

; 100  : 	}
; 101  : #endif
; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@CvBuilderTaskingAI@@QAEXPAVCvPlayer@@@Z ENDP	; CvBuilderTaskingAI::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@CvBuilderTaskingAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Uninit@CvBuilderTaskingAI@@QAEXXZ PROC			; CvBuilderTaskingAI::Uninit, COMDAT
; _this$ = ecx

; 106  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 	m_eRepairBuild = NO_BUILD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], -1

; 108  : 	m_pPlayer = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 109  : 	m_bLogging = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+58392], 0

; 110  : 	m_iNumCities = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+58396], -1

; 111  : 	m_pTargetPlot = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+58400], 0

; 112  : #ifdef AUI_WARNING_FIXES
; 113  : 	m_eFalloutFeature = NO_FEATURE;
; 114  : 	m_eFalloutRemove = NO_BUILD;
; 115  : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 116  : 	m_bKeepJungle = false;
; 117  : 	m_bKeepMarshes = false;
; 118  : #endif
; 119  : #endif
; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvBuilderTaskingAI@@QAEXXZ ENDP			; CvBuilderTaskingAI::Uninit
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
PUBLIC	?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ; CvBuilderTaskingAI::Read
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4BuildTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T220168 = -20						; size = 4
$T220161 = -16						; size = 4
_ui$217182 = -12					; size = 4
_uiNumSlots$ = -8					; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z PROC	; CvBuilderTaskingAI::Read, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	// Version number to maintain backwards compatibility
; 126  : 	uint uiVersion;
; 127  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 128  : 
; 129  : 	kStream >> m_eRepairBuild;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildTypes@@@Z ; operator>>
	add	esp, 8

; 130  : 
; 131  : 	uint uiNumSlots;
; 132  : 
; 133  : 	// non-territory plots
; 134  : 	kStream >> uiNumSlots;

	lea	eax, DWORD PTR _uiNumSlots$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 135  : 	m_aiNonTerritoryPlots.resize(uiNumSlots);

	mov	ecx, DWORD PTR _uiNumSlots$[ebp]
	mov	DWORD PTR $T220161[ebp], ecx
	mov	edx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+8
	cmp	edx, DWORD PTR $T220161[ebp]
	jae	SHORT $LN12@Read
	mov	eax, DWORD PTR $T220161[ebp]
	push	eax
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize
$LN12@Read:
	mov	ecx, DWORD PTR $T220161[ebp]
	mov	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, ecx

; 136  : 
; 137  : 	for(uint ui = 0; ui < uiNumSlots; ui++)

	mov	DWORD PTR _ui$217182[ebp], 0
	jmp	SHORT $LN5@Read
$LN4@Read:
	mov	edx, DWORD PTR _ui$217182[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$217182[ebp], edx
$LN5@Read:
	mov	eax, DWORD PTR _ui$217182[ebp]
	cmp	eax, DWORD PTR _uiNumSlots$[ebp]
	jae	SHORT $LN3@Read

; 138  : 	{
; 139  : 		kStream >> m_aiNonTerritoryPlots[ui];

	mov	ecx, DWORD PTR _ui$217182[ebp]
	mov	edx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T220168[ebp], eax
	mov	ecx, DWORD PTR $T220168[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 140  : 	}

	jmp	SHORT $LN4@Read
$LN3@Read:

; 141  : 
; 142  : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 143  : 	kStream >> m_bKeepMarshes;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 58460				; 0000e45cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 144  : 	if (uiVersion >= 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jb	SHORT $LN2@Read

; 145  : 	{
; 146  : 		kStream >> m_bKeepJungle;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 58461				; 0000e45dH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 147  : 	}
; 148  : 	else

	jmp	SHORT $LN1@Read
$LN2@Read:

; 149  : 	{
; 150  : 		m_bKeepJungle = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+58461], 0
$LN1@Read:

; 151  : 	}
; 152  : #endif
; 153  : 		
; 154  : 	m_iNumCities = -1; //Force everyone to do an CvBuilderTaskingAI::Update() after loading

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+58396], -1

; 155  : 	m_pTargetPlot = NULL;		//Force everyone to recalculate current yields after loading.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+58400], 0

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ENDP	; CvBuilderTaskingAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ; CvBuilderTaskingAI::Write
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4BuildTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T220198 = -24						; size = 4
$T220191 = -20						; size = 4
$T220184 = -16						; size = 4
$T220177 = -12						; size = 4
_ui$217202 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z PROC	; CvBuilderTaskingAI::Write, COMDAT
; _this$ = ecx

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 	// Current version number
; 162  : 	uint uiVersion = 2;

	mov	DWORD PTR _uiVersion$[ebp], 2

; 163  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 164  : 
; 165  : 	kStream << m_eRepairBuild;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4BuildTypes@@@Z ; operator<<
	add	esp, 8

; 166  : 
; 167  : 	// non-territory plots
; 168  : 	kStream << m_aiNonTerritoryPlots.size();

	mov	eax, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	mov	DWORD PTR $T220184[ebp], eax
	mov	ecx, DWORD PTR $T220184[ebp]
	mov	DWORD PTR $T220177[ebp], ecx
	lea	edx, DWORD PTR $T220177[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 169  : 	for(uint ui = 0; ui < m_aiNonTerritoryPlots.size(); ui++)

	mov	DWORD PTR _ui$217202[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	eax, DWORD PTR _ui$217202[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$217202[ebp], eax
$LN3@Write:
	mov	ecx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	mov	DWORD PTR $T220191[ebp], ecx
	mov	edx, DWORD PTR _ui$217202[ebp]
	cmp	edx, DWORD PTR $T220191[ebp]
	jae	SHORT $LN1@Write

; 170  : 	{
; 171  : 		kStream << m_aiNonTerritoryPlots[ui];

	mov	eax, DWORD PTR _ui$217202[ebp]
	mov	ecx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T220198[ebp], edx
	mov	eax, DWORD PTR $T220198[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 172  : 	}

	jmp	SHORT $LN2@Write
$LN1@Write:

; 173  : 
; 174  : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 175  : 	kStream << m_bKeepMarshes;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 58460				; 0000e45cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 176  : 	kStream << m_bKeepJungle;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 58461				; 0000e45dH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 177  : #endif
; 178  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvBuilderTaskingAI@@QAEXAAVFDataStream@@@Z ENDP	; CvBuilderTaskingAI::Write
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_03FPIELGGN@?5?1?1?$AA@			; `string'
PUBLIC	??_C@_07CLPMHPLJ@?2?2?5end?5?$AA@		; `string'
PUBLIC	??_C@_02FHJIKMCF@?5?$CK?$AA@			; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_06PHGHDMGF@?$CFd?0?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@FFIHGBDP@faith?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_0M@DJEDCNJJ@culture?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_0M@CMMFFGDL@gold?5?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_0M@MOPCOJJM@science?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_0M@MJLKGKLJ@production?5?$AA@		; `string'
PUBLIC	??_C@_0M@FMFHKBFH@food?5?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_03NCBEKFB@?5?2?2?$AA@			; `string'
PUBLIC	??_C@_03IAHPLKPE@?1?1?5?$AA@			; `string'
PUBLIC	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BG@OJNBICH@?1?1?5Empire?5Unhappy?$CB?5?1?1?$AA@ ; `string'
PUBLIC	?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ	; CvBuilderTaskingAI::UpdateRoutePlots
PUBLIC	__$ArrayPad$
PUBLIC	?Update@CvBuilderTaskingAI@@QAEXXZ		; CvBuilderTaskingAI::Update
EXTRN	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ:PROC ; CvCityStrategyAI::GetFocusYield
EXTRN	?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z:PROC ; CvCityStrategyAI::GetBestYieldAverageTimes100
EXTRN	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z:PROC ; CvCityStrategyAI::GetYieldDeltaTimes100
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?UpdateBestYields@CvCityStrategyAI@@QAEXXZ:PROC	; CvCityStrategyAI::UpdateBestYields
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
;	COMDAT ??_C@_03FPIELGGN@?5?1?1?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_03FPIELGGN@?5?1?1?$AA@ DB ' //', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLPMHPLJ@?2?2?5end?5?$AA@
CONST	SEGMENT
??_C@_07CLPMHPLJ@?2?2?5end?5?$AA@ DB '\\ end ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02FHJIKMCF@?5?$CK?$AA@
CONST	SEGMENT
??_C@_02FHJIKMCF@?5?$CK?$AA@ DB ' *', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PHGHDMGF@?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_06PHGHDMGF@?$CFd?0?5?$CFd?$AA@ DB '%d, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FFIHGBDP@faith?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@FFIHGBDP@faith?5?5?5?5?5?5?$AA@ DB 'faith      ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DJEDCNJJ@culture?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@DJEDCNJJ@culture?5?5?5?5?$AA@ DB 'culture    ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMMFFGDL@gold?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@CMMFFGDL@gold?5?5?5?5?5?5?5?$AA@ DB 'gold       ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MOPCOJJM@science?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@MOPCOJJM@science?5?5?5?5?$AA@ DB 'science    ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MJLKGKLJ@production?5?$AA@
CONST	SEGMENT
??_C@_0M@MJLKGKLJ@production?5?$AA@ DB 'production ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FMFHKBFH@food?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0M@FMFHKBFH@food?5?5?5?5?5?5?5?$AA@ DB 'food       ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCBEKFB@?5?2?2?$AA@
CONST	SEGMENT
??_C@_03NCBEKFB@?5?2?2?$AA@ DB ' \\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IAHPLKPE@?1?1?5?$AA@
CONST	SEGMENT
??_C@_03IAHPLKPE@?1?1?5?$AA@ DB '// ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OJNBICH@?1?1?5Empire?5Unhappy?$CB?5?1?1?$AA@
CONST	SEGMENT
??_C@_0BG@OJNBICH@?1?1?5Empire?5Unhappy?$CB?5?1?1?$AA@ DB '// Empire Unha'
	DB	'ppy! //', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Update@CvBuilderTaskingAI@@QAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Update@CvBuilderTaskingAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Update@CvBuilderTaskingAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?Update@CvBuilderTaskingAI@@QAEXXZ
_TEXT	SEGMENT
tv332 = -272						; size = 4
tv328 = -268						; size = 4
tv206 = -264						; size = 4
tv322 = -260						; size = 4
tv538 = -256						; size = 4
tv314 = -252						; size = 4
tv340 = -248						; size = 4
_this$ = -244						; size = 4
$T220321 = -240						; size = 4
$T220303 = -236						; size = 4
$T220260 = -232						; size = 4
$T220251 = -228						; size = 4
$T220235 = -224						; size = 4
$T220212 = -220						; size = 4
$T220211 = -216						; size = 4
$T220210 = -212						; size = 4
$T220209 = -208						; size = 28
$T220208 = -180						; size = 4
_strYield$217235 = -176					; size = 28
_strNumbers$217252 = -148				; size = 28
_ui$217231 = -120					; size = 4
_str$217225 = -116					; size = 28
_strCityName$217227 = -88				; size = 28
_str$217218 = -60					; size = 28
__$ArrayPad$ = -32					; size = 4
_bShowOutput$217216 = -25				; size = 1
_pLoopCity$217221 = -24					; size = 4
_pCity$ = -20						; size = 4
_iLoop$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Update@CvBuilderTaskingAI@@QAEXXZ PROC			; CvBuilderTaskingAI::Update, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Update@CvBuilderTaskingAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 	UpdateRoutePlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ ; CvBuilderTaskingAI::UpdateRoutePlots

; 184  : 	m_iNumCities = m_pPlayer->getNumCities();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+58396], eax

; 185  : 
; 186  : 	int iLoop;
; 187  : 	CvCity* pCity;
; 188  : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN20@Update
$LN19@Update:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN20@Update:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN18@Update

; 189  : 	{
; 190  : 		pCity->GetCityStrategyAI()->UpdateBestYields();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?UpdateBestYields@CvCityStrategyAI@@QAEXXZ ; CvCityStrategyAI::UpdateBestYields

; 191  : 	}

	jmp	SHORT $LN19@Update
$LN18@Update:

; 192  : 
; 193  : 	if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN21@Update

; 194  : 	{
; 195  : 		bool bShowOutput = m_pPlayer->isHuman();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	mov	BYTE PTR _bShowOutput$217216[ebp], al

; 196  : 
; 197  : 		if(m_pPlayer->IsEmpireUnhappy())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@Update

; 198  : 		{
; 199  : 			CvString str = "// Empire Unhappy! //";

	mov	edx, OFFSET ??_C@_0BG@OJNBICH@?1?1?5Empire?5Unhappy?$CB?5?1?1?$AA@
	test	edx, edx
	je	SHORT $LN35@Update
	mov	DWORD PTR tv340[ebp], OFFSET ??_C@_0BG@OJNBICH@?1?1?5Empire?5Unhappy?$CB?5?1?1?$AA@
	jmp	SHORT $LN36@Update
$LN35@Update:
	mov	DWORD PTR tv340[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN36@Update:
	mov	eax, DWORD PTR tv340[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$217218[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 200  : 			LogInfo(str, m_pPlayer, bShowOutput);

	movzx	ecx, BYTE PTR _bShowOutput$217216[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T220208[ebp], esp
	mov	DWORD PTR $T220235[ebp], ecx
	lea	edx, DWORD PTR _str$217218[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220235[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T220235[ebp]
	mov	DWORD PTR tv314[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 201  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$217218[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN16@Update:

; 202  : 
; 203  : 		// show crisis states
; 204  : 		CvCity* pLoopCity;
; 205  : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$217221[ebp], eax
	jmp	SHORT $LN15@Update
$LN14@Update:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$217221[ebp], eax
$LN15@Update:
	cmp	DWORD PTR _pLoopCity$217221[ebp], 0
	je	$LN21@Update

; 206  : 		{
; 207  : 			CvString str;

	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 208  : 			str += "// ";

	push	OFFSET ??_C@_03IAHPLKPE@?1?1?5?$AA@
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 209  : 			CvString strCityName;

	lea	ecx, DWORD PTR _strCityName$217227[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 210  : 			strCityName = pLoopCity->getName();

	lea	edx, DWORD PTR $T220209[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$217221[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv538[ebp], eax
	mov	eax, DWORD PTR tv538[ebp]
	mov	DWORD PTR $T220251[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T220251[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strCityName$217227[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T220209[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 211  : 			str += strCityName;

	lea	edx, DWORD PTR _strCityName$217227[ebp]
	push	edx
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 212  : 			str += " \\\\";

	push	OFFSET ??_C@_03NCBEKFB@?5?2?2?$AA@
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 213  : 
; 214  : 			LogInfo(str, m_pPlayer, bShowOutput);

	movzx	eax, BYTE PTR _bShowOutput$217216[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T220210[ebp], esp
	mov	DWORD PTR $T220260[ebp], eax
	lea	ecx, DWORD PTR _str$217225[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T220260[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T220260[ebp]
	mov	DWORD PTR tv322[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 215  : 
; 216  : #ifdef AUI_WARNING_FIXES
; 217  : 			for (int ui = 0; ui < NUM_YIELD_TYPES; ui++)
; 218  : #else
; 219  : 			for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$217231[ebp], 0
	jmp	SHORT $LN12@Update
$LN11@Update:
	mov	eax, DWORD PTR _ui$217231[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$217231[ebp], eax
$LN12@Update:
	cmp	DWORD PTR _ui$217231[ebp], 6
	jae	$LN10@Update

; 220  : #endif
; 221  : 			{
; 222  : 				//double fYield = pLoopCity->GetCityStrategyAI()->GetYieldAverage((YieldTypes)ui);
; 223  : 				//double fYieldDeficient = pLoopCity->GetCityStrategyAI()->GetDeficientYieldValue((YieldTypes)ui);
; 224  : 				CvString strYield;

	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 225  : 				switch(ui)

	mov	ecx, DWORD PTR _ui$217231[ebp]
	mov	DWORD PTR tv206[ebp], ecx
	cmp	DWORD PTR tv206[ebp], 5
	ja	$LN8@Update
	mov	edx, DWORD PTR tv206[ebp]
	jmp	DWORD PTR $LN111@Update[edx*4]
$LN7@Update:

; 226  : 				{
; 227  : 				case YIELD_FOOD:
; 228  : 					strYield = "food       ";

	mov	eax, OFFSET ??_C@_0M@FMFHKBFH@food?5?5?5?5?5?5?5?$AA@
	test	eax, eax
	je	SHORT $LN62@Update
	push	OFFSET ??_C@_0M@FMFHKBFH@food?5?5?5?5?5?5?5?$AA@
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN63@Update
$LN62@Update:
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN63@Update:

; 229  : 					break;

	jmp	$LN8@Update
$LN6@Update:

; 230  : 				case YIELD_PRODUCTION:
; 231  : 					strYield = "production ";

	mov	ecx, OFFSET ??_C@_0M@MJLKGKLJ@production?5?$AA@
	test	ecx, ecx
	je	SHORT $LN66@Update
	push	OFFSET ??_C@_0M@MJLKGKLJ@production?5?$AA@
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN67@Update
$LN66@Update:
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN67@Update:

; 232  : 					break;

	jmp	$LN8@Update
$LN5@Update:

; 233  : 				case YIELD_SCIENCE:
; 234  : 					strYield = "science    ";

	mov	edx, OFFSET ??_C@_0M@MOPCOJJM@science?5?5?5?5?$AA@
	test	edx, edx
	je	SHORT $LN70@Update
	push	OFFSET ??_C@_0M@MOPCOJJM@science?5?5?5?5?$AA@
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN71@Update
$LN70@Update:
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN71@Update:

; 235  : 					break;

	jmp	SHORT $LN8@Update
$LN4@Update:

; 236  : 				case YIELD_GOLD:
; 237  : 					strYield = "gold       ";

	mov	eax, OFFSET ??_C@_0M@CMMFFGDL@gold?5?5?5?5?5?5?5?$AA@
	test	eax, eax
	je	SHORT $LN74@Update
	push	OFFSET ??_C@_0M@CMMFFGDL@gold?5?5?5?5?5?5?5?$AA@
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN75@Update
$LN74@Update:
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN75@Update:

; 238  : 					break;

	jmp	SHORT $LN8@Update
$LN3@Update:

; 239  : 				case YIELD_CULTURE:
; 240  : 					strYield = "culture    ";

	mov	ecx, OFFSET ??_C@_0M@DJEDCNJJ@culture?5?5?5?5?$AA@
	test	ecx, ecx
	je	SHORT $LN78@Update
	push	OFFSET ??_C@_0M@DJEDCNJJ@culture?5?5?5?5?$AA@
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN79@Update
$LN78@Update:
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN79@Update:

; 241  : 					break;

	jmp	SHORT $LN8@Update
$LN2@Update:

; 242  : 				case YIELD_FAITH:
; 243  : 					strYield = "faith      ";

	mov	edx, OFFSET ??_C@_0M@FFIHGBDP@faith?5?5?5?5?5?5?$AA@
	test	edx, edx
	je	SHORT $LN82@Update
	push	OFFSET ??_C@_0M@FFIHGBDP@faith?5?5?5?5?5?5?$AA@
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN8@Update
$LN82@Update:
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN8@Update:

; 244  : 					break;
; 245  : 				}
; 246  : 
; 247  : 				CvString strNumbers;

	lea	ecx, DWORD PTR _strNumbers$217252[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 248  : 				strNumbers.Format("%d, %d", pLoopCity->GetCityStrategyAI()->GetBestYieldAverageTimes100((YieldTypes)ui), pLoopCity->GetCityStrategyAI()->GetYieldDeltaTimes100((YieldTypes)ui));

	mov	eax, DWORD PTR _ui$217231[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$217221[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldDeltaTimes100
	movsx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _ui$217231[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$217221[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetBestYieldAverageTimes100@CvCityStrategyAI@@QAEGW4YieldTypes@@@Z ; CvCityStrategyAI::GetBestYieldAverageTimes100
	movzx	eax, ax
	push	eax
	push	OFFSET ??_C@_06PHGHDMGF@?$CFd?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strNumbers$217252[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 249  : 
; 250  : 				//int iYieldAdjusted = (int)workerround(fYield * 100);
; 251  : 				//int iYieldDeficientAdjacent = (int)workerround(fYieldDeficient * 100);
; 252  : 
; 253  : 				//strNumbers.Format("%d / %d", iYieldAdjusted, iYieldDeficientAdjacent);
; 254  : 				strYield += strNumbers;

	lea	edx, DWORD PTR _strNumbers$217252[ebp]
	push	edx
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 255  : 
; 256  : 				if(ui == pLoopCity->GetCityStrategyAI()->GetFocusYield())

	mov	ecx, DWORD PTR _pLoopCity$217221[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetFocusYield
	cmp	DWORD PTR _ui$217231[ebp], eax
	jne	SHORT $LN1@Update

; 257  : 				{
; 258  : 					strYield += " *";

	push	OFFSET ??_C@_02FHJIKMCF@?5?$CK?$AA@
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@Update:

; 259  : 				}
; 260  : 
; 261  : 				//if (iYieldAdjusted < iYieldDeficientAdjacent)
; 262  : 				//{
; 263  : 				//if (GetDeficientYield(pLoopCity, false) != GetDeficientYield(pLoopCity, true))
; 264  : 				//{
; 265  : 				//	strYield += "  Problem, but happiness over is overriding it";
; 266  : 				//}
; 267  : 				//else
; 268  : 				//{
; 269  : 				//	strYield += "  PROBLEM!!";
; 270  : 				//}
; 271  : 				//}
; 272  : 				LogInfo(strYield, m_pPlayer, bShowOutput);

	movzx	eax, BYTE PTR _bShowOutput$217216[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T220211[ebp], esp
	mov	DWORD PTR $T220303[ebp], eax
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T220303[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T220303[ebp]
	mov	DWORD PTR tv328[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 273  : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strNumbers$217252[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN11@Update
$LN10@Update:

; 274  : 
; 275  : 			str = "\\\\ end ";

	mov	eax, OFFSET ??_C@_07CLPMHPLJ@?2?2?5end?5?$AA@
	test	eax, eax
	je	SHORT $LN98@Update
	push	OFFSET ??_C@_07CLPMHPLJ@?2?2?5end?5?$AA@
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN99@Update
$LN98@Update:
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN99@Update:

; 276  : 			str += strCityName;

	lea	ecx, DWORD PTR _strCityName$217227[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 277  : 			str += " //";

	push	OFFSET ??_C@_03FPIELGGN@?5?1?1?$AA@
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 278  : 			LogInfo(str, m_pPlayer, bShowOutput);

	movzx	edx, BYTE PTR _bShowOutput$217216[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T220212[ebp], esp
	mov	DWORD PTR $T220321[ebp], edx
	lea	eax, DWORD PTR _str$217225[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220321[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T220321[ebp]
	mov	DWORD PTR tv332[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 279  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strCityName$217227[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$217225[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN14@Update
$LN21@Update:

; 280  : 	}
; 281  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN111@Update:
	DD	$LN7@Update
	DD	$LN6@Update
	DD	$LN4@Update
	DD	$LN5@Update
	DD	$LN3@Update
	DD	$LN2@Update
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _str$217218[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _str$217225[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strCityName$217227[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T220209[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _strYield$217235[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?Update@CvBuilderTaskingAI@@QAEXXZ$7:
	lea	ecx, DWORD PTR _strNumbers$217252[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Update@CvBuilderTaskingAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Update@CvBuilderTaskingAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Update@CvBuilderTaskingAI@@QAEXXZ ENDP			; CvBuilderTaskingAI::Update
PUBLIC	?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z	; GetPlotYield
EXTRN	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::calculateNatureYield
; Function compile flags: /Odtp
;	COMDAT ?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
_eYield$ = 12						; size = 4
?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z PROC	; GetPlotYield, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp

; 285  : 	if(pPlot->getTerrainType() == NO_TERRAIN)

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	cmp	ecx, -1
	jne	SHORT $LN1@GetPlotYie

; 286  : 	{
; 287  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN2@GetPlotYie
$LN1@GetPlotYie:

; 288  : 	}
; 289  : 
; 290  : 	return pPlot->calculateNatureYield(eYield, NO_TEAM);;

	push	0
	push	-1
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
$LN2@GetPlotYie:

; 291  : }

	pop	ebp
	ret	0
?GetPlotYield@@YAHPAVCvPlot@@W4YieldTypes@@@Z ENDP	; GetPlotYield
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesToCapital
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z:PROC ; CvPlot::SetBuilderAIScratchPadPlayer
EXTRN	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z:PROC ; CvPlot::SetBuilderAIScratchPadTurn
EXTRN	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z:PROC ; CvPlot::SetBuilderAIScratchPadRoute
EXTRN	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z:PROC ; CvPlot::SetBuilderAIScratchPadValue
EXTRN	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ:PROC ; CvPlot::GetBuilderAIScratchPadValue
EXTRN	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlot::GetBuilderAIScratchPadPlayer
EXTRN	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ:PROC	; CvPlot::GetBuilderAIScratchPadTurn
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRate
EXTRN	?calculateGoldRate@CvPlayer@@QBEHXZ:PROC	; CvPlayer::calculateGoldRate
EXTRN	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlot::GetPlayerResponsibleForRoute
EXTRN	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::IsTradeRoute
EXTRN	?IsRoutePillaged@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsRoutePillaged
EXTRN	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::getRouteType
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetBuildRouteFinder
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
EXTRN	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ:PROC	; CvRouteInfo::GetGoldMaintenance
EXTRN	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z:PROC ; CvGlobals::getRouteInfo
EXTRN	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z:PROC ; CvTreasury::GetCityConnectionRouteGoldTimes100
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
EXTRN	?IsCapitalConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@W4RouteTypes@@@Z:PROC ; CvPlayer::IsCapitalConnectedToCity
EXTRN	?IsIndustrialRouteToCapital@CvCity@@QBE_NXZ:PROC ; CvCity::IsIndustrialRouteToCapital
EXTRN	?GetIndustrialRoute@CvGame@@QBE?AW4RouteTypes@@XZ:PROC ; CvGame::GetIndustrialRoute
; Function compile flags: /Odtp
;	COMDAT ?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z
_TEXT	SEGMENT
tv239 = -292						; size = 4
tv391 = -288						; size = 4
_this$ = -284						; size = 4
$T220564 = -240						; size = 4
$T220559 = -236						; size = 4
$T220555 = -232						; size = 4
$T220551 = -228						; size = 4
$T220547 = -224						; size = 4
$T220538 = -220						; size = 4
$T220534 = -216						; size = 4
$T220525 = -212						; size = 4
$T220516 = -208						; size = 4
$T220515 = -204						; size = 4
$T220502 = -200						; size = 4
$T220496 = -196						; size = 4
$T220492 = -192						; size = 4
$T220488 = -188						; size = 4
$T220481 = -184						; size = 4
$T220472 = -180						; size = 4
$T220466 = -176						; size = 4
$T220462 = -172						; size = 4
$T220458 = -168						; size = 4
$T220449 = -164						; size = 4
$T220440 = -160						; size = 4
$T220439 = -156						; size = 4
$T220425 = -148						; size = 4
$T220424 = -144						; size = 4
$T220411 = -140						; size = 4
$T220405 = -136						; size = 4
$T220401 = -132						; size = 4
$T220397 = -128						; size = 4
$T220396 = -124						; size = 4
$T220392 = -120						; size = 4
$T220391 = -116						; size = 4
$T220387 = -112						; size = 4
$T220386 = -108						; size = 4
$T220382 = -104						; size = 4
$T220381 = -100						; size = 4
$T220369 = -96						; size = 4
$T220365 = -92						; size = 4
$T220356 = -88						; size = 4
$T220347 = -84						; size = 4
$T220346 = -80						; size = 4
$T220345 = -76						; size = 4
$T220344 = -72						; size = 4
_iValue$217324 = -68					; size = 4
_pCity$217298 = -64					; size = 4
_iProfit$ = -60						; size = 4
_bMajorMinorConnection$ = -53				; size = 1
_iRoadLength$ = -52					; size = 4
_iPlotsNeeded$ = -48					; size = 4
_pPlot$ = -44						; size = 4
_pRouteInfo$ = -40					; size = 4
_pNode$ = -36						; size = 4
_iGameTurn$ = -32					; size = 4
_iGoldForRoute$ = -28					; size = 4
_iMaintenancePerTile$ = -24				; size = 4
_iRouteValue$ = -20					; size = 4
_bIndustrialRoute$ = -13				; size = 1
_iPathfinderFlags$ = -12				; size = 4
_bFoundPath$ = -5					; size = 1
_sValue$ = -4						; size = 2
_pPlayerCapital$ = 8					; size = 4
_pTargetCity$ = 12					; size = 4
_eRoute$ = 16						; size = 4
?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z PROC ; CvBuilderTaskingAI::ConnectCitiesToCapital, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	bool bMajorMinorConnection = false;

	mov	BYTE PTR _bMajorMinorConnection$[ebp], 0

; 296  : 	if(pTargetCity->getOwner() != pPlayerCapital->getOwner())

	mov	eax, DWORD PTR _pTargetCity$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T220356[ebp], ecx
	mov	edx, DWORD PTR _pPlayerCapital$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T220365[ebp], eax
	mov	ecx, DWORD PTR $T220356[ebp]
	cmp	ecx, DWORD PTR $T220365[ebp]
	je	SHORT $LN37@ConnectCit

; 297  : 	{
; 298  : 		bMajorMinorConnection = true;

	mov	BYTE PTR _bMajorMinorConnection$[ebp], 1
$LN37@ConnectCit:

; 299  : 	}
; 300  : 
; 301  : 	bool bIndustrialRoute = false;

	mov	BYTE PTR _bIndustrialRoute$[ebp], 0

; 302  : 	if(GC.getGame().GetIndustrialRoute() == eRoute)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T220369[ebp], edx
	mov	ecx, DWORD PTR $T220369[ebp]
	call	?GetIndustrialRoute@CvGame@@QBE?AW4RouteTypes@@XZ ; CvGame::GetIndustrialRoute
	cmp	eax, DWORD PTR _eRoute$[ebp]
	jne	SHORT $LN36@ConnectCit

; 303  : 	{
; 304  : 		bIndustrialRoute = true;

	mov	BYTE PTR _bIndustrialRoute$[ebp], 1
$LN36@ConnectCit:

; 305  : 	}
; 306  : 
; 307  : 	// if we already have a connection, bail out
; 308  : 	if(bIndustrialRoute && pTargetCity->IsIndustrialRouteToCapital())

	movzx	eax, BYTE PTR _bIndustrialRoute$[ebp]
	test	eax, eax
	je	SHORT $LN35@ConnectCit
	mov	ecx, DWORD PTR _pTargetCity$[ebp]
	call	?IsIndustrialRouteToCapital@CvCity@@QBE_NXZ ; CvCity::IsIndustrialRouteToCapital
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN35@ConnectCit
	jmp	$LN38@ConnectCit

; 309  : 	{
; 310  : 		return;

	jmp	SHORT $LN34@ConnectCit
$LN35@ConnectCit:

; 311  : 	}
; 312  : 	else if(m_pPlayer->IsCapitalConnectedToCity(pTargetCity, eRoute))

	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTargetCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?IsCapitalConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@W4RouteTypes@@@Z ; CvPlayer::IsCapitalConnectedToCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@ConnectCit

; 313  : 	{
; 314  : 		return;

	jmp	$LN38@ConnectCit
$LN34@ConnectCit:

; 315  : 	}
; 316  : 
; 317  : 	int iGoldForRoute = 0;

	mov	DWORD PTR _iGoldForRoute$[ebp], 0

; 318  : 	if(!bMajorMinorConnection)

	movzx	eax, BYTE PTR _bMajorMinorConnection$[ebp]
	test	eax, eax
	jne	SHORT $LN32@ConnectCit

; 319  : 	{
; 320  : 		iGoldForRoute = m_pPlayer->GetTreasury()->GetCityConnectionRouteGoldTimes100(pTargetCity) / 100;

	mov	ecx, DWORD PTR _pTargetCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetCityConnectionRouteGoldTimes100@CvTreasury@@QBEHPAVCvCity@@@Z ; CvTreasury::GetCityConnectionRouteGoldTimes100
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGoldForRoute$[ebp], eax
$LN32@ConnectCit:

; 321  : 	}
; 322  : 
; 323  : 	CvRouteInfo* pRouteInfo = GC.getRouteInfo(eRoute);

	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pRouteInfo$[ebp], eax

; 324  : 	if(!pRouteInfo)

	cmp	DWORD PTR _pRouteInfo$[ebp], 0
	jne	SHORT $LN31@ConnectCit

; 325  : 	{
; 326  : 		return;

	jmp	$LN38@ConnectCit
$LN31@ConnectCit:

; 327  : 	}
; 328  : 	int iMaintenancePerTile = pRouteInfo->GetGoldMaintenance();

	mov	ecx, DWORD PTR _pRouteInfo$[ebp]
	call	?GetGoldMaintenance@CvRouteInfo@@QBEHXZ	; CvRouteInfo::GetGoldMaintenance
	mov	DWORD PTR _iMaintenancePerTile$[ebp], eax

; 329  : 	if(iMaintenancePerTile < 0)  // div by zero check

	cmp	DWORD PTR _iMaintenancePerTile$[ebp], 0
	jge	SHORT $LN52@ConnectCit

; 330  : 	{
; 331  : 		return;

	jmp	$LN38@ConnectCit

; 332  : 	}
; 333  : 
; 334  : 	// build a path between the two cities
; 335  : 	int iPathfinderFlags = m_pPlayer->GetID();

$LN52@ConnectCit:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _iPathfinderFlags$[ebp], edx

; 336  : 	int iRouteValue = eRoute + 1;

	mov	eax, DWORD PTR _eRoute$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRouteValue$[ebp], eax

; 337  : 	// assuming that there are fewer than 256 players
; 338  : 	iPathfinderFlags |= (iRouteValue << 8);

	mov	ecx, DWORD PTR _iRouteValue$[ebp]
	shl	ecx, 8
	or	ecx, DWORD PTR _iPathfinderFlags$[ebp]
	mov	DWORD PTR _iPathfinderFlags$[ebp], ecx

; 339  : 	bool bFoundPath = GC.GetBuildRouteFinder().GeneratePath(pPlayerCapital->plot()->getX(), pPlayerCapital->plot()->getY(), pTargetCity->plot()->getX(), pTargetCity->plot()->getY(), iPathfinderFlags);

	mov	ecx, DWORD PTR _pTargetCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220381[ebp], eax
	mov	edx, DWORD PTR $T220381[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T220382[ebp], eax
	mov	ecx, DWORD PTR _pTargetCity$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220386[ebp], eax
	mov	ecx, DWORD PTR $T220386[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T220387[ebp], edx
	mov	ecx, DWORD PTR _pPlayerCapital$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220391[ebp], eax
	mov	eax, DWORD PTR $T220391[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T220392[ebp], ecx
	mov	ecx, DWORD PTR _pPlayerCapital$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220396[ebp], eax
	mov	edx, DWORD PTR $T220396[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T220397[ebp], eax
	push	0
	mov	ecx, DWORD PTR _iPathfinderFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220382[ebp]
	push	edx
	mov	eax, DWORD PTR $T220387[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220392[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220397[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bFoundPath$[ebp], al

; 340  : 
; 341  : 	//  if no path, then bail!
; 342  : 	if(!bFoundPath)

	movzx	eax, BYTE PTR _bFoundPath$[ebp]
	test	eax, eax
	jne	SHORT $LN29@ConnectCit

; 343  : 	{
; 344  : 		return;

	jmp	$LN38@ConnectCit
$LN29@ConnectCit:

; 345  : 	}
; 346  : 
; 347  : 	// walk the path
; 348  : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 349  : 
; 350  : 	// go through the route to see how long it is and how many plots already have roads
; 351  : 	int iRoadLength = 0;

	mov	DWORD PTR _iRoadLength$[ebp], 0

; 352  : 	int iPlotsNeeded = 0;

	mov	DWORD PTR _iPlotsNeeded$[ebp], 0

; 353  : 	CvAStarNode* pNode = GC.GetBuildRouteFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	DWORD PTR $T220401[ebp], eax
	mov	ecx, DWORD PTR $T220401[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR _pNode$[ebp], edx
$LN28@ConnectCit:

; 354  : #ifdef AUI_WORKER_INCA_HILLS
; 355  : 	bool bIncaBonusActive = (m_pPlayer->GetPlayerTraits()->IsNoHillsImprovementMaintenance() && !m_pPlayer->isHuman());
; 356  : #endif
; 357  : 	while(pNode)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN27@ConnectCit

; 358  : 	{
; 359  : 		pPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220405[ebp], eax
	mov	ecx, DWORD PTR _pNode$[ebp]
	movsx	edx, WORD PTR [ecx+82]
	mov	DWORD PTR $T220425[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	mov	DWORD PTR $T220424[ebp], ecx
	cmp	DWORD PTR $T220424[ebp], -2147483647	; 80000001H
	je	SHORT $LN66@ConnectCit
	cmp	DWORD PTR $T220425[ebp], -2147483647	; 80000001H
	jne	SHORT $LN67@ConnectCit
$LN66@ConnectCit:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	SHORT $LN68@ConnectCit
$LN67@ConnectCit:
	mov	edx, DWORD PTR $T220405[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T220411[ebp], eax
	mov	ecx, DWORD PTR $T220425[ebp]
	imul	ecx, DWORD PTR $T220411[ebp]
	add	ecx, DWORD PTR $T220424[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T220405[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$[ebp], ecx
$LN68@ConnectCit:

; 360  : 		pNode = pNode->m_pParent;

	mov	eax, DWORD PTR _pNode$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _pNode$[ebp], ecx

; 361  : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN26@ConnectCit

; 362  : 		{
; 363  : 			break;

	jmp	$LN27@ConnectCit
$LN26@ConnectCit:

; 364  : 		}
; 365  : 
; 366  : 		CvCity* pCity = pPlot->getPlotCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	mov	DWORD PTR _pCity$217298[ebp], eax

; 367  : 		if(NULL != pCity && pCity->getTeam() == m_pPlayer->getTeam())

	cmp	DWORD PTR _pCity$217298[ebp], 0
	je	SHORT $LN25@ConnectCit
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T220439[ebp], eax
	mov	ecx, DWORD PTR $T220439[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T220440[ebp], eax
	mov	ecx, DWORD PTR _pCity$217298[ebp]
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	cmp	eax, DWORD PTR $T220440[ebp]
	jne	SHORT $LN25@ConnectCit

; 368  : 		{
; 369  : 			continue;

	jmp	$LN28@ConnectCit
$LN25@ConnectCit:

; 370  : 		}
; 371  : 
; 372  : #ifdef AUI_WORKER_INCA_HILLS
; 373  : 		if (!bIncaBonusActive || !pPlot->isHills())
; 374  : 		{
; 375  : #endif
; 376  : 		if(pPlot->getRouteType() == eRoute && !pPlot->IsRoutePillaged())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, DWORD PTR _eRoute$[ebp]
	jne	SHORT $LN24@ConnectCit
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN24@ConnectCit

; 377  : 		{
; 378  : 			// if this is already a trade route or someone else built it, we can count is as free
; 379  : 			if(pPlot->IsTradeRoute(m_pPlayer->GetID()) || pPlot->GetPlayerResponsibleForRoute() != m_pPlayer->GetID())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T220449[ebp], eax
	mov	ecx, DWORD PTR $T220449[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsTradeRoute@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::IsTradeRoute
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN22@ConnectCit
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T220458[ebp], edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetPlayerResponsibleForRoute@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetPlayerResponsibleForRoute
	cmp	eax, DWORD PTR $T220458[ebp]
	je	SHORT $LN23@ConnectCit
$LN22@ConnectCit:

; 380  : 			{
; 381  : 				continue;

	jmp	$LN28@ConnectCit
$LN23@ConnectCit:

; 382  : 			}
; 383  : 			iRoadLength++;

	mov	eax, DWORD PTR _iRoadLength$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRoadLength$[ebp], eax

; 384  : 		}
; 385  : 		else

	jmp	SHORT $LN21@ConnectCit
$LN24@ConnectCit:

; 386  : 		{
; 387  : 			iRoadLength++;

	mov	ecx, DWORD PTR _iRoadLength$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRoadLength$[ebp], ecx

; 388  : 			iPlotsNeeded++;

	mov	edx, DWORD PTR _iPlotsNeeded$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotsNeeded$[ebp], edx
$LN21@ConnectCit:

; 389  : 		}
; 390  : #ifdef AUI_WORKER_INCA_HILLS
; 391  : 		}
; 392  : #endif
; 393  : 	}

	jmp	$LN28@ConnectCit
$LN27@ConnectCit:

; 394  : 
; 395  : #ifdef AUI_WORKER_INCA_HILLS
; 396  : 	int iFreeIncaRoadLength = 0;
; 397  : 	if (bIncaBonusActive)
; 398  : 	{
; 399  : 		if (iRoadLength == 0)
; 400  : 		{
; 401  : 			iRoadLength = 1;
; 402  : 			iFreeIncaRoadLength = 1;
; 403  : 		}
; 404  : 		if (iPlotsNeeded == 0)
; 405  : 		{
; 406  : 			iPlotsNeeded = 1;
; 407  : 		}
; 408  : 	}
; 409  : #endif
; 410  : 
; 411  : 	// This is very odd
; 412  : 	if(iRoadLength <= 0 || iPlotsNeeded <= 0)

	cmp	DWORD PTR _iRoadLength$[ebp], 0
	jle	SHORT $LN19@ConnectCit
	cmp	DWORD PTR _iPlotsNeeded$[ebp], 0
	jg	SHORT $LN20@ConnectCit
$LN19@ConnectCit:

; 413  : 	{
; 414  : 		return;

	jmp	$LN38@ConnectCit
$LN20@ConnectCit:

; 415  : 	}
; 416  : 
; 417  : 
; 418  : #ifdef AUI_WARNING_FIXES
; 419  : 	int sValue = -1;
; 420  : #else
; 421  : 	short sValue = -1;

	or	eax, -1
	mov	WORD PTR _sValue$[ebp], ax

; 422  : #endif
; 423  : #ifdef AUI_WORKER_FIX_CONNECT_CITIES_TO_CAPITOL_CONSIDER_MAINTENANCE_MODIFIERS
; 424  : #ifdef AUI_WORKER_INCA_HILLS
; 425  : 	int iTotalMaintenance = (iRoadLength - iFreeIncaRoadLength) * iMaintenancePerTile;
; 426  : #else
; 427  : 	int iTotalMaintenance = iRoadLength * iMaintenancePerTile;
; 428  : #endif
; 429  : 	// Player modifier
; 430  : 	iTotalMaintenance *= (100 + m_pPlayer->GetRouteGoldMaintenanceMod());
; 431  : 	iTotalMaintenance /= 100;
; 432  : 	// Handicap
; 433  : 	iTotalMaintenance *= m_pPlayer->getHandicapInfo().getRouteCostPercent();
; 434  : 	iTotalMaintenance /= 100;
; 435  : #ifdef AUI_WORKER_INCA_HILLS
; 436  : 	int iProfit = iGoldForRoute - iTotalMaintenance;
; 437  : #else
; 438  : 	int iProfit = iGoldForRoute - iTotalMaintenance;
; 439  : #endif
; 440  : #elif defined(AUI_WORKER_INCA_HILLS)
; 441  : 	int iProfit = iGoldForRoute - ((iRoadLength - iFreeIncaRoadLength) * iMaintenancePerTile);
; 442  : #else
; 443  : 	int iProfit = iGoldForRoute - (iRoadLength * iMaintenancePerTile);

	mov	ecx, DWORD PTR _iRoadLength$[ebp]
	imul	ecx, DWORD PTR _iMaintenancePerTile$[ebp]
	mov	edx, DWORD PTR _iGoldForRoute$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _iProfit$[ebp], edx

; 444  : #endif
; 445  : 	if(bIndustrialRoute)

	movzx	eax, BYTE PTR _bIndustrialRoute$[ebp]
	test	eax, eax
	je	SHORT $LN18@ConnectCit

; 446  : 	{
; 447  : 		if(iProfit >= 0)

	cmp	DWORD PTR _iProfit$[ebp], 0
	jl	SHORT $LN17@ConnectCit

; 448  : 		{
; 449  : #ifdef AUI_WARNING_FIXES
; 450  : 			sValue = MAX_INT;
; 451  : #else
; 452  : 			sValue = MAX_SHORT;

	mov	ecx, 32767				; 00007fffH
	mov	WORD PTR _sValue$[ebp], cx
	jmp	SHORT $LN16@ConnectCit
$LN17@ConnectCit:

; 453  : #endif
; 454  : 		}
; 455  : 		else if(m_pPlayer->calculateGoldRate() + iProfit >= 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?calculateGoldRate@CvPlayer@@QBEHXZ	; CvPlayer::calculateGoldRate
	add	eax, DWORD PTR _iProfit$[ebp]
	js	SHORT $LN15@ConnectCit

; 456  : 		{
; 457  : 			sValue = pTargetCity->getYieldRate(YIELD_PRODUCTION, false) * GC.getINDUSTRIAL_ROUTE_PRODUCTION_MOD();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6432
	mov	DWORD PTR $T220462[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR _pTargetCity$[ebp]
	call	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRate
	imul	eax, DWORD PTR $T220462[ebp]
	mov	WORD PTR _sValue$[ebp], ax

; 458  : 		}
; 459  : 		else

	jmp	SHORT $LN16@ConnectCit
$LN15@ConnectCit:

; 460  : 		{
; 461  : 			return;

	jmp	$LN38@ConnectCit
$LN16@ConnectCit:

; 462  : 		}

	jmp	$LN13@ConnectCit
$LN18@ConnectCit:

; 463  : 	}
; 464  : 	else if(bMajorMinorConnection)

	movzx	ecx, BYTE PTR _bMajorMinorConnection$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@ConnectCit

; 465  : 	{
; 466  : #ifdef AUI_WARNING_FIXES
; 467  : 		sValue = MIN(GC.getMINOR_CIV_ROUTE_QUEST_WEIGHT() / iPlotsNeeded, MAX_INT);
; 468  : #else
; 469  : 		sValue = min(GC.getMINOR_CIV_ROUTE_QUEST_WEIGHT() / iPlotsNeeded, MAX_SHORT);

	mov	DWORD PTR $T220344[ebp], 32767		; 00007fffH
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7840
	mov	DWORD PTR $T220466[ebp], edx
	mov	eax, DWORD PTR $T220466[ebp]
	cdq
	idiv	DWORD PTR _iPlotsNeeded$[ebp]
	mov	DWORD PTR $T220345[ebp], eax
	mov	eax, DWORD PTR $T220344[ebp]
	cmp	eax, DWORD PTR $T220345[ebp]
	jge	SHORT $LN97@ConnectCit
	lea	ecx, DWORD PTR $T220344[ebp]
	mov	DWORD PTR tv391[ebp], ecx
	jmp	SHORT $LN98@ConnectCit
$LN97@ConnectCit:
	lea	edx, DWORD PTR $T220345[ebp]
	mov	DWORD PTR tv391[ebp], edx
$LN98@ConnectCit:
	mov	eax, DWORD PTR tv391[ebp]
	mov	DWORD PTR $T220472[ebp], eax
	mov	ecx, DWORD PTR $T220472[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _sValue$[ebp], dx

; 470  : #endif
; 471  : 	}
; 472  : 	else // normal route

	jmp	SHORT $LN13@ConnectCit
$LN12@ConnectCit:

; 473  : 	{
; 474  : 		// is this route worth building?
; 475  : 		if(iProfit < 0)

	cmp	DWORD PTR _iProfit$[ebp], 0
	jge	SHORT $LN10@ConnectCit

; 476  : 		{
; 477  : 			return;

	jmp	$LN38@ConnectCit
$LN10@ConnectCit:

; 478  : 		}
; 479  : 
; 480  : #ifdef AUI_WORKER_FIX_CONNECT_CITIES_TO_CAPITOL_CONSIDER_MAINTENANCE_MODIFIERS
; 481  : 		int iValue = iGoldForRoute * 100 * iRoadLength;
; 482  : 		if (iTotalMaintenance + iRoadLength > iFreeIncaRoadLength)
; 483  : 			iValue /= (iTotalMaintenance + iRoadLength - iFreeIncaRoadLength);
; 484  : 		iValue /= iPlotsNeeded;
; 485  : #else
; 486  : 		int iValue = (iGoldForRoute * 100) / (iRoadLength * (iMaintenancePerTile + 1));

	mov	eax, DWORD PTR _iGoldForRoute$[ebp]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _iMaintenancePerTile$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _iRoadLength$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iValue$217324[ebp], eax

; 487  : #ifdef AUI_WORKER_INCA_HILLS
; 488  : 		iValue = (iValue * iRoadLength * (1 + iFreeIncaRoadLength * iMaintenancePerTile)) / iPlotsNeeded;
; 489  : #else
; 490  : 		iValue = (iValue * iRoadLength) / iPlotsNeeded;

	mov	eax, DWORD PTR _iValue$217324[ebp]
	imul	eax, DWORD PTR _iRoadLength$[ebp]
	cdq
	idiv	DWORD PTR _iPlotsNeeded$[ebp]
	mov	DWORD PTR _iValue$217324[ebp], eax

; 491  : #endif
; 492  : #endif
; 493  : #ifdef AUI_WARNING_FIXES
; 494  : 		sValue = MIN(iValue, MAX_INT);
; 495  : #else
; 496  : 		sValue = min(iValue, MAX_SHORT);

	mov	DWORD PTR $T220346[ebp], 32767		; 00007fffH
	mov	edx, DWORD PTR $T220346[ebp]
	cmp	edx, DWORD PTR _iValue$217324[ebp]
	jge	SHORT $LN101@ConnectCit
	lea	eax, DWORD PTR $T220346[ebp]
	mov	DWORD PTR tv239[ebp], eax
	jmp	SHORT $LN102@ConnectCit
$LN101@ConnectCit:
	lea	ecx, DWORD PTR _iValue$217324[ebp]
	mov	DWORD PTR tv239[ebp], ecx
$LN102@ConnectCit:
	mov	edx, DWORD PTR tv239[ebp]
	mov	DWORD PTR $T220481[ebp], edx
	mov	eax, DWORD PTR $T220481[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _sValue$[ebp], cx
$LN13@ConnectCit:

; 497  : #endif
; 498  : 	}
; 499  : 
; 500  : 	pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 501  : 	pNode = GC.GetBuildRouteFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	DWORD PTR $T220488[ebp], eax
	mov	edx, DWORD PTR $T220488[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pNode$[ebp], eax

; 502  : 
; 503  : 	int iGameTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T220492[ebp], ecx
	mov	ecx, DWORD PTR $T220492[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGameTurn$[ebp], eax
$LN9@ConnectCit:

; 504  : 
; 505  : 	while(pNode)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN38@ConnectCit

; 506  : 	{
; 507  : 		pPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220496[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR $T220516[ebp], ecx
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR $T220515[ebp], eax
	cmp	DWORD PTR $T220515[ebp], -2147483647	; 80000001H
	je	SHORT $LN109@ConnectCit
	cmp	DWORD PTR $T220516[ebp], -2147483647	; 80000001H
	jne	SHORT $LN110@ConnectCit
$LN109@ConnectCit:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	SHORT $LN111@ConnectCit
$LN110@ConnectCit:
	mov	ecx, DWORD PTR $T220496[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T220502[ebp], edx
	mov	eax, DWORD PTR $T220516[ebp]
	imul	eax, DWORD PTR $T220502[ebp]
	add	eax, DWORD PTR $T220515[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T220496[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pPlot$[ebp], eax
$LN111@ConnectCit:

; 508  : 		pNode = pNode->m_pParent;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pNode$[ebp], eax

; 509  : 
; 510  : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN7@ConnectCit

; 511  : 		{
; 512  : 			break;

	jmp	$LN38@ConnectCit
$LN7@ConnectCit:

; 513  : 		}
; 514  : 
; 515  : 		if(pPlot->getRouteType() == eRoute && !pPlot->IsRoutePillaged())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, DWORD PTR _eRoute$[ebp]
	jne	SHORT $LN6@ConnectCit
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN6@ConnectCit

; 516  : 		{
; 517  : 			continue;

	jmp	$LN9@ConnectCit
$LN6@ConnectCit:

; 518  : 		}
; 519  : 
; 520  : 		// if we already know about this plot, continue on
; 521  : 		if(pPlot->GetBuilderAIScratchPadTurn() == iGameTurn && pPlot->GetBuilderAIScratchPadPlayer() == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	movsx	edx, ax
	cmp	edx, DWORD PTR _iGameTurn$[ebp]
	jne	SHORT $LN5@ConnectCit
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T220525[ebp], edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, DWORD PTR $T220525[ebp]
	jne	SHORT $LN5@ConnectCit

; 522  : 		{
; 523  : 			if(sValue > pPlot->GetBuilderAIScratchPadValue())

	movsx	esi, WORD PTR _sValue$[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadValue
	cwde
	cmp	esi, eax
	jle	SHORT $LN4@ConnectCit

; 524  : 			{
; 525  : 				pPlot->SetBuilderAIScratchPadValue(sValue);

	movzx	ecx, WORD PTR _sValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadValue

; 526  : 				pPlot->SetBuilderAIScratchPadRoute(eRoute);

	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute
$LN4@ConnectCit:

; 527  : 			}
; 528  : 			continue;

	jmp	$LN9@ConnectCit
$LN5@ConnectCit:

; 529  : 		}
; 530  : 
; 531  : 		// mark nodes and reset values
; 532  : 		pPlot->SetBuilderAIScratchPadTurn(iGameTurn);

	movzx	eax, WORD PTR _iGameTurn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadTurn

; 533  : 		pPlot->SetBuilderAIScratchPadPlayer(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T220534[ebp], eax
	mov	ecx, DWORD PTR $T220534[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetBuilderAIScratchPadPlayer

; 534  : 		pPlot->SetBuilderAIScratchPadValue(sValue);

	movzx	edx, WORD PTR _sValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadValue

; 535  : 		pPlot->SetBuilderAIScratchPadRoute(eRoute);

	mov	eax, DWORD PTR _eRoute$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute

; 536  : 
; 537  : 		// add nodes that are not in territory to extra list
; 538  : 		// minors should not build out of their borders when they are doing a major/minor connection, only when connecting their two cities
; 539  : 		if(!(m_pPlayer->isMinorCiv() && bMajorMinorConnection))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ConnectCit
	movzx	eax, BYTE PTR _bMajorMinorConnection$[ebp]
	test	eax, eax
	jne	$LN3@ConnectCit
$LN2@ConnectCit:

; 540  : 		{
; 541  : 			if(pPlot->getOwner() != m_pPlayer->GetID())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR $T220538[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T220547[ebp], edx
	mov	eax, DWORD PTR $T220538[ebp]
	cmp	eax, DWORD PTR $T220547[ebp]
	je	SHORT $LN3@ConnectCit

; 542  : 			{
; 543  : 				m_aiNonTerritoryPlots.push_back(GC.getMap().plotNum(pPlot->getX(), pPlot->getY()));

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T220551[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T220555[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220559[ebp], edx
	mov	eax, DWORD PTR $T220559[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T220564[ebp], ecx
	mov	edx, DWORD PTR $T220551[ebp]
	imul	edx, DWORD PTR $T220564[ebp]
	add	edx, DWORD PTR $T220555[ebp]
	mov	DWORD PTR $T220347[ebp], edx
	lea	eax, DWORD PTR $T220347[ebp]
	push	eax
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back
$LN3@ConnectCit:

; 544  : 			}
; 545  : 		}
; 546  : 	}

	jmp	$LN9@ConnectCit
$LN38@ConnectCit:

; 547  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ENDP ; CvBuilderTaskingAI::ConnectCitiesToCapital
_TEXT	ENDS
PUBLIC	?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesForScenario
EXTRN	?IsCityConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@0W4RouteTypes@@_N@Z:PROC ; CvPlayer::IsCityConnectedToCity
; Function compile flags: /Odtp
;	COMDAT ?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z
_TEXT	SEGMENT
_this$ = -168						; size = 4
$T220744 = -124						; size = 4
$T220739 = -120						; size = 4
$T220735 = -116						; size = 4
$T220731 = -112						; size = 4
$T220727 = -108						; size = 4
$T220718 = -104						; size = 4
$T220714 = -100						; size = 4
$T220705 = -96						; size = 4
$T220696 = -92						; size = 4
$T220695 = -88						; size = 4
$T220682 = -84						; size = 4
$T220676 = -80						; size = 4
$T220672 = -76						; size = 4
$T220668 = -72						; size = 4
$T220664 = -68						; size = 4
$T220663 = -64						; size = 4
$T220659 = -60						; size = 4
$T220658 = -56						; size = 4
$T220654 = -52						; size = 4
$T220653 = -48						; size = 4
$T220649 = -44						; size = 4
$T220648 = -40						; size = 4
$T220636 = -36						; size = 4
$T220627 = -32						; size = 4
$T220618 = -28						; size = 4
_pPlot$ = -24						; size = 4
_pNode$ = -20						; size = 4
_iGameTurn$ = -16					; size = 4
_iRouteValue$ = -12					; size = 4
_iPathfinderFlags$ = -8					; size = 4
_bFoundPath$ = -1					; size = 1
_pCity1$ = 8						; size = 4
_pCity2$ = 12						; size = 4
_eRoute$ = 16						; size = 4
?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z PROC ; CvBuilderTaskingAI::ConnectCitiesForScenario, COMDAT
; _this$ = ecx

; 550  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	DWORD PTR _this$[ebp], ecx

; 551  : 	// don't connect cities from different owners
; 552  : 	if(pCity1->getOwner() != pCity2->getOwner())

	mov	eax, DWORD PTR _pCity1$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T220627[ebp], ecx
	mov	edx, DWORD PTR _pCity2$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T220636[ebp], eax
	mov	ecx, DWORD PTR $T220627[ebp]
	cmp	ecx, DWORD PTR $T220636[ebp]
	je	SHORT $LN9@ConnectCit@2

; 553  : 	{
; 554  : 		return;

	jmp	$LN10@ConnectCit@2
$LN9@ConnectCit@2:

; 555  : 	}
; 556  : 
; 557  : 	// if we already have a connection, bail out
; 558  : 	if (m_pPlayer->IsCityConnectedToCity(pCity1, pCity2, eRoute, true))

	push	1
	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCity2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCity1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?IsCityConnectedToCity@CvPlayer@@QAE_NPAVCvCity@@0W4RouteTypes@@_N@Z ; CvPlayer::IsCityConnectedToCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@ConnectCit@2

; 559  : 	{
; 560  : 		return;

	jmp	$LN10@ConnectCit@2

; 561  : 	}
; 562  : 
; 563  : 	// build a path between the two cities
; 564  : 	int iPathfinderFlags = m_pPlayer->GetID();

$LN22@ConnectCit@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _iPathfinderFlags$[ebp], eax

; 565  : 	int iRouteValue = eRoute + 1;

	mov	ecx, DWORD PTR _eRoute$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRouteValue$[ebp], ecx

; 566  : 	// assuming that there are fewer than 256 players
; 567  : 	iPathfinderFlags |= (iRouteValue << 8);

	mov	edx, DWORD PTR _iRouteValue$[ebp]
	shl	edx, 8
	or	edx, DWORD PTR _iPathfinderFlags$[ebp]
	mov	DWORD PTR _iPathfinderFlags$[ebp], edx

; 568  : 	bool bFoundPath = GC.GetBuildRouteFinder().GeneratePath(pCity1->plot()->getX(), pCity1->plot()->getY(), pCity2->plot()->getX(), pCity2->plot()->getY(), iPathfinderFlags);

	mov	ecx, DWORD PTR _pCity2$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220648[ebp], eax
	mov	eax, DWORD PTR $T220648[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T220649[ebp], ecx
	mov	ecx, DWORD PTR _pCity2$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220653[ebp], eax
	mov	edx, DWORD PTR $T220653[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T220654[ebp], eax
	mov	ecx, DWORD PTR _pCity1$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220658[ebp], eax
	mov	ecx, DWORD PTR $T220658[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T220659[ebp], edx
	mov	ecx, DWORD PTR _pCity1$[ebp]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR $T220663[ebp], eax
	mov	eax, DWORD PTR $T220663[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T220664[ebp], ecx
	push	0
	mov	edx, DWORD PTR _iPathfinderFlags$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220649[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220654[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220659[ebp]
	push	edx
	mov	eax, DWORD PTR $T220664[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	mov	BYTE PTR _bFoundPath$[ebp], al

; 569  : 
; 570  : 	//  if no path, then bail!
; 571  : 	if(!bFoundPath)

	movzx	ecx, BYTE PTR _bFoundPath$[ebp]
	test	ecx, ecx
	jne	SHORT $LN7@ConnectCit@2

; 572  : 	{
; 573  : 		return;

	jmp	$LN10@ConnectCit@2
$LN7@ConnectCit@2:

; 574  : 	}
; 575  : 
; 576  : 	CvPlot* pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 577  : 	CvAStarNode* pNode = GC.GetBuildRouteFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	DWORD PTR $T220668[ebp], eax
	mov	edx, DWORD PTR $T220668[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR _pNode$[ebp], eax

; 578  : 	int iGameTurn = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T220672[ebp], ecx
	mov	ecx, DWORD PTR $T220672[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR _iGameTurn$[ebp], eax
$LN6@ConnectCit@2:

; 579  : 
; 580  : 	while(pNode)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	$LN10@ConnectCit@2

; 581  : 	{
; 582  : 		pPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220676[ebp], edx
	mov	eax, DWORD PTR _pNode$[ebp]
	movsx	ecx, WORD PTR [eax+82]
	mov	DWORD PTR $T220696[ebp], ecx
	mov	edx, DWORD PTR _pNode$[ebp]
	movsx	eax, WORD PTR [edx+80]
	mov	DWORD PTR $T220695[ebp], eax
	cmp	DWORD PTR $T220695[ebp], -2147483647	; 80000001H
	je	SHORT $LN38@ConnectCit@2
	cmp	DWORD PTR $T220696[ebp], -2147483647	; 80000001H
	jne	SHORT $LN39@ConnectCit@2
$LN38@ConnectCit@2:
	mov	DWORD PTR _pPlot$[ebp], 0
	jmp	SHORT $LN40@ConnectCit@2
$LN39@ConnectCit@2:
	mov	ecx, DWORD PTR $T220676[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T220682[ebp], edx
	mov	eax, DWORD PTR $T220696[ebp]
	imul	eax, DWORD PTR $T220682[ebp]
	add	eax, DWORD PTR $T220695[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T220676[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pPlot$[ebp], eax
$LN40@ConnectCit@2:

; 583  : 		pNode = pNode->m_pParent;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pNode$[ebp], eax

; 584  : 
; 585  : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN4@ConnectCit@2

; 586  : 		{
; 587  : 			break;

	jmp	$LN10@ConnectCit@2
$LN4@ConnectCit@2:

; 588  : 		}
; 589  : 
; 590  : 		if(pPlot->getRouteType() == eRoute && !pPlot->IsRoutePillaged())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, DWORD PTR _eRoute$[ebp]
	jne	SHORT $LN3@ConnectCit@2
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@ConnectCit@2

; 591  : 		{
; 592  : 			continue;

	jmp	$LN6@ConnectCit@2
$LN3@ConnectCit@2:

; 593  : 		}
; 594  : 
; 595  : 		// if we already know about this plot, continue on
; 596  : 		if(pPlot->GetBuilderAIScratchPadTurn() == iGameTurn && pPlot->GetBuilderAIScratchPadPlayer() == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	movsx	edx, ax
	cmp	edx, DWORD PTR _iGameTurn$[ebp]
	jne	SHORT $LN2@ConnectCit@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T220705[ebp], edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, DWORD PTR $T220705[ebp]
	jne	SHORT $LN2@ConnectCit@2

; 597  : 		{
; 598  : 			continue;

	jmp	$LN6@ConnectCit@2
$LN2@ConnectCit@2:

; 599  : 		}
; 600  : 
; 601  : 		// mark nodes and reset values
; 602  : 		pPlot->SetBuilderAIScratchPadTurn(iGameTurn);

	movzx	eax, WORD PTR _iGameTurn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadTurn@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadTurn

; 603  : 		pPlot->SetBuilderAIScratchPadPlayer(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T220714[ebp], eax
	mov	ecx, DWORD PTR $T220714[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadPlayer@CvPlot@@QAEXW4PlayerTypes@@@Z ; CvPlot::SetBuilderAIScratchPadPlayer

; 604  : 		pPlot->SetBuilderAIScratchPadValue(1000);

	push	1000					; 000003e8H
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadValue@CvPlot@@QAEXF@Z ; CvPlot::SetBuilderAIScratchPadValue

; 605  : 		pPlot->SetBuilderAIScratchPadRoute(eRoute);

	mov	edx, DWORD PTR _eRoute$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?SetBuilderAIScratchPadRoute@CvPlot@@QAEXW4RouteTypes@@@Z ; CvPlot::SetBuilderAIScratchPadRoute

; 606  : 
; 607  : 		// add nodes that are not in territory to extra list
; 608  : 		if(pPlot->getOwner() != m_pPlayer->GetID())

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T220718[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T220727[ebp], ecx
	mov	edx, DWORD PTR $T220718[ebp]
	cmp	edx, DWORD PTR $T220727[ebp]
	je	SHORT $LN1@ConnectCit@2

; 609  : 		{
; 610  : 			m_aiNonTerritoryPlots.push_back(GC.getMap().plotNum(pPlot->getX(), pPlot->getY()));

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T220731[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T220735[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220739[ebp], ecx
	mov	edx, DWORD PTR $T220739[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T220744[ebp], eax
	mov	ecx, DWORD PTR $T220731[ebp]
	imul	ecx, DWORD PTR $T220744[ebp]
	add	ecx, DWORD PTR $T220735[ebp]
	mov	DWORD PTR $T220618[ebp], ecx
	lea	edx, DWORD PTR $T220618[ebp]
	push	edx
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,64,1,297,0>::push_back
$LN1@ConnectCit@2:

; 611  : 		}
; 612  : 	}

	jmp	$LN6@ConnectCit@2
$LN10@ConnectCit@2:

; 613  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ENDP ; CvBuilderTaskingAI::ConnectCitiesForScenario
_TEXT	ENDS
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z:PROC ; CvCityConnections::GetCityFromIndex
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?getRoute@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getRoute
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z:PROC ; CvPlayer::getBestRoute
EXTRN	?GetNumConnectableCities@CvCityConnections@@QAEIXZ:PROC ; CvCityConnections::GetNumConnectableCities
EXTRN	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ:PROC ; CvPlayer::GetCityConnections
; Function compile flags: /Odtp
;	COMDAT ?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T220857 = -104						; size = 4
$T220848 = -100						; size = 4
$T220839 = -96						; size = 4
$T220835 = -92						; size = 4
$T220831 = -88						; size = 4
$T220827 = -84						; size = 4
$T220823 = -80						; size = 4
$T220822 = -76						; size = 4
_i$220809 = -72						; size = 4
_bConnectOnlyCapitals$217406 = -65			; size = 1
_pFirstCity$217400 = -64				; size = 4
_pPlayerCapitalCity$217402 = -60			; size = 4
_pTargetCity$217403 = -56				; size = 4
_pSecondCity$217401 = -52				; size = 4
_uiSecondCityIndex$217396 = -48				; size = 4
_uiFirstCityIndex$217392 = -44				; size = 4
_bHasTech$217389 = -37					; size = 1
_pkBuild$217383 = -36					; size = 4
_eRoute$217385 = -32					; size = 4
_eBuild$217381 = -28					; size = 4
_i$217377 = -24						; size = 4
_pBuilder$ = -20					; size = 4
_eBestRoute$ = -16					; size = 4
_iLoopUnit$ = -12					; size = 4
_pLoopUnit$ = -8					; size = 4
_pCityConnections$ = -4					; size = 4
?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ PROC	; CvBuilderTaskingAI::UpdateRoutePlots, COMDAT
; _this$ = ecx

; 617  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 618  : 	m_aiNonTerritoryPlots.clear();

	xor	eax, eax
	je	SHORT $LN36@UpdateRout
	mov	DWORD PTR _i$220809[ebp], 0
	jmp	SHORT $LN34@UpdateRout
$LN33@UpdateRout:
	mov	ecx, DWORD PTR _i$220809[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$220809[ebp], ecx
$LN34@UpdateRout:
	mov	edx, DWORD PTR _i$220809[ebp]
	cmp	edx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	jae	SHORT $LN36@UpdateRout
	jmp	SHORT $LN33@UpdateRout
$LN36@UpdateRout:
	mov	DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4, 0

; 619  : 
; 620  : 	// if there are fewer than 2 cities, we don't need to run this function
; 621  : 	if(m_pPlayer->GetCityConnections()->GetNumConnectableCities() < 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	ecx, eax
	call	?GetNumConnectableCities@CvCityConnections@@QAEIXZ ; CvCityConnections::GetNumConnectableCities
	cmp	eax, 2
	jae	SHORT $LN27@UpdateRout

; 622  : 	{
; 623  : 		return;

	jmp	$LN28@UpdateRout
$LN27@UpdateRout:

; 624  : 	}
; 625  : 
; 626  : 	RouteTypes eBestRoute = m_pPlayer->getBestRoute();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	mov	DWORD PTR _eBestRoute$[ebp], eax

; 627  : 	if(eBestRoute == NO_ROUTE)

	cmp	DWORD PTR _eBestRoute$[ebp], -1
	jne	SHORT $LN26@UpdateRout

; 628  : 	{
; 629  : 		return;

	jmp	$LN28@UpdateRout
$LN26@UpdateRout:

; 630  : 	}
; 631  : 
; 632  : 	// find a builder, if I don't have a builder, bail!
; 633  : 	CvUnit* pBuilder = NULL;

	mov	DWORD PTR _pBuilder$[ebp], 0

; 634  : 	CvUnit* pLoopUnit;
; 635  : 	int iLoopUnit;
; 636  : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	edx, DWORD PTR _iLoopUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN25@UpdateRout
$LN24@UpdateRout:
	push	0
	lea	ecx, DWORD PTR _iLoopUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN25@UpdateRout:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN23@UpdateRout

; 637  : 	{
; 638  : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	jne	SHORT $LN22@UpdateRout

; 639  : 		{
; 640  : 			pBuilder = pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR _pBuilder$[ebp], eax

; 641  : 			break;

	jmp	SHORT $LN23@UpdateRout
$LN22@UpdateRout:

; 642  : 		}
; 643  : 	}

	jmp	SHORT $LN24@UpdateRout
$LN23@UpdateRout:

; 644  : 
; 645  : 	// If there's no builder, bail!
; 646  : 	if(!pBuilder)

	cmp	DWORD PTR _pBuilder$[ebp], 0
	jne	SHORT $LN21@UpdateRout

; 647  : 	{
; 648  : 		return;

	jmp	$LN28@UpdateRout
$LN21@UpdateRout:

; 649  : 	}
; 650  : 
; 651  : 	// updating plots that are part of the road network
; 652  : 	CvCityConnections* pCityConnections = m_pPlayer->GetCityConnections();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetCityConnections@CvPlayer@@QBEPAVCvCityConnections@@XZ ; CvPlayer::GetCityConnections
	mov	DWORD PTR _pCityConnections$[ebp], eax

; 653  : 
; 654  : #ifdef AUI_WARNING_FIXES
; 655  : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 656  : #else
; 657  : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	DWORD PTR _i$217377[ebp], 0
	jmp	SHORT $LN20@UpdateRout
$LN19@UpdateRout:
	mov	edx, DWORD PTR _i$217377[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217377[ebp], edx
$LN20@UpdateRout:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _i$217377[ebp], eax
	jge	$LN28@UpdateRout

; 658  : #endif
; 659  : 	{
; 660  : 		BuildTypes eBuild = (BuildTypes)i;

	mov	eax, DWORD PTR _i$217377[ebp]
	mov	DWORD PTR _eBuild$217381[ebp], eax

; 661  : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	ecx, DWORD PTR _eBuild$217381[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217383[ebp], eax

; 662  : 		if(!pkBuild)

	cmp	DWORD PTR _pkBuild$217383[ebp], 0
	jne	SHORT $LN17@UpdateRout

; 663  : 		{
; 664  : 			continue;

	jmp	SHORT $LN19@UpdateRout
$LN17@UpdateRout:

; 665  : 		}
; 666  : 
; 667  : 		RouteTypes eRoute = (RouteTypes)pkBuild->getRoute();

	mov	ecx, DWORD PTR _pkBuild$217383[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	mov	DWORD PTR _eRoute$217385[ebp], eax

; 668  : 		if(eRoute == NO_ROUTE)

	cmp	DWORD PTR _eRoute$217385[ebp], -1
	jne	SHORT $LN16@UpdateRout

; 669  : 		{
; 670  : 			continue;

	jmp	SHORT $LN19@UpdateRout
$LN16@UpdateRout:

; 671  : 		}
; 672  : 
; 673  : 		if(GC.getBuildInfo(eBuild)->getTechPrereq() != NO_TECH)

	mov	edx, DWORD PTR _eBuild$217381[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	cmp	eax, -1
	je	SHORT $LN15@UpdateRout

; 674  : 		{
; 675  : 			bool bHasTech = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T220822[ebp], ecx
	mov	edx, DWORD PTR $T220822[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T220823[ebp], eax
	mov	ecx, DWORD PTR $T220823[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T220827[ebp], ecx
	mov	edx, DWORD PTR _eBuild$217381[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	push	eax
	mov	ecx, DWORD PTR $T220827[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	mov	BYTE PTR _bHasTech$217389[ebp], al

; 676  : 			if(!bHasTech)

	movzx	eax, BYTE PTR _bHasTech$217389[ebp]
	test	eax, eax
	jne	SHORT $LN15@UpdateRout

; 677  : 			{
; 678  : 				continue;

	jmp	$LN19@UpdateRout
$LN15@UpdateRout:

; 679  : 			}
; 680  : 		}
; 681  : 
; 682  : 		for(uint uiFirstCityIndex = 0; uiFirstCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiFirstCityIndex++)

	mov	DWORD PTR _uiFirstCityIndex$217392[ebp], 0
	jmp	SHORT $LN13@UpdateRout
$LN12@UpdateRout:
	mov	ecx, DWORD PTR _uiFirstCityIndex$217392[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiFirstCityIndex$217392[ebp], ecx
$LN13@UpdateRout:
	mov	edx, DWORD PTR _pCityConnections$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T220831[ebp], eax
	mov	ecx, DWORD PTR _uiFirstCityIndex$217392[ebp]
	cmp	ecx, DWORD PTR $T220831[ebp]
	jae	$LN11@UpdateRout

; 683  : 		{
; 684  : 			for(uint uiSecondCityIndex = uiFirstCityIndex + 1; uiSecondCityIndex < pCityConnections->m_aiCityPlotIDs.size(); uiSecondCityIndex++)

	mov	edx, DWORD PTR _uiFirstCityIndex$217392[ebp]
	add	edx, 1
	mov	DWORD PTR _uiSecondCityIndex$217396[ebp], edx
	jmp	SHORT $LN10@UpdateRout
$LN9@UpdateRout:
	mov	eax, DWORD PTR _uiSecondCityIndex$217396[ebp]
	add	eax, 1
	mov	DWORD PTR _uiSecondCityIndex$217396[ebp], eax
$LN10@UpdateRout:
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T220835[ebp], edx
	mov	eax, DWORD PTR _uiSecondCityIndex$217396[ebp]
	cmp	eax, DWORD PTR $T220835[ebp]
	jae	$LN8@UpdateRout

; 685  : 			{
; 686  : 				// get the two cities
; 687  : 				CvCity* pFirstCity  = pCityConnections->GetCityFromIndex(uiFirstCityIndex);

	mov	ecx, DWORD PTR _uiFirstCityIndex$217392[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
	mov	DWORD PTR _pFirstCity$217400[ebp], eax

; 688  : 				CvCity* pSecondCity = pCityConnections->GetCityFromIndex(uiSecondCityIndex);

	mov	edx, DWORD PTR _uiSecondCityIndex$217396[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCityConnections$[ebp]
	call	?GetCityFromIndex@CvCityConnections@@QAEPAVCvCity@@H@Z ; CvCityConnections::GetCityFromIndex
	mov	DWORD PTR _pSecondCity$217401[ebp], eax

; 689  : 				CvCity* pPlayerCapitalCity = NULL;

	mov	DWORD PTR _pPlayerCapitalCity$217402[ebp], 0

; 690  : 				CvCity* pTargetCity = NULL;

	mov	DWORD PTR _pTargetCity$217403[ebp], 0

; 691  : 
; 692  : 				if(!pFirstCity || !pSecondCity)

	cmp	DWORD PTR _pFirstCity$217400[ebp], 0
	je	SHORT $LN6@UpdateRout
	cmp	DWORD PTR _pSecondCity$217401[ebp], 0
	jne	SHORT $LN7@UpdateRout
$LN6@UpdateRout:

; 693  : 				{
; 694  : 					continue;

	jmp	SHORT $LN9@UpdateRout
$LN7@UpdateRout:

; 695  : 				}
; 696  : 
; 697  : 				bool bConnectOnlyCapitals = (bool)GC.getCITY_CONNECTIONS_CONNECT_TO_CAPITAL();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8188
	mov	DWORD PTR $T220839[ebp], eax
	cmp	DWORD PTR $T220839[ebp], 0
	setne	cl
	mov	BYTE PTR _bConnectOnlyCapitals$217406[ebp], cl

; 698  : 				if (bConnectOnlyCapitals)

	movzx	edx, BYTE PTR _bConnectOnlyCapitals$217406[ebp]
	test	edx, edx
	je	SHORT $LN5@UpdateRout

; 699  : 				{
; 700  : 					// only need to build roads to the capital
; 701  : 					if(!pFirstCity->isCapital() && !pSecondCity->isCapital())

	mov	ecx, DWORD PTR _pFirstCity$217400[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@UpdateRout
	mov	ecx, DWORD PTR _pSecondCity$217401[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@UpdateRout

; 702  : 					{
; 703  : 						continue;

	jmp	$LN9@UpdateRout
$LN4@UpdateRout:

; 704  : 					}
; 705  : 
; 706  : 					if(pFirstCity->isCapital() && pFirstCity->getOwner() == m_pPlayer->GetID())

	mov	ecx, DWORD PTR _pFirstCity$217400[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@UpdateRout
	mov	eax, DWORD PTR _pFirstCity$217400[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR $T220848[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T220857[ebp], ecx
	mov	edx, DWORD PTR $T220848[ebp]
	cmp	edx, DWORD PTR $T220857[ebp]
	jne	SHORT $LN3@UpdateRout

; 707  : 					{
; 708  : 						pPlayerCapitalCity = pFirstCity;

	mov	eax, DWORD PTR _pFirstCity$217400[ebp]
	mov	DWORD PTR _pPlayerCapitalCity$217402[ebp], eax

; 709  : 						pTargetCity = pSecondCity;

	mov	ecx, DWORD PTR _pSecondCity$217401[ebp]
	mov	DWORD PTR _pTargetCity$217403[ebp], ecx

; 710  : 					}
; 711  : 					else

	jmp	SHORT $LN2@UpdateRout
$LN3@UpdateRout:

; 712  : 					{
; 713  : 						pPlayerCapitalCity = pSecondCity;

	mov	edx, DWORD PTR _pSecondCity$217401[ebp]
	mov	DWORD PTR _pPlayerCapitalCity$217402[ebp], edx

; 714  : 						pTargetCity = pFirstCity;

	mov	eax, DWORD PTR _pFirstCity$217400[ebp]
	mov	DWORD PTR _pTargetCity$217403[ebp], eax
$LN2@UpdateRout:

; 715  : 					}
; 716  : 					ConnectCitiesToCapital(pPlayerCapitalCity, pTargetCity, eRoute);

	mov	ecx, DWORD PTR _eRoute$217385[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTargetCity$217403[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayerCapitalCity$217402[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConnectCitiesToCapital@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesToCapital

; 717  : 				}
; 718  : 				else

	jmp	SHORT $LN1@UpdateRout
$LN5@UpdateRout:

; 719  : 				{
; 720  : 					ConnectCitiesForScenario(pFirstCity, pSecondCity, eBestRoute);

	mov	ecx, DWORD PTR _eBestRoute$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pSecondCity$217401[ebp]
	push	edx
	mov	eax, DWORD PTR _pFirstCity$217400[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConnectCitiesForScenario@CvBuilderTaskingAI@@IAEXPAVCvCity@@0W4RouteTypes@@@Z ; CvBuilderTaskingAI::ConnectCitiesForScenario
$LN1@UpdateRout:

; 721  : 				}
; 722  : 			}

	jmp	$LN9@UpdateRout
$LN8@UpdateRout:

; 723  : 		}

	jmp	$LN12@UpdateRout
$LN11@UpdateRout:

; 724  : 	}

	jmp	$LN19@UpdateRout
$LN28@UpdateRout:

; 725  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateRoutePlots@CvBuilderTaskingAI@@QAEXXZ ENDP	; CvBuilderTaskingAI::UpdateRoutePlots
_TEXT	ENDS
PUBLIC	?CorrectWeight@@YAHH@Z				; CorrectWeight
; Function compile flags: /Odtp
;	COMDAT ?CorrectWeight@@YAHH@Z
_TEXT	SEGMENT
_iWeight$ = 8						; size = 4
?CorrectWeight@@YAHH@Z PROC				; CorrectWeight, COMDAT

; 728  : {

	push	ebp
	mov	ebp, esp

; 729  : 	if(iWeight < -1000)

	cmp	DWORD PTR _iWeight$[ebp], -1000		; fffffc18H
	jge	SHORT $LN2@CorrectWei

; 730  : 	{
; 731  : 		return MAX_INT;

	mov	eax, 2147483647				; 7fffffffH
	jmp	SHORT $LN3@CorrectWei

; 732  : 	}
; 733  : 	else

	jmp	SHORT $LN3@CorrectWei
$LN2@CorrectWei:

; 734  : 	{
; 735  : 		return iWeight;

	mov	eax, DWORD PTR _iWeight$[ebp]
$LN3@CorrectWei:

; 736  : 	}
; 737  : }

	pop	ebp
	ret	0
?CorrectWeight@@YAHH@Z ENDP				; CorrectWeight
_TEXT	ENDS
PUBLIC	?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ; CvBuilderTaskingAI::LogDirective
PUBLIC	?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z ; CvBuilderTaskingAI::LogDirectives
PUBLIC	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
PUBLIC	??_C@_0CO@EDMNELMA@x?3?5?$CFd?5y?3?5?$CFd?0?5Evaluating?5out?5of?5t@ ; `string'
PUBLIC	??_C@_0FM@LMGJIHMD@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@ ; `string'
PUBLIC	?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddScrubFalloutDirectives
PUBLIC	?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddChopDirectives
PUBLIC	?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingPlotsDirectives
PUBLIC	?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingResourcesDirectives
PUBLIC	?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRouteDirectives
PUBLIC	?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ; CvBuilderTaskingAI::UpdateCurrentPlotYields
PUBLIC	??_C@_0DK@KAPAIHN@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@ ; `string'
PUBLIC	?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::FindTurnsAway
PUBLIC	?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
PUBLIC	??_C@_0BB@JIJICDOP@end?5of?5plot?5list?$AA@	; `string'
PUBLIC	??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<int,14592,1,297,0>::operator=
PUBLIC	?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,14592,1,297,0>::push_back
PUBLIC	__$ArrayPad$
PUBLIC	?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z ; CvBuilderTaskingAI::EvaluateBuilder
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ:PROC ; CvUnit::getBuildType
;	COMDAT ??_C@_0CO@EDMNELMA@x?3?5?$CFd?5y?3?5?$CFd?0?5Evaluating?5out?5of?5t@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0CO@EDMNELMA@x?3?5?$CFd?5y?3?5?$CFd?0?5Evaluating?5out?5of?5t@ DB 'x'
	DB	': %d y: %d, Evaluating out of territory plot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@LMGJIHMD@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@
CONST	SEGMENT
??_C@_0FM@LMGJIHMD@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@ DB 'u'
	DB	'nitx: %d unity: %d, plotx: %d ploty: %d, Evaluating out of te'
	DB	'rritory plot, can''t find path', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KAPAIHN@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@
CONST	SEGMENT
??_C@_0DK@KAPAIHN@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@ DB 'u'
	DB	'nitx: %d unity: %d, plotx: %d ploty: %d, can''t find path', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JIJICDOP@end?5of?5plot?5list?$AA@
CONST	SEGMENT
??_C@_0BB@JIJICDOP@end?5of?5plot?5list?$AA@ DB 'end of plot list', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$6
__ehfuncinfo$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
_TEXT	SEGMENT
tv487 = -552						; size = 4
tv486 = -548						; size = 4
tv859 = -544						; size = 4
tv874 = -540						; size = 4
tv480 = -536						; size = 4
tv475 = -532						; size = 4
tv694 = -528						; size = 4
tv470 = -524						; size = 4
tv652 = -520						; size = 4
tv465 = -516						; size = 4
tv594 = -512						; size = 4
_this$ = -508						; size = 4
$T221390 = -504						; size = 4
_elem$221373 = -500					; size = 24
_elem$221356 = -476					; size = 24
$T221335 = -452						; size = 4
$T221325 = -448						; size = 4
$T221324 = -444						; size = 4
$T221279 = -440						; size = 4
$T221266 = -436						; size = 4
$T221262 = -432						; size = 4
$T221248 = -428						; size = 4
$T221244 = -421						; size = 1
$T221233 = -420						; size = 4
$T221229 = -413						; size = 1
_iMapY$221323 = -412					; size = 4
_iMapX$221322 = -408					; size = 4
$T221222 = -404						; size = 4
$T221218 = -400						; size = 4
$T221209 = -396						; size = 4
$T221196 = -392						; size = 4
$T221178 = -388						; size = 4
$T221140 = -352						; size = 4
$T221131 = -348						; size = 4
$T221123 = -344						; size = 4
$T221111 = -340						; size = 4
$T221106 = -336						; size = 4
$T221097 = -332						; size = 4
$T221088 = -328						; size = 4
$T221084 = -324						; size = 4
$T221076 = -320						; size = 4
$T221069 = -316						; size = 4
$T221062 = -312						; size = 4
$T221058 = -308						; size = 4
$T221054 = -304						; size = 4
$T221046 = -300						; size = 4
$T221041 = -296						; size = 4
$T221032 = -292						; size = 4
$T221023 = -288						; size = 4
$T221019 = -284						; size = 4
$T221011 = -280						; size = 4
$T221004 = -276						; size = 4
$T220997 = -272						; size = 4
$T220993 = -268						; size = 4
$T220985 = -264						; size = 4
$T220969 = -260						; size = 4
$T220957 = -252						; size = 4
$T220948 = -248						; size = 4
$T220944 = -244						; size = 4
_i$220939 = -240					; size = 4
$T220925 = -236						; size = 4
$T220916 = -232						; size = 4
_i$220903 = -228					; size = 4
$T220868 = -224						; size = 4
$T220867 = -220						; size = 4
$T220866 = -216						; size = 4
$T220865 = -212						; size = 4
$T220864 = -208						; size = 4
$T220863 = -204						; size = 4
_iWeight$217486 = -200					; size = 4
_pTarget$217480 = -196					; size = 4
_directive$217488 = -192				; size = 20
_i$217476 = -172					; size = 4
_strLog$217471 = -168					; size = 28
_strLog$217467 = -140					; size = 28
_pPlot$217459 = -112					; size = 4
_iMoveTurnsAway$217464 = -108				; size = 4
_ui$217455 = -104					; size = 4
_strLog$217451 = -100					; size = 28
_strLog$217443 = -72					; size = 28
__$ArrayPad$ = -44					; size = 4
_pPlot$217446 = -40					; size = 4
_iMoveTurnsAway$217448 = -36				; size = 4
_uiPlotIndex$217437 = -32				; size = 4
_eOwner$217433 = -28					; size = 4
_ui$217427 = -24					; size = 4
_iBestWeight$ = -20					; size = 4
_iAssignIndex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_paDirectives$ = 12					; size = 4
_uaDirectives$ = 16					; size = 4
_bOnlyKeepBest$ = 20					; size = 1
_bOnlyEvaluateWorkersPlot$ = 24				; size = 1
?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z PROC ; CvBuilderTaskingAI::EvaluateBuilder, COMDAT
; _this$ = ecx

; 741  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 540				; 0000021cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 742  : 	// number of cities has changed mid-turn, so we need to re-evaluate what workers should do
; 743  : 	if(m_pPlayer->getNumCities() != m_iNumCities)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+58396]
	je	SHORT $LN40@EvaluateBu

; 744  : 	{
; 745  : 		Update();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Update@CvBuilderTaskingAI@@QAEXXZ	; CvBuilderTaskingAI::Update
$LN40@EvaluateBu:

; 746  : 	}
; 747  : 
; 748  : 	CvAssertMsg(uaDirectives > 0, "Need more than one directive");
; 749  : 
; 750  : 	for(uint ui = 0; ui < uaDirectives; ui++)

	mov	DWORD PTR _ui$217427[ebp], 0
	jmp	SHORT $LN39@EvaluateBu
$LN38@EvaluateBu:
	mov	edx, DWORD PTR _ui$217427[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$217427[ebp], edx
$LN39@EvaluateBu:
	mov	eax, DWORD PTR _ui$217427[ebp]
	cmp	eax, DWORD PTR _uaDirectives$[ebp]
	jae	SHORT $LN37@EvaluateBu

; 751  : 	{
; 752  : 		paDirectives[ui].m_eDirective = BuilderDirective::NUM_DIRECTIVES;

	mov	ecx, DWORD PTR _ui$217427[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _paDirectives$[ebp]
	mov	DWORD PTR [edx+ecx], 6

; 753  : 	}

	jmp	SHORT $LN38@EvaluateBu
$LN37@EvaluateBu:

; 754  : 
; 755  : 	m_aDirectives.clear();

	xor	eax, eax
	je	SHORT $LN60@EvaluateBu
	mov	DWORD PTR _i$220903[ebp], 0
	jmp	SHORT $LN58@EvaluateBu
$LN57@EvaluateBu:
	mov	ecx, DWORD PTR _i$220903[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$220903[ebp], ecx
$LN58@EvaluateBu:
	mov	edx, DWORD PTR _i$220903[ebp]
	cmp	edx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	jae	SHORT $LN60@EvaluateBu
	jmp	SHORT $LN57@EvaluateBu
$LN60@EvaluateBu:
	mov	DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4, 0

; 756  : 
; 757  : 	// check for no brainer bail-outs
; 758  : 	// if the builder is already building something
; 759  : #ifdef AUI_WORKER_EVALUATE_WORKER_RETREAT_AND_BUILD
; 760  : #ifdef AUI_DANGER_PLOTS_REMADE
; 761  : 	if (pUnit->getBuildType() != NO_BUILD && pUnit->GetCurrHitPoints() > m_pPlayer->GetPlotDanger(*pUnit->plot(), pUnit))
; 762  : #elif defined(AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH)
; 763  : 	if (pUnit->getBuildType() != NO_BUILD && 
; 764  : 		((pUnit->IsCombatUnit() && pUnit->GetBaseCombatStrengthConsideringDamage() * AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH > m_pPlayer->GetPlotDanger(*pUnit->plot())) ||
; 765  : 		(!pUnit->IsCombatUnit() && !m_pPlayer->IsPlotUnderImmediateThreat(*pUnit->plot()))))
; 766  : #else
; 767  : 	if (pUnit->getBuildType() != NO_BUILD && !m_pPlayer->IsPlotUnderImmediateThreat(*pUnit->plot())))
; 768  : #endif
; 769  : #else
; 770  : 	if(pUnit->getBuildType() != NO_BUILD)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	cmp	eax, -1
	je	SHORT $LN36@EvaluateBu

; 771  : #endif
; 772  : 	{
; 773  : 		paDirectives[0].m_eDirective = BuilderDirective::BUILD_IMPROVEMENT;

	mov	eax, DWORD PTR _paDirectives$[ebp]
	mov	DWORD PTR [eax], 1

; 774  : 		paDirectives[0].m_eBuild = pUnit->getBuildType();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getBuildType@CvUnit@@QBE?AW4BuildTypes@@XZ ; CvUnit::getBuildType
	mov	ecx, DWORD PTR _paDirectives$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 775  : 		paDirectives[0].m_sX = pUnit->getX();

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T220916[ebp], eax
	mov	ecx, DWORD PTR _paDirectives$[ebp]
	mov	dx, WORD PTR $T220916[ebp]
	mov	WORD PTR [ecx+12], dx

; 776  : 		paDirectives[0].m_sY = pUnit->getY();

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T220925[ebp], ecx
	mov	edx, DWORD PTR _paDirectives$[ebp]
	mov	ax, WORD PTR $T220925[ebp]
	mov	WORD PTR [edx+14], ax

; 777  : 		//inDirective.m_sGoldCost = 0;
; 778  : 		paDirectives[0].m_sMoveTurnsAway = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _paDirectives$[ebp]
	mov	WORD PTR [edx+16], cx

; 779  : 		return true;

	mov	al, 1
	jmp	$LN41@EvaluateBu
$LN36@EvaluateBu:

; 780  : 	}
; 781  : 
; 782  : 	m_aiPlots.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	DWORD PTR $T220944[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN76@EvaluateBu
	mov	DWORD PTR _i$220939[ebp], 0
	jmp	SHORT $LN74@EvaluateBu
$LN73@EvaluateBu:
	mov	edx, DWORD PTR _i$220939[ebp]
	add	edx, 1
	mov	DWORD PTR _i$220939[ebp], edx
$LN74@EvaluateBu:
	mov	eax, DWORD PTR $T220944[ebp]
	mov	ecx, DWORD PTR _i$220939[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN76@EvaluateBu
	jmp	SHORT $LN73@EvaluateBu
$LN76@EvaluateBu:
	mov	edx, DWORD PTR $T220944[ebp]
	mov	DWORD PTR [edx+4], 0

; 783  : 	if(bOnlyEvaluateWorkersPlot)

	movzx	eax, BYTE PTR _bOnlyEvaluateWorkersPlot$[ebp]
	test	eax, eax
	je	SHORT $LN35@EvaluateBu

; 784  : 	{
; 785  : 		// can't build on plots others own
; 786  : 		PlayerTypes eOwner = pUnit->plot()->getOwner();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T220948[ebp], eax
	mov	ecx, DWORD PTR $T220948[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _eOwner$217433[ebp], edx

; 787  : 		if(eOwner == m_pPlayer->GetID())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T220957[ebp], edx
	mov	eax, DWORD PTR _eOwner$217433[ebp]
	cmp	eax, DWORD PTR $T220957[ebp]
	jne	SHORT $LN34@EvaluateBu

; 788  : 		{
; 789  : 			m_aiPlots.push_back(pUnit->plot()->GetPlotIndex());

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR $T220863[ebp], eax
	lea	ecx, DWORD PTR $T220863[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z ; FStaticVector<int,14592,1,297,0>::push_back
$LN34@EvaluateBu:

; 790  : 		}
; 791  : 	}
; 792  : 	else

	jmp	SHORT $LN33@EvaluateBu
$LN35@EvaluateBu:

; 793  : 	{
; 794  : 		m_aiPlots = m_pPlayer->GetPlots();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<int,14592,1,297,0>::operator=
$LN33@EvaluateBu:

; 795  : 	}
; 796  : 
; 797  : #ifdef AUI_WORKER_ADD_IMPROVING_MINOR_PLOTS_DIRECTIVES
; 798  : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 799  : 	{
; 800  : 		CvBuildInfo* pkBuild = GC.getBuildInfo((BuildTypes)iBuildIndex);
; 801  : 		if (pkBuild)
; 802  : 		{
; 803  : 			ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();
; 804  : 			if (eImprovement != NO_IMPROVEMENT)
; 805  : 			{
; 806  : 				CvImprovementEntry* pkImprovement = GC.getImprovementInfo(eImprovement);
; 807  : 				if (pkImprovement && pkImprovement->IsOnlyCityStateTerritory() && (!pkImprovement->IsSpecificCivRequired() || pkImprovement->GetRequiredCivilization() == m_pPlayer->getCivilizationType()))
; 808  : 				{
; 809  : 					for (int iJ = 0; iJ < MAX_CIV_PLAYERS; iJ++)
; 810  : 					{
; 811  : 						CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iJ);
; 812  : 						if (kLoopPlayer.isAlive() && kLoopPlayer.isMinorCiv() && !GET_TEAM(m_pPlayer->getTeam()).isAtWar(kLoopPlayer.getTeam()))
; 813  : 						{
; 814  : 							m_aiPlots.push_back(kLoopPlayer.GetPlots().begin(), kLoopPlayer.GetPlots().size());
; 815  : 						}
; 816  : 					}
; 817  : 					break;
; 818  : 				}
; 819  : 			}
; 820  : 		}
; 821  : 	}
; 822  : #endif
; 823  : 
; 824  : 	// go through all the plots the player has under their control
; 825  : 	for(uint uiPlotIndex = 0; uiPlotIndex < m_aiPlots.size(); uiPlotIndex++)

	mov	DWORD PTR _uiPlotIndex$217437[ebp], 0
	jmp	SHORT $LN32@EvaluateBu
$LN31@EvaluateBu:
	mov	eax, DWORD PTR _uiPlotIndex$217437[ebp]
	add	eax, 1
	mov	DWORD PTR _uiPlotIndex$217437[ebp], eax
$LN32@EvaluateBu:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T220969[ebp], edx
	mov	eax, DWORD PTR _uiPlotIndex$217437[ebp]
	cmp	eax, DWORD PTR $T220969[ebp]
	jae	$LN30@EvaluateBu

; 826  : 	{
; 827  : 		// when we encounter the first plot that is invalid, the rest of the list will be invalid
; 828  : 		if(m_aiPlots[uiPlotIndex] == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _uiPlotIndex$217437[ebp]
	cmp	DWORD PTR [edx+eax*4], -1
	jne	$LN29@EvaluateBu

; 829  : 		{
; 830  : 			if(m_bLogging)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+58392]
	test	edx, edx
	je	$LN28@EvaluateBu

; 831  : 			{
; 832  : 				CvString strLog = "end of plot list";

	mov	eax, OFFSET ??_C@_0BB@JIJICDOP@end?5of?5plot?5list?$AA@
	test	eax, eax
	je	SHORT $LN101@EvaluateBu
	mov	DWORD PTR tv594[ebp], OFFSET ??_C@_0BB@JIJICDOP@end?5of?5plot?5list?$AA@
	jmp	SHORT $LN102@EvaluateBu
$LN101@EvaluateBu:
	mov	DWORD PTR tv594[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN102@EvaluateBu:
	mov	ecx, DWORD PTR tv594[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strLog$217443[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 833  : 				LogInfo(strLog, m_pPlayer);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T220864[ebp], esp
	mov	DWORD PTR $T220985[ebp], ecx
	lea	edx, DWORD PTR _strLog$217443[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220985[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T220985[ebp]
	mov	DWORD PTR tv465[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 834  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217443[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN28@EvaluateBu:

; 835  : 			break;

	jmp	$LN30@EvaluateBu
$LN29@EvaluateBu:

; 836  : 		}
; 837  : 
; 838  : 		CvPlot* pPlot = GC.getMap().plotByIndex(m_aiPlots[uiPlotIndex]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _uiPlotIndex$217437[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T220993[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T220997[ebp], edx
	mov	eax, DWORD PTR $T220993[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T221011[ebp], ecx
	cmp	DWORD PTR $T221011[ebp], 0
	jl	SHORT $LN116@EvaluateBu
	mov	edx, DWORD PTR $T220997[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T221004[ebp], eax
	mov	ecx, DWORD PTR $T221011[ebp]
	cmp	ecx, DWORD PTR $T221004[ebp]
	jge	SHORT $LN116@EvaluateBu
	mov	edx, DWORD PTR $T221011[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T220997[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv652[ebp], edx
	jmp	SHORT $LN114@EvaluateBu
$LN116@EvaluateBu:
	mov	DWORD PTR tv652[ebp], 0
$LN114@EvaluateBu:
	mov	ecx, DWORD PTR tv652[ebp]
	mov	DWORD PTR _pPlot$217446[ebp], ecx

; 839  : 
; 840  : 		if(!ShouldBuilderConsiderPlot(pUnit, pPlot))

	mov	edx, DWORD PTR _pPlot$217446[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@EvaluateBu

; 841  : 		{
; 842  : 			continue;

	jmp	$LN31@EvaluateBu
$LN27@EvaluateBu:

; 843  : 		}
; 844  : 
; 845  : 		// distance weight
; 846  : 		// find how many turns the plot is away
; 847  : 		int iMoveTurnsAway = FindTurnsAway(pUnit, pPlot);

	mov	edx, DWORD PTR _pPlot$217446[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::FindTurnsAway
	mov	DWORD PTR _iMoveTurnsAway$217448[ebp], eax

; 848  : 		if(iMoveTurnsAway < 0)

	cmp	DWORD PTR _iMoveTurnsAway$217448[ebp], 0
	jge	$LN26@EvaluateBu

; 849  : 		{
; 850  : 			if(m_bLogging)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+58392]
	test	edx, edx
	je	$LN25@EvaluateBu

; 851  : 			{
; 852  : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$217451[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 853  : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, can't find path", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$217446[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T221019[ebp], ecx
	mov	edx, DWORD PTR _pPlot$217446[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T221023[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T221032[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T221041[ebp], ecx
	mov	edx, DWORD PTR $T221019[ebp]
	push	edx
	mov	eax, DWORD PTR $T221023[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221032[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221041[ebp]
	push	edx
	push	OFFSET ??_C@_0DK@KAPAIHN@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@
	lea	eax, DWORD PTR _strLog$217451[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 854  : 				LogInfo(strLog, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T220865[ebp], esp
	mov	DWORD PTR $T221046[ebp], eax
	lea	ecx, DWORD PTR _strLog$217451[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221046[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T221046[ebp]
	mov	DWORD PTR tv470[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 855  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217451[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN25@EvaluateBu:

; 856  : 
; 857  : 			continue;

	jmp	$LN31@EvaluateBu
$LN26@EvaluateBu:

; 858  : 		}
; 859  : 
; 860  : #ifdef AUI_WORKER_ADD_IMPROVING_MINOR_PLOTS_DIRECTIVES
; 861  : 		if (pPlot->getOwner() != m_pPlayer->GetID())
; 862  : 			AddImprovingMinorPlotsDirectives(pUnit, pPlot, iMoveTurnsAway);
; 863  : 		else
; 864  : 		{
; 865  : #endif
; 866  : 		UpdateCurrentPlotYields(pPlot);

	mov	eax, DWORD PTR _pPlot$217446[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ; CvBuilderTaskingAI::UpdateCurrentPlotYields

; 867  : 
; 868  : 		//AddRepairDirectives(pUnit, pPlot, iMoveTurnsAway);
; 869  : 		AddRouteDirectives(pUnit, pPlot, iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$217448[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$217446[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRouteDirectives

; 870  : 		AddImprovingResourcesDirectives(pUnit, pPlot, iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$217448[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$217446[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingResourcesDirectives

; 871  : 		AddImprovingPlotsDirectives(pUnit, pPlot, iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$217448[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$217446[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddImprovingPlotsDirectives

; 872  : 		AddChopDirectives(pUnit, pPlot, iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$217448[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$217446[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddChopDirectives

; 873  : 		AddScrubFalloutDirectives(pUnit, pPlot, iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$217448[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$217446[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddScrubFalloutDirectives

; 874  : 		// only AIs have permission to remove roads
; 875  : 		if(!m_pPlayer->isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman

; 876  : 		{
; 877  : 			//AddRemoveUselessRoadDirectives(pUnit, pPlot, iMoveTurnsAway);
; 878  : 		}
; 879  : #ifdef AUI_WORKER_ADD_IMPROVING_MINOR_PLOTS_DIRECTIVES
; 880  : 		}
; 881  : #endif
; 882  : 	}

	jmp	$LN31@EvaluateBu
$LN30@EvaluateBu:

; 883  : 
; 884  : 	// we need to evaluate the tiles outside of our territory to build roads
; 885  : 	for(uint ui = 0; ui < m_aiNonTerritoryPlots.size(); ui++)

	mov	DWORD PTR _ui$217455[ebp], 0
	jmp	SHORT $LN23@EvaluateBu
$LN22@EvaluateBu:
	mov	eax, DWORD PTR _ui$217455[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$217455[ebp], eax
$LN23@EvaluateBu:
	mov	ecx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A+4
	mov	DWORD PTR $T221054[ebp], ecx
	mov	edx, DWORD PTR _ui$217455[ebp]
	cmp	edx, DWORD PTR $T221054[ebp]
	jae	$LN21@EvaluateBu

; 886  : 	{
; 887  : 		//FAssertMsg(!m_pPlayer->isMinorCiv(), "MinorCivs should have no nonterritory plots");
; 888  : 		CvPlot* pPlot = GC.getMap().plotByIndex(m_aiNonTerritoryPlots[ui]);

	mov	eax, DWORD PTR _ui$217455[ebp]
	mov	ecx, DWORD PTR ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T221058[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T221062[ebp], eax
	mov	ecx, DWORD PTR $T221058[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T221076[ebp], edx
	cmp	DWORD PTR $T221076[ebp], 0
	jl	SHORT $LN149@EvaluateBu
	mov	eax, DWORD PTR $T221062[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T221069[ebp], ecx
	mov	edx, DWORD PTR $T221076[ebp]
	cmp	edx, DWORD PTR $T221069[ebp]
	jge	SHORT $LN149@EvaluateBu
	mov	eax, DWORD PTR $T221076[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T221062[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv694[ebp], eax
	jmp	SHORT $LN147@EvaluateBu
$LN149@EvaluateBu:
	mov	DWORD PTR tv694[ebp], 0
$LN147@EvaluateBu:
	mov	edx, DWORD PTR tv694[ebp]
	mov	DWORD PTR _pPlot$217459[ebp], edx

; 889  : 		CvAssertMsg(pPlot != NULL, "Plot should not be NULL");
; 890  : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$217459[ebp], 0
	jne	SHORT $LN20@EvaluateBu

; 891  : 			continue;

	jmp	$LN22@EvaluateBu
$LN20@EvaluateBu:

; 892  : 
; 893  : 		if(bOnlyEvaluateWorkersPlot)

	movzx	eax, BYTE PTR _bOnlyEvaluateWorkersPlot$[ebp]
	test	eax, eax
	je	SHORT $LN19@EvaluateBu

; 894  : 		{
; 895  : 			if(pPlot != pUnit->plot())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	DWORD PTR _pPlot$217459[ebp], eax
	je	SHORT $LN19@EvaluateBu

; 896  : 			{
; 897  : 				continue;

	jmp	$LN22@EvaluateBu
$LN19@EvaluateBu:

; 898  : 			}
; 899  : 		}
; 900  : 
; 901  : 		if(!ShouldBuilderConsiderPlot(pUnit, pPlot))

	mov	ecx, DWORD PTR _pPlot$217459[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@EvaluateBu

; 902  : 		{
; 903  : 			continue;

	jmp	$LN22@EvaluateBu
$LN17@EvaluateBu:

; 904  : 		}
; 905  : 
; 906  : 		// distance weight
; 907  : 		// find how many turns the plot is away
; 908  : 		int iMoveTurnsAway = FindTurnsAway(pUnit, pPlot);

	mov	ecx, DWORD PTR _pPlot$217459[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::FindTurnsAway
	mov	DWORD PTR _iMoveTurnsAway$217464[ebp], eax

; 909  : 		if(iMoveTurnsAway < 0)

	cmp	DWORD PTR _iMoveTurnsAway$217464[ebp], 0
	jge	$LN16@EvaluateBu

; 910  : 		{
; 911  : 			if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN15@EvaluateBu

; 912  : 			{
; 913  : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$217467[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 914  : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, Evaluating out of territory plot, can't find path", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$217459[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T221084[ebp], eax
	mov	ecx, DWORD PTR _pPlot$217459[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T221088[ebp], edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T221097[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T221106[ebp], eax
	mov	ecx, DWORD PTR $T221084[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221088[ebp]
	push	edx
	mov	eax, DWORD PTR $T221097[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221106[ebp]
	push	ecx
	push	OFFSET ??_C@_0FM@LMGJIHMD@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@
	lea	edx, DWORD PTR _strLog$217467[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 915  : 				LogInfo(strLog, m_pPlayer);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T220866[ebp], esp
	mov	DWORD PTR $T221111[ebp], edx
	lea	eax, DWORD PTR _strLog$217467[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221111[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T221111[ebp]
	mov	DWORD PTR tv475[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 916  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217467[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN15@EvaluateBu:

; 917  : 
; 918  : 			continue;

	jmp	$LN22@EvaluateBu
$LN16@EvaluateBu:

; 919  : 		}
; 920  : 
; 921  : 		if(m_bLogging)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	$LN14@EvaluateBu

; 922  : 		{
; 923  : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$217471[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 924  : 			strLog.Format("x: %d y: %d, Evaluating out of territory plot", pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$217459[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T221123[ebp], edx
	mov	eax, DWORD PTR $T221123[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$217459[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0CO@EDMNELMA@x?3?5?$CFd?5y?3?5?$CFd?0?5Evaluating?5out?5of?5t@
	lea	eax, DWORD PTR _strLog$217471[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 925  : 			LogInfo(strLog, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T220867[ebp], esp
	mov	DWORD PTR $T221131[ebp], eax
	lea	ecx, DWORD PTR _strLog$217471[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221131[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T221131[ebp]
	mov	DWORD PTR tv480[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 926  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217471[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@EvaluateBu:

; 927  : 
; 928  : 		//AddRepairDirectives(pUnit, pPlot, iMoveTurnsAway);
; 929  : 		AddRouteDirectives(pUnit, pPlot, iMoveTurnsAway);

	mov	eax, DWORD PTR _iMoveTurnsAway$217464[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$217459[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRouteDirectives

; 930  : 	}

	jmp	$LN22@EvaluateBu
$LN21@EvaluateBu:

; 931  : 
; 932  : 	m_aDirectives.StableSortItems();

	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	DWORD PTR $T221140[ebp], eax
	mov	ecx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	DWORD PTR $T221178[ebp], ecx
	mov	edx, DWORD PTR $T221178[ebp]
	cmp	edx, DWORD PTR $T221140[ebp]
	je	SHORT $LN187@EvaluateBu
	push	0
	push	0
	mov	eax, DWORD PTR $T221140[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221178[ebp]
	push	ecx
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN187@EvaluateBu:

; 933  : 
; 934  : 	int iBestWeight = 0;

	mov	DWORD PTR _iBestWeight$[ebp], 0

; 935  : 
; 936  : 	int iAssignIndex = 0;

	mov	DWORD PTR _iAssignIndex$[ebp], 0

; 937  : 	for(int i = 0; i < m_aDirectives.size(); i++)

	mov	DWORD PTR _i$217476[ebp], 0
	jmp	SHORT $LN13@EvaluateBu
$LN12@EvaluateBu:
	mov	edx, DWORD PTR _i$217476[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217476[ebp], edx
$LN13@EvaluateBu:
	mov	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	mov	DWORD PTR $T221196[ebp], eax
	mov	ecx, DWORD PTR _i$217476[ebp]
	cmp	ecx, DWORD PTR $T221196[ebp]
	jge	$LN11@EvaluateBu

; 938  : 	{
; 939  : 		// If this target was far away, we only estimated the time to get there.  We need to be sure we have a real path there
; 940  : 		CvPlot* pTarget = GC.getMap().plot(m_aDirectives.GetElement(i).m_sX, m_aDirectives.GetElement(i).m_sY);

	mov	edx, DWORD PTR _i$217476[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	DWORD PTR $T221209[ebp], edx
	mov	eax, DWORD PTR _i$217476[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	DWORD PTR $T221218[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T221222[ebp], ecx
	mov	edx, DWORD PTR $T221209[ebp]
	movsx	eax, WORD PTR [edx+14]
	mov	DWORD PTR $T221325[ebp], eax
	mov	ecx, DWORD PTR $T221218[ebp]
	movsx	edx, WORD PTR [ecx+12]
	mov	DWORD PTR $T221324[ebp], edx
	cmp	DWORD PTR $T221324[ebp], -2147483647	; 80000001H
	je	SHORT $LN223@EvaluateBu
	cmp	DWORD PTR $T221325[ebp], -2147483647	; 80000001H
	jne	SHORT $LN224@EvaluateBu
$LN223@EvaluateBu:
	mov	DWORD PTR _pTarget$217480[ebp], 0
	jmp	$LN225@EvaluateBu
$LN224@EvaluateBu:
	mov	eax, DWORD PTR $T221222[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T221229[ebp], cl
	mov	edx, DWORD PTR $T221222[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T221233[ebp], eax
	movzx	ecx, BYTE PTR $T221229[ebp]
	test	ecx, ecx
	je	SHORT $LN236@EvaluateBu
	cmp	DWORD PTR $T221324[ebp], 0
	jge	SHORT $LN235@EvaluateBu
	mov	eax, DWORD PTR $T221324[ebp]
	cdq
	idiv	DWORD PTR $T221233[ebp]
	add	edx, DWORD PTR $T221233[ebp]
	mov	DWORD PTR _iMapX$221322[ebp], edx
	jmp	SHORT $LN237@EvaluateBu
	jmp	SHORT $LN236@EvaluateBu
$LN235@EvaluateBu:
	mov	edx, DWORD PTR $T221324[ebp]
	cmp	edx, DWORD PTR $T221233[ebp]
	jl	SHORT $LN236@EvaluateBu
	mov	eax, DWORD PTR $T221324[ebp]
	cdq
	idiv	DWORD PTR $T221233[ebp]
	mov	DWORD PTR _iMapX$221322[ebp], edx
	jmp	SHORT $LN237@EvaluateBu
$LN236@EvaluateBu:
	mov	eax, DWORD PTR $T221324[ebp]
	mov	DWORD PTR _iMapX$221322[ebp], eax
$LN237@EvaluateBu:
	mov	ecx, DWORD PTR $T221222[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T221244[ebp], dl
	mov	eax, DWORD PTR $T221222[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T221248[ebp], ecx
	movzx	edx, BYTE PTR $T221244[ebp]
	test	edx, edx
	je	SHORT $LN246@EvaluateBu
	cmp	DWORD PTR $T221325[ebp], 0
	jge	SHORT $LN245@EvaluateBu
	mov	eax, DWORD PTR $T221325[ebp]
	cdq
	idiv	DWORD PTR $T221248[ebp]
	add	edx, DWORD PTR $T221248[ebp]
	mov	DWORD PTR _iMapY$221323[ebp], edx
	jmp	SHORT $LN247@EvaluateBu
	jmp	SHORT $LN246@EvaluateBu
$LN245@EvaluateBu:
	mov	eax, DWORD PTR $T221325[ebp]
	cmp	eax, DWORD PTR $T221248[ebp]
	jl	SHORT $LN246@EvaluateBu
	mov	eax, DWORD PTR $T221325[ebp]
	cdq
	idiv	DWORD PTR $T221248[ebp]
	mov	DWORD PTR _iMapY$221323[ebp], edx
	jmp	SHORT $LN247@EvaluateBu
$LN246@EvaluateBu:
	mov	ecx, DWORD PTR $T221325[ebp]
	mov	DWORD PTR _iMapY$221323[ebp], ecx
$LN247@EvaluateBu:
	cmp	DWORD PTR _iMapX$221322[ebp], 0
	jl	SHORT $LN251@EvaluateBu
	mov	edx, DWORD PTR $T221222[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T221262[ebp], eax
	mov	ecx, DWORD PTR _iMapX$221322[ebp]
	cmp	ecx, DWORD PTR $T221262[ebp]
	jge	SHORT $LN251@EvaluateBu
	cmp	DWORD PTR _iMapY$221323[ebp], 0
	jl	SHORT $LN251@EvaluateBu
	mov	edx, DWORD PTR $T221222[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T221266[ebp], eax
	mov	ecx, DWORD PTR _iMapY$221323[ebp]
	cmp	ecx, DWORD PTR $T221266[ebp]
	jge	SHORT $LN251@EvaluateBu
	mov	DWORD PTR tv874[ebp], 1
	jmp	SHORT $LN249@EvaluateBu
$LN251@EvaluateBu:
	mov	DWORD PTR tv874[ebp], 0
$LN249@EvaluateBu:
	cmp	DWORD PTR tv874[ebp], 0
	je	SHORT $LN227@EvaluateBu
	mov	edx, DWORD PTR $T221222[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T221279[ebp], eax
	mov	ecx, DWORD PTR _iMapY$221323[ebp]
	imul	ecx, DWORD PTR $T221279[ebp]
	add	ecx, DWORD PTR _iMapX$221322[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T221222[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv859[ebp], ecx
	jmp	SHORT $LN228@EvaluateBu
$LN227@EvaluateBu:
	mov	DWORD PTR tv859[ebp], 0
$LN228@EvaluateBu:
	mov	eax, DWORD PTR tv859[ebp]
	mov	DWORD PTR _pTarget$217480[ebp], eax
$LN225@EvaluateBu:

; 941  : 		CvAssertMsg(pTarget != NULL, "Not expecting the target to be NULL");
; 942  : 		if(!pTarget)

	cmp	DWORD PTR _pTarget$217480[ebp], 0
	jne	SHORT $LN10@EvaluateBu

; 943  : 			continue;

	jmp	$LN12@EvaluateBu
$LN10@EvaluateBu:

; 944  : 
; 945  : #if 0	// KWG: We are now always doing a raw estimate when gathering the directives
; 946  : 		int iPlotDistance = plotDistance(pUnit->getX(), pUnit->getY(), pTarget->getX(), pTarget->getY());
; 947  : 		if(iPlotDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())
; 948  : #endif
; 949  : 		{
; 950  : 			if(TurnsToReachTarget(pUnit, pTarget) == MAX_INT)

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pTarget$217480[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	DWORD PTR $T220868[ebp], esp
	mov	DWORD PTR $T221335[ebp], edx
	mov	eax, DWORD PTR $T221335[ebp]
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T221335[ebp]
	mov	BYTE PTR [edx+4], 0
	mov	eax, DWORD PTR $T221335[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN262@EvaluateBu
	mov	ecx, DWORD PTR $T221335[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN262@EvaluateBu:
	mov	edx, DWORD PTR $T221335[ebp]
	mov	DWORD PTR tv486[ebp], edx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv487[ebp], eax
	cmp	DWORD PTR tv487[ebp], 2147483647	; 7fffffffH
	jne	SHORT $LN9@EvaluateBu

; 951  : 			{
; 952  : 				// No path, need to pick a new directive
; 953  : 				continue;

	jmp	$LN12@EvaluateBu
$LN9@EvaluateBu:

; 954  : 			}
; 955  : 		}
; 956  : 
; 957  : 		if(iBestWeight == 0)

	cmp	DWORD PTR _iBestWeight$[ebp], 0
	jne	$LN8@EvaluateBu

; 958  : 		{
; 959  : 			iBestWeight = m_aDirectives.GetWeight(i);

	mov	DWORD PTR _elem$221356[ebp], 6
	mov	DWORD PTR _elem$221356[ebp+4], -1
	mov	DWORD PTR _elem$221356[ebp+8], -1
	or	eax, -1
	mov	WORD PTR _elem$221356[ebp+12], ax
	or	ecx, -1
	mov	WORD PTR _elem$221356[ebp+14], cx
	or	edx, -1
	mov	WORD PTR _elem$221356[ebp+16], dx
	mov	DWORD PTR _elem$221356[ebp+20], 0
	mov	eax, DWORD PTR _i$217476[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$221356[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$221356[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$221356[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$221356[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _elem$221356[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _elem$221356[ebp+20], edx
	mov	eax, DWORD PTR _elem$221356[ebp+20]
	mov	DWORD PTR _iBestWeight$[ebp], eax
$LN8@EvaluateBu:

; 960  : 		}
; 961  : 
; 962  : 		if(bOnlyKeepBest)

	movzx	ecx, BYTE PTR _bOnlyKeepBest$[ebp]
	test	ecx, ecx
	je	$LN282@EvaluateBu

; 963  : 		{
; 964  : 			int iWeight = m_aDirectives.GetWeight(i);

	mov	DWORD PTR _elem$221373[ebp], 6
	mov	DWORD PTR _elem$221373[ebp+4], -1
	mov	DWORD PTR _elem$221373[ebp+8], -1
	or	edx, -1
	mov	WORD PTR _elem$221373[ebp+12], dx
	or	eax, -1
	mov	WORD PTR _elem$221373[ebp+14], ax
	or	ecx, -1
	mov	WORD PTR _elem$221373[ebp+16], cx
	mov	DWORD PTR _elem$221373[ebp+20], 0
	mov	edx, DWORD PTR _i$217476[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _elem$221373[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _elem$221373[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _elem$221373[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _elem$221373[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _elem$221373[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR _elem$221373[ebp+20], ecx
	mov	edx, DWORD PTR _elem$221373[ebp+20]
	mov	DWORD PTR _iWeight$217486[ebp], edx

; 965  : 			if(iWeight < iBestWeight * 3 / 4)

	mov	eax, DWORD PTR _iBestWeight$[ebp]
	imul	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	DWORD PTR _iWeight$217486[ebp], eax
	jge	SHORT $LN282@EvaluateBu

; 966  : 			{
; 967  : 				break;

	jmp	$LN11@EvaluateBu

; 968  : 			}
; 969  : 		}
; 970  : 
; 971  : 		BuilderDirective directive = m_aDirectives.GetElement(i);

$LN282@EvaluateBu:
	mov	eax, DWORD PTR _i$217476[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _directive$217488[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _directive$217488[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _directive$217488[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _directive$217488[ebp+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _directive$217488[ebp+16], eax

; 972  : 		paDirectives[iAssignIndex] = directive;

	mov	ecx, DWORD PTR _iAssignIndex$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR _paDirectives$[ebp]
	mov	edx, DWORD PTR _directive$217488[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _directive$217488[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _directive$217488[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _directive$217488[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _directive$217488[ebp+16]
	mov	DWORD PTR [ecx+16], edx

; 973  : 		iAssignIndex++;

	mov	eax, DWORD PTR _iAssignIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _iAssignIndex$[ebp], eax

; 974  : 
; 975  : 		// if we shouldn't copy over any more directives, then break
; 976  : 		if(iAssignIndex >= (int)uaDirectives)

	mov	ecx, DWORD PTR _iAssignIndex$[ebp]
	cmp	ecx, DWORD PTR _uaDirectives$[ebp]
	jl	SHORT $LN5@EvaluateBu

; 977  : 		{
; 978  : 			break;

	jmp	SHORT $LN11@EvaluateBu
$LN5@EvaluateBu:

; 979  : 		}
; 980  : 	}

	jmp	$LN12@EvaluateBu
$LN11@EvaluateBu:

; 981  : 
; 982  : 	if(m_bLogging)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	SHORT $LN4@EvaluateBu

; 983  : 	{
; 984  : 		if(m_aDirectives.size() > 0)

	mov	ecx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	mov	DWORD PTR $T221390[ebp], ecx

; 985  : 		{
; 986  : 			//LogFlavors(NO_FLAVOR);
; 987  : 		}
; 988  : 
; 989  : 		LogDirectives(pUnit);

	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z ; CvBuilderTaskingAI::LogDirectives
$LN4@EvaluateBu:

; 990  : 	}
; 991  : 
; 992  : 	//if (m_aDirectives.size() > 0 && iAssignIndex > 0)
; 993  : 	if(iAssignIndex > 0)

	cmp	DWORD PTR _iAssignIndex$[ebp], 0
	jle	SHORT $LN2@EvaluateBu

; 994  : 	{
; 995  : 		if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	SHORT $LN1@EvaluateBu

; 996  : 		{
; 997  : 			LogDirective(paDirectives[0], pUnit, -1, true /*bChosen*/);

	push	1
	push	-1
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _paDirectives$[ebp]
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ; CvBuilderTaskingAI::LogDirective
$LN1@EvaluateBu:

; 998  : 		}
; 999  : 		return true;

	mov	al, 1
	jmp	SHORT $LN41@EvaluateBu
$LN2@EvaluateBu:

; 1000 : 	}
; 1001 : 
; 1002 : 	return false;

	xor	al, al
$LN41@EvaluateBu:

; 1003 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$0:
	lea	ecx, DWORD PTR _strLog$217443[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$2:
	lea	ecx, DWORD PTR _strLog$217451[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$4:
	lea	ecx, DWORD PTR _strLog$217467[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z$6:
	lea	ecx, DWORD PTR _strLog$217471[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-544]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EvaluateBuilder@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAUBuilderDirective@@I_N2@Z ENDP ; CvBuilderTaskingAI::EvaluateBuilder
PUBLIC	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
PUBLIC	??_C@_0CG@JJDEGAOH@?$CFd?0?5Build?5Time?5Weight?0?5?$CFd?0?5Weigh@ ; `string'
PUBLIC	??_C@_0P@CFGIALGA@Helps?5rush?0?5?$CFd?$AA@	; `string'
PUBLIC	?ScorePlot@CvBuilderTaskingAI@@QAEHXZ		; CvBuilderTaskingAI::ScorePlot
PUBLIC	?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::UpdateProjectedPlotYields
PUBLIC	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ; CvBuilderTaskingAI::GetResourceWeight
PUBLIC	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
PUBLIC	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
PUBLIC	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
PUBLIC	__$ArrayPad$
EXTRN	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z:PROC ; CvPlot::getFeatureProduction
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::getBuildTime
EXTRN	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z:PROC ; CvUnit::canBuild
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?HasSpecialImprovement@CvPlot@@QBE_NXZ:PROC	; CvPlot::HasSpecialImprovement
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
;	COMDAT ??_C@_0CG@JJDEGAOH@?$CFd?0?5Build?5Time?5Weight?0?5?$CFd?0?5Weigh@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
CONST	SEGMENT
??_C@_0CG@JJDEGAOH@?$CFd?0?5Build?5Time?5Weight?0?5?$CFd?0?5Weigh@ DB '%d'
	DB	', Build Time Weight, %d, Weight, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CFGIALGA@Helps?5rush?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0P@CFGIALGA@Helps?5rush?0?5?$CFd?$AA@ DB 'Helps rush, %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2
__ehfuncinfo$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
tv344 = -296						; size = 4
tv339 = -292						; size = 4
_this$ = -288						; size = 4
$T221483 = -208						; size = 4
$T221478 = -204						; size = 4
$T221452 = -200						; size = 4
$T221443 = -196						; size = 4
$T221434 = -192						; size = 4
$T221419 = -188						; size = 4
$T221418 = -184						; size = 4
$T221405 = -180						; size = 4
$T221404 = -176						; size = 4
_strTemp$217556 = -172					; size = 28
_strLog$217550 = -144					; size = 28
__$ArrayPad$ = -116					; size = 4
_iProduction$217547 = -112				; size = 4
_pLogCity$217546 = -108					; size = 4
_pkBuild2$217540 = -104					; size = 4
_iBuildIndex2$217535 = -100				; size = 4
_eExistingBuild$217533 = -96				; size = 4
_eBuild2$217534 = -92					; size = 4
_pkBuild$217514 = -88					; size = 4
_pkImprovementInfo$217519 = -84				; size = 4
_iInvestedImprovementTime$217531 = -80			; size = 4
_eDirectiveType$217528 = -76				; size = 4
_eImprovement$217516 = -72				; size = 4
_iWeight$217529 = -68					; size = 4
_directive$217554 = -64					; size = 20
_iBuildTimeWeight$217543 = -44				; size = 4
_iScore$217544 = -40					; size = 4
_eExistingPlotImprovement$ = -36			; size = 4
_eBuild$ = -32						; size = 4
_eOriginalBuild$ = -28					; size = 4
_eResource$ = -24					; size = 4
_pkResource$ = -20					; size = 4
_iBuildIndex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddImprovingResourcesDirectives, COMDAT
; _this$ = ecx

; 1008 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1009 : #ifdef AUI_WARNING_FIXES
; 1010 : 	if (!pUnit)
; 1011 : 		return;
; 1012 : #endif
; 1013 : 
; 1014 : 	ImprovementTypes eExistingPlotImprovement = pPlot->getImprovementType();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eExistingPlotImprovement$[ebp], eax

; 1015 : 
; 1016 : 	// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1017 : 	if(eExistingPlotImprovement != NO_IMPROVEMENT && pPlot->HasSpecialImprovement() && !pPlot->IsImprovementPillaged())

	cmp	DWORD PTR _eExistingPlotImprovement$[ebp], -1
	je	SHORT $LN28@AddImprovi
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@AddImprovi
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN28@AddImprovi

; 1018 : 	{
; 1019 : 		return;

	jmp	$LN29@AddImprovi
$LN28@AddImprovi:

; 1020 : 	}
; 1021 : 
; 1022 : 	// check to see if a resource is here. If not, bail out!
; 1023 : 	ResourceTypes eResource = pPlot->getResourceType(m_pPlayer->getTeam());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T221418[ebp], eax
	mov	ecx, DWORD PTR $T221418[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T221419[ebp], eax
	mov	eax, DWORD PTR $T221419[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 1024 : 	if(eResource == NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	jne	SHORT $LN27@AddImprovi

; 1025 : 	{
; 1026 : 		return;

	jmp	$LN29@AddImprovi
$LN27@AddImprovi:

; 1027 : 	}
; 1028 : 
; 1029 : 	CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResource$[ebp], eax

; 1030 : 	if(pkResource->getResourceUsage() == RESOURCEUSAGE_BONUS)

	mov	ecx, DWORD PTR _pkResource$[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	test	eax, eax
	jne	SHORT $LN26@AddImprovi

; 1031 : 	{
; 1032 : 		// evaluate bonus resources as normal improvements
; 1033 : 		return;

	jmp	$LN29@AddImprovi
$LN26@AddImprovi:

; 1034 : 	}
; 1035 : 
; 1036 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 1037 : 	// check to see if someone already has a conflicting mission here
; 1038 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 1039 : 	{
; 1040 : 		int iLoop;
; 1041 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 1042 : 		{
; 1043 : 			if (pUnit == pLoopUnit)
; 1044 : 			{
; 1045 : 				continue;
; 1046 : 			}
; 1047 : 
; 1048 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 1049 : 			if (!pMissionPlot)
; 1050 : 			{
; 1051 : 				continue;
; 1052 : 			}
; 1053 : 
; 1054 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 1055 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 1056 : 			{
; 1057 : 				continue;
; 1058 : 			}
; 1059 : 
; 1060 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 1061 : 			{
; 1062 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 1063 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 1064 : 				if (pkBuild != NULL)
; 1065 : 				{
; 1066 : 					ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();
; 1067 : 					if (eImprovement != NO_IMPROVEMENT || (eOtherBuild == m_eRepairBuild && eExistingPlotImprovement != NO_IMPROVEMENT))
; 1068 : 					{
; 1069 : 						if (m_bLogging)
; 1070 : 						{
; 1071 : 							CvString strLog;
; 1072 : 							strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 1073 : 							LogInfo(strLog, m_pPlayer, true);
; 1074 : 						}
; 1075 : 						return;
; 1076 : 					}
; 1077 : 				}
; 1078 : 			}
; 1079 : 		}
; 1080 : 	}
; 1081 : #endif
; 1082 : 
; 1083 : 	// loop through the build types to find one that we can use
; 1084 : 	BuildTypes eBuild;
; 1085 : 	BuildTypes eOriginalBuild;
; 1086 : #ifdef AUI_WARNING_FIXES
; 1087 : 	uint iBuildIndex;
; 1088 : #else
; 1089 : 	int iBuildIndex;
; 1090 : #endif
; 1091 : 	for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$[ebp], 0
	jmp	SHORT $LN25@AddImprovi
$LN24@AddImprovi:
	mov	edx, DWORD PTR _iBuildIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _iBuildIndex$[ebp], edx
$LN25@AddImprovi:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$[ebp], eax
	jge	$LN29@AddImprovi

; 1092 : 	{
; 1093 : 		eBuild = (BuildTypes)iBuildIndex;

	mov	eax, DWORD PTR _iBuildIndex$[ebp]
	mov	DWORD PTR _eBuild$[ebp], eax

; 1094 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217514[ebp], eax

; 1095 : 		if(pkBuild == NULL)

	cmp	DWORD PTR _pkBuild$217514[ebp], 0
	jne	SHORT $LN22@AddImprovi

; 1096 : 			continue;

	jmp	SHORT $LN24@AddImprovi
$LN22@AddImprovi:

; 1097 : 
; 1098 : 		eOriginalBuild = eBuild;

	mov	edx, DWORD PTR _eBuild$[ebp]
	mov	DWORD PTR _eOriginalBuild$[ebp], edx

; 1099 : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();

	mov	ecx, DWORD PTR _pkBuild$217514[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$217516[ebp], eax

; 1100 : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$217516[ebp], -1
	jne	SHORT $LN21@AddImprovi

; 1101 : 		{
; 1102 : 			continue;

	jmp	SHORT $LN24@AddImprovi
$LN21@AddImprovi:

; 1103 : 		}
; 1104 : 
; 1105 : 		CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$217516[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$217519[ebp], eax

; 1106 : 		if(pkImprovementInfo == NULL || !pkImprovementInfo->IsImprovementResourceTrade(eResource))

	cmp	DWORD PTR _pkImprovementInfo$217519[ebp], 0
	je	SHORT $LN19@AddImprovi
	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkImprovementInfo$217519[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@AddImprovi
$LN19@AddImprovi:

; 1107 : 		{
; 1108 : 			continue;

	jmp	SHORT $LN24@AddImprovi
$LN20@AddImprovi:

; 1109 : 		}
; 1110 : 
; 1111 : 		if(eImprovement == eExistingPlotImprovement)

	mov	eax, DWORD PTR _eImprovement$217516[ebp]
	cmp	eax, DWORD PTR _eExistingPlotImprovement$[ebp]
	jne	SHORT $LN18@AddImprovi

; 1112 : 		{
; 1113 : 			if(pPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN17@AddImprovi

; 1114 : 			{
; 1115 : 				eBuild = m_eRepairBuild;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _eBuild$[ebp], eax

; 1116 : 			}
; 1117 : 			else

	jmp	SHORT $LN16@AddImprovi
$LN17@AddImprovi:

; 1118 : 			{
; 1119 : 				// this plot already has the appropriate improvement to use the resource
; 1120 : 				break;

	jmp	$LN29@AddImprovi
$LN16@AddImprovi:

; 1121 : 			}
; 1122 : 		}
; 1123 : 		else

	jmp	SHORT $LN15@AddImprovi
$LN18@AddImprovi:

; 1124 : 		{
; 1125 : 			// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1126 : 			if (eExistingPlotImprovement != NO_IMPROVEMENT && pPlot->HasSpecialImprovement())

	cmp	DWORD PTR _eExistingPlotImprovement$[ebp], -1
	je	SHORT $LN15@AddImprovi
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@AddImprovi

; 1127 : 				continue;

	jmp	$LN24@AddImprovi
$LN15@AddImprovi:

; 1128 : 		}
; 1129 : 
; 1130 : 		if(!pUnit->canBuild(pPlot, eBuild))

	push	1
	push	0
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@AddImprovi

; 1131 : 		{
; 1132 : 			break;

	jmp	$LN29@AddImprovi
$LN13@AddImprovi:

; 1133 : 		}
; 1134 : 
; 1135 : 		BuilderDirective::BuilderDirectiveType eDirectiveType = BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE;

	mov	DWORD PTR _eDirectiveType$217528[ebp], 0

; 1136 : 		int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_RESOURCE_IMPROVEMENTS();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2144
	mov	DWORD PTR _iWeight$217529[ebp], edx

; 1137 : 		if(eBuild == m_eRepairBuild)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eBuild$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN12@AddImprovi

; 1138 : 		{
; 1139 : 			eDirectiveType = BuilderDirective::REPAIR;

	mov	DWORD PTR _eDirectiveType$217528[ebp], 3

; 1140 : 			iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152
	mov	DWORD PTR _iWeight$217529[ebp], edx
$LN12@AddImprovi:

; 1141 : 		}
; 1142 : 
; 1143 : 		iWeight = GetBuildCostWeight(iWeight, pPlot, eBuild);

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWeight$217529[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
	mov	DWORD PTR _iWeight$217529[ebp], eax

; 1144 : 
; 1145 : 		// this is to deal with when the plot is already improved with another improvement that doesn't enable the resource
; 1146 : 		int iInvestedImprovementTime = 0;

	mov	DWORD PTR _iInvestedImprovementTime$217531[ebp], 0

; 1147 : 		if(eExistingPlotImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eExistingPlotImprovement$[ebp], -1
	je	$LN11@AddImprovi

; 1148 : 		{
; 1149 : 			BuildTypes eExistingBuild = NO_BUILD;

	mov	DWORD PTR _eExistingBuild$217533[ebp], -1

; 1150 : 			BuildTypes eBuild2 = NO_BUILD;

	mov	DWORD PTR _eBuild2$217534[ebp], -1

; 1151 : #ifdef AUI_WARNING_FIXES
; 1152 : 			for (uint iBuildIndex2 = 0; iBuildIndex2 < GC.getNumBuildInfos(); iBuildIndex2++)
; 1153 : #else
; 1154 : 			for(int iBuildIndex2 = 0; iBuildIndex2 < GC.getNumBuildInfos(); iBuildIndex2++)

	mov	DWORD PTR _iBuildIndex2$217535[ebp], 0
	jmp	SHORT $LN10@AddImprovi
$LN9@AddImprovi:
	mov	eax, DWORD PTR _iBuildIndex2$217535[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildIndex2$217535[ebp], eax
$LN10@AddImprovi:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex2$217535[ebp], eax
	jge	SHORT $LN8@AddImprovi

; 1155 : #endif
; 1156 : 			{
; 1157 : 				eBuild2 = (BuildTypes)iBuildIndex2;

	mov	ecx, DWORD PTR _iBuildIndex2$217535[ebp]
	mov	DWORD PTR _eBuild2$217534[ebp], ecx

; 1158 : 				CvBuildInfo* pkBuild2 = GC.getBuildInfo(eBuild2);

	mov	edx, DWORD PTR _eBuild2$217534[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild2$217540[ebp], eax

; 1159 : 				if(pkBuild2 && pkBuild2->getImprovement() == eExistingPlotImprovement)

	cmp	DWORD PTR _pkBuild2$217540[ebp], 0
	je	SHORT $LN7@AddImprovi
	mov	ecx, DWORD PTR _pkBuild2$217540[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, DWORD PTR _eExistingPlotImprovement$[ebp]
	jne	SHORT $LN7@AddImprovi

; 1160 : 				{
; 1161 : 					eExistingBuild = eBuild2;

	mov	eax, DWORD PTR _eBuild2$217534[ebp]
	mov	DWORD PTR _eExistingBuild$217533[ebp], eax

; 1162 : 					break;

	jmp	SHORT $LN8@AddImprovi
$LN7@AddImprovi:

; 1163 : 				}
; 1164 : 			}

	jmp	SHORT $LN9@AddImprovi
$LN8@AddImprovi:

; 1165 : 
; 1166 : 			if(eExistingBuild != NO_BUILD)

	cmp	DWORD PTR _eExistingBuild$217533[ebp], -1
	je	SHORT $LN11@AddImprovi

; 1167 : 			{
; 1168 : 				iInvestedImprovementTime = pPlot->getBuildTime(eExistingBuild, m_pPlayer->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T221434[ebp], eax
	mov	ecx, DWORD PTR $T221434[ebp]
	push	ecx
	mov	edx, DWORD PTR _eExistingBuild$217533[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	DWORD PTR _iInvestedImprovementTime$217531[ebp], eax
$LN11@AddImprovi:

; 1169 : 			}
; 1170 : 		}
; 1171 : 
; 1172 : 		int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, eBuild, DoesBuildHelpRush(pUnit, pPlot, eBuild), iInvestedImprovementTime + iMoveTurnsAway);

	mov	eax, DWORD PTR _iInvestedImprovementTime$217531[ebp]
	add	eax, DWORD PTR _iMoveTurnsAway$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
	mov	DWORD PTR _iBuildTimeWeight$217543[ebp], eax

; 1173 : 		iWeight += iBuildTimeWeight;

	mov	edx, DWORD PTR _iWeight$217529[ebp]
	add	edx, DWORD PTR _iBuildTimeWeight$217543[ebp]
	mov	DWORD PTR _iWeight$217529[ebp], edx

; 1174 : 		iWeight = CorrectWeight(iWeight);

	mov	eax, DWORD PTR _iWeight$217529[ebp]
	push	eax
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4
	mov	DWORD PTR _iWeight$217529[ebp], eax

; 1175 : 
; 1176 : 		iWeight += GetResourceWeight(eResource, eImprovement, pPlot->getNumResource());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	push	eax
	mov	ecx, DWORD PTR _eImprovement$217516[ebp]
	push	ecx
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ; CvBuilderTaskingAI::GetResourceWeight
	add	eax, DWORD PTR _iWeight$217529[ebp]
	mov	DWORD PTR _iWeight$217529[ebp], eax

; 1177 : 		iWeight = CorrectWeight(iWeight);

	mov	eax, DWORD PTR _iWeight$217529[ebp]
	push	eax
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4
	mov	DWORD PTR _iWeight$217529[ebp], eax

; 1178 : 
; 1179 : 		UpdateProjectedPlotYields(pPlot, eBuild);

	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::UpdateProjectedPlotYields

; 1180 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1181 : 		int iScore = ScorePlot(eBuild);
; 1182 : #else
; 1183 : 		int iScore = ScorePlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScorePlot@CvBuilderTaskingAI@@QAEHXZ	; CvBuilderTaskingAI::ScorePlot
	mov	DWORD PTR _iScore$217544[ebp], eax

; 1184 : #endif
; 1185 : 		if(iScore > 0)

	cmp	DWORD PTR _iScore$217544[ebp], 0
	jle	SHORT $LN5@AddImprovi

; 1186 : 		{
; 1187 : 			iWeight *= iScore;

	mov	eax, DWORD PTR _iWeight$217529[ebp]
	imul	eax, DWORD PTR _iScore$217544[ebp]
	mov	DWORD PTR _iWeight$217529[ebp], eax

; 1188 : 			iWeight = CorrectWeight(iWeight);

	mov	ecx, DWORD PTR _iWeight$217529[ebp]
	push	ecx
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4
	mov	DWORD PTR _iWeight$217529[ebp], eax
$LN5@AddImprovi:

; 1189 : 		}
; 1190 : 
; 1191 : 		{
; 1192 : 			CvCity* pLogCity = NULL;

	mov	DWORD PTR _pLogCity$217546[ebp], 0

; 1193 : 			int iProduction = pPlot->getFeatureProduction(eBuild, pUnit->getOwner(), &pLogCity);

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T221443[ebp], eax
	lea	ecx, DWORD PTR _pLogCity$217546[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221443[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
	mov	DWORD PTR _iProduction$217547[ebp], eax

; 1194 : 			if(DoesBuildHelpRush(pUnit, pPlot, eBuild))

	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	movzx	ecx, al
	test	ecx, ecx
	je	$LN4@AddImprovi

; 1195 : 			{
; 1196 : 				iWeight += iProduction; // a nominal benefit for choosing this production

	mov	edx, DWORD PTR _iWeight$217529[ebp]
	add	edx, DWORD PTR _iProduction$217547[ebp]
	mov	DWORD PTR _iWeight$217529[ebp], edx

; 1197 : 
; 1198 : 				if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN4@AddImprovi

; 1199 : 				{
; 1200 : 					CvString strLog;

	lea	ecx, DWORD PTR _strLog$217550[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1201 : 					strLog.Format("Helps rush, %d", iProduction);

	mov	edx, DWORD PTR _iProduction$217547[ebp]
	push	edx
	push	OFFSET ??_C@_0P@CFGIALGA@Helps?5rush?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strLog$217550[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1202 : 					LogInfo(strLog, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T221404[ebp], esp
	mov	DWORD PTR $T221452[ebp], eax
	lea	ecx, DWORD PTR _strLog$217550[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221452[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T221452[ebp]
	mov	DWORD PTR tv339[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1203 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217550[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@AddImprovi:

; 1204 : 			}
; 1205 : 		}
; 1206 : 
; 1207 : 		if(iWeight <= 0)

	cmp	DWORD PTR _iWeight$217529[ebp], 0
	jg	SHORT $LN2@AddImprovi

; 1208 : 		{
; 1209 : 			continue;

	jmp	$LN24@AddImprovi
$LN2@AddImprovi:

; 1210 : 		}
; 1211 : 
; 1212 : 		BuilderDirective directive;

	mov	DWORD PTR _directive$217554[ebp], 6
	mov	DWORD PTR _directive$217554[ebp+4], -1
	mov	DWORD PTR _directive$217554[ebp+8], -1
	or	eax, -1
	mov	WORD PTR _directive$217554[ebp+12], ax
	or	ecx, -1
	mov	WORD PTR _directive$217554[ebp+14], cx
	or	edx, -1
	mov	WORD PTR _directive$217554[ebp+16], dx

; 1213 : 		directive.m_eDirective = eDirectiveType;

	mov	eax, DWORD PTR _eDirectiveType$217528[ebp]
	mov	DWORD PTR _directive$217554[ebp], eax

; 1214 : 		directive.m_eBuild = eBuild;

	mov	ecx, DWORD PTR _eBuild$[ebp]
	mov	DWORD PTR _directive$217554[ebp+4], ecx

; 1215 : 		directive.m_eResource = eResource;

	mov	edx, DWORD PTR _eResource$[ebp]
	mov	DWORD PTR _directive$217554[ebp+8], edx

; 1216 : 		directive.m_sX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	WORD PTR _directive$217554[ebp+12], cx

; 1217 : 		directive.m_sY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	WORD PTR _directive$217554[ebp+14], ax

; 1218 : 		//directive.m_iGoldCost = m_pPlayer->getBuildCost(pPlot, eBuild);
; 1219 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;

	mov	cx, WORD PTR _iMoveTurnsAway$[ebp]
	mov	WORD PTR _directive$217554[ebp+16], cx

; 1220 : 
; 1221 : 		if(m_bLogging)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	$LN1@AddImprovi

; 1222 : 		{
; 1223 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217556[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1224 : 			strTemp.Format("%d, Build Time Weight, %d, Weight, %d", pUnit->GetID(), iBuildTimeWeight, iWeight);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T221478[ebp], edx
	mov	eax, DWORD PTR _iWeight$217529[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBuildTimeWeight$217543[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221478[ebp]
	push	edx
	push	OFFSET ??_C@_0CG@JJDEGAOH@?$CFd?0?5Build?5Time?5Weight?0?5?$CFd?0?5Weigh@
	lea	eax, DWORD PTR _strTemp$217556[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1225 : 			LogInfo(strTemp, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T221405[ebp], esp
	mov	DWORD PTR $T221483[ebp], eax
	lea	ecx, DWORD PTR _strTemp$217556[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221483[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T221483[ebp]
	mov	DWORD PTR tv344[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1226 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217556[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@AddImprovi:

; 1227 : 
; 1228 : 		m_aDirectives.push_back(directive, iWeight);

	mov	eax, DWORD PTR _iWeight$217529[ebp]
	push	eax
	lea	ecx, DWORD PTR _directive$217554[ebp]
	push	ecx
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
	jmp	$LN24@AddImprovi
$LN29@AddImprovi:

; 1229 : 	}
; 1230 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strLog$217550[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2:
	lea	ecx, DWORD PTR _strTemp$217556[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddImprovingResourcesDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddImprovingResourcesDirectives
PUBLIC	??_C@_0DC@BCGOLGBG@Weight?0Directive?5Score?5Added?0?$CFs?0@ ; `string'
PUBLIC	??_C@_0CF@NLMCLPJP@Weight?0Negative?5Score?0?$CFs?0?$CFi?0?0?0?$CFi@ ; `string'
PUBLIC	??_C@_0CB@MAEBKOFF@Weight?0Keep?5Forests?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@ ; `string'
PUBLIC	??_C@_0CC@HIPJBJHD@Weight?0Jungle?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CF@ ; `string'
PUBLIC	??_C@_0CB@LLJKFMHM@Weight?0Marsh?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@ ; `string'
PUBLIC	??_C@_0CH@CNEEGBKG@Weight?0?$CBpUnit?9?$DOcanBuild?$CI?$CJ?0?$CFs?0?0?0?0@ ; `string'
PUBLIC	??_C@_0EE@KLFGBAEO@Weight?0Improvement?5Type?5Blocked?5@ ; `string'
PUBLIC	??_C@_0EC@LANMMDIG@Weight?0eImprovement?5?$DN?$DN?5pPlot?9?$DOge@ ; `string'
PUBLIC	??_C@_0EL@LCKBJAAA@Weight?0?$CBpImprovement?9?$DOIsImprovem@ ; `string'
PUBLIC	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity
PUBLIC	__$ArrayPad$
EXTRN	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvPlot::ComputeCultureFromAdjacentImprovement
EXTRN	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetCultureAdjacentSameType
EXTRN	?GetYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChange
EXTRN	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z:PROC	; CvBuildInfo::isFeatureRemove
EXTRN	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z:PROC ; CvPlayer::isOption
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z:PROC ; CvPlot::GetAdjacentCity
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z:PROC ; CvPlot::isWithinTeamCityRadius
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
;	COMDAT ??_C@_0DC@BCGOLGBG@Weight?0Directive?5Score?5Added?0?$CFs?0@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
CONST	SEGMENT
??_C@_0DC@BCGOLGBG@Weight?0Directive?5Score?5Added?0?$CFs?0@ DB 'Weight,D'
	DB	'irective Score Added,%s,,,,%i, %i, %i, %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NLMCLPJP@Weight?0Negative?5Score?0?$CFs?0?$CFi?0?0?0?$CFi@
CONST	SEGMENT
??_C@_0CF@NLMCLPJP@Weight?0Negative?5Score?0?$CFs?0?$CFi?0?0?0?$CFi@ DB 'W'
	DB	'eight,Negative Score,%s,%i,,,%i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MAEBKOFF@Weight?0Keep?5Forests?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@
CONST	SEGMENT
??_C@_0CB@MAEBKOFF@Weight?0Keep?5Forests?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@ DB 'W'
	DB	'eight,Keep Forests,%s,,,,%i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HIPJBJHD@Weight?0Jungle?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CF@
CONST	SEGMENT
??_C@_0CC@HIPJBJHD@Weight?0Jungle?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CF@ DB 'W'
	DB	'eight,Jungle Remove,%s,,,,%i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LLJKFMHM@Weight?0Marsh?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@
CONST	SEGMENT
??_C@_0CB@LLJKFMHM@Weight?0Marsh?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@ DB 'W'
	DB	'eight,Marsh Remove,%s,,,,%i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CNEEGBKG@Weight?0?$CBpUnit?9?$DOcanBuild?$CI?$CJ?0?$CFs?0?0?0?0@
CONST	SEGMENT
??_C@_0CH@CNEEGBKG@Weight?0?$CBpUnit?9?$DOcanBuild?$CI?$CJ?0?$CFs?0?0?0?0@ DB 'W'
	DB	'eight,!pUnit->canBuild(),%s,,,,%i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@KLFGBAEO@Weight?0Improvement?5Type?5Blocked?5@
CONST	SEGMENT
??_C@_0EE@KLFGBAEO@Weight?0Improvement?5Type?5Blocked?5@ DB 'Weight,Impro'
	DB	'vement Type Blocked by Special Improvement,%s,,,,%i, %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@LANMMDIG@Weight?0eImprovement?5?$DN?$DN?5pPlot?9?$DOge@
CONST	SEGMENT
??_C@_0EC@LANMMDIG@Weight?0eImprovement?5?$DN?$DN?5pPlot?9?$DOge@ DB 'Wei'
	DB	'ght,eImprovement == pPlot->getImprovementType(),%s,%i,,,%i, %'
	DB	'i', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@LCKBJAAA@Weight?0?$CBpImprovement?9?$DOIsImprovem@
CONST	SEGMENT
??_C@_0EL@LCKBJAAA@Weight?0?$CBpImprovement?9?$DOIsImprovem@ DB 'Weight,!'
	DB	'pImprovement->IsImprovementResourceTrade(eResource),%s,%i,,,%'
	DB	'i, %i', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$16
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
tv770 = -716						; size = 4
tv765 = -712						; size = 4
tv760 = -708						; size = 4
tv755 = -704						; size = 4
tv750 = -700						; size = 4
tv745 = -696						; size = 4
tv740 = -692						; size = 4
tv735 = -688						; size = 4
tv730 = -684						; size = 4
_this$ = -680						; size = 4
$T221911 = -600						; size = 4
$T221906 = -596						; size = 4
$T221905 = -592						; size = 4
$T221888 = -585						; size = 1
$T221887 = -584						; size = 4
$T221883 = -580						; size = 4
$T221869 = -576						; size = 4
$T221864 = -572						; size = 4
$T221860 = -568						; size = 4
$T221856 = -564						; size = 4
$T221844 = -560						; size = 4
$T221839 = -556						; size = 4
$T221835 = -552						; size = 4
$T221831 = -548						; size = 4
$T221823 = -544						; size = 4
$T221819 = -540						; size = 4
$T221810 = -536						; size = 4
$T221809 = -532						; size = 4
$T221796 = -528						; size = 4
$T221791 = -524						; size = 4
$T221787 = -520						; size = 4
$T221783 = -516						; size = 4
$T221771 = -512						; size = 4
$T221766 = -508						; size = 4
$T221762 = -504						; size = 4
$T221758 = -500						; size = 4
_f$221750 = -493					; size = 1
$T221737 = -492						; size = 4
$T221732 = -488						; size = 4
$T221728 = -484						; size = 4
$T221724 = -480						; size = 4
$T221712 = -476						; size = 4
$T221707 = -472						; size = 4
$T221703 = -468						; size = 4
$T221699 = -464						; size = 4
$T221691 = -460						; size = 4
$T221687 = -456						; size = 4
$T221674 = -452						; size = 4
$T221669 = -448						; size = 4
$T221665 = -444						; size = 4
$T221661 = -440						; size = 4
$T221649 = -436						; size = 4
$T221644 = -432						; size = 4
$T221640 = -428						; size = 4
$T221636 = -424						; size = 4
_f$221628 = -417					; size = 1
$T221619 = -416						; size = 4
$T221610 = -412						; size = 4
$T221601 = -405						; size = 1
$T221600 = -404						; size = 4
$T221596 = -400						; size = 4
$T221595 = -396						; size = 4
$T221568 = -392						; size = 4
$T221567 = -388						; size = 4
$T221566 = -384						; size = 4
$T221565 = -380						; size = 4
$T221564 = -376						; size = 4
$T221563 = -372						; size = 4
$T221562 = -368						; size = 4
$T221561 = -364						; size = 4
$T221560 = -360						; size = 4
_strTemp$217658 = -356					; size = 28
_iAdjacentCulture$217652 = -328				; size = 4
_strTemp$217644 = -324					; size = 28
_strTemp$217638 = -296					; size = 28
_strTemp$217630 = -268					; size = 28
_strTemp$217624 = -240					; size = 28
_strTemp$217613 = -212					; size = 28
_strTemp$217608 = -184					; size = 28
_strTemp$217600 = -156					; size = 28
_strTemp$217593 = -128					; size = 28
__$ArrayPad$ = -100					; size = 4
_pkBuild$217584 = -96					; size = 4
_eDirectiveType$217647 = -92				; size = 4
_eImprovement$217586 = -88				; size = 4
_iWeight$217648 = -84					; size = 4
_pImprovement$217589 = -80				; size = 4
_directive$217656 = -76					; size = 20
_eFeature$217617 = -56					; size = 4
_iBuildTimeWeight$217654 = -52				; size = 4
_bWillRemoveForestOrJungle$217616 = -45			; size = 1
_iScore$217641 = -44					; size = 4
_pNextCity$217572 = -40					; size = 4
_eOriginalBuildType$ = -36				; size = 4
_pCity$ = -32						; size = 4
_eBuild$ = -28						; size = 4
_eExistingImprovement$ = -24				; size = 4
_eResource$ = -20					; size = 4
_iBuildIndex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddImprovingPlotsDirectives, COMDAT
; _this$ = ecx

; 1234 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 704				; 000002c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1235 : 	ImprovementTypes eExistingImprovement = pPlot->getImprovementType();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eExistingImprovement$[ebp], eax

; 1236 : 
; 1237 : 	// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1238 : 	if(eExistingImprovement != NO_IMPROVEMENT && pPlot->HasSpecialImprovement() && !pPlot->IsImprovementPillaged())

	cmp	DWORD PTR _eExistingImprovement$[ebp], -1
	je	SHORT $LN49@AddImprovi@2
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN49@AddImprovi@2
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN49@AddImprovi@2

; 1239 : 	{
; 1240 : 		return;

	jmp	$LN50@AddImprovi@2
$LN49@AddImprovi@2:

; 1241 : 	}
; 1242 : 
; 1243 : 	// if it's not within a city radius
; 1244 : 	if(!pPlot->isWithinTeamCityRadius(pUnit->getTeam()))

	push	-1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN48@AddImprovi@2

; 1245 : 	{
; 1246 : 		return;

	jmp	$LN50@AddImprovi@2
$LN48@AddImprovi@2:

; 1247 : 	}
; 1248 : 
; 1249 : 	// check to see if a non-bonus resource is here. if so, bail out!
; 1250 : 	ResourceTypes eResource = pPlot->getResourceType(m_pPlayer->getTeam());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T221595[ebp], ecx
	mov	edx, DWORD PTR $T221595[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T221596[ebp], eax
	mov	ecx, DWORD PTR $T221596[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 1251 : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN47@AddImprovi@2

; 1252 : 	{
; 1253 : 		if(GC.getResourceInfo(eResource)->getResourceUsage() != RESOURCEUSAGE_BONUS)

	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	test	eax, eax
	je	SHORT $LN47@AddImprovi@2

; 1254 : 		{
; 1255 : 			return;

	jmp	$LN50@AddImprovi@2
$LN47@AddImprovi@2:

; 1256 : 		}
; 1257 : 	}
; 1258 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1259 : 	FeatureTypes eFeature = pPlot->getFeatureType();
; 1260 : #endif
; 1261 : 
; 1262 : 	// celtic rule: if this is a forest tile next to a city, do not improve this tile with a normal improvement
; 1263 : 	if (m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest() && eExistingImprovement == NO_IMPROVEMENT)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T221600[ebp], eax
	mov	ecx, DWORD PTR $T221600[ebp]
	mov	dl, BYTE PTR [ecx+341]
	mov	BYTE PTR $T221601[ebp], dl
	movzx	eax, BYTE PTR $T221601[ebp]
	test	eax, eax
	je	SHORT $LN45@AddImprovi@2
	cmp	DWORD PTR _eExistingImprovement$[ebp], -1
	jne	SHORT $LN45@AddImprovi@2

; 1264 : 	{
; 1265 : 		CvCity* pNextCity = pPlot->GetAdjacentCity();

	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z ; CvPlot::GetAdjacentCity
	mov	DWORD PTR _pNextCity$217572[ebp], eax

; 1266 : 		if (pNextCity && pNextCity->getOwner() == m_pPlayer->GetID())

	cmp	DWORD PTR _pNextCity$217572[ebp], 0
	je	SHORT $LN45@AddImprovi@2
	mov	ecx, DWORD PTR _pNextCity$217572[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR $T221610[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T221619[ebp], edx
	mov	eax, DWORD PTR $T221610[ebp]
	cmp	eax, DWORD PTR $T221619[ebp]
	jne	SHORT $LN45@AddImprovi@2

; 1267 : 		{
; 1268 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1269 : 			if (eFeature == FEATURE_FOREST)
; 1270 : #else
; 1271 : 			if (pPlot->getFeatureType() == FEATURE_FOREST)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$221628[ebp], dl
	movsx	eax, BYTE PTR _f$221628[ebp]
	cmp	eax, 5
	jne	SHORT $LN45@AddImprovi@2

; 1272 : #endif
; 1273 : 			{
; 1274 : 				return;

	jmp	$LN50@AddImprovi@2
$LN45@AddImprovi@2:

; 1275 : 			}
; 1276 : 		}
; 1277 : 	}
; 1278 : 
; 1279 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 1280 : 	// check to see if someone already has a conflicting mission here
; 1281 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 1282 : 	{
; 1283 : 		int iLoop;
; 1284 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 1285 : 		{
; 1286 : 			if (pUnit == pLoopUnit)
; 1287 : 			{
; 1288 : 				continue;
; 1289 : 			}
; 1290 : 
; 1291 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 1292 : 			if (!pMissionPlot)
; 1293 : 			{
; 1294 : 				continue;
; 1295 : 			}
; 1296 : 
; 1297 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 1298 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 1299 : 			{
; 1300 : 				continue;
; 1301 : 			}
; 1302 : 
; 1303 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 1304 : 			{
; 1305 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 1306 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 1307 : 				if (pkBuild != NULL)
; 1308 : 				{
; 1309 : 					ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();
; 1310 : 					if (eImprovement != NO_IMPROVEMENT || (eOtherBuild == m_eRepairBuild && eExistingImprovement != NO_IMPROVEMENT))
; 1311 : 					{
; 1312 : 						if (m_bLogging)
; 1313 : 						{
; 1314 : 							CvString strLog;
; 1315 : 							strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 1316 : 							LogInfo(strLog, m_pPlayer, true);
; 1317 : 						}
; 1318 : 						return;
; 1319 : 					}
; 1320 : 				}
; 1321 : 			}
; 1322 : 		}
; 1323 : 	}
; 1324 : #endif
; 1325 : 
; 1326 : 	CvCity* pCity = GetWorkingCity(pPlot);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity
	mov	DWORD PTR _pCity$[ebp], eax

; 1327 : #ifndef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1328 : 	if(!pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	SHORT $LN42@AddImprovi@2

; 1329 : 	{
; 1330 : 		return;

	jmp	$LN50@AddImprovi@2
$LN42@AddImprovi@2:

; 1331 : 	}
; 1332 : #endif
; 1333 : 
; 1334 : 	// loop through the build types to find one that we can use
; 1335 : 	BuildTypes eBuild;
; 1336 : 	BuildTypes eOriginalBuildType;
; 1337 : #ifdef AUI_WARNING_FIXES
; 1338 : 	uint iBuildIndex;
; 1339 : #else
; 1340 : 	int iBuildIndex;
; 1341 : #endif
; 1342 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1343 : 	int iLoopScore;
; 1344 : 	int iBestUniqueImprovementWeight = 0;
; 1345 : 	for (uint iI = 0; iI < m_pPlayer->GetNumUniqueImprovements(); iI++)
; 1346 : 	{
; 1347 : 		ImprovementTypes eUniqueImprovement = m_pPlayer->GetUniqueImprovement(iI);
; 1348 : 		if (eUniqueImprovement != NO_IMPROVEMENT)
; 1349 : 		{
; 1350 : 			CvImprovementEntry* pUniqueImprovement = GC.getImprovementInfo(eUniqueImprovement);
; 1351 : 			if (pUniqueImprovement && pUniqueImprovement->IsRequiresFeature() && pUniqueImprovement->GetFeatureMakesValid(eFeature))
; 1352 : 			{
; 1353 : 				eBuild = m_pPlayer->GetUniqueImprovementBuild(iI);
; 1354 : #ifdef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1355 : 				iLoopScore = 0;
; 1356 : 				if (pCity)
; 1357 : 				{
; 1358 : 					UpdateProjectedPlotYields(pPlot, eBuild);
; 1359 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1360 : 					iLoopScore = ScorePlot(eBuild);
; 1361 : #else
; 1362 : 					iLoopScore = ScorePlot();
; 1363 : #endif
; 1364 : 				}
; 1365 : 				if (!pCity || iLoopScore > 0)
; 1366 : 				{
; 1367 : 					int iBaseDefenseBonus = (pPlot->isHills() || pPlot->isMountain() ? GC.getHILLS_EXTRA_DEFENSE() : GC.getFeatureInfo(eFeature)->getDefenseModifier());
; 1368 : 					iLoopScore += (pUniqueImprovement->GetDefenseModifier() + iBaseDefenseBonus) * pPlot->getStrategicValue() / (100 * GC.getCHOKEPOINT_STRATEGIC_VALUE());
; 1369 : 				}
; 1370 : #else
; 1371 : 				UpdateProjectedPlotYields(pPlot, eBuild);
; 1372 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1373 : 				iLoopScore = ScorePlot(eBuild);
; 1374 : #else
; 1375 : 				iLoopScore = ScorePlot();
; 1376 : #endif
; 1377 : #endif
; 1378 : 				int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS();
; 1379 : 				iWeight = GetBuildCostWeight(iWeight, pPlot, eBuild);
; 1380 : 				iWeight += GetBuildTimeWeight(pUnit, pPlot, eBuild, DoesBuildHelpRush(pUnit, pPlot, eBuild), iMoveTurnsAway);
; 1381 : 				iWeight *= iLoopScore;
; 1382 : 				iWeight = CorrectWeight(iWeight);
; 1383 : 
; 1384 : 				if (iWeight > iBestUniqueImprovementWeight)
; 1385 : 					iBestUniqueImprovementWeight = iWeight;
; 1386 : 			}
; 1387 : 		}
; 1388 : 	}
; 1389 : #endif
; 1390 : 	for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$[ebp], 0
	jmp	SHORT $LN41@AddImprovi@2
$LN40@AddImprovi@2:
	mov	edx, DWORD PTR _iBuildIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _iBuildIndex$[ebp], edx
$LN41@AddImprovi@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$[ebp], eax
	jge	$LN50@AddImprovi@2

; 1391 : 	{
; 1392 : 		eBuild = (BuildTypes)iBuildIndex;

	mov	eax, DWORD PTR _iBuildIndex$[ebp]
	mov	DWORD PTR _eBuild$[ebp], eax

; 1393 : 		eOriginalBuildType = eBuild;

	mov	ecx, DWORD PTR _eBuild$[ebp]
	mov	DWORD PTR _eOriginalBuildType$[ebp], ecx

; 1394 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217584[ebp], eax

; 1395 : 		if(pkBuild == NULL)

	cmp	DWORD PTR _pkBuild$217584[ebp], 0
	jne	SHORT $LN38@AddImprovi@2

; 1396 : 		{
; 1397 : 			continue;

	jmp	SHORT $LN40@AddImprovi@2
$LN38@AddImprovi@2:

; 1398 : 		}
; 1399 : 
; 1400 : 		ImprovementTypes eImprovement = (ImprovementTypes)pkBuild->getImprovement();

	mov	ecx, DWORD PTR _pkBuild$217584[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$217586[ebp], eax

; 1401 : 		if(eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$217586[ebp], -1
	jne	SHORT $LN37@AddImprovi@2

; 1402 : 		{
; 1403 : 			continue;

	jmp	SHORT $LN40@AddImprovi@2
$LN37@AddImprovi@2:

; 1404 : 		}
; 1405 : 
; 1406 : 		CvImprovementEntry* pImprovement = GC.getImprovementInfo(eImprovement);

	mov	eax, DWORD PTR _eImprovement$217586[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pImprovement$217589[ebp], eax

; 1407 : 
; 1408 : #ifdef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1409 : 		// If the improvement has no defensive effect, skip it
; 1410 : 		if (pImprovement->GetDefenseModifier() == 0 && !pCity)
; 1411 : 		{
; 1412 : 			continue;
; 1413 : 		}
; 1414 : #else
; 1415 : 		// if this improvement has a defense modifier, ignore it for now
; 1416 : 		//if(pImprovement->GetDefenseModifier() > 0)
; 1417 : 		//{
; 1418 : 		//	continue;
; 1419 : 		//}
; 1420 : #endif
; 1421 : 
; 1422 : #ifndef AUI_WORKER_FIX_IMPROVING_PLOTS_DIRECTIVE_DONT_REQUIRE_BONUS_RESOURCE_UNLOCKER
; 1423 : 		// for bonus resources, check to see if this is the improvement that connects it
; 1424 : 		if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	$LN36@AddImprovi@2

; 1425 : 		{
; 1426 : 			if(!pImprovement->IsImprovementResourceTrade(eResource))

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pImprovement$217589[ebp]
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	movzx	edx, al
	test	edx, edx
	jne	$LN36@AddImprovi@2

; 1427 : 			{
; 1428 : 				if(m_bLogging){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN34@AddImprovi@2

; 1429 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217593[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1430 : 					strTemp.Format("Weight,!pImprovement->IsImprovementResourceTrade(eResource),%s,%i,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), eResource, pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T221636[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T221640[ebp], edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221644[ebp], eax
	mov	ecx, DWORD PTR $T221636[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221640[ebp]
	push	edx
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221644[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0EL@LCKBJAAA@Weight?0?$CBpImprovement?9?$DOIsImprovem@
	lea	ecx, DWORD PTR _strTemp$217593[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1431 : 					LogInfo(strTemp, m_pPlayer);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T221560[ebp], esp
	mov	DWORD PTR $T221649[ebp], ecx
	lea	edx, DWORD PTR _strTemp$217593[ebp]
	push	edx
	mov	ecx, DWORD PTR $T221649[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T221649[ebp]
	mov	DWORD PTR tv730[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1432 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217593[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN34@AddImprovi@2:

; 1433 : 				continue;

	jmp	$LN40@AddImprovi@2
$LN36@AddImprovi@2:

; 1434 : 			}
; 1435 : 		}
; 1436 : #endif
; 1437 : 
; 1438 : 		if(eImprovement == pPlot->getImprovementType())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	DWORD PTR _eImprovement$217586[ebp], eax
	jne	$LN33@AddImprovi@2

; 1439 : 		{
; 1440 : 			if(pPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN32@AddImprovi@2

; 1441 : 			{
; 1442 : 				eBuild = m_eRepairBuild;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _eBuild$[ebp], eax

; 1443 : 			}
; 1444 : 			else

	jmp	$LN31@AddImprovi@2
$LN32@AddImprovi@2:

; 1445 : 			{
; 1446 : 				if(m_bLogging){

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+58392]
	test	edx, edx
	je	$LN30@AddImprovi@2

; 1447 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217600[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1448 : 					strTemp.Format("Weight,eImprovement == pPlot->getImprovementType(),%s,%i,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), eImprovement, pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T221661[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T221665[ebp], eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221669[ebp], eax
	mov	edx, DWORD PTR $T221661[ebp]
	push	edx
	mov	eax, DWORD PTR $T221665[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$217586[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221669[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0EC@LANMMDIG@Weight?0eImprovement?5?$DN?$DN?5pPlot?9?$DOge@
	lea	edx, DWORD PTR _strTemp$217600[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1449 : 					LogInfo(strTemp, m_pPlayer);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T221561[ebp], esp
	mov	DWORD PTR $T221674[ebp], edx
	lea	eax, DWORD PTR _strTemp$217600[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221674[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T221674[ebp]
	mov	DWORD PTR tv735[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1450 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217600[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN30@AddImprovi@2:

; 1451 : 				continue;

	jmp	$LN40@AddImprovi@2
$LN31@AddImprovi@2:

; 1452 : 			}
; 1453 : 		}
; 1454 : 		else

	jmp	$LN29@AddImprovi@2
$LN33@AddImprovi@2:

; 1455 : 		{
; 1456 : 			// Do we have a special improvement here? (great person improvement, gifted improvement from major civ)
; 1457 : 			if (eExistingImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eExistingImprovement$[ebp], -1
	je	$LN29@AddImprovi@2

; 1458 : 			{
; 1459 : 				if (pPlot->HasSpecialImprovement() || GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_SAFE_AUTOMATION))

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?HasSpecialImprovement@CvPlot@@QBE_NXZ	; CvPlot::HasSpecialImprovement
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN26@AddImprovi@2
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T221687[ebp], ecx
	mov	edx, DWORD PTR $T221687[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221691[ebp], edx
	push	5
	mov	ecx, DWORD PTR $T221691[ebp]
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	movzx	eax, al
	test	eax, eax
	je	$LN29@AddImprovi@2
$LN26@AddImprovi@2:

; 1460 : 				{
; 1461 : 					if(m_bLogging){

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+58392]
	test	edx, edx
	je	$LN25@AddImprovi@2

; 1462 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217608[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 1463 : 						strTemp.Format("Weight,Improvement Type Blocked by Special Improvement,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T221699[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T221703[ebp], eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221707[ebp], eax
	mov	edx, DWORD PTR $T221699[ebp]
	push	edx
	mov	eax, DWORD PTR $T221703[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221707[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0EE@KLFGBAEO@Weight?0Improvement?5Type?5Blocked?5@
	lea	ecx, DWORD PTR _strTemp$217608[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1464 : 						LogInfo(strTemp, m_pPlayer);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T221562[ebp], esp
	mov	DWORD PTR $T221712[ebp], ecx
	lea	edx, DWORD PTR _strTemp$217608[ebp]
	push	edx
	mov	ecx, DWORD PTR $T221712[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T221712[ebp]
	mov	DWORD PTR tv740[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1465 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217608[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN25@AddImprovi@2:

; 1466 : 					continue;

	jmp	$LN40@AddImprovi@2
$LN29@AddImprovi@2:

; 1467 : 				}
; 1468 : 			}
; 1469 : 		}
; 1470 : 
; 1471 : 		// Only check to make sure our unit can build this after possibly switching this to a repair build in the block of code above
; 1472 : 		if(!pUnit->canBuild(pPlot, eBuild))

	push	1
	push	0
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	eax, al
	test	eax, eax
	jne	$LN24@AddImprovi@2

; 1473 : 		{
; 1474 : 			if(m_bLogging){

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+58392]
	test	edx, edx
	je	$LN23@AddImprovi@2

; 1475 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217613[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 1476 : 				strTemp.Format("Weight,!pUnit->canBuild(),%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T221724[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T221728[ebp], eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221732[ebp], eax
	mov	edx, DWORD PTR $T221724[ebp]
	push	edx
	mov	eax, DWORD PTR $T221728[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221732[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CH@CNEEGBKG@Weight?0?$CBpUnit?9?$DOcanBuild?$CI?$CJ?0?$CFs?0?0?0?0@
	lea	ecx, DWORD PTR _strTemp$217613[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1477 : 				LogInfo(strTemp, m_pPlayer);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T221563[ebp], esp
	mov	DWORD PTR $T221737[ebp], ecx
	lea	edx, DWORD PTR _strTemp$217613[ebp]
	push	edx
	mov	ecx, DWORD PTR $T221737[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T221737[ebp]
	mov	DWORD PTR tv745[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1478 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217613[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN23@AddImprovi@2:

; 1479 : 			continue;

	jmp	$LN40@AddImprovi@2
$LN24@AddImprovi@2:

; 1480 : 		}
; 1481 : 
; 1482 : 		bool bWillRemoveForestOrJungle = false;

	mov	BYTE PTR _bWillRemoveForestOrJungle$217616[ebp], 0

; 1483 : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1484 : 		FeatureTypes eFeature = pPlot->getFeatureType();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$221750[ebp], dl
	movsx	eax, BYTE PTR _f$221750[ebp]
	mov	DWORD PTR _eFeature$217617[ebp], eax

; 1485 : #endif
; 1486 : 		if(eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE)

	cmp	DWORD PTR _eFeature$217617[ebp], 5
	je	SHORT $LN21@AddImprovi@2
	cmp	DWORD PTR _eFeature$217617[ebp], 1
	jne	SHORT $LN22@AddImprovi@2
$LN21@AddImprovi@2:

; 1487 : 		{
; 1488 : 			if(pkBuild->isFeatureRemove(eFeature))

	mov	ecx, DWORD PTR _eFeature$217617[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkBuild$217584[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@AddImprovi@2

; 1489 : 			{
; 1490 : 				bWillRemoveForestOrJungle = true;

	mov	BYTE PTR _bWillRemoveForestOrJungle$217616[ebp], 1
$LN22@AddImprovi@2:

; 1491 : 			}
; 1492 : 		}
; 1493 : 
; 1494 : #ifndef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1495 : 		// special case for Dutch
; 1496 : 		if (m_bKeepMarshes && eFeature == FEATURE_MARSH)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58460]
	test	ecx, ecx
	je	$LN19@AddImprovi@2
	cmp	DWORD PTR _eFeature$217617[ebp], 2
	jne	$LN19@AddImprovi@2

; 1497 : 		{
; 1498 : 			if (pkBuild->isFeatureRemove(FEATURE_MARSH))

	push	2
	mov	ecx, DWORD PTR _pkBuild$217584[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	edx, al
	test	edx, edx
	je	$LN19@AddImprovi@2

; 1499 : 			{
; 1500 : 				if(m_bLogging){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN17@AddImprovi@2

; 1501 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217624[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 1502 : 					strTemp.Format("Weight,Marsh Remove,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T221758[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T221762[ebp], edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221766[ebp], eax
	mov	ecx, DWORD PTR $T221758[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221762[ebp]
	push	edx
	mov	ecx, DWORD PTR $T221766[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CB@LLJKFMHM@Weight?0Marsh?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@
	lea	eax, DWORD PTR _strTemp$217624[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1503 : 					LogInfo(strTemp, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T221564[ebp], esp
	mov	DWORD PTR $T221771[ebp], eax
	lea	ecx, DWORD PTR _strTemp$217624[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221771[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T221771[ebp]
	mov	DWORD PTR tv750[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1504 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217624[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@AddImprovi@2:

; 1505 : 				continue;

	jmp	$LN40@AddImprovi@2
$LN19@AddImprovi@2:

; 1506 : 			}
; 1507 : 		}
; 1508 : 
; 1509 : 		// special case for Brazil
; 1510 : 		if (m_bKeepJungle && eFeature == FEATURE_JUNGLE)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58461]
	test	ecx, ecx
	je	$LN194@AddImprovi@2
	cmp	DWORD PTR _eFeature$217617[ebp], 1
	jne	$LN194@AddImprovi@2

; 1511 : 		{
; 1512 : 			if (pkBuild->isFeatureRemove(FEATURE_JUNGLE))

	push	1
	mov	ecx, DWORD PTR _pkBuild$217584[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	edx, al
	test	edx, edx
	je	$LN194@AddImprovi@2

; 1513 : 			{
; 1514 : 				if(m_bLogging){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN14@AddImprovi@2

; 1515 : 					CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217630[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 1516 : 					strTemp.Format("Weight,Jungle Remove,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T221783[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T221787[ebp], edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221791[ebp], eax
	mov	ecx, DWORD PTR $T221783[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221787[ebp]
	push	edx
	mov	ecx, DWORD PTR $T221791[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CC@HIPJBJHD@Weight?0Jungle?5Remove?0?$CFs?0?0?0?0?$CFi?0?5?$CF@
	lea	eax, DWORD PTR _strTemp$217630[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1517 : 					LogInfo(strTemp, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T221565[ebp], esp
	mov	DWORD PTR $T221796[ebp], eax
	lea	ecx, DWORD PTR _strTemp$217630[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221796[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T221796[ebp]
	mov	DWORD PTR tv755[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1518 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217630[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@AddImprovi@2:

; 1519 : 				if (pPlot->getResourceType(m_pPlayer->getTeam()) == NO_RESOURCE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T221809[ebp], ecx
	mov	edx, DWORD PTR $T221809[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T221810[ebp], eax
	mov	ecx, DWORD PTR $T221810[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	jne	SHORT $LN194@AddImprovi@2

; 1520 : 				{
; 1521 : 					continue;

	jmp	$LN40@AddImprovi@2

; 1522 : 				}
; 1523 : 			}
; 1524 : 		}
; 1525 : #endif
; 1526 : 
; 1527 : 		if(GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_LEAVE_FORESTS))

$LN194@AddImprovi@2:
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T221819[ebp], eax
	mov	ecx, DWORD PTR $T221819[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T221823[ebp], ecx
	push	7
	mov	ecx, DWORD PTR $T221823[ebp]
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	movzx	edx, al
	test	edx, edx
	je	$LN12@AddImprovi@2

; 1528 : 		{
; 1529 : 			if(eFeature != NO_FEATURE)

	cmp	DWORD PTR _eFeature$217617[ebp], -1
	je	$LN12@AddImprovi@2

; 1530 : 			{
; 1531 : 				if(pkBuild->isFeatureRemove(eFeature))

	mov	eax, DWORD PTR _eFeature$217617[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkBuild$217584[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@AddImprovi@2

; 1532 : 				{
; 1533 : 					if(m_bLogging){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	$LN9@AddImprovi@2

; 1534 : 						CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217638[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 1535 : 						strTemp.Format("Weight,Keep Forests,%s,,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T221831[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T221835[ebp], ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221839[ebp], eax
	mov	eax, DWORD PTR $T221831[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221835[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221839[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CB@MAEBKOFF@Weight?0Keep?5Forests?0?$CFs?0?0?0?0?$CFi?0?5?$CFi@
	lea	edx, DWORD PTR _strTemp$217638[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1536 : 						LogInfo(strTemp, m_pPlayer);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T221566[ebp], esp
	mov	DWORD PTR $T221844[ebp], edx
	lea	eax, DWORD PTR _strTemp$217638[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221844[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T221844[ebp]
	mov	DWORD PTR tv760[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1537 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217638[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@AddImprovi@2:

; 1538 : 					continue;

	jmp	$LN40@AddImprovi@2
$LN12@AddImprovi@2:

; 1539 : 				}
; 1540 : 			}
; 1541 : 		}
; 1542 : 
; 1543 : #ifdef AUI_WORKER_ADD_IMPROVING_PLOTS_DIRECTIVE_DEFENSIVES
; 1544 : 		int iScore = 0;
; 1545 : 		if (pCity)
; 1546 : 		{
; 1547 : 			UpdateProjectedPlotYields(pPlot, eBuild);
; 1548 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1549 : 			iScore = ScorePlot(eBuild);
; 1550 : #else
; 1551 : 			iScore = ScorePlot();
; 1552 : #endif
; 1553 : 		}
; 1554 : 		if (!pCity || iScore > 0)
; 1555 : 		{
; 1556 : 			int iBaseDefenseBonus = (pPlot->isHills() || pPlot->isMountain() ? GC.getHILLS_EXTRA_DEFENSE() :
; 1557 : 				(eFeature != NO_FEATURE && !pkBuild->isFeatureRemove(eFeature) ? GC.getFeatureInfo(eFeature)->getDefenseModifier() :
; 1558 : 					GC.getTerrainInfo(pPlot->getTerrainType())->getDefenseModifier() + GC.getFLAT_LAND_EXTRA_DEFENSE()));
; 1559 : 			iScore += (pImprovement->GetDefenseModifier() + iBaseDefenseBonus) * pPlot->getStrategicValue() / (100 * GC.getCHOKEPOINT_STRATEGIC_VALUE());
; 1560 : 		}
; 1561 : #else
; 1562 : 		UpdateProjectedPlotYields(pPlot, eBuild);

	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::UpdateProjectedPlotYields

; 1563 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 1564 : 		int iScore = ScorePlot(eBuild);
; 1565 : #else
; 1566 : 		int iScore = ScorePlot();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScorePlot@CvBuilderTaskingAI@@QAEHXZ	; CvBuilderTaskingAI::ScorePlot
	mov	DWORD PTR _iScore$217641[ebp], eax

; 1567 : #endif
; 1568 : #endif
; 1569 : 
; 1570 : 		// if we're going backward, bail out!
; 1571 : 		if(iScore <= 0)

	cmp	DWORD PTR _iScore$217641[ebp], 0
	jg	$LN8@AddImprovi@2

; 1572 : 		{
; 1573 : 			if(m_bLogging){

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+58392]
	test	edx, edx
	je	$LN7@AddImprovi@2

; 1574 : 				CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217644[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 1575 : 				strTemp.Format("Weight,Negative Score,%s,%i,,,%i, %i", GC.getBuildInfo(eBuild)->GetType(), iScore, pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T221856[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T221860[ebp], eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221864[ebp], eax
	mov	edx, DWORD PTR $T221856[ebp]
	push	edx
	mov	eax, DWORD PTR $T221860[ebp]
	push	eax
	mov	ecx, DWORD PTR _iScore$217641[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221864[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CF@NLMCLPJP@Weight?0Negative?5Score?0?$CFs?0?$CFi?0?0?0?$CFi@
	lea	edx, DWORD PTR _strTemp$217644[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1576 : 				LogInfo(strTemp, m_pPlayer);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T221567[ebp], esp
	mov	DWORD PTR $T221869[ebp], edx
	lea	eax, DWORD PTR _strTemp$217644[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221869[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T221869[ebp]
	mov	DWORD PTR tv765[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1577 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217644[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@AddImprovi@2:

; 1578 : 			continue;

	jmp	$LN40@AddImprovi@2
$LN8@AddImprovi@2:

; 1579 : 		}
; 1580 : 
; 1581 : 		BuilderDirective::BuilderDirectiveType eDirectiveType = BuilderDirective::BUILD_IMPROVEMENT;

	mov	DWORD PTR _eDirectiveType$217647[ebp], 1

; 1582 : 		int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_IMPROVEMENTS();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2140
	mov	DWORD PTR _iWeight$217648[ebp], edx

; 1583 : 		if(eBuild == m_eRepairBuild)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eBuild$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN6@AddImprovi@2

; 1584 : 		{
; 1585 : 			eDirectiveType = BuilderDirective::REPAIR;

	mov	DWORD PTR _eDirectiveType$217647[ebp], 3

; 1586 : 			iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152
	mov	DWORD PTR _iWeight$217648[ebp], edx

; 1587 : 		}
; 1588 : 		else if(pImprovement->GetYieldChange(YIELD_CULTURE) > 0)

	jmp	SHORT $LN5@AddImprovi@2
$LN6@AddImprovi@2:
	push	4
	mov	ecx, DWORD PTR _pImprovement$217589[ebp]
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN5@AddImprovi@2

; 1589 : 		{
; 1590 : 			iWeight = GC.getBUILDER_TASKING_BASELINE_ADDS_CULTURE() * GC.getImprovementInfo(eImprovement)->GetYieldChange(YIELD_CULTURE);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2160
	mov	DWORD PTR $T221883[ebp], eax
	push	4
	mov	ecx, DWORD PTR _eImprovement$217586[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	imul	eax, DWORD PTR $T221883[ebp]
	mov	DWORD PTR _iWeight$217648[ebp], eax

; 1591 : 			int iAdjacentCulture = pImprovement->GetCultureAdjacentSameType();

	mov	ecx, DWORD PTR _pImprovement$217589[ebp]
	call	?GetCultureAdjacentSameType@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetCultureAdjacentSameType
	mov	DWORD PTR _iAdjacentCulture$217652[ebp], eax

; 1592 : 
; 1593 : 			if(iAdjacentCulture > 0)

	cmp	DWORD PTR _iAdjacentCulture$217652[ebp], 0
	jle	SHORT $LN5@AddImprovi@2

; 1594 : 			{
; 1595 : 				iScore *= (1 + pPlot->ComputeCultureFromAdjacentImprovement(*pImprovement, eImprovement));

	mov	edx, DWORD PTR _eImprovement$217586[ebp]
	push	edx
	mov	eax, DWORD PTR _pImprovement$217589[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?ComputeCultureFromAdjacentImprovement@CvPlot@@QBEHAAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvPlot::ComputeCultureFromAdjacentImprovement
	add	eax, 1
	imul	eax, DWORD PTR _iScore$217641[ebp]
	mov	DWORD PTR _iScore$217641[ebp], eax
$LN5@AddImprovi@2:

; 1596 : 			}
; 1597 : 		}
; 1598 : 
; 1599 : 		iWeight = GetBuildCostWeight(iWeight, pPlot, eBuild);

	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _iWeight$217648[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
	mov	DWORD PTR _iWeight$217648[ebp], eax

; 1600 : 		int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, eBuild, DoesBuildHelpRush(pUnit, pPlot, eBuild), iMoveTurnsAway);

	mov	ecx, DWORD PTR _iMoveTurnsAway$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
	mov	DWORD PTR _iBuildTimeWeight$217654[ebp], eax

; 1601 : 		iWeight += iBuildTimeWeight;

	mov	eax, DWORD PTR _iWeight$217648[ebp]
	add	eax, DWORD PTR _iBuildTimeWeight$217654[ebp]
	mov	DWORD PTR _iWeight$217648[ebp], eax

; 1602 : 		iWeight *= iScore;

	mov	ecx, DWORD PTR _iWeight$217648[ebp]
	imul	ecx, DWORD PTR _iScore$217641[ebp]
	mov	DWORD PTR _iWeight$217648[ebp], ecx

; 1603 : 
; 1604 : 		if(m_pPlayer->GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad() && bWillRemoveForestOrJungle)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T221887[ebp], eax
	mov	eax, DWORD PTR $T221887[ebp]
	mov	cl, BYTE PTR [eax+333]
	mov	BYTE PTR $T221888[ebp], cl
	movzx	edx, BYTE PTR $T221888[ebp]
	test	edx, edx
	je	SHORT $LN2@AddImprovi@2
	movzx	eax, BYTE PTR _bWillRemoveForestOrJungle$217616[ebp]
	test	eax, eax
	je	SHORT $LN2@AddImprovi@2

; 1605 : 		{
; 1606 : 			iWeight = iWeight / 4;

	mov	eax, DWORD PTR _iWeight$217648[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _iWeight$217648[ebp], eax
$LN2@AddImprovi@2:

; 1607 : 		}
; 1608 : 
; 1609 : 		iWeight = CorrectWeight(iWeight);

	mov	ecx, DWORD PTR _iWeight$217648[ebp]
	push	ecx
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4
	mov	DWORD PTR _iWeight$217648[ebp], eax

; 1610 : 
; 1611 : #ifdef AUI_WORKER_UNHARDCODE_NO_REMOVE_FEATURE_THAT_IS_REQUIRED_FOR_UNIQUE_IMPROVEMENT
; 1612 : 		if (iWeight < iBestUniqueImprovementWeight && eFeature != NO_FEATURE && pkBuild->isFeatureRemove(eFeature))
; 1613 : 			continue;
; 1614 : #endif
; 1615 : 
; 1616 : 		BuilderDirective directive;

	mov	DWORD PTR _directive$217656[ebp], 6
	mov	DWORD PTR _directive$217656[ebp+4], -1
	mov	DWORD PTR _directive$217656[ebp+8], -1
	or	edx, -1
	mov	WORD PTR _directive$217656[ebp+12], dx
	or	eax, -1
	mov	WORD PTR _directive$217656[ebp+14], ax
	or	ecx, -1
	mov	WORD PTR _directive$217656[ebp+16], cx

; 1617 : 
; 1618 : 		directive.m_eDirective = eDirectiveType;

	mov	edx, DWORD PTR _eDirectiveType$217647[ebp]
	mov	DWORD PTR _directive$217656[ebp], edx

; 1619 : 		directive.m_eBuild = eBuild;

	mov	eax, DWORD PTR _eBuild$[ebp]
	mov	DWORD PTR _directive$217656[ebp+4], eax

; 1620 : 		directive.m_eResource = NO_RESOURCE;

	mov	DWORD PTR _directive$217656[ebp+8], -1

; 1621 : 		directive.m_sX = pPlot->getX();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	WORD PTR _directive$217656[ebp+12], dx

; 1622 : 		directive.m_sY = pPlot->getY();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	WORD PTR _directive$217656[ebp+14], cx

; 1623 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;

	mov	dx, WORD PTR _iMoveTurnsAway$[ebp]
	mov	WORD PTR _directive$217656[ebp+16], dx

; 1624 : 
; 1625 : 		if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN1@AddImprovi@2

; 1626 : 		{
; 1627 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217658[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 8

; 1628 : 			strTemp.Format("Weight,Directive Score Added,%s,,,,%i, %i, %i, %d", GC.getBuildInfo(eBuild)->GetType(), directive.m_sX, directive.m_sY, directive.m_sMoveTurnsAway, iWeight);

	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T221905[ebp], eax
	mov	ecx, DWORD PTR $T221905[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T221906[ebp], eax
	mov	eax, DWORD PTR _iWeight$217648[ebp]
	push	eax
	movsx	ecx, WORD PTR _directive$217656[ebp+16]
	push	ecx
	movsx	edx, WORD PTR _directive$217656[ebp+14]
	push	edx
	movsx	eax, WORD PTR _directive$217656[ebp+12]
	push	eax
	mov	ecx, DWORD PTR $T221906[ebp]
	push	ecx
	push	OFFSET ??_C@_0DC@BCGOLGBG@Weight?0Directive?5Score?5Added?0?$CFs?0@
	lea	edx, DWORD PTR _strTemp$217658[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 1629 : 			LogInfo(strTemp, m_pPlayer);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T221568[ebp], esp
	mov	DWORD PTR $T221911[ebp], edx
	lea	eax, DWORD PTR _strTemp$217658[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221911[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T221911[ebp]
	mov	DWORD PTR tv770[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 1630 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217658[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@AddImprovi@2:

; 1631 : 
; 1632 : 		m_aDirectives.push_back(directive, iWeight);

	mov	edx, DWORD PTR _iWeight$217648[ebp]
	push	edx
	lea	eax, DWORD PTR _directive$217656[ebp]
	push	eax
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
	jmp	$LN40@AddImprovi@2
$LN50@AddImprovi@2:

; 1633 : 	}
; 1634 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strTemp$217593[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$2:
	lea	ecx, DWORD PTR _strTemp$217600[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$4:
	lea	ecx, DWORD PTR _strTemp$217608[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$6:
	lea	ecx, DWORD PTR _strTemp$217613[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$8:
	lea	ecx, DWORD PTR _strTemp$217624[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$10:
	lea	ecx, DWORD PTR _strTemp$217630[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$12:
	lea	ecx, DWORD PTR _strTemp$217638[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$14:
	lea	ecx, DWORD PTR _strTemp$217644[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$16:
	lea	ecx, DWORD PTR _strTemp$217658[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-708]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddImprovingPlotsDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddImprovingPlotsDirectives
PUBLIC	??_C@_0DE@HOCAFBDO@AddRouteDirectives?0?5adding?0?5x?3?5?$CF@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?GetBuilds@CvUnitEntry@@QBE_NH@Z:PROC		; CvUnitEntry::GetBuilds
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ:PROC ; CvPlot::GetBuilderAIScratchPadRoute
;	COMDAT ??_C@_0DE@HOCAFBDO@AddRouteDirectives?0?5adding?0?5x?3?5?$CF@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
CONST	SEGMENT
??_C@_0DE@HOCAFBDO@AddRouteDirectives?0?5adding?0?5x?3?5?$CF@ DB 'AddRout'
	DB	'eDirectives, adding, x: %d y: %d, Weight, %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
__ehfuncinfo$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
tv247 = -220						; size = 4
tv88 = -216						; size = 4
_this$ = -212						; size = 4
$T222058 = -144						; size = 4
$T222050 = -140						; size = 4
_f$222024 = -133					; size = 1
$T222018 = -132						; size = 4
$T222014 = -128						; size = 4
$T222005 = -124						; size = 4
$T221996 = -120						; size = 4
$T221990 = -116						; size = 4
_strTemp$217697 = -112					; size = 28
__$ArrayPad$ = -84					; size = 4
_pkBuild$217690 = -80					; size = 4
_eFeature$217688 = -76					; size = 4
_pkBuild$217682 = -72					; size = 4
_eBuild$217680 = -68					; size = 4
_i$217676 = -64						; size = 4
_eRoute$217675 = -60					; size = 4
_eRouteBuild$ = -56					; size = 4
_eDirectiveType$ = -52					; size = 4
_bShouldRoadThisTile$ = -45				; size = 1
_iWeight$ = -44						; size = 4
_kUnitInfo$ = -40					; size = 4
_eBestRouteType$ = -36					; size = 4
_directive$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddRouteDirectives, COMDAT
; _this$ = ecx

; 1863 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1864 : 	RouteTypes eBestRouteType = m_pPlayer->getBestRoute();

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getBestRoute@CvPlayer@@QBE?AW4RouteTypes@@PAVCvPlot@@@Z ; CvPlayer::getBestRoute
	mov	DWORD PTR _eBestRouteType$[ebp], eax

; 1865 : 
; 1866 : 	// if the player can't build a route, bail out!
; 1867 : 	if(eBestRouteType == NO_ROUTE)

	cmp	DWORD PTR _eBestRouteType$[ebp], -1
	jne	SHORT $LN16@AddRouteDi

; 1868 : 	{
; 1869 : 		return;

	jmp	$LN17@AddRouteDi
$LN16@AddRouteDi:

; 1870 : 	}
; 1871 : 
; 1872 : 	if(pPlot->getRouteType() == eBestRouteType && !pPlot->IsRoutePillaged())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, DWORD PTR _eBestRouteType$[ebp]
	jne	SHORT $LN15@AddRouteDi
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@AddRouteDi

; 1873 : 	{
; 1874 : 		return;

	jmp	$LN17@AddRouteDi
$LN15@AddRouteDi:

; 1875 : 	}
; 1876 : 
; 1877 : #ifdef AUI_WARNING_FIXES
; 1878 : 	if (!pUnit)
; 1879 : 		return;
; 1880 : #endif
; 1881 : 
; 1882 : 	// the plot was not flagged this turn, so ignore
; 1883 : 	bool bShouldRoadThisTile = (pPlot->GetBuilderAIScratchPadTurn() == GC.getGame().getGameTurn()) && (pPlot->GetBuilderAIScratchPadPlayer() == pUnit->getOwner());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T221996[ebp], edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	movsx	esi, ax
	mov	ecx, DWORD PTR $T221996[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jne	SHORT $LN19@AddRouteDi
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T222005[ebp], ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, DWORD PTR $T222005[ebp]
	jne	SHORT $LN19@AddRouteDi
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN20@AddRouteDi
$LN19@AddRouteDi:
	mov	DWORD PTR tv88[ebp], 0
$LN20@AddRouteDi:
	mov	dl, BYTE PTR tv88[ebp]
	mov	BYTE PTR _bShouldRoadThisTile$[ebp], dl

; 1884 : #ifdef AUI_WORKER_INCA_HILLS
; 1885 : 	bool bIncaBonusActive = (m_pPlayer->GetPlayerTraits()->IsNoHillsImprovementMaintenance() && !m_pPlayer->isHuman() && pPlot->getTerrainType() == TERRAIN_HILL);
; 1886 : 	if (!bShouldRoadThisTile && !bIncaBonusActive)
; 1887 : 	{
; 1888 : 		return;
; 1889 : 	}
; 1890 : #else
; 1891 : 	if(!bShouldRoadThisTile)

	movzx	eax, BYTE PTR _bShouldRoadThisTile$[ebp]
	test	eax, eax
	jne	SHORT $LN14@AddRouteDi

; 1892 : 	{
; 1893 : 		return;

	jmp	$LN17@AddRouteDi
$LN14@AddRouteDi:

; 1894 : 	}
; 1895 : #endif
; 1896 : 
; 1897 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 1898 : 	// check to see if someone already has a conflicting mission here
; 1899 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 1900 : 	{
; 1901 : 		int iLoop;
; 1902 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 1903 : 		{
; 1904 : 			if (pUnit == pLoopUnit)
; 1905 : 			{
; 1906 : 				continue;
; 1907 : 			}
; 1908 : 
; 1909 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 1910 : 			if (!pMissionPlot)
; 1911 : 			{
; 1912 : 				continue;
; 1913 : 			}
; 1914 : 
; 1915 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 1916 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 1917 : 			{
; 1918 : 				continue;
; 1919 : 			}
; 1920 : 
; 1921 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 1922 : 			{
; 1923 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 1924 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 1925 : 				if (pkBuild != NULL)
; 1926 : 				{
; 1927 : 					RouteTypes eOtherRoute = (RouteTypes)pkBuild->getRoute();
; 1928 : 					if (eOtherRoute != NO_ROUTE || (eOtherBuild == m_eRepairBuild && pPlot->IsRoutePillaged()))
; 1929 : 					{
; 1930 : 						if (m_bLogging)
; 1931 : 						{
; 1932 : 							CvString strLog;
; 1933 : 							strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 1934 : 							LogInfo(strLog, m_pPlayer, true);
; 1935 : 						}
; 1936 : 						return;
; 1937 : 					}
; 1938 : 				}
; 1939 : 			}
; 1940 : 		}
; 1941 : 	}
; 1942 : #endif
; 1943 : 
; 1944 : 	// find the route build
; 1945 : 	BuildTypes eRouteBuild = NO_BUILD;

	mov	DWORD PTR _eRouteBuild$[ebp], -1

; 1946 : 	if(pPlot->IsRoutePillaged())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@AddRouteDi

; 1947 : 	{
; 1948 : 		eRouteBuild = m_eRepairBuild;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _eRouteBuild$[ebp], eax

; 1949 : 	}
; 1950 : 	else

	jmp	SHORT $LN12@AddRouteDi
$LN13@AddRouteDi:

; 1951 : 	{
; 1952 : 		RouteTypes eRoute = pPlot->GetBuilderAIScratchPadRoute();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadRoute@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::GetBuilderAIScratchPadRoute
	mov	DWORD PTR _eRoute$217675[ebp], eax

; 1953 : #ifdef AUI_WARNING_FIXES
; 1954 : 		for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 1955 : #else
; 1956 : 		for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	DWORD PTR _i$217676[ebp], 0
	jmp	SHORT $LN11@AddRouteDi
$LN10@AddRouteDi:
	mov	ecx, DWORD PTR _i$217676[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$217676[ebp], ecx
$LN11@AddRouteDi:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _i$217676[ebp], eax
	jge	SHORT $LN12@AddRouteDi

; 1957 : #endif
; 1958 : 		{
; 1959 : 			BuildTypes eBuild = (BuildTypes)i;

	mov	edx, DWORD PTR _i$217676[ebp]
	mov	DWORD PTR _eBuild$217680[ebp], edx

; 1960 : 			CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	eax, DWORD PTR _eBuild$217680[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217682[ebp], eax

; 1961 : 			if(pkBuild && pkBuild->getRoute() == eRoute)

	cmp	DWORD PTR _pkBuild$217682[ebp], 0
	je	SHORT $LN8@AddRouteDi
	mov	ecx, DWORD PTR _pkBuild$217682[ebp]
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, DWORD PTR _eRoute$217675[ebp]
	jne	SHORT $LN8@AddRouteDi

; 1962 : 			{
; 1963 : 				eRouteBuild = eBuild;

	mov	ecx, DWORD PTR _eBuild$217680[ebp]
	mov	DWORD PTR _eRouteBuild$[ebp], ecx

; 1964 : 				break;

	jmp	SHORT $LN12@AddRouteDi
$LN8@AddRouteDi:

; 1965 : 			}
; 1966 : 		}

	jmp	SHORT $LN10@AddRouteDi
$LN12@AddRouteDi:

; 1967 : 	}
; 1968 : 
; 1969 : 	if(eRouteBuild == NO_BUILD)

	cmp	DWORD PTR _eRouteBuild$[ebp], -1
	jne	SHORT $LN7@AddRouteDi

; 1970 : 	{
; 1971 : 		return;

	jmp	$LN17@AddRouteDi
$LN7@AddRouteDi:

; 1972 : 	}
; 1973 : 
; 1974 : 	CvUnitEntry& kUnitInfo = pUnit->getUnitInfo();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	DWORD PTR _kUnitInfo$[ebp], eax

; 1975 : 	if(!kUnitInfo.GetBuilds(eRouteBuild))

	mov	edx, DWORD PTR _eRouteBuild$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUnitInfo$[ebp]
	call	?GetBuilds@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetBuilds
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN31@AddRouteDi

; 1976 : 	{
; 1977 : 		return;

	jmp	$LN17@AddRouteDi

; 1978 : 	}
; 1979 : 
; 1980 : 	if(GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_LEAVE_FORESTS))

$LN31@AddRouteDi:
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T222014[ebp], edx
	mov	eax, DWORD PTR $T222014[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T222018[ebp], eax
	push	7
	mov	ecx, DWORD PTR $T222018[ebp]
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@AddRouteDi

; 1981 : 	{
; 1982 : 		FeatureTypes eFeature = pPlot->getFeatureType();

	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$222024[ebp], al
	movsx	ecx, BYTE PTR _f$222024[ebp]
	mov	DWORD PTR _eFeature$217688[ebp], ecx

; 1983 : 		if(eFeature != NO_FEATURE)

	cmp	DWORD PTR _eFeature$217688[ebp], -1
	je	SHORT $LN5@AddRouteDi

; 1984 : 		{
; 1985 : 			CvBuildInfo* pkBuild = GC.getBuildInfo(eRouteBuild);

	mov	edx, DWORD PTR _eRouteBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217690[ebp], eax

; 1986 : 			if(pkBuild && pkBuild->isFeatureRemove(eFeature))

	cmp	DWORD PTR _pkBuild$217690[ebp], 0
	je	SHORT $LN5@AddRouteDi
	mov	eax, DWORD PTR _eFeature$217688[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkBuild$217690[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@AddRouteDi

; 1987 : 			{
; 1988 : 				return;

	jmp	$LN17@AddRouteDi
$LN5@AddRouteDi:

; 1989 : 			}
; 1990 : 		}
; 1991 : 	}
; 1992 : 
; 1993 : 	int iWeight = GC.getBUILDER_TASKING_BASELINE_BUILD_ROUTES();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2148
	mov	DWORD PTR _iWeight$[ebp], edx

; 1994 : 	BuilderDirective::BuilderDirectiveType eDirectiveType = BuilderDirective::BUILD_ROUTE;

	mov	DWORD PTR _eDirectiveType$[ebp], 2

; 1995 : 	if(eRouteBuild == m_eRepairBuild)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eRouteBuild$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN2@AddRouteDi

; 1996 : 	{
; 1997 : 		iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152
	mov	DWORD PTR _iWeight$[ebp], edx

; 1998 : 		eDirectiveType = BuilderDirective::REPAIR;

	mov	DWORD PTR _eDirectiveType$[ebp], 3
$LN2@AddRouteDi:

; 1999 : 	}
; 2000 : 
; 2001 : 	// int iTurnsAway = FindTurnsAway(pUnit, pPlot);
; 2002 : 	iWeight = iWeight / (iMoveTurnsAway/*iTurnsAway*/ + 1);

	mov	ecx, DWORD PTR _iMoveTurnsAway$[ebp]
	add	ecx, 1
	mov	eax, DWORD PTR _iWeight$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iWeight$[ebp], eax

; 2003 : 	iWeight = GetBuildCostWeight(iWeight, pPlot, eRouteBuild);

	mov	edx, DWORD PTR _eRouteBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
	mov	DWORD PTR _iWeight$[ebp], eax

; 2004 : 	iWeight += GetBuildTimeWeight(pUnit, pPlot, eRouteBuild, false, iMoveTurnsAway);

	mov	edx, DWORD PTR _iMoveTurnsAway$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _eRouteBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
	add	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax

; 2005 : #ifdef AUI_WORKER_INCA_HILLS
; 2006 : 	if (!(bIncaBonusActive && pPlot->GetBuilderAIScratchPadValue() <= 0))
; 2007 : 	{
; 2008 : 		iWeight *= pPlot->GetBuilderAIScratchPadValue();
; 2009 : 	}
; 2010 : #else
; 2011 : 	iWeight *= pPlot->GetBuilderAIScratchPadValue();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadValue@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadValue
	cwde
	imul	eax, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax

; 2012 : #endif
; 2013 : 	iWeight = CorrectWeight(iWeight);

	mov	ecx, DWORD PTR _iWeight$[ebp]
	push	ecx
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4
	mov	DWORD PTR _iWeight$[ebp], eax

; 2014 : 
; 2015 : 	BuilderDirective directive;

	mov	DWORD PTR _directive$[ebp], 6
	mov	DWORD PTR _directive$[ebp+4], -1
	mov	DWORD PTR _directive$[ebp+8], -1
	or	edx, -1
	mov	WORD PTR _directive$[ebp+12], dx
	or	eax, -1
	mov	WORD PTR _directive$[ebp+14], ax
	or	ecx, -1
	mov	WORD PTR _directive$[ebp+16], cx

; 2016 : 	directive.m_eDirective = eDirectiveType;

	mov	edx, DWORD PTR _eDirectiveType$[ebp]
	mov	DWORD PTR _directive$[ebp], edx

; 2017 : 	directive.m_eBuild = eRouteBuild;

	mov	eax, DWORD PTR _eRouteBuild$[ebp]
	mov	DWORD PTR _directive$[ebp+4], eax

; 2018 : 	directive.m_eResource = NO_RESOURCE;

	mov	DWORD PTR _directive$[ebp+8], -1

; 2019 : 	directive.m_sX = pPlot->getX();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	WORD PTR _directive$[ebp+12], dx

; 2020 : 	directive.m_sY = pPlot->getY();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	WORD PTR _directive$[ebp+14], cx

; 2021 : 	directive.m_sMoveTurnsAway = iMoveTurnsAway;

	mov	dx, WORD PTR _iMoveTurnsAway$[ebp]
	mov	WORD PTR _directive$[ebp+16], dx

; 2022 : 
; 2023 : 	if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN1@AddRouteDi

; 2024 : 	{
; 2025 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217697[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2026 : 		strTemp.Format("AddRouteDirectives, adding, x: %d y: %d, Weight, %d", pPlot->getX(), pPlot->getY(), iWeight);

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T222050[ebp], eax
	mov	ecx, DWORD PTR _iWeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222050[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0DE@HOCAFBDO@AddRouteDirectives?0?5adding?0?5x?3?5?$CF@
	lea	edx, DWORD PTR _strTemp$217697[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2027 : 		LogInfo(strTemp, m_pPlayer);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T221990[ebp], esp
	mov	DWORD PTR $T222058[ebp], edx
	lea	eax, DWORD PTR _strTemp$217697[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222058[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T222058[ebp]
	mov	DWORD PTR tv247[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2028 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217697[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@AddRouteDi:

; 2029 : 
; 2030 : 	m_aDirectives.push_back(directive, iWeight);

	mov	edx, DWORD PTR _iWeight$[ebp]
	push	edx
	lea	eax, DWORD PTR _directive$[ebp]
	push	eax
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back
$LN17@AddRouteDi:

; 2031 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strTemp$217697[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddRouteDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddRouteDirectives
PUBLIC	??_C@_0CF@HMFBFKGP@Add?5chop?5directives?0?5Weight?5is?5z@ ; `string'
PUBLIC	??_C@_0CA@CMGKGGDH@BuildTimeWeight?0?5?$CFd?0?5Weight?0?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@		; `string'
PUBLIC	??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@		; `string'
PUBLIC	??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@		; `string'
PUBLIC	??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@	; `string'
PUBLIC	??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	?getFeatureProduction@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureProduction
EXTRN	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z:PROC ; CvCityCitizens::IsWorkingPlot
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
;	COMDAT ??_C@_0CF@HMFBFKGP@Add?5chop?5directives?0?5Weight?5is?5z@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CF@HMFBFKGP@Add?5chop?5directives?0?5Weight?5is?5z@ DB 'Add chop d'
	DB	'irectives, Weight is zero!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CMGKGGDH@BuildTimeWeight?0?5?$CFd?0?5Weight?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0CA@CMGKGGDH@BuildTimeWeight?0?5?$CFd?0?5Weight?0?5?$CFd?$AA@ DB 'B'
	DB	'uildTimeWeight, %d, Weight, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@
CONST	SEGMENT
??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@ DB 'FLAVOR_CULTURE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@
CONST	SEGMENT
??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@ DB 'FLAVOR_SCIENCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
CONST	SEGMENT
??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@ DB 'FLAVOR_GOLD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@
CONST	SEGMENT
??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@ DB 'FLAVOR_PRODUCTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
CONST	SEGMENT
??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@ DB 'FLAVOR_GROWTH', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0
__ehfuncinfo$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
tv469 = -368						; size = 4
tv577 = -364						; size = 4
tv465 = -360						; size = 4
tv241 = -356						; size = 4
_this$ = -352						; size = 4
$T222342 = -348						; size = 4
$T222281 = -272						; size = 4
$T222263 = -265						; size = 1
$T222262 = -264						; size = 4
$T222258 = -257						; size = 1
$T222257 = -256						; size = 4
$T222253 = -249						; size = 1
$T222252 = -248						; size = 4
$T222248 = -244						; size = 4
$T222244 = -240						; size = 4
$T222240 = -236						; size = 4
$T222236 = -232						; size = 4
$T222232 = -228						; size = 4
$T222228 = -224						; size = 4
$T222224 = -220						; size = 4
$T222220 = -216						; size = 4
$T222216 = -212						; size = 4
$T222212 = -208						; size = 4
$T222208 = -204						; size = 4
$T222204 = -200						; size = 4
$T222203 = -196						; size = 4
$T222194 = -192						; size = 4
$T222193 = -188						; size = 4
$T222181 = -184						; size = 4
$T222172 = -180						; size = 4
$T222163 = -176						; size = 4
$T222154 = -169						; size = 1
$T222153 = -168						; size = 4
_f$222146 = -161					; size = 1
$T222140 = -160						; size = 4
$T222139 = -156						; size = 4
$T222130 = -152						; size = 4
$T222126 = -148						; size = 4
$T222114 = -144						; size = 4
$T222113 = -140						; size = 4
_strTemp$217789 = -136					; size = 28
__$ArrayPad$ = -108					; size = 4
_directive$217787 = -104				; size = 20
_iFlavorLoop$217746 = -84				; size = 4
_iPreviousYield$217740 = -80				; size = 4
_iNewYield$217742 = -76					; size = 4
_iDeltaYield$217744 = -72				; size = 4
_ui$217736 = -68					; size = 4
_pkBuild$217727 = -64					; size = 4
_eBuild$217725 = -60					; size = 4
_iBuildIndex$217721 = -56				; size = 4
_pAdjacentCity$217717 = -52				; size = 4
_eChopBuild$ = -48					; size = 4
_pFlavorManager$ = -44					; size = 4
_iWeight$ = -40						; size = 4
_pCity$ = -36						; size = 4
_iYieldDifferenceWeight$ = -32				; size = 4
_iProduction$ = -28					; size = 4
_eFeature$ = -24					; size = 4
_iBuildTimeWeight$ = -20				; size = 4
_eResource$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddChopDirectives, COMDAT
; _this$ = ecx

; 2035 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 356				; 00000164H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2036 : #ifdef AUI_WARNING_FIXES
; 2037 : 	if (!pUnit || !pPlot)
; 2038 : 		return;
; 2039 : #endif
; 2040 : 	// if it's not within a city radius
; 2041 : 	if(!pPlot->isWithinTeamCityRadius(pUnit->getTeam()))

	push	-1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN46@AddChopDir

; 2042 : 	{
; 2043 : 		return;

	jmp	$LN47@AddChopDir
$LN46@AddChopDir:

; 2044 : 	}
; 2045 : 
; 2046 : 	if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN54@AddChopDir

; 2047 : 	{
; 2048 : 		return;

	jmp	$LN47@AddChopDir

; 2049 : 	}
; 2050 : 
; 2051 : 	if(GET_PLAYER(pUnit->getOwner()).isOption(PLAYEROPTION_LEAVE_FORESTS))

$LN54@AddChopDir:
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T222126[ebp], edx
	mov	eax, DWORD PTR $T222126[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T222130[ebp], eax
	push	7
	mov	ecx, DWORD PTR $T222130[ebp]
	call	?isOption@CvPlayer@@QBE_NW4PlayerOptionTypes@@@Z ; CvPlayer::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@AddChopDir

; 2052 : 	{
; 2053 : 		return;

	jmp	$LN47@AddChopDir
$LN44@AddChopDir:

; 2054 : 	}
; 2055 : 
; 2056 : 	// check to see if a resource is here. If so, bail out!
; 2057 : 	ResourceTypes eResource = pPlot->getResourceType(m_pPlayer->getTeam());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222139[ebp], eax
	mov	ecx, DWORD PTR $T222139[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T222140[ebp], eax
	mov	eax, DWORD PTR $T222140[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 2058 : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN43@AddChopDir

; 2059 : 	{
; 2060 : 		return;

	jmp	$LN47@AddChopDir
$LN43@AddChopDir:

; 2061 : 	}
; 2062 : 
; 2063 : 	CvCity* pCity = GetWorkingCity(pPlot);

	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity
	mov	DWORD PTR _pCity$[ebp], eax

; 2064 : 	if(!pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	SHORT $LN42@AddChopDir

; 2065 : 	{
; 2066 : 		return;

	jmp	$LN47@AddChopDir
$LN42@AddChopDir:

; 2067 : 	}
; 2068 : 
; 2069 : 	if(pCity->GetCityCitizens()->IsWorkingPlot(pPlot))

	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsWorkingPlot@CvCityCitizens@@QBE_NPBVCvPlot@@@Z ; CvCityCitizens::IsWorkingPlot
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN64@AddChopDir

; 2070 : 	{
; 2071 : 		return;

	jmp	$LN47@AddChopDir

; 2072 : 	}
; 2073 : 
; 2074 : 	FeatureTypes eFeature = pPlot->getFeatureType();

$LN64@AddChopDir:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$222146[ebp], dl
	movsx	eax, BYTE PTR _f$222146[ebp]
	mov	DWORD PTR _eFeature$[ebp], eax

; 2075 : 	if(eFeature == NO_FEATURE)

	cmp	DWORD PTR _eFeature$[ebp], -1
	jne	SHORT $LN40@AddChopDir

; 2076 : 	{
; 2077 : 		// no feature in this tile, so bail
; 2078 : 		return;

	jmp	$LN47@AddChopDir
$LN40@AddChopDir:

; 2079 : 	}
; 2080 : 
; 2081 : 	// celtic rule: if this is a forest tile next to a city, do not chop the trees
; 2082 : 	if (m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T222153[ebp], eax
	mov	edx, DWORD PTR $T222153[ebp]
	mov	al, BYTE PTR [edx+341]
	mov	BYTE PTR $T222154[ebp], al
	movzx	ecx, BYTE PTR $T222154[ebp]
	test	ecx, ecx
	je	SHORT $LN39@AddChopDir

; 2083 : 	{
; 2084 : 		CvCity* pAdjacentCity = pPlot->GetAdjacentCity();

	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetAdjacentCity@CvPlot@@QBEPAVCvCity@@_N@Z ; CvPlot::GetAdjacentCity
	mov	DWORD PTR _pAdjacentCity$217717[ebp], eax

; 2085 : 		if (pAdjacentCity && pAdjacentCity->getOwner() == m_pPlayer->GetID())

	cmp	DWORD PTR _pAdjacentCity$217717[ebp], 0
	je	SHORT $LN39@AddChopDir
	mov	edx, DWORD PTR _pAdjacentCity$217717[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR $T222163[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T222172[ebp], eax
	mov	ecx, DWORD PTR $T222163[ebp]
	cmp	ecx, DWORD PTR $T222172[ebp]
	jne	SHORT $LN39@AddChopDir

; 2086 : 		{
; 2087 : 			if (eFeature == FEATURE_FOREST)

	cmp	DWORD PTR _eFeature$[ebp], 5
	jne	SHORT $LN39@AddChopDir

; 2088 : 			{
; 2089 : 				return;

	jmp	$LN47@AddChopDir
$LN39@AddChopDir:

; 2090 : 			}
; 2091 : 		}
; 2092 : 	}
; 2093 : 
; 2094 : #ifdef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 2095 : 	// check to see if someone already has a conflicting mission here
; 2096 : 	if (pUnit->GetMissionAIPlot() != pPlot)
; 2097 : 	{
; 2098 : 		int iLoop;
; 2099 : 		for (CvUnit* pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))
; 2100 : 		{
; 2101 : 			if (pUnit == pLoopUnit)
; 2102 : 			{
; 2103 : 				continue;
; 2104 : 			}
; 2105 : 
; 2106 : 			CvPlot* pMissionPlot = pLoopUnit->GetMissionAIPlot();
; 2107 : 			if (!pMissionPlot)
; 2108 : 			{
; 2109 : 				continue;
; 2110 : 			}
; 2111 : 
; 2112 : 			MissionAITypes eGroupMissionAI = pLoopUnit->GetMissionAIType();
; 2113 : 			if (eGroupMissionAI != MISSIONAI_BUILD)
; 2114 : 			{
; 2115 : 				continue;
; 2116 : 			}
; 2117 : 
; 2118 : 			if (pPlot->getX() == pMissionPlot->getX() && pPlot->getY() == pMissionPlot->getY())
; 2119 : 			{
; 2120 : 				BuildTypes eOtherBuild = pLoopUnit->getBuildType();
; 2121 : 				CvBuildInfo* pkBuild = GC.getBuildInfo(eOtherBuild);
; 2122 : 				if (pkBuild != NULL && pkBuild->getImprovement() == NO_IMPROVEMENT && pkBuild->isFeatureRemove(eFeature))
; 2123 : 				{
; 2124 : 					if (m_bLogging)
; 2125 : 					{
; 2126 : 						CvString strLog;
; 2127 : 						strLog.Format("x: %d y: %d, Somebody has a conflicting mission here.", pPlot->getX(), pPlot->getY());
; 2128 : 						LogInfo(strLog, m_pPlayer, true);
; 2129 : 					}
; 2130 : 					return;
; 2131 : 				}
; 2132 : 			}
; 2133 : 		}
; 2134 : 	}
; 2135 : #endif
; 2136 : 
; 2137 : 	BuildTypes eChopBuild = NO_BUILD;

	mov	DWORD PTR _eChopBuild$[ebp], -1

; 2138 : #ifdef AUI_WARNING_FIXES
; 2139 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2140 : #else
; 2141 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$217721[ebp], 0
	jmp	SHORT $LN36@AddChopDir
$LN35@AddChopDir:
	mov	edx, DWORD PTR _iBuildIndex$217721[ebp]
	add	edx, 1
	mov	DWORD PTR _iBuildIndex$217721[ebp], edx
$LN36@AddChopDir:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$217721[ebp], eax
	jge	SHORT $LN34@AddChopDir

; 2142 : #endif
; 2143 : 	{
; 2144 : 		BuildTypes eBuild = (BuildTypes)iBuildIndex;

	mov	eax, DWORD PTR _iBuildIndex$217721[ebp]
	mov	DWORD PTR _eBuild$217725[ebp], eax

; 2145 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	ecx, DWORD PTR _eBuild$217725[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217727[ebp], eax

; 2146 : 		if(NULL != pkBuild && pkBuild->getImprovement() == NO_IMPROVEMENT && pkBuild->isFeatureRemove(eFeature) && pkBuild->getFeatureProduction(eFeature) > 0 && pUnit->canBuild(pPlot, eBuild))

	cmp	DWORD PTR _pkBuild$217727[ebp], 0
	je	SHORT $LN33@AddChopDir
	mov	ecx, DWORD PTR _pkBuild$217727[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, -1
	jne	SHORT $LN33@AddChopDir
	mov	edx, DWORD PTR _eFeature$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkBuild$217727[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@AddChopDir
	mov	ecx, DWORD PTR _eFeature$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkBuild$217727[ebp]
	call	?getFeatureProduction@CvBuildInfo@@QBEHH@Z ; CvBuildInfo::getFeatureProduction
	test	eax, eax
	jle	SHORT $LN33@AddChopDir
	push	1
	push	0
	mov	edx, DWORD PTR _eBuild$217725[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN33@AddChopDir

; 2147 : 		{
; 2148 : 			eChopBuild = eBuild;

	mov	edx, DWORD PTR _eBuild$217725[ebp]
	mov	DWORD PTR _eChopBuild$[ebp], edx

; 2149 : 			break;

	jmp	SHORT $LN34@AddChopDir
$LN33@AddChopDir:

; 2150 : 		}
; 2151 : 	}

	jmp	$LN35@AddChopDir
$LN34@AddChopDir:

; 2152 : 
; 2153 : 	if(eChopBuild == NO_BUILD)

	cmp	DWORD PTR _eChopBuild$[ebp], -1
	jne	SHORT $LN32@AddChopDir

; 2154 : 	{
; 2155 : 		// we couldn't find a build that removed the feature without a production benefit
; 2156 : 		return;

	jmp	$LN47@AddChopDir
$LN32@AddChopDir:

; 2157 : 	}
; 2158 : 
; 2159 : 	pCity = NULL;

	mov	DWORD PTR _pCity$[ebp], 0

; 2160 : 	int iProduction = pPlot->getFeatureProduction(eChopBuild, pUnit->getOwner(), &pCity);

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T222181[ebp], ecx
	lea	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	eax, DWORD PTR $T222181[ebp]
	push	eax
	mov	ecx, DWORD PTR _eChopBuild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
	mov	DWORD PTR _iProduction$[ebp], eax

; 2161 : 
; 2162 : 	if(!DoesBuildHelpRush(pUnit, pPlot, eChopBuild))

	mov	edx, DWORD PTR _eChopBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::DoesBuildHelpRush
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN31@AddChopDir

; 2163 : 	{
; 2164 : 		return;

	jmp	$LN47@AddChopDir
$LN31@AddChopDir:

; 2165 : 	}
; 2166 : 
; 2167 : 	int iWeight = GC.getBUILDER_TASKING_BASELINE_REPAIR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2152
	mov	DWORD PTR _iWeight$[ebp], eax

; 2168 : 	//int iTurnsAway = FindTurnsAway(pUnit, pPlot);
; 2169 : 	iWeight = iWeight / (iMoveTurnsAway/*iTurnsAway*/ + 1);

	mov	ecx, DWORD PTR _iMoveTurnsAway$[ebp]
	add	ecx, 1
	mov	eax, DWORD PTR _iWeight$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iWeight$[ebp], eax

; 2170 : 	iWeight = GetBuildCostWeight(iWeight, pPlot, eChopBuild);

	mov	edx, DWORD PTR _eChopBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
	mov	DWORD PTR _iWeight$[ebp], eax

; 2171 : 	int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, eChopBuild, false, iMoveTurnsAway);

	mov	edx, DWORD PTR _iMoveTurnsAway$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _eChopBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
	mov	DWORD PTR _iBuildTimeWeight$[ebp], eax

; 2172 : 	iWeight += iBuildTimeWeight;

	mov	eax, DWORD PTR _iWeight$[ebp]
	add	eax, DWORD PTR _iBuildTimeWeight$[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax

; 2173 : 	iWeight *= iProduction; // times the amount that the plot produces from the chopping

	mov	ecx, DWORD PTR _iWeight$[ebp]
	imul	ecx, DWORD PTR _iProduction$[ebp]
	mov	DWORD PTR _iWeight$[ebp], ecx

; 2174 : 
; 2175 : 	int iYieldDifferenceWeight = 0;

	mov	DWORD PTR _iYieldDifferenceWeight$[ebp], 0

; 2176 : 	CvFlavorManager* pFlavorManager = m_pPlayer->GetFlavorManager();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	DWORD PTR _pFlavorManager$[ebp], eax

; 2177 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$217736[ebp], 0
	jmp	SHORT $LN30@AddChopDir
$LN29@AddChopDir:
	mov	eax, DWORD PTR _ui$217736[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$217736[ebp], eax
$LN30@AddChopDir:
	cmp	DWORD PTR _ui$217736[ebp], 6
	jae	$LN28@AddChopDir

; 2178 : 	{
; 2179 : 		// calculate natural yields
; 2180 : 		int iPreviousYield = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T222193[ebp], edx
	mov	eax, DWORD PTR $T222193[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T222194[ebp], eax
	push	0
	mov	edx, DWORD PTR $T222194[ebp]
	push	edx
	mov	eax, DWORD PTR _ui$217736[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR _iPreviousYield$217740[ebp], eax

; 2181 : 		int iNewYield = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam(), true /*bIgnoreFeature*/);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T222203[ebp], edx
	mov	eax, DWORD PTR $T222203[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T222204[ebp], eax
	push	1
	mov	edx, DWORD PTR $T222204[ebp]
	push	edx
	mov	eax, DWORD PTR _ui$217736[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	DWORD PTR _iNewYield$217742[ebp], eax

; 2182 : 		int iDeltaYield = iNewYield - iPreviousYield;

	mov	ecx, DWORD PTR _iNewYield$217742[ebp]
	sub	ecx, DWORD PTR _iPreviousYield$217740[ebp]
	mov	DWORD PTR _iDeltaYield$217744[ebp], ecx

; 2183 : 
; 2184 : 		if(iDeltaYield == 0)

	jne	SHORT $LN27@AddChopDir

; 2185 : 		{
; 2186 : 			continue;

	jmp	$LN29@AddChopDir
$LN27@AddChopDir:

; 2187 : 		}
; 2188 : 
; 2189 : 		for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$217746[ebp], 0
	jmp	SHORT $LN26@AddChopDir
$LN25@AddChopDir:
	mov	edx, DWORD PTR _iFlavorLoop$217746[ebp]
	add	edx, 1
	mov	DWORD PTR _iFlavorLoop$217746[ebp], edx
$LN26@AddChopDir:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T222208[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$217746[ebp]
	cmp	ecx, DWORD PTR $T222208[ebp]
	jge	$LN24@AddChopDir

; 2190 : 		{
; 2191 : 			switch(ui)

	mov	edx, DWORD PTR _ui$217736[ebp]
	mov	DWORD PTR tv241[ebp], edx
	cmp	DWORD PTR tv241[ebp], 4
	ja	$LN22@AddChopDir
	mov	eax, DWORD PTR tv241[ebp]
	jmp	DWORD PTR $LN181@AddChopDir[eax*4]
$LN21@AddChopDir:

; 2192 : 			{
; 2193 : 			case YIELD_FOOD:
; 2194 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GROWTH")

	mov	ecx, DWORD PTR _iFlavorLoop$217746[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T222212[ebp], ecx
	push	OFFSET ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
	mov	edx, DWORD PTR $T222212[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@AddChopDir

; 2195 : 				{
; 2196 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_FOOD();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2104
	mov	DWORD PTR $T222216[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$217746[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFlavorManager$[ebp]
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	imul	eax, DWORD PTR _iDeltaYield$217744[ebp]
	imul	eax, DWORD PTR $T222216[ebp]
	add	eax, DWORD PTR _iYieldDifferenceWeight$[ebp]
	mov	DWORD PTR _iYieldDifferenceWeight$[ebp], eax
$LN20@AddChopDir:

; 2197 : 				}
; 2198 : 				break;

	jmp	$LN22@AddChopDir
$LN19@AddChopDir:

; 2199 : 			case YIELD_PRODUCTION:
; 2200 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_PRODUCTION")

	mov	eax, DWORD PTR _iFlavorLoop$217746[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T222220[ebp], eax
	push	OFFSET ??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@
	mov	ecx, DWORD PTR $T222220[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN18@AddChopDir

; 2201 : 				{
; 2202 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_PRODUCTION();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2108
	mov	DWORD PTR $T222224[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$217746[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFlavorManager$[ebp]
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	imul	eax, DWORD PTR _iDeltaYield$217744[ebp]
	imul	eax, DWORD PTR $T222224[ebp]
	add	eax, DWORD PTR _iYieldDifferenceWeight$[ebp]
	mov	DWORD PTR _iYieldDifferenceWeight$[ebp], eax
$LN18@AddChopDir:

; 2203 : 				}
; 2204 : 				break;

	jmp	$LN22@AddChopDir
$LN17@AddChopDir:

; 2205 : 			case YIELD_GOLD:
; 2206 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GOLD")

	mov	edx, DWORD PTR _iFlavorLoop$217746[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T222228[ebp], edx
	push	OFFSET ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
	mov	eax, DWORD PTR $T222228[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@AddChopDir

; 2207 : 				{
; 2208 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_GOLD();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2112
	mov	DWORD PTR $T222232[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$217746[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFlavorManager$[ebp]
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	imul	eax, DWORD PTR _iDeltaYield$217744[ebp]
	imul	eax, DWORD PTR $T222232[ebp]
	add	eax, DWORD PTR _iYieldDifferenceWeight$[ebp]
	mov	DWORD PTR _iYieldDifferenceWeight$[ebp], eax
$LN16@AddChopDir:

; 2209 : 				}
; 2210 : 				break;

	jmp	$LN22@AddChopDir
$LN15@AddChopDir:

; 2211 : 			case YIELD_SCIENCE:
; 2212 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_SCIENCE")

	mov	ecx, DWORD PTR _iFlavorLoop$217746[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T222236[ebp], ecx
	push	OFFSET ??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@
	mov	edx, DWORD PTR $T222236[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@AddChopDir

; 2213 : 				{
; 2214 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2116
	mov	DWORD PTR $T222240[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$217746[ebp]
	push	edx
	mov	ecx, DWORD PTR _pFlavorManager$[ebp]
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	imul	eax, DWORD PTR _iDeltaYield$217744[ebp]
	imul	eax, DWORD PTR $T222240[ebp]
	add	eax, DWORD PTR _iYieldDifferenceWeight$[ebp]
	mov	DWORD PTR _iYieldDifferenceWeight$[ebp], eax
$LN14@AddChopDir:

; 2215 : 				}
; 2216 : 				break;

	jmp	SHORT $LN22@AddChopDir
$LN13@AddChopDir:

; 2217 : 			case YIELD_CULTURE:
; 2218 : 				if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_CULTURE")

	mov	eax, DWORD PTR _iFlavorLoop$217746[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T222244[ebp], eax
	push	OFFSET ??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@
	mov	ecx, DWORD PTR $T222244[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@AddChopDir

; 2219 : 				{
; 2220 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2120
	mov	DWORD PTR $T222248[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$217746[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pFlavorManager$[ebp]
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	imul	eax, DWORD PTR _iDeltaYield$217744[ebp]
	imul	eax, DWORD PTR $T222248[ebp]
	add	eax, DWORD PTR _iYieldDifferenceWeight$[ebp]
	mov	DWORD PTR _iYieldDifferenceWeight$[ebp], eax
$LN22@AddChopDir:

; 2221 : 				}
; 2222 : 				break;
; 2223 : 			case YIELD_FAITH:
; 2224 : #ifdef AUI_WORKER_EVALUATE_FAITH
; 2225 : 				if (GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_RELIGION")
; 2226 : 				{
; 2227 : 					iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_CULTURE();
; 2228 : 				}
; 2229 : #else
; 2230 : 				//if (GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_SCIENCE")
; 2231 : 				//{
; 2232 : 				//	iYieldDifferenceWeight += iDeltaYield * pFlavorManager->GetPersonalityIndividualFlavor((FlavorTypes)iFlavorLoop) * GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_SCIENCE();
; 2233 : 				//}
; 2234 : #endif
; 2235 : 				break;
; 2236 : 			}
; 2237 : 		}

	jmp	$LN25@AddChopDir
$LN24@AddChopDir:

; 2238 : 	}

	jmp	$LN29@AddChopDir
$LN28@AddChopDir:

; 2239 : 
; 2240 : 	// if we are going backwards, bail
; 2241 : 	if(iYieldDifferenceWeight < 0)

	cmp	DWORD PTR _iYieldDifferenceWeight$[ebp], 0
	jge	SHORT $LN10@AddChopDir

; 2242 : 	{
; 2243 : 		return;

	jmp	$LN47@AddChopDir
$LN10@AddChopDir:

; 2244 : 	}
; 2245 : 
; 2246 : 	iWeight += iYieldDifferenceWeight;

	mov	edx, DWORD PTR _iWeight$[ebp]
	add	edx, DWORD PTR _iYieldDifferenceWeight$[ebp]
	mov	DWORD PTR _iWeight$[ebp], edx

; 2247 : 
; 2248 : 	if (m_pPlayer->GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T222252[ebp], eax
	mov	ecx, DWORD PTR $T222252[ebp]
	mov	dl, BYTE PTR [ecx+333]
	mov	BYTE PTR $T222253[ebp], dl
	movzx	eax, BYTE PTR $T222253[ebp]
	test	eax, eax
	je	SHORT $LN9@AddChopDir
	cmp	DWORD PTR _eFeature$[ebp], 5
	je	SHORT $LN8@AddChopDir
	cmp	DWORD PTR _eFeature$[ebp], 1
	jne	SHORT $LN9@AddChopDir
$LN8@AddChopDir:

; 2249 : 	{
; 2250 : 		iWeight = iWeight / 4;

	mov	eax, DWORD PTR _iWeight$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _iWeight$[ebp], eax
$LN9@AddChopDir:

; 2251 : 	}
; 2252 : 	if (m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest() && eFeature == FEATURE_FOREST)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T222257[ebp], eax
	mov	edx, DWORD PTR $T222257[ebp]
	mov	al, BYTE PTR [edx+341]
	mov	BYTE PTR $T222258[ebp], al
	movzx	ecx, BYTE PTR $T222258[ebp]
	test	ecx, ecx
	je	SHORT $LN7@AddChopDir
	cmp	DWORD PTR _eFeature$[ebp], 5
	jne	SHORT $LN7@AddChopDir

; 2253 : 	{
; 2254 : 		iWeight = iWeight / 4;

	mov	eax, DWORD PTR _iWeight$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _iWeight$[ebp], eax
$LN7@AddChopDir:

; 2255 : 	}
; 2256 : #ifndef AUI_WORKER_NO_CHOP_BIAS
; 2257 : 	// this doesn't actually help them, but adds some historical flavor
; 2258 : 	if (m_pPlayer->GetPlayerTraits()->IsEmbarkedAllWater() && (eFeature == FEATURE_FOREST || eFeature == FEATURE_JUNGLE))

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T222262[ebp], eax
	mov	eax, DWORD PTR $T222262[ebp]
	mov	cl, BYTE PTR [eax+336]
	mov	BYTE PTR $T222263[ebp], cl
	movzx	edx, BYTE PTR $T222263[ebp]
	test	edx, edx
	je	SHORT $LN6@AddChopDir
	cmp	DWORD PTR _eFeature$[ebp], 5
	je	SHORT $LN5@AddChopDir
	cmp	DWORD PTR _eFeature$[ebp], 1
	jne	SHORT $LN6@AddChopDir
$LN5@AddChopDir:

; 2259 : 	{
; 2260 : 		iWeight = iWeight * 2;

	mov	eax, DWORD PTR _iWeight$[ebp]
	shl	eax, 1
	mov	DWORD PTR _iWeight$[ebp], eax
$LN6@AddChopDir:

; 2261 : 	}
; 2262 : #endif
; 2263 : 
; 2264 : 	iWeight = CorrectWeight(iWeight);

	mov	ecx, DWORD PTR _iWeight$[ebp]
	push	ecx
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4
	mov	DWORD PTR _iWeight$[ebp], eax

; 2265 : 
; 2266 : 	if(iWeight > 0)

	cmp	DWORD PTR _iWeight$[ebp], 0
	jle	$LN4@AddChopDir

; 2267 : 	{
; 2268 : 		BuilderDirective directive;

	mov	DWORD PTR _directive$217787[ebp], 6
	mov	DWORD PTR _directive$217787[ebp+4], -1
	mov	DWORD PTR _directive$217787[ebp+8], -1
	or	edx, -1
	mov	WORD PTR _directive$217787[ebp+12], dx
	or	eax, -1
	mov	WORD PTR _directive$217787[ebp+14], ax
	or	ecx, -1
	mov	WORD PTR _directive$217787[ebp+16], cx

; 2269 : 		directive.m_eDirective = BuilderDirective::CHOP;

	mov	DWORD PTR _directive$217787[ebp], 4

; 2270 : 		directive.m_eBuild = eChopBuild;

	mov	edx, DWORD PTR _eChopBuild$[ebp]
	mov	DWORD PTR _directive$217787[ebp+4], edx

; 2271 : 		directive.m_eResource = NO_RESOURCE;

	mov	DWORD PTR _directive$217787[ebp+8], -1

; 2272 : 		directive.m_sX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	WORD PTR _directive$217787[ebp+12], cx

; 2273 : 		directive.m_sY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	WORD PTR _directive$217787[ebp+14], ax

; 2274 : 		//directive.m_iGoldCost = m_pPlayer->getBuildCost(pPlot, eChopBuild);
; 2275 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;

	mov	cx, WORD PTR _iMoveTurnsAway$[ebp]
	mov	WORD PTR _directive$217787[ebp+16], cx

; 2276 : 
; 2277 : 		if(m_bLogging)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	$LN3@AddChopDir

; 2278 : 		{
; 2279 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$217789[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2280 : 			strTemp.Format("BuildTimeWeight, %d, Weight, %d", iBuildTimeWeight, iWeight);

	mov	ecx, DWORD PTR _iWeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBuildTimeWeight$[ebp]
	push	edx
	push	OFFSET ??_C@_0CA@CMGKGGDH@BuildTimeWeight?0?5?$CFd?0?5Weight?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strTemp$217789[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2281 : 			LogInfo(strTemp, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T222113[ebp], esp
	mov	DWORD PTR $T222281[ebp], eax
	lea	ecx, DWORD PTR _strTemp$217789[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222281[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T222281[ebp]
	mov	DWORD PTR tv465[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2282 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strTemp$217789[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@AddChopDir:

; 2283 : 
; 2284 : 		m_aDirectives.push_back(directive, iWeight);

	mov	eax, DWORD PTR _iWeight$[ebp]
	push	eax
	lea	ecx, DWORD PTR _directive$217787[ebp]
	push	ecx
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ; CvWeightedVector<BuilderDirective,100,1>::push_back

; 2285 : 	}
; 2286 : 	else

	jmp	SHORT $LN47@AddChopDir
$LN4@AddChopDir:

; 2287 : 	{
; 2288 : 		if(m_bLogging)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	SHORT $LN47@AddChopDir

; 2289 : 		{
; 2290 : 			LogInfo("Add chop directives, Weight is zero!", m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T222114[ebp], esp
	mov	DWORD PTR $T222342[ebp], eax
	mov	ecx, OFFSET ??_C@_0CF@HMFBFKGP@Add?5chop?5directives?0?5Weight?5is?5z@
	test	ecx, ecx
	je	SHORT $LN177@AddChopDir
	mov	DWORD PTR tv577[ebp], OFFSET ??_C@_0CF@HMFBFKGP@Add?5chop?5directives?0?5Weight?5is?5z@
	jmp	SHORT $LN178@AddChopDir
$LN177@AddChopDir:
	mov	DWORD PTR tv577[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN178@AddChopDir:
	mov	edx, DWORD PTR tv577[ebp]
	push	edx
	mov	ecx, DWORD PTR $T222342[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T222342[ebp]
	mov	DWORD PTR tv469[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H
$LN47@AddChopDir:

; 2291 : 		}
; 2292 : 	}
; 2293 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN181@AddChopDir:
	DD	$LN21@AddChopDir
	DD	$LN19@AddChopDir
	DD	$LN17@AddChopDir
	DD	$LN15@AddChopDir
	DD	$LN13@AddChopDir
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z$0:
	lea	ecx, DWORD PTR _strTemp$217789[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-360]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddChopDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddChopDirectives
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back
PUBLIC	??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
PUBLIC	?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z ; CvBuilderTaskingAI::GetBuildTypeFromImprovement
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ; CvBuilderTaskingAI::AddRemoveUselessRoadDirectives
EXTRN	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ:PROC	; CvBuildInfo::IsRemoveRoute
; Function compile flags: /Odtp
;	COMDAT ?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
_weightedElem$222418 = -84				; size = 24
$T222369 = -60						; size = 4
$T222360 = -56						; size = 4
_directive$217821 = -48					; size = 20
_pkBuild$217813 = -28					; size = 4
_eBuild$217811 = -24					; size = 4
_iBuildIndex$217807 = -20				; size = 4
_eRemoveRouteBuild$ = -16				; size = 4
_eImprovement$ = -12					; size = 4
_iWeight$ = -8						; size = 4
_eBuild$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddRemoveUselessRoadDirectives, COMDAT
; _this$ = ecx

; 2296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2297 : 	// if it's not within a city radius
; 2298 : 	if(!pPlot->isWithinTeamCityRadius(pUnit->getTeam()))

	push	-1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isWithinTeamCityRadius@CvPlot@@QBE_NW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlot::isWithinTeamCityRadius
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@AddRemoveU

; 2299 : 	{
; 2300 : 		return;

	jmp	$LN12@AddRemoveU
$LN11@AddRemoveU:

; 2301 : 	}
; 2302 : 
; 2303 : 	// don't try to remove the route under the city
; 2304 : 	if(pPlot->isCity())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@AddRemoveU

; 2305 : 	{
; 2306 : 		return;

	jmp	$LN12@AddRemoveU
$LN10@AddRemoveU:

; 2307 : 	}
; 2308 : 
; 2309 : 	// nothing here to remove
; 2310 : 	if(pPlot->getRouteType() == NO_ROUTE)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	jne	SHORT $LN9@AddRemoveU

; 2311 : 	{
; 2312 : 		return;

	jmp	$LN12@AddRemoveU
$LN9@AddRemoveU:

; 2313 : 	}
; 2314 : 
; 2315 : 	// flagged this turn means this is a valid route plot
; 2316 : 	if(pPlot->GetBuilderAIScratchPadTurn() == GC.getGame().getGameTurn() && pPlot->GetBuilderAIScratchPadPlayer() == pUnit->getOwner())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T222360[ebp], edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadTurn@CvPlot@@QBEFXZ ; CvPlot::GetBuilderAIScratchPadTurn
	movsx	esi, ax
	mov	ecx, DWORD PTR $T222360[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	esi, eax
	jne	SHORT $LN8@AddRemoveU
	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T222369[ebp], ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?GetBuilderAIScratchPadPlayer@CvPlot@@QBE?AW4PlayerTypes@@XZ ; CvPlot::GetBuilderAIScratchPadPlayer
	cmp	eax, DWORD PTR $T222369[ebp]
	jne	SHORT $LN8@AddRemoveU

; 2317 : 	{
; 2318 : 		return;

	jmp	$LN12@AddRemoveU
$LN8@AddRemoveU:

; 2319 : 	}
; 2320 : 
; 2321 : 	BuildTypes eRemoveRouteBuild = NO_BUILD;

	mov	DWORD PTR _eRemoveRouteBuild$[ebp], -1

; 2322 : #ifdef AUI_WARNING_FIXES
; 2323 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 2324 : #else
; 2325 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$217807[ebp], 0
	jmp	SHORT $LN7@AddRemoveU
$LN6@AddRemoveU:
	mov	edx, DWORD PTR _iBuildIndex$217807[ebp]
	add	edx, 1
	mov	DWORD PTR _iBuildIndex$217807[ebp], edx
$LN7@AddRemoveU:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$217807[ebp], eax
	jge	SHORT $LN5@AddRemoveU

; 2326 : #endif
; 2327 : 	{
; 2328 : 		BuildTypes eBuild = (BuildTypes)iBuildIndex;

	mov	eax, DWORD PTR _iBuildIndex$217807[ebp]
	mov	DWORD PTR _eBuild$217811[ebp], eax

; 2329 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	ecx, DWORD PTR _eBuild$217811[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$217813[ebp], eax

; 2330 : 		if(NULL != pkBuild && pkBuild->IsRemoveRoute() && pUnit->canBuild(pPlot, eBuild))

	cmp	DWORD PTR _pkBuild$217813[ebp], 0
	je	SHORT $LN4@AddRemoveU
	mov	ecx, DWORD PTR _pkBuild$217813[ebp]
	call	?IsRemoveRoute@CvBuildInfo@@QBE_NXZ	; CvBuildInfo::IsRemoveRoute
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@AddRemoveU
	push	1
	push	0
	mov	eax, DWORD PTR _eBuild$217811[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@AddRemoveU

; 2331 : 		{
; 2332 : 			eRemoveRouteBuild = eBuild;

	mov	eax, DWORD PTR _eBuild$217811[ebp]
	mov	DWORD PTR _eRemoveRouteBuild$[ebp], eax

; 2333 : 			break;

	jmp	SHORT $LN5@AddRemoveU
$LN4@AddRemoveU:

; 2334 : 		}
; 2335 : 	}

	jmp	SHORT $LN6@AddRemoveU
$LN5@AddRemoveU:

; 2336 : 
; 2337 : 
; 2338 : 	if(eRemoveRouteBuild == NO_BUILD)

	cmp	DWORD PTR _eRemoveRouteBuild$[ebp], -1
	jne	SHORT $LN3@AddRemoveU

; 2339 : 	{
; 2340 : 		return;

	jmp	$LN12@AddRemoveU
$LN3@AddRemoveU:

; 2341 : 	}
; 2342 : 
; 2343 : 	// evaluate if removing the road helps anything
; 2344 : 	ImprovementTypes eImprovement = pPlot->getImprovementType();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$[ebp], eax

; 2345 : 	BuildTypes eBuild = NO_BUILD;

	mov	DWORD PTR _eBuild$[ebp], -1

; 2346 : 	if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN2@AddRemoveU

; 2347 : 	{
; 2348 : 		eBuild = GetBuildTypeFromImprovement(eImprovement);

	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z ; CvBuilderTaskingAI::GetBuildTypeFromImprovement
	mov	DWORD PTR _eBuild$[ebp], eax
$LN2@AddRemoveU:

; 2349 : 	}
; 2350 : 
; 2351 : 	//int iWeight = GetWeightFromPlotYields(m_pPlayer, pPlot, eBuild, NULL, NO_YIELD, 100, NO_ROUTE) - GetWeightFromPlotYields(m_pPlayer, pPlot, eBuild, NULL, NO_YIELD, 10);
; 2352 : 	int iWeight = 0;

	mov	DWORD PTR _iWeight$[ebp], 0

; 2353 : 	iWeight = CorrectWeight(iWeight);

	mov	edx, DWORD PTR _iWeight$[ebp]
	push	edx
	call	?CorrectWeight@@YAHH@Z			; CorrectWeight
	add	esp, 4
	mov	DWORD PTR _iWeight$[ebp], eax

; 2354 : 
; 2355 : 	if(iWeight > 0)

	cmp	DWORD PTR _iWeight$[ebp], 0
	jle	$LN12@AddRemoveU

; 2356 : 	{
; 2357 : 		BuilderDirective directive;

	mov	DWORD PTR _directive$217821[ebp], 6
	mov	DWORD PTR _directive$217821[ebp+4], -1
	mov	DWORD PTR _directive$217821[ebp+8], -1
	or	eax, -1
	mov	WORD PTR _directive$217821[ebp+12], ax
	or	ecx, -1
	mov	WORD PTR _directive$217821[ebp+14], cx
	or	edx, -1
	mov	WORD PTR _directive$217821[ebp+16], dx

; 2358 : 		directive.m_eDirective = BuilderDirective::REMOVE_ROAD;

	mov	DWORD PTR _directive$217821[ebp], 5

; 2359 : 		directive.m_eBuild = eRemoveRouteBuild;

	mov	eax, DWORD PTR _eRemoveRouteBuild$[ebp]
	mov	DWORD PTR _directive$217821[ebp+4], eax

; 2360 : 		directive.m_eResource = NO_RESOURCE;

	mov	DWORD PTR _directive$217821[ebp+8], -1

; 2361 : 		directive.m_sX = pPlot->getX();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	WORD PTR _directive$217821[ebp+12], dx

; 2362 : 		directive.m_sY = pPlot->getY();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	WORD PTR _directive$217821[ebp+14], cx

; 2363 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;

	mov	dx, WORD PTR _iMoveTurnsAway$[ebp]
	mov	WORD PTR _directive$217821[ebp+16], dx

; 2364 : 
; 2365 : 		m_aDirectives.push_back(directive, iWeight);

	lea	ecx, DWORD PTR _weightedElem$222418[ebp]
	call	??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
	mov	eax, DWORD PTR _directive$217821[ebp]
	mov	DWORD PTR _weightedElem$222418[ebp], eax
	mov	ecx, DWORD PTR _directive$217821[ebp+4]
	mov	DWORD PTR _weightedElem$222418[ebp+4], ecx
	mov	edx, DWORD PTR _directive$217821[ebp+8]
	mov	DWORD PTR _weightedElem$222418[ebp+8], edx
	mov	eax, DWORD PTR _directive$217821[ebp+12]
	mov	DWORD PTR _weightedElem$222418[ebp+12], eax
	mov	ecx, DWORD PTR _directive$217821[ebp+16]
	mov	DWORD PTR _weightedElem$222418[ebp+16], ecx
	mov	edx, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _weightedElem$222418[ebp+20], edx
	lea	eax, DWORD PTR _weightedElem$222418[ebp]
	push	eax
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back
$LN12@AddRemoveU:

; 2366 : 	}
; 2367 : 
; 2368 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddRemoveUselessRoadDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddRemoveUselessRoadDirectives
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
_weightedElem$222480 = -60				; size = 24
_f$222429 = -33						; size = 1
_iWeight$217833 = -32					; size = 4
_directive$217835 = -28					; size = 20
_iBuildTimeWeight$217834 = -8				; size = 4
_pCity$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iMoveTurnsAway$ = 16					; size = 4
?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z PROC ; CvBuilderTaskingAI::AddScrubFalloutDirectives, COMDAT
; _this$ = ecx

; 2372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 2373 : 	if(m_eFalloutFeature == NO_FEATURE || m_eFalloutRemove == NO_BUILD)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+58452], -1
	je	SHORT $LN3@AddScrubFa
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+58456], -1
	jne	SHORT $LN4@AddScrubFa
$LN3@AddScrubFa:

; 2374 : 	{
; 2375 : 		return;

	jmp	$LN5@AddScrubFa
$LN4@AddScrubFa:

; 2376 : 	}
; 2377 : 
; 2378 : 	CvCity* pCity = GetWorkingCity(pPlot);

	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ; CvBuilderTaskingAI::GetWorkingCity
	mov	DWORD PTR _pCity$[ebp], eax

; 2379 : 	if(!pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	SHORT $LN9@AddScrubFa

; 2380 : 	{
; 2381 : 		return;

	jmp	$LN5@AddScrubFa

; 2382 : 	}
; 2383 : 
; 2384 : 	if(pPlot->getFeatureType() == m_eFalloutFeature && pUnit->canBuild(pPlot, m_eFalloutRemove))

$LN9@AddScrubFa:
	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$222429[ebp], cl
	movsx	edx, BYTE PTR _f$222429[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+58452]
	jne	$LN5@AddScrubFa
	push	1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+58456]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canBuild@CvUnit@@QBE_NPBVCvPlot@@W4BuildTypes@@_N2@Z ; CvUnit::canBuild
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@AddScrubFa

; 2385 : 	{
; 2386 : 		int iWeight = GC.getBUILDER_TASKING_BASELINE_SCRUB_FALLOUT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2156
	mov	DWORD PTR _iWeight$217833[ebp], edx

; 2387 : 		//int iTurnsAway = FindTurnsAway(pUnit, pPlot);
; 2388 : 		iWeight = iWeight / (iMoveTurnsAway/*iTurnsAway*/ + 1);

	mov	ecx, DWORD PTR _iMoveTurnsAway$[ebp]
	add	ecx, 1
	mov	eax, DWORD PTR _iWeight$217833[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iWeight$217833[ebp], eax

; 2389 : #ifdef AUI_WORKER_FIX_FALLOUT
; 2390 : 		// For scrubbing fallout, build times and build costs should be ignored because... well, it's fallout
; 2391 : 		// Max values returned from BuildCostWeight and BuildTimeWeight
; 2392 : 		iWeight *= 100;
; 2393 : 		iWeight += 10000 / (iMoveTurnsAway/*iTurnsAway*/ + 1);
; 2394 : #else
; 2395 : 		iWeight = GetBuildCostWeight(iWeight, pPlot, m_eFalloutRemove);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+58456]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWeight$217833[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ; CvBuilderTaskingAI::GetBuildCostWeight
	mov	DWORD PTR _iWeight$217833[ebp], eax

; 2396 : 		int iBuildTimeWeight = GetBuildTimeWeight(pUnit, pPlot, m_eFalloutRemove, false, iMoveTurnsAway);

	mov	eax, DWORD PTR _iMoveTurnsAway$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+58456]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ; CvBuilderTaskingAI::GetBuildTimeWeight
	mov	DWORD PTR _iBuildTimeWeight$217834[ebp], eax

; 2397 : 		iWeight += iBuildTimeWeight;

	mov	edx, DWORD PTR _iWeight$217833[ebp]
	add	edx, DWORD PTR _iBuildTimeWeight$217834[ebp]
	mov	DWORD PTR _iWeight$217833[ebp], edx

; 2398 : #endif
; 2399 : 
; 2400 : 		BuilderDirective directive;

	mov	DWORD PTR _directive$217835[ebp], 6
	mov	DWORD PTR _directive$217835[ebp+4], -1
	mov	DWORD PTR _directive$217835[ebp+8], -1
	or	eax, -1
	mov	WORD PTR _directive$217835[ebp+12], ax
	or	ecx, -1
	mov	WORD PTR _directive$217835[ebp+14], cx
	or	edx, -1
	mov	WORD PTR _directive$217835[ebp+16], dx

; 2401 : 		directive.m_eDirective = BuilderDirective::CHOP;

	mov	DWORD PTR _directive$217835[ebp], 4

; 2402 : 		directive.m_eBuild = m_eFalloutRemove;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+58456]
	mov	DWORD PTR _directive$217835[ebp+4], ecx

; 2403 : 		directive.m_eResource = NO_RESOURCE;

	mov	DWORD PTR _directive$217835[ebp+8], -1

; 2404 : 		directive.m_sX = pPlot->getX();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	WORD PTR _directive$217835[ebp+12], ax

; 2405 : 		directive.m_sY = pPlot->getY();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	WORD PTR _directive$217835[ebp+14], dx

; 2406 : 		directive.m_sMoveTurnsAway = iMoveTurnsAway;

	mov	ax, WORD PTR _iMoveTurnsAway$[ebp]
	mov	WORD PTR _directive$217835[ebp+16], ax

; 2407 : 		m_aDirectives.push_back(directive, iWeight);

	lea	ecx, DWORD PTR _weightedElem$222480[ebp]
	call	??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
	mov	ecx, DWORD PTR _directive$217835[ebp]
	mov	DWORD PTR _weightedElem$222480[ebp], ecx
	mov	edx, DWORD PTR _directive$217835[ebp+4]
	mov	DWORD PTR _weightedElem$222480[ebp+4], edx
	mov	eax, DWORD PTR _directive$217835[ebp+8]
	mov	DWORD PTR _weightedElem$222480[ebp+8], eax
	mov	ecx, DWORD PTR _directive$217835[ebp+12]
	mov	DWORD PTR _weightedElem$222480[ebp+12], ecx
	mov	edx, DWORD PTR _directive$217835[ebp+16]
	mov	DWORD PTR _weightedElem$222480[ebp+16], edx
	mov	eax, DWORD PTR _iWeight$217833[ebp]
	mov	DWORD PTR _weightedElem$222480[ebp+20], eax
	lea	ecx, DWORD PTR _weightedElem$222480[ebp]
	push	ecx
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back
$LN5@AddScrubFa:

; 2408 : 	}
; 2409 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddScrubFalloutDirectives@CvBuilderTaskingAI@@QAEXPAVCvUnit@@PAVCvPlot@@H@Z ENDP ; CvBuilderTaskingAI::AddScrubFalloutDirectives
_TEXT	ENDS
PUBLIC	??_C@_0EE@ONNNHHME@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?0?5this?5tile?5@ ; `string'
PUBLIC	??_C@_0DI@FKACIEBE@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?5danger?3?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0CL@KLNPMPBF@x?3?5?$CFd?5y?3?5?$CFd?0?0Somebody?5has?5a?5miss@ ; `string'
PUBLIC	??_C@_0BA@LBJECBDC@?0This?5is?5normal?$AA@	; `string'
PUBLIC	??_C@_0P@FILALACM@?0This?5is?5weird?$AA@	; `string'
PUBLIC	??_C@_0HA@IMLHLIBP@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@ ; `string'
PUBLIC	??_C@_0CH@CJJMCMNO@x?3?5?$CFd?5y?3?5?$CFd?0?0Impassable?5tile?4?5To@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z:PROC ; CvPlot::getNumFriendlyUnitsOfType
EXTRN	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z:PROC		; CvUnit::atPlot
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ:PROC	; CvUnit::GetMissionAIPlot
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z:PROC ; CvPlot::isAdjacentToArea
EXTRN	?area@CvUnit@@QBEPAVCvArea@@XZ:PROC		; CvUnit::area
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
;	COMDAT ??_C@_0EE@ONNNHHME@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?0?5this?5tile?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0EE@ONNNHHME@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?0?5this?5tile?5@ DB 'p'
	DB	'lotX: %d plotY: %d,, this tile is full with another unit. bai'
	DB	'ling!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@FKACIEBE@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?5danger?3?5?$CFd?0@
CONST	SEGMENT
??_C@_0DI@FKACIEBE@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?5danger?3?5?$CFd?0@ DB 'p'
	DB	'lotX: %d plotY: %d, danger: %d,, bailing due to danger', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KLNPMPBF@x?3?5?$CFd?5y?3?5?$CFd?0?0Somebody?5has?5a?5miss@
CONST	SEGMENT
??_C@_0CL@KLNPMPBF@x?3?5?$CFd?5y?3?5?$CFd?0?0Somebody?5has?5a?5miss@ DB 'x'
	DB	': %d y: %d,,Somebody has a mission here, ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBJECBDC@?0This?5is?5normal?$AA@
CONST	SEGMENT
??_C@_0BA@LBJECBDC@?0This?5is?5normal?$AA@ DB ',This is normal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FILALACM@?0This?5is?5weird?$AA@
CONST	SEGMENT
??_C@_0P@FILALACM@?0This?5is?5weird?$AA@ DB ',This is weird', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HA@IMLHLIBP@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@
CONST	SEGMENT
??_C@_0HA@IMLHLIBP@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@ DB 'u'
	DB	'nitx: %d unity: %d, plotx: %d ploty: %d, plot area: %d, unit '
	DB	'area: %d,,Plot areas don''t match and can''t embark', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CJJMCMNO@x?3?5?$CFd?5y?3?5?$CFd?0?0Impassable?5tile?4?5To@
CONST	SEGMENT
??_C@_0CH@CJJMCMNO@x?3?5?$CFd?5y?3?5?$CFd?0?0Impassable?5tile?4?5To@ DB 'x'
	DB	': %d y: %d,,Impassable tile. Toss out', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$8
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
tv398 = -288						; size = 4
tv393 = -284						; size = 4
tv388 = -280						; size = 4
tv383 = -276						; size = 4
tv152 = -272						; size = 4
tv378 = -268						; size = 4
_this$ = -264						; size = 4
$T222655 = -260						; size = 4
$T222647 = -256						; size = 4
$T222639 = -252						; size = 4
$T222631 = -248						; size = 4
$T222626 = -244						; size = 4
$T222622 = -240						; size = 4
$T222610 = -236						; size = 4
$T222602 = -232						; size = 4
$T222590 = -228						; size = 4
$T222585 = -224						; size = 4
$T222581 = -217						; size = 1
$T222577 = -216						; size = 4
$T222568 = -212						; size = 4
$T222559 = -208						; size = 4
$T222555 = -204						; size = 4
$T222541 = -200						; size = 4
$T222537 = -196						; size = 4
$T222521 = -192						; size = 4
$T222513 = -188						; size = 4
$T222489 = -184						; size = 4
$T222488 = -180						; size = 4
$T222487 = -176						; size = 4
$T222486 = -172						; size = 4
$T222485 = -168						; size = 4
_strLog$217887 = -164					; size = 28
_strLog$217882 = -136					; size = 28
_strLog$217876 = -108					; size = 28
_strLog$217866 = -80					; size = 28
_bCanCrossToNewArea$217859 = -49			; size = 1
_strLog$217844 = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_eOwner$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot, COMDAT
; _this$ = ecx

; 2414 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2415 : 	// if plot is impassable, bail!
; 2416 : #ifdef AUI_WORKER_FIX_SHOULD_CONSIDER_PLOT_FLYING_WORKER_DISREGARDS_PEAKS
; 2417 : 	if (!pUnit->canMoveAllTerrain() && ((pPlot->isImpassable() && !pUnit->canMoveImpassable()) ||
; 2418 : 		(pPlot->isMountain() && !pUnit->IsHoveringUnit() && !m_pPlayer->GetPlayerTraits()->IsAbleToCrossMountains())))
; 2419 : #else
; 2420 : 	if(pPlot->isImpassable() || pPlot->isMountain())

	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN27@ShouldBuil
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN58@ShouldBuil
$LN27@ShouldBuil:

; 2421 : #endif
; 2422 : 	{
; 2423 : 		if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN26@ShouldBuil

; 2424 : 		{
; 2425 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$217844[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2426 : 			strLog.Format("x: %d y: %d,,Impassable tile. Toss out", pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T222513[ebp], eax
	mov	ecx, DWORD PTR $T222513[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0CH@CJJMCMNO@x?3?5?$CFd?5y?3?5?$CFd?0?0Impassable?5tile?4?5To@
	lea	ecx, DWORD PTR _strLog$217844[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2427 : 			LogInfo(strLog, m_pPlayer);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T222485[ebp], esp
	mov	DWORD PTR $T222521[ebp], ecx
	lea	edx, DWORD PTR _strLog$217844[ebp]
	push	edx
	mov	ecx, DWORD PTR $T222521[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T222521[ebp]
	mov	DWORD PTR tv378[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2428 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217844[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@ShouldBuil:

; 2429 : 		return false;

	xor	al, al
	jmp	$LN29@ShouldBuil

; 2430 : 	}
; 2431 : 
; 2432 : 	// can't build on plots others own (unless inside a minor)
; 2433 : 	PlayerTypes eOwner = pPlot->getOwner();

$LN58@ShouldBuil:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _eOwner$[ebp], edx

; 2434 : 	if(eOwner != NO_PLAYER && eOwner != m_pPlayer->GetID() && !GET_PLAYER(eOwner).isMinorCiv())

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN25@ShouldBuil
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T222537[ebp], edx
	mov	eax, DWORD PTR _eOwner$[ebp]
	cmp	eax, DWORD PTR $T222537[ebp]
	je	SHORT $LN25@ShouldBuil
	mov	ecx, DWORD PTR _eOwner$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T222541[ebp], ecx
	mov	ecx, DWORD PTR $T222541[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN25@ShouldBuil

; 2435 : 	{
; 2436 : 		return false;

	xor	al, al
	jmp	$LN29@ShouldBuil
$LN25@ShouldBuil:

; 2437 : 	}
; 2438 : 
; 2439 : 	// workers should not be able to work in plots that do not match their default domain
; 2440 : 	switch(pUnit->getDomainType())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	DWORD PTR tv152[ebp], eax
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN68@ShouldBuil
	cmp	DWORD PTR tv152[ebp], 2
	je	SHORT $LN66@ShouldBuil
	jmp	SHORT $LN23@ShouldBuil

; 2441 : 	{
; 2442 : 	case DOMAIN_LAND:
; 2443 : 		if(pPlot->isWater())

$LN66@ShouldBuil:
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN21@ShouldBuil

; 2444 : 		{
; 2445 : 			return false;

	xor	al, al
	jmp	$LN29@ShouldBuil
$LN21@ShouldBuil:

; 2446 : 		}
; 2447 : 		break;

	jmp	SHORT $LN23@ShouldBuil

; 2448 : 	case DOMAIN_SEA:
; 2449 : 		if(!pPlot->isWater())

$LN68@ShouldBuil:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN23@ShouldBuil

; 2450 : 		{
; 2451 : 			return false;

	xor	al, al
	jmp	$LN29@ShouldBuil
$LN23@ShouldBuil:

; 2452 : 		}
; 2453 : 		break;
; 2454 : 	default:
; 2455 : 		break;
; 2456 : 	}
; 2457 : 
; 2458 : 	// need more planning for amphibious units
; 2459 : 	// we should include here the ability for work boats to cross to other areas with cities
; 2460 : 	if(pPlot->area() != pUnit->area())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	esi, eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	cmp	esi, eax
	je	$LN17@ShouldBuil

; 2461 : 	{
; 2462 : #ifdef AUI_WORKER_FIX_SHOULD_CONSIDER_PLOT_WORK_BOATS_CONSIDER_ALL_SEA_PLOTS
; 2463 : 		if (pUnit->getDomainType() != DOMAIN_SEA && !pUnit->CanEverEmbark())
; 2464 : 		{
; 2465 : 			if (m_bLogging)
; 2466 : 			{
; 2467 : 				CvString strLog;
; 2468 : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, plot area: %d, unit area: %d,,Plot areas don't match and can't embark", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY(), pPlot->area(), pUnit->area());
; 2469 : 				if (pPlot->isWater() == pUnit->plot()->isWater())
; 2470 : 				{
; 2471 : 					strLog += ",This is weird";
; 2472 : 				}
; 2473 : 				else
; 2474 : 				{
; 2475 : 					strLog += ",This is normal";
; 2476 : 				}
; 2477 : 				LogInfo(strLog, m_pPlayer);
; 2478 : 			}
; 2479 : 			return false;
; 2480 : 		}
; 2481 : #else
; 2482 : 		bool bCanCrossToNewArea = false;

	mov	BYTE PTR _bCanCrossToNewArea$217859[ebp], 0

; 2483 : 
; 2484 : 		if(pUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN16@ShouldBuil

; 2485 : 		{
; 2486 : 			if(pPlot->isAdjacentToArea(pUnit->area()))

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isAdjacentToArea@CvPlot@@QBE_NPBVCvArea@@@Z ; CvPlot::isAdjacentToArea
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@ShouldBuil

; 2487 : 			{
; 2488 : 				bCanCrossToNewArea = true;

	mov	BYTE PTR _bCanCrossToNewArea$217859[ebp], 1
$LN15@ShouldBuil:

; 2489 : 			}
; 2490 : 		}
; 2491 : 		else

	jmp	SHORT $LN14@ShouldBuil
$LN16@ShouldBuil:

; 2492 : 		{
; 2493 : 			if(pUnit->CanEverEmbark())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@ShouldBuil

; 2494 : 			{
; 2495 : 				bCanCrossToNewArea = true;

	mov	BYTE PTR _bCanCrossToNewArea$217859[ebp], 1
$LN14@ShouldBuil:

; 2496 : 			}
; 2497 : 		}
; 2498 : 
; 2499 : 		if(!bCanCrossToNewArea)

	movzx	ecx, BYTE PTR _bCanCrossToNewArea$217859[ebp]
	test	ecx, ecx
	jne	$LN17@ShouldBuil

; 2500 : 		{
; 2501 : 			if(m_bLogging)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	$LN11@ShouldBuil

; 2502 : 			{
; 2503 : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$217866[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2504 : 				strLog.Format("unitx: %d unity: %d, plotx: %d ploty: %d, plot area: %d, unit area: %d,,Plot areas don't match and can't embark", pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY(), pPlot->area(), pUnit->area());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T222555[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T222559[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T222568[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T222577[ebp], edx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?area@CvUnit@@QBEPAVCvArea@@XZ		; CvUnit::area
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	push	eax
	mov	eax, DWORD PTR $T222555[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222559[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222568[ebp]
	push	edx
	mov	eax, DWORD PTR $T222577[ebp]
	push	eax
	push	OFFSET ??_C@_0HA@IMLHLIBP@unitx?3?5?$CFd?5unity?3?5?$CFd?0?5plotx?3?5?$CFd?5p@
	lea	ecx, DWORD PTR _strLog$217866[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 32					; 00000020H

; 2505 : 				if(pPlot->isWater() == pUnit->plot()->isWater())

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR $T222581[ebp], cl
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR $T222585[ebp], eax
	movzx	edx, BYTE PTR $T222581[ebp]
	mov	eax, DWORD PTR $T222585[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	eax, eax
	cmp	ecx, 3
	sete	al
	movzx	ecx, al
	cmp	edx, ecx
	jne	SHORT $LN10@ShouldBuil

; 2506 : 				{
; 2507 : 					strLog += ",This is weird";

	push	OFFSET ??_C@_0P@FILALACM@?0This?5is?5weird?$AA@
	lea	ecx, DWORD PTR _strLog$217866[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 2508 : 				}
; 2509 : 				else

	jmp	SHORT $LN9@ShouldBuil
$LN10@ShouldBuil:

; 2510 : 				{
; 2511 : 					strLog += ",This is normal";

	push	OFFSET ??_C@_0BA@LBJECBDC@?0This?5is?5normal?$AA@
	lea	ecx, DWORD PTR _strLog$217866[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN9@ShouldBuil:

; 2512 : 				}
; 2513 : 				LogInfo(strLog, m_pPlayer);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T222486[ebp], esp
	mov	DWORD PTR $T222590[ebp], ecx
	lea	edx, DWORD PTR _strLog$217866[ebp]
	push	edx
	mov	ecx, DWORD PTR $T222590[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T222590[ebp]
	mov	DWORD PTR tv383[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2514 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217866[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@ShouldBuil:

; 2515 : 			return false;

	xor	al, al
	jmp	$LN29@ShouldBuil
$LN17@ShouldBuil:

; 2516 : 		}
; 2517 : #endif
; 2518 : 	}
; 2519 : 
; 2520 : #ifndef AUI_WORKER_FIX_SHOULD_BUILDER_CONSIDER_PLOT_EXISTING_BUILD_MISSIONS_SHIFT
; 2521 : 	// check to see if someone already has a mission here
; 2522 : 	if(pUnit->GetMissionAIPlot() != pPlot)

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetMissionAIPlot@CvUnit@@QAEPAVCvPlot@@XZ ; CvUnit::GetMissionAIPlot
	cmp	eax, DWORD PTR _pPlot$[ebp]
	je	$LN8@ShouldBuil

; 2523 : 	{
; 2524 : 		if(m_pPlayer->AI_plotTargetMissionAIs(pPlot, MISSIONAI_BUILD) > 0)

	push	0
	push	18					; 00000012H
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+64]
	call	eax
	test	eax, eax
	jle	$LN8@ShouldBuil

; 2525 : 		{
; 2526 : 			if(m_bLogging)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+58392]
	test	edx, edx
	je	$LN6@ShouldBuil

; 2527 : 			{
; 2528 : 				CvString strLog;

	lea	ecx, DWORD PTR _strLog$217876[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2529 : 				strLog.Format("x: %d y: %d,,Somebody has a mission here, ", pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T222602[ebp], ecx
	mov	edx, DWORD PTR $T222602[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0CL@KLNPMPBF@x?3?5?$CFd?5y?3?5?$CFd?0?0Somebody?5has?5a?5miss@
	lea	edx, DWORD PTR _strLog$217876[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2530 : 				LogInfo(strLog, m_pPlayer, true);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T222487[ebp], esp
	mov	DWORD PTR $T222610[ebp], edx
	lea	eax, DWORD PTR _strLog$217876[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222610[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T222610[ebp]
	mov	DWORD PTR tv388[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2531 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217876[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@ShouldBuil:

; 2532 : 
; 2533 : 			return false;

	xor	al, al
	jmp	$LN29@ShouldBuil
$LN8@ShouldBuil:

; 2534 : 		}
; 2535 : 	}
; 2536 : #endif
; 2537 : 
; 2538 : #if defined(AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH)
; 2539 : if ((!pUnit->IsCombatUnit() && m_pPlayer->GetPlotDanger(*pPlot) > 0) ||
; 2540 : 	m_pPlayer->GetPlotDanger(*pPlot) > pUnit->GetBaseCombatStrengthConsideringDamage() * AUI_WORKER_SHOULD_BUILDER_CONSIDER_PLOT_MAXIMUM_DANGER_BASED_ON_UNIT_STRENGTH)
; 2541 : #else
; 2542 : if (m_pPlayer->GetPlotDanger(*pPlot) > 0)

	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	$LN5@ShouldBuil

; 2543 : #endif
; 2544 : 	if(m_pPlayer->GetPlotDanger(*pPlot) > 0)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	$LN5@ShouldBuil

; 2545 : 	{
; 2546 : 		if(m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN3@ShouldBuil

; 2547 : 		{
; 2548 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$217882[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 2549 : 			strLog.Format("plotX: %d plotY: %d, danger: %d,, bailing due to danger", pPlot->getX(), pPlot->getY(), m_pPlayer->GetPlotDanger(*pPlot));

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T222622[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T222626[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	push	eax
	mov	edx, DWORD PTR $T222622[ebp]
	push	edx
	mov	eax, DWORD PTR $T222626[ebp]
	push	eax
	push	OFFSET ??_C@_0DI@FKACIEBE@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?5danger?3?5?$CFd?0@
	lea	ecx, DWORD PTR _strLog$217882[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 2550 : 			LogInfo(strLog, m_pPlayer, true);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T222488[ebp], esp
	mov	DWORD PTR $T222631[ebp], ecx
	lea	edx, DWORD PTR _strLog$217882[ebp]
	push	edx
	mov	ecx, DWORD PTR $T222631[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T222631[ebp]
	mov	DWORD PTR tv393[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2551 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217882[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@ShouldBuil:

; 2552 : 
; 2553 : 		return false;

	xor	al, al
	jmp	$LN29@ShouldBuil
$LN5@ShouldBuil:

; 2554 : 	}
; 2555 : 
; 2556 : 	if(!pUnit->atPlot(*pPlot) && pPlot->getNumFriendlyUnitsOfType(pUnit) >= GC.getPLOT_UNIT_LIMIT())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?atPlot@CvUnit@@QBE_NABVCvPlot@@@Z	; CvUnit::atPlot
	movzx	edx, al
	test	edx, edx
	jne	$LN2@ShouldBuil
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7356
	mov	DWORD PTR $T222639[ebp], eax
	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumFriendlyUnitsOfType@CvPlot@@QBEHPBVCvUnit@@_N@Z ; CvPlot::getNumFriendlyUnitsOfType
	cmp	eax, DWORD PTR $T222639[ebp]
	jl	$LN2@ShouldBuil

; 2557 : 	{
; 2558 : 		if(m_bLogging)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	$LN1@ShouldBuil

; 2559 : 		{
; 2560 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$217887[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 2561 : 			strLog.Format("plotX: %d plotY: %d,, this tile is full with another unit. bailing!", pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T222647[ebp], edx
	mov	eax, DWORD PTR $T222647[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET ??_C@_0EE@ONNNHHME@plotX?3?5?$CFd?5plotY?3?5?$CFd?0?0?5this?5tile?5@
	lea	eax, DWORD PTR _strLog$217887[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2562 : 			LogInfo(strLog, m_pPlayer, true);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T222489[ebp], esp
	mov	DWORD PTR $T222655[ebp], eax
	lea	ecx, DWORD PTR _strLog$217887[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222655[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T222655[ebp]
	mov	DWORD PTR tv398[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 2563 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$217887[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ShouldBuil:

; 2564 : 
; 2565 : 		return false;

	xor	al, al
	jmp	SHORT $LN29@ShouldBuil
$LN2@ShouldBuil:

; 2566 : 	}
; 2567 : 
; 2568 : 	return true;

	mov	al, 1
$LN29@ShouldBuil:

; 2569 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _strLog$217844[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$2:
	lea	ecx, DWORD PTR _strLog$217866[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$4:
	lea	ecx, DWORD PTR _strLog$217876[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$6:
	lea	ecx, DWORD PTR _strLog$217882[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z$8:
	lea	ecx, DWORD PTR _strLog$217887[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldBuilderConsiderPlot@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::ShouldBuilderConsiderPlot
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Odtp
;	COMDAT ?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
$T222693 = -20						; size = 4
$T222684 = -16						; size = 4
$T222675 = -12						; size = 4
$T222671 = -8						; size = 4
_iPlotDistance$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::FindTurnsAway, COMDAT
; _this$ = ecx

; 2573 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2574 : 	// If this plot is far away, we'll just use its distance as an estimate of the time to get there (to avoid hitting the path finder)
; 2575 : 	// We'll be sure to check later to make sure we have a real path before we execute this
; 2576 : 	if(pUnit->getDomainType() == DOMAIN_LAND && pUnit->plot()->area() != pPlot->area() && !pUnit->CanEverEmbark())

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN1@FindTurnsA
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, eax
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	esi, eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	esi, eax
	je	SHORT $LN1@FindTurnsA
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@FindTurnsA

; 2577 : 	{
; 2578 : 		return -1;

	or	eax, -1
	jmp	SHORT $LN2@FindTurnsA
$LN1@FindTurnsA:

; 2579 : 	}
; 2580 : 
; 2581 : #ifdef AUI_WORKER_FIND_TURNS_AWAY_USES_PATHFINDER
; 2582 : 	int iPlotDistance = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, AUI_WORKER_FIND_TURNS_AWAY_USES_PATHFINDER /*bIgnoreUnits*/);
; 2583 : 	if (iPlotDistance < MAX_INT)
; 2584 : 		return iPlotDistance;
; 2585 : 	else
; 2586 : 		return -1;
; 2587 : #else
; 2588 : 	int iPlotDistance = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T222671[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T222675[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T222684[ebp], eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T222693[ebp], edx
	mov	eax, DWORD PTR $T222671[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222675[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222684[ebp]
	push	edx
	mov	eax, DWORD PTR $T222693[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$[ebp], eax

; 2589 : #if 1
; 2590 : 	// Always return the raw distance
; 2591 : 	return iPlotDistance;

	mov	eax, DWORD PTR _iPlotDistance$[ebp]
$LN2@FindTurnsA:

; 2592 : #else
; 2593 : 	if(iPlotDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())
; 2594 : 	{
; 2595 : 		return iPlotDistance;
; 2596 : 	}
; 2597 : 	else
; 2598 : 	{
; 2599 : 		int iResult = TurnsToReachTarget(pUnit, pPlot);
; 2600 : 		if(iResult == MAX_INT)
; 2601 : 		{
; 2602 : 			return -1;
; 2603 : 		}
; 2604 : 
; 2605 : 		return iResult;
; 2606 : 	}
; 2607 : #endif
; 2608 : #endif
; 2609 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?FindTurnsAway@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::FindTurnsAway
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T222862 = -80						; size = 4
$T222835 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T222835[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T222835[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T222835[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T222862[ebp], edx
	mov	eax, DWORD PTR $T222862[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T222885 = -16						; size = 4
$T222877 = -12						; size = 4
$T222873 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T222873[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T222877[ebp], ecx
	movzx	edx, BYTE PTR $T222873[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T222877[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T222877[ebp]
	mov	DWORD PTR $T222885[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T222877[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T222877[ebp]
	mov	DWORD PTR $T222885[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T222885[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T222885[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T222906 = -16						; size = 4
$T222898 = -12						; size = 4
$T222894 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T222894[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T222898[ebp], ecx
	movzx	edx, BYTE PTR $T222894[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T222898[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T222898[ebp]
	mov	DWORD PTR $T222906[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T222898[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T222898[ebp]
	mov	DWORD PTR $T222906[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T222906[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T222906[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
EXTRN	?getBuildCost@CvPlayer@@QBEHPBVCvPlot@@W4BuildTypes@@@Z:PROC ; CvPlayer::getBuildCost
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iBuildCost$ = -4					; size = 4
_iWeight$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_eBuild$ = 16						; size = 4
?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z PROC ; CvBuilderTaskingAI::GetBuildCostWeight, COMDAT
; _this$ = ecx

; 2613 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2614 : 	int iBuildCost = m_pPlayer->getBuildCost(pPlot, eBuild);

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getBuildCost@CvPlayer@@QBEHPBVCvPlot@@W4BuildTypes@@@Z ; CvPlayer::getBuildCost
	mov	DWORD PTR _iBuildCost$[ebp], eax

; 2615 : 	if(iBuildCost > 0)

	cmp	DWORD PTR _iBuildCost$[ebp], 0
	jle	SHORT $LN2@GetBuildCo

; 2616 : 	{
; 2617 : 		iWeight = (iWeight * 100) / iBuildCost;

	mov	eax, DWORD PTR _iWeight$[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iBuildCost$[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax

; 2618 : 	}
; 2619 : 	else

	jmp	SHORT $LN1@GetBuildCo
$LN2@GetBuildCo:

; 2620 : 	{
; 2621 : 		//if (m_bLogging)
; 2622 : 		//{
; 2623 : 		//	LogInfo("Build cost is zero", m_pPlayer);
; 2624 : 		//}
; 2625 : 		iWeight = (iWeight * 100);

	mov	eax, DWORD PTR _iWeight$[ebp]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iWeight$[ebp], eax
$LN1@GetBuildCo:

; 2626 : 	}
; 2627 : 	return iWeight;

	mov	eax, DWORD PTR _iWeight$[ebp]

; 2628 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetBuildCostWeight@CvBuilderTaskingAI@@QAEHHPAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvBuilderTaskingAI::GetBuildCostWeight
_TEXT	ENDS
EXTRN	?getFeatureTime@CvBuildInfo@@QBEHH@Z:PROC	; CvBuildInfo::getFeatureTime
EXTRN	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z:PROC ; CvPlot::getBuildTurnsLeft
EXTRN	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z:PROC	; CvUnit::workRate
; Function compile flags: /Odtp
;	COMDAT ?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z
_TEXT	SEGMENT
tv160 = -36						; size = 4
_this$ = -32						; size = 4
_f$222952 = -26						; size = 1
_f$222943 = -25						; size = 1
$T222935 = -24						; size = 4
$T222928 = -20						; size = 4
$T222919 = -16						; size = 4
_iBuildTimeNormal$ = -12				; size = 4
_iBuildTurnsLeft$ = -8					; size = 4
_iBuildTime$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_eBuild$ = 16						; size = 4
_bIgnoreFeatureTime$ = 20				; size = 1
_iAdditionalTime$ = 24					; size = 4
?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z PROC ; CvBuilderTaskingAI::GetBuildTimeWeight, COMDAT
; _this$ = ecx

; 2632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 2633 : 	// if we need to repair this plot, replace the build with a repair build
; 2634 : 	if((GC.getBuildInfo(eBuild)->getImprovement() != NO_IMPROVEMENT && pPlot->IsImprovementPillaged()) || (GC.getBuildInfo(eBuild)->getRoute() != NO_ROUTE && pPlot->IsRoutePillaged()))

	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, -1
	je	SHORT $LN4@GetBuildTi
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@GetBuildTi
$LN4@GetBuildTi:
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getRoute@CvBuildInfo@@QBEHXZ		; CvBuildInfo::getRoute
	cmp	eax, -1
	je	SHORT $LN11@GetBuildTi
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?IsRoutePillaged@CvPlot@@QBE_NXZ	; CvPlot::IsRoutePillaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@GetBuildTi
$LN5@GetBuildTi:

; 2635 : 	{
; 2636 : 		// find a repair directive to replace
; 2637 : 		// find the repair build
; 2638 : 		eBuild = m_eRepairBuild;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _eBuild$[ebp], edx

; 2639 : 	}
; 2640 : 
; 2641 : 	int iBuildTimeNormal = pPlot->getBuildTime(eBuild, m_pPlayer->GetID());

$LN11@GetBuildTi:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T222919[ebp], edx
	mov	eax, DWORD PTR $T222919[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getBuildTime@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@@Z ; CvPlot::getBuildTime
	mov	DWORD PTR _iBuildTimeNormal$[ebp], eax

; 2642 : 	int iBuildTurnsLeft = pPlot->getBuildTurnsLeft(eBuild, m_pPlayer->GetID(), pUnit->workRate(true), pUnit->workRate(true));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T222928[ebp], ecx
	push	-1
	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	push	eax
	push	-1
	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?workRate@CvUnit@@QBEH_NW4BuildTypes@@@Z ; CvUnit::workRate
	push	eax
	mov	edx, DWORD PTR $T222928[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getBuildTurnsLeft@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@HH@Z ; CvPlot::getBuildTurnsLeft
	mov	DWORD PTR _iBuildTurnsLeft$[ebp], eax

; 2643 : 	int iBuildTime = min(iBuildTimeNormal, iBuildTurnsLeft);

	mov	ecx, DWORD PTR _iBuildTurnsLeft$[ebp]
	cmp	ecx, DWORD PTR _iBuildTimeNormal$[ebp]
	jge	SHORT $LN19@GetBuildTi
	lea	edx, DWORD PTR _iBuildTurnsLeft$[ebp]
	mov	DWORD PTR tv160[ebp], edx
	jmp	SHORT $LN20@GetBuildTi
$LN19@GetBuildTi:
	lea	eax, DWORD PTR _iBuildTimeNormal$[ebp]
	mov	DWORD PTR tv160[ebp], eax
$LN20@GetBuildTi:
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR $T222935[ebp], ecx
	mov	edx, DWORD PTR $T222935[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iBuildTime$[ebp], eax

; 2644 : 	if(iBuildTime <= 0)

	cmp	DWORD PTR _iBuildTime$[ebp], 0
	jg	SHORT $LN3@GetBuildTi

; 2645 : 	{
; 2646 : 		iBuildTime = 1;

	mov	DWORD PTR _iBuildTime$[ebp], 1
$LN3@GetBuildTi:

; 2647 : 	}
; 2648 : 
; 2649 : 	if(bIgnoreFeatureTime)

	movzx	ecx, BYTE PTR _bIgnoreFeatureTime$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetBuildTi

; 2650 : 	{
; 2651 : 		if(pPlot->getFeatureType() != NO_FEATURE)

	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$222943[ebp], al
	movsx	ecx, BYTE PTR _f$222943[ebp]
	cmp	ecx, -1
	je	SHORT $LN2@GetBuildTi

; 2652 : 		{
; 2653 : 			iBuildTime -= GC.getBuildInfo(eBuild)->getFeatureTime(pPlot->getFeatureType());

	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$222952[ebp], al
	movsx	ecx, BYTE PTR _f$222952[ebp]
	push	ecx
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getFeatureTime@CvBuildInfo@@QBEHH@Z	; CvBuildInfo::getFeatureTime
	mov	ecx, DWORD PTR _iBuildTime$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iBuildTime$[ebp], ecx
$LN2@GetBuildTi:

; 2654 : 		}
; 2655 : 	}
; 2656 : 
; 2657 : 	iBuildTime += iAdditionalTime;

	mov	edx, DWORD PTR _iBuildTime$[ebp]
	add	edx, DWORD PTR _iAdditionalTime$[ebp]
	mov	DWORD PTR _iBuildTime$[ebp], edx

; 2658 : 
; 2659 : 	return 10000 / iBuildTime;

	mov	eax, 10000				; 00002710H
	cdq
	idiv	DWORD PTR _iBuildTime$[ebp]

; 2660 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetBuildTimeWeight@CvBuilderTaskingAI@@QAEHPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@_NH@Z ENDP ; CvBuilderTaskingAI::GetBuildTimeWeight
_TEXT	ENDS
EXTRN	?getNumResourceUsed@CvPlayer@@QBEHW4ResourceTypes@@@Z:PROC ; CvPlayer::getNumResourceUsed
EXTRN	?getTechCityTrade@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getTechCityTrade
EXTRN	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceAvailable
EXTRN	?getHappiness@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getHappiness
EXTRN	?GetFlavorValue@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetFlavorValue
EXTRN	?getFlavorValue@CvResourceInfo@@QBEHH@Z:PROC	; CvResourceInfo::getFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T222979 = -64						; size = 4
$T222975 = -60						; size = 4
$T222974 = -56						; size = 4
$T222965 = -52						; size = 4
$T222961 = -48						; size = 4
_iMultiplyingAmount$217955 = -44			; size = 4
_bHasTech$217952 = -37					; size = 1
_iModifier$217947 = -36					; size = 4
_iResourceFlavor$217936 = -32				; size = 4
_iImprovementFlavor$217942 = -28			; size = 4
_iUsableByCityWeight$217944 = -24			; size = 4
_iPersonalityFlavorValue$217938 = -20			; size = 4
_iResult$217940 = -16					; size = 4
_i$217932 = -12						; size = 4
_iWeight$ = -8						; size = 4
_pkResource$ = -4					; size = 4
_eResource$ = 8						; size = 4
_eImprovement$ = 12					; size = 4
_iQuantity$ = 16					; size = 4
?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z PROC ; CvBuilderTaskingAI::GetResourceWeight, COMDAT
; _this$ = ecx

; 2664 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 2665 : 	int iWeight = 0;

	mov	DWORD PTR _iWeight$[ebp], 0

; 2666 : 	CvResourceInfo* pkResource = GC.getResourceInfo(eResource);

	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResource$[ebp], eax

; 2667 : 	if(pkResource == NULL)

	cmp	DWORD PTR _pkResource$[ebp], 0
	jne	SHORT $LN16@GetResourc

; 2668 : 	{
; 2669 : 		return 0;

	xor	eax, eax
	jmp	$LN17@GetResourc
$LN16@GetResourc:

; 2670 : 	}
; 2671 : 
; 2672 : 	for(int i = 0; i < GC.getNumFlavorTypes(); i++)

	mov	DWORD PTR _i$217932[ebp], 0
	jmp	SHORT $LN15@GetResourc
$LN14@GetResourc:
	mov	ecx, DWORD PTR _i$217932[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$217932[ebp], ecx
$LN15@GetResourc:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T222961[ebp], edx
	mov	eax, DWORD PTR _i$217932[ebp]
	cmp	eax, DWORD PTR $T222961[ebp]
	jge	$LN13@GetResourc

; 2673 : 	{
; 2674 : 		int iResourceFlavor = pkResource->getFlavorValue((FlavorTypes)i);

	mov	ecx, DWORD PTR _i$217932[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkResource$[ebp]
	call	?getFlavorValue@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getFlavorValue
	mov	DWORD PTR _iResourceFlavor$217936[ebp], eax

; 2675 : 		int iPersonalityFlavorValue = m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)i);

	mov	edx, DWORD PTR _i$217932[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR _iPersonalityFlavorValue$217938[ebp], eax

; 2676 : 		int iResult = iResourceFlavor * iPersonalityFlavorValue;

	mov	ecx, DWORD PTR _iResourceFlavor$217936[ebp]
	imul	ecx, DWORD PTR _iPersonalityFlavorValue$217938[ebp]
	mov	DWORD PTR _iResult$217940[ebp], ecx

; 2677 : 
; 2678 : 		if(iResult > 0)

	cmp	DWORD PTR _iResult$217940[ebp], 0
	jle	SHORT $LN12@GetResourc

; 2679 : 		{
; 2680 : 			iWeight += iResult;

	mov	edx, DWORD PTR _iWeight$[ebp]
	add	edx, DWORD PTR _iResult$217940[ebp]
	mov	DWORD PTR _iWeight$[ebp], edx
$LN12@GetResourc:

; 2681 : 		}
; 2682 : 
; 2683 : 		int iImprovementFlavor = 1;

	mov	DWORD PTR _iImprovementFlavor$217942[ebp], 1

; 2684 : 		if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN11@GetResourc

; 2685 : 		{
; 2686 : 			iImprovementFlavor = GC.getImprovementInfo(eImprovement)->GetFlavorValue(i);

	mov	eax, DWORD PTR _i$217932[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetFlavorValue@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetFlavorValue
	mov	DWORD PTR _iImprovementFlavor$217942[ebp], eax
$LN11@GetResourc:

; 2687 : 		}
; 2688 : 
; 2689 : 		int iUsableByCityWeight = iPersonalityFlavorValue * iImprovementFlavor;

	mov	edx, DWORD PTR _iPersonalityFlavorValue$217938[ebp]
	imul	edx, DWORD PTR _iImprovementFlavor$217942[ebp]
	mov	DWORD PTR _iUsableByCityWeight$217944[ebp], edx

; 2690 : 		if(iUsableByCityWeight > 0)

	cmp	DWORD PTR _iUsableByCityWeight$217944[ebp], 0
	jle	SHORT $LN10@GetResourc

; 2691 : 		{
; 2692 : 			iWeight += iUsableByCityWeight;

	mov	eax, DWORD PTR _iWeight$[ebp]
	add	eax, DWORD PTR _iUsableByCityWeight$217944[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax
$LN10@GetResourc:

; 2693 : 		}
; 2694 : 	}

	jmp	$LN14@GetResourc
$LN13@GetResourc:

; 2695 : 
; 2696 : 	// if the empire is unhappy (or close to it) and this is a luxury resource the player doesn't have, provide a super bonus to getting it
; 2697 : 	if(pkResource->getResourceUsage() == RESOURCEUSAGE_LUXURY)

	mov	ecx, DWORD PTR _pkResource$[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 2
	jne	SHORT $LN9@GetResourc

; 2698 : 	{
; 2699 : 		int iModifier = GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE() * pkResource->getHappiness();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2124
	mov	DWORD PTR $T222965[ebp], ecx
	mov	ecx, DWORD PTR _pkResource$[ebp]
	call	?getHappiness@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getHappiness
	imul	eax, DWORD PTR $T222965[ebp]
	mov	DWORD PTR _iModifier$217947[ebp], eax

; 2700 : #ifdef AUI_WORKER_GET_RESOURCE_WEIGHT_CONSIDER_EXTRAS_FOR_HAPPINESS_FROM_RESOURCE
; 2701 : 		iModifier += GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE() * m_pPlayer->GetExtraHappinessPerLuxury();
; 2702 : #endif
; 2703 : 
; 2704 : 		//if (m_pPlayer->IsEmpireUnhappy() || m_pPlayer->GetExcessHappiness() <= 2)
; 2705 : 		//{
; 2706 : 		//}
; 2707 : 		if(m_pPlayer->getNumResourceAvailable(eResource) == 0)

	push	1
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	test	eax, eax
	jne	SHORT $LN8@GetResourc

; 2708 : 		{
; 2709 : 			// full bonus
; 2710 : #ifdef AUI_WORKER_GET_RESOURCE_WEIGHT_CONSIDER_EXTRAS_FOR_HAPPINESS_FROM_RESOURCE
; 2711 : 			if (m_pPlayer->GetPlayerTraits()->GetLuxuryHappinessRetention() > 0)
; 2712 : 				iModifier = iModifier * (m_pPlayer->GetPlayerTraits()->GetLuxuryHappinessRetention() + pkResource->getHappiness()) / pkResource->getHappiness();
; 2713 : 			iModifier += GC.getBUILDER_TASKING_PLOT_EVAL_MULTIPLIER_LUXURY_RESOURCE() * GC.getHAPPINESS_PER_EXTRA_LUXURY();
; 2714 : #endif
; 2715 : #ifdef AUI_WORKER_GET_RESOURCE_WEIGHT_INCREASE_UNOWNED_LUXURY_WEIGHT
; 2716 : 			if (m_pPlayer->GetExcessHappiness() < -GC.getVERY_UNHAPPY_THRESHOLD())
; 2717 : 			{
; 2718 : 				iModifier = int(iModifier * pow(AUI_WORKER_GET_RESOURCE_WEIGHT_INCREASE_UNOWNED_LUXURY_WEIGHT, 1.0 - (double)m_pPlayer->GetExcessHappiness() / -(double)GC.getVERY_UNHAPPY_THRESHOLD()) + 0.5);
; 2719 : 			}
; 2720 : #endif
; 2721 : 		}
; 2722 : 		else

	jmp	SHORT $LN7@GetResourc
$LN8@GetResourc:

; 2723 : 		{
; 2724 : 			iModifier = (iModifier * 3) / 4; // 3/4ths the awesome bonus, so that we pick up extra resources 

	mov	eax, DWORD PTR _iModifier$217947[ebp]
	imul	eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _iModifier$217947[ebp], eax
$LN7@GetResourc:

; 2725 : 		}
; 2726 : 
; 2727 : 		iWeight *= iModifier;

	mov	ecx, DWORD PTR _iWeight$[ebp]
	imul	ecx, DWORD PTR _iModifier$217947[ebp]
	mov	DWORD PTR _iWeight$[ebp], ecx
	jmp	$LN6@GetResourc
$LN9@GetResourc:

; 2728 : 	}
; 2729 : 	else if(pkResource->getResourceUsage() == RESOURCEUSAGE_STRATEGIC && pkResource->getTechCityTrade())

	mov	ecx, DWORD PTR _pkResource$[ebp]
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	cmp	eax, 1
	jne	$LN6@GetResourc
	mov	ecx, DWORD PTR _pkResource$[ebp]
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	test	eax, eax
	je	$LN6@GetResourc

; 2730 : 	{
; 2731 : 		bool bHasTech = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes) pkResource->getTechCityTrade());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222974[ebp], eax
	mov	ecx, DWORD PTR $T222974[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T222975[ebp], eax
	mov	eax, DWORD PTR $T222975[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T222979[ebp], eax
	mov	ecx, DWORD PTR _pkResource$[ebp]
	call	?getTechCityTrade@CvResourceInfo@@QBEHXZ ; CvResourceInfo::getTechCityTrade
	push	eax
	mov	ecx, DWORD PTR $T222979[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	mov	BYTE PTR _bHasTech$217952[ebp], al

; 2732 : 		if(bHasTech)

	movzx	ecx, BYTE PTR _bHasTech$217952[ebp]
	test	ecx, ecx
	je	SHORT $LN6@GetResourc

; 2733 : 		{
; 2734 : 			// measure quantity
; 2735 : 			int iMultiplyingAmount = iQuantity * 200;

	mov	edx, DWORD PTR _iQuantity$[ebp]
	imul	edx, 200				; 000000c8H
	mov	DWORD PTR _iMultiplyingAmount$217955[ebp], edx

; 2736 : 
; 2737 : 			// if we don't have any currently available
; 2738 : 			if(m_pPlayer->getNumResourceAvailable(eResource) == 0)

	push	1
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getNumResourceAvailable@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceAvailable
	test	eax, eax
	jne	SHORT $LN3@GetResourc

; 2739 : 			{
; 2740 : 				// if we have some of the strategic resource, but all is used
; 2741 : 				if(m_pPlayer->getNumResourceUsed(eResource) > 0)

	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getNumResourceUsed@CvPlayer@@QBEHW4ResourceTypes@@@Z ; CvPlayer::getNumResourceUsed
	test	eax, eax
	jle	SHORT $LN2@GetResourc

; 2742 : 				{
; 2743 : 					iMultiplyingAmount *= 4;

	mov	ecx, DWORD PTR _iMultiplyingAmount$217955[ebp]
	shl	ecx, 2
	mov	DWORD PTR _iMultiplyingAmount$217955[ebp], ecx

; 2744 : 				}
; 2745 : 				else

	jmp	SHORT $LN3@GetResourc
$LN2@GetResourc:

; 2746 : 				{
; 2747 : 					// if we don't have any of it
; 2748 : #ifdef AUI_WORKER_TWEAKED_DONT_HAVE_MULTIPLIER
; 2749 : 					iMultiplyingAmount *= AUI_WORKER_TWEAKED_DONT_HAVE_MULTIPLIER;
; 2750 : #else
; 2751 : 					iMultiplyingAmount *= 4;

	mov	edx, DWORD PTR _iMultiplyingAmount$217955[ebp]
	shl	edx, 2
	mov	DWORD PTR _iMultiplyingAmount$217955[ebp], edx
$LN3@GetResourc:

; 2752 : #endif
; 2753 : 				}
; 2754 : 			}
; 2755 : 
; 2756 : 			iWeight *= iMultiplyingAmount;

	mov	eax, DWORD PTR _iWeight$[ebp]
	imul	eax, DWORD PTR _iMultiplyingAmount$217955[ebp]
	mov	DWORD PTR _iWeight$[ebp], eax
$LN6@GetResourc:

; 2757 : 		}
; 2758 : 	}
; 2759 : 
; 2760 : 	return iWeight;

	mov	eax, DWORD PTR _iWeight$[ebp]
$LN17@GetResourc:

; 2761 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetResourceWeight@CvBuilderTaskingAI@@QAEHW4ResourceTypes@@W4ImprovementTypes@@H@Z ENDP ; CvBuilderTaskingAI::GetResourceWeight
_TEXT	ENDS
PUBLIC	?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z ; CvBuilderTaskingAI::IsImprovementBeneficial
EXTRN	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z:PROC ; CvPlot::calculateImprovementYieldChange
EXTRN	?getYieldChange@CvRouteInfo@@QBEHH@Z:PROC	; CvRouteInfo::getYieldChange
; Function compile flags: /Odtp
;	COMDAT ?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T223019 = -104						; size = 4
$T223010 = -100						; size = 4
$T223009 = -96						; size = 4
$T223000 = -92						; size = 4
$T222999 = -88						; size = 4
_f$222987 = -81						; size = 1
_ui$217991 = -80					; size = 4
_bIgnoreFeature$217985 = -73				; size = 1
_ui$217980 = -72					; size = 4
_pkImprovementInfo$ = -68				; size = 4
_aiImprovedYieldTypes$ = -64				; size = 24
_eImprovement$ = -40					; size = 4
_pkPlotRouteInfo$ = -36					; size = 4
_aiNaturalYieldTypes$ = -32				; size = 24
_bFeatureNeedsRemove$ = -5				; size = 1
_eFeature$ = -4						; size = 4
_pPlot$ = 8						; size = 4
_kBuild$ = 12						; size = 4
_eYield$ = 16						; size = 4
_bIsBreakEvenOK$ = 20					; size = 1
?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z PROC ; CvBuilderTaskingAI::IsImprovementBeneficial, COMDAT
; _this$ = ecx

; 2766 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 2767 : 	const ImprovementTypes eImprovement = (ImprovementTypes)kBuild.getImprovement();

	mov	ecx, DWORD PTR _kBuild$[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$[ebp], eax

; 2768 : 
; 2769 : 	const FeatureTypes eFeature = pPlot->getFeatureType();

	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$222987[ebp], cl
	movsx	edx, BYTE PTR _f$222987[ebp]
	mov	DWORD PTR _eFeature$[ebp], edx

; 2770 : 
; 2771 : 	bool bFeatureNeedsRemove = false;

	mov	BYTE PTR _bFeatureNeedsRemove$[ebp], 0

; 2772 : 
; 2773 : 	if(eFeature != NO_FEATURE)

	cmp	DWORD PTR _eFeature$[ebp], -1
	je	SHORT $LN24@IsImprovem

; 2774 : 	{
; 2775 : 		if(kBuild.isFeatureRemove(eFeature))

	mov	eax, DWORD PTR _eFeature$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kBuild$[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN24@IsImprovem

; 2776 : 		{
; 2777 : 			bFeatureNeedsRemove = true;

	mov	BYTE PTR _bFeatureNeedsRemove$[ebp], 1
$LN24@IsImprovem:

; 2778 : 		}
; 2779 : 	}
; 2780 : 
; 2781 : 	CvImprovementEntry* pkImprovementInfo = NULL;

	mov	DWORD PTR _pkImprovementInfo$[ebp], 0

; 2782 : 	if(eImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$[ebp], -1
	je	SHORT $LN22@IsImprovem

; 2783 : 	{
; 2784 : 		pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$[ebp], eax
$LN22@IsImprovem:

; 2785 : 	}
; 2786 : 	CvAssert(pkImprovementInfo);
; 2787 : 
; 2788 : 	//This can technically happen if a build as passed in that doesn't contain an improvement..
; 2789 : 	//Returning false isn't the ideal error approach, but there's nothing better to do atm.
; 2790 : 	if(pkImprovementInfo == NULL)

	cmp	DWORD PTR _pkImprovementInfo$[ebp], 0
	jne	SHORT $LN21@IsImprovem

; 2791 : 	{
; 2792 : 		return false;

	xor	al, al
	jmp	$LN25@IsImprovem
$LN21@IsImprovem:

; 2793 : 	}
; 2794 : 
; 2795 : 	CvRouteInfo* pkPlotRouteInfo = NULL;

	mov	DWORD PTR _pkPlotRouteInfo$[ebp], 0

; 2796 : 	if(pPlot->getRouteType() != NO_ROUTE)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN20@IsImprovem

; 2797 : 	{
; 2798 : 		pkPlotRouteInfo = GC.getRouteInfo(pPlot->getRouteType());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkPlotRouteInfo$[ebp], eax
$LN20@IsImprovem:

; 2799 : 	}
; 2800 : 
; 2801 : 
; 2802 : 	int aiNaturalYieldTypes[NUM_YIELD_TYPES];
; 2803 : 	int aiImprovedYieldTypes[NUM_YIELD_TYPES];
; 2804 : 
; 2805 : 	// hacky solution for the great artist's landmark.
; 2806 : 	// if an improvement generates culture, then it is beneficial
; 2807 : 	if(pkImprovementInfo->GetYieldChange(YIELD_CULTURE) > 0)

	push	4
	mov	ecx, DWORD PTR _pkImprovementInfo$[ebp]
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN19@IsImprovem

; 2808 : 	{
; 2809 : 		return true;

	mov	al, 1
	jmp	$LN25@IsImprovem
$LN19@IsImprovem:

; 2810 : 	}
; 2811 : 
; 2812 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$217980[ebp], 0
	jmp	SHORT $LN18@IsImprovem
$LN17@IsImprovem:
	mov	eax, DWORD PTR _ui$217980[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$217980[ebp], eax
$LN18@IsImprovem:
	cmp	DWORD PTR _ui$217980[ebp], 6
	jae	$LN16@IsImprovem

; 2813 : 	{
; 2814 : 		// calculate natural yields
; 2815 : 		aiNaturalYieldTypes[ui] = 0;

	mov	ecx, DWORD PTR _ui$217980[ebp]
	mov	DWORD PTR _aiNaturalYieldTypes$[ebp+ecx*4], 0

; 2816 : 		aiNaturalYieldTypes[ui] = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T222999[ebp], eax
	mov	ecx, DWORD PTR $T222999[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223000[ebp], eax
	push	0
	mov	eax, DWORD PTR $T223000[ebp]
	push	eax
	mov	ecx, DWORD PTR _ui$217980[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	edx, DWORD PTR _ui$217980[ebp]
	mov	DWORD PTR _aiNaturalYieldTypes$[ebp+edx*4], eax

; 2817 : 
; 2818 : 		// calculate improvement yields
; 2819 : 		aiImprovedYieldTypes[ui] = 0;

	mov	eax, DWORD PTR _ui$217980[ebp]
	mov	DWORD PTR _aiImprovedYieldTypes$[ebp+eax*4], 0

; 2820 : 
; 2821 : 		bool bIgnoreFeature = false;

	mov	BYTE PTR _bIgnoreFeature$217985[ebp], 0

; 2822 : 		if(bFeatureNeedsRemove)

	movzx	ecx, BYTE PTR _bFeatureNeedsRemove$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@IsImprovem

; 2823 : 		{
; 2824 : 			bIgnoreFeature = true;

	mov	BYTE PTR _bIgnoreFeature$217985[ebp], 1
$LN15@IsImprovem:

; 2825 : 		}
; 2826 : 
; 2827 : 		aiImprovedYieldTypes[ui] = pPlot->calculateNatureYield((YieldTypes)ui, m_pPlayer->getTeam(), bIgnoreFeature);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223009[ebp], eax
	mov	ecx, DWORD PTR $T223009[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223010[ebp], eax
	movzx	eax, BYTE PTR _bIgnoreFeature$217985[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223010[ebp]
	push	ecx
	mov	edx, DWORD PTR _ui$217980[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	mov	ecx, DWORD PTR _ui$217980[ebp]
	mov	DWORD PTR _aiImprovedYieldTypes$[ebp+ecx*4], eax

; 2828 : 		if(pkPlotRouteInfo)

	cmp	DWORD PTR _pkPlotRouteInfo$[ebp], 0
	je	SHORT $LN41@IsImprovem

; 2829 : 		{
; 2830 : 			aiImprovedYieldTypes[ui] += pkPlotRouteInfo->getYieldChange(ui);

	mov	edx, DWORD PTR _ui$217980[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPlotRouteInfo$[ebp]
	call	?getYieldChange@CvRouteInfo@@QBEHH@Z	; CvRouteInfo::getYieldChange
	mov	ecx, DWORD PTR _ui$217980[ebp]
	add	eax, DWORD PTR _aiImprovedYieldTypes$[ebp+ecx*4]
	mov	edx, DWORD PTR _ui$217980[ebp]
	mov	DWORD PTR _aiImprovedYieldTypes$[ebp+edx*4], eax

; 2831 : 		}
; 2832 : 		aiImprovedYieldTypes[ui] += pPlot->calculateImprovementYieldChange(eImprovement, (YieldTypes)ui, m_pPlayer->GetID(), false /*bOptimal*/);

$LN41@IsImprovem:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T223019[ebp], edx
	push	2
	push	0
	mov	eax, DWORD PTR $T223019[ebp]
	push	eax
	mov	ecx, DWORD PTR _ui$217980[ebp]
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateImprovementYieldChange@CvPlot@@QBEHW4ImprovementTypes@@W4YieldTypes@@W4PlayerTypes@@_NW4RouteTypes@@@Z ; CvPlot::calculateImprovementYieldChange
	mov	ecx, DWORD PTR _ui$217980[ebp]
	add	eax, DWORD PTR _aiImprovedYieldTypes$[ebp+ecx*4]
	mov	edx, DWORD PTR _ui$217980[ebp]
	mov	DWORD PTR _aiImprovedYieldTypes$[ebp+edx*4], eax

; 2833 : 	}

	jmp	$LN17@IsImprovem
$LN16@IsImprovem:

; 2834 : 
; 2835 : 	if(eYield == NO_YIELD)

	cmp	DWORD PTR _eYield$[ebp], -1
	jne	SHORT $LN13@IsImprovem

; 2836 : 	{
; 2837 : 		// if any of the yields are increased from their natural state, then the improvement is considered a success
; 2838 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$217991[ebp], 0
	jmp	SHORT $LN12@IsImprovem
$LN11@IsImprovem:
	mov	eax, DWORD PTR _ui$217991[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$217991[ebp], eax
$LN12@IsImprovem:
	cmp	DWORD PTR _ui$217991[ebp], 6
	jae	SHORT $LN10@IsImprovem

; 2839 : 		{
; 2840 : 			if(bIsBreakEvenOK)

	movzx	ecx, BYTE PTR _bIsBreakEvenOK$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@IsImprovem

; 2841 : 			{
; 2842 : 				if(aiImprovedYieldTypes[ui] >= aiNaturalYieldTypes[ui])

	mov	edx, DWORD PTR _ui$217991[ebp]
	mov	eax, DWORD PTR _ui$217991[ebp]
	mov	ecx, DWORD PTR _aiImprovedYieldTypes$[ebp+edx*4]
	cmp	ecx, DWORD PTR _aiNaturalYieldTypes$[ebp+eax*4]
	jl	SHORT $LN8@IsImprovem

; 2843 : 				{
; 2844 : 					return true;

	mov	al, 1
	jmp	SHORT $LN25@IsImprovem
$LN8@IsImprovem:

; 2845 : 				}
; 2846 : 			}
; 2847 : 			else

	jmp	SHORT $LN7@IsImprovem
$LN9@IsImprovem:

; 2848 : 			{
; 2849 : 				if(aiImprovedYieldTypes[ui] > aiNaturalYieldTypes[ui])

	mov	edx, DWORD PTR _ui$217991[ebp]
	mov	eax, DWORD PTR _ui$217991[ebp]
	mov	ecx, DWORD PTR _aiImprovedYieldTypes$[ebp+edx*4]
	cmp	ecx, DWORD PTR _aiNaturalYieldTypes$[ebp+eax*4]
	jle	SHORT $LN7@IsImprovem

; 2850 : 				{
; 2851 : 					return true;

	mov	al, 1
	jmp	SHORT $LN25@IsImprovem
$LN7@IsImprovem:

; 2852 : 				}
; 2853 : 			}
; 2854 : 		}

	jmp	SHORT $LN11@IsImprovem
$LN10@IsImprovem:

; 2855 : 	}
; 2856 : 	else

	jmp	SHORT $LN5@IsImprovem
$LN13@IsImprovem:

; 2857 : 	{
; 2858 : 		if(bIsBreakEvenOK)

	movzx	edx, BYTE PTR _bIsBreakEvenOK$[ebp]
	test	edx, edx
	je	SHORT $LN4@IsImprovem

; 2859 : 		{
; 2860 : 			if(aiImprovedYieldTypes[eYield] >= aiNaturalYieldTypes[eYield])

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR _aiImprovedYieldTypes$[ebp+eax*4]
	cmp	edx, DWORD PTR _aiNaturalYieldTypes$[ebp+ecx*4]
	jl	SHORT $LN3@IsImprovem

; 2861 : 			{
; 2862 : 				return true;

	mov	al, 1
	jmp	SHORT $LN25@IsImprovem
$LN3@IsImprovem:

; 2863 : 			}
; 2864 : 		}
; 2865 : 		else

	jmp	SHORT $LN5@IsImprovem
$LN4@IsImprovem:

; 2866 : 		{
; 2867 : 			if(aiImprovedYieldTypes[eYield] > aiNaturalYieldTypes[eYield])

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	ecx, DWORD PTR _eYield$[ebp]
	mov	edx, DWORD PTR _aiImprovedYieldTypes$[ebp+eax*4]
	cmp	edx, DWORD PTR _aiNaturalYieldTypes$[ebp+ecx*4]
	jle	SHORT $LN5@IsImprovem

; 2868 : 			{
; 2869 : 				return true;

	mov	al, 1
	jmp	SHORT $LN25@IsImprovem
$LN5@IsImprovem:

; 2870 : 			}
; 2871 : 		}
; 2872 : 	}
; 2873 : 
; 2874 : 	return false;

	xor	al, al
$LN25@IsImprovem:

; 2875 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?IsImprovementBeneficial@CvBuilderTaskingAI@@QAE_NPAVCvPlot@@ABVCvBuildInfo@@W4YieldTypes@@_N@Z ENDP ; CvBuilderTaskingAI::IsImprovementBeneficial
_TEXT	ENDS
EXTRN	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z:PROC ; CvCityCitizens::IsCanWork
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
; Function compile flags: /Odtp
;	COMDAT ?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pLoopCity$218011 = -12					; size = 4
_iLoop$218012 = -8					; size = 4
_pCity$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::GetWorkingCity, COMDAT
; _this$ = ecx

; 2880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2881 : #ifdef AUI_WARNING_FIXES
; 2882 : 	CvCity* pCity = pPlot->getWorkingCity();
; 2883 : 	if (!pCity)
; 2884 : #else
; 2885 : 	CvCity* pCity = NULL;

	mov	DWORD PTR _pCity$[ebp], 0

; 2886 : 	if(pPlot->getWorkingCity())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	test	eax, eax
	je	SHORT $LN6@GetWorking

; 2887 : 	{
; 2888 : 		pCity = pPlot->getWorkingCity();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pCity$[ebp], eax

; 2889 : 	}
; 2890 : 	else

	jmp	SHORT $LN5@GetWorking
$LN6@GetWorking:

; 2891 : #endif
; 2892 : 	{
; 2893 : 		CvCity* pLoopCity;
; 2894 : 		int iLoop;
; 2895 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$218012[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$218011[ebp], eax
	jmp	SHORT $LN4@GetWorking
$LN3@GetWorking:
	push	0
	lea	edx, DWORD PTR _iLoop$218012[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$218011[ebp], eax
$LN4@GetWorking:
	cmp	DWORD PTR _pLoopCity$218011[ebp], 0
	je	SHORT $LN5@GetWorking

; 2896 : 		{
; 2897 : 			if(pLoopCity->GetCityCitizens()->IsCanWork(pPlot))

	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$218011[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetWorking

; 2898 : 			{
; 2899 : #ifdef AUI_WARNING_FIXES
; 2900 : 				return pLoopCity;
; 2901 : #else
; 2902 : 				pCity = pLoopCity;

	mov	eax, DWORD PTR _pLoopCity$218011[ebp]
	mov	DWORD PTR _pCity$[ebp], eax

; 2903 : 				break;

	jmp	SHORT $LN5@GetWorking
$LN1@GetWorking:

; 2904 : #endif
; 2905 : 			}
; 2906 : 		}

	jmp	SHORT $LN3@GetWorking
$LN5@GetWorking:

; 2907 : 	}
; 2908 : 
; 2909 : 	return pCity;

	mov	eax, DWORD PTR _pCity$[ebp]

; 2910 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetWorkingCity@CvBuilderTaskingAI@@QAEPAVCvCity@@PAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::GetWorkingCity
_TEXT	ENDS
EXTRN	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z:PROC ; CvCity::getOrderFromQueue
EXTRN	?getOrderQueueLength@CvCity@@QAEHXZ:PROC	; CvCity::getOrderQueueLength
; Function compile flags: /Odtp
;	COMDAT ?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T223032 = -12						; size = 4
_pCity$ = -8						; size = 4
_iProduction$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_eBuild$ = 16						; size = 4
?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z PROC ; CvBuilderTaskingAI::DoesBuildHelpRush, COMDAT
; _this$ = ecx

; 2914 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2915 : 	CvCity* pCity = NULL;

	mov	DWORD PTR _pCity$[ebp], 0

; 2916 : 	int iProduction = pPlot->getFeatureProduction(eBuild, pUnit->getOwner(), &pCity);

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T223032[ebp], ecx
	lea	edx, DWORD PTR _pCity$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223032[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBuild$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getFeatureProduction@CvPlot@@QBEHW4BuildTypes@@W4PlayerTypes@@PAPAVCvCity@@@Z ; CvPlot::getFeatureProduction
	mov	DWORD PTR _iProduction$[ebp], eax

; 2917 : 	if(iProduction <= 0)

	cmp	DWORD PTR _iProduction$[ebp], 0
	jg	SHORT $LN4@DoesBuildH

; 2918 : 	{
; 2919 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@DoesBuildH
$LN4@DoesBuildH:

; 2920 : 	}
; 2921 : 
; 2922 : 	if(!pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	SHORT $LN3@DoesBuildH

; 2923 : 	{
; 2924 : 		// this chop does not benefit any city
; 2925 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@DoesBuildH
$LN3@DoesBuildH:

; 2926 : 	}
; 2927 : 
; 2928 : 	if(pCity->getOrderQueueLength() <= 0)

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getOrderQueueLength@CvCity@@QAEHXZ	; CvCity::getOrderQueueLength
	test	eax, eax
	jg	SHORT $LN2@DoesBuildH

; 2929 : 	{
; 2930 : 		// nothing in the build queue
; 2931 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@DoesBuildH
$LN2@DoesBuildH:

; 2932 : 	}
; 2933 : 
; 2934 : 	if(!(pCity->getOrderFromQueue(0)->bRush))

	push	0
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z ; CvCity::getOrderFromQueue
	movzx	edx, BYTE PTR [eax+13]
	test	edx, edx
	jne	SHORT $LN1@DoesBuildH

; 2935 : 	{
; 2936 : 		// this order should not be rushed
; 2937 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@DoesBuildH
$LN1@DoesBuildH:

; 2938 : 	}
; 2939 : 
; 2940 : 	return true;

	mov	al, 1
$LN5@DoesBuildH:

; 2941 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DoesBuildHelpRush@CvBuilderTaskingAI@@QAE_NPAVCvUnit@@PAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvBuilderTaskingAI::DoesBuildHelpRush
_TEXT	ENDS
EXTRN	?IsOriginalCapital@CvCity@@QBE_NXZ:PROC		; CvCity::IsOriginalCapital
; Function compile flags: /Odtp
;	COMDAT ?ScorePlot@CvBuilderTaskingAI@@QAEHXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
_iYieldDelta$218057 = -40				; size = 4
_iAbsMultiplier$218046 = -36				; size = 4
_iYieldDelta$218047 = -32				; size = 4
_iMultiplier$218044 = -28				; size = 4
_ui$218040 = -24					; size = 4
_bAnyNegativeMultiplier$ = -17				; size = 1
_pCity$ = -16						; size = 4
_eFocusYield$ = -12					; size = 4
_pCityStrategy$ = -8					; size = 4
_iScore$ = -4						; size = 4
?ScorePlot@CvBuilderTaskingAI@@QAEHXZ PROC		; CvBuilderTaskingAI::ScorePlot, COMDAT
; _this$ = ecx

; 2950 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2951 : 	if(!m_pTargetPlot)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+58400], 0
	jne	SHORT $LN19@ScorePlot

; 2952 : 	{
; 2953 : 		return -1;

	or	eax, -1
	jmp	$LN20@ScorePlot
$LN19@ScorePlot:

; 2954 : 	}
; 2955 : 
; 2956 : 	CvCity* pCity = m_pTargetPlot->getWorkingCity();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+58400]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	mov	DWORD PTR _pCity$[ebp], eax

; 2957 : #ifdef AUI_WORKER_SCORE_PLOT_NO_SCORE_FROM_RAZE
; 2958 : 	if (!pCity || pCity->IsRazing())
; 2959 : #else
; 2960 : 	if(!pCity)

	cmp	DWORD PTR _pCity$[ebp], 0
	jne	SHORT $LN18@ScorePlot

; 2961 : #endif
; 2962 : 	{
; 2963 : 		return -1;

	or	eax, -1
	jmp	$LN20@ScorePlot
$LN18@ScorePlot:

; 2964 : 	}
; 2965 : 
; 2966 : 	CvCityStrategyAI* pCityStrategy = pCity->GetCityStrategyAI();

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	DWORD PTR _pCityStrategy$[ebp], eax

; 2967 : 	if(!pCityStrategy)

	cmp	DWORD PTR _pCityStrategy$[ebp], 0
	jne	SHORT $LN17@ScorePlot

; 2968 : 	{
; 2969 : 		return -1;

	or	eax, -1
	jmp	$LN20@ScorePlot
$LN17@ScorePlot:

; 2970 : 	}
; 2971 : 
; 2972 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 2973 : 	CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);
; 2974 : 	if (!pkBuild)
; 2975 : 	{
; 2976 : 		return -1;
; 2977 : 	}
; 2978 : 	FeatureTypes ePlotFeature = m_pTargetPlot->getFeatureType();
; 2979 : #endif
; 2980 : 
; 2981 : #ifdef AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK
; 2982 : 	bool bWouldBeWorked = m_pTargetPlot->isBeingWorked();
; 2983 : #endif
; 2984 : 	int iScore = 0;

	mov	DWORD PTR _iScore$[ebp], 0

; 2985 : 	bool bAnyNegativeMultiplier = false;

	mov	BYTE PTR _bAnyNegativeMultiplier$[ebp], 0

; 2986 : 	YieldTypes eFocusYield = pCityStrategy->GetFocusYield();

	mov	ecx, DWORD PTR _pCityStrategy$[ebp]
	call	?GetFocusYield@CvCityStrategyAI@@QAE?AW4YieldTypes@@XZ ; CvCityStrategyAI::GetFocusYield
	mov	DWORD PTR _eFocusYield$[ebp], eax

; 2987 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$218040[ebp], 0
	jmp	SHORT $LN16@ScorePlot
$LN15@ScorePlot:
	mov	edx, DWORD PTR _ui$218040[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$218040[ebp], edx
$LN16@ScorePlot:
	cmp	DWORD PTR _ui$218040[ebp], 6
	jae	$LN14@ScorePlot

; 2988 : 	{
; 2989 : 		int iMultiplier = pCityStrategy->GetYieldDeltaTimes100((YieldTypes)ui);

	mov	eax, DWORD PTR _ui$218040[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCityStrategy$[ebp]
	call	?GetYieldDeltaTimes100@CvCityStrategyAI@@QAEFW4YieldTypes@@@Z ; CvCityStrategyAI::GetYieldDeltaTimes100
	movsx	ecx, ax
	mov	DWORD PTR _iMultiplier$218044[ebp], ecx

; 2990 : 		int iAbsMultiplier = abs(iMultiplier);

	mov	eax, DWORD PTR _iMultiplier$218044[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iAbsMultiplier$218046[ebp], eax

; 2991 : 		int iYieldDelta = m_aiProjectedPlotYields[ui] - m_aiCurrentPlotYields[ui];

	mov	edx, DWORD PTR _ui$218040[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ui$218040[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+58428]
	sub	edx, DWORD PTR [esi+ecx*4+58404]
	mov	DWORD PTR _iYieldDelta$218047[ebp], edx

; 2992 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 2993 : 		double dFlatBonus = 0;
; 2994 : 		if (ePlotFeature != NO_FEATURE && pkBuild->isFeatureRemove(ePlotFeature) && ui == YIELD_PRODUCTION && iYieldDelta >= 0)
; 2995 : 		{
; 2996 : 			dFlatBonus = AUI_WORKER_SCORE_PLOT_CHOP;
; 2997 : 		}
; 2998 : #endif
; 2999 : 
; 3000 : 		// the multiplier being lower than zero means that we need more of this resource
; 3001 : 		if(iMultiplier < 0)

	cmp	DWORD PTR _iMultiplier$218044[ebp], 0
	jge	SHORT $LN13@ScorePlot

; 3002 : 		{
; 3003 : 			bAnyNegativeMultiplier = true;

	mov	BYTE PTR _bAnyNegativeMultiplier$[ebp], 1

; 3004 : 			if(iYieldDelta > 0)  // this would be an improvement to the yield

	cmp	DWORD PTR _iYieldDelta$218047[ebp], 0
	jle	SHORT $LN12@ScorePlot

; 3005 : 			{
; 3006 : #ifdef AUI_WORKER_SCORE_PLOT_CHOP
; 3007 : 				iScore += int((m_aiProjectedPlotYields[ui] + dFlatBonus) * iAbsMultiplier + 0.5);
; 3008 : 			}
; 3009 : 			else if (iYieldDelta < 0)  // the yield would go down
; 3010 : 			{
; 3011 : 				iScore += int((iYieldDelta + dFlatBonus) * iAbsMultiplier - 0.5);
; 3012 : 			}
; 3013 : 		}
; 3014 : 		else
; 3015 : 		{
; 3016 : 			if (iYieldDelta >= 0)
; 3017 : 			{
; 3018 : 				iScore += int(m_aiProjectedPlotYields[ui] + dFlatBonus + 0.5); // provide a nominal score to plots that improve anything
; 3019 : 			}
; 3020 : 			else if (iYieldDelta < 0)
; 3021 : 			{
; 3022 : 				iScore += int((iYieldDelta + dFlatBonus) * iAbsMultiplier - 0.5);
; 3023 : #else
; 3024 : 				iScore += m_aiProjectedPlotYields[ui] * iAbsMultiplier;

	mov	eax, DWORD PTR _ui$218040[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+58428]
	imul	edx, DWORD PTR _iAbsMultiplier$218046[ebp]
	add	edx, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iScore$[ebp], edx
	jmp	SHORT $LN11@ScorePlot
$LN12@ScorePlot:

; 3025 : 			}
; 3026 : 			else if(iYieldDelta < 0)  // the yield would go down

	cmp	DWORD PTR _iYieldDelta$218047[ebp], 0
	jge	SHORT $LN11@ScorePlot

; 3027 : 			{
; 3028 : 				iScore += iYieldDelta * iAbsMultiplier;

	mov	eax, DWORD PTR _iYieldDelta$218047[ebp]
	imul	eax, DWORD PTR _iAbsMultiplier$218046[ebp]
	add	eax, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iScore$[ebp], eax
$LN11@ScorePlot:

; 3029 : 			}
; 3030 : 		}
; 3031 : 		else

	jmp	SHORT $LN9@ScorePlot
$LN13@ScorePlot:

; 3032 : 		{
; 3033 : 			if(iYieldDelta >= 0)

	cmp	DWORD PTR _iYieldDelta$218047[ebp], 0
	jl	SHORT $LN8@ScorePlot

; 3034 : 			{
; 3035 : 				iScore += m_aiProjectedPlotYields[ui]; // provide a nominal score to plots that improve anything

	mov	ecx, DWORD PTR _ui$218040[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iScore$[ebp]
	add	eax, DWORD PTR [edx+ecx*4+58428]
	mov	DWORD PTR _iScore$[ebp], eax
	jmp	SHORT $LN9@ScorePlot
$LN8@ScorePlot:

; 3036 : 			}
; 3037 : 			else if(iYieldDelta < 0)

	cmp	DWORD PTR _iYieldDelta$218047[ebp], 0
	jge	SHORT $LN9@ScorePlot

; 3038 : 			{
; 3039 : 				iScore += iYieldDelta * iAbsMultiplier;

	mov	ecx, DWORD PTR _iYieldDelta$218047[ebp]
	imul	ecx, DWORD PTR _iAbsMultiplier$218046[ebp]
	add	ecx, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iScore$[ebp], ecx
$LN9@ScorePlot:

; 3040 : #endif
; 3041 : 			}
; 3042 : 		}
; 3043 : 	}

	jmp	$LN15@ScorePlot
$LN14@ScorePlot:

; 3044 : 
; 3045 : 	if(!bAnyNegativeMultiplier && eFocusYield != NO_YIELD)

	movzx	edx, BYTE PTR _bAnyNegativeMultiplier$[ebp]
	test	edx, edx
	jne	SHORT $LN5@ScorePlot
	cmp	DWORD PTR _eFocusYield$[ebp], -1
	je	SHORT $LN5@ScorePlot

; 3046 : 	{
; 3047 : 		int iYieldDelta = m_aiProjectedPlotYields[eFocusYield] - m_aiCurrentPlotYields[eFocusYield];

	mov	eax, DWORD PTR _eFocusYield$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _eFocusYield$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+58428]
	sub	eax, DWORD PTR [esi+edx*4+58404]
	mov	DWORD PTR _iYieldDelta$218057[ebp], eax

; 3048 : 		if(iYieldDelta > 0)

	cmp	DWORD PTR _iYieldDelta$218057[ebp], 0
	jle	SHORT $LN5@ScorePlot

; 3049 : 		{
; 3050 : #ifdef AUI_WORKER_SCORE_PLOT_EFFECT_FROM_CITY_FOCUS
; 3051 : 			iScore += m_aiProjectedPlotYields[eFocusYield] * AUI_WORKER_SCORE_PLOT_EFFECT_FROM_CITY_FOCUS;
; 3052 : #else
; 3053 : 			iScore += m_aiProjectedPlotYields[eFocusYield] * 100;

	mov	ecx, DWORD PTR _eFocusYield$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+58428]
	imul	eax, 100				; 00000064H
	add	eax, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iScore$[ebp], eax
$LN5@ScorePlot:

; 3054 : #endif
; 3055 : 		}
; 3056 : 	}
; 3057 : 
; 3058 : #ifndef AUI_WORKER_SCORE_PLOT_NO_CAPITOL_FAVORING
; 3059 : 	if (pCity->isCapital()) // this is our capital and needs emphasis

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ScorePlot

; 3060 : 	{
; 3061 : 		iScore *= 8;

	mov	edx, DWORD PTR _iScore$[ebp]
	shl	edx, 3
	mov	DWORD PTR _iScore$[ebp], edx
	jmp	SHORT $LN2@ScorePlot
$LN3@ScorePlot:

; 3062 : 	}
; 3063 : 	else if (pCity->IsOriginalCapital()) // this was a particularly good city and needs a little emphasis

	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsOriginalCapital@CvCity@@QBE_NXZ	; CvCity::IsOriginalCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@ScorePlot

; 3064 : 	{
; 3065 : 		iScore *= 2;

	mov	ecx, DWORD PTR _iScore$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _iScore$[ebp], ecx
$LN2@ScorePlot:

; 3066 : 	}
; 3067 : #endif
; 3068 : #ifdef AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK
; 3069 : 	if (bWouldBeWorked)
; 3070 : 	{
; 3071 : 		iScore *= AUI_WORKER_SCORE_PLOT_MULTIPLY_SCORE_IF_WOULD_WORK;
; 3072 : 	}
; 3073 : #endif
; 3074 : #ifdef AUI_WORKER_SCORE_PLOT_REDUCED_PUPPET_SCORE
; 3075 : 	if (pCity->IsPuppet())
; 3076 : 	{
; 3077 : 		iScore /= AUI_WORKER_SCORE_PLOT_REDUCED_PUPPET_SCORE;
; 3078 : 	}
; 3079 : #endif
; 3080 : 
; 3081 : 	return iScore;

	mov	eax, DWORD PTR _iScore$[ebp]
$LN20@ScorePlot:

; 3082 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?ScorePlot@CvBuilderTaskingAI@@QAEHXZ ENDP		; CvBuilderTaskingAI::ScorePlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pkBuild$218072 = -12					; size = 4
_eBuild$218070 = -8					; size = 4
_iBuildIndex$218066 = -4				; size = 4
_eImprovement$ = 8					; size = 4
?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z PROC ; CvBuilderTaskingAI::GetBuildTypeFromImprovement, COMDAT
; _this$ = ecx

; 3089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3090 : #ifdef AUI_WARNING_FIXES
; 3091 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 3092 : #else
; 3093 : 	for(int iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$218066[ebp], 0
	jmp	SHORT $LN4@GetBuildTy
$LN3@GetBuildTy:
	mov	eax, DWORD PTR _iBuildIndex$218066[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildIndex$218066[ebp], eax
$LN4@GetBuildTy:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$218066[ebp], eax
	jge	SHORT $LN2@GetBuildTy

; 3094 : #endif
; 3095 : 	{
; 3096 : 		BuildTypes eBuild = (BuildTypes)iBuildIndex;

	mov	ecx, DWORD PTR _iBuildIndex$218066[ebp]
	mov	DWORD PTR _eBuild$218070[ebp], ecx

; 3097 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$218070[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$218072[ebp], eax

; 3098 : 
; 3099 : 		if(NULL != pkBuild && eImprovement == (ImprovementTypes)pkBuild->getImprovement())

	cmp	DWORD PTR _pkBuild$218072[ebp], 0
	je	SHORT $LN1@GetBuildTy
	mov	ecx, DWORD PTR _pkBuild$218072[ebp]
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	DWORD PTR _eImprovement$[ebp], eax
	jne	SHORT $LN1@GetBuildTy

; 3100 : 		{
; 3101 : 			return eBuild;

	mov	eax, DWORD PTR _eBuild$218070[ebp]
	jmp	SHORT $LN5@GetBuildTy
$LN1@GetBuildTy:

; 3102 : 		}
; 3103 : 	}

	jmp	SHORT $LN3@GetBuildTy
$LN2@GetBuildTy:

; 3104 : 
; 3105 : 	return NO_BUILD;

	or	eax, -1
$LN5@GetBuildTy:

; 3106 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildTypeFromImprovement@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@W4ImprovementTypes@@@Z ENDP ; CvBuilderTaskingAI::GetBuildTypeFromImprovement
_TEXT	ENDS
EXTRN	?isRepair@CvBuildInfo@@QBE_NXZ:PROC		; CvBuildInfo::isRepair
; Function compile flags: /Odtp
;	COMDAT ?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pkBuild$218085 = -12					; size = 4
_eBuild$218083 = -8					; size = 4
_i$218079 = -4						; size = 4
?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ PROC ; CvBuilderTaskingAI::GetRepairBuild, COMDAT
; _this$ = ecx

; 3113 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3114 : #ifdef AUI_WARNING_FIXES
; 3115 : 	for (uint i = 0; i < GC.getNumBuildInfos(); i++)
; 3116 : #else
; 3117 : 	for(int i = 0; i < GC.getNumBuildInfos(); i++)

	mov	DWORD PTR _i$218079[ebp], 0
	jmp	SHORT $LN4@GetRepairB
$LN3@GetRepairB:
	mov	eax, DWORD PTR _i$218079[ebp]
	add	eax, 1
	mov	DWORD PTR _i$218079[ebp], eax
$LN4@GetRepairB:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _i$218079[ebp], eax
	jge	SHORT $LN2@GetRepairB

; 3118 : #endif
; 3119 : 	{
; 3120 : 		BuildTypes eBuild = (BuildTypes)i;

	mov	ecx, DWORD PTR _i$218079[ebp]
	mov	DWORD PTR _eBuild$218083[ebp], ecx

; 3121 : 		CvBuildInfo* pkBuild = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$218083[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuild$218085[ebp], eax

; 3122 : 
; 3123 : 		if(NULL != pkBuild && pkBuild->isRepair())

	cmp	DWORD PTR _pkBuild$218085[ebp], 0
	je	SHORT $LN1@GetRepairB
	mov	ecx, DWORD PTR _pkBuild$218085[ebp]
	call	?isRepair@CvBuildInfo@@QBE_NXZ		; CvBuildInfo::isRepair
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetRepairB

; 3124 : 		{
; 3125 : 			return eBuild;

	mov	eax, DWORD PTR _eBuild$218083[ebp]
	jmp	SHORT $LN5@GetRepairB
$LN1@GetRepairB:

; 3126 : 		}
; 3127 : 	}

	jmp	SHORT $LN3@GetRepairB
$LN2@GetRepairB:

; 3128 : 
; 3129 : 	return NO_BUILD;

	or	eax, -1
$LN5@GetRepairB:

; 3130 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRepairBuild@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ENDP ; CvBuilderTaskingAI::GetRepairBuild
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T223044 = -4						; size = 4
?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ PROC ; CvBuilderTaskingAI::GetFalloutFeature, COMDAT
; _this$ = ecx

; 3137 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 3138 : 	return static_cast<FeatureTypes>(GC.getNUKE_FEATURE());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8404
	mov	DWORD PTR $T223044[ebp], eax
	mov	eax, DWORD PTR $T223044[ebp]

; 3139 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ ENDP ; CvBuilderTaskingAI::GetFalloutFeature
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_eBuild$218103 = -16					; size = 4
_pBuildInfo$218105 = -12				; size = 4
_iBuild$218099 = -8					; size = 4
_eFalloutFeature$ = -4					; size = 4
?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ PROC ; CvBuilderTaskingAI::GetFalloutRemove, COMDAT
; _this$ = ecx

; 3146 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3147 : 	FeatureTypes eFalloutFeature = m_eFalloutFeature;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+58452]
	mov	DWORD PTR _eFalloutFeature$[ebp], ecx

; 3148 : 	if(eFalloutFeature == NO_FEATURE)

	cmp	DWORD PTR _eFalloutFeature$[ebp], -1
	jne	SHORT $LN6@GetFallout

; 3149 : 	{
; 3150 : 		eFalloutFeature = GetFalloutFeature();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetFalloutFeature@CvBuilderTaskingAI@@QAE?AW4FeatureTypes@@XZ ; CvBuilderTaskingAI::GetFalloutFeature
	mov	DWORD PTR _eFalloutFeature$[ebp], eax
$LN6@GetFallout:

; 3151 : 	}
; 3152 : 
; 3153 : 	if(eFalloutFeature == NO_FEATURE)

	cmp	DWORD PTR _eFalloutFeature$[ebp], -1
	jne	SHORT $LN5@GetFallout

; 3154 : 	{
; 3155 : 		return NO_BUILD;

	or	eax, -1
	jmp	SHORT $LN7@GetFallout
$LN5@GetFallout:

; 3156 : 	}
; 3157 : 
; 3158 : #ifdef AUI_WARNING_FIXES
; 3159 : 	for (uint iBuild = 0; iBuild < GC.getNumBuildInfos(); iBuild++)
; 3160 : #else
; 3161 : 	for(int iBuild = 0; iBuild < GC.getNumBuildInfos(); iBuild++)

	mov	DWORD PTR _iBuild$218099[ebp], 0
	jmp	SHORT $LN4@GetFallout
$LN3@GetFallout:
	mov	edx, DWORD PTR _iBuild$218099[ebp]
	add	edx, 1
	mov	DWORD PTR _iBuild$218099[ebp], edx
$LN4@GetFallout:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuild$218099[ebp], eax
	jge	SHORT $LN2@GetFallout

; 3162 : #endif
; 3163 : 	{
; 3164 : 		BuildTypes eBuild = (BuildTypes)iBuild;

	mov	eax, DWORD PTR _iBuild$218099[ebp]
	mov	DWORD PTR _eBuild$218103[ebp], eax

; 3165 : 		CvBuildInfo* pBuildInfo = GC.getBuildInfo(eBuild);

	mov	ecx, DWORD PTR _eBuild$218103[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pBuildInfo$218105[ebp], eax

; 3166 : 		if(NULL != pBuildInfo && pBuildInfo->isFeatureRemove(eFalloutFeature))

	cmp	DWORD PTR _pBuildInfo$218105[ebp], 0
	je	SHORT $LN1@GetFallout
	mov	edx, DWORD PTR _eFalloutFeature$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pBuildInfo$218105[ebp]
	call	?isFeatureRemove@CvBuildInfo@@QBE_NH@Z	; CvBuildInfo::isFeatureRemove
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetFallout

; 3167 : 		{
; 3168 : 			return eBuild;

	mov	eax, DWORD PTR _eBuild$218103[ebp]
	jmp	SHORT $LN7@GetFallout
$LN1@GetFallout:

; 3169 : 		}
; 3170 : 	}

	jmp	SHORT $LN3@GetFallout
$LN2@GetFallout:

; 3171 : 
; 3172 : 	return NO_BUILD;

	or	eax, -1
$LN7@GetFallout:

; 3173 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFalloutRemove@CvBuilderTaskingAI@@QAE?AW4BuildTypes@@XZ ENDP ; CvBuilderTaskingAI::GetFalloutRemove
_TEXT	ENDS
PUBLIC	??_C@_03DPLIHHLN@?$CFd?0?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
;	COMDAT ??_C@_03DPLIHHLN@?$CFd?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_03DPLIHHLN@?$CFd?0?$AA@ DB '%d,', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
CONST	SEGMENT
??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@ DB 'BuilderTaskingLog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
tv83 = -156						; size = 4
tv205 = -152						; size = 4
$T223096 = -148						; size = 4
$T223092 = -144						; size = 4
$T223088 = -140						; size = 4
$T223070 = -136						; size = 4
_strFileName$ = -132					; size = 28
_strLog$ = -104						; size = 28
_strPlayerName$ = -76					; size = 28
_pLog$ = -48						; size = 4
_strTemp$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strNewLogStr$ = 8					; size = 28
_pPlayer$ = 36						; size = 4
___formal$ = 40						; size = 1
?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z PROC ; CvBuilderTaskingAI::LogInfo, COMDAT

; 3181 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3182 : 	if(!(GC.getLogging() && GC.getAILogging() && GC.GetBuilderAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@LogInfo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@LogInfo
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@LogInfo
$LN1@LogInfo:

; 3183 : 	{
; 3184 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strNewLogStr$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN3@LogInfo
$LN2@LogInfo:

; 3185 : 	}
; 3186 : 
; 3187 : 	// Open the log file
; 3188 : 	CvString strFileName = "BuilderTaskingLog.csv";

	mov	eax, OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	test	eax, eax
	je	SHORT $LN15@LogInfo
	mov	DWORD PTR tv205[ebp], OFFSET ??_C@_0BG@IAMEKOEI@BuilderTaskingLog?4csv?$AA@
	jmp	SHORT $LN16@LogInfo
$LN15@LogInfo:
	mov	DWORD PTR tv205[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN16@LogInfo:
	mov	ecx, DWORD PTR tv205[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3189 : 	FILogFile* pLog;
; 3190 : 	pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv83[ebp], eax
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T223070[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T223070[ebp]
	push	edx
	mov	eax, DWORD PTR tv83[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv83[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$[ebp], eax

; 3191 : 
; 3192 : 	CvString strLog, strTemp;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3193 : 
; 3194 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3195 : 	strPlayerName = pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T223088[ebp], eax
	cmp	DWORD PTR $T223088[ebp], 0
	je	SHORT $LN30@LogInfo
	mov	ecx, DWORD PTR $T223088[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN31@LogInfo
$LN30@LogInfo:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN31@LogInfo:

; 3196 : 	strLog += strPlayerName;

	lea	edx, DWORD PTR _strPlayerName$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3197 : 	strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3198 : 
; 3199 : 	strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223092[ebp], eax
	mov	ecx, DWORD PTR $T223092[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3200 : 	strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3201 : 	strLog += strNewLogStr;

	lea	eax, DWORD PTR _strNewLogStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3202 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T223096[ebp], eax
	mov	ecx, DWORD PTR $T223096[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 3203 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strNewLogStr$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@LogInfo:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$0:
	lea	ecx, DWORD PTR _strNewLogStr$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$1:
	lea	ecx, DWORD PTR _strFileName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$2:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$3:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z$4:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ENDP ; CvBuilderTaskingAI::LogInfo
PUBLIC	??_C@_0BL@ELKPAOAK@BuilderTaskingYieldLog?4csv?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ; CvBuilderTaskingAI::LogYieldInfo
;	COMDAT ??_C@_0BL@ELKPAOAK@BuilderTaskingYieldLog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BL@ELKPAOAK@BuilderTaskingYieldLog?4csv?$AA@ DB 'BuilderTaskingYie'
	DB	'ldLog.csv', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$4
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
tv83 = -156						; size = 4
tv205 = -152						; size = 4
$T223172 = -148						; size = 4
$T223168 = -144						; size = 4
$T223164 = -140						; size = 4
$T223146 = -136						; size = 4
_strFileName$ = -132					; size = 28
_strLog$ = -104						; size = 28
_strPlayerName$ = -76					; size = 28
_pLog$ = -48						; size = 4
_strTemp$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strNewLogStr$ = 8					; size = 28
_pPlayer$ = 36						; size = 4
?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z PROC ; CvBuilderTaskingAI::LogYieldInfo, COMDAT

; 3210 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3211 : 	if(!(GC.getLogging() && GC.getAILogging() && GC.GetBuilderAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@LogYieldIn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@LogYieldIn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuilderAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::GetBuilderAILogging
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@LogYieldIn
$LN1@LogYieldIn:

; 3212 : 	{
; 3213 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strNewLogStr$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN3@LogYieldIn
$LN2@LogYieldIn:

; 3214 : 	}
; 3215 : 
; 3216 : 	// Open the log file
; 3217 : 	CvString strFileName = "BuilderTaskingYieldLog.csv";

	mov	eax, OFFSET ??_C@_0BL@ELKPAOAK@BuilderTaskingYieldLog?4csv?$AA@
	test	eax, eax
	je	SHORT $LN15@LogYieldIn
	mov	DWORD PTR tv205[ebp], OFFSET ??_C@_0BL@ELKPAOAK@BuilderTaskingYieldLog?4csv?$AA@
	jmp	SHORT $LN16@LogYieldIn
$LN15@LogYieldIn:
	mov	DWORD PTR tv205[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN16@LogYieldIn:
	mov	ecx, DWORD PTR tv205[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3218 : 	FILogFile* pLog;
; 3219 : 	pLog = LOGFILEMGR.GetLog(strFileName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv83[ebp], eax
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T223146[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T223146[ebp]
	push	edx
	mov	eax, DWORD PTR tv83[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv83[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$[ebp], eax

; 3220 : 
; 3221 : 	CvString strLog, strTemp;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3222 : 
; 3223 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3224 : 	strPlayerName = pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T223164[ebp], eax
	cmp	DWORD PTR $T223164[ebp], 0
	je	SHORT $LN30@LogYieldIn
	mov	ecx, DWORD PTR $T223164[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN31@LogYieldIn
$LN30@LogYieldIn:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN31@LogYieldIn:

; 3225 : 	strLog += strPlayerName;

	lea	edx, DWORD PTR _strPlayerName$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3226 : 	strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3227 : 
; 3228 : 	strTemp.Format("%d,", GC.getGame().getGameTurn()); // turn

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223168[ebp], eax
	mov	ecx, DWORD PTR $T223168[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3229 : 	strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3230 : 	strLog += strNewLogStr;

	lea	eax, DWORD PTR _strNewLogStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3231 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T223172[ebp], eax
	mov	ecx, DWORD PTR $T223172[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 3232 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strFileName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strNewLogStr$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN3@LogYieldIn:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR _strNewLogStr$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$1:
	lea	ecx, DWORD PTR _strFileName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$2:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$3:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z$4:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-148]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ENDP ; CvBuilderTaskingAI::LogYieldInfo
PUBLIC	??_C@_0BA@HFABGIJA@Flavor?0?5?$CFs?0?5?$CFd?0?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z ; CvBuilderTaskingAI::LogFlavors
;	COMDAT ??_C@_0BA@HFABGIJA@Flavor?0?5?$CFs?0?5?$CFd?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BA@HFABGIJA@Flavor?0?5?$CFs?0?5?$CFd?0?$AA@ DB 'Flavor, %s, %d,', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$1
__ehfuncinfo$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
tv209 = -124						; size = 4
tv205 = -120						; size = 4
_this$ = -116						; size = 4
$T223245 = -112						; size = 4
$T223240 = -108						; size = 4
$T223236 = -104						; size = 4
$T223232 = -100						; size = 4
$T223227 = -96						; size = 4
$T223223 = -92						; size = 4
$T223219 = -88						; size = 4
$T223203 = -84						; size = 4
$T223202 = -80						; size = 4
_iI$218141 = -76					; size = 4
_strLog$ = -72						; size = 28
_strTemp$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eFlavor$ = 8						; size = 4
?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z PROC ; CvBuilderTaskingAI::LogFlavors, COMDAT
; _this$ = ecx

; 3236 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3237 : 	if(!m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	jne	SHORT $LN6@LogFlavors

; 3238 : 	{
; 3239 : 		return;

	jmp	$LN7@LogFlavors
$LN6@LogFlavors:

; 3240 : 	}
; 3241 : 
; 3242 : 	// Open the log file
; 3243 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3244 : 	CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3245 : 
; 3246 : 	// Dump out the setting for each flavor
; 3247 : 	if(eFlavor == NO_FLAVOR)

	cmp	DWORD PTR _eFlavor$[ebp], -1
	jne	$LN5@LogFlavors

; 3248 : 	{
; 3249 : 		for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	mov	DWORD PTR _iI$218141[ebp], 0
	jmp	SHORT $LN4@LogFlavors
$LN3@LogFlavors:
	mov	edx, DWORD PTR _iI$218141[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$218141[ebp], edx
$LN4@LogFlavors:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T223219[ebp], eax
	mov	ecx, DWORD PTR _iI$218141[ebp]
	cmp	ecx, DWORD PTR $T223219[ebp]
	jge	$LN2@LogFlavors

; 3250 : 		{
; 3251 : 			strLog.clear();

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 3252 : 			strTemp.Format("Flavor, %s, %d,", GC.getFlavorTypes((FlavorTypes)iI).GetCString(), m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor((FlavorTypes)iI));

	mov	edx, DWORD PTR _iI$218141[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T223223[ebp], edx
	mov	ecx, DWORD PTR $T223223[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T223227[ebp], eax
	mov	eax, DWORD PTR _iI$218141[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	push	eax
	mov	edx, DWORD PTR $T223227[ebp]
	push	edx
	push	OFFSET ??_C@_0BA@HFABGIJA@Flavor?0?5?$CFs?0?5?$CFd?0?$AA@
	lea	eax, DWORD PTR _strTemp$[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3253 : 			strLog += strTemp;

	lea	ecx, DWORD PTR _strTemp$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3254 : 			LogInfo(strLog, m_pPlayer);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T223202[ebp], esp
	mov	DWORD PTR $T223232[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T223232[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T223232[ebp]
	mov	DWORD PTR tv205[ebp], eax
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 3255 : 		}

	jmp	$LN3@LogFlavors
$LN2@LogFlavors:

; 3256 : 	}
; 3257 : 	else

	jmp	$LN1@LogFlavors
$LN5@LogFlavors:

; 3258 : 	{
; 3259 : 		strLog.clear();

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 3260 : 		strTemp.Format("Flavor, %s, %d,", GC.getFlavorTypes(eFlavor).GetCString(), m_pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor));

	mov	ecx, DWORD PTR _eFlavor$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T223236[ebp], ecx
	mov	ecx, DWORD PTR $T223236[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T223240[ebp], eax
	mov	edx, DWORD PTR _eFlavor$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	push	eax
	mov	ecx, DWORD PTR $T223240[ebp]
	push	ecx
	push	OFFSET ??_C@_0BA@HFABGIJA@Flavor?0?5?$CFs?0?5?$CFd?0?$AA@
	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3261 : 		strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3262 : 		LogInfo(strLog, m_pPlayer);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T223203[ebp], esp
	mov	DWORD PTR $T223245[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T223245[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T223245[ebp]
	mov	DWORD PTR tv209[ebp], edx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H
$LN1@LogFlavors:

; 3263 : 	}
; 3264 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogFlavors:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$0:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogFlavors@CvBuilderTaskingAI@@IAEXW4FlavorTypes@@@Z ENDP ; CvBuilderTaskingAI::LogFlavors
PUBLIC	??_C@_0P@ELOMFNPI@No?5directives?$CB?$AA@	; `string'
PUBLIC	??0BuilderDirective@@QAE@XZ			; BuilderDirective::BuilderDirective
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0P@ELOMFNPI@No?5directives?$CB?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0P@ELOMFNPI@No?5directives?$CB?$AA@ DB 'No directives!', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$1
__ehfuncinfo$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
tv165 = -132						; size = 4
_this$ = -128						; size = 4
$T223329 = -124						; size = 4
$T223324 = -120						; size = 4
$T223299 = -116						; size = 4
_elem$223298 = -112					; size = 24
$T223280 = -88						; size = 4
$T223271 = -84						; size = 4
$T223263 = -80						; size = 4
_strLog$218162 = -76					; size = 28
_strTemp$218163 = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_i$218157 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 4
?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z PROC ; CvBuilderTaskingAI::LogDirectives, COMDAT
; _this$ = ecx

; 3268 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3269 : 	if(!m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	jne	SHORT $LN6@LogDirecti

; 3270 : 	{
; 3271 : 		return;

	jmp	$LN7@LogDirecti
$LN6@LogDirecti:

; 3272 : 	}
; 3273 : 
; 3274 : 	if(m_aDirectives.size() > 0)

	mov	edx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	mov	DWORD PTR $T223271[ebp], edx
	cmp	DWORD PTR $T223271[ebp], 0
	jle	$LN5@LogDirecti

; 3275 : 	{
; 3276 : 		for(int i = 0; i < m_aDirectives.size(); i++)

	mov	DWORD PTR _i$218157[ebp], 0
	jmp	SHORT $LN4@LogDirecti
$LN3@LogDirecti:
	mov	eax, DWORD PTR _i$218157[ebp]
	add	eax, 1
	mov	DWORD PTR _i$218157[ebp], eax
$LN4@LogDirecti:
	mov	ecx, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A+4
	mov	DWORD PTR $T223280[ebp], ecx
	mov	edx, DWORD PTR _i$218157[ebp]
	cmp	edx, DWORD PTR $T223280[ebp]
	jge	$LN2@LogDirecti

; 3277 : 		{
; 3278 : 			LogDirective(m_aDirectives.GetElement(i), pUnit, m_aDirectives.GetWeight(i));

	lea	ecx, DWORD PTR _elem$223298[ebp]
	call	??0BuilderDirective@@QAE@XZ		; BuilderDirective::BuilderDirective
	mov	DWORD PTR _elem$223298[ebp+20], 0
	mov	eax, DWORD PTR _i$218157[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$223298[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _elem$223298[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _elem$223298[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _elem$223298[ebp+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _elem$223298[ebp+16], ecx
	mov	edx, DWORD PTR [eax+20]
	mov	DWORD PTR _elem$223298[ebp+20], edx
	mov	eax, DWORD PTR _elem$223298[ebp+20]
	mov	DWORD PTR $T223299[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T223299[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$218157[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ; CvBuilderTaskingAI::LogDirective

; 3279 : 		}

	jmp	$LN3@LogDirecti
$LN2@LogDirecti:

; 3280 : 	}
; 3281 : 	else

	jmp	$LN7@LogDirecti
$LN5@LogDirecti:

; 3282 : 	{
; 3283 : 		CvString strLog;

	lea	ecx, DWORD PTR _strLog$218162[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3284 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218163[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3285 : 
; 3286 : 		strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR $T223324[ebp], edx
	mov	eax, DWORD PTR $T223324[ebp]
	push	eax
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	ecx, DWORD PTR _strTemp$218163[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3287 : 		strLog += strTemp;

	lea	edx, DWORD PTR _strTemp$218163[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLog$218162[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3288 : 
; 3289 : 		strLog += "No directives!";

	push	OFFSET ??_C@_0P@ELOMFNPI@No?5directives?$CB?$AA@
	lea	ecx, DWORD PTR _strLog$218162[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3290 : 		LogInfo(strLog, m_pPlayer);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T223263[ebp], esp
	mov	DWORD PTR $T223329[ebp], edx
	lea	eax, DWORD PTR _strLog$218162[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223329[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T223329[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 3291 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$218163[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$218162[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogDirecti:

; 3292 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$0:
	lea	ecx, DWORD PTR _strLog$218162[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z$1:
	lea	ecx, DWORD PTR _strTemp$218163[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDirectives@CvBuilderTaskingAI@@IAEXPAVCvUnit@@@Z ENDP ; CvBuilderTaskingAI::LogDirectives
PUBLIC	??_C@_09FBFAOCJA@?0?5Chosen?$CB?$AA@		; `string'
PUBLIC	??_C@_06IJEBOOKN@?$CFd?0?$CFd?0?$AA@		; `string'
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	??_C@_04LJFDMNAA@CHOP?$AA@			; `string'
PUBLIC	??_C@_0N@BOMBHPEI@BUILD_ROUTE?0?$AA@		; `string'
PUBLIC	??_C@_07ECOFHBDK@REPAIR?0?$AA@			; `string'
PUBLIC	??_C@_0BD@DHGLPCLK@BUILD_IMPROVEMENT?0?$AA@	; `string'
PUBLIC	??_C@_0BP@IKJJJFIJ@BUILD_IMPROVEMENT_ON_RESOURCE?0?$AA@ ; `string'
PUBLIC	??_C@_0M@NMLPMIEL@Evaluating?0?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:PROC
;	COMDAT ??_C@_09FBFAOCJA@?0?5Chosen?$CB?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_09FBFAOCJA@?0?5Chosen?$CB?$AA@ DB ', Chosen!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJEBOOKN@?$CFd?0?$CFd?0?$AA@
CONST	SEGMENT
??_C@_06IJEBOOKN@?$CFd?0?$CFd?0?$AA@ DB '%d,%d,', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LJFDMNAA@CHOP?$AA@
CONST	SEGMENT
??_C@_04LJFDMNAA@CHOP?$AA@ DB 'CHOP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BOMBHPEI@BUILD_ROUTE?0?$AA@
CONST	SEGMENT
??_C@_0N@BOMBHPEI@BUILD_ROUTE?0?$AA@ DB 'BUILD_ROUTE,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECOFHBDK@REPAIR?0?$AA@
CONST	SEGMENT
??_C@_07ECOFHBDK@REPAIR?0?$AA@ DB 'REPAIR,', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHGLPCLK@BUILD_IMPROVEMENT?0?$AA@
CONST	SEGMENT
??_C@_0BD@DHGLPCLK@BUILD_IMPROVEMENT?0?$AA@ DB 'BUILD_IMPROVEMENT,', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IKJJJFIJ@BUILD_IMPROVEMENT_ON_RESOURCE?0?$AA@
CONST	SEGMENT
??_C@_0BP@IKJJJFIJ@BUILD_IMPROVEMENT_ON_RESOURCE?0?$AA@ DB 'BUILD_IMPROVE'
	DB	'MENT_ON_RESOURCE,', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMLPMIEL@Evaluating?0?$AA@
CONST	SEGMENT
??_C@_0M@NMLPMIEL@Evaluating?0?$AA@ DB 'Evaluating,', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$1
__ehfuncinfo$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
_TEXT	SEGMENT
tv403 = -268						; size = 4
tv576 = -264						; size = 4
tv533 = -260						; size = 4
tv502 = -256						; size = 4
tv93 = -252						; size = 4
_this$ = -248						; size = 4
$T223615 = -244						; size = 4
$T223610 = -240						; size = 4
$T223606 = -236						; size = 4
$T223594 = -232						; size = 4
$T223593 = -228						; size = 4
$T223556 = -224						; size = 4
$T223544 = -220						; size = 4
$T223540 = -213						; size = 1
$T223529 = -212						; size = 4
$T223525 = -205						; size = 1
_iMapY$223592 = -204					; size = 4
_iMapX$223591 = -200					; size = 4
$T223518 = -196						; size = 4
$T223508 = -192						; size = 4
$T223507 = -188						; size = 4
$T223476 = -184						; size = 4
$T223471 = -180						; size = 4
$T223467 = -173						; size = 1
$T223456 = -172						; size = 4
$T223452 = -165						; size = 1
_iMapY$223506 = -164					; size = 4
_iMapX$223505 = -160					; size = 4
$T223445 = -156						; size = 4
$T223441 = -152						; size = 4
$T223440 = -148						; size = 4
$T223409 = -144						; size = 4
$T223404 = -140						; size = 4
$T223400 = -133						; size = 1
$T223389 = -132						; size = 4
$T223385 = -125						; size = 1
_iMapY$223439 = -124					; size = 4
_iMapX$223438 = -120					; size = 4
$T223378 = -116						; size = 4
$T223371 = -112						; size = 4
$T223367 = -108						; size = 4
$T223347 = -104						; size = 4
_pkImprovementInfo$218209 = -100			; size = 4
_pPlot$218207 = -96					; size = 4
_pkRouteInfo$218204 = -92				; size = 4
_pkImprovementInfo$218200 = -88				; size = 4
_pPlot$218197 = -84					; size = 4
_pPlot$218194 = -80					; size = 4
_pkResourceInfo$218192 = -76				; size = 4
_strLog$ = -72						; size = 28
_strTemp$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_directive$ = 8						; size = 20
_pUnit$ = 28						; size = 4
_iWeight$ = 32						; size = 4
_bChosen$ = 36						; size = 1
?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z PROC ; CvBuilderTaskingAI::LogDirective, COMDAT
; _this$ = ecx

; 3295 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3296 : 	if(!m_bLogging)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	jne	SHORT $LN22@LogDirecti@2

; 3297 : 	{
; 3298 : 		return;

	jmp	$LN23@LogDirecti@2
$LN22@LogDirecti@2:

; 3299 : 	}
; 3300 : 
; 3301 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3302 : 	CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3303 : 
; 3304 : 	strTemp.Format("%d,", pUnit->GetID()); // unit id

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T223367[ebp], eax
	mov	ecx, DWORD PTR $T223367[ebp]
	push	ecx
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3305 : 	strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3306 : 
; 3307 : 	strLog += "Evaluating,";

	push	OFFSET ??_C@_0M@NMLPMIEL@Evaluating?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3308 : 
; 3309 : 	switch(directive.m_eDirective)

	mov	ecx, DWORD PTR _directive$[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	cmp	DWORD PTR tv93[ebp], 4
	ja	SHORT $LN20@LogDirecti@2
	mov	edx, DWORD PTR tv93[ebp]
	jmp	DWORD PTR $LN148@LogDirecti@2[edx*4]
$LN19@LogDirecti@2:

; 3310 : 	{
; 3311 : 	case BuilderDirective::BUILD_IMPROVEMENT_ON_RESOURCE:
; 3312 : 		strLog += "BUILD_IMPROVEMENT_ON_RESOURCE,";

	push	OFFSET ??_C@_0BP@IKJJJFIJ@BUILD_IMPROVEMENT_ON_RESOURCE?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3313 : 		break;

	jmp	SHORT $LN20@LogDirecti@2
$LN18@LogDirecti@2:

; 3314 : 	case BuilderDirective::BUILD_IMPROVEMENT:
; 3315 : 		strLog += "BUILD_IMPROVEMENT,";

	push	OFFSET ??_C@_0BD@DHGLPCLK@BUILD_IMPROVEMENT?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3316 : 		break;

	jmp	SHORT $LN20@LogDirecti@2
$LN17@LogDirecti@2:

; 3317 : 	case BuilderDirective::REPAIR:
; 3318 : 		strLog += "REPAIR,";

	push	OFFSET ??_C@_07ECOFHBDK@REPAIR?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3319 : 		break;

	jmp	SHORT $LN20@LogDirecti@2
$LN16@LogDirecti@2:

; 3320 : 	case BuilderDirective::BUILD_ROUTE:
; 3321 : 		strLog += "BUILD_ROUTE,";

	push	OFFSET ??_C@_0N@BOMBHPEI@BUILD_ROUTE?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3322 : 		break;

	jmp	SHORT $LN20@LogDirecti@2
$LN15@LogDirecti@2:

; 3323 : 	case BuilderDirective::CHOP:
; 3324 : 		strLog += "CHOP";

	push	OFFSET ??_C@_04LJFDMNAA@CHOP?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN20@LogDirecti@2:

; 3325 : 	}
; 3326 : 
; 3327 : 	strLog += GC.getBuildInfo(directive.m_eBuild)->GetType();

	mov	eax, DWORD PTR _directive$[ebp+4]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR $T223371[ebp], eax
	mov	ecx, DWORD PTR $T223371[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3328 : 	strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3329 : 
; 3330 : 	if(directive.m_eResource != NO_RESOURCE)

	cmp	DWORD PTR _directive$[ebp+8], -1
	je	$LN14@LogDirecti@2

; 3331 : 	{
; 3332 : 		CvResourceInfo* pkResourceInfo = GC.getResourceInfo(directive.m_eResource);

	mov	ecx, DWORD PTR _directive$[ebp+8]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _pkResourceInfo$218192[ebp], eax

; 3333 : 		if(pkResourceInfo)

	cmp	DWORD PTR _pkResourceInfo$218192[ebp], 0
	je	$LN13@LogDirecti@2

; 3334 : 		{
; 3335 : 			strLog += pkResourceInfo->GetType();

	mov	ecx, DWORD PTR _pkResourceInfo$218192[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3336 : 			strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3337 : 			CvPlot* pPlot = GC.getMap().plot(directive.m_sX, directive.m_sY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223378[ebp], edx
	movsx	eax, WORD PTR _directive$[ebp+14]
	mov	DWORD PTR $T223441[ebp], eax
	movsx	ecx, WORD PTR _directive$[ebp+12]
	mov	DWORD PTR $T223440[ebp], ecx
	cmp	DWORD PTR $T223440[ebp], -2147483647	; 80000001H
	je	SHORT $LN44@LogDirecti@2
	cmp	DWORD PTR $T223441[ebp], -2147483647	; 80000001H
	jne	SHORT $LN45@LogDirecti@2
$LN44@LogDirecti@2:
	mov	DWORD PTR _pPlot$218194[ebp], 0
	jmp	$LN46@LogDirecti@2
$LN45@LogDirecti@2:
	mov	edx, DWORD PTR $T223378[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T223385[ebp], al
	mov	ecx, DWORD PTR $T223378[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223389[ebp], edx
	movzx	eax, BYTE PTR $T223385[ebp]
	test	eax, eax
	je	SHORT $LN57@LogDirecti@2
	cmp	DWORD PTR $T223440[ebp], 0
	jge	SHORT $LN56@LogDirecti@2
	mov	eax, DWORD PTR $T223440[ebp]
	cdq
	idiv	DWORD PTR $T223389[ebp]
	add	edx, DWORD PTR $T223389[ebp]
	mov	DWORD PTR _iMapX$223438[ebp], edx
	jmp	SHORT $LN58@LogDirecti@2
	jmp	SHORT $LN57@LogDirecti@2
$LN56@LogDirecti@2:
	mov	ecx, DWORD PTR $T223440[ebp]
	cmp	ecx, DWORD PTR $T223389[ebp]
	jl	SHORT $LN57@LogDirecti@2
	mov	eax, DWORD PTR $T223440[ebp]
	cdq
	idiv	DWORD PTR $T223389[ebp]
	mov	DWORD PTR _iMapX$223438[ebp], edx
	jmp	SHORT $LN58@LogDirecti@2
$LN57@LogDirecti@2:
	mov	edx, DWORD PTR $T223440[ebp]
	mov	DWORD PTR _iMapX$223438[ebp], edx
$LN58@LogDirecti@2:
	mov	eax, DWORD PTR $T223378[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T223400[ebp], cl
	mov	edx, DWORD PTR $T223378[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T223404[ebp], eax
	movzx	ecx, BYTE PTR $T223400[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223404[ebp]
	push	edx
	mov	eax, DWORD PTR $T223441[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$223439[ebp], eax
	mov	ecx, DWORD PTR _iMapY$223439[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$223438[ebp]
	push	edx
	mov	ecx, DWORD PTR $T223378[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN48@LogDirecti@2
	mov	eax, DWORD PTR $T223378[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223409[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223439[ebp]
	imul	edx, DWORD PTR $T223409[ebp]
	add	edx, DWORD PTR _iMapX$223438[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T223378[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv502[ebp], edx
	jmp	SHORT $LN49@LogDirecti@2
$LN48@LogDirecti@2:
	mov	DWORD PTR tv502[ebp], 0
$LN49@LogDirecti@2:
	mov	ecx, DWORD PTR tv502[ebp]
	mov	DWORD PTR _pPlot$218194[ebp], ecx
$LN46@LogDirecti@2:

; 3338 : #ifdef AUI_WARNING_FIXES
; 3339 : 			strTemp.Format("%d,", pPlot->getNumResource());
; 3340 : 			strLog += strTemp;
; 3341 : #else
; 3342 : 			strLog += pPlot->getNumResource();

	mov	ecx, DWORD PTR _pPlot$218194[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 3343 : #endif
; 3344 : 			strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN13@LogDirecti@2:

; 3345 : 		}
; 3346 : 	}
; 3347 : 	else

	jmp	SHORT $LN12@LogDirecti@2
$LN14@LogDirecti@2:

; 3348 : 	{
; 3349 : 		strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN12@LogDirecti@2:

; 3350 : 	}
; 3351 : 
; 3352 : 	if(directive.m_eDirective == BuilderDirective::REPAIR)

	cmp	DWORD PTR _directive$[ebp], 3
	jne	$LN11@LogDirecti@2

; 3353 : 	{
; 3354 : 		CvPlot* pPlot = GC.getMap().plot(directive.m_sX, directive.m_sY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223445[ebp], edx
	movsx	eax, WORD PTR _directive$[ebp+14]
	mov	DWORD PTR $T223508[ebp], eax
	movsx	ecx, WORD PTR _directive$[ebp+12]
	mov	DWORD PTR $T223507[ebp], ecx
	cmp	DWORD PTR $T223507[ebp], -2147483647	; 80000001H
	je	SHORT $LN70@LogDirecti@2
	cmp	DWORD PTR $T223508[ebp], -2147483647	; 80000001H
	jne	SHORT $LN71@LogDirecti@2
$LN70@LogDirecti@2:
	mov	DWORD PTR _pPlot$218197[ebp], 0
	jmp	$LN72@LogDirecti@2
$LN71@LogDirecti@2:
	mov	edx, DWORD PTR $T223445[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T223452[ebp], al
	mov	ecx, DWORD PTR $T223445[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223456[ebp], edx
	movzx	eax, BYTE PTR $T223452[ebp]
	test	eax, eax
	je	SHORT $LN83@LogDirecti@2
	cmp	DWORD PTR $T223507[ebp], 0
	jge	SHORT $LN82@LogDirecti@2
	mov	eax, DWORD PTR $T223507[ebp]
	cdq
	idiv	DWORD PTR $T223456[ebp]
	add	edx, DWORD PTR $T223456[ebp]
	mov	DWORD PTR _iMapX$223505[ebp], edx
	jmp	SHORT $LN84@LogDirecti@2
	jmp	SHORT $LN83@LogDirecti@2
$LN82@LogDirecti@2:
	mov	ecx, DWORD PTR $T223507[ebp]
	cmp	ecx, DWORD PTR $T223456[ebp]
	jl	SHORT $LN83@LogDirecti@2
	mov	eax, DWORD PTR $T223507[ebp]
	cdq
	idiv	DWORD PTR $T223456[ebp]
	mov	DWORD PTR _iMapX$223505[ebp], edx
	jmp	SHORT $LN84@LogDirecti@2
$LN83@LogDirecti@2:
	mov	edx, DWORD PTR $T223507[ebp]
	mov	DWORD PTR _iMapX$223505[ebp], edx
$LN84@LogDirecti@2:
	mov	eax, DWORD PTR $T223445[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T223467[ebp], cl
	mov	edx, DWORD PTR $T223445[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T223471[ebp], eax
	movzx	ecx, BYTE PTR $T223467[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223471[ebp]
	push	edx
	mov	eax, DWORD PTR $T223508[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$223506[ebp], eax
	mov	ecx, DWORD PTR _iMapY$223506[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$223505[ebp]
	push	edx
	mov	ecx, DWORD PTR $T223445[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN74@LogDirecti@2
	mov	eax, DWORD PTR $T223445[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223476[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223506[ebp]
	imul	edx, DWORD PTR $T223476[ebp]
	add	edx, DWORD PTR _iMapX$223505[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T223445[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv533[ebp], edx
	jmp	SHORT $LN75@LogDirecti@2
$LN74@LogDirecti@2:
	mov	DWORD PTR tv533[ebp], 0
$LN75@LogDirecti@2:
	mov	ecx, DWORD PTR tv533[ebp]
	mov	DWORD PTR _pPlot$218197[ebp], ecx
$LN72@LogDirecti@2:

; 3355 : 		if(pPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pPlot$218197[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@LogDirecti@2

; 3356 : 		{
; 3357 : 			if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pPlot$218197[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN9@LogDirecti@2

; 3358 : 			{
; 3359 : 				CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(pPlot->getImprovementType());

	mov	ecx, DWORD PTR _pPlot$218197[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$218200[ebp], eax

; 3360 : 				if(pkImprovementInfo)

	cmp	DWORD PTR _pkImprovementInfo$218200[ebp], 0
	je	SHORT $LN9@LogDirecti@2

; 3361 : 				{
; 3362 : 					strLog += pkImprovementInfo->GetType();

	mov	ecx, DWORD PTR _pkImprovementInfo$218200[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN9@LogDirecti@2:

; 3363 : 				}
; 3364 : 			}
; 3365 : 		}
; 3366 : 		else

	jmp	SHORT $LN7@LogDirecti@2
$LN10@LogDirecti@2:

; 3367 : 		{
; 3368 : 			if(pPlot->getRouteType() != NO_ROUTE)

	mov	ecx, DWORD PTR _pPlot$218197[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	cmp	eax, -1
	je	SHORT $LN7@LogDirecti@2

; 3369 : 			{
; 3370 : 				CvRouteInfo* pkRouteInfo = GC.getRouteInfo(pPlot->getRouteType());

	mov	ecx, DWORD PTR _pPlot$218197[ebp]
	call	?getRouteType@CvPlot@@QBE?AW4RouteTypes@@XZ ; CvPlot::getRouteType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteInfo@CvGlobals@@QAEPAVCvRouteInfo@@W4RouteTypes@@@Z ; CvGlobals::getRouteInfo
	mov	DWORD PTR _pkRouteInfo$218204[ebp], eax

; 3371 : 				if(pkRouteInfo)

	cmp	DWORD PTR _pkRouteInfo$218204[ebp], 0
	je	SHORT $LN7@LogDirecti@2

; 3372 : 				{
; 3373 : 					strLog += pkRouteInfo->GetType();

	mov	ecx, DWORD PTR _pkRouteInfo$218204[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN7@LogDirecti@2:

; 3374 : 				}
; 3375 : 			}
; 3376 : 		}
; 3377 : 	}
; 3378 : 	else

	jmp	$LN4@LogDirecti@2
$LN11@LogDirecti@2:

; 3379 : 	{
; 3380 : 		CvPlot* pPlot = GC.getMap().plot(directive.m_sX, directive.m_sY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223518[ebp], eax
	movsx	ecx, WORD PTR _directive$[ebp+14]
	mov	DWORD PTR $T223594[ebp], ecx
	movsx	edx, WORD PTR _directive$[ebp+12]
	mov	DWORD PTR $T223593[ebp], edx
	cmp	DWORD PTR $T223593[ebp], -2147483647	; 80000001H
	je	SHORT $LN100@LogDirecti@2
	cmp	DWORD PTR $T223594[ebp], -2147483647	; 80000001H
	jne	SHORT $LN101@LogDirecti@2
$LN100@LogDirecti@2:
	mov	DWORD PTR _pPlot$218207[ebp], 0
	jmp	$LN102@LogDirecti@2
$LN101@LogDirecti@2:
	mov	eax, DWORD PTR $T223518[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T223525[ebp], cl
	mov	edx, DWORD PTR $T223518[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T223529[ebp], eax
	movzx	ecx, BYTE PTR $T223525[ebp]
	test	ecx, ecx
	je	SHORT $LN113@LogDirecti@2
	cmp	DWORD PTR $T223593[ebp], 0
	jge	SHORT $LN112@LogDirecti@2
	mov	eax, DWORD PTR $T223593[ebp]
	cdq
	idiv	DWORD PTR $T223529[ebp]
	add	edx, DWORD PTR $T223529[ebp]
	mov	DWORD PTR _iMapX$223591[ebp], edx
	jmp	SHORT $LN114@LogDirecti@2
	jmp	SHORT $LN113@LogDirecti@2
$LN112@LogDirecti@2:
	mov	edx, DWORD PTR $T223593[ebp]
	cmp	edx, DWORD PTR $T223529[ebp]
	jl	SHORT $LN113@LogDirecti@2
	mov	eax, DWORD PTR $T223593[ebp]
	cdq
	idiv	DWORD PTR $T223529[ebp]
	mov	DWORD PTR _iMapX$223591[ebp], edx
	jmp	SHORT $LN114@LogDirecti@2
$LN113@LogDirecti@2:
	mov	eax, DWORD PTR $T223593[ebp]
	mov	DWORD PTR _iMapX$223591[ebp], eax
$LN114@LogDirecti@2:
	mov	ecx, DWORD PTR $T223518[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T223540[ebp], dl
	mov	eax, DWORD PTR $T223518[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T223544[ebp], ecx
	movzx	edx, BYTE PTR $T223540[ebp]
	test	edx, edx
	je	SHORT $LN123@LogDirecti@2
	cmp	DWORD PTR $T223594[ebp], 0
	jge	SHORT $LN122@LogDirecti@2
	mov	eax, DWORD PTR $T223594[ebp]
	cdq
	idiv	DWORD PTR $T223544[ebp]
	add	edx, DWORD PTR $T223544[ebp]
	mov	DWORD PTR _iMapY$223592[ebp], edx
	jmp	SHORT $LN124@LogDirecti@2
	jmp	SHORT $LN123@LogDirecti@2
$LN122@LogDirecti@2:
	mov	eax, DWORD PTR $T223594[ebp]
	cmp	eax, DWORD PTR $T223544[ebp]
	jl	SHORT $LN123@LogDirecti@2
	mov	eax, DWORD PTR $T223594[ebp]
	cdq
	idiv	DWORD PTR $T223544[ebp]
	mov	DWORD PTR _iMapY$223592[ebp], edx
	jmp	SHORT $LN124@LogDirecti@2
$LN123@LogDirecti@2:
	mov	ecx, DWORD PTR $T223594[ebp]
	mov	DWORD PTR _iMapY$223592[ebp], ecx
$LN124@LogDirecti@2:
	mov	edx, DWORD PTR _iMapY$223592[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$223591[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223518[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN104@LogDirecti@2
	mov	ecx, DWORD PTR $T223518[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T223556[ebp], edx
	mov	eax, DWORD PTR _iMapY$223592[ebp]
	imul	eax, DWORD PTR $T223556[ebp]
	add	eax, DWORD PTR _iMapX$223591[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T223518[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv576[ebp], eax
	jmp	SHORT $LN105@LogDirecti@2
$LN104@LogDirecti@2:
	mov	DWORD PTR tv576[ebp], 0
$LN105@LogDirecti@2:
	mov	edx, DWORD PTR tv576[ebp]
	mov	DWORD PTR _pPlot$218207[ebp], edx
$LN102@LogDirecti@2:

; 3381 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pPlot$218207[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN4@LogDirecti@2

; 3382 : 		{
; 3383 : 			CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(pPlot->getImprovementType());

	mov	ecx, DWORD PTR _pPlot$218207[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkImprovementInfo$218209[ebp], eax

; 3384 : 			if(pkImprovementInfo)

	cmp	DWORD PTR _pkImprovementInfo$218209[ebp], 0
	je	SHORT $LN4@LogDirecti@2

; 3385 : 			{
; 3386 : 				strLog += pkImprovementInfo->GetType();

	mov	ecx, DWORD PTR _pkImprovementInfo$218209[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN4@LogDirecti@2:

; 3387 : 			}
; 3388 : 		}
; 3389 : 	}
; 3390 : 	strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3391 : 
; 3392 : 	strTemp.Format("%d,%d,", directive.m_sX, directive.m_sY);

	movsx	eax, WORD PTR _directive$[ebp+14]
	push	eax
	movsx	ecx, WORD PTR _directive$[ebp+12]
	push	ecx
	push	OFFSET ??_C@_06IJEBOOKN@?$CFd?0?$CFd?0?$AA@
	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3393 : 	strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3394 : 
; 3395 : 	strTemp.Format("%d,", directive.m_sMoveTurnsAway);

	movsx	ecx, WORD PTR _directive$[ebp+16]
	push	ecx
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3396 : 	strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3397 : 
; 3398 : 	strTemp.Format("%d,", iWeight);

	mov	ecx, DWORD PTR _iWeight$[ebp]
	push	ecx
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	edx, DWORD PTR _strTemp$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 3399 : 	strLog += strTemp;

	lea	eax, DWORD PTR _strTemp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3400 : 
; 3401 : 	if(bChosen)

	movzx	ecx, BYTE PTR _bChosen$[ebp]
	test	ecx, ecx
	je	SHORT $LN134@LogDirecti@2

; 3402 : 	{
; 3403 : 		strLog += (", Chosen!");

	push	OFFSET ??_C@_09FBFAOCJA@?0?5Chosen?$CB?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 3404 : 	}
; 3405 : 
; 3406 : 	LogInfo(strLog, m_pPlayer, GET_PLAYER(pUnit->getOwner()).isHuman());

$LN134@LogDirecti@2:
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T223606[ebp], eax
	mov	ecx, DWORD PTR $T223606[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223610[ebp], ecx
	mov	ecx, DWORD PTR $T223610[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T223347[ebp], esp
	mov	DWORD PTR $T223615[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223615[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T223615[ebp]
	mov	DWORD PTR tv403[ebp], ecx
	call	?LogInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@_N@Z ; CvBuilderTaskingAI::LogInfo
	add	esp, 36					; 00000024H

; 3407 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strTemp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN23@LogDirecti@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	3
$LN148@LogDirecti@2:
	DD	$LN19@LogDirecti@2
	DD	$LN18@LogDirecti@2
	DD	$LN16@LogDirecti@2
	DD	$LN17@LogDirecti@2
	DD	$LN15@LogDirecti@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$0:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z$1:
	lea	ecx, DWORD PTR _strTemp$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogDirective@CvBuilderTaskingAI@@IAEXUBuilderDirective@@PAVCvUnit@@H_N@Z ENDP ; CvBuilderTaskingAI::LogDirective
PUBLIC	??_C@_0CC@NMNODMKM@Plot?5Yield?5Update?0?5?$CFs?0?5?$CFi?0?5?$CFi?0?5?$CF@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z:PROC ; FSerialization::toString
EXTRN	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z:PROC	; CvPlot::getYield
;	COMDAT ??_C@_0CC@NMNODMKM@Plot?5Yield?5Update?0?5?$CFs?0?5?$CFi?0?5?$CFi?0?5?$CF@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CC@NMNODMKM@Plot?5Yield?5Update?0?5?$CFs?0?5?$CFi?0?5?$CFi?0?5?$CF@ DB 'P'
	DB	'lot Yield Update, %s, %i, %i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$1
__ehfuncinfo$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
tv151 = -112						; size = 4
tv148 = -108						; size = 4
tv169 = -104						; size = 4
_this$ = -100						; size = 4
$T223655 = -96						; size = 4
$T223650 = -92						; size = 4
$T223646 = -88						; size = 4
$T223635 = -84						; size = 4
$T223634 = -80						; size = 28
_strLog$218225 = -52					; size = 28
__$ArrayPad$ = -24					; size = 4
_yield$218226 = -20					; size = 4
_ui$218219 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z PROC ; CvBuilderTaskingAI::UpdateCurrentPlotYields, COMDAT
; _this$ = ecx

; 3411 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3412 : 	m_pTargetPlot = pPlot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	DWORD PTR [eax+58400], ecx

; 3413 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$218219[ebp], 0
	jmp	SHORT $LN4@UpdateCurr
$LN3@UpdateCurr:
	mov	edx, DWORD PTR _ui$218219[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$218219[ebp], edx
$LN4@UpdateCurr:
	cmp	DWORD PTR _ui$218219[ebp], 6
	jae	$LN5@UpdateCurr

; 3414 : 	{
; 3415 : 		m_aiCurrentPlotYields[ui] = pPlot->getYield((YieldTypes)ui);

	mov	eax, DWORD PTR _ui$218219[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getYield@CvPlot@@QBEHW4YieldTypes@@@Z	; CvPlot::getYield
	mov	ecx, DWORD PTR _ui$218219[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+58404], eax

; 3416 : 
; 3417 : 		if(m_bLogging){

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+58392]
	test	ecx, ecx
	je	$LN1@UpdateCurr

; 3418 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$218225[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3419 : 			YieldTypes yield = (YieldTypes) ui;

	mov	edx, DWORD PTR _ui$218219[ebp]
	mov	DWORD PTR _yield$218226[ebp], edx

; 3420 : 			strLog.Format("Plot Yield Update, %s, %i, %i, %i", FSerialization::toString(yield).c_str(), m_aiCurrentPlotYields[ui], pPlot->getX(), pPlot->getY());

	lea	eax, DWORD PTR _yield$218226[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223634[ebp]
	push	ecx
	call	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z ; FSerialization::toString
	add	esp, 8
	mov	DWORD PTR tv169[ebp], eax
	mov	edx, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv148[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T223646[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T223650[ebp], eax
	mov	ecx, DWORD PTR $T223646[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223650[ebp]
	push	edx
	mov	eax, DWORD PTR _ui$218219[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+58404]
	push	edx
	mov	ecx, DWORD PTR tv148[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CC@NMNODMKM@Plot?5Yield?5Update?0?5?$CFs?0?5?$CFi?0?5?$CFi?0?5?$CF@
	lea	eax, DWORD PTR _strLog$218225[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T223634[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3421 : 			LogYieldInfo(strLog, m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T223635[ebp], esp
	mov	DWORD PTR $T223655[ebp], eax
	lea	ecx, DWORD PTR _strLog$218225[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T223655[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T223655[ebp]
	mov	DWORD PTR tv151[ebp], edx
	call	?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ; CvBuilderTaskingAI::LogYieldInfo
	add	esp, 32					; 00000020H

; 3422 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$218225[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@UpdateCurr:
	jmp	$LN3@UpdateCurr
$LN5@UpdateCurr:

; 3423 : 	}
; 3424 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$0:
	lea	ecx, DWORD PTR _strLog$218225[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z$1:
	lea	ecx, DWORD PTR $T223634[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ENDP ; CvBuilderTaskingAI::UpdateCurrentPlotYields
PUBLIC	??_C@_0CM@KCHGJLOA@Plot?5Projected?5Yield?5Update?0?5?$CFs?0@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z:PROC ; CvPlot::getYieldWithBuild
;	COMDAT ??_C@_0CM@KCHGJLOA@Plot?5Projected?5Yield?5Update?0?5?$CFs?0@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CM@KCHGJLOA@Plot?5Projected?5Yield?5Update?0?5?$CFs?0@ DB 'Plot Pr'
	DB	'ojected Yield Update, %s, %i, %i, %i', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$1
__ehfuncinfo$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
xdata$x	ENDS
;	COMDAT ?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
_TEXT	SEGMENT
tv168 = -132						; size = 4
tv165 = -128						; size = 4
tv188 = -124						; size = 4
tv170 = -120						; size = 4
_this$ = -116						; size = 4
$T223710 = -112						; size = 4
$T223705 = -108						; size = 4
$T223701 = -104						; size = 4
$T223693 = -100						; size = 4
$T223690 = -96						; size = 4
$T223683 = -92						; size = 4
$T223671 = -88						; size = 4
$T223670 = -84						; size = 28
$T223669 = -56						; size = 4
_strLog$218248 = -52					; size = 28
__$ArrayPad$ = -24					; size = 4
_yield$218249 = -20					; size = 4
_ui$218241 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pPlot$ = 8						; size = 4
_eBuild$ = 12						; size = 4
?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z PROC ; CvBuilderTaskingAI::UpdateProjectedPlotYields, COMDAT
; _this$ = ecx

; 3428 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3429 : 	if(pPlot != m_pTargetPlot)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	cmp	ecx, DWORD PTR [eax+58400]
	je	SHORT $LN5@UpdateProj

; 3430 : 	{
; 3431 : 		UpdateCurrentPlotYields(pPlot);

	mov	edx, DWORD PTR _pPlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateCurrentPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@@Z ; CvBuilderTaskingAI::UpdateCurrentPlotYields
$LN5@UpdateProj:

; 3432 : 	}
; 3433 : 
; 3434 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$218241[ebp], 0
	jmp	SHORT $LN4@UpdateProj
$LN3@UpdateProj:
	mov	eax, DWORD PTR _ui$218241[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$218241[ebp], eax
$LN4@UpdateProj:
	cmp	DWORD PTR _ui$218241[ebp], 6
	jae	$LN6@UpdateProj

; 3435 : 	{
; 3436 : 		m_aiProjectedPlotYields[ui] = pPlot->getYieldWithBuild(eBuild, (YieldTypes)ui, false, m_pPlayer->GetID());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T223683[ebp], eax
	mov	ecx, DWORD PTR $T223683[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ui$218241[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getYieldWithBuild@CvPlot@@QBEHW4BuildTypes@@W4YieldTypes@@_NW4PlayerTypes@@@Z ; CvPlot::getYieldWithBuild
	mov	ecx, DWORD PTR _ui$218241[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+58428], eax

; 3437 : 		m_aiProjectedPlotYields[ui] = max(m_aiProjectedPlotYields[ui], 0);

	mov	DWORD PTR $T223669[ebp], 0
	mov	eax, DWORD PTR _ui$218241[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+58428]
	mov	DWORD PTR $T223693[ebp], edx
	mov	eax, DWORD PTR $T223693[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T223669[ebp]
	jge	SHORT $LN17@UpdateProj
	lea	edx, DWORD PTR $T223669[ebp]
	mov	DWORD PTR tv170[ebp], edx
	jmp	SHORT $LN18@UpdateProj
$LN17@UpdateProj:
	mov	eax, DWORD PTR $T223693[ebp]
	mov	DWORD PTR tv170[ebp], eax
$LN18@UpdateProj:
	mov	ecx, DWORD PTR tv170[ebp]
	mov	DWORD PTR $T223690[ebp], ecx
	mov	edx, DWORD PTR _ui$218241[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T223690[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx*4+58428], ecx

; 3438 : #ifdef AUI_WORKER_FIX_CELTIC_IMPROVE_UNIMPROVED_FORESTS
; 3439 : 		if (ui == YIELD_FAITH && m_pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest() && pPlot->getImprovementType() == NO_IMPROVEMENT)
; 3440 : 		{
; 3441 : 			CvBuildInfo* pBuildInfo = GC.getBuildInfo(eBuild);
; 3442 : 			if (pBuildInfo && (pBuildInfo->getImprovement() != NO_IMPROVEMENT || pBuildInfo->isFeatureRemove(FEATURE_FOREST)))
; 3443 : 			{
; 3444 : 				CvCity* pNextCity = pPlot->GetAdjacentCity();
; 3445 : 				if (pNextCity && pNextCity->getOwner() == m_pPlayer->GetID())
; 3446 : 				{
; 3447 : 					int iNeighboringForestCount = 1;
; 3448 : 					CvPlot* pAdjacentPlot = NULL;
; 3449 : 					for (int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)
; 3450 : 					{
; 3451 : 						pAdjacentPlot = pNextCity->plot()->getNeighboringPlot((DirectionTypes)iI);
; 3452 : 						if (pAdjacentPlot && pAdjacentPlot != pPlot && pAdjacentPlot->getFeatureType() == FEATURE_FOREST && pPlot->getImprovementType() == NO_IMPROVEMENT)
; 3453 : 						{
; 3454 : 							ResourceTypes eAdjacentResource = pPlot->getResourceType(m_pPlayer->getTeam());
; 3455 : 							if (eAdjacentResource == NO_RESOURCE || GC.getResourceInfo(eAdjacentResource)->getResourceUsage() == RESOURCEUSAGE_BONUS)
; 3456 : 							{
; 3457 : 								iNeighboringForestCount++;
; 3458 : 							}
; 3459 : 						}
; 3460 : 					}
; 3461 : 					if (iNeighboringForestCount == 3 || iNeighboringForestCount == 1)
; 3462 : 					{
; 3463 : 						m_aiProjectedPlotYields[YIELD_FAITH] -= 1;
; 3464 : 					}
; 3465 : 				}
; 3466 : 			}
; 3467 : 		}
; 3468 : #endif
; 3469 : 
; 3470 : 		if(m_bLogging){

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+58392]
	test	eax, eax
	je	$LN1@UpdateProj

; 3471 : 			CvString strLog;

	lea	ecx, DWORD PTR _strLog$218248[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3472 : 			YieldTypes yield = (YieldTypes) ui;

	mov	ecx, DWORD PTR _ui$218241[ebp]
	mov	DWORD PTR _yield$218249[ebp], ecx

; 3473 : 			strLog.Format("Plot Projected Yield Update, %s, %i, %i, %i", FSerialization::toString(yield).c_str(), m_aiProjectedPlotYields[ui], pPlot->getX(), pPlot->getY());

	lea	edx, DWORD PTR _yield$218249[ebp]
	push	edx
	lea	eax, DWORD PTR $T223670[ebp]
	push	eax
	call	?toString@FSerialization@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABW4YieldTypes@@@Z ; FSerialization::toString
	add	esp, 8
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T223701[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T223705[ebp], edx
	mov	eax, DWORD PTR $T223701[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223705[ebp]
	push	ecx
	mov	edx, DWORD PTR _ui$218241[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+58428]
	push	ecx
	mov	ecx, DWORD PTR tv165[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CM@KCHGJLOA@Plot?5Projected?5Yield?5Update?0?5?$CFs?0@
	lea	edx, DWORD PTR _strLog$218248[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T223670[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3474 : 			LogYieldInfo(strLog, m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T223671[ebp], esp
	mov	DWORD PTR $T223710[ebp], edx
	lea	eax, DWORD PTR _strLog$218248[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223710[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T223710[ebp]
	mov	DWORD PTR tv168[ebp], ecx
	call	?LogYieldInfo@CvBuilderTaskingAI@@SAXVCvString@@PAVCvPlayer@@@Z ; CvBuilderTaskingAI::LogYieldInfo
	add	esp, 32					; 00000020H

; 3475 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLog$218248[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@UpdateProj:
	jmp	$LN3@UpdateProj
$LN6@UpdateProj:

; 3476 : 	}
; 3477 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$0:
	lea	ecx, DWORD PTR _strLog$218248[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z$1:
	lea	ecx, DWORD PTR $T223670[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdateProjectedPlotYields@CvBuilderTaskingAI@@IAEXPAVCvPlot@@W4BuildTypes@@@Z ENDP ; CvBuilderTaskingAI::UpdateProjectedPlotYields
PUBLIC	??1?$BaseVector@H$00@@QAE@XZ			; BaseVector<int,1>::~BaseVector<int,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T223733 = -20						; size = 4
_pRet$223729 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,14592,1,297,0>::FStaticVector<int,14592,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 14592		; 00003900H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223733[ebp], edx
	cmp	DWORD PTR $T223733[ebp], 14592		; 00003900H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T223733[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$223729[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T223733[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$223729[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 14592		; 00003900H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$223729[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,14592,1,297,0>::FStaticVector<int,14592,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T223764 = -24						; size = 4
$T223763 = -20						; size = 4
_i$223758 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223764[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223763[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$223758[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$223758[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223758[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$223758[ebp]
	cmp	ecx, DWORD PTR $T223764[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T223763[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T223763[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,14592,1,297,0>::~FStaticVector<int,14592,1,297,0>
PUBLIC	?Copy@?$BaseVector@H$00@@IAEXABV1@@Z		; BaseVector<int,1>::Copy
; Function compile flags: /Odtp
;	COMDAT ??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_i$223808 = -24						; size = 4
$T223804 = -20						; size = 4
_pRet$223800 = -16					; size = 4
$T223797 = -12						; size = 4
$T223796 = -8						; size = 4
_i$223791 = -4						; size = 4
_RHS$ = 8						; size = 4
??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<int,14592,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	ja	$LN2@operator

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223797[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223796[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN6@operator
	xor	edx, edx
	je	SHORT $LN6@operator
	mov	DWORD PTR _i$223791[ebp], 0
	jmp	SHORT $LN11@operator
$LN10@operator:
	mov	eax, DWORD PTR _i$223791[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223791[ebp], eax
$LN11@operator:
	mov	ecx, DWORD PTR _i$223791[ebp]
	cmp	ecx, DWORD PTR $T223797[ebp]
	jae	SHORT $LN6@operator
	jmp	SHORT $LN10@operator
$LN6@operator:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T223796[ebp], edx
	je	SHORT $LN7@operator
	mov	eax, DWORD PTR $T223796[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN7@operator:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223804[ebp], edx
	cmp	DWORD PTR $T223804[ebp], 14592		; 00003900H
	jbe	SHORT $LN16@operator
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T223804[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$223800[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T223804[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN17@operator
$LN16@operator:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$223800[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 14592		; 00003900H
$LN17@operator:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$223800[ebp]
	mov	DWORD PTR [edx], eax

; 624  : 		}else{

	jmp	SHORT $LN1@operator
$LN2@operator:

; 625  : 			Destroy(m_pData, m_uiCurrSize);

	xor	ecx, ecx
	je	SHORT $LN1@operator
	mov	DWORD PTR _i$223808[ebp], 0
	jmp	SHORT $LN21@operator
$LN20@operator:
	mov	edx, DWORD PTR _i$223808[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223808[ebp], edx
$LN21@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$223808[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN1@operator
	jmp	SHORT $LN20@operator
$LN1@operator:

; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR _RHS$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@?$BaseVector@H$00@@IAEXABV1@@Z	; BaseVector<int,1>::Copy

; 628  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<int,14592,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,14592,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T223822 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,14592,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+58380], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,14592,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T223822[ebp], ecx
	cmp	DWORD PTR $T223822[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T223822[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T223822[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,14592,1,297,0>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
_weightedElem$ = -24					; size = 24
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z PROC ; CvWeightedVector<BuilderDirective,100,1>::push_back, COMDAT
; _this$ = ecx

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;

	lea	ecx, DWORD PTR _weightedElem$[ebp]
	call	??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement

; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _weightedElem$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _weightedElem$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _weightedElem$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _weightedElem$[ebp+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _weightedElem$[ebp+16], eax

; 108  : 		weightedElem.m_iWeight = iWeight;

	mov	ecx, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR _weightedElem$[ebp+20], ecx

; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	lea	edx, DWORD PTR _weightedElem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back

; 111  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?push_back@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAEIABUBuilderDirective@@H@Z ENDP ; CvWeightedVector<BuilderDirective,100,1>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T223911 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z PROC ; FStaticVector<int,64,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+268], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<int,64,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T223911[ebp], ecx
	cmp	DWORD PTR $T223911[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR $T223911[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T223911[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAEIABH@Z ENDP ; FStaticVector<int,64,1,297,0>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@H$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@H$00@@QAE@XZ PROC			; BaseVector<int,1>::~BaseVector<int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@H$00@@QAE@XZ ENDP			; BaseVector<int,1>::~BaseVector<int,1>
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?Copy@?$BaseVector@H$00@@IAEXABV1@@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
_this$ = -12						; size = 4
$T223957 = -8						; size = 4
_i$218340 = -4						; size = 4
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@H$00@@IAEXABV1@@Z PROC		; BaseVector<int,1>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 231  : 		if( bPODType ){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Copy

; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _RHS$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{

	jmp	SHORT $LN6@Copy
$LN5@Copy:

; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	mov	DWORD PTR _i$218340[ebp], 0
	jmp	SHORT $LN3@Copy
$LN2@Copy:
	mov	ecx, DWORD PTR _i$218340[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$218340[ebp], ecx
$LN3@Copy:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$218340[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@Copy

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$218340[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T223957[ebp], ecx
	cmp	DWORD PTR $T223957[ebp], 0
	je	SHORT $LN8@Copy
	mov	edx, DWORD PTR _RHS$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T223957[ebp]
	mov	edx, DWORD PTR _i$218340[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T223957[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN9@Copy
$LN8@Copy:
	mov	DWORD PTR tv83[ebp], 0
$LN9@Copy:

; 236  : 			}

	jmp	SHORT $LN2@Copy
$LN6@Copy:

; 237  : 		}
; 238  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@?$BaseVector@H$00@@IAEXABV1@@Z ENDP		; BaseVector<int,1>::Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T224000 = -36						; size = 4
$T223999 = -32						; size = 4
_i$223994 = -28						; size = 4
$T223975 = -24						; size = 4
_pRet$223971 = -20					; size = 4
$T223966 = -16						; size = 4
_i$218365 = -12						; size = 4
_uiNewSize$218357 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,14592,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$218357[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$218357[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$218357[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T223975[ebp], ecx
	cmp	DWORD PTR $T223975[ebp], 14592		; 00003900H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T223975[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$223971[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T223975[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$223971[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 14592		; 00003900H
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$223971[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$218365[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$218365[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218365[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$218365[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$218365[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T223966[ebp], ecx
	cmp	DWORD PTR $T223966[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T223966[ebp]
	mov	edx, DWORD PTR _i$218365[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T223966[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224000[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T223999[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$223994[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	edx, DWORD PTR _i$223994[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223994[ebp], edx
$LN26@GrowSize:
	mov	eax, DWORD PTR _i$223994[ebp]
	cmp	eax, DWORD PTR $T224000[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T223999[ebp], ecx
	je	SHORT $LN22@GrowSize
	mov	edx, DWORD PTR $T223999[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+58380], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,14592,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T224004 = -8						; size = 4
$T224003 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2412], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T224004[ebp], ecx
	je	SHORT $LN4@push_back@3
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T224004[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T224004[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR $T224004[ebp]
	mov	DWORD PTR tv149[ebp], ecx
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@3:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T224003[ebp], edx

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv157[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::push_back
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ PROC ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], -1
	or	eax, -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax
	or	edx, -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+14], dx
	or	ecx, -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+16], cx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 32   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@QAE@XZ ENDP ; CvWeightedVector<BuilderDirective,100,1>::WeightedElement::WeightedElement
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T224097 = -36						; size = 4
$T224096 = -32						; size = 4
_i$224091 = -28						; size = 4
$T224072 = -24						; size = 4
_pRet$224068 = -20					; size = 4
$T224063 = -16						; size = 4
_i$218426 = -12						; size = 4
_uiNewSize$218418 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<int,64,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$218418[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$218418[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$218418[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224072[ebp], ecx
	cmp	DWORD PTR $T224072[ebp], 64		; 00000040H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T224072[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$224068[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T224072[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@2
$LN15@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$224068[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H
$LN16@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$224068[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$218426[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$218426[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218426[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$218426[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$218426[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T224063[ebp], ecx
	cmp	DWORD PTR $T224063[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T224063[ebp]
	mov	edx, DWORD PTR _i$218426[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T224063[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize@2:
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224097[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T224096[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize@2
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@2
	mov	DWORD PTR _i$224091[ebp], 0
	jmp	SHORT $LN26@GrowSize@2
$LN25@GrowSize@2:
	mov	edx, DWORD PTR _i$224091[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224091[ebp], edx
$LN26@GrowSize@2:
	mov	eax, DWORD PTR _i$224091[ebp]
	cmp	eax, DWORD PTR $T224097[ebp]
	jae	SHORT $LN21@GrowSize@2
	jmp	SHORT $LN25@GrowSize@2
$LN21@GrowSize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T224096[ebp], ecx
	je	SHORT $LN22@GrowSize@2
	mov	edx, DWORD PTR $T224096[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+268], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<int,64,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T224140 = -44						; size = 4
$T224139 = -40						; size = 4
_i$224134 = -36						; size = 4
$T224118 = -32						; size = 4
$T224111 = -28						; size = 4
_pRet$224107 = -24					; size = 4
$T224101 = -20						; size = 4
$T224100 = -16						; size = 4
_i$218462 = -12						; size = 4
_uiNewSize$218454 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@3

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$218454[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$218454[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@3

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@3
$LN6@GrowSize@3:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$218454[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@3
$LN7@GrowSize@3:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224111[ebp], ecx
	cmp	DWORD PTR $T224111[ebp], 100		; 00000064H
	jbe	SHORT $LN16@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T224111[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$224107[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T224111[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$224107[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 100			; 00000064H
$LN17@GrowSize@3:
	mov	ecx, DWORD PTR _pRet$224107[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@3

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@3
$LN5@GrowSize@3:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$218462[ebp], 0
	jmp	SHORT $LN3@GrowSize@3
$LN2@GrowSize@3:
	mov	edx, DWORD PTR _i$218462[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218462[ebp], edx
$LN3@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$218462[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@3

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$218462[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T224101[ebp], edx
	je	SHORT $LN12@GrowSize@3
	mov	eax, DWORD PTR _i$218462[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T224118[ebp], eax
	mov	edx, DWORD PTR $T224118[ebp]
	mov	eax, DWORD PTR $T224101[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T224101[ebp]
	mov	ecx, DWORD PTR $T224118[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T224101[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@3
$LN12@GrowSize@3:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@3:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T224100[ebp], ecx
	jmp	SHORT $LN2@GrowSize@3
$LN4@GrowSize@3:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224140[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T224139[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@3
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@3
	mov	DWORD PTR _i$224134[ebp], 0
	jmp	SHORT $LN29@GrowSize@3
$LN28@GrowSize@3:
	mov	edx, DWORD PTR _i$224134[ebp]
	add	edx, 1
	mov	DWORD PTR _i$224134[ebp], edx
$LN29@GrowSize@3:
	mov	eax, DWORD PTR _i$224134[ebp]
	cmp	eax, DWORD PTR $T224140[ebp]
	jae	SHORT $LN24@GrowSize@3
	jmp	SHORT $LN28@GrowSize@3
$LN24@GrowSize@3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T224139[ebp], ecx
	je	SHORT $LN25@GrowSize@3
	mov	edx, DWORD PTR $T224139[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+2412], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
PUBLIC	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
_TEXT	SEGMENT
$T224248 = -112						; size = 4
__Next$224251 = -108					; size = 4
$T224165 = -48						; size = 4
$T224161 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z PROC ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3411 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3412 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T224161[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T224161[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T224165[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T224165[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H

; 3415 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$224251[ebp], edx
	jmp	SHORT $LN62@Stable_sor
$LN61@Stable_sor:
	mov	eax, DWORD PTR __Next$224251[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$224251[ebp], eax
$LN62@Stable_sor:
	mov	ecx, DWORD PTR __Next$224251[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor
	jmp	SHORT $LN61@Stable_sor
$LN60@Stable_sor:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T224248[ebp], edx
	mov	eax, DWORD PTR $T224248[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0PAH0@Z ENDP ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T224274 = -8						; size = 4
__Next$218617 = -4					; size = 4
??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$218617[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$218617[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$218617[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$218617[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224274[ebp], ecx
	mov	edx, DWORD PTR $T224274[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
PUBLIC	??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
PUBLIC	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
__Count2$218676 = -8					; size = 4
__Mid$218677 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H

; 3382 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 3384 : 	else

	jmp	$LN5@Stable_sor@2
$LN4@Stable_sor@2:

; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$218676[ebp], eax

; 3387 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$218677[ebp], edx

; 3388 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$218676[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Mid$218677[ebp]
	mov	DWORD PTR __Mid$218677[ebp], eax

; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	DWORD PTR __Count2$218676[ebp], eax
	jg	SHORT $LN2@Stable_sor@2

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$218676[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$218677[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$218676[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$218677[ebp]
	push	edx
	call	??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN1@Stable_sor@2
$LN2@Stable_sor@2:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$218676[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$218677[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$218676[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$218677[ebp]
	push	ecx
	call	??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@Stable_sor@2:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$218676[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$218676[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$218677[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 24					; 00000018H
$LN5@Stable_sor@2:

; 3403 : 		}
; 3404 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Stable_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$218742 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$218742[ebp]
	push	ecx
	call	??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$218742[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$218742[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$218742[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$218742[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
PUBLIC	??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
tv139 = -248						; size = 4
$T224877 = -133						; size = 1
$T224715 = -132						; size = 4
$T224711 = -128						; size = 4
$T224674 = -104						; size = 4
$T224644 = -64						; size = 4
$T224607 = -20						; size = 4
__Chunk$218810 = -16					; size = 4
__Midend$218808 = -12					; size = 4
__Nleft$218804 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 3355 : 	{	// sort using temp buffer for merges, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$218804[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$218804[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$218804[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$218804[ebp], 32	; 00000020H
	jl	SHORT $LN38@Buffered_m

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midend$218808[ebp], eax

; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Midend$218808[ebp]
	mov	DWORD PTR __Midend$218808[ebp], ecx

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	mov	edx, DWORD PTR __Midend$218808[ebp]
	mov	DWORD PTR $T224644[ebp], edx
	push	0
	mov	eax, DWORD PTR $T224644[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 3363 : 		_Mid = _Midend;

	mov	edx, DWORD PTR __Midend$218808[ebp]
	mov	DWORD PTR __Mid$[ebp], edx

; 3364 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

$LN38@Buffered_m:
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$218810[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	edx, DWORD PTR __Chunk$218810[ebp]
	shl	edx, 1
	mov	DWORD PTR __Chunk$218810[ebp], edx
$LN3@Buffered_m:
	mov	eax, DWORD PTR __Chunk$218810[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$218810[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T224607[ebp], esp
	mov	DWORD PTR $T224674[ebp], edx
	mov	eax, DWORD PTR $T224674[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T224674[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T224674[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T224674[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T224674[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T224674[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
	add	esp, 36					; 00000024H

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	ecx, DWORD PTR __Chunk$218810[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$218810[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224711[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224715[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T224877[ebp], dl
	movzx	eax, BYTE PTR $T224877[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$218810[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224711[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224715[ebp]
	push	edx
	call	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
	add	esp, 24					; 00000018H

; 3373 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3374 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0HAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
PUBLIC	??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
PUBLIC	??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
PUBLIC	??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
PUBLIC	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
tv221 = -312						; size = 4
tv220 = -308						; size = 4
tv217 = -304						; size = 4
tv216 = -300						; size = 4
$T225141 = -228						; size = 4
$T225123 = -220						; size = 4
$T225122 = -216						; size = 4
$T225057 = -184						; size = 4
$T225039 = -176						; size = 4
$T225038 = -172						; size = 4
$T225012 = -165						; size = 1
$T225007 = -164						; size = 4
$T225003 = -160						; size = 4
$T224988 = -156						; size = 4
__Next$224991 = -152					; size = 4
$T224980 = -148						; size = 4
$T224967 = -136						; size = 4
$T224966 = -132						; size = 4
$T224965 = -128						; size = 4
$T224961 = -122						; size = 1
$T224960 = -121						; size = 1
$T224950 = -120						; size = 4
$T224946 = -116						; size = 4
$T224931 = -112						; size = 4
__Next$224934 = -108					; size = 4
$T224923 = -104						; size = 4
__Tmp$224906 = -92					; size = 24
$T224884 = -68						; size = 20
$T224883 = -48						; size = 4
$T224882 = -44						; size = 20
$T224881 = -24						; size = 4
__Firstn$218880 = -20					; size = 4
__Count2n$218883 = -16					; size = 4
__Midn$218900 = -12					; size = 4
__Lastn$218881 = -8					; size = 4
__Count1n$218882 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	$LN9@Buffered_m@2

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN8@Buffered_m@2

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$224906[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$224906[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$224906[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$224906[ebp+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$224906[ebp+16], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$224906[ebp+20], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR __Tmp$224906[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$224906[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Tmp$224906[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Tmp$224906[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR __Tmp$224906[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR __Tmp$224906[ebp+20]
	mov	DWORD PTR [edx+20], ecx
$LN8@Buffered_m@2:

; 2764 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	edx, DWORD PTR __Count1$[ebp]
	cmp	edx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T224881[ebp], esp
	mov	DWORD PTR $T224923[ebp], edx
	mov	eax, DWORD PTR $T224923[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T224923[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T224923[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T224923[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T224923[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T224923[ebp]
	mov	DWORD PTR tv216[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224882[ebp]
	push	ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv217[ebp], eax
	cmp	DWORD PTR $T224882[ebp], 0
	je	SHORT $LN38@Buffered_m@2
	mov	edx, DWORD PTR $T224882[ebp]
	mov	DWORD PTR __Next$224934[ebp], edx
	jmp	SHORT $LN36@Buffered_m@2
$LN35@Buffered_m@2:
	mov	eax, DWORD PTR __Next$224934[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$224934[ebp], eax
$LN36@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$224934[ebp]
	cmp	ecx, DWORD PTR $T224882[ebp+8]
	je	SHORT $LN34@Buffered_m@2
	jmp	SHORT $LN35@Buffered_m@2
$LN34@Buffered_m@2:
	mov	edx, DWORD PTR $T224882[ebp]
	mov	DWORD PTR $T224931[ebp], edx
	mov	eax, DWORD PTR $T224931[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN38@Buffered_m@2:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224946[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T224950[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T224967[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T224966[ebp], edx
	mov	eax, DWORD PTR $T224950[ebp]
	mov	DWORD PTR $T224965[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T224960[ebp], cl
	movzx	edx, BYTE PTR $T224960[ebp]
	push	edx
	movzx	eax, BYTE PTR $T224961[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224967[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T224966[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224946[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224965[ebp]
	push	edx
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T224883[ebp], esp
	mov	DWORD PTR $T224980[ebp], edx
	mov	eax, DWORD PTR $T224980[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T224980[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T224980[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T224980[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T224980[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T224980[ebp]
	mov	DWORD PTR tv220[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224884[ebp]
	push	ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR $T224884[ebp], 0
	je	SHORT $LN65@Buffered_m@2
	mov	edx, DWORD PTR $T224884[ebp]
	mov	DWORD PTR __Next$224991[ebp], edx
	jmp	SHORT $LN63@Buffered_m@2
$LN62@Buffered_m@2:
	mov	eax, DWORD PTR __Next$224991[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$224991[ebp], eax
$LN63@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$224991[ebp]
	cmp	ecx, DWORD PTR $T224884[ebp+8]
	je	SHORT $LN61@Buffered_m@2
	jmp	SHORT $LN62@Buffered_m@2
$LN61@Buffered_m@2:
	mov	edx, DWORD PTR $T224884[ebp]
	mov	DWORD PTR $T224988[ebp], edx
	mov	eax, DWORD PTR $T224988[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN65@Buffered_m@2:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T225003[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225007[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225012[ebp], cl
	movzx	edx, BYTE PTR $T225012[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225003[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225007[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
	add	esp, 24					; 00000018H

; 2775 : 		}
; 2776 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	edx, DWORD PTR __Count2$[ebp]
	cmp	edx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@2

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$218882[ebp], eax
	mov	DWORD PTR __Count2n$218883[ebp], 0

; 2784 : 			_Firstn = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$218880[ebp], eax

; 2785 : 			std::advance(_Firstn, _Count1n);

	mov	ecx, DWORD PTR __Count1n$218882[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Firstn$218880[ebp]
	mov	DWORD PTR __Firstn$218880[ebp], ecx

; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	mov	edx, DWORD PTR __Firstn$218880[ebp]
	mov	DWORD PTR $T225039[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T225038[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T225039[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T225038[ebp]
	push	eax
	call	??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T225038[ebp], eax
	mov	ecx, DWORD PTR $T225038[ebp]
	mov	DWORD PTR __Lastn$218881[ebp], ecx

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T225057[ebp], edx
	mov	eax, DWORD PTR __Lastn$218881[ebp]
	sub	eax, DWORD PTR $T225057[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count2n$218883[ebp]
	mov	DWORD PTR __Count2n$218883[ebp], eax

; 2788 : 			}
; 2789 : 		else

	jmp	$LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$218882[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$218883[ebp], eax

; 2792 : 			_Lastn = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$218881[ebp], edx

; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Count2n$218883[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Lastn$218881[ebp]
	mov	DWORD PTR __Lastn$218881[ebp], eax

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	ecx, DWORD PTR __Lastn$218881[ebp]
	mov	DWORD PTR $T225123[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225122[ebp], edx
	push	0
	mov	eax, DWORD PTR $T225123[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225122[ebp]
	push	edx
	call	??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T225122[ebp], eax
	mov	eax, DWORD PTR $T225122[ebp]
	mov	DWORD PTR __Firstn$218880[ebp], eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225141[ebp], ecx
	mov	eax, DWORD PTR __Firstn$218880[ebp]
	sub	eax, DWORD PTR $T225141[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count1n$218882[ebp]
	mov	DWORD PTR __Count1n$218882[ebp], eax
$LN1@Buffered_m@2:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$218883[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$218882[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$218881[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$218880[ebp]
	push	ecx
	call	??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$218900[ebp], eax

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$218883[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1n$218882[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$218900[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$218880[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 24					; 00000018H

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$[ebp]
	sub	eax, DWORD PTR __Count2n$218883[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$218882[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$218881[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$218900[ebp]
	push	ecx
	call	??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 24					; 00000018H
$LN10@Buffered_m@2:

; 2804 : 		}
; 2805 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Buffered_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
CONST	ENDS
;	COMDAT ??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z
_TEXT	SEGMENT
$T225196 = -20						; size = 4
$T225192 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z PROC ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T225196[ebp], 0
	lea	eax, DWORD PTR $T225196[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225192[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T225192[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T225192[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z
_TEXT	SEGMENT
$T225253 = -68						; size = 4
$T225252 = -64						; size = 4
$T225236 = -58						; size = 1
$T225235 = -57						; size = 1
$T225234 = -56						; size = 4
$T225233 = -52						; size = 4
$T225232 = -48						; size = 4
__Cat$225243 = -40					; size = 1
$T225241 = -39						; size = 1
$T225240 = -38						; size = 1
$T225239 = -37						; size = 1
__First1$218964 = -36					; size = 4
__Val$218954 = -32					; size = 24
__Next1$218953 = -8					; size = 4
__Next$218949 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$218949[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$218949[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Next$218949[ebp], edx
	mov	eax, DWORD PTR __Next$218949[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$218949[ebp]
	mov	DWORD PTR __Next1$218953[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$218949[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$218954[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$218954[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$218954[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Val$218954[ebp+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR __Val$218954[ebp+16], edx
	mov	eax, DWORD PTR __Next$218949[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Val$218954[ebp+20], ecx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$218954[ebp+20]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, DWORD PTR __Next1$218953[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next1$218953[ebp], eax
	mov	ecx, DWORD PTR __Next1$218953[ebp]
	mov	DWORD PTR $T225253[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225252[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T225239[ebp], al
	mov	cl, BYTE PTR __Cat$225243[ebp]
	mov	BYTE PTR $T225240[ebp], cl
	mov	dl, BYTE PTR $T225239[ebp]
	mov	BYTE PTR $T225236[ebp], dl
	mov	al, BYTE PTR $T225241[ebp]
	mov	BYTE PTR $T225235[ebp], al
	mov	ecx, DWORD PTR $T225253[ebp]
	mov	DWORD PTR $T225234[ebp], ecx
	mov	edx, DWORD PTR __Next$218949[ebp]
	mov	DWORD PTR $T225233[ebp], edx
	mov	eax, DWORD PTR $T225252[ebp]
	mov	DWORD PTR $T225232[ebp], eax
$LN22@Insertion_:
	mov	ecx, DWORD PTR $T225232[ebp]
	cmp	ecx, DWORD PTR $T225233[ebp]
	je	SHORT $LN15@Insertion_
	mov	edx, DWORD PTR $T225233[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR $T225233[ebp], edx
	mov	eax, DWORD PTR $T225234[ebp]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR $T225234[ebp], eax
	mov	ecx, DWORD PTR $T225233[ebp]
	mov	edx, DWORD PTR $T225234[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$218954[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$218954[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Val$218954[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$218954[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR __Val$218954[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR __Val$218954[ebp+20]
	mov	DWORD PTR [edx+20], ecx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	edx, DWORD PTR __Next1$218953[ebp]
	mov	DWORD PTR __First1$218964[ebp], edx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	eax, DWORD PTR __First1$218964[ebp]
	mov	DWORD PTR __Next1$218953[ebp], eax
$LN3@Insertion_:
	mov	ecx, DWORD PTR __First1$218964[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __First1$218964[ebp], ecx
	mov	edx, DWORD PTR __First1$218964[ebp]
	mov	eax, DWORD PTR __Val$218954[ebp+20]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	eax, DWORD PTR __First1$218964[ebp]
	mov	ecx, DWORD PTR __Next1$218953[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Next1$218953[ebp]
	mov	edx, DWORD PTR __Val$218954[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$218954[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$218954[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$218954[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR __Val$218954[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR __Val$218954[ebp+20]
	mov	DWORD PTR [ecx+20], eax
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z
_TEXT	SEGMENT
tv92 = -164						; size = 4
$T225413 = -160						; size = 4
__Next$225421 = -156					; size = 4
$T225271 = -24						; size = 4
$T225260 = -20						; size = 4
$T225259 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>, COMDAT

; 5252 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T225259[ebp], al
	movzx	ecx, BYTE PTR $T225259[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T225260[ebp], esp
	mov	DWORD PTR $T225271[ebp], ecx
	mov	edx, DWORD PTR $T225271[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T225271[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T225271[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T225271[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T225271[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T225271[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
	add	esp, 40					; 00000028H

; 5254 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$225421[ebp], edx
	jmp	SHORT $LN77@Unchecked_
$LN76@Unchecked_:
	mov	eax, DWORD PTR __Next$225421[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$225421[ebp], eax
$LN77@Unchecked_:
	mov	ecx, DWORD PTR __Next$225421[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN75@Unchecked_
	jmp	SHORT $LN76@Unchecked_
$LN75@Unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T225413[ebp], edx
	mov	eax, DWORD PTR $T225413[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@stdext@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
PUBLIC	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T225466 = -40						; size = 4
__Next$225474 = -36					; size = 4
$T225458 = -32						; size = 4
__Cat$225445 = -25					; size = 1
$T225440 = -24						; size = 4
$T225436 = -20						; size = 4
$T225435 = -15						; size = 1
$T225434 = -14						; size = 1
$T225433 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z PROC ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T225440[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T225433[ebp], al
	mov	cl, BYTE PTR __Cat$225445[ebp]
	mov	BYTE PTR $T225434[ebp], cl
	movzx	edx, BYTE PTR $T225433[ebp]
	push	edx
	movzx	eax, BYTE PTR $T225434[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T225435[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T225436[ebp], esp
	mov	DWORD PTR $T225458[ebp], edx
	mov	eax, DWORD PTR $T225458[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T225458[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T225458[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T225458[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T225458[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T225458[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T225440[ebp]
	or	ecx, 1
	mov	DWORD PTR $T225440[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$225474[ebp], edx
	jmp	SHORT $LN17@unchecked_
$LN16@unchecked_:
	mov	eax, DWORD PTR __Next$225474[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$225474[ebp], eax
$LN17@unchecked_:
	mov	ecx, DWORD PTR __Next$225474[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_
	jmp	SHORT $LN16@unchecked_
$LN15@unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T225466[ebp], edx
	mov	eax, DWORD PTR $T225466[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ENDP ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
PUBLIC	??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z
_TEXT	SEGMENT
tv178 = -260						; size = 4
tv177 = -256						; size = 4
tv174 = -252						; size = 4
tv173 = -248						; size = 4
$T225766 = -240						; size = 4
$T225752 = -233						; size = 1
$T225751 = -232						; size = 4
$T225756 = -225						; size = 1
$T225731 = -224						; size = 4
$T225730 = -220						; size = 4
$T225713 = -214						; size = 1
$T225712 = -213						; size = 1
$T225711 = -212						; size = 4
$T225710 = -208						; size = 4
__Cat$225720 = -200					; size = 1
$T225718 = -199						; size = 1
$T225717 = -198						; size = 1
$T225716 = -197						; size = 1
$T225691 = -196						; size = 4
$T225687 = -192						; size = 4
$T225683 = -188						; size = 4
$T225682 = -184						; size = 4
$T225666 = -178						; size = 1
$T225665 = -177						; size = 1
$T225664 = -176						; size = 4
$T225663 = -172						; size = 4
$T225662 = -168						; size = 4
__Cat$225674 = -160					; size = 1
$T225671 = -159						; size = 1
$T225670 = -158						; size = 1
$T225669 = -157						; size = 1
$T225633 = -156						; size = 4
__Next$225641 = -152					; size = 4
$T225625 = -148						; size = 4
$T225612 = -136						; size = 4
$T225611 = -132						; size = 4
$T225595 = -126						; size = 1
$T225594 = -125						; size = 1
$T225593 = -124						; size = 4
$T225592 = -120						; size = 4
$T225591 = -116						; size = 4
__Cat$225603 = -108					; size = 1
$T225600 = -107						; size = 1
$T225599 = -106						; size = 1
$T225598 = -105						; size = 1
$T225573 = -104						; size = 4
$T225569 = -100						; size = 4
$T225565 = -96						; size = 4
$T225564 = -92						; size = 4
$T225547 = -86						; size = 1
$T225546 = -85						; size = 1
$T225545 = -84						; size = 4
$T225544 = -80						; size = 4
__Cat$225554 = -72					; size = 1
$T225551 = -71						; size = 1
$T225550 = -70						; size = 1
$T225549 = -69						; size = 1
$T225514 = -68						; size = 4
__Next$225522 = -64					; size = 4
$T225506 = -60						; size = 4
$T225489 = -48						; size = 20
$T225488 = -28						; size = 4
$T225487 = -24						; size = 20
$T225486 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z PROC ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T225486[ebp], esp
	mov	DWORD PTR $T225506[ebp], eax
	mov	ecx, DWORD PTR $T225506[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T225506[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T225506[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T225506[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T225506[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T225506[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T225487[ebp]
	push	edx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv174[ebp], eax
	cmp	DWORD PTR $T225487[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T225487[ebp]
	mov	DWORD PTR __Next$225522[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$225522[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Next$225522[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$225522[ebp]
	cmp	edx, DWORD PTR $T225487[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T225487[ebp]
	mov	DWORD PTR $T225514[ebp], eax
	mov	ecx, DWORD PTR $T225514[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225565[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T225564[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225549[ebp], cl
	mov	dl, BYTE PTR __Cat$225554[ebp]
	mov	BYTE PTR $T225550[ebp], dl
	mov	al, BYTE PTR $T225549[ebp]
	mov	BYTE PTR $T225547[ebp], al
	mov	cl, BYTE PTR $T225551[ebp]
	mov	BYTE PTR $T225546[ebp], cl
	mov	edx, DWORD PTR $T225565[ebp]
	mov	DWORD PTR $T225545[ebp], edx
	mov	eax, DWORD PTR $T225564[ebp]
	mov	DWORD PTR $T225544[ebp], eax
	jmp	SHORT $LN38@Buffered_r
$LN37@Buffered_r:
	mov	ecx, DWORD PTR $T225545[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T225545[ebp], ecx
	mov	edx, DWORD PTR $T225544[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T225544[ebp], edx
$LN38@Buffered_r:
	mov	eax, DWORD PTR $T225544[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN30@Buffered_r
	mov	ecx, DWORD PTR $T225544[ebp]
	mov	edx, DWORD PTR $T225545[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	jmp	SHORT $LN37@Buffered_r
$LN30@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225569[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225573[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T225612[ebp], edx
	mov	eax, DWORD PTR $T225573[ebp]
	mov	DWORD PTR $T225611[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225598[ebp], cl
	mov	dl, BYTE PTR __Cat$225603[ebp]
	mov	BYTE PTR $T225599[ebp], dl
	mov	al, BYTE PTR $T225598[ebp]
	mov	BYTE PTR $T225595[ebp], al
	mov	cl, BYTE PTR $T225600[ebp]
	mov	BYTE PTR $T225594[ebp], cl
	mov	edx, DWORD PTR $T225612[ebp]
	mov	DWORD PTR $T225593[ebp], edx
	mov	eax, DWORD PTR $T225569[ebp]
	mov	DWORD PTR $T225592[ebp], eax
	mov	ecx, DWORD PTR $T225611[ebp]
	mov	DWORD PTR $T225591[ebp], ecx
$LN52@Buffered_r:
	mov	edx, DWORD PTR $T225591[ebp]
	cmp	edx, DWORD PTR $T225592[ebp]
	je	SHORT $LN45@Buffered_r
	mov	eax, DWORD PTR $T225592[ebp]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR $T225592[ebp], eax
	mov	ecx, DWORD PTR $T225593[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR $T225593[ebp], ecx
	mov	edx, DWORD PTR $T225592[ebp]
	mov	eax, DWORD PTR $T225593[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	jmp	SHORT $LN52@Buffered_r
$LN45@Buffered_r:
	mov	eax, DWORD PTR $T225593[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEHXZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T225488[ebp], esp
	mov	DWORD PTR $T225625[ebp], edx
	mov	eax, DWORD PTR $T225625[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T225625[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T225625[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T225625[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T225625[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T225625[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225489[ebp]
	push	ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv178[ebp], eax
	cmp	DWORD PTR $T225489[ebp], 0
	je	SHORT $LN68@Buffered_r
	mov	edx, DWORD PTR $T225489[ebp]
	mov	DWORD PTR __Next$225641[ebp], edx
	jmp	SHORT $LN66@Buffered_r
$LN65@Buffered_r:
	mov	eax, DWORD PTR __Next$225641[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$225641[ebp], eax
$LN66@Buffered_r:
	mov	ecx, DWORD PTR __Next$225641[ebp]
	cmp	ecx, DWORD PTR $T225489[ebp+8]
	je	SHORT $LN64@Buffered_r
	jmp	SHORT $LN65@Buffered_r
$LN64@Buffered_r:
	mov	edx, DWORD PTR $T225489[ebp]
	mov	DWORD PTR $T225633[ebp], edx
	mov	eax, DWORD PTR $T225633[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T225683[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225682[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T225669[ebp], al
	mov	cl, BYTE PTR __Cat$225674[ebp]
	mov	BYTE PTR $T225670[ebp], cl
	mov	dl, BYTE PTR $T225669[ebp]
	mov	BYTE PTR $T225666[ebp], dl
	mov	al, BYTE PTR $T225671[ebp]
	mov	BYTE PTR $T225665[ebp], al
	mov	ecx, DWORD PTR $T225683[ebp]
	mov	DWORD PTR $T225664[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T225663[ebp], edx
	mov	eax, DWORD PTR $T225682[ebp]
	mov	DWORD PTR $T225662[ebp], eax
$LN81@Buffered_r:
	mov	ecx, DWORD PTR $T225662[ebp]
	cmp	ecx, DWORD PTR $T225663[ebp]
	je	SHORT $LN74@Buffered_r
	mov	edx, DWORD PTR $T225663[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR $T225663[ebp], edx
	mov	eax, DWORD PTR $T225664[ebp]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR $T225664[ebp], eax
	mov	ecx, DWORD PTR $T225663[ebp]
	mov	edx, DWORD PTR $T225664[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	jmp	SHORT $LN81@Buffered_r
$LN74@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225687[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225691[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225731[ebp], edx
	mov	eax, DWORD PTR $T225691[ebp]
	mov	DWORD PTR $T225730[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225716[ebp], cl
	mov	dl, BYTE PTR __Cat$225720[ebp]
	mov	BYTE PTR $T225717[ebp], dl
	mov	al, BYTE PTR $T225716[ebp]
	mov	BYTE PTR $T225713[ebp], al
	mov	cl, BYTE PTR $T225718[ebp]
	mov	BYTE PTR $T225712[ebp], cl
	mov	edx, DWORD PTR $T225731[ebp]
	mov	DWORD PTR $T225711[ebp], edx
	mov	eax, DWORD PTR $T225730[ebp]
	mov	DWORD PTR $T225710[ebp], eax
	jmp	SHORT $LN96@Buffered_r
$LN95@Buffered_r:
	mov	ecx, DWORD PTR $T225711[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T225711[ebp], ecx
	mov	edx, DWORD PTR $T225710[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T225710[ebp], edx
$LN96@Buffered_r:
	mov	eax, DWORD PTR $T225710[ebp]
	cmp	eax, DWORD PTR $T225687[ebp]
	je	SHORT $LN88@Buffered_r
	mov	ecx, DWORD PTR $T225710[ebp]
	mov	edx, DWORD PTR $T225711[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	jmp	SHORT $LN95@Buffered_r
$LN88@Buffered_r:
	mov	eax, DWORD PTR $T225711[ebp]
	jmp	SHORT $LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	SHORT $LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225766[ebp], edx
	mov	eax, DWORD PTR $T225766[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	dl, BYTE PTR $T225756[ebp]
	mov	BYTE PTR $T225752[ebp], dl
	mov	eax, DWORD PTR $T225766[ebp]
	mov	DWORD PTR $T225751[ebp], eax
	push	0
	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T225751[ebp]
	push	eax
	call	??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN112@Buffered_r:
	mov	ecx, DWORD PTR __Count2$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 2701 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@00HHAAV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@@Z ENDP ; std::_Buffered_rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv183 = -180						; size = 4
tv182 = -176						; size = 4
tv179 = -172						; size = 4
tv178 = -168						; size = 4
tv174 = -164						; size = 4
tv173 = -160						; size = 4
$T225945 = -156						; size = 4
__Next$225948 = -152					; size = 4
$T225926 = -148						; size = 4
__Next$225929 = -144					; size = 4
$T225918 = -140						; size = 4
$T225881 = -132						; size = 4
__Next$225884 = -128					; size = 4
$T225873 = -124						; size = 4
$T225853 = -120						; size = 4
__Next$225856 = -116					; size = 4
$T225845 = -112						; size = 4
$T225841 = -108						; size = 4
$T225791 = -100						; size = 20
$T225790 = -80						; size = 4
$T225789 = -76						; size = 20
$T225788 = -56						; size = 4
$T225787 = -52						; size = 20
$T225786 = -32						; size = 4
__Mid$219356 = -28					; size = 4
__Mid2$219339 = -24					; size = 4
__Mid1$219338 = -20					; size = 4
__Chunk2$219334 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$219334[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$219334[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$219334[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$219338[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Mid1$219338[ebp]
	mov	DWORD PTR __Mid1$219338[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$219338[ebp]
	mov	DWORD PTR __Mid2$219339[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Mid2$219339[ebp]
	mov	DWORD PTR __Mid2$219339[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T225786[ebp], esp
	mov	DWORD PTR $T225841[ebp], ecx
	mov	edx, DWORD PTR $T225841[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T225841[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T225841[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T225841[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T225841[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T225841[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid2$219339[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$219338[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$219338[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225787[ebp]
	push	ecx
	call	??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv174[ebp], eax
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T225845[ebp], edx
	mov	eax, DWORD PTR $T225845[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T225787[ebp], 0
	je	SHORT $LN37@Chunked_me
	mov	edx, DWORD PTR $T225787[ebp]
	mov	DWORD PTR __Next$225856[ebp], edx
	jmp	SHORT $LN35@Chunked_me
$LN34@Chunked_me:
	mov	eax, DWORD PTR __Next$225856[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$225856[ebp], eax
$LN35@Chunked_me:
	mov	ecx, DWORD PTR __Next$225856[ebp]
	cmp	ecx, DWORD PTR $T225787[ebp+8]
	je	SHORT $LN33@Chunked_me
	jmp	SHORT $LN34@Chunked_me
$LN33@Chunked_me:
	mov	edx, DWORD PTR $T225787[ebp]
	mov	DWORD PTR $T225853[ebp], edx
	mov	eax, DWORD PTR $T225853[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me:

; 3297 : 		_First = _Mid2;

	mov	ecx, DWORD PTR __Mid2$219339[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 3298 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	edx, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T225788[ebp], esp
	mov	DWORD PTR $T225873[ebp], eax
	mov	ecx, DWORD PTR $T225873[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T225873[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T225873[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T225873[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T225873[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T225873[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225789[ebp]
	push	ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR $T225789[ebp], 0
	je	SHORT $LN51@Chunked_me
	mov	edx, DWORD PTR $T225789[ebp]
	mov	DWORD PTR __Next$225884[ebp], edx
	jmp	SHORT $LN49@Chunked_me
$LN48@Chunked_me:
	mov	eax, DWORD PTR __Next$225884[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$225884[ebp], eax
$LN49@Chunked_me:
	mov	ecx, DWORD PTR __Next$225884[ebp]
	cmp	ecx, DWORD PTR $T225789[ebp+8]
	je	SHORT $LN47@Chunked_me
	jmp	SHORT $LN48@Chunked_me
$LN47@Chunked_me:
	mov	edx, DWORD PTR $T225789[ebp]
	mov	DWORD PTR $T225881[ebp], edx
	mov	eax, DWORD PTR $T225881[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me:

; 3302 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$219356[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Mid$219356[ebp]
	mov	DWORD PTR __Mid$219356[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T225790[ebp], esp
	mov	DWORD PTR $T225918[ebp], eax
	mov	ecx, DWORD PTR $T225918[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T225918[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T225918[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T225918[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T225918[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T225918[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$219356[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$219356[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T225791[ebp]
	push	eax
	call	??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR $T225791[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	ecx, DWORD PTR $T225791[ebp]
	mov	DWORD PTR __Next$225929[ebp], ecx
	jmp	SHORT $LN69@Chunked_me
$LN68@Chunked_me:
	mov	edx, DWORD PTR __Next$225929[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Next$225929[ebp], edx
$LN69@Chunked_me:
	mov	eax, DWORD PTR __Next$225929[ebp]
	cmp	eax, DWORD PTR $T225791[ebp+8]
	je	SHORT $LN67@Chunked_me
	jmp	SHORT $LN68@Chunked_me
$LN67@Chunked_me:
	mov	ecx, DWORD PTR $T225791[ebp]
	mov	DWORD PTR $T225926[ebp], ecx
	mov	edx, DWORD PTR $T225926[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3308 : 		}
; 3309 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$225948[ebp], eax
	jmp	SHORT $LN79@Chunked_me
$LN78@Chunked_me:
	mov	ecx, DWORD PTR __Next$225948[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Next$225948[ebp], ecx
$LN79@Chunked_me:
	mov	edx, DWORD PTR __Next$225948[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me
	jmp	SHORT $LN78@Chunked_me
$LN77@Chunked_me:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T225945[ebp], eax
	mov	ecx, DWORD PTR $T225945[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T226230 = -176						; size = 4
$T226229 = -172						; size = 4
$T226228 = -168						; size = 4
$T226227 = -164						; size = 4
$T226223 = -104						; size = 1
$T226222 = -103						; size = 1
$T226111 = -100						; size = 4
$T226110 = -96						; size = 4
$T226093 = -90						; size = 1
$T226092 = -89						; size = 1
$T226091 = -88						; size = 4
$T226090 = -84						; size = 4
__Cat$226100 = -76					; size = 1
$T226098 = -75						; size = 1
$T226097 = -74						; size = 1
$T226096 = -73						; size = 1
$T226071 = -72						; size = 4
$T226070 = -68						; size = 4
$T226069 = -64						; size = 4
$T226068 = -60						; size = 4
$T226067 = -56						; size = 4
$T226063 = -22						; size = 1
$T226062 = -21						; size = 1
__Mid$219368 = -16					; size = 4
__Mid2$219365 = -12					; size = 4
__Mid1$219364 = -8					; size = 4
__Chunk2$219360 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$219360[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$219360[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$219360[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$219364[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Mid1$219364[ebp]
	mov	DWORD PTR __Mid1$219364[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$219364[ebp]
	mov	DWORD PTR __Mid2$219365[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Mid2$219365[ebp]
	mov	DWORD PTR __Mid2$219365[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226071[ebp], ecx
	mov	edx, DWORD PTR __Mid2$219365[ebp]
	mov	DWORD PTR $T226070[ebp], edx
	mov	eax, DWORD PTR __Mid1$219364[ebp]
	mov	DWORD PTR $T226069[ebp], eax
	mov	ecx, DWORD PTR __Mid1$219364[ebp]
	mov	DWORD PTR $T226068[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226067[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T226062[ebp], al
	movzx	ecx, BYTE PTR $T226062[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T226063[ebp]
	push	edx
	mov	eax, DWORD PTR $T226071[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226070[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226069[ebp]
	push	edx
	mov	eax, DWORD PTR $T226068[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226067[ebp]
	push	ecx
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], eax

; 3297 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$219365[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3298 : 		}

	jmp	$LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226111[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226110[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T226096[ebp], al
	mov	cl, BYTE PTR __Cat$226100[ebp]
	mov	BYTE PTR $T226097[ebp], cl
	mov	dl, BYTE PTR $T226096[ebp]
	mov	BYTE PTR $T226093[ebp], dl
	mov	al, BYTE PTR $T226098[ebp]
	mov	BYTE PTR $T226092[ebp], al
	mov	ecx, DWORD PTR $T226111[ebp]
	mov	DWORD PTR $T226091[ebp], ecx
	mov	edx, DWORD PTR $T226110[ebp]
	mov	DWORD PTR $T226090[ebp], edx
	jmp	SHORT $LN53@Chunked_me@2
$LN52@Chunked_me@2:
	mov	eax, DWORD PTR $T226091[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T226091[ebp], eax
	mov	ecx, DWORD PTR $T226090[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T226090[ebp], ecx
$LN53@Chunked_me@2:
	mov	edx, DWORD PTR $T226090[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN45@Chunked_me@2
	mov	eax, DWORD PTR $T226090[ebp]
	mov	ecx, DWORD PTR $T226091[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	jmp	SHORT $LN52@Chunked_me@2
$LN45@Chunked_me@2:

; 3302 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$219368[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Mid$219368[ebp]
	mov	DWORD PTR __Mid$219368[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226230[ebp], eax
	mov	ecx, DWORD PTR __Mid$219368[ebp]
	mov	DWORD PTR $T226229[ebp], ecx
	mov	edx, DWORD PTR __Mid$219368[ebp]
	mov	DWORD PTR $T226228[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226227[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226222[ebp], cl
	movzx	edx, BYTE PTR $T226222[ebp]
	push	edx
	movzx	eax, BYTE PTR $T226223[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226230[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T226229[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226228[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226227[ebp]
	push	edx
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN6@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T226282 = -40						; size = 4
__Next$226285 = -36					; size = 4
$T226235 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T226235[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T226235[ebp]
	or	eax, 1
	mov	DWORD PTR $T226235[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN34@Copy_opt
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$226285[ebp], ecx
	jmp	SHORT $LN32@Copy_opt
$LN31@Copy_opt:
	mov	edx, DWORD PTR __Next$226285[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Next$226285[ebp], edx
$LN32@Copy_opt:
	mov	eax, DWORD PTR __Next$226285[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN30@Copy_opt
	jmp	SHORT $LN31@Copy_opt
$LN30@Copy_opt:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226282[ebp], ecx
	mov	edx, DWORD PTR $T226282[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T226384 = -56						; size = 4
$T226383 = -52						; size = 4
$T226366 = -46						; size = 1
$T226365 = -45						; size = 1
$T226364 = -44						; size = 4
$T226363 = -40						; size = 4
__Cat$226373 = -32					; size = 1
$T226370 = -31						; size = 1
$T226369 = -30						; size = 1
$T226368 = -29						; size = 1
$T226344 = -28						; size = 4
$T226343 = -24						; size = 4
$T226326 = -18						; size = 1
$T226325 = -17						; size = 1
$T226324 = -16						; size = 4
$T226323 = -12						; size = 4
__Cat$226333 = -4					; size = 1
$T226330 = -3						; size = 1
$T226329 = -2						; size = 1
$T226328 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	$LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	$LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+20]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+20]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First2$[ebp], eax

; 2516 : 		else

	jmp	SHORT $LN1@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge:
	jmp	$LN4@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226344[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T226343[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T226328[ebp], dl
	mov	al, BYTE PTR __Cat$226333[ebp]
	mov	BYTE PTR $T226329[ebp], al
	mov	cl, BYTE PTR $T226328[ebp]
	mov	BYTE PTR $T226326[ebp], cl
	mov	dl, BYTE PTR $T226330[ebp]
	mov	BYTE PTR $T226325[ebp], dl
	mov	eax, DWORD PTR $T226344[ebp]
	mov	DWORD PTR $T226324[ebp], eax
	mov	ecx, DWORD PTR $T226343[ebp]
	mov	DWORD PTR $T226323[ebp], ecx
	jmp	SHORT $LN18@Merge
$LN17@Merge:
	mov	edx, DWORD PTR $T226324[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR $T226324[ebp], edx
	mov	eax, DWORD PTR $T226323[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T226323[ebp], eax
$LN18@Merge:
	mov	ecx, DWORD PTR $T226323[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN10@Merge
	mov	edx, DWORD PTR $T226323[ebp]
	mov	eax, DWORD PTR $T226324[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	jmp	SHORT $LN17@Merge
$LN10@Merge:
	mov	eax, DWORD PTR $T226324[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226384[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T226383[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T226368[ebp], al
	mov	cl, BYTE PTR __Cat$226373[ebp]
	mov	BYTE PTR $T226369[ebp], cl
	mov	dl, BYTE PTR $T226368[ebp]
	mov	BYTE PTR $T226366[ebp], dl
	mov	al, BYTE PTR $T226370[ebp]
	mov	BYTE PTR $T226365[ebp], al
	mov	ecx, DWORD PTR $T226384[ebp]
	mov	DWORD PTR $T226364[ebp], ecx
	mov	edx, DWORD PTR $T226383[ebp]
	mov	DWORD PTR $T226363[ebp], edx
	jmp	SHORT $LN29@Merge
$LN28@Merge:
	mov	eax, DWORD PTR $T226364[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T226364[ebp], eax
	mov	ecx, DWORD PTR $T226363[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T226363[ebp], ecx
$LN29@Merge:
	mov	edx, DWORD PTR $T226363[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN21@Merge
	mov	eax, DWORD PTR $T226363[ebp]
	mov	ecx, DWORD PTR $T226364[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	jmp	SHORT $LN28@Merge
$LN21@Merge:
	mov	eax, DWORD PTR $T226364[ebp]

; 2521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T226464 = -64						; size = 4
$T226463 = -60						; size = 4
$T226447 = -54						; size = 1
$T226446 = -53						; size = 1
$T226445 = -52						; size = 4
$T226444 = -48						; size = 4
$T226443 = -44						; size = 4
__Cat$226455 = -36					; size = 1
$T226451 = -35						; size = 1
$T226450 = -34						; size = 1
$T226449 = -33						; size = 1
$T226425 = -32						; size = 4
$T226424 = -28						; size = 4
$T226408 = -22						; size = 1
$T226407 = -21						; size = 1
$T226406 = -20						; size = 4
$T226405 = -16						; size = 4
$T226404 = -12						; size = 4
__Cat$226415 = -4					; size = 1
$T226412 = -3						; size = 1
$T226411 = -2						; size = 1
$T226410 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
$LN8@Merge_back:

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	$LN6@Merge_back

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226425[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T226424[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T226410[ebp], al
	mov	cl, BYTE PTR __Cat$226415[ebp]
	mov	BYTE PTR $T226411[ebp], cl
	mov	dl, BYTE PTR $T226410[ebp]
	mov	BYTE PTR $T226408[ebp], dl
	mov	al, BYTE PTR $T226412[ebp]
	mov	BYTE PTR $T226407[ebp], al
	mov	ecx, DWORD PTR $T226425[ebp]
	mov	DWORD PTR $T226406[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T226405[ebp], edx
	mov	eax, DWORD PTR $T226424[ebp]
	mov	DWORD PTR $T226404[ebp], eax
$LN18@Merge_back:
	mov	ecx, DWORD PTR $T226404[ebp]
	cmp	ecx, DWORD PTR $T226405[ebp]
	je	SHORT $LN11@Merge_back
	mov	edx, DWORD PTR $T226405[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR $T226405[ebp], edx
	mov	eax, DWORD PTR $T226406[ebp]
	sub	eax, 24					; 00000018H
	mov	DWORD PTR $T226406[ebp], eax
	mov	ecx, DWORD PTR $T226405[ebp]
	mov	edx, DWORD PTR $T226406[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx
	jmp	SHORT $LN18@Merge_back
$LN11@Merge_back:
	mov	eax, DWORD PTR $T226406[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	jne	$LN4@Merge_back

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226464[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T226463[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T226449[ebp], dl
	mov	al, BYTE PTR __Cat$226455[ebp]
	mov	BYTE PTR $T226450[ebp], al
	mov	cl, BYTE PTR $T226449[ebp]
	mov	BYTE PTR $T226447[ebp], cl
	mov	dl, BYTE PTR $T226451[ebp]
	mov	BYTE PTR $T226446[ebp], dl
	mov	eax, DWORD PTR $T226464[ebp]
	mov	DWORD PTR $T226445[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T226444[ebp], ecx
	mov	edx, DWORD PTR $T226463[ebp]
	mov	DWORD PTR $T226443[ebp], edx
$LN28@Merge_back:
	mov	eax, DWORD PTR $T226443[ebp]
	cmp	eax, DWORD PTR $T226444[ebp]
	je	SHORT $LN21@Merge_back
	mov	ecx, DWORD PTR $T226444[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR $T226444[ebp], ecx
	mov	edx, DWORD PTR $T226445[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR $T226445[ebp], edx
	mov	eax, DWORD PTR $T226444[ebp]
	mov	ecx, DWORD PTR $T226445[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	jmp	SHORT $LN28@Merge_back
$LN21@Merge_back:
	mov	eax, DWORD PTR $T226445[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN4@Merge_back:

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR __Last2$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	edx, DWORD PTR [eax+20]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+20]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge_back

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Last2$[ebp], ecx

; 2718 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Last1$[ebp], ecx
$LN5@Merge_back:
	jmp	$LN8@Merge_back
$LN9@Merge_back:

; 2720 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@PAU12@@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z
_TEXT	SEGMENT
$T226487 = -20						; size = 4
__Count2$219418 = -12					; size = 4
__Mid$219419 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z PROC ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2255 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226487[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T226487[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$219418[ebp], eax

; 2260 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$219419[ebp], edx

; 2261 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$219418[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Mid$219419[ebp]
	mov	DWORD PTR __Mid$219419[ebp], eax

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	ecx, DWORD PTR __Mid$219419[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$219419[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Mid$219419[ebp], eax
	mov	ecx, DWORD PTR __Mid$219419[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$219418[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$219418[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Lower_boun:

; 2268 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2269 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2270 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ENDP ; std::_Lower_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z
_TEXT	SEGMENT
$T226527 = -20						; size = 4
__Count2$219427 = -12					; size = 4
__Mid$219428 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z PROC ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2327 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226527[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T226527[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$219427[ebp], eax

; 2331 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$219428[ebp], edx

; 2332 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$219427[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Mid$219428[ebp]
	mov	DWORD PTR __Mid$219428[ebp], eax

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR __Mid$219428[ebp]
	mov	eax, DWORD PTR [ecx+20]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+20]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$219428[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Mid$219428[ebp], eax
	mov	ecx, DWORD PTR __Mid$219428[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$219427[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$219427[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Upper_boun:

; 2339 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2340 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2341 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@U12@H@std@@YAPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@0ABU12@PAH@Z ENDP ; std::_Upper_bound<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z
_TEXT	SEGMENT
tv133 = -24						; size = 4
_this$ = -20						; size = 4
$T226564 = -16						; size = 4
$T226563 = -12						; size = 4
__Vptr$226572 = -8					; size = 4
__Ptr$219485 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z PROC ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@2

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	$LN1@operator@2
$LN2@operator@2:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$219485[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$219485[ebp]
	mov	DWORD PTR __Vptr$226572[ebp], edx
	mov	eax, DWORD PTR __Vptr$226572[ebp]
	mov	DWORD PTR $T226564[ebp], eax
	cmp	DWORD PTR $T226564[ebp], 0
	je	SHORT $LN7@operator@2
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T226564[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T226564[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR $T226564[ebp]
	mov	DWORD PTR tv133[ebp], edx
	jmp	SHORT $LN8@operator@2
$LN7@operator@2:
	mov	DWORD PTR tv133[ebp], 0
$LN8@operator@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T226563[ebp], eax

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], ecx
$LN1@operator@2:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ENDP ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
_TEXT	ENDS
PUBLIC	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z$0
__ehfuncinfo$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv132 = -44						; size = 4
$T226603 = -40						; size = 4
__Next$226611 = -36					; size = 4
$T226595 = -32						; size = 4
$T226581 = -24						; size = 4
$T226577 = -20						; size = 4
$T226576 = -14						; size = 1
$T226575 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z PROC ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T226581[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T226575[ebp], al
	movzx	ecx, BYTE PTR $T226575[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T226576[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T226577[ebp], esp
	mov	DWORD PTR $T226595[ebp], eax
	mov	ecx, DWORD PTR $T226595[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T226595[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T226595[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T226595[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T226595[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T226595[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR $T226581[ebp]
	or	ecx, 1
	mov	DWORD PTR $T226581[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@2
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$226611[ebp], edx
	jmp	SHORT $LN15@unchecked_@2
$LN14@unchecked_@2:
	mov	eax, DWORD PTR __Next$226611[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$226611[ebp], eax
$LN15@unchecked_@2:
	mov	ecx, DWORD PTR __Next$226611[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@2
	jmp	SHORT $LN14@unchecked_@2
$LN13@unchecked_@2:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226603[ebp], edx
	mov	eax, DWORD PTR $T226603[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V12@@Z ENDP ; stdext::unchecked_merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -120						; size = 4
tv163 = -116						; size = 4
tv159 = -112						; size = 4
tv158 = -108						; size = 4
$T226741 = -104						; size = 4
__Next$226749 = -100					; size = 4
$T226733 = -96						; size = 4
$T226713 = -92						; size = 4
__Next$226721 = -88					; size = 4
$T226705 = -84						; size = 4
$T226701 = -80						; size = 4
$T226631 = -44						; size = 4
$T226625 = -40						; size = 4
$T226624 = -36						; size = 20
$T226623 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T226631[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+20]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN33@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN33@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAEAAV01@ABUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@Z ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::operator=
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@2:
	jmp	SHORT $LN5@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T226623[ebp], esp
	mov	DWORD PTR $T226701[ebp], edx
	mov	eax, DWORD PTR $T226701[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T226701[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T226701[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T226701[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T226701[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T226701[ebp]
	mov	DWORD PTR tv158[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T226624[ebp]
	push	eax
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T226705[ebp], ecx
	mov	edx, DWORD PTR $T226705[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Dest$[ebp+16], eax
	cmp	DWORD PTR $T226624[ebp], 0
	je	SHORT $LN58@Merge@2
	mov	ecx, DWORD PTR $T226624[ebp]
	mov	DWORD PTR __Next$226721[ebp], ecx
	jmp	SHORT $LN56@Merge@2
$LN55@Merge@2:
	mov	edx, DWORD PTR __Next$226721[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Next$226721[ebp], edx
$LN56@Merge@2:
	mov	eax, DWORD PTR __Next$226721[ebp]
	cmp	eax, DWORD PTR $T226624[ebp+8]
	je	SHORT $LN54@Merge@2
	jmp	SHORT $LN55@Merge@2
$LN54@Merge@2:
	mov	ecx, DWORD PTR $T226624[ebp]
	mov	DWORD PTR $T226713[ebp], ecx
	mov	edx, DWORD PTR $T226713[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN58@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T226625[ebp], esp
	mov	DWORD PTR $T226733[ebp], eax
	mov	ecx, DWORD PTR $T226733[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T226733[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T226733[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T226733[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T226733[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T226733[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$unchecked_copy@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@@stdext@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@0V12@@Z ; stdext::unchecked_copy<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv164[ebp], eax
	mov	edx, DWORD PTR $T226631[ebp]
	or	edx, 1
	mov	DWORD PTR $T226631[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN72@Merge@2
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$226749[ebp], eax
	jmp	SHORT $LN70@Merge@2
$LN69@Merge@2:
	mov	ecx, DWORD PTR __Next$226749[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Next$226749[ebp], ecx
$LN70@Merge@2:
	mov	edx, DWORD PTR __Next$226749[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN68@Merge@2
	jmp	SHORT $LN69@Merge@2
$LN68@Merge@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T226741[ebp], eax
	mov	ecx, DWORD PTR $T226741[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN72@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@QAE@XZ ; std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>::~_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
__ehhandler$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@PAU12@V?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@std@@Uforward_iterator_tag@4@@std@@YA?AV?$_Temp_iterator@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@@0@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,std::_Temp_iterator<CvWeightedVector<BuilderDirective,100,1>::WeightedElement>,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z
_TEXT	SEGMENT
tv129 = -60						; size = 4
tv84 = -56						; size = 4
__Hole$219609 = -52					; size = 4
__Holeval$219611 = -48					; size = 24
__Next1$219612 = -24					; size = 4
__Next$219610 = -20					; size = 4
__Tmp$219604 = -16					; size = 4
__Factor$219600 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z PROC ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR __Count$[ebp], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$219600[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$219600[ebp], 0
	je	SHORT $LN7@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$219600[ebp]
	mov	DWORD PTR __Tmp$219604[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$219600[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$219604[ebp]
	mov	DWORD PTR __Factor$219600[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate
$LN7@Rotate:

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	cmp	DWORD PTR __Count$[ebp], eax
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Hole$219609[ebp], eax

; 1695 : 			_RanIt _Next = _Hole;

	mov	ecx, DWORD PTR __Hole$219609[ebp]
	mov	DWORD PTR __Next$219610[ebp], ecx

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	edx, DWORD PTR __Hole$219609[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Holeval$219611[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Holeval$219611[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Holeval$219611[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Holeval$219611[ebp+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR __Holeval$219611[ebp+16], edx
	mov	eax, DWORD PTR __Hole$219609[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Holeval$219611[ebp+20], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	edx, DWORD PTR __Shift$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Next$219610[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN11@Rotate
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	ecx, DWORD PTR __Shift$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Next$219610[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN12@Rotate:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Next1$219612[ebp], edx
$LN2@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	mov	eax, DWORD PTR __Next1$219612[ebp]
	cmp	eax, DWORD PTR __Hole$219609[ebp]
	je	SHORT $LN1@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	ecx, DWORD PTR __Next1$219612[ebp]
	mov	edx, DWORD PTR __Next$219610[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [edx+20], ecx

; 1701 : 				_Next = _Next1;

	mov	edx, DWORD PTR __Next1$219612[ebp]
	mov	DWORD PTR __Next$219610[ebp], edx

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$219612[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	cmp	DWORD PTR __Shift$[ebp], eax
	jge	SHORT $LN13@Rotate
	mov	edx, DWORD PTR __Shift$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Next1$219612[ebp]
	mov	DWORD PTR tv129[ebp], edx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$219612[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	sub	edx, eax
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv129[ebp], edx
$LN14@Rotate:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR __Next1$219612[ebp], eax

; 1704 : 				}

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Next$219610[ebp]
	mov	edx, DWORD PTR __Holeval$219611[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Holeval$219611[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Holeval$219611[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Holeval$219611[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR __Holeval$219611[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR __Holeval$219611[ebp+20]
	mov	DWORD PTR [ecx+20], eax

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@PAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@00PAH0@Z ENDP ; std::_Rotate<CvWeightedVector<BuilderDirective,100,1>::WeightedElement *,int,CvWeightedVector<BuilderDirective,100,1>::WeightedElement>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T226798 = -2092					; size = 4
$T226797 = -2088					; size = 4
$T226796 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T226796[ebp], eax
	mov	ecx, DWORD PTR $T226796[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T226797[ebp], eax
	mov	eax, DWORD PTR $T226797[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T226798[ebp], eax
	mov	ecx, DWORD PTR $T226798[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T226809 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226809[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T226809[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T226815 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226815[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T226815[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T226829 = -8						; size = 4
$T226825 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T226825[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T226825[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T226829[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T226829[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.h
_TEXT	ENDS
;	COMDAT ??0BuilderDirective@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BuilderDirective@@QAE@XZ PROC			; BuilderDirective::BuilderDirective, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 6
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], -1
	or	eax, -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+12], ax
	or	edx, -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+14], dx
	or	ecx, -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+16], cx

; 47   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BuilderDirective@@QAE@XZ ENDP			; BuilderDirective::BuilderDirective
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
EXTRN	_atexit:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ
text$yc	SEGMENT
??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ PROC ; `dynamic initializer for 'CvBuilderTaskingAI::m_aDirectives'', COMDAT

; 22   : CvWeightedVector<BuilderDirective, 100, true> CvBuilderTaskingAI::m_aDirectives;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
	push	OFFSET ??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aDirectives''
	call	_atexit
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ENDP ; `dynamic initializer for 'CvBuilderTaskingAI::m_aDirectives''
text$yc	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T226866 = -20						; size = 4
_pRet$226862 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 100			; 00000064H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226866[ebp], edx
	cmp	DWORD PTR $T226866[ebp], 100		; 00000064H
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T226866[ebp]
	imul	eax, 24					; 00000018H
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$226862[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T226866[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$226862[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 100			; 00000064H
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$226862[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvbuildertaskingai.cpp
;	COMDAT ??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ
text$yc	SEGMENT
??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ PROC ; `dynamic initializer for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots'', COMDAT

; 23   : FStaticVector<int, SAFE_ESTIMATE_NUM_EXTRA_PLOTS, true, c_eCiv5GameplayDLL, 0> CvBuilderTaskingAI::m_aiNonTerritoryPlots; // plots that we need to evaluate that are outside of our territory

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
	push	OFFSET ??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots''
	call	_atexit
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots''
text$yc	ENDS
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T226901 = -20						; size = 4
_pRet$226897 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226901[ebp], edx
	cmp	DWORD PTR $T226901[ebp], 64		; 00000040H
	jbe	SHORT $LN7@FStaticVec@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T226901[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$226897[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T226901[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@4
$LN7@FStaticVec@4:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$226897[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 64			; 00000040H
$LN8@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$226897[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,64,1,297,0>::FStaticVector<int,64,1,297,0>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
; Function compile flags: /Odtp
;	COMDAT ??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ
text$yd	SEGMENT
??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aDirectives'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET ?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aDirectives''
text$yd	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T226965 = -24						; size = 4
$T226964 = -20						; size = 4
_i$226959 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226965[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226964[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@5
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@5
	mov	DWORD PTR _i$226959[ebp], 0
	jmp	SHORT $LN10@FStaticVec@5
$LN9@FStaticVec@5:
	mov	eax, DWORD PTR _i$226959[ebp]
	add	eax, 1
	mov	DWORD PTR _i$226959[ebp], eax
$LN10@FStaticVec@5:
	mov	ecx, DWORD PTR _i$226959[ebp]
	cmp	ecx, DWORD PTR $T226965[ebp]
	jae	SHORT $LN5@FStaticVec@5
	jmp	SHORT $LN9@FStaticVec@5
$LN5@FStaticVec@5:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T226964[ebp], edx
	je	SHORT $LN1@FStaticVec@5
	mov	eax, DWORD PTR $T226964[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@5:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@$0GE@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>::~FStaticVector<CvWeightedVector<BuilderDirective,100,1>::WeightedElement,100,1,0,0>
PUBLIC	??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
; Function compile flags: /Odtp
;	COMDAT ??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ
text$yd	SEGMENT
??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	ecx, OFFSET ?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
	call	??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??__F?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CvBuilderTaskingAI::m_aiNonTerritoryPlots''
text$yd	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T227028 = -24						; size = 4
$T227027 = -20						; size = 4
_i$227022 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ PROC	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227028[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227027[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@6
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@6
	mov	DWORD PTR _i$227022[ebp], 0
	jmp	SHORT $LN10@FStaticVec@6
$LN9@FStaticVec@6:
	mov	eax, DWORD PTR _i$227022[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227022[ebp], eax
$LN10@FStaticVec@6:
	mov	ecx, DWORD PTR _i$227022[ebp]
	cmp	ecx, DWORD PTR $T227028[ebp]
	jae	SHORT $LN5@FStaticVec@6
	jmp	SHORT $LN9@FStaticVec@6
$LN5@FStaticVec@6:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T227027[ebp], edx
	je	SHORT $LN1@FStaticVec@6
	mov	eax, DWORD PTR $T227027[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@6:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@QAE@XZ ENDP	; FStaticVector<int,64,1,297,0>::~FStaticVector<int,64,1,297,0>
PUBLIC	?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
PUBLIC	?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A ; CvBuilderTaskingAI::m_aDirectives
_BSS	SEGMENT
?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A DB 0110H DUP (?) ; CvBuilderTaskingAI::m_aiNonTerritoryPlots
?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A DB 0970H DUP (?) ; CvBuilderTaskingAI::m_aDirectives
_BSS	ENDS
CRT$XCU	SEGMENT
?m_aDirectives$initializer$@CvBuilderTaskingAI@@2P6AXXZA DD FLAT:??__E?m_aDirectives@CvBuilderTaskingAI@@2V?$CvWeightedVector@UBuilderDirective@@$0GE@$00@@A@@YAXXZ ; CvBuilderTaskingAI::m_aDirectives$initializer$
?m_aiNonTerritoryPlots$initializer$@CvBuilderTaskingAI@@2P6AXXZA DD FLAT:??__E?m_aiNonTerritoryPlots@CvBuilderTaskingAI@@2V?$FStaticVector@H$0EA@$00$0BCJ@$0A@@@A@@YAXXZ ; CvBuilderTaskingAI::m_aiNonTerritoryPlots$initializer$
CRT$XCU	ENDS
END
