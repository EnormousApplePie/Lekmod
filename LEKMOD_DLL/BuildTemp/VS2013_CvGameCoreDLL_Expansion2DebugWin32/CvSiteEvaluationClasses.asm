; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvSiteEvaluationClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??_7CvCitySiteEvaluator@@6B@			; CvCitySiteEvaluator::`vftable'
PUBLIC	??0CvCitySiteEvaluator@@QAE@XZ			; CvCitySiteEvaluator::CvCitySiteEvaluator
PUBLIC	?Init@CvCitySiteEvaluator@@UAEXXZ		; CvCitySiteEvaluator::Init
PUBLIC	?ComputeFlavorMultipliers@CvCitySiteEvaluator@@UAEXPAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeFlavorMultipliers
PUBLIC	?CanFound@CvCitySiteEvaluator@@UBE_NPAVCvPlot@@PBVCvPlayer@@_N@Z ; CvCitySiteEvaluator::CanFound
PUBLIC	?PlotFoundValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ; CvCitySiteEvaluator::PlotFoundValue
PUBLIC	?PlotFertilityValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@@Z ; CvCitySiteEvaluator::PlotFertilityValue
PUBLIC	?BestFoundValueForSpecificYield@CvCitySiteEvaluator@@UAEHPAVCvPlayer@@W4YieldTypes@@@Z ; CvCitySiteEvaluator::BestFoundValueForSpecificYield
PUBLIC	?ComputeFoodValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeFoodValue
PUBLIC	?ComputeHappinessValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeHappinessValue
PUBLIC	?ComputeProductionValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeProductionValue
PUBLIC	?ComputeGoldValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeGoldValue
PUBLIC	?ComputeScienceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeScienceValue
PUBLIC	?ComputeFaithValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeFaithValue
PUBLIC	?ComputeTradeableResourceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ; CvCitySiteEvaluator::ComputeTradeableResourceValue
PUBLIC	?ComputeStrategicValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@H@Z ; CvCitySiteEvaluator::ComputeStrategicValue
;	COMDAT ??_7CvCitySiteEvaluator@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvsiteevaluationclasses.cpp
CONST	SEGMENT
??_7CvCitySiteEvaluator@@6B@ DD FLAT:?Init@CvCitySiteEvaluator@@UAEXXZ ; CvCitySiteEvaluator::`vftable'
	DD	FLAT:?ComputeFlavorMultipliers@CvCitySiteEvaluator@@UAEXPAVCvPlayer@@@Z
	DD	FLAT:?CanFound@CvCitySiteEvaluator@@UBE_NPAVCvPlot@@PBVCvPlayer@@_N@Z
	DD	FLAT:?PlotFoundValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z
	DD	FLAT:?PlotFertilityValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@@Z
	DD	FLAT:?BestFoundValueForSpecificYield@CvCitySiteEvaluator@@UAEHPAVCvPlayer@@W4YieldTypes@@@Z
	DD	FLAT:?ComputeFoodValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeHappinessValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeProductionValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeGoldValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeScienceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeFaithValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeTradeableResourceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeStrategicValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@H@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvCitySiteEvaluator@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvCitySiteEvaluator@@QAE@XZ PROC			; CvCitySiteEvaluator::CvCitySiteEvaluator, COMDAT
; _this$ = ecx

; 24   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvCitySiteEvaluator@@6B@

; 25   : 	m_iExpansionIndex = 12;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 12			; 0000000cH

; 26   : 	m_iGrowthIndex = 13;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 13			; 0000000dH

; 27   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvCitySiteEvaluator@@QAE@XZ ENDP			; CvCitySiteEvaluator::CvCitySiteEvaluator
_TEXT	ENDS
PUBLIC	??1CvCitySiteEvaluator@@QAE@XZ			; CvCitySiteEvaluator::~CvCitySiteEvaluator
; Function compile flags: /Odtp
;	COMDAT ??1CvCitySiteEvaluator@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvCitySiteEvaluator@@QAE@XZ PROC			; CvCitySiteEvaluator::~CvCitySiteEvaluator, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvCitySiteEvaluator@@6B@

; 32   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvCitySiteEvaluator@@QAE@XZ ENDP			; CvCitySiteEvaluator::~CvCitySiteEvaluator
_TEXT	ENDS
PUBLIC	??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@		; `string'
PUBLIC	??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@	; `string'
PUBLIC	??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@		; `string'
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
;	COMDAT ??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@ DB 'FLAVOR_NAVAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
CONST	SEGMENT
??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@ DB 'FLAVOR_EXPANSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
CONST	SEGMENT
??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@ DB 'FLAVOR_GROWTH', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvsiteevaluationclasses.cpp
CONST	ENDS
;	COMDAT ?Init@CvCitySiteEvaluator@@UAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T223180 = -20						; size = 4
$T223176 = -16						; size = 4
$T223172 = -12						; size = 4
$T223168 = -8						; size = 4
$T223164 = -4						; size = 4
?Init@CvCitySiteEvaluator@@UAEXXZ PROC			; CvCitySiteEvaluator::Init, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 37   : 	// Set up city ring multipliers
; 38   : 	m_iRingModifier[0] = 1;   // Items under city get handled separately

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 1

; 39   : 	m_iRingModifier[1] = /*6*/ GC.getCITY_RING_1_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7232
	mov	DWORD PTR $T223164[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T223164[ebp]
	mov	DWORD PTR [edx+44], eax

; 40   : 	m_iRingModifier[2] = /*3*/ GC.getCITY_RING_2_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7236
	mov	DWORD PTR $T223168[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T223168[ebp]
	mov	DWORD PTR [edx+48], eax

; 41   : 	m_iRingModifier[3] = /*2*/ GC.getCITY_RING_3_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7240
	mov	DWORD PTR $T223172[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T223172[ebp]
	mov	DWORD PTR [edx+52], eax

; 42   : 	m_iRingModifier[4] = /*1*/ GC.getCITY_RING_4_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7244
	mov	DWORD PTR $T223176[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T223176[ebp]
	mov	DWORD PTR [edx+56], eax

; 43   : 	m_iRingModifier[5] = /*1*/ GC.getCITY_RING_5_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7248
	mov	DWORD PTR $T223180[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T223180[ebp]
	mov	DWORD PTR [edx+60], eax

; 44   : 	m_iRingModifier[6] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 45   : 	m_iRingModifier[7] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 46   : 
; 47   : 	m_iGrowthIndex = GC.getInfoTypeForString("FLAVOR_GROWTH");

	push	0
	push	OFFSET ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 48   : 	m_iExpansionIndex = GC.getInfoTypeForString("FLAVOR_EXPANSION");

	push	0
	push	OFFSET ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], eax

; 49   : 	m_iNavalIndex = GC.getInfoTypeForString("FLAVOR_NAVAL");

	push	0
	push	OFFSET ??_C@_0N@CLMADBAM@FLAVOR_NAVAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 50   : 
; 51   : 	m_iBrazilMultiplier = 1000;	//fertility boost from jungles

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 1000		; 000003e8H

; 52   : 	m_iSpainMultiplier = 55000;	//fertility boost from natural wonders

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 55000		; 0000d6d8H

; 53   : 	m_iMorrocoMultiplier = 1000; //fertility boost from desert

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 1000		; 000003e8H

; 54   : 	m_iNetherlandsMultiplier = 2000; //fertility boost from marshes and flood plains

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 2000		; 000007d0H

; 55   : 	m_iIncaMultiplier = 500; //fertility boost for hill tiles surrounded my mountains

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 500		; 000001f4H

; 56   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Init@CvCitySiteEvaluator@@UAEXXZ ENDP			; CvCitySiteEvaluator::Init
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
PUBLIC	??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@ ; `string'
PUBLIC	??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@	; `string'
EXTRN	?isFreshWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFreshWater
EXTRN	?isFoundFreshWater@CvTerrainInfo@@QBE_NXZ:PROC	; CvTerrainInfo::isFoundFreshWater
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?isFoundCoast@CvTerrainInfo@@QBE_NXZ:PROC	; CvTerrainInfo::isFoundCoast
EXTRN	?isFound@CvTerrainInfo@@QBE_NXZ:PROC		; CvTerrainInfo::isFound
EXTRN	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z:PROC ; CvGlobals::getTerrainInfo
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?isNoCity@CvFeatureInfo@@QBE_NXZ:PROC		; CvFeatureInfo::isNoCity
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isFinalInitialized@CvGame@@QBE_NXZ:PROC	; CvGame::isFinalInitialized
;	COMDAT ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
CONST	SEGMENT
??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@ DB 'GAMEOPTION_AI_GI'
	DB	'MP_NO_BUILDING_SETTLERS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
CONST	SEGMENT
??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@ DB 'GAMEOPTION_AI_TWEAKS', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvsiteevaluationclasses.cpp
CONST	ENDS
;	COMDAT ?CanFound@CvCitySiteEvaluator@@UBE_NPAVCvPlot@@PBVCvPlayer@@_N@Z
_TEXT	SEGMENT
_this$ = -164						; size = 4
$T223371 = -144						; size = 4
$T223367 = -140						; size = 4
$T223253 = -64						; size = 4
$T223249 = -60						; size = 4
$T223239 = -56						; size = 4
$T223235 = -52						; size = 4
$T223226 = -48						; size = 4
_f$223219 = -42						; size = 1
_f$223210 = -41						; size = 1
$T223198 = -40						; size = 4
$T223194 = -36						; size = 4
$T223190 = -32						; size = 4
$T223186 = -28						; size = 4
_iDY$ = -24						; size = 4
_pTerrainInfo$ = -20					; size = 4
_iDX$ = -16						; size = 4
_bValid$ = -9						; size = 1
_iRange$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_bTestVisible$ = 16					; size = 1
?CanFound@CvCitySiteEvaluator@@UBE_NPAVCvPlot@@PBVCvPlayer@@_N@Z PROC ; CvCitySiteEvaluator::CanFound, COMDAT
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 	CvAssert(pPlot);
; 62   : 	if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN36@CanFound

; 63   : 		return false;

	xor	al, al
	jmp	$LN37@CanFound
$LN36@CanFound:

; 64   : 
; 65   : 	CvPlot* pLoopPlot(NULL);

	mov	DWORD PTR _pLoopPlot$[ebp], 0

; 66   : 	bool bValid(false);

	mov	BYTE PTR _bValid$[ebp], 0

; 67   : 	int iRange(0), iDX(0), iDY(0);

	mov	DWORD PTR _iRange$[ebp], 0
	mov	DWORD PTR _iDX$[ebp], 0
	mov	DWORD PTR _iDY$[ebp], 0

; 68   : 
; 69   : 	// Used to have a Python hook: CANNOT_FOUND_CITY_CALLBACK
; 70   : 
; 71   : 	if(GC.getGame().isFinalInitialized())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223186[ebp], eax
	mov	ecx, DWORD PTR $T223186[ebp]
	call	?isFinalInitialized@CvGame@@QBE_NXZ	; CvGame::isFinalInitialized
	movzx	ecx, al
	test	ecx, ecx
	je	$LN47@CanFound

; 72   : 	{
; 73   : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 74   : 		if (pPlayer && (pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN32@CanFound
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN32@CanFound
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223190[ebp], eax
	push	5
	mov	ecx, DWORD PTR $T223190[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN33@CanFound
$LN32@CanFound:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN47@CanFound
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223194[ebp], eax
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T223194[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN33@CanFound
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223198[ebp], edx
	push	OFFSET ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
	mov	ecx, DWORD PTR $T223198[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN47@CanFound
$LN33@CanFound:

; 75   : #else
; 76   : 		if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer && pPlayer->isHuman())
; 77   : #endif
; 78   : 		{
; 79   : 			if(pPlayer->getNumCities() > 0)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	test	eax, eax
	jle	SHORT $LN47@CanFound

; 80   : 			{
; 81   : 				return false;

	xor	al, al
	jmp	$LN37@CanFound

; 82   : 			}
; 83   : 		}
; 84   : 	}
; 85   : 
; 86   : 	if(pPlot->isImpassable() || pPlot->isMountain())

$LN47@CanFound:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN27@CanFound
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN53@CanFound
$LN27@CanFound:

; 87   : 	{
; 88   : 		return false;

	xor	al, al
	jmp	$LN37@CanFound

; 89   : 	}
; 90   : 
; 91   : 	if(pPlot->getFeatureType() != NO_FEATURE)

$LN53@CanFound:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$223210[ebp], dl
	movsx	eax, BYTE PTR _f$223210[ebp]
	cmp	eax, -1
	je	SHORT $LN26@CanFound

; 92   : 	{
; 93   : 		if(GC.getFeatureInfo(pPlot->getFeatureType())->isNoCity())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$223219[ebp], dl
	movsx	eax, BYTE PTR _f$223219[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isNoCity@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isNoCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@CanFound

; 94   : 		{
; 95   : 			return false;

	xor	al, al
	jmp	$LN37@CanFound
$LN26@CanFound:

; 96   : 		}
; 97   : 	}
; 98   : 
; 99   : 	if(pPlayer)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN24@CanFound

; 100  : 	{
; 101  : 		if(pPlot->isOwned() && (pPlot->getOwner() != pPlayer->GetID()))

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN24@CanFound
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T223226[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T223235[ebp], eax
	mov	ecx, DWORD PTR $T223226[ebp]
	cmp	ecx, DWORD PTR $T223235[ebp]
	je	SHORT $LN24@CanFound

; 102  : 		{
; 103  : 			return false;

	xor	al, al
	jmp	$LN37@CanFound
$LN24@CanFound:

; 104  : 		}
; 105  : 	}
; 106  : 
; 107  : 	CvTerrainInfo* pTerrainInfo = GC.getTerrainInfo(pPlot->getTerrainType());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	DWORD PTR $T223239[ebp], eax
	mov	ecx, DWORD PTR $T223239[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTerrainInfo@CvGlobals@@QAEPAVCvTerrainInfo@@W4TerrainTypes@@@Z ; CvGlobals::getTerrainInfo
	mov	DWORD PTR _pTerrainInfo$[ebp], eax

; 108  : 
; 109  : 	if(!bValid)

	movzx	edx, BYTE PTR _bValid$[ebp]
	test	edx, edx
	jne	SHORT $LN22@CanFound

; 110  : 	{
; 111  : 		if(pTerrainInfo->isFound())

	mov	ecx, DWORD PTR _pTerrainInfo$[ebp]
	call	?isFound@CvTerrainInfo@@QBE_NXZ		; CvTerrainInfo::isFound
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@CanFound

; 112  : 		{
; 113  : 			bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN22@CanFound:

; 114  : 		}
; 115  : 	}
; 116  : 
; 117  : 	if(!bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	jne	SHORT $LN20@CanFound

; 118  : 	{
; 119  : 		if(pTerrainInfo->isFoundCoast())

	mov	ecx, DWORD PTR _pTerrainInfo$[ebp]
	call	?isFoundCoast@CvTerrainInfo@@QBE_NXZ	; CvTerrainInfo::isFoundCoast
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN20@CanFound

; 120  : 		{
; 121  : 			if(pPlot->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@CanFound

; 122  : 			{
; 123  : 				bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1
$LN20@CanFound:

; 124  : 			}
; 125  : 		}
; 126  : 	}
; 127  : 
; 128  : 	if(!bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	jne	SHORT $LN67@CanFound

; 129  : 	{
; 130  : 		if(pTerrainInfo->isFoundFreshWater())

	mov	ecx, DWORD PTR _pTerrainInfo$[ebp]
	call	?isFoundFreshWater@CvTerrainInfo@@QBE_NXZ ; CvTerrainInfo::isFoundFreshWater
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN67@CanFound

; 131  : 		{
; 132  : 			if(pPlot->isFreshWater())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN67@CanFound

; 133  : 			{
; 134  : 				bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 135  : 			}
; 136  : 		}
; 137  : 	}
; 138  : 
; 139  : 	// Used to have a Python hook: CAN_FOUND_CITIES_ON_WATER_CALLBACK
; 140  : 
; 141  : 	if(pPlot->isWater())

$LN67@CanFound:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@CanFound

; 142  : 	{
; 143  : 		return false;

	xor	al, al
	jmp	$LN37@CanFound
$LN14@CanFound:

; 144  : 	}
; 145  : 
; 146  : 	if(!bValid)

	movzx	edx, BYTE PTR _bValid$[ebp]
	test	edx, edx
	jne	SHORT $LN13@CanFound

; 147  : 	{
; 148  : 		return false;

	xor	al, al
	jmp	$LN37@CanFound
$LN13@CanFound:

; 149  : 	}
; 150  : 
; 151  : 	if(!bTestVisible)

	movzx	eax, BYTE PTR _bTestVisible$[ebp]
	test	eax, eax
	jne	$LN12@CanFound

; 152  : 	{
; 153  : 		// look at same land mass
; 154  : 		iRange = GC.getMIN_CITY_RANGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6248
	mov	DWORD PTR _iRange$[ebp], ecx

; 155  : 
; 156  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 157  : 		int iMaxDX;
; 158  : 		for (iDY = -iRange; iDY <= iRange; iDY++)
; 159  : 		{
; 160  : 			iMaxDX = iRange - MAX(0, iDY);
; 161  : 			for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 162  : 			{
; 163  : 				pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 164  : #else
; 165  : 		for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	edx, DWORD PTR _iRange$[ebp]
	neg	edx
	mov	DWORD PTR _iDX$[ebp], edx
	jmp	SHORT $LN11@CanFound
$LN10@CanFound:
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$[ebp], eax
$LN11@CanFound:
	mov	ecx, DWORD PTR _iDX$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jg	$LN12@CanFound

; 166  : 		{
; 167  : 			for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	edx, DWORD PTR _iRange$[ebp]
	neg	edx
	mov	DWORD PTR _iDY$[ebp], edx
	jmp	SHORT $LN8@CanFound
$LN7@CanFound:
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, 1
	mov	DWORD PTR _iDY$[ebp], eax
$LN8@CanFound:
	mov	ecx, DWORD PTR _iDY$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jg	$LN6@CanFound

; 168  : 			{
; 169  : 				pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iDX, iDY, iRange);

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T223249[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T223253[ebp], edx
	mov	eax, DWORD PTR _iRange$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDX$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223249[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223253[ebp]
	push	ecx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 170  : #endif
; 171  : 
; 172  : 				if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN5@CanFound

; 173  : 				{
; 174  : 					if(pLoopPlot->isCity())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@CanFound

; 175  : 					{
; 176  : 						if(pLoopPlot->getLandmass() == pPlot->getLandmass())

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	ecx, DWORD PTR [eax+360]
	mov	DWORD PTR $T223367[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	eax, DWORD PTR [edx+360]
	mov	DWORD PTR $T223371[ebp], eax
	mov	ecx, DWORD PTR $T223367[ebp]
	cmp	ecx, DWORD PTR $T223371[ebp]
	jne	SHORT $LN3@CanFound

; 177  : 						{
; 178  : 							return false;

	xor	al, al
	jmp	SHORT $LN37@CanFound
	jmp	SHORT $LN5@CanFound
$LN3@CanFound:

; 179  : 						}
; 180  : 						else if(hexDistance(iDX, iDY) < iRange)  // one less for off shore

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	cmp	eax, DWORD PTR _iRange$[ebp]
	jge	SHORT $LN5@CanFound

; 181  : 						{
; 182  : 							return false;

	xor	al, al
	jmp	SHORT $LN37@CanFound
$LN5@CanFound:

; 183  : 						}
; 184  : 					}
; 185  : 				}
; 186  : 			}

	jmp	$LN7@CanFound
$LN6@CanFound:

; 187  : 		}

	jmp	$LN10@CanFound
$LN12@CanFound:

; 188  : 	}
; 189  : 
; 190  : 	return true;

	mov	al, 1
$LN37@CanFound:

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CanFound@CvCitySiteEvaluator@@UBE_NPAVCvPlot@@PBVCvPlayer@@_N@Z ENDP ; CvCitySiteEvaluator::CanFound
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
tv83 = -36						; size = 4
tv81 = -32						; size = 4
tv78 = -28						; size = 4
tv74 = -24						; size = 4
tv71 = -20						; size = 4
_iAbsDY$216713 = -16					; size = 4
_iAbsDX$216712 = -12					; size = 4
_iAbsDY$216710 = -8					; size = 4
_iAbsDX$216709 = -4					; size = 4
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN5@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN6@hexDistanc
$LN5@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN6@hexDistanc:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216709[ebp], ecx

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN7@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN8@hexDistanc
$LN7@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN8@hexDistanc:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216710[ebp], ecx

; 112  : 		return iAbsDX + iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216709[ebp]
	add	eax, DWORD PTR _iAbsDY$216710[ebp]
	jmp	SHORT $LN3@hexDistanc

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN3@hexDistanc
$LN2@hexDistanc:

; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN9@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN10@hexDistanc
$LN9@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv78[ebp], eax
$LN10@hexDistanc:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216712[ebp], ecx

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN11@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN12@hexDistanc
$LN11@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv81[ebp], eax
$LN12@hexDistanc:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216713[ebp], ecx

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216712[ebp]
	cmp	edx, DWORD PTR _iAbsDY$216713[ebp]
	jl	SHORT $LN13@hexDistanc
	mov	eax, DWORD PTR _iAbsDX$216712[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@hexDistanc
$LN13@hexDistanc:
	mov	ecx, DWORD PTR _iAbsDY$216713[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN14@hexDistanc:
	mov	eax, DWORD PTR tv83[ebp]
$LN3@hexDistanc:

; 119  : 	}
; 120  : #endif
; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216767 = -20					; size = 4
_iAbsDX$216766 = -16					; size = 4
_iAbsDY$216764 = -12					; size = 4
_iAbsDX$216763 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216763[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216764[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216763[ebp]
	add	edx, DWORD PTR _iAbsDY$216764[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216766[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216767[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216766[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216767[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216766[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216767[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T223649 = -56						; size = 4
$T223604 = -52						; size = 4
$T223591 = -48						; size = 4
$T223587 = -44						; size = 4
$T223573 = -40						; size = 4
$T223569 = -33						; size = 1
$T223558 = -32						; size = 4
$T223554 = -25						; size = 1
_iMapY$223648 = -24					; size = 4
_iMapX$223647 = -20					; size = 4
$T223547 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223547[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T223649[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T223547[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T223554[ebp], dl
	mov	eax, DWORD PTR $T223547[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223558[ebp], ecx
	movzx	edx, BYTE PTR $T223554[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T223558[ebp]
	add	edx, DWORD PTR $T223558[ebp]
	mov	DWORD PTR _iMapX$223647[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T223558[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T223558[ebp]
	mov	DWORD PTR _iMapX$223647[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$223647[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T223547[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T223569[ebp], al
	mov	ecx, DWORD PTR $T223547[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T223573[ebp], edx
	movzx	eax, BYTE PTR $T223569[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T223573[ebp]
	add	edx, DWORD PTR $T223573[ebp]
	mov	DWORD PTR _iMapY$223648[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T223573[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T223573[ebp]
	mov	DWORD PTR _iMapY$223648[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$223648[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$223647[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T223547[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223587[ebp], ecx
	mov	edx, DWORD PTR _iMapX$223647[ebp]
	cmp	edx, DWORD PTR $T223587[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$223648[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T223547[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T223591[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223648[ebp]
	cmp	edx, DWORD PTR $T223591[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T223547[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T223604[ebp], ecx
	mov	edx, DWORD PTR _iMapY$223648[ebp]
	imul	edx, DWORD PTR $T223604[ebp]
	add	edx, DWORD PTR _iMapX$223647[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T223547[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T223649[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T223649[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@		; `string'
PUBLIC	??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@	; `string'
PUBLIC	??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@		; `string'
PUBLIC	??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@		; `string'
PUBLIC	??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@	; `string'
PUBLIC	??_C@_0BI@OGGDNFPL@FLAVOR_TILE_IMPROVEMENT?$AA@	; `string'
PUBLIC	??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@		; `string'
EXTRN	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z:PROC ; CvCitySpecializationXMLEntry::GetFlavorValue
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z:PROC ; CvGlobals::getCitySpecializationInfo
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
;	COMDAT ??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@ DB 'FLAVOR_RELIGION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@
CONST	SEGMENT
??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@ DB 'FLAVOR_HAPPINESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@
CONST	SEGMENT
??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@ DB 'FLAVOR_SCIENCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@
CONST	SEGMENT
??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@ DB 'FLAVOR_WONDER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@
CONST	SEGMENT
??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@ DB 'FLAVOR_PRODUCTION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OGGDNFPL@FLAVOR_TILE_IMPROVEMENT?$AA@
CONST	SEGMENT
??_C@_0BI@OGGDNFPL@FLAVOR_TILE_IMPROVEMENT?$AA@ DB 'FLAVOR_TILE_IMPROVEME'
	DB	'NT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
CONST	SEGMENT
??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@ DB 'FLAVOR_GOLD', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvsiteevaluationclasses.cpp
CONST	ENDS
;	COMDAT ?ComputeFlavorMultipliers@CvCitySiteEvaluator@@UAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T223659 = -36						; size = 4
$T223655 = -32						; size = 4
_iI$222543 = -28					; size = 4
_strFlavor$222515 = -24					; size = 4
_eFlavor$222513 = -20					; size = 4
_iFlavorLoop$222509 = -16				; size = 4
_iI$222502 = -12					; size = 4
_eNextSpecialization$ = -8				; size = 4
_pkCitySpecializationEntry$ = -4			; size = 4
_pPlayer$ = 8						; size = 4
?ComputeFlavorMultipliers@CvCitySiteEvaluator@@UAEXPAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeFlavorMultipliers, COMDAT
; _this$ = ecx

; 195  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 196  : 	// Set all to 0
; 197  : 	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)

	mov	DWORD PTR _iI$222502[ebp], 0
	jmp	SHORT $LN31@ComputeFla
$LN30@ComputeFla:
	mov	eax, DWORD PTR _iI$222502[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222502[ebp], eax
$LN31@ComputeFla:
	cmp	DWORD PTR _iI$222502[ebp], 6
	jge	SHORT $LN29@ComputeFla

; 198  : 	{
; 199  : 		m_iFlavorMultiplier[iI] = 0;

	mov	ecx, DWORD PTR _iI$222502[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], 0

; 200  : 	}

	jmp	SHORT $LN30@ComputeFla
$LN29@ComputeFla:

; 201  : 
; 202  : 	m_iFlavorMultiplier[SITE_EVALUATION_HAPPINESS] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 203  : 
; 204  : 	// Find out if player has a desired next city specialization
; 205  : 	CitySpecializationTypes eNextSpecialization = pPlayer->GetCitySpecializationAI()->GetNextSpecializationDesired();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	DWORD PTR $T223655[ebp], eax
	mov	ecx, DWORD PTR $T223655[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _eNextSpecialization$[ebp], edx

; 206  : 	CvCitySpecializationXMLEntry* pkCitySpecializationEntry = NULL;

	mov	DWORD PTR _pkCitySpecializationEntry$[ebp], 0

; 207  : 	if(eNextSpecialization != NO_CITY_SPECIALIZATION)

	cmp	DWORD PTR _eNextSpecialization$[ebp], -1
	je	SHORT $LN28@ComputeFla

; 208  : 		pkCitySpecializationEntry = GC.getCitySpecializationInfo(eNextSpecialization);

	mov	eax, DWORD PTR _eNextSpecialization$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCitySpecializationInfo@CvGlobals@@QAEPAVCvCitySpecializationXMLEntry@@W4CitySpecializationTypes@@@Z ; CvGlobals::getCitySpecializationInfo
	mov	DWORD PTR _pkCitySpecializationEntry$[ebp], eax
$LN28@ComputeFla:

; 209  : 
; 210  : 
; 211  : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$222509[ebp], 0
	jmp	SHORT $LN27@ComputeFla
$LN26@ComputeFla:
	mov	ecx, DWORD PTR _iFlavorLoop$222509[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$222509[ebp], ecx
$LN27@ComputeFla:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T223659[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$222509[ebp]
	cmp	eax, DWORD PTR $T223659[ebp]
	jge	$LN25@ComputeFla

; 212  : 	{
; 213  : 		const FlavorTypes eFlavor = static_cast<FlavorTypes>(iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$222509[ebp]
	mov	DWORD PTR _eFlavor$222513[ebp], ecx

; 214  : 		const CvString& strFlavor = GC.getFlavorTypes(eFlavor);

	mov	edx, DWORD PTR _eFlavor$222513[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR _strFlavor$222515[ebp], edx

; 215  : 		if(strFlavor == "FLAVOR_GROWTH" ||
; 216  : 		        strFlavor == "FLAVOR_EXPANSION")

	push	OFFSET ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
	mov	eax, DWORD PTR _strFlavor$222515[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN23@ComputeFla
	push	OFFSET ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
	mov	edx, DWORD PTR _strFlavor$222515[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@ComputeFla
$LN23@ComputeFla:

; 217  : 		{
; 218  : 			m_iFlavorMultiplier[YIELD_FOOD] += pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	mov	ecx, DWORD PTR _eFlavor$222513[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 219  : 			if(pkCitySpecializationEntry)

	cmp	DWORD PTR _pkCitySpecializationEntry$[ebp], 0
	je	SHORT $LN22@ComputeFla

; 220  : 			{
; 221  : 				m_iFlavorMultiplier[YIELD_FOOD] += pkCitySpecializationEntry->GetFlavorValue(eFlavor);

	mov	edx, DWORD PTR _eFlavor$222513[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkCitySpecializationEntry$[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN22@ComputeFla:

; 222  : 			}
; 223  : 		}
; 224  : 		else if(strFlavor == "FLAVOR_GOLD" ||

	jmp	$LN21@ComputeFla
$LN24@ComputeFla:

; 225  : 		        strFlavor == "FLAVOR_TILE_IMPROVEMENT")

	push	OFFSET ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
	mov	eax, DWORD PTR _strFlavor$222515[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN19@ComputeFla
	push	OFFSET ??_C@_0BI@OGGDNFPL@FLAVOR_TILE_IMPROVEMENT?$AA@
	mov	edx, DWORD PTR _strFlavor$222515[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@ComputeFla
$LN19@ComputeFla:

; 226  : 		{
; 227  : 			m_iFlavorMultiplier[YIELD_GOLD] += pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	mov	ecx, DWORD PTR _eFlavor$222513[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 228  : 			if(pkCitySpecializationEntry)

	cmp	DWORD PTR _pkCitySpecializationEntry$[ebp], 0
	je	SHORT $LN18@ComputeFla

; 229  : 			{
; 230  : 				m_iFlavorMultiplier[YIELD_GOLD] += pkCitySpecializationEntry->GetFlavorValue(eFlavor);

	mov	edx, DWORD PTR _eFlavor$222513[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkCitySpecializationEntry$[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax
$LN18@ComputeFla:

; 231  : 			}
; 232  : 		}
; 233  : 		else if(strFlavor == "FLAVOR_PRODUCTION" ||

	jmp	$LN21@ComputeFla
$LN20@ComputeFla:

; 234  : 		        strFlavor == "FLAVOR_WONDER")

	push	OFFSET ??_C@_0BC@FHBLEBJB@FLAVOR_PRODUCTION?$AA@
	mov	eax, DWORD PTR _strFlavor$222515[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN15@ComputeFla
	push	OFFSET ??_C@_0O@CBMDBMFP@FLAVOR_WONDER?$AA@
	mov	edx, DWORD PTR _strFlavor$222515[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@ComputeFla
$LN15@ComputeFla:

; 235  : 		{
; 236  : 			m_iFlavorMultiplier[YIELD_PRODUCTION] += pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	mov	ecx, DWORD PTR _eFlavor$222513[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 237  : 			if(pkCitySpecializationEntry)

	cmp	DWORD PTR _pkCitySpecializationEntry$[ebp], 0
	je	SHORT $LN14@ComputeFla

; 238  : 			{
; 239  : 				m_iFlavorMultiplier[YIELD_PRODUCTION] += pkCitySpecializationEntry->GetFlavorValue(eFlavor);

	mov	edx, DWORD PTR _eFlavor$222513[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkCitySpecializationEntry$[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN14@ComputeFla:

; 240  : 			}
; 241  : 		}

	jmp	$LN21@ComputeFla
$LN16@ComputeFla:

; 242  : 		else if(strFlavor == "FLAVOR_SCIENCE")

	push	OFFSET ??_C@_0P@NPJBAHPJ@FLAVOR_SCIENCE?$AA@
	mov	eax, DWORD PTR _strFlavor$222515[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@ComputeFla

; 243  : 		{
; 244  : 			// Doubled since only one flavor related to science
; 245  : 			m_iFlavorMultiplier[YIELD_SCIENCE] += pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor) * 2;

	mov	edx, DWORD PTR _eFlavor$222513[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 246  : 			if(pkCitySpecializationEntry)

	cmp	DWORD PTR _pkCitySpecializationEntry$[ebp], 0
	je	SHORT $LN11@ComputeFla

; 247  : 			{
; 248  : 				m_iFlavorMultiplier[YIELD_SCIENCE] += pkCitySpecializationEntry->GetFlavorValue(eFlavor) * 2;

	mov	edx, DWORD PTR _eFlavor$222513[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkCitySpecializationEntry$[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN11@ComputeFla:

; 249  : 			}
; 250  : 		}

	jmp	$LN21@ComputeFla
$LN12@ComputeFla:

; 251  : 		else if(strFlavor == "FLAVOR_HAPPINESS")

	push	OFFSET ??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@
	mov	edx, DWORD PTR _strFlavor$222515[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@ComputeFla

; 252  : 		{
; 253  : 			// Doubled since only one flavor related to Happiness
; 254  : 			m_iFlavorMultiplier[SITE_EVALUATION_HAPPINESS] += pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor) * 2;

	mov	ecx, DWORD PTR _eFlavor$222513[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx

; 255  : 			if(pkCitySpecializationEntry)

	cmp	DWORD PTR _pkCitySpecializationEntry$[ebp], 0
	je	SHORT $LN8@ComputeFla

; 256  : 			{
; 257  : 				m_iFlavorMultiplier[SITE_EVALUATION_HAPPINESS] += pkCitySpecializationEntry->GetFlavorValue(eFlavor) * 2;

	mov	ecx, DWORD PTR _eFlavor$222513[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkCitySpecializationEntry$[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN8@ComputeFla:

; 258  : 			}
; 259  : 		}

	jmp	SHORT $LN21@ComputeFla
$LN9@ComputeFla:

; 260  : 		else if(strFlavor == "FLAVOR_RELIGION")

	push	OFFSET ??_C@_0BA@DBJAEMOP@FLAVOR_RELIGION?$AA@
	mov	ecx, DWORD PTR _strFlavor$222515[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN21@ComputeFla

; 261  : 		{
; 262  : 			// Doubled since only one flavor related to faith
; 263  : 			m_iFlavorMultiplier[YIELD_FAITH] += pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor) * 2;

	mov	eax, DWORD PTR _eFlavor$222513[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 264  : 			if (pkCitySpecializationEntry)

	cmp	DWORD PTR _pkCitySpecializationEntry$[ebp], 0
	je	SHORT $LN21@ComputeFla

; 265  : 			{
; 266  : 				m_iFlavorMultiplier[YIELD_FAITH] += pkCitySpecializationEntry->GetFlavorValue(eFlavor) * 2;

	mov	edx, DWORD PTR _eFlavor$222513[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkCitySpecializationEntry$[ebp]
	call	?GetFlavorValue@CvCitySpecializationXMLEntry@@QBEHH@Z ; CvCitySpecializationXMLEntry::GetFlavorValue
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax
$LN21@ComputeFla:

; 267  : 			}
; 268  : 		}
; 269  : 	}

	jmp	$LN26@ComputeFla
$LN25@ComputeFla:

; 270  : 
; 271  : 	// Make sure none are negative
; 272  : 	for(int iI = 0; iI < NUM_YIELD_TYPES; iI++)

	mov	DWORD PTR _iI$222543[ebp], 0
	jmp	SHORT $LN4@ComputeFla
$LN3@ComputeFla:
	mov	edx, DWORD PTR _iI$222543[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$222543[ebp], edx
$LN4@ComputeFla:
	cmp	DWORD PTR _iI$222543[ebp], 6
	jge	SHORT $LN2@ComputeFla

; 273  : 	{
; 274  : 		if(m_iFlavorMultiplier[iI] < 0)

	mov	eax, DWORD PTR _iI$222543[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+4], 0
	jge	SHORT $LN1@ComputeFla

; 275  : 		{
; 276  : 			m_iFlavorMultiplier[iI] = 0;

	mov	edx, DWORD PTR _iI$222543[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+4], 0
$LN1@ComputeFla:

; 277  : 		}
; 278  : 	}

	jmp	SHORT $LN3@ComputeFla
$LN2@ComputeFla:

; 279  : 
; 280  : 	// Set tradable resources and strategic value to times 10 (so multiplying this by the number of map gives a number from 1 to 100)
; 281  : 	m_iFlavorMultiplier[SITE_EVALUATION_RESOURCES] = 10;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 10			; 0000000aH

; 282  : 	m_iFlavorMultiplier[SITE_EVALUATION_STRATEGIC] = 10;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 10			; 0000000aH

; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ComputeFlavorMultipliers@CvCitySiteEvaluator@@UAEXPAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeFlavorMultipliers
_TEXT	ENDS
PUBLIC	??_C@_0BD@JLAGGNHC@IMPROVEMENT_POLDER?$AA@	; `string'
PUBLIC	??_C@_0BD@LECKMJLO@IMPROVEMENT_KASBAH?$AA@	; `string'
PUBLIC	??_C@_0BM@EBHADHKI@IMPROVEMENT_BRAZILWOOD_CAMP?$AA@ ; `string'
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	??_C@_0BJ@NHDJFCAM@IMPROVEMENT_TERRACE_FARM?$AA@ ; `string'
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ:PROC	; CvCivilizationInfo::isCoastalCiv
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?GetNumAdjacentMountains@CvPlot@@QBEHXZ:PROC	; CvPlot::GetNumAdjacentMountains
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?IsNaturalWonder@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsNaturalWonder
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvImprovementEntry::GetRequiredCivilization
EXTRN	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsSpecificCivRequired
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
;	COMDAT ??_C@_0BD@JLAGGNHC@IMPROVEMENT_POLDER?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
CONST	SEGMENT
??_C@_0BD@JLAGGNHC@IMPROVEMENT_POLDER?$AA@ DB 'IMPROVEMENT_POLDER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LECKMJLO@IMPROVEMENT_KASBAH?$AA@
CONST	SEGMENT
??_C@_0BD@LECKMJLO@IMPROVEMENT_KASBAH?$AA@ DB 'IMPROVEMENT_KASBAH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EBHADHKI@IMPROVEMENT_BRAZILWOOD_CAMP?$AA@
CONST	SEGMENT
??_C@_0BM@EBHADHKI@IMPROVEMENT_BRAZILWOOD_CAMP?$AA@ DB 'IMPROVEMENT_BRAZI'
	DB	'LWOOD_CAMP', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NHDJFCAM@IMPROVEMENT_TERRACE_FARM?$AA@
CONST	SEGMENT
??_C@_0BJ@NHDJFCAM@IMPROVEMENT_TERRACE_FARM?$AA@ DB 'IMPROVEMENT_TERRACE_'
	DB	'FARM', 00H					; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvsiteevaluationclasses.cpp
CONST	ENDS
;	COMDAT ?PlotFoundValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
tv582 = -496						; size = 4
tv696 = -492						; size = 4
_this$ = -488						; size = 4
$T224012 = -484						; size = 4
$T224006 = -480						; size = 4
$T223997 = -476						; size = 4
$T223990 = -472						; size = 4
$T223986 = -468						; size = 4
$T223982 = -464						; size = 4
$T223978 = -460						; size = 4
$T223971 = -456						; size = 4
$T223967 = -452						; size = 4
$T223958 = -448						; size = 4
$T223957 = -444						; size = 4
$T223953 = -437						; size = 1
$T223952 = -436						; size = 4
$T223948 = -429						; size = 1
$T223947 = -428						; size = 4
_f$223926 = -417					; size = 1
$T223920 = -416						; size = 4
$T223911 = -412						; size = 4
$T223907 = -408						; size = 4
$T223903 = -404						; size = 4
$T223899 = -400						; size = 4
$T223895 = -396						; size = 4
$T223888 = -392						; size = 4
$T223884 = -388						; size = 4
$T223880 = -384						; size = 4
$T223876 = -380						; size = 4
$T223872 = -376						; size = 4
$T223863 = -368						; size = 4
$T223854 = -364						; size = 4
$T223798 = -304						; size = 4
$T223794 = -300						; size = 4
$T223790 = -296						; size = 4
$T223786 = -292						; size = 4
$T223674 = -232						; size = 4
$T223670 = -228						; size = 4
$T223666 = -224						; size = 4
$T223665 = -220						; size = 4
_iExpansionFlavor$222704 = -216				; size = 4
_iSweetSpot$222706 = -212				; size = 4
_iBoldness$222719 = -208				; size = 4
_iGrowthFlavor$222702 = -204				; size = 4
_iNavalFlavor$222694 = -200				; size = 4
_eCiv$222685 = -196					; size = 4
_pkEntry$222683 = -192					; size = 4
_eCiv$222677 = -188					; size = 4
_pkEntry$222675 = -184					; size = 4
_eCiv$222669 = -180					; size = 4
_pkEntry$222667 = -176					; size = 4
_ePlotImprovement$222630 = -172				; size = 4
_iRingModifier$222611 = -168				; size = 4
_ePlotResource$222631 = -164				; size = 4
_ePlotFeature$222629 = -160				; size = 4
_iPlotValue$222625 = -156				; size = 4
_iDistance$222604 = -152				; size = 4
_pLoopPlot$222602 = -148				; size = 4
_iDY$222598 = -144					; size = 4
_iDX$222594 = -140					; size = 4
_eCiv$222592 = -136					; size = 4
_pkEntry$222590 = -132					; size = 4
_iProductionValue$ = -128				; size = 4
_iGoldValue$ = -124					; size = 4
_iDesertCount$ = -120					; size = 4
_iTotalProductionValue$ = -116				; size = 4
_iClosestEnemyCity$ = -112				; size = 4
_eIncaImprovement$ = -108				; size = 4
_iScienceValue$ = -104					; size = 4
_iFoodValue$ = -100					; size = 4
_iStrategicValue$ = -96					; size = 4
_iTotalStrategicValue$ = -92				; size = 4
_eBrazilImprovement$ = -88				; size = 4
_iIroquoisForestCount$ = -84				; size = 4
_ePolderImprovement$ = -80				; size = 4
_iResourceValue$ = -76					; size = 4
_iBrazilJungleCount$ = -72				; size = 4
_iTotalScienceValue$ = -68				; size = 4
_iWetlandsCount$ = -64					; size = 4
_rtnValue$ = -60					; size = 4
_iCelticForestCount$ = -56				; size = 4
_iTotalFoodValue$ = -52					; size = 4
_iCapitalArea$ = -48					; size = 4
_iTotalHappinessValue$ = -44				; size = 4
_iTotalFaithValue$ = -40				; size = 4
_iTotalResourceValue$ = -36				; size = 4
_iAdjacentMountains$ = -32				; size = 4
_iClosestCityOfMine$ = -28				; size = 4
_eMoroccoImprovement$ = -24				; size = 4
_iNaturalWonderCount$ = -20				; size = 4
_bIsInca$ = -13						; size = 1
_iHappinessValue$ = -12					; size = 4
_iTotalGoldValue$ = -8					; size = 4
_iFaithValue$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_eYield$ = 16						; size = 4
___formal$ = 20						; size = 1
?PlotFoundValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z PROC ; CvCitySiteEvaluator::PlotFoundValue, COMDAT
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 496				; 000001f0H
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 	CvAssert(pPlot);
; 289  : 	if(!pPlot)

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN100@PlotFoundV

; 290  : 		return 0;

	xor	eax, eax
	jmp	$LN101@PlotFoundV
$LN100@PlotFoundV:

; 291  : #ifdef AUI_WARNING_FIXES
; 292  : 	if (!pPlayer)
; 293  : 		return 0;
; 294  : #endif
; 295  : 
; 296  : 	// Make sure this player can even build a city here
; 297  : 	if(!CanFound(pPlot, pPlayer, false))

	push	0
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN99@PlotFoundV

; 298  : 	{
; 299  : 		return 0;

	xor	eax, eax
	jmp	$LN101@PlotFoundV
$LN99@PlotFoundV:

; 300  : 	}
; 301  : 
; 302  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 303  : 
; 304  : 	int iFoodValue = 0;

	mov	DWORD PTR _iFoodValue$[ebp], 0

; 305  : 	int iHappinessValue = 0;

	mov	DWORD PTR _iHappinessValue$[ebp], 0

; 306  : 	int iProductionValue = 0;

	mov	DWORD PTR _iProductionValue$[ebp], 0

; 307  : 	int iGoldValue = 0;

	mov	DWORD PTR _iGoldValue$[ebp], 0

; 308  : 	int iScienceValue = 0;

	mov	DWORD PTR _iScienceValue$[ebp], 0

; 309  : 	int iFaithValue = 0;

	mov	DWORD PTR _iFaithValue$[ebp], 0

; 310  : 	int iResourceValue = 0;

	mov	DWORD PTR _iResourceValue$[ebp], 0

; 311  : 	int iStrategicValue = 0;

	mov	DWORD PTR _iStrategicValue$[ebp], 0

; 312  : 
; 313  : 	int iCelticForestCount = 0;

	mov	DWORD PTR _iCelticForestCount$[ebp], 0

; 314  : 	int iIroquoisForestCount = 0;

	mov	DWORD PTR _iIroquoisForestCount$[ebp], 0

; 315  : 	int iBrazilJungleCount = 0;

	mov	DWORD PTR _iBrazilJungleCount$[ebp], 0

; 316  : 	int iNaturalWonderCount = 0;

	mov	DWORD PTR _iNaturalWonderCount$[ebp], 0

; 317  : 	int iDesertCount = 0;

	mov	DWORD PTR _iDesertCount$[ebp], 0

; 318  : 	int iWetlandsCount = 0;

	mov	DWORD PTR _iWetlandsCount$[ebp], 0

; 319  : 
; 320  : 	int iTotalFoodValue = 0;

	mov	DWORD PTR _iTotalFoodValue$[ebp], 0

; 321  : 	int iTotalHappinessValue = 0;

	mov	DWORD PTR _iTotalHappinessValue$[ebp], 0

; 322  : 	int iTotalProductionValue = 0;

	mov	DWORD PTR _iTotalProductionValue$[ebp], 0

; 323  : 	int iTotalGoldValue = 0;

	mov	DWORD PTR _iTotalGoldValue$[ebp], 0

; 324  : 	int iTotalScienceValue = 0;

	mov	DWORD PTR _iTotalScienceValue$[ebp], 0

; 325  : 	int iTotalFaithValue = 0;

	mov	DWORD PTR _iTotalFaithValue$[ebp], 0

; 326  : 	int iTotalResourceValue = 0;

	mov	DWORD PTR _iTotalResourceValue$[ebp], 0

; 327  : 	int iTotalStrategicValue = 0;

	mov	DWORD PTR _iTotalStrategicValue$[ebp], 0

; 328  : 
; 329  : 	int iClosestCityOfMine = 999;

	mov	DWORD PTR _iClosestCityOfMine$[ebp], 999 ; 000003e7H

; 330  : 	int iClosestEnemyCity = 999;

	mov	DWORD PTR _iClosestEnemyCity$[ebp], 999	; 000003e7H

; 331  : 
; 332  : 	int iCapitalArea = NULL;

	mov	DWORD PTR _iCapitalArea$[ebp], 0

; 333  : 
; 334  : 	bool bIsInca = false;

	mov	BYTE PTR _bIsInca$[ebp], 0

; 335  : 	int iAdjacentMountains = 0;

	mov	DWORD PTR _iAdjacentMountains$[ebp], 0

; 336  : 
; 337  : 	if ( pPlayer->getCapitalCity() )

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN98@PlotFoundV

; 338  : 		iCapitalArea = pPlayer->getCapitalCity()->getArea();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	DWORD PTR _iCapitalArea$[ebp], eax
$LN98@PlotFoundV:

; 339  : 
; 340  : 	// Custom code for Inca ideal terrace farm locations
; 341  : 	ImprovementTypes eIncaImprovement = (ImprovementTypes)GC.getInfoTypeForString("IMPROVEMENT_TERRACE_FARM", true);  

	push	1
	push	OFFSET ??_C@_0BJ@NHDJFCAM@IMPROVEMENT_TERRACE_FARM?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eIncaImprovement$[ebp], eax

; 342  : 	if(eIncaImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eIncaImprovement$[ebp], -1
	je	SHORT $LN97@PlotFoundV

; 343  : 	{
; 344  : 		CvImprovementEntry* pkEntry = GC.getImprovementInfo(eIncaImprovement);

	mov	ecx, DWORD PTR _eIncaImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkEntry$222590[ebp], eax

; 345  : 		if(pkEntry != NULL && pkEntry->IsSpecificCivRequired())

	cmp	DWORD PTR _pkEntry$222590[ebp], 0
	je	SHORT $LN97@PlotFoundV
	mov	ecx, DWORD PTR _pkEntry$222590[ebp]
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN97@PlotFoundV

; 346  : 		{
; 347  : 			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();

	mov	ecx, DWORD PTR _pkEntry$222590[ebp]
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
	mov	DWORD PTR _eCiv$222592[ebp], eax

; 348  : 			if(eCiv == pPlayer->getCivilizationType())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	DWORD PTR _eCiv$222592[ebp], eax
	jne	SHORT $LN97@PlotFoundV

; 349  : 			{
; 350  : 				bIsInca = true;

	mov	BYTE PTR _bIsInca$[ebp], 1
$LN97@PlotFoundV:

; 351  : 			}
; 352  : 		}
; 353  : 	}
; 354  : 
; 355  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 356  : 	int iDX, iMaxDX;
; 357  : 	for (int iDY = -7; iDY <= 7; iDY++)
; 358  : 	{
; 359  : 		iMaxDX = 7 - MAX(0, iDY);
; 360  : 		for (iDX = -7 - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 361  : #else
; 362  : 	for (int iDX = -7; iDX <= 7; iDX++)

	mov	DWORD PTR _iDX$222594[ebp], -7		; fffffff9H
	jmp	SHORT $LN94@PlotFoundV
$LN93@PlotFoundV:
	mov	eax, DWORD PTR _iDX$222594[ebp]
	add	eax, 1
	mov	DWORD PTR _iDX$222594[ebp], eax
$LN94@PlotFoundV:
	cmp	DWORD PTR _iDX$222594[ebp], 7
	jg	$LN92@PlotFoundV

; 363  : 	{
; 364  : 		for (int iDY = -7; iDY <= 7; iDY++)

	mov	DWORD PTR _iDY$222598[ebp], -7		; fffffff9H
	jmp	SHORT $LN91@PlotFoundV
$LN90@PlotFoundV:
	mov	ecx, DWORD PTR _iDY$222598[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$222598[ebp], ecx
$LN91@PlotFoundV:
	cmp	DWORD PTR _iDY$222598[ebp], 7
	jg	$LN89@PlotFoundV

; 365  : #endif
; 366  : 		{
; 367  : 			CvPlot* pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T223670[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T223674[ebp], edx
	mov	eax, DWORD PTR _iDY$222598[ebp]
	push	eax
	mov	ecx, DWORD PTR _iDX$222594[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223670[ebp]
	push	edx
	mov	eax, DWORD PTR $T223674[ebp]
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pLoopPlot$222602[ebp], eax

; 368  : 
; 369  : 			if (pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$222602[ebp], 0
	je	$LN88@PlotFoundV

; 370  : 			{
; 371  : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 372  : 				int iDistance = hexDistance(iDX, iDY);
; 373  : #else
; 374  : 				int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY());

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T223786[ebp], edx
	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T223790[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T223794[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T223798[ebp], edx
	mov	eax, DWORD PTR $T223786[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223790[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223794[ebp]
	push	edx
	mov	eax, DWORD PTR $T223798[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$222604[ebp], eax

; 375  : #endif
; 376  : #ifndef AUI_HEXSPACE_DX_LOOPS
; 377  : 				if (iDistance <= 7)

	cmp	DWORD PTR _iDistance$222604[ebp], 7
	jg	$LN88@PlotFoundV

; 378  : #endif
; 379  : 				{
; 380  : 					if ((pLoopPlot->getOwner() == NO_PLAYER) || (pLoopPlot->getOwner() == pPlayer->GetID()))

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	je	SHORT $LN85@PlotFoundV
	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T223854[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T223863[ebp], eax
	mov	ecx, DWORD PTR $T223854[ebp]
	cmp	ecx, DWORD PTR $T223863[ebp]
	jne	$LN86@PlotFoundV
$LN85@PlotFoundV:

; 381  : 					{
; 382  : 						// See if there are other cities nearby
; 383  : 						if (iClosestCityOfMine > iDistance)

	mov	edx, DWORD PTR _iClosestCityOfMine$[ebp]
	cmp	edx, DWORD PTR _iDistance$222604[ebp]
	jle	SHORT $LN84@PlotFoundV

; 384  : 						{
; 385  : 							if (pLoopPlot->isCity())

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN84@PlotFoundV

; 386  : 							{
; 387  : 								iClosestCityOfMine = iDistance;

	mov	ecx, DWORD PTR _iDistance$222604[ebp]
	mov	DWORD PTR _iClosestCityOfMine$[ebp], ecx
$LN84@PlotFoundV:

; 388  : 							}
; 389  : 						}
; 390  : 
; 391  : 						// Skip the city plot itself for now
; 392  : 						if (iDistance <= 5)

	cmp	DWORD PTR _iDistance$222604[ebp], 5
	jg	$LN82@PlotFoundV

; 393  : 						{
; 394  : 							int iRingModifier = m_iRingModifier[iDistance];

	mov	edx, DWORD PTR _iDistance$222604[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+40]
	mov	DWORD PTR _iRingModifier$222611[ebp], ecx

; 395  : 
; 396  : 							iFoodValue = 0;

	mov	DWORD PTR _iFoodValue$[ebp], 0

; 397  : 							iProductionValue = 0;

	mov	DWORD PTR _iProductionValue$[ebp], 0

; 398  : 							iGoldValue = 0;

	mov	DWORD PTR _iGoldValue$[ebp], 0

; 399  : 							iScienceValue = 0;

	mov	DWORD PTR _iScienceValue$[ebp], 0

; 400  : 							iHappinessValue = 0;

	mov	DWORD PTR _iHappinessValue$[ebp], 0

; 401  : 							iResourceValue = 0;

	mov	DWORD PTR _iResourceValue$[ebp], 0

; 402  : 							iStrategicValue = 0;

	mov	DWORD PTR _iStrategicValue$[ebp], 0

; 403  : 
; 404  : 							if (iDistance > 0 && iDistance <= NUM_CITY_RINGS)

	cmp	DWORD PTR _iDistance$222604[ebp], 0
	jle	$LN81@PlotFoundV
	cmp	DWORD PTR _iDistance$222604[ebp], 3
	jg	$LN81@PlotFoundV

; 405  : 							{
; 406  : 								if (eYield == NO_YIELD || eYield == YIELD_FOOD)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN79@PlotFoundV
	cmp	DWORD PTR _eYield$[ebp], 0
	jne	SHORT $LN80@PlotFoundV
$LN79@PlotFoundV:

; 407  : 								{
; 408  : 									iFoodValue = iRingModifier * ComputeFoodValue(pLoopPlot, pPlayer) * /*15*/ GC.getSETTLER_FOOD_MULTIPLIER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7196
	mov	DWORD PTR $T223872[ebp], edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	imul	eax, DWORD PTR _iRingModifier$222611[ebp]
	imul	eax, DWORD PTR $T223872[ebp]
	mov	DWORD PTR _iFoodValue$[ebp], eax
$LN80@PlotFoundV:

; 409  : 								}
; 410  : 								if (eYield == NO_YIELD || eYield == YIELD_PRODUCTION)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN77@PlotFoundV
	cmp	DWORD PTR _eYield$[ebp], 1
	jne	SHORT $LN78@PlotFoundV
$LN77@PlotFoundV:

; 411  : 								{
; 412  : 									iProductionValue = iRingModifier * ComputeProductionValue(pLoopPlot, pPlayer) * /*3*/ GC.getSETTLER_PRODUCTION_MULTIPLIER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7204
	mov	DWORD PTR $T223876[ebp], eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopPlot$222602[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222611[ebp]
	imul	eax, DWORD PTR $T223876[ebp]
	mov	DWORD PTR _iProductionValue$[ebp], eax
$LN78@PlotFoundV:

; 413  : 								}
; 414  : 								if (eYield == NO_YIELD || eYield == YIELD_GOLD)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN75@PlotFoundV
	cmp	DWORD PTR _eYield$[ebp], 2
	jne	SHORT $LN76@PlotFoundV
$LN75@PlotFoundV:

; 415  : 								{
; 416  : 									iGoldValue = iRingModifier * ComputeGoldValue(pLoopPlot, pPlayer) * /*2*/ GC.getSETTLER_GOLD_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7208
	mov	DWORD PTR $T223880[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222611[ebp]
	imul	eax, DWORD PTR $T223880[ebp]
	mov	DWORD PTR _iGoldValue$[ebp], eax
$LN76@PlotFoundV:

; 417  : 								}
; 418  : 								if (eYield == NO_YIELD || eYield == YIELD_SCIENCE)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN73@PlotFoundV
	cmp	DWORD PTR _eYield$[ebp], 3
	jne	SHORT $LN74@PlotFoundV
$LN73@PlotFoundV:

; 419  : 								{
; 420  : 									iScienceValue = iRingModifier * ComputeScienceValue(pLoopPlot, pPlayer) * /*1*/ GC.getSETTLER_SCIENCE_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7212
	mov	DWORD PTR $T223884[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222611[ebp]
	imul	eax, DWORD PTR $T223884[ebp]
	mov	DWORD PTR _iScienceValue$[ebp], eax
$LN74@PlotFoundV:

; 421  : 								}
; 422  : 								if (eYield == NO_YIELD || eYield == YIELD_FAITH)

	cmp	DWORD PTR _eYield$[ebp], -1
	je	SHORT $LN71@PlotFoundV
	cmp	DWORD PTR _eYield$[ebp], 5
	jne	SHORT $LN81@PlotFoundV
$LN71@PlotFoundV:

; 423  : 								{
; 424  : 									iFaithValue = iRingModifier * ComputeFaithValue(pLoopPlot, pPlayer) * /*1*/ GC.getSETTLER_FAITH_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7216
	mov	DWORD PTR $T223888[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222611[ebp]
	imul	eax, DWORD PTR $T223888[ebp]
	mov	DWORD PTR _iFaithValue$[ebp], eax
$LN81@PlotFoundV:

; 425  : 								}
; 426  : 							}
; 427  : 
; 428  : 							// whether or not we are working these we get the benefit as long as culture can grow to take them
; 429  : 							if (iDistance <= 5 && pLoopPlot->getOwner() == NO_PLAYER) // there is no benefit if we already own these tiles

	cmp	DWORD PTR _iDistance$222604[ebp], 5
	jg	$LN70@PlotFoundV
	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	jne	$LN70@PlotFoundV

; 430  : 							{
; 431  : 								iHappinessValue = iRingModifier * ComputeHappinessValue(pLoopPlot, pPlayer) * /*6*/ GC.getSETTLER_HAPPINESS_MULTIPLIER();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7200
	mov	DWORD PTR $T223895[ebp], eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLoopPlot$222602[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222611[ebp]
	imul	eax, DWORD PTR $T223895[ebp]
	mov	DWORD PTR _iHappinessValue$[ebp], eax

; 432  : 								iResourceValue = iRingModifier * ComputeTradeableResourceValue(pLoopPlot, pPlayer) * /*1*/ GC.getSETTLER_RESOURCE_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7220
	mov	DWORD PTR $T223899[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222611[ebp]
	imul	eax, DWORD PTR $T223899[ebp]
	mov	DWORD PTR _iResourceValue$[ebp], eax

; 433  : 								if (iDistance)

	cmp	DWORD PTR _iDistance$222604[ebp], 0
	je	SHORT $LN70@PlotFoundV

; 434  : 									iStrategicValue = ComputeStrategicValue(pLoopPlot, pPlayer, iDistance) * /*1*/ GC.getSETTLER_STRATEGIC_MULTIPLIER();  // the ring is included in the computation

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7224
	mov	DWORD PTR $T223903[ebp], ecx
	mov	edx, DWORD PTR _iDistance$222604[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	imul	eax, DWORD PTR $T223903[ebp]
	mov	DWORD PTR _iStrategicValue$[ebp], eax
$LN70@PlotFoundV:

; 435  : 							}
; 436  : 
; 437  : 							iTotalFoodValue += iFoodValue;

	mov	eax, DWORD PTR _iTotalFoodValue$[ebp]
	add	eax, DWORD PTR _iFoodValue$[ebp]
	mov	DWORD PTR _iTotalFoodValue$[ebp], eax

; 438  : 							iTotalHappinessValue += iHappinessValue;

	mov	ecx, DWORD PTR _iTotalHappinessValue$[ebp]
	add	ecx, DWORD PTR _iHappinessValue$[ebp]
	mov	DWORD PTR _iTotalHappinessValue$[ebp], ecx

; 439  : 							iTotalProductionValue += iProductionValue;

	mov	edx, DWORD PTR _iTotalProductionValue$[ebp]
	add	edx, DWORD PTR _iProductionValue$[ebp]
	mov	DWORD PTR _iTotalProductionValue$[ebp], edx

; 440  : 							iTotalGoldValue += iGoldValue;

	mov	eax, DWORD PTR _iTotalGoldValue$[ebp]
	add	eax, DWORD PTR _iGoldValue$[ebp]
	mov	DWORD PTR _iTotalGoldValue$[ebp], eax

; 441  : 							iTotalScienceValue += iScienceValue;

	mov	ecx, DWORD PTR _iTotalScienceValue$[ebp]
	add	ecx, DWORD PTR _iScienceValue$[ebp]
	mov	DWORD PTR _iTotalScienceValue$[ebp], ecx

; 442  : 							iTotalFaithValue += iFaithValue;

	mov	edx, DWORD PTR _iTotalFaithValue$[ebp]
	add	edx, DWORD PTR _iFaithValue$[ebp]
	mov	DWORD PTR _iTotalFaithValue$[ebp], edx

; 443  : 							iTotalResourceValue += iResourceValue;

	mov	eax, DWORD PTR _iTotalResourceValue$[ebp]
	add	eax, DWORD PTR _iResourceValue$[ebp]
	mov	DWORD PTR _iTotalResourceValue$[ebp], eax

; 444  : 							iTotalStrategicValue += iStrategicValue;

	mov	ecx, DWORD PTR _iTotalStrategicValue$[ebp]
	add	ecx, DWORD PTR _iStrategicValue$[ebp]
	mov	DWORD PTR _iTotalStrategicValue$[ebp], ecx

; 445  : 
; 446  : 							int iPlotValue = iFoodValue + iHappinessValue + iProductionValue + iGoldValue + iScienceValue + iFaithValue + iResourceValue;

	mov	edx, DWORD PTR _iFoodValue$[ebp]
	add	edx, DWORD PTR _iHappinessValue$[ebp]
	add	edx, DWORD PTR _iProductionValue$[ebp]
	add	edx, DWORD PTR _iGoldValue$[ebp]
	add	edx, DWORD PTR _iScienceValue$[ebp]
	add	edx, DWORD PTR _iFaithValue$[ebp]
	add	edx, DWORD PTR _iResourceValue$[ebp]
	mov	DWORD PTR _iPlotValue$222625[ebp], edx

; 447  : 							
; 448  : 							if (iPlotValue == 0)

	jne	SHORT $LN68@PlotFoundV

; 449  : 							{
; 450  : 								// this tile is so bad it gets negatives
; 451  : 								iPlotValue -= iRingModifier * GC.getSETTLER_FOOD_MULTIPLIER() * 2;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7196
	mov	DWORD PTR $T223907[ebp], eax
	mov	ecx, DWORD PTR _iRingModifier$222611[ebp]
	imul	ecx, DWORD PTR $T223907[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _iPlotValue$222625[ebp]
	sub	edx, ecx
	mov	DWORD PTR _iPlotValue$222625[ebp], edx
$LN68@PlotFoundV:

; 452  : 							}
; 453  : 							iPlotValue += iStrategicValue;

	mov	eax, DWORD PTR _iPlotValue$222625[ebp]
	add	eax, DWORD PTR _iStrategicValue$[ebp]
	mov	DWORD PTR _iPlotValue$222625[ebp], eax

; 454  : 
; 455  : 							// if this tile is a NW boost the value just so that we force the AI to claim them (if we can work it)
; 456  : 							if (pLoopPlot->IsNaturalWonder() && iDistance > 0 && iDistance <= NUM_CITY_RINGS)

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	call	?IsNaturalWonder@CvPlot@@QBE_NXZ	; CvPlot::IsNaturalWonder
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN67@PlotFoundV
	cmp	DWORD PTR _iDistance$222604[ebp], 0
	jle	SHORT $LN67@PlotFoundV
	cmp	DWORD PTR _iDistance$222604[ebp], 3
	jg	SHORT $LN67@PlotFoundV

; 457  : 							{
; 458  : 								//iPlotValue += iPlotValue * 2 + 10;
; 459  : 								iPlotValue += iPlotValue * 2 + 500;

	mov	edx, DWORD PTR _iPlotValue$222625[ebp]
	mov	eax, DWORD PTR _iPlotValue$222625[ebp]
	lea	ecx, DWORD PTR [eax+edx*2+500]
	mov	DWORD PTR _iPlotValue$222625[ebp], ecx
$LN67@PlotFoundV:

; 460  : 							}
; 461  : 
; 462  : 							// lower value a lot if we already own this tile
; 463  : 							if (iPlotValue > 0 && pLoopPlot->getOwner() == pPlayer->GetID())

	cmp	DWORD PTR _iPlotValue$222625[ebp], 0
	jle	SHORT $LN66@PlotFoundV
	mov	edx, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T223911[ebp], eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T223920[ebp], edx
	mov	eax, DWORD PTR $T223911[ebp]
	cmp	eax, DWORD PTR $T223920[ebp]
	jne	SHORT $LN66@PlotFoundV

; 464  : 							{
; 465  : 								iPlotValue /= 4;

	mov	eax, DWORD PTR _iPlotValue$222625[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _iPlotValue$222625[ebp], eax
$LN66@PlotFoundV:

; 466  : 							}
; 467  : 
; 468  : 							// add this plot into the total
; 469  : 							rtnValue += iPlotValue;

	mov	ecx, DWORD PTR _rtnValue$[ebp]
	add	ecx, DWORD PTR _iPlotValue$222625[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx

; 470  : 
; 471  : 							FeatureTypes ePlotFeature = pLoopPlot->getFeatureType();

	mov	edx, DWORD PTR _pLoopPlot$222602[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$223926[ebp], al
	movsx	ecx, BYTE PTR _f$223926[ebp]
	mov	DWORD PTR _ePlotFeature$222629[ebp], ecx

; 472  : 							ImprovementTypes ePlotImprovement = pLoopPlot->getImprovementType();

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _ePlotImprovement$222630[ebp], eax

; 473  : 							ResourceTypes ePlotResource = pLoopPlot->getResourceType();

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _ePlotResource$222631[ebp], eax

; 474  : 
; 475  : 							if (ePlotFeature == FEATURE_FOREST)

	cmp	DWORD PTR _ePlotFeature$222629[ebp], 5
	jne	SHORT $LN65@PlotFoundV

; 476  : 							{
; 477  : 								if (iDistance <= 5)

	cmp	DWORD PTR _iDistance$222604[ebp], 5
	jg	SHORT $LN64@PlotFoundV

; 478  : 								{
; 479  : 									++iIroquoisForestCount;

	mov	edx, DWORD PTR _iIroquoisForestCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iIroquoisForestCount$[ebp], edx

; 480  : 									if (iDistance == 1)

	cmp	DWORD PTR _iDistance$222604[ebp], 1
	jne	SHORT $LN64@PlotFoundV

; 481  : 									{
; 482  : 										if (ePlotImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _ePlotImprovement$222630[ebp], -1
	jne	SHORT $LN64@PlotFoundV

; 483  : 										{
; 484  : 											++iCelticForestCount;

	mov	eax, DWORD PTR _iCelticForestCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCelticForestCount$[ebp], eax
$LN64@PlotFoundV:

; 485  : 										}
; 486  : 									}
; 487  : 								}
; 488  : 							}

	jmp	SHORT $LN61@PlotFoundV
$LN65@PlotFoundV:

; 489  : 							else if (ePlotFeature == FEATURE_JUNGLE)

	cmp	DWORD PTR _ePlotFeature$222629[ebp], 1
	jne	SHORT $LN60@PlotFoundV

; 490  : 							{
; 491  : 								if (iDistance <= NUM_CITY_RINGS)

	cmp	DWORD PTR _iDistance$222604[ebp], 3
	jg	SHORT $LN59@PlotFoundV

; 492  : 								{
; 493  : 									++iBrazilJungleCount;

	mov	ecx, DWORD PTR _iBrazilJungleCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBrazilJungleCount$[ebp], ecx
$LN59@PlotFoundV:

; 494  : 								}
; 495  : 							}

	jmp	SHORT $LN61@PlotFoundV
$LN60@PlotFoundV:

; 496  : 							else if (ePlotFeature == FEATURE_MARSH || ePlotFeature == FEATURE_FLOOD_PLAINS)

	cmp	DWORD PTR _ePlotFeature$222629[ebp], 2
	je	SHORT $LN56@PlotFoundV
	cmp	DWORD PTR _ePlotFeature$222629[ebp], 4
	jne	SHORT $LN61@PlotFoundV
$LN56@PlotFoundV:

; 497  : 							{
; 498  : 								if (iDistance <= NUM_CITY_RINGS)

	cmp	DWORD PTR _iDistance$222604[ebp], 3
	jg	SHORT $LN61@PlotFoundV

; 499  : 								{
; 500  : 									++iWetlandsCount;

	mov	edx, DWORD PTR _iWetlandsCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iWetlandsCount$[ebp], edx
$LN61@PlotFoundV:

; 501  : 								}
; 502  : 							}
; 503  : 
; 504  : 							if (pLoopPlot->IsNaturalWonder())

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	call	?IsNaturalWonder@CvPlot@@QBE_NXZ	; CvPlot::IsNaturalWonder
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN234@PlotFoundV

; 505  : 							{
; 506  : 								if (iDistance <= 1)

	cmp	DWORD PTR _iDistance$222604[ebp], 1
	jg	SHORT $LN234@PlotFoundV

; 507  : 								{
; 508  : 									++iNaturalWonderCount;

	mov	ecx, DWORD PTR _iNaturalWonderCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNaturalWonderCount$[ebp], ecx

; 509  : 								}
; 510  : 							}
; 511  : 
; 512  : 							if (pLoopPlot->getTerrainType() == TERRAIN_DESERT)

$LN234@PlotFoundV:
	mov	edx, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	eax, BYTE PTR [edx+6]
	cmp	eax, 2
	jne	SHORT $LN52@PlotFoundV

; 513  : 							{
; 514  : 								if (iDistance <= NUM_CITY_RINGS)

	cmp	DWORD PTR _iDistance$222604[ebp], 3
	jg	SHORT $LN52@PlotFoundV

; 515  : 								{
; 516  : 									if (ePlotResource == NO_RESOURCE)

	cmp	DWORD PTR _ePlotResource$222631[ebp], -1
	jne	SHORT $LN52@PlotFoundV

; 517  : 									{
; 518  : 										++iDesertCount;

	mov	ecx, DWORD PTR _iDesertCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDesertCount$[ebp], ecx
$LN52@PlotFoundV:

; 519  : 									}
; 520  : 								}
; 521  : 							}
; 522  : 
; 523  : 							if (bIsInca)

	movzx	edx, BYTE PTR _bIsInca$[ebp]
	test	edx, edx
	je	SHORT $LN82@PlotFoundV

; 524  : 							{
; 525  : 								if (pLoopPlot->isHills())

	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN82@PlotFoundV

; 526  : 								{
; 527  : 									if (iDistance <= NUM_CITY_RINGS)

	cmp	DWORD PTR _iDistance$222604[ebp], 3
	jg	SHORT $LN82@PlotFoundV

; 528  : 									{
; 529  : 										iAdjacentMountains = pLoopPlot->GetNumAdjacentMountains();

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	call	?GetNumAdjacentMountains@CvPlot@@QBEHXZ	; CvPlot::GetNumAdjacentMountains
	mov	DWORD PTR _iAdjacentMountains$[ebp], eax

; 530  : 										if (iAdjacentMountains > 0 && iAdjacentMountains < 6)

	cmp	DWORD PTR _iAdjacentMountains$[ebp], 0
	jle	SHORT $LN82@PlotFoundV
	cmp	DWORD PTR _iAdjacentMountains$[ebp], 6
	jge	SHORT $LN82@PlotFoundV

; 531  : 										{
; 532  : 											//give the bonus if it's hills, with additional if bordered by mountains
; 533  : 											rtnValue += m_iIncaMultiplier + (iAdjacentMountains * m_iIncaMultiplier);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iAdjacentMountains$[ebp]
	imul	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	add	eax, ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN82@PlotFoundV:

; 534  : 										}
; 535  : 									}
; 536  : 									
; 537  : 								}
; 538  : 							}
; 539  : 						}
; 540  : 					}
; 541  : 					else // this tile is owned by someone else

	jmp	SHORT $LN88@PlotFoundV
$LN86@PlotFoundV:

; 542  : 					{
; 543  : 						// See if there are other cities nearby (only count major civs)
; 544  : 						if (iClosestEnemyCity > iDistance)

	mov	ecx, DWORD PTR _iClosestEnemyCity$[ebp]
	cmp	ecx, DWORD PTR _iDistance$222604[ebp]
	jle	SHORT $LN88@PlotFoundV

; 545  : 						{
; 546  : 							if (pLoopPlot->isCity() && (pLoopPlot->getOwner() < MAX_MAJOR_CIVS))

	mov	ecx, DWORD PTR _pLoopPlot$222602[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN88@PlotFoundV
	mov	eax, DWORD PTR _pLoopPlot$222602[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 22					; 00000016H
	jge	SHORT $LN88@PlotFoundV

; 547  : 							{
; 548  : 								iClosestEnemyCity = iDistance;

	mov	edx, DWORD PTR _iDistance$222604[ebp]
	mov	DWORD PTR _iClosestEnemyCity$[ebp], edx
$LN88@PlotFoundV:

; 549  : 							}
; 550  : 						}
; 551  : 					}
; 552  : 				}
; 553  : 			}
; 554  : 		}

	jmp	$LN90@PlotFoundV
$LN89@PlotFoundV:

; 555  : 	}

	jmp	$LN93@PlotFoundV
$LN92@PlotFoundV:

; 556  : 
; 557  : 	if (pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T223947[ebp], eax
	mov	eax, DWORD PTR $T223947[ebp]
	mov	cl, BYTE PTR [eax+341]
	mov	BYTE PTR $T223948[ebp], cl
	movzx	edx, BYTE PTR $T223948[ebp]
	test	edx, edx
	je	SHORT $LN42@PlotFoundV

; 558  : 	{
; 559  : 		if (iCelticForestCount >= 3)

	cmp	DWORD PTR _iCelticForestCount$[ebp], 3
	jl	SHORT $LN41@PlotFoundV

; 560  : 		{
; 561  : 			rtnValue += 2 * 1000 * m_iFlavorMultiplier[YIELD_FAITH];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 2000				; 000007d0H
	add	ecx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx
	jmp	SHORT $LN40@PlotFoundV
$LN41@PlotFoundV:

; 562  : 		}
; 563  : 		else if (iCelticForestCount >= 1)

	cmp	DWORD PTR _iCelticForestCount$[ebp], 1
	jl	SHORT $LN40@PlotFoundV

; 564  : 		{
; 565  : 			rtnValue += 1 * 1000 * m_iFlavorMultiplier[YIELD_FAITH];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	imul	eax, 1000				; 000003e8H
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN40@PlotFoundV:

; 566  : 		}
; 567  : 	}

	jmp	SHORT $LN38@PlotFoundV
$LN42@PlotFoundV:

; 568  : 	else if (pPlayer->GetPlayerTraits()->IsMoveFriendlyWoodsAsRoad())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T223952[ebp], eax
	mov	ecx, DWORD PTR $T223952[ebp]
	mov	dl, BYTE PTR [ecx+333]
	mov	BYTE PTR $T223953[ebp], dl
	movzx	eax, BYTE PTR $T223953[ebp]
	test	eax, eax
	je	SHORT $LN37@PlotFoundV

; 569  : 	{
; 570  : 		rtnValue += iIroquoisForestCount * 10;	

	mov	ecx, DWORD PTR _iIroquoisForestCount$[ebp]
	imul	ecx, 10					; 0000000aH
	add	ecx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx
	jmp	SHORT $LN38@PlotFoundV
$LN37@PlotFoundV:

; 571  : 	}
; 572  : 	else if (pPlayer->GetPlayerTraits()->GetNaturalWonderYieldModifier() > 0)	//ie: Spain

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T223957[ebp], eax
	mov	edx, DWORD PTR $T223957[ebp]
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR $T223958[ebp], eax
	cmp	DWORD PTR $T223958[ebp], 0
	jle	SHORT $LN38@PlotFoundV

; 573  : 	{
; 574  : 		rtnValue += iNaturalWonderCount * m_iSpainMultiplier;	

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iNaturalWonderCount$[ebp]
	imul	edx, DWORD PTR [ecx+88]
	add	edx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], edx
$LN38@PlotFoundV:

; 575  : 	}
; 576  : 
; 577  : 	// Custom code for Brazil
; 578  : 	ImprovementTypes eBrazilImprovement = (ImprovementTypes)GC.getInfoTypeForString("IMPROVEMENT_BRAZILWOOD_CAMP", true);  

	push	1
	push	OFFSET ??_C@_0BM@EBHADHKI@IMPROVEMENT_BRAZILWOOD_CAMP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eBrazilImprovement$[ebp], eax

; 579  : 	if(eBrazilImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eBrazilImprovement$[ebp], -1
	je	SHORT $LN34@PlotFoundV

; 580  : 	{
; 581  : 		CvImprovementEntry* pkEntry = GC.getImprovementInfo(eBrazilImprovement);

	mov	eax, DWORD PTR _eBrazilImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkEntry$222667[ebp], eax

; 582  : 		if(pkEntry != NULL && pkEntry->IsSpecificCivRequired())

	cmp	DWORD PTR _pkEntry$222667[ebp], 0
	je	SHORT $LN34@PlotFoundV
	mov	ecx, DWORD PTR _pkEntry$222667[ebp]
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@PlotFoundV

; 583  : 		{
; 584  : 			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();

	mov	ecx, DWORD PTR _pkEntry$222667[ebp]
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
	mov	DWORD PTR _eCiv$222669[ebp], eax

; 585  : 			if(eCiv == pPlayer->getCivilizationType())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	DWORD PTR _eCiv$222669[ebp], eax
	jne	SHORT $LN34@PlotFoundV

; 586  : 			{
; 587  : 				rtnValue += iBrazilJungleCount * m_iBrazilMultiplier;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iBrazilJungleCount$[ebp]
	imul	eax, DWORD PTR [edx+84]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN34@PlotFoundV:

; 588  : 			}
; 589  : 		}
; 590  : 	}
; 591  : 
; 592  : 	// Custom code for Morocco
; 593  : 	ImprovementTypes eMoroccoImprovement = (ImprovementTypes)GC.getInfoTypeForString("IMPROVEMENT_KASBAH", true);  

	push	1
	push	OFFSET ??_C@_0BD@LECKMJLO@IMPROVEMENT_KASBAH?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eMoroccoImprovement$[ebp], eax

; 594  : 	if(eMoroccoImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _eMoroccoImprovement$[ebp], -1
	je	SHORT $LN31@PlotFoundV

; 595  : 	{
; 596  : 		CvImprovementEntry* pkEntry = GC.getImprovementInfo(eMoroccoImprovement);

	mov	ecx, DWORD PTR _eMoroccoImprovement$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkEntry$222675[ebp], eax

; 597  : 		if(pkEntry != NULL && pkEntry->IsSpecificCivRequired())

	cmp	DWORD PTR _pkEntry$222675[ebp], 0
	je	SHORT $LN31@PlotFoundV
	mov	ecx, DWORD PTR _pkEntry$222675[ebp]
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN31@PlotFoundV

; 598  : 		{
; 599  : 			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();

	mov	ecx, DWORD PTR _pkEntry$222675[ebp]
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
	mov	DWORD PTR _eCiv$222677[ebp], eax

; 600  : 			if(eCiv == pPlayer->getCivilizationType())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	DWORD PTR _eCiv$222677[ebp], eax
	jne	SHORT $LN31@PlotFoundV

; 601  : 			{
; 602  : 				rtnValue += iDesertCount * m_iMorrocoMultiplier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iDesertCount$[ebp]
	imul	ecx, DWORD PTR [eax+92]
	add	ecx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx
$LN31@PlotFoundV:

; 603  : 			}
; 604  : 		}
; 605  : 	}
; 606  : 
; 607  : 	//Custom code for Netherlands
; 608  : 	ImprovementTypes ePolderImprovement = (ImprovementTypes)GC.getInfoTypeForString("IMPROVEMENT_POLDER", true);  

	push	1
	push	OFFSET ??_C@_0BD@JLAGGNHC@IMPROVEMENT_POLDER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _ePolderImprovement$[ebp], eax

; 609  : 	if(ePolderImprovement != NO_IMPROVEMENT)

	cmp	DWORD PTR _ePolderImprovement$[ebp], -1
	je	SHORT $LN28@PlotFoundV

; 610  : 	{
; 611  : 		CvImprovementEntry* pkEntry = GC.getImprovementInfo(ePolderImprovement);

	mov	edx, DWORD PTR _ePolderImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	DWORD PTR _pkEntry$222683[ebp], eax

; 612  : 		if(pkEntry != NULL && pkEntry->IsSpecificCivRequired())

	cmp	DWORD PTR _pkEntry$222683[ebp], 0
	je	SHORT $LN28@PlotFoundV
	mov	ecx, DWORD PTR _pkEntry$222683[ebp]
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN28@PlotFoundV

; 613  : 		{
; 614  : 			CivilizationTypes eCiv = pkEntry->GetRequiredCivilization();

	mov	ecx, DWORD PTR _pkEntry$222683[ebp]
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
	mov	DWORD PTR _eCiv$222685[ebp], eax

; 615  : 			if(eCiv == pPlayer->getCivilizationType())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	DWORD PTR _eCiv$222685[ebp], eax
	jne	SHORT $LN28@PlotFoundV

; 616  : 			{
; 617  : 				rtnValue += iWetlandsCount * m_iNetherlandsMultiplier;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iWetlandsCount$[ebp]
	imul	edx, DWORD PTR [ecx+96]
	add	edx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], edx
$LN28@PlotFoundV:

; 618  : 			}
; 619  : 		}
; 620  : 	}
; 621  : 
; 622  : 	if (rtnValue < 0) rtnValue = 0;

	cmp	DWORD PTR _rtnValue$[ebp], 0
	jge	SHORT $LN253@PlotFoundV
	mov	DWORD PTR _rtnValue$[ebp], 0

; 623  : 
; 624  : 	// Finally, look at the city plot itself and use it as an overall multiplier
; 625  : 	if (pPlot->getResourceType(pPlayer->getTeam()) != NO_RESOURCE)

$LN253@PlotFoundV:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223967[ebp], eax
	mov	edx, DWORD PTR $T223967[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN257@PlotFoundV

; 626  : 	{
; 627  : 		rtnValue += (int)rtnValue * /*-50*/ GC.getBUILD_ON_RESOURCE_PERCENT() / 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7260
	mov	DWORD PTR $T223971[ebp], eax
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR $T223971[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 628  : 	}
; 629  : 
; 630  : 	if (pPlot->isRiver())

$LN257@PlotFoundV:
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+457]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN23@PlotFoundV

; 631  : 	{
; 632  : 		rtnValue += (int)rtnValue * /*15*/ GC.getBUILD_ON_RIVER_PERCENT() / 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7264
	mov	DWORD PTR $T223978[ebp], eax
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR $T223978[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN23@PlotFoundV:

; 633  : 	}
; 634  : 
; 635  : 	if (pPlot->isCoastalLand(GC.getMIN_WATER_SIZE_FOR_OCEAN()))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6876
	mov	DWORD PTR $T223982[ebp], edx
	mov	eax, DWORD PTR $T223982[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	ecx, al
	test	ecx, ecx
	je	$LN22@PlotFoundV

; 636  : 	{
; 637  : 		// okay, coast used to have lots of gold so players settled there "naturally", it doesn't any more, so I am going to give it a nudge in that direction
; 638  : 		// slewis - removed Brian(?)'s rtnValue adjustment and raised the BUILD_ON_COAST_PERCENT to 40 from 25
; 639  : 		//rtnValue += rtnValue > 0 ? 10 : 0;
; 640  : 		rtnValue += (int)rtnValue * /*40*/ GC.getSETTLER_BUILD_ON_COAST_PERCENT() / 100;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7228
	mov	DWORD PTR $T223986[ebp], edx
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR $T223986[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 641  : 		int iNavalFlavor = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)m_iNavalIndex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iNavalFlavor$222694[ebp], eax

; 642  : 		if (iNavalFlavor > 7)

	cmp	DWORD PTR _iNavalFlavor$222694[ebp], 7
	jle	SHORT $LN21@PlotFoundV

; 643  : 		{
; 644  : 			rtnValue += (int)rtnValue * /*40*/ GC.getSETTLER_BUILD_ON_COAST_PERCENT() / 100;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7228
	mov	DWORD PTR $T223990[ebp], ecx
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR $T223990[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN21@PlotFoundV:

; 645  : 		}
; 646  : 		if (pPlayer->getCivilizationInfo().isCoastalCiv()) // we really like the coast (England, Norway, Polynesia, Carthage, etc.)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?isCoastalCiv@CvCivilizationInfo@@QBE_NXZ ; CvCivilizationInfo::isCoastalCiv
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN22@PlotFoundV

; 647  : 		{
; 648  : 			rtnValue += rtnValue > 0 ? 25 : 0;

	xor	eax, eax
	cmp	DWORD PTR _rtnValue$[ebp], 0
	setle	al
	sub	eax, 1
	and	eax, 25					; 00000019H
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 649  : 			rtnValue *= 2;

	mov	ecx, DWORD PTR _rtnValue$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _rtnValue$[ebp], ecx
$LN22@PlotFoundV:

; 650  : 		}
; 651  : 	}
; 652  : 
; 653  : 	// Nearby Cities?
; 654  : 
; 655  : 	// Human
; 656  : #ifdef AUI_WARNING_FIXES
; 657  : 	if (pPlayer->isHuman())
; 658  : #else
; 659  : 	if (pPlayer != NULL && pPlayer->isHuman())

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN19@PlotFoundV
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN19@PlotFoundV

; 660  : #endif
; 661  : 	{
; 662  : 		if (iClosestCityOfMine == 3)

	cmp	DWORD PTR _iClosestCityOfMine$[ebp], 3
	jne	SHORT $LN18@PlotFoundV

; 663  : 		{
; 664  : 			rtnValue /= 2;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN18@PlotFoundV:

; 665  : 		}
; 666  : 	}
; 667  : 	// AI
; 668  : 	else

	jmp	$LN17@PlotFoundV
$LN19@PlotFoundV:

; 669  : 	{
; 670  : 		int iGrowthFlavor = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)m_iGrowthIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iGrowthFlavor$222702[ebp], eax

; 671  : 		int iExpansionFlavor = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)m_iExpansionIndex);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iExpansionFlavor$222704[ebp], eax

; 672  : 
; 673  : 		int iSweetSpot = 5;

	mov	DWORD PTR _iSweetSpot$222706[ebp], 5

; 674  : 		iSweetSpot += (iGrowthFlavor > 7) ?  1 : 0;

	xor	ecx, ecx
	cmp	DWORD PTR _iGrowthFlavor$222702[ebp], 7
	setg	cl
	add	ecx, DWORD PTR _iSweetSpot$222706[ebp]
	mov	DWORD PTR _iSweetSpot$222706[ebp], ecx

; 675  : 		iSweetSpot += (iExpansionFlavor > 7) ?  -1 : 0;

	xor	edx, edx
	cmp	DWORD PTR _iExpansionFlavor$222704[ebp], 7
	setle	dl
	sub	edx, 1
	add	edx, DWORD PTR _iSweetSpot$222706[ebp]
	mov	DWORD PTR _iSweetSpot$222706[ebp], edx

; 676  : 		iSweetSpot += (iGrowthFlavor < 4) ?  -1 : 0;

	xor	eax, eax
	cmp	DWORD PTR _iGrowthFlavor$222702[ebp], 4
	setge	al
	sub	eax, 1
	add	eax, DWORD PTR _iSweetSpot$222706[ebp]
	mov	DWORD PTR _iSweetSpot$222706[ebp], eax

; 677  : 		iSweetSpot += (iExpansionFlavor < 4) ?  1 : 0;

	xor	ecx, ecx
	cmp	DWORD PTR _iExpansionFlavor$222704[ebp], 4
	setl	cl
	add	ecx, DWORD PTR _iSweetSpot$222706[ebp]
	mov	DWORD PTR _iSweetSpot$222706[ebp], ecx

; 678  : 		iSweetSpot = max(4,iSweetSpot);

	mov	DWORD PTR $T223665[ebp], 4
	mov	edx, DWORD PTR $T223665[ebp]
	cmp	edx, DWORD PTR _iSweetSpot$222706[ebp]
	jge	SHORT $LN269@PlotFoundV
	lea	eax, DWORD PTR _iSweetSpot$222706[ebp]
	mov	DWORD PTR tv696[ebp], eax
	jmp	SHORT $LN270@PlotFoundV
$LN269@PlotFoundV:
	lea	ecx, DWORD PTR $T223665[ebp]
	mov	DWORD PTR tv696[ebp], ecx
$LN270@PlotFoundV:
	mov	edx, DWORD PTR tv696[ebp]
	mov	DWORD PTR $T223997[ebp], edx
	mov	eax, DWORD PTR $T223997[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iSweetSpot$222706[ebp], ecx

; 679  : 		iSweetSpot = min(6,iSweetSpot);

	mov	DWORD PTR $T223666[ebp], 6
	mov	edx, DWORD PTR _iSweetSpot$222706[ebp]
	cmp	edx, DWORD PTR $T223666[ebp]
	jge	SHORT $LN273@PlotFoundV
	lea	eax, DWORD PTR _iSweetSpot$222706[ebp]
	mov	DWORD PTR tv582[ebp], eax
	jmp	SHORT $LN274@PlotFoundV
$LN273@PlotFoundV:
	lea	ecx, DWORD PTR $T223666[ebp]
	mov	DWORD PTR tv582[ebp], ecx
$LN274@PlotFoundV:
	mov	edx, DWORD PTR tv582[ebp]
	mov	DWORD PTR $T224006[ebp], edx
	mov	eax, DWORD PTR $T224006[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iSweetSpot$222706[ebp], ecx

; 680  : 
; 681  : 		if (iClosestCityOfMine == iSweetSpot) 

	mov	edx, DWORD PTR _iClosestCityOfMine$[ebp]
	cmp	edx, DWORD PTR _iSweetSpot$222706[ebp]
	jne	SHORT $LN16@PlotFoundV

; 682  : 		{
; 683  : 			// 1.5 was not enough 2.0 was too much, so lets split the difference
; 684  : 			rtnValue *= 175;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, 175				; 000000afH
	mov	DWORD PTR _rtnValue$[ebp], eax

; 685  : 			rtnValue /= 100;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _rtnValue$[ebp], eax
	jmp	SHORT $LN15@PlotFoundV
$LN16@PlotFoundV:

; 686  : 		}
; 687  : 		else if (iClosestCityOfMine < iSweetSpot)

	mov	edx, DWORD PTR _iClosestCityOfMine$[ebp]
	cmp	edx, DWORD PTR _iSweetSpot$222706[ebp]
	jge	SHORT $LN14@PlotFoundV

; 688  : 		{
; 689  : 			rtnValue /= 2;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax
	jmp	SHORT $LN15@PlotFoundV
$LN14@PlotFoundV:

; 690  : 		}
; 691  : 		else if (iClosestCityOfMine > 7)

	cmp	DWORD PTR _iClosestCityOfMine$[ebp], 7
	jle	SHORT $LN15@PlotFoundV

; 692  : 		{
; 693  : 			rtnValue *= 2;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	shl	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax

; 694  : 			rtnValue /= 3;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN15@PlotFoundV:

; 695  : 		}
; 696  : 
; 697  : 		// use boldness to decide if we want to push close to enemies
; 698  : 		int iBoldness = pPlayer->GetDiplomacyAI()->GetBoldness();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	mov	DWORD PTR _iBoldness$222719[ebp], eax

; 699  : 		if (iBoldness < 4)

	cmp	DWORD PTR _iBoldness$222719[ebp], 4
	jge	SHORT $LN11@PlotFoundV

; 700  : 		{
; 701  : 			if (iClosestEnemyCity <= 4)

	cmp	DWORD PTR _iClosestEnemyCity$[ebp], 4
	jg	SHORT $LN10@PlotFoundV

; 702  : 			{
; 703  : 				rtnValue /= 4;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _rtnValue$[ebp], eax
	jmp	SHORT $LN9@PlotFoundV
$LN10@PlotFoundV:

; 704  : 			}
; 705  : 			else if (iClosestEnemyCity == 5)

	cmp	DWORD PTR _iClosestEnemyCity$[ebp], 5
	jne	SHORT $LN9@PlotFoundV

; 706  : 			{
; 707  : 				rtnValue /= 2;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN9@PlotFoundV:

; 708  : 			}
; 709  : 		}

	jmp	SHORT $LN7@PlotFoundV
$LN11@PlotFoundV:

; 710  : 		else if (iBoldness > 7)

	cmp	DWORD PTR _iBoldness$222719[ebp], 7
	jle	SHORT $LN6@PlotFoundV

; 711  : 		{
; 712  : 			if (iClosestEnemyCity <= 5 && iClosestCityOfMine < 8)

	cmp	DWORD PTR _iClosestEnemyCity$[ebp], 5
	jg	SHORT $LN5@PlotFoundV
	cmp	DWORD PTR _iClosestCityOfMine$[ebp], 8
	jge	SHORT $LN5@PlotFoundV

; 713  : 			{
; 714  : 				rtnValue *= 3;

	mov	edx, DWORD PTR _rtnValue$[ebp]
	imul	edx, 3
	mov	DWORD PTR _rtnValue$[ebp], edx

; 715  : 				rtnValue /= 2;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN5@PlotFoundV:

; 716  : 			}
; 717  : 		}
; 718  : 		else

	jmp	SHORT $LN7@PlotFoundV
$LN6@PlotFoundV:

; 719  : 		{
; 720  : 			if (iClosestEnemyCity < 5)

	cmp	DWORD PTR _iClosestEnemyCity$[ebp], 5
	jge	SHORT $LN7@PlotFoundV

; 721  : 			{
; 722  : 				rtnValue *= 2;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	shl	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax

; 723  : 				rtnValue /= 3;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN7@PlotFoundV:

; 724  : 			}
; 725  : 		}
; 726  : 
; 727  : 		// if we are offshore, pull cities in tighter
; 728  : 		if (iCapitalArea != pPlot->getArea())

	mov	edx, DWORD PTR _pPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T224012[ebp], eax
	mov	ecx, DWORD PTR _iCapitalArea$[ebp]
	cmp	ecx, DWORD PTR $T224012[ebp]
	je	SHORT $LN17@PlotFoundV

; 729  : 		{
; 730  : 			if (iClosestCityOfMine < 7)

	cmp	DWORD PTR _iClosestCityOfMine$[ebp], 7
	jge	SHORT $LN17@PlotFoundV

; 731  : 			{
; 732  : 				rtnValue *= 3;

	mov	edx, DWORD PTR _rtnValue$[ebp]
	imul	edx, 3
	mov	DWORD PTR _rtnValue$[ebp], edx

; 733  : 				rtnValue /= 2;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN17@PlotFoundV:

; 734  : 			}
; 735  : 		}
; 736  : 	}
; 737  : 
; 738  : 	rtnValue = (rtnValue > 0) ? rtnValue : 0;

	xor	eax, eax
	cmp	DWORD PTR _rtnValue$[ebp], 0
	setle	al
	sub	eax, 1
	and	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 739  : 
; 740  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]
$LN101@PlotFoundV:

; 741  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PlotFoundValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ENDP ; CvCitySiteEvaluator::PlotFoundValue
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T224096 = -80						; size = 4
$T224069 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T224069[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T224069[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T224069[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T224096[ebp], edx
	mov	eax, DWORD PTR $T224096[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T224119 = -16						; size = 4
$T224111 = -12						; size = 4
$T224107 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T224107[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224111[ebp], ecx
	movzx	edx, BYTE PTR $T224107[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T224111[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T224111[ebp]
	mov	DWORD PTR $T224119[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T224111[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T224111[ebp]
	mov	DWORD PTR $T224119[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T224119[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T224119[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T224140 = -16						; size = 4
$T224132 = -12						; size = 4
$T224128 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T224128[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T224132[ebp], ecx
	movzx	edx, BYTE PTR $T224128[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T224132[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T224132[ebp]
	mov	DWORD PTR $T224140[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T224132[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T224132[ebp]
	mov	DWORD PTR $T224140[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T224140[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T224140[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvsiteevaluationclasses.cpp
_TEXT	ENDS
;	COMDAT ?PlotFertilityValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rtnValue$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?PlotFertilityValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@@Z PROC ; CvCitySiteEvaluator::PlotFertilityValue, COMDAT
; _this$ = ecx

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 746  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 747  : 
; 748  : 	if(!pPlot->isWater() && !pPlot->isImpassable() && !pPlot->isMountain())

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	$LN2@PlotFertil
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	$LN2@PlotFertil
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN2@PlotFertil

; 749  : 	{
; 750  : 		rtnValue += ComputeFoodValue(pPlot, NULL);

	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 751  : 		rtnValue += ComputeProductionValue(pPlot, NULL);

	push	0
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 752  : 		rtnValue += ComputeGoldValue(pPlot, NULL);

	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 753  : 		rtnValue += ComputeScienceValue(pPlot, NULL);

	push	0
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 754  : 		rtnValue += ComputeTradeableResourceValue(pPlot, NULL);

	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+48]
	call	edx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN2@PlotFertil:

; 755  : 	}
; 756  : 
; 757  : 	if(rtnValue < 0) rtnValue = 0;

	cmp	DWORD PTR _rtnValue$[ebp], 0
	jge	SHORT $LN1@PlotFertil
	mov	DWORD PTR _rtnValue$[ebp], 0
$LN1@PlotFertil:

; 758  : 
; 759  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PlotFertilityValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@@Z ENDP ; CvCitySiteEvaluator::PlotFertilityValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?BestFoundValueForSpecificYield@CvCitySiteEvaluator@@UAEHPAVCvPlayer@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pPlayer$ = 8						; size = 4
_eYield$ = 12						; size = 4
?BestFoundValueForSpecificYield@CvCitySiteEvaluator@@UAEHPAVCvPlayer@@W4YieldTypes@@@Z PROC ; CvCitySiteEvaluator::BestFoundValueForSpecificYield, COMDAT
; _this$ = ecx

; 764  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 	pPlayer;
; 766  : 	eYield;
; 767  : 	return 0;

	xor	eax, eax

; 768  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?BestFoundValueForSpecificYield@CvCitySiteEvaluator@@UAEHPAVCvPlayer@@W4YieldTypes@@@Z ENDP ; CvCitySiteEvaluator::BestFoundValueForSpecificYield
_TEXT	ENDS
EXTRN	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z:PROC ; CvImprovementEntry::GetImprovementResourceYield
EXTRN	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z:PROC ; CvImprovementXMLEntries::GetImprovementForResource
EXTRN	?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ:PROC ; CvGlobals::GetGameImprovements
EXTRN	?getYieldChange@CvResourceInfo@@QBEHH@Z:PROC	; CvResourceInfo::getYieldChange
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z:PROC ; CvPlot::calculateNatureYield
; Function compile flags: /Odtp
;	COMDAT ?ComputeFoodValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224164 = -20						; size = 4
_pImprovement$222755 = -16				; size = 4
_rtnValue$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_eResource$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?ComputeFoodValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeFoodValue, COMDAT
; _this$ = ecx

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 776  : 
; 777  : 	// From tile yield
; 778  : 	if(pPlayer == NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $LN10@ComputeFoo

; 779  : 	{
; 780  : 		rtnValue += pPlot->calculateNatureYield(YIELD_FOOD, NO_TEAM);

	push	0
	push	-1
	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 781  : 	}
; 782  : 	else

	jmp	SHORT $LN4@ComputeFoo

; 783  : 	{
; 784  : 		rtnValue += pPlot->calculateNatureYield(YIELD_FOOD, pPlayer->getTeam());

$LN10@ComputeFoo:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224164[ebp], eax
	push	0
	mov	edx, DWORD PTR $T224164[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN4@ComputeFoo:

; 785  : 	}
; 786  : 
; 787  : 	// From resource
; 788  : 	TeamTypes eTeam = NO_TEAM;

	mov	DWORD PTR _eTeam$[ebp], -1

; 789  : 	if(pPlayer != NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN3@ComputeFoo

; 790  : 	{
; 791  : 		eTeam = pPlayer->getTeam();

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax
$LN3@ComputeFoo:

; 792  : 	}
; 793  : 
; 794  : 	ResourceTypes eResource;
; 795  : 	eResource = pPlot->getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 796  : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN2@ComputeFoo

; 797  : 	{
; 798  : 		rtnValue += GC.getResourceInfo(eResource)->getYieldChange(YIELD_FOOD);

	push	0
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getYieldChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getYieldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 799  : 
; 800  : 		CvImprovementEntry* pImprovement = GC.GetGameImprovements()->GetImprovementForResource(eResource);

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ ; CvGlobals::GetGameImprovements
	mov	ecx, eax
	call	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetImprovementForResource
	mov	DWORD PTR _pImprovement$222755[ebp], eax

; 801  : 		if(pImprovement)

	cmp	DWORD PTR _pImprovement$222755[ebp], 0
	je	SHORT $LN2@ComputeFoo

; 802  : 		{
; 803  : 			rtnValue += pImprovement->GetImprovementResourceYield(eResource, YIELD_FOOD);

	push	0
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$222755[ebp]
	call	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN2@ComputeFoo:

; 804  : 		}
; 805  : 	}
; 806  : 
; 807  : 	return rtnValue * m_iFlavorMultiplier[YIELD_FOOD];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rtnValue$[ebp]
	imul	ecx, DWORD PTR [eax+4]
	mov	eax, ecx

; 808  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeFoodValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeFoodValue
_TEXT	ENDS
EXTRN	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z:PROC ; CvPlayer::getNumResourceTotal
EXTRN	?getHappiness@CvResourceInfo@@QBEHXZ:PROC	; CvResourceInfo::getHappiness
; Function compile flags: /Odtp
;	COMDAT ?ComputeHappinessValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_rtnValue$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_eResource$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?ComputeHappinessValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeHappinessValue, COMDAT
; _this$ = ecx

; 812  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 813  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 814  : 
; 815  : 	// From resource
; 816  : 	TeamTypes eTeam = NO_TEAM;

	mov	DWORD PTR _eTeam$[ebp], -1

; 817  : 	if(pPlayer != NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN5@ComputeHap

; 818  : 	{
; 819  : 		eTeam = pPlayer->getTeam();

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax
$LN5@ComputeHap:

; 820  : 	}
; 821  : 
; 822  : 	ResourceTypes eResource;
; 823  : 	eResource = pPlot->getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 824  : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN4@ComputeHap

; 825  : 	{
; 826  : 		// Add a bonus if adds Happiness
; 827  : 		if(!pPlot->isOwned())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ComputeHap

; 828  : 		{
; 829  : 			rtnValue += GC.getResourceInfo(eResource)->getHappiness();

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getHappiness@CvResourceInfo@@QBEHXZ	; CvResourceInfo::getHappiness
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN3@ComputeHap:

; 830  : 		}
; 831  : 
; 832  : 		// If we don't have this resource yet, increase it's value
; 833  : 		if(pPlayer)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN4@ComputeHap

; 834  : 		{
; 835  : 			if(pPlayer->getNumResourceTotal(eResource) == 0)

	push	1
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jne	SHORT $LN4@ComputeHap

; 836  : 				rtnValue *= 5;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, 5
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN4@ComputeHap:

; 837  : 		}
; 838  : 	}
; 839  : 
; 840  : 	return rtnValue * m_iFlavorMultiplier[SITE_EVALUATION_HAPPINESS];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR [ecx+28]

; 841  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeHappinessValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeHappinessValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ComputeProductionValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224193 = -20						; size = 4
_pImprovement$222782 = -16				; size = 4
_rtnValue$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_eResource$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?ComputeProductionValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeProductionValue, COMDAT
; _this$ = ecx

; 845  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 846  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 847  : 
; 848  : 	// From tile yield
; 849  : 	if(pPlayer == NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $LN10@ComputePro

; 850  : 	{
; 851  : 		rtnValue += pPlot->calculateNatureYield(YIELD_PRODUCTION, NO_TEAM);

	push	0
	push	-1
	push	1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 852  : 	}
; 853  : 	else

	jmp	SHORT $LN4@ComputePro

; 854  : 	{
; 855  : 		rtnValue += pPlot->calculateNatureYield(YIELD_PRODUCTION, pPlayer->getTeam());

$LN10@ComputePro:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224193[ebp], eax
	push	0
	mov	edx, DWORD PTR $T224193[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN4@ComputePro:

; 856  : 	}
; 857  : 
; 858  : 	// From resource
; 859  : 	TeamTypes eTeam = NO_TEAM;

	mov	DWORD PTR _eTeam$[ebp], -1

; 860  : 	if(pPlayer != NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN3@ComputePro

; 861  : 	{
; 862  : 		eTeam = pPlayer->getTeam();

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax
$LN3@ComputePro:

; 863  : 	}
; 864  : 
; 865  : 	ResourceTypes eResource;
; 866  : 	eResource = pPlot->getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 867  : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN2@ComputePro

; 868  : 	{
; 869  : 		rtnValue += GC.getResourceInfo(eResource)->getYieldChange(YIELD_PRODUCTION);

	push	1
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getYieldChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getYieldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 870  : 
; 871  : 		CvImprovementEntry* pImprovement = GC.GetGameImprovements()->GetImprovementForResource(eResource);

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ ; CvGlobals::GetGameImprovements
	mov	ecx, eax
	call	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetImprovementForResource
	mov	DWORD PTR _pImprovement$222782[ebp], eax

; 872  : 		if(pImprovement)

	cmp	DWORD PTR _pImprovement$222782[ebp], 0
	je	SHORT $LN2@ComputePro

; 873  : 		{
; 874  : 			rtnValue += pImprovement->GetImprovementResourceYield(eResource, YIELD_PRODUCTION);

	push	1
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$222782[ebp]
	call	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN2@ComputePro:

; 875  : 		}
; 876  : 	}
; 877  : 
; 878  : 	return rtnValue * m_iFlavorMultiplier[YIELD_PRODUCTION];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rtnValue$[ebp]
	imul	ecx, DWORD PTR [eax+8]
	mov	eax, ecx

; 879  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeProductionValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeProductionValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ComputeGoldValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224212 = -20						; size = 4
_pImprovement$222796 = -16				; size = 4
_rtnValue$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_eResource$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?ComputeGoldValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeGoldValue, COMDAT
; _this$ = ecx

; 883  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 885  : 
; 886  : 	// From tile yield
; 887  : 	if(pPlayer == NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $LN10@ComputeGol

; 888  : 	{
; 889  : 		rtnValue += pPlot->calculateNatureYield(YIELD_GOLD, NO_TEAM);

	push	0
	push	-1
	push	2
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 890  : 	}
; 891  : 	else

	jmp	SHORT $LN4@ComputeGol

; 892  : 	{
; 893  : 		rtnValue += pPlot->calculateNatureYield(YIELD_GOLD, pPlayer->getTeam());

$LN10@ComputeGol:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224212[ebp], eax
	push	0
	mov	edx, DWORD PTR $T224212[ebp]
	push	edx
	push	2
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN4@ComputeGol:

; 894  : 	}
; 895  : 
; 896  : 	// From resource
; 897  : 	TeamTypes eTeam = NO_TEAM;

	mov	DWORD PTR _eTeam$[ebp], -1

; 898  : 	if(pPlayer != NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN3@ComputeGol

; 899  : 	{
; 900  : 		eTeam = pPlayer->getTeam();

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax
$LN3@ComputeGol:

; 901  : 	}
; 902  : 
; 903  : 	ResourceTypes eResource;
; 904  : 	eResource = pPlot->getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 905  : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN2@ComputeGol

; 906  : 	{
; 907  : 		rtnValue += GC.getResourceInfo(eResource)->getYieldChange(YIELD_GOLD);

	push	2
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getYieldChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getYieldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 908  : 
; 909  : 		CvImprovementEntry* pImprovement = GC.GetGameImprovements()->GetImprovementForResource(eResource);

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ ; CvGlobals::GetGameImprovements
	mov	ecx, eax
	call	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetImprovementForResource
	mov	DWORD PTR _pImprovement$222796[ebp], eax

; 910  : 		if(pImprovement)

	cmp	DWORD PTR _pImprovement$222796[ebp], 0
	je	SHORT $LN2@ComputeGol

; 911  : 		{
; 912  : 			rtnValue += pImprovement->GetImprovementResourceYield(eResource, YIELD_GOLD);

	push	2
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$222796[ebp]
	call	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN2@ComputeGol:

; 913  : 		}
; 914  : 	}
; 915  : 
; 916  : 	return rtnValue * m_iFlavorMultiplier[YIELD_GOLD];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rtnValue$[ebp]
	imul	ecx, DWORD PTR [eax+12]
	mov	eax, ecx

; 917  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeGoldValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeGoldValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ComputeScienceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224231 = -20						; size = 4
_pImprovement$222811 = -16				; size = 4
_rtnValue$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_eResource$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?ComputeScienceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeScienceValue, COMDAT
; _this$ = ecx

; 921  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 922  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 923  : 
; 924  : 	CvAssert(pPlot);
; 925  : 	if(!pPlot) return rtnValue;

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN6@ComputeSci
	mov	eax, DWORD PTR _rtnValue$[ebp]
	jmp	$LN7@ComputeSci
$LN6@ComputeSci:

; 926  : 
; 927  : 	// From tile yield
; 928  : 	if(pPlayer == NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $LN11@ComputeSci

; 929  : 	{
; 930  : 		rtnValue += pPlot->calculateNatureYield(YIELD_SCIENCE, NO_TEAM);

	push	0
	push	-1
	push	3
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 931  : 	}
; 932  : 	else

	jmp	SHORT $LN4@ComputeSci

; 933  : 	{
; 934  : 		rtnValue += pPlot->calculateNatureYield(YIELD_SCIENCE, pPlayer->getTeam());

$LN11@ComputeSci:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224231[ebp], eax
	push	0
	mov	edx, DWORD PTR $T224231[ebp]
	push	edx
	push	3
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN4@ComputeSci:

; 935  : 	}
; 936  : 
; 937  : 	// From resource
; 938  : 	TeamTypes eTeam = NO_TEAM;

	mov	DWORD PTR _eTeam$[ebp], -1

; 939  : 	if(pPlayer != NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN3@ComputeSci

; 940  : 	{
; 941  : 		eTeam = pPlayer->getTeam();

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax
$LN3@ComputeSci:

; 942  : 	}
; 943  : 
; 944  : 	ResourceTypes eResource;
; 945  : 	eResource = pPlot->getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 946  : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN2@ComputeSci

; 947  : 	{
; 948  : 		rtnValue += GC.getResourceInfo(eResource)->getYieldChange(YIELD_SCIENCE);

	push	3
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getYieldChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getYieldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 949  : 
; 950  : 		CvImprovementEntry* pImprovement = GC.GetGameImprovements()->GetImprovementForResource(eResource);

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ ; CvGlobals::GetGameImprovements
	mov	ecx, eax
	call	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetImprovementForResource
	mov	DWORD PTR _pImprovement$222811[ebp], eax

; 951  : 		if(pImprovement)

	cmp	DWORD PTR _pImprovement$222811[ebp], 0
	je	SHORT $LN2@ComputeSci

; 952  : 		{
; 953  : 			rtnValue += pImprovement->GetImprovementResourceYield(eResource, YIELD_SCIENCE);

	push	3
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$222811[ebp]
	call	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN2@ComputeSci:

; 954  : 		}
; 955  : 	}
; 956  : 
; 957  : 	return rtnValue * m_iFlavorMultiplier[YIELD_SCIENCE];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rtnValue$[ebp]
	imul	ecx, DWORD PTR [eax+16]
	mov	eax, ecx
$LN7@ComputeSci:

; 958  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeScienceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeScienceValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ComputeFaithValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224250 = -20						; size = 4
_pImprovement$222826 = -16				; size = 4
_rtnValue$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_eResource$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?ComputeFaithValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeFaithValue, COMDAT
; _this$ = ecx

; 962  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 963  : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 964  : 
; 965  : 	CvAssert(pPlot);
; 966  : 	if(!pPlot) return rtnValue;

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN6@ComputeFai
	mov	eax, DWORD PTR _rtnValue$[ebp]
	jmp	$LN7@ComputeFai
$LN6@ComputeFai:

; 967  : 
; 968  : 	// From tile yield
; 969  : 	if(pPlayer == NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	jne	SHORT $LN11@ComputeFai

; 970  : 	{
; 971  : 		rtnValue += pPlot->calculateNatureYield(YIELD_FAITH, NO_TEAM);

	push	0
	push	-1
	push	5
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 972  : 	}
; 973  : 	else

	jmp	SHORT $LN4@ComputeFai

; 974  : 	{
; 975  : 		rtnValue += pPlot->calculateNatureYield(YIELD_FAITH, pPlayer->getTeam());

$LN11@ComputeFai:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224250[ebp], eax
	push	0
	mov	edx, DWORD PTR $T224250[ebp]
	push	edx
	push	5
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?calculateNatureYield@CvPlot@@QBEHW4YieldTypes@@W4TeamTypes@@_N@Z ; CvPlot::calculateNatureYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN4@ComputeFai:

; 976  : 	}
; 977  : 
; 978  : 	// From resource
; 979  : 	TeamTypes eTeam = NO_TEAM;

	mov	DWORD PTR _eTeam$[ebp], -1

; 980  : 	if(pPlayer != NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN3@ComputeFai

; 981  : 	{
; 982  : 		eTeam = pPlayer->getTeam();

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax
$LN3@ComputeFai:

; 983  : 	}
; 984  : 
; 985  : 	ResourceTypes eResource;
; 986  : 	eResource = pPlot->getResourceType(eTeam);

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 987  : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN2@ComputeFai

; 988  : 	{
; 989  : 		rtnValue += GC.getResourceInfo(eResource)->getYieldChange(YIELD_FAITH);

	push	5
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getYieldChange@CvResourceInfo@@QBEHH@Z	; CvResourceInfo::getYieldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 990  : 
; 991  : 		CvImprovementEntry* pImprovement = GC.GetGameImprovements()->GetImprovementForResource(eResource);

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameImprovements@CvGlobals@@QBEPAVCvImprovementXMLEntries@@XZ ; CvGlobals::GetGameImprovements
	mov	ecx, eax
	call	?GetImprovementForResource@CvImprovementXMLEntries@@QAEPAVCvImprovementEntry@@H@Z ; CvImprovementXMLEntries::GetImprovementForResource
	mov	DWORD PTR _pImprovement$222826[ebp], eax

; 992  : 		if(pImprovement)

	cmp	DWORD PTR _pImprovement$222826[ebp], 0
	je	SHORT $LN2@ComputeFai

; 993  : 		{
; 994  : 			rtnValue += pImprovement->GetImprovementResourceYield(eResource, YIELD_FAITH);

	push	5
	mov	edx, DWORD PTR _eResource$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pImprovement$222826[ebp]
	call	?GetImprovementResourceYield@CvImprovementEntry@@QBEHHH@Z ; CvImprovementEntry::GetImprovementResourceYield
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN2@ComputeFai:

; 995  : 		}
; 996  : 	}
; 997  : 
; 998  : 	return rtnValue * m_iFlavorMultiplier[YIELD_FAITH];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rtnValue$[ebp]
	imul	ecx, DWORD PTR [eax+24]
	mov	eax, ecx
$LN7@ComputeFai:

; 999  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeFaithValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeFaithValue
_TEXT	ENDS
EXTRN	?getNumResource@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumResource
EXTRN	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ:PROC ; CvResourceInfo::getResourceUsage
; Function compile flags: /Odtp
;	COMDAT ?ComputeTradeableResourceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_eResourceUsage$222840 = -16				; size = 4
_rtnValue$ = -12					; size = 4
_eTeam$ = -8						; size = 4
_eResource$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?ComputeTradeableResourceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z PROC ; CvCitySiteEvaluator::ComputeTradeableResourceValue, COMDAT
; _this$ = ecx

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1005 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 1006 : 
; 1007 : 	CvAssert(pPlot);
; 1008 : 	if(!pPlot) return rtnValue;

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN8@ComputeTra
	mov	eax, DWORD PTR _rtnValue$[ebp]
	jmp	$LN9@ComputeTra
$LN8@ComputeTra:

; 1009 : 
; 1010 : 	// If we already own this Tile then we already have access to the Strategic Resource
; 1011 : 	if(pPlot->isOwned())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@ComputeTra

; 1012 : 	{
; 1013 : 		return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	jmp	$LN9@ComputeTra
$LN7@ComputeTra:

; 1014 : 	}
; 1015 : 
; 1016 : 	TeamTypes eTeam = NO_TEAM;

	mov	DWORD PTR _eTeam$[ebp], -1

; 1017 : 	if(pPlayer != NULL)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN6@ComputeTra

; 1018 : 	{
; 1019 : 		eTeam = pPlayer->getTeam();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax
$LN6@ComputeTra:

; 1020 : 	}
; 1021 : 
; 1022 : 	ResourceTypes eResource;
; 1023 : 	eResource = pPlot->getResourceType(eTeam);

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	DWORD PTR _eResource$[ebp], eax

; 1024 : 
; 1025 : 	if(eResource != NO_RESOURCE)

	cmp	DWORD PTR _eResource$[ebp], -1
	je	SHORT $LN5@ComputeTra

; 1026 : 	{
; 1027 : 		ResourceUsageTypes eResourceUsage = GC.getResourceInfo(eResource)->getResourceUsage();

	mov	ecx, DWORD PTR _eResource$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	ecx, eax
	call	?getResourceUsage@CvResourceInfo@@QBE?AW4ResourceUsageTypes@@XZ ; CvResourceInfo::getResourceUsage
	mov	DWORD PTR _eResourceUsage$222840[ebp], eax

; 1028 : 
; 1029 : 		// Multiply number of tradeable resources by flavor value
; 1030 : 		if(eResourceUsage == RESOURCEUSAGE_LUXURY || eResourceUsage == RESOURCEUSAGE_STRATEGIC)

	cmp	DWORD PTR _eResourceUsage$222840[ebp], 2
	je	SHORT $LN3@ComputeTra
	cmp	DWORD PTR _eResourceUsage$222840[ebp], 1
	jne	SHORT $LN5@ComputeTra
$LN3@ComputeTra:

; 1031 : 		{
; 1032 : 			rtnValue += pPlot->getNumResource() * m_iFlavorMultiplier[SITE_EVALUATION_RESOURCES];

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumResource@CvPlot@@QBEHXZ		; CvPlot::getNumResource
	mov	edx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [edx+32]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1033 : 
; 1034 : 			if(pPlayer)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN5@ComputeTra

; 1035 : 			{
; 1036 : 				// If we don't have this resource yet, increase it's value
; 1037 : 				if(pPlayer->getNumResourceTotal(eResource) == 0)

	push	1
	mov	eax, DWORD PTR _eResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumResourceTotal@CvPlayer@@QBEHW4ResourceTypes@@_N@Z ; CvPlayer::getNumResourceTotal
	test	eax, eax
	jne	SHORT $LN5@ComputeTra

; 1038 : 					rtnValue *= 3;

	mov	ecx, DWORD PTR _rtnValue$[ebp]
	imul	ecx, 3
	mov	DWORD PTR _rtnValue$[ebp], ecx
$LN5@ComputeTra:

; 1039 : 			}
; 1040 : 		}
; 1041 : 	}
; 1042 : 
; 1043 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]
$LN9@ComputeTra:

; 1044 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ComputeTradeableResourceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z ENDP ; CvCitySiteEvaluator::ComputeTradeableResourceValue
_TEXT	ENDS
EXTRN	?getStartingLocationWeight@CvFeatureInfo@@QBEHXZ:PROC ; CvFeatureInfo::getStartingLocationWeight
; Function compile flags: /Odtp
;	COMDAT ?ComputeStrategicValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@H@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T224314 = -28						; size = 4
_f$224305 = -18						; size = 1
_f$224296 = -17						; size = 1
$T224287 = -16						; size = 4
$T224280 = -12						; size = 4
_iWeight$222857 = -8					; size = 4
_rtnValue$ = -4						; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_iPlotsFromCity$ = 16					; size = 4
?ComputeStrategicValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@H@Z PROC ; CvCitySiteEvaluator::ComputeStrategicValue, COMDAT
; _this$ = ecx

; 1048 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1049 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 1050 : 
; 1051 : 	CvAssert(pPlot);
; 1052 : 	if(!pPlot) return rtnValue;

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN7@ComputeStr
	mov	eax, DWORD PTR _rtnValue$[ebp]
	jmp	$LN8@ComputeStr
$LN7@ComputeStr:

; 1053 : 
; 1054 : 	// Possible chokepoint if impassable terrain and exactly 2 plots from city
; 1055 : 	if(iPlotsFromCity == 2 && (pPlot->isImpassable() || pPlot->isMountain()))

	cmp	DWORD PTR _iPlotsFromCity$[ebp], 2
	jne	SHORT $LN6@ComputeStr
	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN5@ComputeStr
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN6@ComputeStr
$LN5@ComputeStr:

; 1056 : 	{
; 1057 : 		rtnValue += /*5*/ GC.getCHOKEPOINT_STRATEGIC_VALUE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7268
	mov	DWORD PTR $T224280[ebp], eax
	mov	ecx, DWORD PTR _rtnValue$[ebp]
	add	ecx, DWORD PTR $T224280[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx
$LN6@ComputeStr:

; 1058 : 	}
; 1059 : 
; 1060 : 	// Hills in first ring are useful for defense and production
; 1061 : 	if(iPlotsFromCity == 1 && pPlot->isHills())

	cmp	DWORD PTR _iPlotsFromCity$[ebp], 1
	jne	SHORT $LN22@ComputeStr
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@ComputeStr

; 1062 : 	{
; 1063 : 		rtnValue += /*3*/ GC.getHILL_STRATEGIC_VALUE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7272
	mov	DWORD PTR $T224287[ebp], edx
	mov	eax, DWORD PTR _rtnValue$[ebp]
	add	eax, DWORD PTR $T224287[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1064 : 	}
; 1065 : 
; 1066 : 	// Some Features are less attractive to settle in, (e.g. Jungles, since it takes a while before you can clear them and they slow down movement)
; 1067 : 	if(pPlot->getFeatureType() != NO_FEATURE)

$LN22@ComputeStr:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$224296[ebp], dl
	movsx	eax, BYTE PTR _f$224296[ebp]
	cmp	eax, -1
	je	SHORT $LN3@ComputeStr

; 1068 : 	{
; 1069 : 		int iWeight = GC.getFeatureInfo(pPlot->getFeatureType())->getStartingLocationWeight();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	dl, BYTE PTR [ecx+432]
	mov	BYTE PTR _f$224305[ebp], dl
	movsx	eax, BYTE PTR _f$224305[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getStartingLocationWeight@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getStartingLocationWeight
	mov	DWORD PTR _iWeight$222857[ebp], eax

; 1070 : 		if(iWeight != 0 && iPlotsFromCity == 1)

	cmp	DWORD PTR _iWeight$222857[ebp], 0
	je	SHORT $LN3@ComputeStr
	cmp	DWORD PTR _iPlotsFromCity$[ebp], 1
	jne	SHORT $LN3@ComputeStr

; 1071 : 		{
; 1072 : 			rtnValue += iWeight;

	mov	ecx, DWORD PTR _rtnValue$[ebp]
	add	ecx, DWORD PTR _iWeight$222857[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx
$LN3@ComputeStr:

; 1073 : 		}
; 1074 : 	}
; 1075 : 
; 1076 : 	// Nearby City
; 1077 : 	if(pPlayer != NULL && pPlot->isCity())

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN1@ComputeStr
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@ComputeStr

; 1078 : 	{
; 1079 : //		if (pPlot->getOwner() == pPlayer->getID())
; 1080 : 		{
; 1081 : 			rtnValue += /*-1000*/ GC.getALREADY_OWNED_STRATEGIC_VALUE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7276
	mov	DWORD PTR $T224314[ebp], eax
	mov	ecx, DWORD PTR _rtnValue$[ebp]
	add	ecx, DWORD PTR $T224314[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx
$LN1@ComputeStr:

; 1082 : 		}
; 1083 : 	}
; 1084 : 
; 1085 : 	// POSSIBLE FUTURE: Is there any way for us to know to grab land between us and another major civ?
; 1086 : 
; 1087 : 	rtnValue *= m_iFlavorMultiplier[SITE_EVALUATION_STRATEGIC];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1088 : 
; 1089 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]
$LN8@ComputeStr:

; 1090 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ComputeStrategicValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@H@Z ENDP ; CvCitySiteEvaluator::ComputeStrategicValue
_TEXT	ENDS
PUBLIC	??_7CvSiteEvaluatorForSettler@@6B@		; CvSiteEvaluatorForSettler::`vftable'
PUBLIC	??0CvSiteEvaluatorForSettler@@QAE@XZ		; CvSiteEvaluatorForSettler::CvSiteEvaluatorForSettler
PUBLIC	?PlotFoundValue@CvSiteEvaluatorForSettler@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ; CvSiteEvaluatorForSettler::PlotFoundValue
;	COMDAT ??_7CvSiteEvaluatorForSettler@@6B@
CONST	SEGMENT
??_7CvSiteEvaluatorForSettler@@6B@ DD FLAT:?Init@CvCitySiteEvaluator@@UAEXXZ ; CvSiteEvaluatorForSettler::`vftable'
	DD	FLAT:?ComputeFlavorMultipliers@CvCitySiteEvaluator@@UAEXPAVCvPlayer@@@Z
	DD	FLAT:?CanFound@CvCitySiteEvaluator@@UBE_NPAVCvPlot@@PBVCvPlayer@@_N@Z
	DD	FLAT:?PlotFoundValue@CvSiteEvaluatorForSettler@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z
	DD	FLAT:?PlotFertilityValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@@Z
	DD	FLAT:?BestFoundValueForSpecificYield@CvCitySiteEvaluator@@UAEHPAVCvPlayer@@W4YieldTypes@@@Z
	DD	FLAT:?ComputeFoodValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeHappinessValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeProductionValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeGoldValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeScienceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeFaithValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeTradeableResourceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeStrategicValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@H@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvSiteEvaluatorForSettler@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvSiteEvaluatorForSettler@@QAE@XZ PROC		; CvSiteEvaluatorForSettler::CvSiteEvaluatorForSettler, COMDAT
; _this$ = ecx

; 1097 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvCitySiteEvaluator@@QAE@XZ		; CvCitySiteEvaluator::CvCitySiteEvaluator
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvSiteEvaluatorForSettler@@6B@

; 1098 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvSiteEvaluatorForSettler@@QAE@XZ ENDP		; CvSiteEvaluatorForSettler::CvSiteEvaluatorForSettler
_TEXT	ENDS
PUBLIC	??1CvSiteEvaluatorForSettler@@QAE@XZ		; CvSiteEvaluatorForSettler::~CvSiteEvaluatorForSettler
; Function compile flags: /Odtp
;	COMDAT ??1CvSiteEvaluatorForSettler@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvSiteEvaluatorForSettler@@QAE@XZ PROC		; CvSiteEvaluatorForSettler::~CvSiteEvaluatorForSettler, COMDAT
; _this$ = ecx

; 1102 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvSiteEvaluatorForSettler@@6B@

; 1103 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvCitySiteEvaluator@@QAE@XZ		; CvCitySiteEvaluator::~CvCitySiteEvaluator
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvSiteEvaluatorForSettler@@QAE@XZ ENDP		; CvSiteEvaluatorForSettler::~CvSiteEvaluatorForSettler
_TEXT	ENDS
EXTRN	?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z:PROC ; CvPlayerTraits::WillGetUniqueLuxury
EXTRN	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getCitiesPerPlayer
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
; Function compile flags: /Odtp
;	COMDAT ?PlotFoundValue@CvSiteEvaluatorForSettler@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T224335 = -24						; size = 4
$T224326 = -20						; size = 4
_iLuxuryModifier$222883 = -16				; size = 4
_bIsCoastal$ = -9					; size = 1
_pArea$ = -8						; size = 4
_iNumAreaCities$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_eYield$ = 16						; size = 4
_bCoastOnly$ = 20					; size = 1
?PlotFoundValue@CvSiteEvaluatorForSettler@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z PROC ; CvSiteEvaluatorForSettler::PlotFoundValue, COMDAT
; _this$ = ecx

; 1107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1108 : 	CvAssert(pPlot);
; 1109 : 	if(!pPlot) return 0;

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN7@PlotFoundV@2
	xor	eax, eax
	jmp	$LN8@PlotFoundV@2
$LN7@PlotFoundV@2:

; 1110 : 
; 1111 : 	if(!CanFound(pPlot, pPlayer, true))

	push	1
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@PlotFoundV@2

; 1112 : 	{
; 1113 : 		return 0;

	xor	eax, eax
	jmp	$LN8@PlotFoundV@2
$LN6@PlotFoundV@2:

; 1114 : 	}
; 1115 : 
; 1116 : 	// Is there any reason this site doesn't work for a settler?
; 1117 : 	//
; 1118 : 	// First must be on coast if settling a new continent
; 1119 : 	bool bIsCoastal = pPlot->isCoastalLand(GC.getMIN_WATER_SIZE_FOR_OCEAN());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6876
	mov	DWORD PTR $T224326[ebp], ecx
	mov	edx, DWORD PTR $T224326[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	mov	BYTE PTR _bIsCoastal$[ebp], al

; 1120 : 	CvArea* pArea = pPlot->area();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	DWORD PTR _pArea$[ebp], eax

; 1121 : 	CvAssert(pArea);
; 1122 : 	if(!pArea) return 0;

	cmp	DWORD PTR _pArea$[ebp], 0
	jne	SHORT $LN14@PlotFoundV@2
	xor	eax, eax
	jmp	$LN8@PlotFoundV@2

; 1123 : 	int iNumAreaCities = pArea->getCitiesPerPlayer(pPlayer->GetID());

$LN14@PlotFoundV@2:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T224335[ebp], ecx
	mov	edx, DWORD PTR $T224335[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
	mov	DWORD PTR _iNumAreaCities$[ebp], eax

; 1124 : 	if(bCoastOnly && !bIsCoastal && iNumAreaCities == 0)

	movzx	eax, BYTE PTR _bCoastOnly$[ebp]
	test	eax, eax
	je	SHORT $LN4@PlotFoundV@2
	movzx	ecx, BYTE PTR _bIsCoastal$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@PlotFoundV@2
	cmp	DWORD PTR _iNumAreaCities$[ebp], 0
	jne	SHORT $LN4@PlotFoundV@2

; 1125 : 	{
; 1126 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN8@PlotFoundV@2

; 1127 : 	}
; 1128 : 
; 1129 : 	// Seems okay for a settler, use base class to determine exact value
; 1130 : 	else

	jmp	SHORT $LN8@PlotFoundV@2
$LN4@PlotFoundV@2:

; 1131 : 	{
; 1132 : 		// if the civ gets a benefit from settling on a new continent (ie: Indonesia)
; 1133 : 		// double the fertility of that plot
; 1134 : 		int iLuxuryModifier = 0;

	mov	DWORD PTR _iLuxuryModifier$222883[ebp], 0

; 1135 : 		//if (pPlayer->GetPlayerTraits()->WillGetUniqueLuxury(pArea))
; 1136 : 		if (pPlayer->GetPlayerTraits()->WillGetUniqueLuxury(pArea) && bIsCoastal) // NQMP GJS - Spice Islanders requires coast

	mov	edx, DWORD PTR _pArea$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	ecx, eax
	call	?WillGetUniqueLuxury@CvPlayerTraits@@QBE_NPAVCvArea@@@Z ; CvPlayerTraits::WillGetUniqueLuxury
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@PlotFoundV@2
	movzx	ecx, BYTE PTR _bIsCoastal$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@PlotFoundV@2

; 1137 : 		{
; 1138 : 			iLuxuryModifier = CvCitySiteEvaluator::PlotFoundValue(pPlot, pPlayer, eYield) * 2;

	push	1
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotFoundValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ; CvCitySiteEvaluator::PlotFoundValue
	shl	eax, 1
	mov	DWORD PTR _iLuxuryModifier$222883[ebp], eax

; 1139 : 			return iLuxuryModifier;

	mov	eax, DWORD PTR _iLuxuryModifier$222883[ebp]
	jmp	SHORT $LN8@PlotFoundV@2

; 1140 : 		}
; 1141 : 		else

	jmp	SHORT $LN8@PlotFoundV@2
$LN2@PlotFoundV@2:

; 1142 : 		{
; 1143 : 			return CvCitySiteEvaluator::PlotFoundValue(pPlot, pPlayer, eYield);

	push	1
	mov	edx, DWORD PTR _eYield$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlotFoundValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ; CvCitySiteEvaluator::PlotFoundValue
$LN8@PlotFoundV@2:

; 1144 : 		}
; 1145 : 	}
; 1146 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PlotFoundValue@CvSiteEvaluatorForSettler@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ENDP ; CvSiteEvaluatorForSettler::PlotFoundValue
_TEXT	ENDS
PUBLIC	??_7CvSiteEvaluatorForStart@@6B@		; CvSiteEvaluatorForStart::`vftable'
PUBLIC	??0CvSiteEvaluatorForStart@@QAE@XZ		; CvSiteEvaluatorForStart::CvSiteEvaluatorForStart
PUBLIC	?ComputeFlavorMultipliers@CvSiteEvaluatorForStart@@UAEXPAVCvPlayer@@@Z ; CvSiteEvaluatorForStart::ComputeFlavorMultipliers
PUBLIC	?PlotFoundValue@CvSiteEvaluatorForStart@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ; CvSiteEvaluatorForStart::PlotFoundValue
;	COMDAT ??_7CvSiteEvaluatorForStart@@6B@
CONST	SEGMENT
??_7CvSiteEvaluatorForStart@@6B@ DD FLAT:?Init@CvCitySiteEvaluator@@UAEXXZ ; CvSiteEvaluatorForStart::`vftable'
	DD	FLAT:?ComputeFlavorMultipliers@CvSiteEvaluatorForStart@@UAEXPAVCvPlayer@@@Z
	DD	FLAT:?CanFound@CvCitySiteEvaluator@@UBE_NPAVCvPlot@@PBVCvPlayer@@_N@Z
	DD	FLAT:?PlotFoundValue@CvSiteEvaluatorForStart@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z
	DD	FLAT:?PlotFertilityValue@CvCitySiteEvaluator@@UAEHPAVCvPlot@@@Z
	DD	FLAT:?BestFoundValueForSpecificYield@CvCitySiteEvaluator@@UAEHPAVCvPlayer@@W4YieldTypes@@@Z
	DD	FLAT:?ComputeFoodValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeHappinessValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeProductionValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeGoldValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeScienceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeFaithValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeTradeableResourceValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@@Z
	DD	FLAT:?ComputeStrategicValue@CvCitySiteEvaluator@@MAEHPAVCvPlot@@PAVCvPlayer@@H@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvSiteEvaluatorForStart@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvSiteEvaluatorForStart@@QAE@XZ PROC			; CvSiteEvaluatorForStart::CvSiteEvaluatorForStart, COMDAT
; _this$ = ecx

; 1153 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvCitySiteEvaluator@@QAE@XZ		; CvCitySiteEvaluator::CvCitySiteEvaluator
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvSiteEvaluatorForStart@@6B@

; 1154 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvSiteEvaluatorForStart@@QAE@XZ ENDP			; CvSiteEvaluatorForStart::CvSiteEvaluatorForStart
_TEXT	ENDS
PUBLIC	??1CvSiteEvaluatorForStart@@QAE@XZ		; CvSiteEvaluatorForStart::~CvSiteEvaluatorForStart
; Function compile flags: /Odtp
;	COMDAT ??1CvSiteEvaluatorForStart@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvSiteEvaluatorForStart@@QAE@XZ PROC			; CvSiteEvaluatorForStart::~CvSiteEvaluatorForStart, COMDAT
; _this$ = ecx

; 1158 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvSiteEvaluatorForStart@@6B@

; 1159 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvCitySiteEvaluator@@QAE@XZ		; CvCitySiteEvaluator::~CvCitySiteEvaluator
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvSiteEvaluatorForStart@@QAE@XZ ENDP			; CvSiteEvaluatorForStart::~CvSiteEvaluatorForStart
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ComputeFlavorMultipliers@CvSiteEvaluatorForStart@@UAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iI$222898 = -4						; size = 4
___formal$ = 8						; size = 4
?ComputeFlavorMultipliers@CvSiteEvaluatorForStart@@UAEXPAVCvPlayer@@@Z PROC ; CvSiteEvaluatorForStart::ComputeFlavorMultipliers, COMDAT
; _this$ = ecx

; 1163 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1164 : 	// Set all to 1; we assign start position without considering flavors yet
; 1165 : 	for(int iI = 0; iI < NUM_SITE_EVALUATION_FACTORS; iI++)

	mov	DWORD PTR _iI$222898[ebp], 0
	jmp	SHORT $LN3@ComputeFla@2
$LN2@ComputeFla@2:
	mov	eax, DWORD PTR _iI$222898[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$222898[ebp], eax
$LN3@ComputeFla@2:
	cmp	DWORD PTR _iI$222898[ebp], 9
	jge	SHORT $LN4@ComputeFla@2

; 1166 : 	{
; 1167 : 		m_iFlavorMultiplier[iI] = 1;

	mov	ecx, DWORD PTR _iI$222898[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], 1
	jmp	SHORT $LN2@ComputeFla@2
$LN4@ComputeFla@2:

; 1168 : 	}
; 1169 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ComputeFlavorMultipliers@CvSiteEvaluatorForStart@@UAEXPAVCvPlayer@@@Z ENDP ; CvSiteEvaluatorForStart::ComputeFlavorMultipliers
_TEXT	ENDS
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
EXTRN	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC	; CvPlot::isGoody
; Function compile flags: /Odtp
;	COMDAT ?PlotFoundValue@CvSiteEvaluatorForStart@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -164						; size = 4
$T224479 = -160						; size = 4
$T224475 = -156						; size = 4
$T224468 = -152						; size = 4
$T224464 = -145						; size = 1
$T224463 = -144						; size = 4
_f$224459 = -137					; size = 1
$T224450 = -136						; size = 4
$T224446 = -132						; size = 4
$T224442 = -128						; size = 4
$T224438 = -124						; size = 4
$T224434 = -120						; size = 4
$T224430 = -116						; size = 4
$T224426 = -112						; size = 4
$T224422 = -108						; size = 4
$T224369 = -48						; size = 4
$T224365 = -44						; size = 4
$T224361 = -40						; size = 4
$T224357 = -36						; size = 4
$T224353 = -32						; size = 4
$T224349 = -28						; size = 4
_iDistance$222921 = -24					; size = 4
_iRingModifier$222923 = -20				; size = 4
_rtnValue$ = -16					; size = 4
_iCelticForestCount$ = -12				; size = 4
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
?PlotFoundValue@CvSiteEvaluatorForStart@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z PROC ; CvSiteEvaluatorForStart::PlotFoundValue, COMDAT
; _this$ = ecx

; 1173 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	DWORD PTR _this$[ebp], ecx

; 1174 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 1175 : 	int iI;
; 1176 : 	CvPlot* pLoopPlot(NULL);

	mov	DWORD PTR _pLoopPlot$[ebp], 0

; 1177 : 	int iCelticForestCount = 0;

	mov	DWORD PTR _iCelticForestCount$[ebp], 0

; 1178 : 
; 1179 : 	CvAssert(pPlot);
; 1180 : 	if(!pPlot) return rtnValue;

	cmp	DWORD PTR _pPlot$[ebp], 0
	jne	SHORT $LN20@PlotFoundV@3
	mov	eax, DWORD PTR _rtnValue$[ebp]
	jmp	$LN21@PlotFoundV@3
$LN20@PlotFoundV@3:

; 1181 : 
; 1182 : 	if(!CanFound(pPlot, pPlayer, false))

	push	0
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN19@PlotFoundV@3

; 1183 : 	{
; 1184 : 		return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	jmp	$LN21@PlotFoundV@3
$LN19@PlotFoundV@3:

; 1185 : 	}
; 1186 : 
; 1187 : 	// Is there any reason this site doesn't work for a start location?
; 1188 : 	//
; 1189 : 	// Not on top of a goody hut
; 1190 : 	if(pPlot->isGoody())

	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isGoody@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isGoody
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@PlotFoundV@3

; 1191 : 	{
; 1192 : 		return 0;

	xor	eax, eax
	jmp	$LN21@PlotFoundV@3
$LN18@PlotFoundV@3:

; 1193 : 	}
; 1194 : 
; 1195 : 	// We have our own special method of scoring, so don't call the base class for that (like settler version does)
; 1196 : 	for(iI = 0; iI < NUM_CITY_PLOTS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN17@PlotFoundV@3
$LN16@PlotFoundV@3:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN17@PlotFoundV@3:
	cmp	DWORD PTR _iI$[ebp], 37			; 00000025H
	jge	$LN15@PlotFoundV@3

; 1197 : 	{
; 1198 : 		pLoopPlot = plotCity(pPlot->getX(), pPlot->getY(), iI);

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224349[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224353[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224349[ebp]
	push	edx
	mov	eax, DWORD PTR $T224353[ebp]
	push	eax
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 1199 : 
; 1200 : 		// Too close to map edge?
; 1201 : 		if(pLoopPlot == NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	jne	SHORT $LN14@PlotFoundV@3

; 1202 : 		{
; 1203 : 			return 0;

	xor	eax, eax
	jmp	$LN21@PlotFoundV@3

; 1204 : 		}
; 1205 : 		else

	jmp	$LN13@PlotFoundV@3
$LN14@PlotFoundV@3:

; 1206 : 		{
; 1207 : 			int iDistance = plotDistance(pPlot->getX(), pPlot->getY(), pLoopPlot->getX(), pLoopPlot->getY());

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T224357[ebp], edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T224361[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T224365[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T224369[ebp], edx
	mov	eax, DWORD PTR $T224357[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224361[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224365[ebp]
	push	edx
	mov	eax, DWORD PTR $T224369[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$222921[ebp], eax

; 1208 : 			CvAssert(iDistance <= NUM_CITY_RINGS);
; 1209 : 			if(iDistance > NUM_CITY_RINGS) continue;

	cmp	DWORD PTR _iDistance$222921[ebp], 3
	jle	SHORT $LN12@PlotFoundV@3
	jmp	$LN16@PlotFoundV@3
$LN12@PlotFoundV@3:

; 1210 : 			int iRingModifier = m_iRingModifier[iDistance];

	mov	ecx, DWORD PTR _iDistance$222921[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+40]
	mov	DWORD PTR _iRingModifier$222923[ebp], eax

; 1211 : 
; 1212 : 			// Skip the city plot itself for now
; 1213 : 			if(iDistance != 0)

	cmp	DWORD PTR _iDistance$222921[ebp], 0
	je	$LN11@PlotFoundV@3

; 1214 : 			{
; 1215 : 				rtnValue += iRingModifier * ComputeFoodValue(pLoopPlot, pPlayer) * /*6*/ GC.getSTART_AREA_FOOD_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7160
	mov	DWORD PTR $T224422[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224422[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1216 : 				rtnValue += iRingModifier * ComputeHappinessValue(pLoopPlot, pPlayer) * /*12*/ GC.getSTART_AREA_HAPPINESS_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7164
	mov	DWORD PTR $T224426[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224426[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1217 : 				rtnValue += iRingModifier * ComputeProductionValue(pLoopPlot, pPlayer) * /*8*/ GC.getSTART_AREA_PRODUCTION_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7168
	mov	DWORD PTR $T224430[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224430[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1218 : 				rtnValue += iRingModifier * ComputeGoldValue(pLoopPlot, pPlayer) * /*2*/ GC.getSTART_AREA_GOLD_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7172
	mov	DWORD PTR $T224434[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224434[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1219 : 				rtnValue += iRingModifier * ComputeScienceValue(pLoopPlot, pPlayer) * /*1*/ GC.getSTART_AREA_SCIENCE_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7176
	mov	DWORD PTR $T224438[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224438[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1220 : 				rtnValue += iRingModifier * ComputeFaithValue(pLoopPlot, pPlayer) * /*1*/ GC.getSTART_AREA_FAITH_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7180
	mov	DWORD PTR $T224442[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224442[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1221 : 				rtnValue += iRingModifier * ComputeTradeableResourceValue(pLoopPlot, pPlayer) * /*1*/ GC.getSTART_AREA_RESOURCE_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7184
	mov	DWORD PTR $T224446[ebp], ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224446[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1222 : 				rtnValue += iRingModifier * ComputeStrategicValue(pLoopPlot, pPlayer, iDistance) * /*1*/ GC.getSTART_AREA_STRATEGIC_MULTIPLIER();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7188
	mov	DWORD PTR $T224450[ebp], ecx
	mov	edx, DWORD PTR _iDistance$222921[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+52]
	call	edx
	imul	eax, DWORD PTR _iRingModifier$222923[ebp]
	imul	eax, DWORD PTR $T224450[ebp]
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN11@PlotFoundV@3:

; 1223 : 			}
; 1224 : 
; 1225 : 			if (pPlayer)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $LN13@PlotFoundV@3

; 1226 : 			{
; 1227 : 				if (iDistance == 1 && pLoopPlot->getFeatureType() == FEATURE_FOREST)

	cmp	DWORD PTR _iDistance$222921[ebp], 1
	jne	SHORT $LN13@PlotFoundV@3
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	cl, BYTE PTR [eax+432]
	mov	BYTE PTR _f$224459[ebp], cl
	movsx	edx, BYTE PTR _f$224459[ebp]
	cmp	edx, 5
	jne	SHORT $LN13@PlotFoundV@3

; 1228 : 				{
; 1229 : 					if (pLoopPlot->getImprovementType() == NO_IMPROVEMENT && pPlayer->GetPlayerTraits()->IsFaithFromUnimprovedForest())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	jne	SHORT $LN13@PlotFoundV@3
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T224463[ebp], eax
	mov	eax, DWORD PTR $T224463[ebp]
	mov	cl, BYTE PTR [eax+341]
	mov	BYTE PTR $T224464[ebp], cl
	movzx	edx, BYTE PTR $T224464[ebp]
	test	edx, edx
	je	SHORT $LN13@PlotFoundV@3

; 1230 : 					{
; 1231 : 						iCelticForestCount += 1;

	mov	eax, DWORD PTR _iCelticForestCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCelticForestCount$[ebp], eax
$LN13@PlotFoundV@3:

; 1232 : 					}
; 1233 : 				}
; 1234 : 			}
; 1235 : 		}
; 1236 : 	}

	jmp	$LN16@PlotFoundV@3
$LN15@PlotFoundV@3:

; 1237 : 
; 1238 : 	if (iCelticForestCount >= 3)

	cmp	DWORD PTR _iCelticForestCount$[ebp], 3
	jl	SHORT $LN7@PlotFoundV@3

; 1239 : 	{
; 1240 : 		rtnValue += 2 * 1000 * m_iFlavorMultiplier[YIELD_FAITH];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	imul	edx, 2000				; 000007d0H
	add	edx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], edx
	jmp	SHORT $LN6@PlotFoundV@3
$LN7@PlotFoundV@3:

; 1241 : 	}
; 1242 : 	else if (iCelticForestCount >= 1)

	cmp	DWORD PTR _iCelticForestCount$[ebp], 1
	jl	SHORT $LN6@PlotFoundV@3

; 1243 : 	{
; 1244 : 		rtnValue += 1 * 1000 * m_iFlavorMultiplier[YIELD_FAITH];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	imul	ecx, 1000				; 000003e8H
	add	ecx, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], ecx
$LN6@PlotFoundV@3:

; 1245 : 	}
; 1246 : 
; 1247 : 	if(rtnValue < 0) rtnValue = 0;

	cmp	DWORD PTR _rtnValue$[ebp], 0
	jge	SHORT $LN4@PlotFoundV@3
	mov	DWORD PTR _rtnValue$[ebp], 0
$LN4@PlotFoundV@3:

; 1248 : 
; 1249 : 	// Finally, look at the city plot itself and use it as an overall multiplier
; 1250 : 	if(pPlot->getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN91@PlotFoundV@3

; 1251 : 	{
; 1252 : 		rtnValue += rtnValue * GC.getBUILD_ON_RESOURCE_PERCENT() / 100;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7260
	mov	DWORD PTR $T224468[ebp], edx
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR $T224468[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 1253 : 	}
; 1254 : 
; 1255 : 	if(pPlot->isRiver())

$LN91@PlotFoundV@3:
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+457]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@PlotFoundV@3

; 1256 : 	{
; 1257 : 		rtnValue += rtnValue * GC.getBUILD_ON_RIVER_PERCENT() / 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7264
	mov	DWORD PTR $T224475[ebp], eax
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR $T224475[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN2@PlotFoundV@3:

; 1258 : 	}
; 1259 : 
; 1260 : 	if(pPlot->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@PlotFoundV@3

; 1261 : 	{
; 1262 : 		rtnValue += rtnValue * GC.getSTART_AREA_BUILD_ON_COAST_PERCENT() / 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7192
	mov	DWORD PTR $T224479[ebp], eax
	mov	eax, DWORD PTR _rtnValue$[ebp]
	imul	eax, DWORD PTR $T224479[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@PlotFoundV@3:

; 1263 : 	}
; 1264 : 
; 1265 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]
$LN21@PlotFoundV@3:

; 1266 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PlotFoundValue@CvSiteEvaluatorForStart@@UAEHPAVCvPlot@@PAVCvPlayer@@W4YieldTypes@@_N@Z ENDP ; CvSiteEvaluatorForStart::PlotFoundValue
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T224490 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224490[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T224490[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
END
