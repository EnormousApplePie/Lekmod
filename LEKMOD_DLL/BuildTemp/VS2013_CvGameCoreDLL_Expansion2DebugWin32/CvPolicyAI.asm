; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPolicyAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
PUBLIC	??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z	; CvPolicyAI::CvPolicyAI
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z$0
__ehfuncinfo$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T222991 = -36						; size = 4
$T222974 = -24						; size = 4
__$EHRec$ = -12						; size = 12
_currentPolicies$ = 8					; size = 4
??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z PROC		; CvPolicyAI::CvPolicyAI, COMDAT
; _this$ = ecx

; 20   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentPolicies$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T222974[ebp], edx
	mov	ecx, DWORD PTR $T222974[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 532				; 00000214H
	mov	DWORD PTR $T222991[ebp], eax
	mov	ecx, DWORD PTR $T222991[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>

; 21   : #ifdef AUI_WARNING_FIXES
; 22   : 	m_iPolicyWeightPropagationLevels = 0;
; 23   : 	m_iPolicyWeightPercentDropNewBranch = 0;
; 24   : #endif	
; 25   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ	; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
__ehhandler$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z ENDP		; CvPolicyAI::CvPolicyAI
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
PUBLIC	??1CvPolicyAI@@QAE@XZ				; CvPolicyAI::~CvPolicyAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPolicyAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPolicyAI@@QAE@XZ$0
__ehfuncinfo$??1CvPolicyAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvPolicyAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ??1CvPolicyAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T223070 = -44						; size = 4
$T223038 = -28						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPolicyAI@@QAE@XZ PROC				; CvPolicyAI::~CvPolicyAI, COMDAT
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPolicyAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 30   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 532				; 00000214H
	mov	DWORD PTR $T223038[ebp], eax
	mov	ecx, DWORD PTR $T223038[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T223070[ebp], ecx
	mov	ecx, DWORD PTR $T223070[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPolicyAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ	; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
__ehhandler$??1CvPolicyAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPolicyAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPolicyAI@@QAE@XZ ENDP				; CvPolicyAI::~CvPolicyAI
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back
PUBLIC	?Reset@CvPolicyAI@@QAEXXZ			; CvPolicyAI::Reset
EXTRN	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ:PROC	; CvPolicyXMLEntries::GetNumPolicies
EXTRN	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ:PROC ; CvPlayerPolicies::GetPolicies
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvPolicyAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -80						; size = 4
_weightedElem$223155 = -36				; size = 8
$T223117 = -28						; size = 4
$T223113 = -24						; size = 4
$T223109 = -20						; size = 4
_i$223105 = -16						; size = 4
_i$221286 = -12						; size = 4
_nPolicyEntries$221285 = -8				; size = 4
_pPolicyEntries$221283 = -4				; size = 4
?Reset@CvPolicyAI@@QAEXXZ PROC				; CvPolicyAI::Reset, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	m_PolicyAIWeights.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T223109[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN16@Reset
	mov	DWORD PTR _i$223105[ebp], 0
	jmp	SHORT $LN14@Reset
$LN13@Reset:
	mov	edx, DWORD PTR _i$223105[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223105[ebp], edx
$LN14@Reset:
	mov	eax, DWORD PTR $T223109[ebp]
	mov	ecx, DWORD PTR _i$223105[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN16@Reset
	jmp	SHORT $LN13@Reset
$LN16@Reset:
	mov	edx, DWORD PTR $T223109[ebp]
	mov	DWORD PTR [edx+4], 0

; 36   : 	m_iPolicyWeightPropagationLevels = GC.getPOLICY_WEIGHT_PROPAGATION_LEVELS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1828
	mov	DWORD PTR $T223113[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T223113[ebp]
	mov	DWORD PTR [ecx+1060], edx

; 37   : 	m_iPolicyWeightPercentDropNewBranch = GC.getPOLICY_WEIGHT_PERCENT_DROP_NEW_BRANCH();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1832
	mov	DWORD PTR $T223117[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T223117[ebp]
	mov	DWORD PTR [ecx+1064], edx

; 38   : 
; 39   : 	CvAssertMsg(m_pCurrentPolicies != NULL, "Policy AI init failure: player policy data is NULL");
; 40   : 	if(m_pCurrentPolicies != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@Reset

; 41   : 	{
; 42   : 		CvPolicyXMLEntries* pPolicyEntries = m_pCurrentPolicies->GetPolicies();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	DWORD PTR _pPolicyEntries$221283[ebp], eax

; 43   : 		CvAssertMsg(pPolicyEntries != NULL, "Policy AI init failure: no policy data");
; 44   : 		if(pPolicyEntries != NULL)

	cmp	DWORD PTR _pPolicyEntries$221283[ebp], 0
	je	SHORT $LN6@Reset

; 45   : 		{
; 46   : 			// Loop through reading each one and add an entry with 0 weight to our vector
; 47   : 			const int nPolicyEntries = pPolicyEntries->GetNumPolicies();

	mov	ecx, DWORD PTR _pPolicyEntries$221283[ebp]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _nPolicyEntries$221285[ebp], eax

; 48   : 			for(int i = 0; i < nPolicyEntries; i++)

	mov	DWORD PTR _i$221286[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	edx, DWORD PTR _i$221286[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221286[ebp], edx
$LN3@Reset:
	mov	eax, DWORD PTR _i$221286[ebp]
	cmp	eax, DWORD PTR _nPolicyEntries$221285[ebp]
	jge	SHORT $LN6@Reset

; 49   : 			{
; 50   : 				m_PolicyAIWeights.push_back(i, 0);

	mov	DWORD PTR _weightedElem$223155[ebp], 0
	mov	DWORD PTR _weightedElem$223155[ebp+4], 0
	mov	ecx, DWORD PTR _i$221286[ebp]
	mov	DWORD PTR _weightedElem$223155[ebp], ecx
	mov	DWORD PTR _weightedElem$223155[ebp+4], 0
	lea	edx, DWORD PTR _weightedElem$223155[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back

; 51   : 			}

	jmp	SHORT $LN2@Reset
$LN6@Reset:

; 52   : 		}
; 53   : 	}
; 54   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvPolicyAI@@QAEXXZ ENDP				; CvPolicyAI::Reset
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
PUBLIC	?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z	; CvPolicyAI::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T223228 = -44						; size = 4
$T223205 = -40						; size = 4
$T223194 = -36						; size = 4
_i$223189 = -32						; size = 4
_ePolicy$221306 = -28					; size = 4
_uiIndex$221302 = -24					; size = 4
_uiIndex$221297 = -20					; size = 4
_uiPolicyArraySize$ = -16				; size = 4
_uiVersion$ = -12					; size = 4
_iWeight$ = -8						; size = 4
_uiPolicyCount$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z PROC		; CvPolicyAI::Read, COMDAT
; _this$ = ecx

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	// Version number to maintain backwards compatibility
; 60   : 	uint uiVersion;
; 61   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 62   : 
; 63   : 	int iWeight;
; 64   : 
; 65   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies() != NULL, "Policy AI serialization failure: no policy data");
; 66   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies()->GetNumPolicies() > 0, "Policy AI serialization failure: number of policies not greater than 0");
; 67   : 
; 68   : 	// Reset vector
; 69   : 	m_PolicyAIWeights.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T223194[ebp], ecx
	xor	edx, edx
	je	SHORT $LN20@Read
	mov	DWORD PTR _i$223189[ebp], 0
	jmp	SHORT $LN18@Read
$LN17@Read:
	mov	eax, DWORD PTR _i$223189[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223189[ebp], eax
$LN18@Read:
	mov	ecx, DWORD PTR $T223194[ebp]
	mov	edx, DWORD PTR _i$223189[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN20@Read
	jmp	SHORT $LN17@Read
$LN20@Read:
	mov	eax, DWORD PTR $T223194[ebp]
	mov	DWORD PTR [eax+4], 0

; 70   : 
; 71   : 	uint uiPolicyArraySize = m_pCurrentPolicies->GetPolicies()->GetNumPolicies();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _uiPolicyArraySize$[ebp], eax

; 72   : 	// Must set to the final size because we might not be adding in sequentially
; 73   : 	m_PolicyAIWeights.resize(uiPolicyArraySize);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T223205[ebp], edx
	mov	eax, DWORD PTR $T223205[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _uiPolicyArraySize$[ebp]
	jae	SHORT $LN24@Read
	mov	edx, DWORD PTR _uiPolicyArraySize$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T223205[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
$LN24@Read:
	mov	eax, DWORD PTR $T223205[ebp]
	mov	ecx, DWORD PTR _uiPolicyArraySize$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 74   : 	// Clear the contents in case we are loading a smaller set
; 75   : 	for(uint uiIndex = 0; uiIndex < uiPolicyArraySize; ++uiIndex)

	mov	DWORD PTR _uiIndex$221297[ebp], 0
	jmp	SHORT $LN7@Read
$LN6@Read:
	mov	edx, DWORD PTR _uiIndex$221297[ebp]
	add	edx, 1
	mov	DWORD PTR _uiIndex$221297[ebp], edx
$LN7@Read:
	mov	eax, DWORD PTR _uiIndex$221297[ebp]
	cmp	eax, DWORD PTR _uiPolicyArraySize$[ebp]
	jae	SHORT $LN5@Read

; 76   : 		m_PolicyAIWeights.SetWeight(uiIndex, 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _uiIndex$221297[ebp]
	mov	DWORD PTR [edx+eax*8+4], 0
	jmp	SHORT $LN6@Read
$LN5@Read:

; 77   : 
; 78   : 	uint uiPolicyCount;
; 79   : 	kStream >> uiPolicyCount;

	lea	ecx, DWORD PTR _uiPolicyCount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 80   : 
; 81   : 	for(uint uiIndex = 0; uiIndex < uiPolicyCount; ++uiIndex)

	mov	DWORD PTR _uiIndex$221302[ebp], 0
	jmp	SHORT $LN4@Read
$LN3@Read:
	mov	edx, DWORD PTR _uiIndex$221302[ebp]
	add	edx, 1
	mov	DWORD PTR _uiIndex$221302[ebp], edx
$LN4@Read:
	mov	eax, DWORD PTR _uiIndex$221302[ebp]
	cmp	eax, DWORD PTR _uiPolicyCount$[ebp]
	jae	SHORT $LN8@Read

; 82   : 	{
; 83   : 		PolicyTypes ePolicy = (PolicyTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _ePolicy$221306[ebp], eax

; 84   : 		kStream >> iWeight;

	lea	edx, DWORD PTR _iWeight$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 85   : 		if(ePolicy != NO_POLICY && (uint)ePolicy < uiPolicyArraySize)

	cmp	DWORD PTR _ePolicy$221306[ebp], -1
	je	SHORT $LN1@Read
	mov	eax, DWORD PTR _ePolicy$221306[ebp]
	cmp	eax, DWORD PTR _uiPolicyArraySize$[ebp]
	jae	SHORT $LN1@Read

; 86   : 			m_PolicyAIWeights.SetWeight((uint)ePolicy, iWeight);

	mov	ecx, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR $T223228[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _ePolicy$221306[ebp]
	mov	edx, DWORD PTR $T223228[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx
$LN1@Read:
	jmp	SHORT $LN3@Read
$LN8@Read:

; 87   : 	}
; 88   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z ENDP		; CvPolicyAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z	; CvPolicyAI::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_elem$223251 = -24					; size = 8
$T223231 = -16						; size = 4
_i$221317 = -12						; size = 4
_uiVersion$ = -8					; size = 4
_uiPolicyCount$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z PROC		; CvPolicyAI::Write, COMDAT
; _this$ = ecx

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 	// Current version number
; 94   : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 95   : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 96   : 
; 97   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies() != NULL, "Policy AI serialization failure: no policy data");
; 98   : 	CvAssertMsg(m_pCurrentPolicies->GetPolicies()->GetNumPolicies() > 0, "Policy AI serialization failure: number of policies not greater than 0");
; 99   : 
; 100  : 	// Loop through writing each entry
; 101  : 	uint uiPolicyCount = m_pCurrentPolicies->GetPolicies()->GetNumPolicies();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _uiPolicyCount$[ebp], eax

; 102  : 	kStream << uiPolicyCount;

	lea	edx, DWORD PTR _uiPolicyCount$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 103  : 
; 104  : #ifdef AUI_WARNING_FIXES
; 105  : 	for (uint i = 0; i < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); i++)
; 106  : #else
; 107  : 	for(int i = 0; i < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); i++)

	mov	DWORD PTR _i$221317[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	eax, DWORD PTR _i$221317[ebp]
	add	eax, 1
	mov	DWORD PTR _i$221317[ebp], eax
$LN3@Write:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$221317[ebp], eax
	jge	SHORT $LN4@Write

; 108  : #endif
; 109  : 	{
; 110  : 		CvInfosSerializationHelper::WriteHashed(kStream, static_cast<const PolicyTypes>(i));

	mov	edx, DWORD PTR _i$221317[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 111  : 		kStream << m_PolicyAIWeights.GetWeight(i);

	mov	DWORD PTR _elem$223251[ebp], 0
	mov	DWORD PTR _elem$223251[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$221317[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$223251[ebp], ecx
	mov	DWORD PTR _elem$223251[ebp+4], edx
	mov	eax, DWORD PTR _elem$223251[ebp+4]
	mov	DWORD PTR $T223231[ebp], eax
	lea	ecx, DWORD PTR $T223231[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 112  : 	}

	jmp	SHORT $LN2@Write
$LN4@Write:

; 113  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z ENDP		; CvPolicyAI::Write
_TEXT	ENDS
PUBLIC	?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z		; CvPolicyAI::WeightPrereqs
PUBLIC	__$ArrayPad$
PUBLIC	?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z ; CvPolicyAI::AddFlavorWeights
EXTRN	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z:PROC	; CvPolicyEntry::GetFlavorValue
EXTRN	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z:PROC ; CvPolicyXMLEntries::GetPolicyEntry
EXTRN	__alloca_probe_16:PROC
; Function compile flags: /Odtp
;	COMDAT ?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z
_TEXT	SEGMENT
tv144 = -36						; size = 4
tv71 = -32						; size = 4
_this$ = -28						; size = 4
$T223266 = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
_entry$ = -16						; size = 4
_iPolicy$ = -12						; size = 4
_paiTempWeights$ = -8					; size = 4
_pkPolicyEntries$ = -4					; size = 4
_eFlavor$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z PROC ; CvPolicyAI::AddFlavorWeights, COMDAT
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 118  : #ifdef AUI_WARNING_FIXES
; 119  : 	uint iPolicy;
; 120  : #else
; 121  : 	int iPolicy;
; 122  : #endif
; 123  : 	CvPolicyEntry* entry;
; 124  : #ifndef AUI_WARNING_FIXES
; 125  : 	int* paiTempWeights;
; 126  : #endif
; 127  : 
; 128  : 	CvPolicyXMLEntries* pkPolicyEntries = m_pCurrentPolicies->GetPolicies();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	DWORD PTR _pkPolicyEntries$[ebp], eax

; 129  : 	// Create a temporary array of weights
; 130  : #ifdef AUI_WARNING_FIXES
; 131  : 	FFastVector<int, true> paiTempWeights;
; 132  : 	paiTempWeights.reserve(pkPolicyEntries->GetNumPolicies());
; 133  : #else
; 134  : 	paiTempWeights = (int*)_alloca(sizeof(int*) * pkPolicyEntries->GetNumPolicies());

	mov	ecx, DWORD PTR _pkPolicyEntries$[ebp]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	shl	eax, 2
	call	__alloca_probe_16
	mov	DWORD PTR tv71[ebp], esp
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _paiTempWeights$[ebp], ecx

; 135  : #endif
; 136  : 
; 137  : 	// Loop through all our policies
; 138  : 	for(iPolicy = 0; iPolicy < pkPolicyEntries->GetNumPolicies(); iPolicy++)

	mov	DWORD PTR _iPolicy$[ebp], 0
	jmp	SHORT $LN9@AddFlavorW
$LN8@AddFlavorW:
	mov	edx, DWORD PTR _iPolicy$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPolicy$[ebp], edx
$LN9@AddFlavorW:
	mov	ecx, DWORD PTR _pkPolicyEntries$[ebp]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicy$[ebp], eax
	jge	SHORT $LN7@AddFlavorW

; 139  : 	{
; 140  : 		entry = pkPolicyEntries->GetPolicyEntry(iPolicy);

	mov	eax, DWORD PTR _iPolicy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPolicyEntries$[ebp]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _entry$[ebp], eax

; 141  : 
; 142  : 		// Set its weight by looking at policy's weight for this flavor and using iWeight multiplier passed in
; 143  : 		if(entry)

	cmp	DWORD PTR _entry$[ebp], 0
	je	SHORT $LN6@AddFlavorW

; 144  : #ifdef AUI_WARNING_FIXES
; 145  : 			paiTempWeights.push_back(entry->GetFlavorValue(eFlavor) * iWeight);
; 146  : 		else
; 147  : 			paiTempWeights.push_back(0);
; 148  : #else
; 149  : 			paiTempWeights[iPolicy] = entry->GetFlavorValue(eFlavor) * iWeight;

	mov	ecx, DWORD PTR _eFlavor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _entry$[ebp]
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	imul	eax, DWORD PTR _iWeight$[ebp]
	mov	edx, DWORD PTR _iPolicy$[ebp]
	mov	ecx, DWORD PTR _paiTempWeights$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 150  : 		else

	jmp	SHORT $LN5@AddFlavorW
$LN6@AddFlavorW:

; 151  : 			paiTempWeights[iPolicy] = 0;

	mov	edx, DWORD PTR _iPolicy$[ebp]
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
$LN5@AddFlavorW:

; 152  : #endif
; 153  : 	}

	jmp	SHORT $LN8@AddFlavorW
$LN7@AddFlavorW:

; 154  : 
; 155  : 	// Propagate these values left in the tree so prereqs get bought
; 156  : 	if(iPropagationPercent > 0)

	cmp	DWORD PTR _iPropagationPercent$[ebp], 0
	jle	SHORT $LN4@AddFlavorW

; 157  : 	{
; 158  : 		WeightPrereqs(paiTempWeights, iPropagationPercent);

	mov	ecx, DWORD PTR _iPropagationPercent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _paiTempWeights$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z	; CvPolicyAI::WeightPrereqs
$LN4@AddFlavorW:

; 159  : 	}
; 160  : 
; 161  : 	// Add these weights over previous ones
; 162  : 	for(iPolicy = 0; iPolicy < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicy++)

	mov	DWORD PTR _iPolicy$[ebp], 0
	jmp	SHORT $LN3@AddFlavorW
$LN2@AddFlavorW:
	mov	eax, DWORD PTR _iPolicy$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPolicy$[ebp], eax
$LN3@AddFlavorW:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicy$[ebp], eax
	jge	SHORT $LN10@AddFlavorW

; 163  : 	{
; 164  : 		m_PolicyAIWeights.IncreaseWeight(iPolicy, paiTempWeights[iPolicy]);

	mov	edx, DWORD PTR _iPolicy$[ebp]
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T223266[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iPolicy$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR tv144[ebp], edx
	mov	eax, DWORD PTR tv144[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR $T223266[ebp]
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR [edx], ecx

; 165  : 	}

	jmp	SHORT $LN2@AddFlavorW
$LN10@AddFlavorW:

; 166  : }

	lea	esp, DWORD PTR [ebp-36]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z ENDP ; CvPolicyAI::AddFlavorWeights
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ; CvPolicyAI::LogBranchChoice
PUBLIC	?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,64,1>::ChooseAtRandom
PUBLIC	??_C@_0CM@GEFFIOHP@Choosing?5policy?5at?5random?5?$CIno?5go@ ; `string'
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,64,1>::ChooseFromTopChoices
PUBLIC	??_C@_0CB@EPKNHKBJ@Choosing?5policy?5from?5Top?5Choices@ ; `string'
PUBLIC	??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@		; `string'
PUBLIC	??_C@_0BB@BPIBEAAN@FLAVOR_DIPLOMACY?$AA@	; `string'
PUBLIC	??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ ; `string'
PUBLIC	??_C@_0BB@EDNPBEHK@FLAVOR_SPACESHIP?$AA@	; `string'
PUBLIC	??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ ; `string'
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice
PUBLIC	??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@		; `string'
PUBLIC	??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ ; `string'
PUBLIC	?LogPossiblePolicies@CvPolicyAI@@AAEXXZ		; CvPolicyAI::LogPossiblePolicies
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
PUBLIC	?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z ; CvPolicyAI::WeighBranch
PUBLIC	?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z ; CvPolicyAI::IsBranchEffectiveInGame
PUBLIC	??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@	; `string'
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
PUBLIC	?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z ; CvPolicyAI::ChooseNextPolicy
EXTRN	?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ:PROC ; CvHandicapInfo::GetPolicyNumOptions
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::CanUnlockPolicyBranch
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsMutuallyExclusive
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z:PROC ; CvGlobals::getPolicyBranchInfo
EXTRN	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyBranchInfos
EXTRN	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ:PROC ; CvPolicyBranchEntry::GetFreeFinishingPolicy
EXTRN	?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z:PROC ; CvPolicyXMLEntries::GetPolicyBranchEntry
EXTRN	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ:PROC	; CvPolicyEntry::GetPolicyBranchType
EXTRN	?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::WillFinishBranchIfAdopted
EXTRN	?GetLevel@CvPolicyEntry@@QBEHXZ:PROC		; CvPolicyEntry::GetLevel
EXTRN	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z:PROC ; CvPlayerPolicies::CanAdoptPolicy
EXTRN	?GetNumFreeTenets@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetNumFreeTenets
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
;	COMDAT ??_C@_0CM@GEFFIOHP@Choosing?5policy?5at?5random?5?$CIno?5go@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0CM@GEFFIOHP@Choosing?5policy?5at?5random?5?$CIno?5go@ DB 'Choosing'
	DB	' policy at random (no good choices)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EPKNHKBJ@Choosing?5policy?5from?5Top?5Choices@
CONST	SEGMENT
??_C@_0CB@EPKNHKBJ@Choosing?5policy?5from?5Top?5Choices@ DB 'Choosing pol'
	DB	'icy from Top Choices', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@
CONST	SEGMENT
??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@ DB 'FLAVOR_CULTURE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BPIBEAAN@FLAVOR_DIPLOMACY?$AA@
CONST	SEGMENT
??_C@_0BB@BPIBEAAN@FLAVOR_DIPLOMACY?$AA@ DB 'FLAVOR_DIPLOMACY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
CONST	SEGMENT
??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ DB 'AIGRANDSTRATEG'
	DB	'Y_UNITED_NATIONS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EDNPBEHK@FLAVOR_SPACESHIP?$AA@
CONST	SEGMENT
??_C@_0BB@EDNPBEHK@FLAVOR_SPACESHIP?$AA@ DB 'FLAVOR_SPACESHIP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
CONST	SEGMENT
??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ DB 'AIGRANDSTRATEGY_SPAC'
	DB	'ESHIP', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
CONST	SEGMENT
??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@ DB 'FLAVOR_OFFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
CONST	SEGMENT
??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ DB 'AIGRANDSTRATEGY_CONQ'
	DB	'UEST', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
CONST	SEGMENT
??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@ DB 'AIGRANDSTRATEGY_CULTU'
	DB	'RE', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$10
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -556						; size = 4
$T223871 = -496						; size = 4
$T223866 = -492						; size = 4
$T223851 = -488						; size = 4
$T223844 = -484						; size = 4
_elem$223865 = -480					; size = 8
_i$223861 = -472					; size = 4
_rtnValue$223860 = -468					; size = 4
$T223806 = -428						; size = 4
$T223802 = -424						; size = 4
$T223787 = -420						; size = 4
$T223780 = -416						; size = 4
_elem$223801 = -412					; size = 8
_i$223797 = -404					; size = 4
_rtnValue$223796 = -400					; size = 4
$T223720 = -368						; size = 4
$T223658 = -336						; size = 4
$T223596 = -304						; size = 4
$T223534 = -272						; size = 4
$T223527 = -268						; size = 4
$T223509 = -264						; size = 4
__Tmp$223499 = -260					; size = 4
$T223484 = -256						; size = 4
$T223468 = -252						; size = 4
$T223456 = -248						; size = 4
$T223452 = -244						; size = 4
_weightedElem$223447 = -240				; size = 8
_weightedElem$223403 = -208				; size = 8
_elem$223394 = -200					; size = 8
$T223380 = -192						; size = 4
_elem$223379 = -188					; size = 8
$T223365 = -180						; size = 4
_i$223359 = -176					; size = 4
$T223327 = -164						; size = 4
$T223311 = -160						; size = 4
$T223279 = -156						; size = 4
$T223278 = -152						; size = 4
$T223277 = -148						; size = 4
$T223276 = -144						; size = 4
$T223275 = -140						; size = 4
$T223274 = -136						; size = 4
$T223273 = -132						; size = 4
$T223272 = -128						; size = 4
$T223271 = -124						; size = 4
$T223270 = -120						; size = 8
_iNumChoices$221600 = -112				; size = 4
_eGrandStrategy$221568 = -108				; size = 4
_pEntry$221566 = -104					; size = 4
_it$221559 = -100					; size = 4
_iBranchWeight$221551 = -96				; size = 4
_pkPolicyBranchInfo$221547 = -92			; size = 4
_ePolicyBranch$221545 = -88				; size = 4
_iBranchLoop$221541 = -84				; size = 4
_pkPolicyBranchInfo$221532 = -80			; size = 4
_ePolicyBranch$221530 = -76				; size = 4
_iBranchLoop$221526 = -72				; size = 4
_iFinisherPolicy$221521 = -68				; size = 4
_iPolicyBranch$221519 = -64				; size = 4
_iWeight$221516 = -60					; size = 4
_fcn$ = -56						; size = 8
_iRtnValue$ = -48					; size = 4
_bMustChooseTenet$ = -42				; size = 1
_bStartedAMutuallyExclusiveBranch$ = -41		; size = 1
_eCultureGrandStrategy$ = -40				; size = 4
_iPolicyLoop$ = -36					; size = 4
_aLevel3Tenets$ = -32					; size = 16
_eCurrentGrandStrategy$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z PROC	; CvPolicyAI::ChooseNextPolicy, COMDAT
; _this$ = ecx

; 174  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 544				; 00000220H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 	RandomNumberDelegate fcn;

	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0
	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0

; 176  : 	fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223311[ebp], eax
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	ecx, DWORD PTR $T223311[ebp]
	push	ecx
	lea	edx, DWORD PTR $T223270[ebp]
	push	edx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T223327[ebp], eax
	mov	eax, DWORD PTR $T223327[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _fcn$[ebp+4], ecx
	mov	edx, DWORD PTR $T223327[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _fcn$[ebp], eax

; 177  : #ifdef AUI_WARNING_FIXES
; 178  : 	uint iRtnValue = (uint)NO_POLICY;
; 179  : 	uint iPolicyLoop;
; 180  : #else
; 181  : 	int iRtnValue = (int)NO_POLICY;

	mov	DWORD PTR _iRtnValue$[ebp], -1

; 182  : 	int iPolicyLoop;
; 183  : #endif
; 184  : 	vector<int> aLevel3Tenets;

	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 185  : 
; 186  : 	bool bMustChooseTenet = (pPlayer->GetNumFreeTenets() > 0);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR _bMustChooseTenet$[ebp], cl

; 187  : 
; 188  : 	// Create a new vector holding only policies we can currently adopt
; 189  : 	m_AdoptablePolicies.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 532				; 00000214H
	mov	DWORD PTR $T223365[ebp], edx
	xor	eax, eax
	je	SHORT $LN81@ChooseNext
	mov	DWORD PTR _i$223359[ebp], 0
	jmp	SHORT $LN79@ChooseNext
$LN78@ChooseNext:
	mov	ecx, DWORD PTR _i$223359[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$223359[ebp], ecx
$LN79@ChooseNext:
	mov	edx, DWORD PTR $T223365[ebp]
	mov	eax, DWORD PTR _i$223359[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN81@ChooseNext
	jmp	SHORT $LN78@ChooseNext
$LN81@ChooseNext:
	mov	ecx, DWORD PTR $T223365[ebp]
	mov	DWORD PTR [ecx+4], 0

; 190  : 
; 191  : 	// Loop through adding the adoptable policies
; 192  : 	for(iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$[ebp], 0
	jmp	SHORT $LN46@ChooseNext
$LN45@ChooseNext:
	mov	edx, DWORD PTR _iPolicyLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPolicyLoop$[ebp], edx
$LN46@ChooseNext:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$[ebp], eax
	jge	$LN44@ChooseNext

; 193  : 	{
; 194  : 		if(m_pCurrentPolicies->CanAdoptPolicy((PolicyTypes) iPolicyLoop) && (!bMustChooseTenet || m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicyLoop)->GetLevel() > 0))

	push	0
	mov	ecx, DWORD PTR _iPolicyLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ; CvPlayerPolicies::CanAdoptPolicy
	movzx	eax, al
	test	eax, eax
	je	$LN43@ChooseNext
	movzx	ecx, BYTE PTR _bMustChooseTenet$[ebp]
	test	ecx, ecx
	je	SHORT $LN42@ChooseNext
	mov	edx, DWORD PTR _iPolicyLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	test	eax, eax
	jle	$LN43@ChooseNext
$LN42@ChooseNext:

; 195  : 		{
; 196  : 			int iWeight = 0;

	mov	DWORD PTR _iWeight$221516[ebp], 0

; 197  : 
; 198  : 			iWeight += m_PolicyAIWeights.GetWeight(iPolicyLoop);

	mov	ecx, DWORD PTR _iPolicyLoop$[ebp]
	mov	DWORD PTR $T223380[ebp], ecx
	mov	DWORD PTR _elem$223379[ebp], 0
	mov	DWORD PTR _elem$223379[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR $T223380[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$223379[ebp], edx
	mov	DWORD PTR _elem$223379[ebp+4], eax
	mov	ecx, DWORD PTR _iWeight$221516[ebp]
	add	ecx, DWORD PTR _elem$223379[ebp+4]
	mov	DWORD PTR _iWeight$221516[ebp], ecx

; 199  : 
; 200  : 			// Does this policy finish a branch for us?
; 201  : 			if(m_pCurrentPolicies->WillFinishBranchIfAdopted((PolicyTypes) iPolicyLoop))

	mov	edx, DWORD PTR _iPolicyLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::WillFinishBranchIfAdopted
	movzx	ecx, al
	test	ecx, ecx
	je	$LN41@ChooseNext

; 202  : 			{
; 203  : 				int iPolicyBranch = m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicyLoop)->GetPolicyBranchType();

	mov	edx, DWORD PTR _iPolicyLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _iPolicyBranch$221519[ebp], eax

; 204  : 				if(iPolicyBranch != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _iPolicyBranch$221519[ebp], -1
	je	SHORT $LN41@ChooseNext

; 205  : 				{
; 206  : 					int iFinisherPolicy = m_pCurrentPolicies->GetPolicies()->GetPolicyBranchEntry(iPolicyBranch)->GetFreeFinishingPolicy();

	mov	ecx, DWORD PTR _iPolicyBranch$221519[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyBranchEntry
	mov	ecx, eax
	call	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreeFinishingPolicy
	mov	DWORD PTR _iFinisherPolicy$221521[ebp], eax

; 207  : 					if(iFinisherPolicy != NO_POLICY)

	cmp	DWORD PTR _iFinisherPolicy$221521[ebp], -1
	je	SHORT $LN41@ChooseNext

; 208  : 					{
; 209  : 						iWeight += m_PolicyAIWeights.GetWeight(iFinisherPolicy);

	mov	DWORD PTR _elem$223394[ebp], 0
	mov	DWORD PTR _elem$223394[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iFinisherPolicy$221521[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _elem$223394[ebp], eax
	mov	DWORD PTR _elem$223394[ebp+4], ecx
	mov	edx, DWORD PTR _iWeight$221516[ebp]
	add	edx, DWORD PTR _elem$223394[ebp+4]
	mov	DWORD PTR _iWeight$221516[ebp], edx
$LN41@ChooseNext:

; 210  : 					}
; 211  : 				}
; 212  : 			}
; 213  : 			m_AdoptablePolicies.push_back(iPolicyLoop + GC.getNumPolicyBranchInfos(), iWeight);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	add	eax, DWORD PTR _iPolicyLoop$[ebp]
	mov	DWORD PTR $T223271[ebp], eax
	mov	DWORD PTR _weightedElem$223403[ebp], 0
	mov	DWORD PTR _weightedElem$223403[ebp+4], 0
	mov	eax, DWORD PTR $T223271[ebp]
	mov	DWORD PTR _weightedElem$223403[ebp], eax
	mov	ecx, DWORD PTR _iWeight$221516[ebp]
	mov	DWORD PTR _weightedElem$223403[ebp+4], ecx
	lea	edx, DWORD PTR _weightedElem$223403[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back

; 214  : 
; 215  : 			if (m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicyLoop)->GetLevel() == 3)

	mov	eax, DWORD PTR _iPolicyLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	cmp	eax, 3
	jne	SHORT $LN43@ChooseNext

; 216  : 			{
; 217  : 				aLevel3Tenets.push_back(iPolicyLoop);

	lea	edx, DWORD PTR _iPolicyLoop$[ebp]
	push	edx
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
$LN43@ChooseNext:

; 218  : 			}
; 219  : 		}
; 220  : 	}

	jmp	$LN45@ChooseNext
$LN44@ChooseNext:

; 221  : 
; 222  : 	// Did we already start a branch in the set that is mutually exclusive?
; 223  : 	bool bStartedAMutuallyExclusiveBranch = false;

	mov	BYTE PTR _bStartedAMutuallyExclusiveBranch$[ebp], 0

; 224  : #ifdef AUI_WARNING_FIXES
; 225  : 	for (uint iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)
; 226  : #else
; 227  : 	for(int iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$221526[ebp], 0
	jmp	SHORT $LN37@ChooseNext
$LN36@ChooseNext:
	mov	eax, DWORD PTR _iBranchLoop$221526[ebp]
	add	eax, 1
	mov	DWORD PTR _iBranchLoop$221526[ebp], eax
$LN37@ChooseNext:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	cmp	DWORD PTR _iBranchLoop$221526[ebp], eax
	jge	SHORT $LN35@ChooseNext

; 228  : #endif
; 229  : 	{
; 230  : 		const PolicyBranchTypes ePolicyBranch = static_cast<PolicyBranchTypes>(iBranchLoop);

	mov	ecx, DWORD PTR _iBranchLoop$221526[ebp]
	mov	DWORD PTR _ePolicyBranch$221530[ebp], ecx

; 231  : 		CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(ePolicyBranch);

	mov	edx, DWORD PTR _ePolicyBranch$221530[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$221532[ebp], eax

; 232  : 		if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$221532[ebp], 0
	je	SHORT $LN34@ChooseNext

; 233  : 		{
; 234  : 			if(pPlayer->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))

	mov	eax, DWORD PTR _ePolicyBranch$221530[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@ChooseNext

; 235  : 			{
; 236  : 				if(pkPolicyBranchInfo->IsMutuallyExclusive())

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$221532[ebp]
	call	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsMutuallyExclusive
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN34@ChooseNext

; 237  : 				{
; 238  : 					bStartedAMutuallyExclusiveBranch = true;

	mov	BYTE PTR _bStartedAMutuallyExclusiveBranch$[ebp], 1
$LN34@ChooseNext:

; 239  : 				}
; 240  : 			}
; 241  : 		}
; 242  : 	}

	jmp	SHORT $LN36@ChooseNext
$LN35@ChooseNext:

; 243  : 
; 244  : 	AIGrandStrategyTypes eCultureGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eCultureGrandStrategy$[ebp], eax

; 245  : 	AIGrandStrategyTypes eCurrentGrandStrategy = pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	mov	DWORD PTR _eCurrentGrandStrategy$[ebp], eax

; 246  : 
; 247  : 	// Loop though the branches adding each as another possibility
; 248  : 	if (!bMustChooseTenet)

	movzx	eax, BYTE PTR _bMustChooseTenet$[ebp]
	test	eax, eax
	jne	$LN31@ChooseNext

; 249  : 	{
; 250  : #ifdef AUI_WARNING_FIXES
; 251  : 		for (uint iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)
; 252  : #else
; 253  : 		for(int iBranchLoop = 0; iBranchLoop < GC.getNumPolicyBranchInfos(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$221541[ebp], 0
	jmp	SHORT $LN30@ChooseNext
$LN29@ChooseNext:
	mov	ecx, DWORD PTR _iBranchLoop$221541[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBranchLoop$221541[ebp], ecx
$LN30@ChooseNext:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	cmp	DWORD PTR _iBranchLoop$221541[ebp], eax
	jge	$LN31@ChooseNext

; 254  : #endif
; 255  : 		{
; 256  : 			const PolicyBranchTypes ePolicyBranch = static_cast<PolicyBranchTypes>(iBranchLoop);

	mov	edx, DWORD PTR _iBranchLoop$221541[ebp]
	mov	DWORD PTR _ePolicyBranch$221545[ebp], edx

; 257  : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(ePolicyBranch);

	mov	eax, DWORD PTR _ePolicyBranch$221545[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$221547[ebp], eax

; 258  : 			if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$221547[ebp], 0
	je	$LN27@ChooseNext

; 259  : 			{
; 260  : 				if(bStartedAMutuallyExclusiveBranch && pkPolicyBranchInfo->IsMutuallyExclusive())

	movzx	ecx, BYTE PTR _bStartedAMutuallyExclusiveBranch$[ebp]
	test	ecx, ecx
	je	SHORT $LN26@ChooseNext
	mov	ecx, DWORD PTR _pkPolicyBranchInfo$221547[ebp]
	call	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsMutuallyExclusive
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN26@ChooseNext

; 261  : 				{
; 262  : 					continue;

	jmp	SHORT $LN29@ChooseNext
$LN26@ChooseNext:

; 263  : 				}
; 264  : 
; 265  : 				if(pPlayer->GetPlayerPolicies()->CanUnlockPolicyBranch(ePolicyBranch) && !pPlayer->GetPlayerPolicies()->IsPolicyBranchUnlocked(ePolicyBranch))

	mov	eax, DWORD PTR _ePolicyBranch$221545[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	movzx	ecx, al
	test	ecx, ecx
	je	$LN27@ChooseNext
	mov	edx, DWORD PTR _ePolicyBranch$221545[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	jne	$LN27@ChooseNext

; 266  : 				{
; 267  : 					int iBranchWeight = 0;

	mov	DWORD PTR _iBranchWeight$221551[ebp], 0

; 268  : 
; 269  : 					// Does this branch actually help us, based on game options?
; 270  : 					if(IsBranchEffectiveInGame(ePolicyBranch))

	mov	ecx, DWORD PTR _ePolicyBranch$221545[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z ; CvPolicyAI::IsBranchEffectiveInGame
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN24@ChooseNext

; 271  : 					{
; 272  : 						iBranchWeight += WeighBranch(ePolicyBranch);

	mov	eax, DWORD PTR _ePolicyBranch$221545[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z ; CvPolicyAI::WeighBranch
	add	eax, DWORD PTR _iBranchWeight$221551[ebp]
	mov	DWORD PTR _iBranchWeight$221551[ebp], eax

; 273  : 
; 274  : 						iBranchWeight *= (100 - m_iPolicyWeightPercentDropNewBranch);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, 100				; 00000064H
	sub	edx, DWORD PTR [ecx+1064]
	imul	edx, DWORD PTR _iBranchWeight$221551[ebp]
	mov	DWORD PTR _iBranchWeight$221551[ebp], edx

; 275  : 						iBranchWeight /= 100;

	mov	eax, DWORD PTR _iBranchWeight$221551[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iBranchWeight$221551[ebp], eax

; 276  : 						if(eCurrentGrandStrategy == eCultureGrandStrategy)

	mov	edx, DWORD PTR _eCurrentGrandStrategy$[ebp]
	cmp	edx, DWORD PTR _eCultureGrandStrategy$[ebp]
	jne	SHORT $LN24@ChooseNext

; 277  : 						{
; 278  : 							iBranchWeight /= 3;

	mov	eax, DWORD PTR _iBranchWeight$221551[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _iBranchWeight$221551[ebp], eax
$LN24@ChooseNext:

; 279  : 						}
; 280  : 					}
; 281  : 
; 282  : 					m_AdoptablePolicies.push_back(iBranchLoop, iBranchWeight);

	mov	DWORD PTR _weightedElem$223447[ebp], 0
	mov	DWORD PTR _weightedElem$223447[ebp+4], 0
	mov	edx, DWORD PTR _iBranchLoop$221541[ebp]
	mov	DWORD PTR _weightedElem$223447[ebp], edx
	mov	eax, DWORD PTR _iBranchWeight$221551[ebp]
	mov	DWORD PTR _weightedElem$223447[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$223447[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back
$LN27@ChooseNext:

; 283  : 				}
; 284  : 			}
; 285  : 		}

	jmp	$LN29@ChooseNext
$LN31@ChooseNext:

; 286  : 	}
; 287  : 
; 288  : 	m_AdoptablePolicies.SortItems();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 532				; 00000214H
	mov	DWORD PTR $T223468[ebp], edx
	mov	eax, DWORD PTR $T223468[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T223468[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T223452[ebp], ecx
	mov	edx, DWORD PTR $T223468[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223456[ebp], eax
	mov	ecx, DWORD PTR $T223452[ebp]
	sub	ecx, DWORD PTR $T223456[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T223452[ebp]
	push	edx
	mov	eax, DWORD PTR $T223456[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 289  : 	LogPossiblePolicies();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPossiblePolicies@CvPolicyAI@@AAEXXZ	; CvPolicyAI::LogPossiblePolicies

; 290  : 
; 291  : 	// If there were any Level 3 tenets found, consider going for the one that matches our victory strategy
; 292  : 	if (aLevel3Tenets.size() > 0)

	mov	ecx, DWORD PTR _aLevel3Tenets$[ebp+8]
	sub	ecx, DWORD PTR _aLevel3Tenets$[ebp+4]
	sar	ecx, 2
	test	ecx, ecx
	jbe	$LN22@ChooseNext

; 293  : 	{
; 294  : 		vector<int>::const_iterator it;

	mov	DWORD PTR _it$221559[ebp], 0

; 295  : #ifdef AUI_ITERATOR_POSTFIX_INCREMENT_OPTIMIZATIONS
; 296  : 		for (it = aLevel3Tenets.begin(); it != aLevel3Tenets.end(); ++it)
; 297  : #else
; 298  : 		for (it = aLevel3Tenets.begin(); it != aLevel3Tenets.end(); it++)

	mov	edx, DWORD PTR _aLevel3Tenets$[ebp+4]
	mov	DWORD PTR $T223484[ebp], edx
	mov	eax, DWORD PTR $T223484[ebp]
	mov	DWORD PTR $T223272[ebp], eax
	mov	ecx, DWORD PTR $T223272[ebp]
	mov	DWORD PTR _it$221559[ebp], ecx
	jmp	SHORT $LN21@ChooseNext
$LN20@ChooseNext:
	mov	edx, DWORD PTR _it$221559[ebp]
	mov	DWORD PTR __Tmp$223499[ebp], edx
	mov	eax, DWORD PTR _it$221559[ebp]
	add	eax, 4
	mov	DWORD PTR _it$221559[ebp], eax
	mov	ecx, DWORD PTR __Tmp$223499[ebp]
	mov	DWORD PTR $T223273[ebp], ecx
$LN21@ChooseNext:
	mov	edx, DWORD PTR _aLevel3Tenets$[ebp+8]
	mov	DWORD PTR $T223509[ebp], edx
	mov	eax, DWORD PTR $T223509[ebp]
	mov	DWORD PTR $T223274[ebp], eax
	mov	ecx, DWORD PTR _it$221559[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T223274[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN22@ChooseNext

; 299  : #endif
; 300  : 		{
; 301  : 			CvPolicyEntry *pEntry;
; 302  : 			pEntry = m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(*it);

	mov	edx, DWORD PTR _it$221559[ebp]
	mov	DWORD PTR $T223527[ebp], edx
	mov	eax, DWORD PTR $T223527[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pEntry$221566[ebp], eax

; 303  : 			if (pEntry)

	cmp	DWORD PTR _pEntry$221566[ebp], 0
	je	$LN18@ChooseNext

; 304  : 			{
; 305  : 				AIGrandStrategyTypes eGrandStrategy = pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	mov	DWORD PTR _eGrandStrategy$221568[ebp], eax

; 306  : 				if (eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST"))

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eGrandStrategy$221568[ebp], eax
	jne	SHORT $LN17@ChooseNext

; 307  : 				{
; 308  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_OFFENSE")) > 0)

	push	0
	push	OFFSET ??_C@_0P@ELMNBNJP@FLAVOR_OFFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pEntry$221566[ebp]
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	test	eax, eax
	jle	SHORT $LN16@ChooseNext

; 309  : 					{
; 310  : 						LogPolicyChoice((PolicyTypes)*it);

	mov	eax, DWORD PTR _it$221559[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice

; 311  : 						return (*it) + GC.getNumPolicyBranchInfos();

	mov	edx, DWORD PTR _it$221559[ebp]
	mov	DWORD PTR $T223534[ebp], edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	ecx, DWORD PTR $T223534[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T223275[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T223275[ebp]
	jmp	$LN47@ChooseNext
$LN16@ChooseNext:

; 312  : 					}
; 313  : 				}

	jmp	$LN18@ChooseNext
$LN17@ChooseNext:

; 314  : 				else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP"))

	push	0
	push	OFFSET ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eGrandStrategy$221568[ebp], eax
	jne	SHORT $LN14@ChooseNext

; 315  : 				{
; 316  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_SPACESHIP")) > 0)

	push	0
	push	OFFSET ??_C@_0BB@EDNPBEHK@FLAVOR_SPACESHIP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pEntry$221566[ebp]
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	test	eax, eax
	jle	SHORT $LN13@ChooseNext

; 317  : 					{
; 318  : 						LogPolicyChoice((PolicyTypes)*it);

	mov	edx, DWORD PTR _it$221559[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice

; 319  : 						return (*it) + GC.getNumPolicyBranchInfos();

	mov	ecx, DWORD PTR _it$221559[ebp]
	mov	DWORD PTR $T223596[ebp], ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	edx, DWORD PTR $T223596[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223276[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T223276[ebp]
	jmp	$LN47@ChooseNext
$LN13@ChooseNext:

; 320  : 					}
; 321  : 				}

	jmp	$LN18@ChooseNext
$LN14@ChooseNext:

; 322  : 				else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS"))

	push	0
	push	OFFSET ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eGrandStrategy$221568[ebp], eax
	jne	SHORT $LN11@ChooseNext

; 323  : 				{
; 324  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_DIPLOMACY")) > 0)

	push	0
	push	OFFSET ??_C@_0BB@BPIBEAAN@FLAVOR_DIPLOMACY?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pEntry$221566[ebp]
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	test	eax, eax
	jle	SHORT $LN10@ChooseNext

; 325  : 					{
; 326  : 						LogPolicyChoice((PolicyTypes)*it);

	mov	eax, DWORD PTR _it$221559[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice

; 327  : 						return (*it) + GC.getNumPolicyBranchInfos();

	mov	edx, DWORD PTR _it$221559[ebp]
	mov	DWORD PTR $T223658[ebp], edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	ecx, DWORD PTR $T223658[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T223277[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T223277[ebp]
	jmp	$LN47@ChooseNext
$LN10@ChooseNext:

; 328  : 					}
; 329  : 				}

	jmp	$LN18@ChooseNext
$LN11@ChooseNext:

; 330  : 				else if(eGrandStrategy == GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE"))

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _eGrandStrategy$221568[ebp], eax
	jne	SHORT $LN18@ChooseNext

; 331  : 				{
; 332  : 					if (pEntry->GetFlavorValue((FlavorTypes)GC.getInfoTypeForString("FLAVOR_CULTURE")) > 0)

	push	0
	push	OFFSET ??_C@_0P@DAJFKJHO@FLAVOR_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pEntry$221566[ebp]
	call	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetFlavorValue
	test	eax, eax
	jle	SHORT $LN18@ChooseNext

; 333  : 					{
; 334  : 						LogPolicyChoice((PolicyTypes)*it);

	mov	edx, DWORD PTR _it$221559[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice

; 335  : 						return (*it) + GC.getNumPolicyBranchInfos();

	mov	ecx, DWORD PTR _it$221559[ebp]
	mov	DWORD PTR $T223720[ebp], ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	edx, DWORD PTR $T223720[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223278[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T223278[ebp]
	jmp	$LN47@ChooseNext
$LN18@ChooseNext:

; 336  : 					}
; 337  : 				}
; 338  : 			}
; 339  : 		}

	jmp	$LN20@ChooseNext
$LN22@ChooseNext:

; 340  : 	}
; 341  : 
; 342  : 	CvAssertMsg(m_AdoptablePolicies.GetTotalWeight() >= 0, "Total weights of considered policies should not be negative! Please send Anton your save file and version.");
; 343  : 
; 344  : 	// If total weight is above 0, choose one above a threshold
; 345  : 	if(m_AdoptablePolicies.GetTotalWeight() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 532				; 00000214H
	mov	DWORD PTR $T223802[ebp], eax
	mov	DWORD PTR _rtnValue$223796[ebp], 0
	mov	DWORD PTR _i$223797[ebp], 0
	jmp	SHORT $LN257@ChooseNext
$LN256@ChooseNext:
	mov	ecx, DWORD PTR _i$223797[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$223797[ebp], ecx
$LN257@ChooseNext:
	mov	edx, DWORD PTR $T223802[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223780[ebp], eax
	mov	ecx, DWORD PTR _i$223797[ebp]
	cmp	ecx, DWORD PTR $T223780[ebp]
	jae	SHORT $LN258@ChooseNext
	mov	edx, DWORD PTR $T223802[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$223797[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T223787[ebp], edx
	mov	eax, DWORD PTR $T223787[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$223801[ebp], ecx
	mov	edx, DWORD PTR $T223787[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _elem$223801[ebp+4], eax
	mov	ecx, DWORD PTR _rtnValue$223796[ebp]
	add	ecx, DWORD PTR _elem$223801[ebp+4]
	mov	DWORD PTR _rtnValue$223796[ebp], ecx
	jmp	SHORT $LN256@ChooseNext
$LN258@ChooseNext:
	cmp	DWORD PTR _rtnValue$223796[ebp], 0
	jle	SHORT $LN6@ChooseNext

; 346  : 	{
; 347  : 		int iNumChoices = GC.getGame().getHandicapInfo().GetPolicyNumOptions();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223806[ebp], edx
	mov	ecx, DWORD PTR $T223806[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?GetPolicyNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetPolicyNumOptions
	mov	DWORD PTR _iNumChoices$221600[ebp], eax

; 348  : 		iRtnValue = m_AdoptablePolicies.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing policy from Top Choices");

	push	OFFSET ??_C@_0CB@EPKNHKBJ@Choosing?5policy?5from?5Top?5Choices@
	lea	eax, DWORD PTR _fcn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumChoices$221600[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,64,1>::ChooseFromTopChoices
	mov	DWORD PTR _iRtnValue$[ebp], eax
	jmp	$LN5@ChooseNext
$LN6@ChooseNext:

; 349  : 	}
; 350  : 	// Total weight may be 0 if the only branches and policies left are ones that are ineffective in our game, but we gotta pick something
; 351  : 	else if(m_AdoptablePolicies.GetTotalWeight() == 0 && m_AdoptablePolicies.size() > 0)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 532				; 00000214H
	mov	DWORD PTR $T223866[ebp], edx
	mov	DWORD PTR _rtnValue$223860[ebp], 0
	mov	DWORD PTR _i$223861[ebp], 0
	jmp	SHORT $LN296@ChooseNext
$LN295@ChooseNext:
	mov	eax, DWORD PTR _i$223861[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223861[ebp], eax
$LN296@ChooseNext:
	mov	ecx, DWORD PTR $T223866[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T223844[ebp], edx
	mov	eax, DWORD PTR _i$223861[ebp]
	cmp	eax, DWORD PTR $T223844[ebp]
	jae	SHORT $LN297@ChooseNext
	mov	ecx, DWORD PTR $T223866[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$223861[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T223851[ebp], ecx
	mov	edx, DWORD PTR $T223851[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _elem$223865[ebp], eax
	mov	ecx, DWORD PTR $T223851[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _elem$223865[ebp+4], edx
	mov	eax, DWORD PTR _rtnValue$223860[ebp]
	add	eax, DWORD PTR _elem$223865[ebp+4]
	mov	DWORD PTR _rtnValue$223860[ebp], eax
	jmp	SHORT $LN295@ChooseNext
$LN297@ChooseNext:
	cmp	DWORD PTR _rtnValue$223860[ebp], 0
	jne	SHORT $LN5@ChooseNext
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	mov	DWORD PTR $T223871[ebp], edx
	cmp	DWORD PTR $T223871[ebp], 0
	jle	SHORT $LN5@ChooseNext

; 352  : 	{
; 353  : 		iRtnValue = m_AdoptablePolicies.ChooseAtRandom(&fcn, "Choosing policy at random (no good choices)");

	push	OFFSET ??_C@_0CM@GEFFIOHP@Choosing?5policy?5at?5random?5?$CIno?5go@
	lea	eax, DWORD PTR _fcn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 532				; 00000214H
	call	?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,64,1>::ChooseAtRandom
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN5@ChooseNext:

; 354  : 	}
; 355  : 
; 356  : 	// Log our choice
; 357  : #ifdef AUI_WARNING_FIXES
; 358  : 	if (iRtnValue != (uint)NO_POLICY)
; 359  : #else
; 360  : 	if(iRtnValue != (int)NO_POLICY)

	cmp	DWORD PTR _iRtnValue$[ebp], -1
	je	SHORT $LN3@ChooseNext

; 361  : #endif
; 362  : 	{
; 363  : 		if(iRtnValue >= GC.getNumPolicyBranchInfos())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	cmp	DWORD PTR _iRtnValue$[ebp], eax
	jl	SHORT $LN2@ChooseNext

; 364  : 		{
; 365  : 			LogPolicyChoice((PolicyTypes)(iRtnValue - GC.getNumPolicyBranchInfos()));

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	ecx, DWORD PTR _iRtnValue$[ebp]
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ; CvPolicyAI::LogPolicyChoice

; 366  : 		}
; 367  : 		else

	jmp	SHORT $LN3@ChooseNext
$LN2@ChooseNext:

; 368  : 		{
; 369  : 			LogBranchChoice((PolicyBranchTypes)iRtnValue);

	mov	edx, DWORD PTR _iRtnValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ; CvPolicyAI::LogBranchChoice
$LN3@ChooseNext:

; 370  : 		}
; 371  : 	}
; 372  : 
; 373  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR $T223279[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T223279[ebp]
$LN47@ChooseNext:

; 374  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$2:
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$4:
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$6:
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$8:
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z$10:
	lea	ecx, DWORD PTR _aLevel3Tenets$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-548]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z ENDP	; CvPolicyAI::ChooseNextPolicy
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_0CH@HBOAPKPC@Final?5?$CIafter?5Clear?5Victory?5Prefe@ ; `string'
PUBLIC	??_C@_0BH@PCNEDEBJ@After?5Random?5?$CI1?5to?510?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BL@FKPNCDOG@Order?5random?5priority?5bump?$AA@ ; `string'
PUBLIC	??_C@_0BP@MIILPLFJ@Autocracy?5random?5priority?5bump?$AA@ ; `string'
PUBLIC	??_C@_0BN@ECFBKOLO@Freedom?5random?5priority?5bump?$AA@ ; `string'
PUBLIC	??_C@_0BP@LIABBEKP@After?5Public?5Opinion?5Happiness?$AA@ ; `string'
PUBLIC	??_C@_0BN@MLNAJKNC@After?5Tenet?5Happiness?5Boosts?$AA@ ; `string'
PUBLIC	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
PUBLIC	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness
PUBLIC	??_C@_0BA@HNHLJGOF@After?5Relations?$AA@	; `string'
PUBLIC	??_C@_0BE@LEFHHEJH@After?5Free?5Policies?$AA@	; `string'
PUBLIC	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BH@LIGMKNEN@After?5Grand?5Strategies?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoChooseIdeology
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z:PROC ; CvPlayerPolicies::SetPolicyBranchUnlocked
EXTRN	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z:PROC ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ:PROC ; CvPlayerPolicies::GetLateGamePolicyTree
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::IsPlayerValid
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z:PROC ; PolicyHelpers::GetNumFreePolicies
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetCulturePriority
EXTRN	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetSpaceshipPriority
EXTRN	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetUnitedNationsPriority
EXTRN	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ:PROC ; CvGrandStrategyAI::GetConquestPriority
;	COMDAT ??_C@_0CH@HBOAPKPC@Final?5?$CIafter?5Clear?5Victory?5Prefe@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CH@HBOAPKPC@Final?5?$CIafter?5Clear?5Victory?5Prefe@ DB 'Final (af'
	DB	'ter Clear Victory Preference)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PCNEDEBJ@After?5Random?5?$CI1?5to?510?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@PCNEDEBJ@After?5Random?5?$CI1?5to?510?$CJ?$AA@ DB 'After Random'
	DB	' (1 to 10)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FKPNCDOG@Order?5random?5priority?5bump?$AA@
CONST	SEGMENT
??_C@_0BL@FKPNCDOG@Order?5random?5priority?5bump?$AA@ DB 'Order random pr'
	DB	'iority bump', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MIILPLFJ@Autocracy?5random?5priority?5bump?$AA@
CONST	SEGMENT
??_C@_0BP@MIILPLFJ@Autocracy?5random?5priority?5bump?$AA@ DB 'Autocracy r'
	DB	'andom priority bump', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECFBKOLO@Freedom?5random?5priority?5bump?$AA@
CONST	SEGMENT
??_C@_0BN@ECFBKOLO@Freedom?5random?5priority?5bump?$AA@ DB 'Freedom rando'
	DB	'm priority bump', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LIABBEKP@After?5Public?5Opinion?5Happiness?$AA@
CONST	SEGMENT
??_C@_0BP@LIABBEKP@After?5Public?5Opinion?5Happiness?$AA@ DB 'After Publi'
	DB	'c Opinion Happiness', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MLNAJKNC@After?5Tenet?5Happiness?5Boosts?$AA@
CONST	SEGMENT
??_C@_0BN@MLNAJKNC@After?5Tenet?5Happiness?5Boosts?$AA@ DB 'After Tenet H'
	DB	'appiness Boosts', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HNHLJGOF@After?5Relations?$AA@
CONST	SEGMENT
??_C@_0BA@HNHLJGOF@After?5Relations?$AA@ DB 'After Relations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LEFHHEJH@After?5Free?5Policies?$AA@
CONST	SEGMENT
??_C@_0BE@LEFHHEJH@After?5Free?5Policies?$AA@ DB 'After Free Policies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIGMKNEN@After?5Grand?5Strategies?$AA@
CONST	SEGMENT
??_C@_0BH@LIGMKNEN@After?5Grand?5Strategies?$AA@ DB 'After Grand Strategi'
	DB	'es', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z$0
__ehfuncinfo$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv423 = -376						; size = 4
tv412 = -372						; size = 4
tv397 = -368						; size = 4
tv283 = -364						; size = 4
tv497 = -360						; size = 4
tv93 = -356						; size = 4
tv86 = -352						; size = 4
tv79 = -348						; size = 4
tv68 = -344						; size = 4
_this$ = -340						; size = 4
$T224198 = -336						; size = 4
$T224194 = -332						; size = 4
$T224190 = -328						; size = 4
$T224178 = -324						; size = 4
$T224169 = -320						; size = 4
$T224160 = -316						; size = 4
$T224141 = -312						; size = 4
$T224137 = -308						; size = 4
$T224133 = -304						; size = 4
$T224129 = -300						; size = 4
$T224125 = -296						; size = 4
$T224121 = -292						; size = 4
$T224117 = -288						; size = 4
$T224113 = -284						; size = 4
$T224109 = -280						; size = 4
$T224105 = -276						; size = 4
$T224101 = -272						; size = 4
$T224097 = -268						; size = 4
$T224093 = -264						; size = 4
$T224089 = -260						; size = 4
$T224085 = -256						; size = 4
$T224081 = -252						; size = 4
$T224077 = -248						; size = 4
$T224073 = -244						; size = 4
$T224066 = -240						; size = 4
$T224052 = -236						; size = 4
$T224048 = -232						; size = 4
$T224044 = -228						; size = 4
$T224023 = -224						; size = 4
$T224014 = -220						; size = 4
$T224005 = -216						; size = 4
$T223996 = -212						; size = 4
$T223980 = -208						; size = 4
$T223979 = -204						; size = 4
$T223978 = -200						; size = 4
$T223977 = -196						; size = 4
$T223976 = -192						; size = 4
$T223975 = -188						; size = 4
$T223974 = -184						; size = 4
$T223973 = -180						; size = 4
$T223972 = -176						; size = 4
$T223971 = -172						; size = 4
$T223970 = -168						; size = 4
$T223969 = -164						; size = 4
$T223968 = -160						; size = 4
$T223967 = -156						; size = 4
_kOtherPlayer$221669 = -152				; size = 4
_eOtherPlayerIdeology$221670 = -148			; size = 4
_iPlayerLoop$221663 = -144				; size = 4
_iPriorityToDivide$221658 = -140			; size = 4
_iTechPriority$ = -136					; size = 4
_iClearPrefPercent$ = -132				; size = 4
_iDiploPriority$ = -128					; size = 4
_iAutocracyTotal$ = -124				; size = 4
_iHappinessDelta$ = -120				; size = 4
_eLoopPlayer$ = -116					; size = 4
_stage$ = -112						; size = 28
__$ArrayPad$ = -84					; size = 4
_iAutocracyMultiplier$ = -80				; size = 4
_eFreedomBranch$ = -76					; size = 4
_iFreedomTotal$ = -72					; size = 4
_iAutocracyPriority$ = -68				; size = 4
_iOrderTotal$ = -64					; size = 4
_iFreedomMultiplier$ = -60				; size = 4
_iOrderMultiplier$ = -56				; size = 4
_iHappinessModifier$ = -52				; size = 4
_iConquestPriority$ = -48				; size = 4
_iGrandTotal$ = -44					; size = 4
_eOrderBranch$ = -40					; size = 4
_iHappinessPoliciesInBranch$ = -36			; size = 4
_iFreedomPriority$ = -32				; size = 4
_iOrderPriority$ = -28					; size = 4
_eAutocracyBranch$ = -24				; size = 4
_iCulturePriority$ = -20				; size = 4
_eChosenBranch$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pPlayer$ = 8						; size = 4
?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z PROC	; CvPolicyAI::DoChooseIdeology, COMDAT
; _this$ = ecx

; 377  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 	int iFreedomPriority = 0;

	mov	DWORD PTR _iFreedomPriority$[ebp], 0

; 379  : 	int iAutocracyPriority = 0;

	mov	DWORD PTR _iAutocracyPriority$[ebp], 0

; 380  : 	int iOrderPriority = 0;

	mov	DWORD PTR _iOrderPriority$[ebp], 0

; 381  : 	int iFreedomMultiplier = 1;

	mov	DWORD PTR _iFreedomMultiplier$[ebp], 1

; 382  : 	int iAutocracyMultiplier = 1;

	mov	DWORD PTR _iAutocracyMultiplier$[ebp], 1

; 383  : 	int iOrderMultiplier = 1;

	mov	DWORD PTR _iOrderMultiplier$[ebp], 1

; 384  : 	PolicyBranchTypes eFreedomBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	mov	DWORD PTR _eFreedomBranch$[ebp], eax

; 385  : 	PolicyBranchTypes eAutocracyBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380
	mov	DWORD PTR _eAutocracyBranch$[ebp], ecx

; 386  : 	PolicyBranchTypes eOrderBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	mov	DWORD PTR _eOrderBranch$[ebp], edx

; 387  : 	if (eFreedomBranch == NO_POLICY_BRANCH_TYPE || eAutocracyBranch == NO_POLICY_BRANCH_TYPE || eOrderBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eFreedomBranch$[ebp], -1
	je	SHORT $LN45@DoChooseId
	cmp	DWORD PTR _eAutocracyBranch$[ebp], -1
	je	SHORT $LN45@DoChooseId
	cmp	DWORD PTR _eOrderBranch$[ebp], -1
	jne	SHORT $LN46@DoChooseId
$LN45@DoChooseId:

; 388  : 	{
; 389  : 		return;

	jmp	$LN47@DoChooseId
$LN46@DoChooseId:

; 390  : 	}
; 391  : 
; 392  : 	// First consideration is our victory type
; 393  : 	int iConquestPriority = max(0, pPlayer->GetGrandStrategyAI()->GetConquestPriority());

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetConquestPriority
	mov	DWORD PTR $T223967[ebp], eax
	mov	DWORD PTR $T223968[ebp], 0
	mov	eax, DWORD PTR $T223968[ebp]
	cmp	eax, DWORD PTR $T223967[ebp]
	jge	SHORT $LN58@DoChooseId
	lea	ecx, DWORD PTR $T223967[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $LN59@DoChooseId
$LN58@DoChooseId:
	lea	edx, DWORD PTR $T223968[ebp]
	mov	DWORD PTR tv68[ebp], edx
$LN59@DoChooseId:
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR $T223996[ebp], eax
	mov	ecx, DWORD PTR $T223996[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iConquestPriority$[ebp], edx

; 394  : 	int iDiploPriority = max(0, pPlayer->GetGrandStrategyAI()->GetUnitedNationsPriority());

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetUnitedNationsPriority
	mov	DWORD PTR $T223969[ebp], eax
	mov	DWORD PTR $T223970[ebp], 0
	mov	eax, DWORD PTR $T223970[ebp]
	cmp	eax, DWORD PTR $T223969[ebp]
	jge	SHORT $LN62@DoChooseId
	lea	ecx, DWORD PTR $T223969[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN63@DoChooseId
$LN62@DoChooseId:
	lea	edx, DWORD PTR $T223970[ebp]
	mov	DWORD PTR tv79[ebp], edx
$LN63@DoChooseId:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T224005[ebp], eax
	mov	ecx, DWORD PTR $T224005[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iDiploPriority$[ebp], edx

; 395  : 	int iTechPriority = max(0, pPlayer->GetGrandStrategyAI()->GetSpaceshipPriority());

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetSpaceshipPriority
	mov	DWORD PTR $T223971[ebp], eax
	mov	DWORD PTR $T223972[ebp], 0
	mov	eax, DWORD PTR $T223972[ebp]
	cmp	eax, DWORD PTR $T223971[ebp]
	jge	SHORT $LN66@DoChooseId
	lea	ecx, DWORD PTR $T223971[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN67@DoChooseId
$LN66@DoChooseId:
	lea	edx, DWORD PTR $T223972[ebp]
	mov	DWORD PTR tv86[ebp], edx
$LN67@DoChooseId:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T224014[ebp], eax
	mov	ecx, DWORD PTR $T224014[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iTechPriority$[ebp], edx

; 396  : 	int iCulturePriority = max(0, pPlayer->GetGrandStrategyAI()->GetCulturePriority());

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetCulturePriority
	mov	DWORD PTR $T223973[ebp], eax
	mov	DWORD PTR $T223974[ebp], 0
	mov	eax, DWORD PTR $T223974[ebp]
	cmp	eax, DWORD PTR $T223973[ebp]
	jge	SHORT $LN70@DoChooseId
	lea	ecx, DWORD PTR $T223973[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	jmp	SHORT $LN71@DoChooseId
$LN70@DoChooseId:
	lea	edx, DWORD PTR $T223974[ebp]
	mov	DWORD PTR tv93[ebp], edx
$LN71@DoChooseId:
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T224023[ebp], eax
	mov	ecx, DWORD PTR $T224023[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iCulturePriority$[ebp], edx

; 397  : 
; 398  : 	// Rule out one ideology if we are clearly (at least 25% more priority) going for the victory this ideology doesn't support
; 399  : 	int iClearPrefPercent = GC.getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8344
	mov	DWORD PTR _iClearPrefPercent$[ebp], eax

; 400  : 	if (iConquestPriority > (iDiploPriority   * (100 + iClearPrefPercent) / 100) &&
; 401  : 		iConquestPriority > (iTechPriority    * (100 + iClearPrefPercent) / 100) &&
; 402  : 		iConquestPriority > (iCulturePriority * (100 + iClearPrefPercent) / 100))

	mov	ecx, DWORD PTR _iClearPrefPercent$[ebp]
	add	ecx, 100				; 00000064H
	mov	eax, ecx
	imul	eax, DWORD PTR _iDiploPriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iConquestPriority$[ebp], eax
	jle	SHORT $LN44@DoChooseId
	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iTechPriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iConquestPriority$[ebp], eax
	jle	SHORT $LN44@DoChooseId
	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iCulturePriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iConquestPriority$[ebp], eax
	jle	SHORT $LN44@DoChooseId

; 403  : 	{
; 404  : 		iFreedomMultiplier = 0;

	mov	DWORD PTR _iFreedomMultiplier$[ebp], 0

; 405  : 	}
; 406  : 	else if (iDiploPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	$LN43@DoChooseId
$LN44@DoChooseId:

; 407  : 		iDiploPriority > (iTechPriority     * (100 + iClearPrefPercent) / 100) &&
; 408  : 		iDiploPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iConquestPriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iDiploPriority$[ebp], eax
	jle	SHORT $LN42@DoChooseId
	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iTechPriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iDiploPriority$[ebp], eax
	jle	SHORT $LN42@DoChooseId
	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iCulturePriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iDiploPriority$[ebp], eax
	jle	SHORT $LN42@DoChooseId

; 409  : 	{
; 410  : 		iOrderMultiplier = 0;

	mov	DWORD PTR _iOrderMultiplier$[ebp], 0

; 411  : 	}
; 412  : 	else if (iTechPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	SHORT $LN43@DoChooseId
$LN42@DoChooseId:

; 413  : 		iTechPriority > (iDiploPriority    * (100 + iClearPrefPercent) / 100) &&
; 414  : 		iTechPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iConquestPriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iTechPriority$[ebp], eax
	jle	SHORT $LN43@DoChooseId
	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iDiploPriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iTechPriority$[ebp], eax
	jle	SHORT $LN43@DoChooseId
	mov	edx, DWORD PTR _iClearPrefPercent$[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iCulturePriority$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iTechPriority$[ebp], eax
	jle	SHORT $LN43@DoChooseId

; 415  : 	{
; 416  : 		iAutocracyMultiplier = 0;

	mov	DWORD PTR _iAutocracyMultiplier$[ebp], 0
$LN43@DoChooseId:

; 417  : 	}
; 418  : 
; 419  : 	int iFreedomTotal = iDiploPriority + iTechPriority + iCulturePriority;

	mov	edx, DWORD PTR _iDiploPriority$[ebp]
	add	edx, DWORD PTR _iTechPriority$[ebp]
	add	edx, DWORD PTR _iCulturePriority$[ebp]
	mov	DWORD PTR _iFreedomTotal$[ebp], edx

; 420  : 	int iAutocracyTotal = iDiploPriority + iConquestPriority + iCulturePriority;

	mov	eax, DWORD PTR _iDiploPriority$[ebp]
	add	eax, DWORD PTR _iConquestPriority$[ebp]
	add	eax, DWORD PTR _iCulturePriority$[ebp]
	mov	DWORD PTR _iAutocracyTotal$[ebp], eax

; 421  : 	int iOrderTotal = iTechPriority + iConquestPriority + iCulturePriority;

	mov	ecx, DWORD PTR _iTechPriority$[ebp]
	add	ecx, DWORD PTR _iConquestPriority$[ebp]
	add	ecx, DWORD PTR _iCulturePriority$[ebp]
	mov	DWORD PTR _iOrderTotal$[ebp], ecx

; 422  : 	int iGrandTotal = iFreedomTotal + iAutocracyTotal + iOrderTotal;

	mov	edx, DWORD PTR _iFreedomTotal$[ebp]
	add	edx, DWORD PTR _iAutocracyTotal$[ebp]
	add	edx, DWORD PTR _iOrderTotal$[ebp]
	mov	DWORD PTR _iGrandTotal$[ebp], edx

; 423  : 
; 424  : 	if (iGrandTotal > 0)

	cmp	DWORD PTR _iGrandTotal$[ebp], 0
	jle	SHORT $LN39@DoChooseId

; 425  : 	{
; 426  : 		int iPriorityToDivide = GC.getIDEOLOGY_SCORE_GRAND_STRATS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8348
	mov	DWORD PTR _iPriorityToDivide$221658[ebp], eax

; 427  : 		iFreedomPriority = (iFreedomTotal * iPriorityToDivide) / iGrandTotal;

	mov	eax, DWORD PTR _iFreedomTotal$[ebp]
	imul	eax, DWORD PTR _iPriorityToDivide$221658[ebp]
	cdq
	idiv	DWORD PTR _iGrandTotal$[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], eax

; 428  : 		iAutocracyPriority = (iAutocracyTotal * iPriorityToDivide) / iGrandTotal;

	mov	eax, DWORD PTR _iAutocracyTotal$[ebp]
	imul	eax, DWORD PTR _iPriorityToDivide$221658[ebp]
	cdq
	idiv	DWORD PTR _iGrandTotal$[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], eax

; 429  : 		iOrderPriority = (iOrderTotal * iPriorityToDivide) / iGrandTotal;

	mov	eax, DWORD PTR _iOrderTotal$[ebp]
	imul	eax, DWORD PTR _iPriorityToDivide$221658[ebp]
	cdq
	idiv	DWORD PTR _iGrandTotal$[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], eax
$LN39@DoChooseId:

; 430  : 	}
; 431  : 
; 432  : 	CvString stage = "After Grand Strategies";

	mov	ecx, OFFSET ??_C@_0BH@LIGMKNEN@After?5Grand?5Strategies?$AA@
	test	ecx, ecx
	je	SHORT $LN78@DoChooseId
	mov	DWORD PTR tv497[ebp], OFFSET ??_C@_0BH@LIGMKNEN@After?5Grand?5Strategies?$AA@
	jmp	SHORT $LN79@DoChooseId
$LN78@DoChooseId:
	mov	DWORD PTR tv497[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN79@DoChooseId:
	mov	edx, DWORD PTR tv497[ebp]
	push	edx
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 433  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	eax, DWORD PTR _iOrderPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFreedomPriority$[ebp]
	push	edx
	lea	eax, DWORD PTR _stage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 434  : 
; 435  : 	// Next look at free policies we can get
; 436  : 	iFreedomPriority += PolicyHelpers::GetNumFreePolicies(eFreedomBranch) * GC.getIDEOLOGY_SCORE_PER_FREE_TENET();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8356
	mov	DWORD PTR $T224044[ebp], ecx
	mov	edx, DWORD PTR _eFreedomBranch$[ebp]
	push	edx
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	add	esp, 4
	imul	eax, DWORD PTR $T224044[ebp]
	add	eax, DWORD PTR _iFreedomPriority$[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], eax

; 437  : 	iAutocracyPriority += PolicyHelpers::GetNumFreePolicies(eAutocracyBranch) * GC.getIDEOLOGY_SCORE_PER_FREE_TENET();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8356
	mov	DWORD PTR $T224048[ebp], eax
	mov	ecx, DWORD PTR _eAutocracyBranch$[ebp]
	push	ecx
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	add	esp, 4
	imul	eax, DWORD PTR $T224048[ebp]
	add	eax, DWORD PTR _iAutocracyPriority$[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], eax

; 438  : 	iOrderPriority += PolicyHelpers::GetNumFreePolicies(eOrderBranch) * GC.getIDEOLOGY_SCORE_PER_FREE_TENET();;

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8356
	mov	DWORD PTR $T224052[ebp], edx
	mov	eax, DWORD PTR _eOrderBranch$[ebp]
	push	eax
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	add	esp, 4
	imul	eax, DWORD PTR $T224052[ebp]
	add	eax, DWORD PTR _iOrderPriority$[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], eax

; 439  : 
; 440  : 	stage = "After Free Policies";

	mov	ecx, OFFSET ??_C@_0BE@LEFHHEJH@After?5Free?5Policies?$AA@
	test	ecx, ecx
	je	SHORT $LN88@DoChooseId
	push	OFFSET ??_C@_0BE@LEFHHEJH@After?5Free?5Policies?$AA@
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN89@DoChooseId
$LN88@DoChooseId:
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN89@DoChooseId:

; 441  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	edx, DWORD PTR _iOrderPriority$[ebp]
	push	edx
	mov	eax, DWORD PTR _iAutocracyPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFreedomPriority$[ebp]
	push	ecx
	lea	edx, DWORD PTR _stage$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 442  : 
; 443  : 	// Finally see what our friends (and enemies) have already chosen
; 444  : 	PlayerTypes eLoopPlayer;
; 445  : 	for (int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$221663[ebp], 0
	jmp	SHORT $LN38@DoChooseId
$LN37@DoChooseId:
	mov	eax, DWORD PTR _iPlayerLoop$221663[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$221663[ebp], eax
$LN38@DoChooseId:
	cmp	DWORD PTR _iPlayerLoop$221663[ebp], 22	; 00000016H
	jge	$LN36@DoChooseId

; 446  : 	{
; 447  : 		eLoopPlayer = (PlayerTypes) iPlayerLoop;

	mov	ecx, DWORD PTR _iPlayerLoop$221663[ebp]
	mov	DWORD PTR _eLoopPlayer$[ebp], ecx

; 448  : 		if (eLoopPlayer != pPlayer->GetID() && pPlayer->GetDiplomacyAI()->IsPlayerValid(eLoopPlayer))

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T224066[ebp], eax
	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	cmp	ecx, DWORD PTR $T224066[ebp]
	je	$LN35@DoChooseId
	push	0
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?IsPlayerValid@CvDiplomacyAI@@QAE_NW4PlayerTypes@@_N@Z ; CvDiplomacyAI::IsPlayerValid
	movzx	eax, al
	test	eax, eax
	je	$LN35@DoChooseId

; 449  : 		{
; 450  : 			CvPlayer &kOtherPlayer = GET_PLAYER(eLoopPlayer);

	mov	ecx, DWORD PTR _eLoopPlayer$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kOtherPlayer$221669[ebp], ecx

; 451  : 			PolicyBranchTypes eOtherPlayerIdeology;
; 452  : 			eOtherPlayerIdeology = kOtherPlayer.GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, DWORD PTR _kOtherPlayer$221669[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eOtherPlayerIdeology$221670[ebp], eax

; 453  : 
; 454  : 			switch(pPlayer->GetDiplomacyAI()->GetMajorCivApproach(eLoopPlayer, /*bHideTrueFeelings*/ true))

	push	1
	mov	edx, DWORD PTR _eLoopPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	mov	DWORD PTR tv283[ebp], eax
	mov	eax, DWORD PTR tv283[ebp]
	sub	eax, 1
	mov	DWORD PTR tv283[ebp], eax
	cmp	DWORD PTR tv283[ebp], 4
	ja	$LN35@DoChooseId
	mov	ecx, DWORD PTR tv283[ebp]
	jmp	DWORD PTR $LN177@DoChooseId[ecx*4]
$LN32@DoChooseId:

; 455  : 			{
; 456  : 			case MAJOR_CIV_APPROACH_HOSTILE:
; 457  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eFreedomBranch$[ebp]
	jne	SHORT $LN31@DoChooseId

; 458  : 				{
; 459  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	mov	DWORD PTR $T224073[ebp], eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	add	ecx, DWORD PTR $T224073[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], ecx

; 460  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	mov	DWORD PTR $T224077[ebp], edx
	mov	eax, DWORD PTR _iOrderPriority$[ebp]
	add	eax, DWORD PTR $T224077[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], eax
	jmp	SHORT $LN30@DoChooseId
$LN31@DoChooseId:

; 461  : 				}
; 462  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	mov	ecx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	ecx, DWORD PTR _eAutocracyBranch$[ebp]
	jne	SHORT $LN29@DoChooseId

; 463  : 				{
; 464  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	mov	DWORD PTR $T224081[ebp], edx
	mov	eax, DWORD PTR _iFreedomPriority$[ebp]
	add	eax, DWORD PTR $T224081[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], eax

; 465  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	mov	DWORD PTR $T224085[ebp], ecx
	mov	edx, DWORD PTR _iOrderPriority$[ebp]
	add	edx, DWORD PTR $T224085[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], edx
	jmp	SHORT $LN30@DoChooseId
$LN29@DoChooseId:

; 466  : 				}
; 467  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	mov	eax, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	eax, DWORD PTR _eOrderBranch$[ebp]
	jne	SHORT $LN30@DoChooseId

; 468  : 				{
; 469  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_HOSTILE();;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	mov	DWORD PTR $T224089[ebp], ecx
	mov	edx, DWORD PTR _iAutocracyPriority$[ebp]
	add	edx, DWORD PTR $T224089[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], edx

; 470  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_HOSTILE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8360
	mov	DWORD PTR $T224093[ebp], eax
	mov	ecx, DWORD PTR _iFreedomPriority$[ebp]
	add	ecx, DWORD PTR $T224093[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], ecx
$LN30@DoChooseId:

; 471  : 				}
; 472  : 				break;

	jmp	$LN35@DoChooseId
$LN26@DoChooseId:

; 473  : 			case MAJOR_CIV_APPROACH_GUARDED:
; 474  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eFreedomBranch$[ebp]
	jne	SHORT $LN25@DoChooseId

; 475  : 				{
; 476  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	mov	DWORD PTR $T224097[ebp], eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	add	ecx, DWORD PTR $T224097[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], ecx

; 477  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	mov	DWORD PTR $T224101[ebp], edx
	mov	eax, DWORD PTR _iOrderPriority$[ebp]
	add	eax, DWORD PTR $T224101[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], eax
	jmp	SHORT $LN24@DoChooseId
$LN25@DoChooseId:

; 478  : 				}
; 479  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	mov	ecx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	ecx, DWORD PTR _eAutocracyBranch$[ebp]
	jne	SHORT $LN23@DoChooseId

; 480  : 				{
; 481  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	mov	DWORD PTR $T224105[ebp], edx
	mov	eax, DWORD PTR _iFreedomPriority$[ebp]
	add	eax, DWORD PTR $T224105[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], eax

; 482  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	mov	DWORD PTR $T224109[ebp], ecx
	mov	edx, DWORD PTR _iOrderPriority$[ebp]
	add	edx, DWORD PTR $T224109[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], edx
	jmp	SHORT $LN24@DoChooseId
$LN23@DoChooseId:

; 483  : 				}
; 484  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	mov	eax, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	eax, DWORD PTR _eOrderBranch$[ebp]
	jne	SHORT $LN24@DoChooseId

; 485  : 				{
; 486  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	mov	DWORD PTR $T224113[ebp], ecx
	mov	edx, DWORD PTR _iAutocracyPriority$[ebp]
	add	edx, DWORD PTR $T224113[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], edx

; 487  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_GUARDED();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8364
	mov	DWORD PTR $T224117[ebp], eax
	mov	ecx, DWORD PTR _iFreedomPriority$[ebp]
	add	ecx, DWORD PTR $T224117[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], ecx
$LN24@DoChooseId:

; 488  : 				}
; 489  : 				break;

	jmp	$LN35@DoChooseId
$LN20@DoChooseId:

; 490  : 			case MAJOR_CIV_APPROACH_AFRAID:
; 491  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eFreedomBranch$[ebp]
	jne	SHORT $LN19@DoChooseId

; 492  : 				{
; 493  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_AFRAID();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8368
	mov	DWORD PTR $T224121[ebp], eax
	mov	ecx, DWORD PTR _iFreedomPriority$[ebp]
	add	ecx, DWORD PTR $T224121[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], ecx
	jmp	SHORT $LN18@DoChooseId
$LN19@DoChooseId:

; 494  : 				}
; 495  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eAutocracyBranch$[ebp]
	jne	SHORT $LN17@DoChooseId

; 496  : 				{
; 497  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_AFRAID();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8368
	mov	DWORD PTR $T224125[ebp], eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	add	ecx, DWORD PTR $T224125[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], ecx
	jmp	SHORT $LN18@DoChooseId
$LN17@DoChooseId:

; 498  : 				}
; 499  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eOrderBranch$[ebp]
	jne	SHORT $LN18@DoChooseId

; 500  : 				{
; 501  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_AFRAID();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8368
	mov	DWORD PTR $T224129[ebp], eax
	mov	ecx, DWORD PTR _iOrderPriority$[ebp]
	add	ecx, DWORD PTR $T224129[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], ecx
$LN18@DoChooseId:

; 502  : 				}
; 503  : 				break;

	jmp	SHORT $LN35@DoChooseId
$LN14@DoChooseId:

; 504  : 			case MAJOR_CIV_APPROACH_FRIENDLY:
; 505  : 				if (eOtherPlayerIdeology == eFreedomBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eFreedomBranch$[ebp]
	jne	SHORT $LN13@DoChooseId

; 506  : 				{
; 507  : 					iFreedomPriority += GC.getIDEOLOGY_SCORE_FRIENDLY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8372
	mov	DWORD PTR $T224133[ebp], eax
	mov	ecx, DWORD PTR _iFreedomPriority$[ebp]
	add	ecx, DWORD PTR $T224133[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], ecx
	jmp	SHORT $LN35@DoChooseId
$LN13@DoChooseId:

; 508  : 				}
; 509  : 				else if (eOtherPlayerIdeology == eAutocracyBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eAutocracyBranch$[ebp]
	jne	SHORT $LN11@DoChooseId

; 510  : 				{
; 511  : 					iAutocracyPriority += GC.getIDEOLOGY_SCORE_FRIENDLY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8372
	mov	DWORD PTR $T224137[ebp], eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	add	ecx, DWORD PTR $T224137[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], ecx
	jmp	SHORT $LN35@DoChooseId
$LN11@DoChooseId:

; 512  : 				}
; 513  : 				else if (eOtherPlayerIdeology == eOrderBranch)

	mov	edx, DWORD PTR _eOtherPlayerIdeology$221670[ebp]
	cmp	edx, DWORD PTR _eOrderBranch$[ebp]
	jne	SHORT $LN35@DoChooseId

; 514  : 				{
; 515  : 					iOrderPriority += GC.getIDEOLOGY_SCORE_FRIENDLY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8372
	mov	DWORD PTR $T224141[ebp], eax
	mov	ecx, DWORD PTR _iOrderPriority$[ebp]
	add	ecx, DWORD PTR $T224141[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], ecx
$LN35@DoChooseId:

; 516  : 				}
; 517  : 				break;
; 518  : 			case MAJOR_CIV_APPROACH_NEUTRAL:
; 519  : 				// No changes
; 520  : 				break;
; 521  : 			}
; 522  : 		}
; 523  : 	}

	jmp	$LN37@DoChooseId
$LN36@DoChooseId:

; 524  : 
; 525  : 	stage = "After Relations";

	mov	edx, OFFSET ??_C@_0BA@HNHLJGOF@After?5Relations?$AA@
	test	edx, edx
	je	SHORT $LN134@DoChooseId
	push	OFFSET ??_C@_0BA@HNHLJGOF@After?5Relations?$AA@
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN135@DoChooseId
$LN134@DoChooseId:
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN135@DoChooseId:

; 526  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	eax, DWORD PTR _iOrderPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFreedomPriority$[ebp]
	push	edx
	lea	eax, DWORD PTR _stage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 527  : 
; 528  : 	// Look at Happiness impacts
; 529  : 	int iHappinessModifier = GC.getIDEOLOGY_SCORE_HAPPINESS();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8352
	mov	DWORD PTR _iHappinessModifier$[ebp], ecx

; 530  : 
; 531  : 	// -- Happiness we could add through tenets
; 532  : 	int iHappinessDelta;
; 533  : 	int iHappinessPoliciesInBranch;
; 534  : 	iHappinessDelta = GetBranchBuildingHappiness(pPlayer, eFreedomBranch);

	mov	edx, DWORD PTR _eFreedomBranch$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness
	mov	DWORD PTR _iHappinessDelta$[ebp], eax

; 535  : 	iHappinessPoliciesInBranch = GetNumHappinessPolicies(pPlayer, eFreedomBranch);

	mov	ecx, DWORD PTR _eFreedomBranch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
	mov	DWORD PTR _iHappinessPoliciesInBranch$[ebp], eax

; 536  : 	if (iHappinessPoliciesInBranch > 0)

	cmp	DWORD PTR _iHappinessPoliciesInBranch$[ebp], 0
	jle	SHORT $LN7@DoChooseId

; 537  : 	{
; 538  : 		iFreedomPriority += iHappinessDelta * iHappinessModifier / iHappinessPoliciesInBranch;		

	mov	eax, DWORD PTR _iHappinessDelta$[ebp]
	imul	eax, DWORD PTR _iHappinessModifier$[ebp]
	cdq
	idiv	DWORD PTR _iHappinessPoliciesInBranch$[ebp]
	add	eax, DWORD PTR _iFreedomPriority$[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], eax
$LN7@DoChooseId:

; 539  : 	}
; 540  : 	iHappinessDelta = GetBranchBuildingHappiness(pPlayer, eAutocracyBranch);

	mov	eax, DWORD PTR _eAutocracyBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness
	mov	DWORD PTR _iHappinessDelta$[ebp], eax

; 541  : 	iHappinessPoliciesInBranch = GetNumHappinessPolicies(pPlayer, eAutocracyBranch);

	mov	edx, DWORD PTR _eAutocracyBranch$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
	mov	DWORD PTR _iHappinessPoliciesInBranch$[ebp], eax

; 542  : 	if (iHappinessPoliciesInBranch > 0)

	cmp	DWORD PTR _iHappinessPoliciesInBranch$[ebp], 0
	jle	SHORT $LN6@DoChooseId

; 543  : 	{
; 544  : 		iAutocracyPriority += iHappinessDelta * iHappinessModifier / iHappinessPoliciesInBranch;		

	mov	eax, DWORD PTR _iHappinessDelta$[ebp]
	imul	eax, DWORD PTR _iHappinessModifier$[ebp]
	cdq
	idiv	DWORD PTR _iHappinessPoliciesInBranch$[ebp]
	add	eax, DWORD PTR _iAutocracyPriority$[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], eax
$LN6@DoChooseId:

; 545  : 	}
; 546  : 	iHappinessDelta = GetBranchBuildingHappiness(pPlayer, eOrderBranch);

	mov	ecx, DWORD PTR _eOrderBranch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness
	mov	DWORD PTR _iHappinessDelta$[ebp], eax

; 547  : 	iHappinessPoliciesInBranch = GetNumHappinessPolicies(pPlayer, eOrderBranch);

	mov	eax, DWORD PTR _eOrderBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetNumHappinessPolicies
	mov	DWORD PTR _iHappinessPoliciesInBranch$[ebp], eax

; 548  : 	if (iHappinessPoliciesInBranch > 0)

	cmp	DWORD PTR _iHappinessPoliciesInBranch$[ebp], 0
	jle	SHORT $LN5@DoChooseId

; 549  : 	{
; 550  : 		iOrderPriority += iHappinessDelta * iHappinessModifier / iHappinessPoliciesInBranch;		

	mov	eax, DWORD PTR _iHappinessDelta$[ebp]
	imul	eax, DWORD PTR _iHappinessModifier$[ebp]
	cdq
	idiv	DWORD PTR _iHappinessPoliciesInBranch$[ebp]
	add	eax, DWORD PTR _iOrderPriority$[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], eax
$LN5@DoChooseId:

; 551  : 	}
; 552  : 
; 553  : 	stage = "After Tenet Happiness Boosts";

	mov	edx, OFFSET ??_C@_0BN@MLNAJKNC@After?5Tenet?5Happiness?5Boosts?$AA@
	test	edx, edx
	je	SHORT $LN140@DoChooseId
	push	OFFSET ??_C@_0BN@MLNAJKNC@After?5Tenet?5Happiness?5Boosts?$AA@
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN141@DoChooseId
$LN140@DoChooseId:
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN141@DoChooseId:

; 554  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	eax, DWORD PTR _iOrderPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFreedomPriority$[ebp]
	push	edx
	lea	eax, DWORD PTR _stage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 555  : 
; 556  : 	// -- Happiness we'd lose through Public Opinion
; 557  : 	iHappinessDelta = max (0, 100 - pPlayer->GetCulture()->ComputeHypotheticalPublicOpinionUnhappiness(eFreedomBranch));

	mov	ecx, DWORD PTR _eFreedomBranch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
	mov	edx, 100				; 00000064H
	sub	edx, eax
	mov	DWORD PTR $T223975[ebp], edx
	mov	DWORD PTR $T223976[ebp], 0
	mov	eax, DWORD PTR $T223976[ebp]
	cmp	eax, DWORD PTR $T223975[ebp]
	jge	SHORT $LN145@DoChooseId
	lea	ecx, DWORD PTR $T223975[ebp]
	mov	DWORD PTR tv397[ebp], ecx
	jmp	SHORT $LN146@DoChooseId
$LN145@DoChooseId:
	lea	edx, DWORD PTR $T223976[ebp]
	mov	DWORD PTR tv397[ebp], edx
$LN146@DoChooseId:
	mov	eax, DWORD PTR tv397[ebp]
	mov	DWORD PTR $T224160[ebp], eax
	mov	ecx, DWORD PTR $T224160[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iHappinessDelta$[ebp], edx

; 558  : 	iFreedomPriority += iHappinessDelta * iHappinessModifier;

	mov	eax, DWORD PTR _iHappinessDelta$[ebp]
	imul	eax, DWORD PTR _iHappinessModifier$[ebp]
	add	eax, DWORD PTR _iFreedomPriority$[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], eax

; 559  : 	iHappinessDelta = max (0, 100 - pPlayer->GetCulture()->ComputeHypotheticalPublicOpinionUnhappiness(eAutocracyBranch));

	mov	ecx, DWORD PTR _eAutocracyBranch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
	mov	edx, 100				; 00000064H
	sub	edx, eax
	mov	DWORD PTR $T223977[ebp], edx
	mov	DWORD PTR $T223978[ebp], 0
	mov	eax, DWORD PTR $T223978[ebp]
	cmp	eax, DWORD PTR $T223977[ebp]
	jge	SHORT $LN149@DoChooseId
	lea	ecx, DWORD PTR $T223977[ebp]
	mov	DWORD PTR tv412[ebp], ecx
	jmp	SHORT $LN150@DoChooseId
$LN149@DoChooseId:
	lea	edx, DWORD PTR $T223978[ebp]
	mov	DWORD PTR tv412[ebp], edx
$LN150@DoChooseId:
	mov	eax, DWORD PTR tv412[ebp]
	mov	DWORD PTR $T224169[ebp], eax
	mov	ecx, DWORD PTR $T224169[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iHappinessDelta$[ebp], edx

; 560  : 	iAutocracyPriority += iHappinessDelta * iHappinessModifier;

	mov	eax, DWORD PTR _iHappinessDelta$[ebp]
	imul	eax, DWORD PTR _iHappinessModifier$[ebp]
	add	eax, DWORD PTR _iAutocracyPriority$[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], eax

; 561  : 	iHappinessDelta = max (0, 100 - pPlayer->GetCulture()->ComputeHypotheticalPublicOpinionUnhappiness(eOrderBranch));

	mov	ecx, DWORD PTR _eOrderBranch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?ComputeHypotheticalPublicOpinionUnhappiness@CvPlayerCulture@@QAEHW4PolicyBranchTypes@@@Z ; CvPlayerCulture::ComputeHypotheticalPublicOpinionUnhappiness
	mov	edx, 100				; 00000064H
	sub	edx, eax
	mov	DWORD PTR $T223979[ebp], edx
	mov	DWORD PTR $T223980[ebp], 0
	mov	eax, DWORD PTR $T223980[ebp]
	cmp	eax, DWORD PTR $T223979[ebp]
	jge	SHORT $LN153@DoChooseId
	lea	ecx, DWORD PTR $T223979[ebp]
	mov	DWORD PTR tv423[ebp], ecx
	jmp	SHORT $LN154@DoChooseId
$LN153@DoChooseId:
	lea	edx, DWORD PTR $T223980[ebp]
	mov	DWORD PTR tv423[ebp], edx
$LN154@DoChooseId:
	mov	eax, DWORD PTR tv423[ebp]
	mov	DWORD PTR $T224178[ebp], eax
	mov	ecx, DWORD PTR $T224178[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iHappinessDelta$[ebp], edx

; 562  : 	iOrderPriority += iHappinessDelta * iHappinessModifier;

	mov	eax, DWORD PTR _iHappinessDelta$[ebp]
	imul	eax, DWORD PTR _iHappinessModifier$[ebp]
	add	eax, DWORD PTR _iOrderPriority$[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], eax

; 563  : 
; 564  : 	stage = "After Public Opinion Happiness";

	mov	ecx, OFFSET ??_C@_0BP@LIABBEKP@After?5Public?5Opinion?5Happiness?$AA@
	test	ecx, ecx
	je	SHORT $LN156@DoChooseId
	push	OFFSET ??_C@_0BP@LIABBEKP@After?5Public?5Opinion?5Happiness?$AA@
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN157@DoChooseId
$LN156@DoChooseId:
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN157@DoChooseId:

; 565  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	edx, DWORD PTR _iOrderPriority$[ebp]
	push	edx
	mov	eax, DWORD PTR _iAutocracyPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFreedomPriority$[ebp]
	push	ecx
	lea	edx, DWORD PTR _stage$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 566  : 
; 567  : 	// Small random add-on
; 568  : 	iFreedomPriority += GC.getGame().getJonRandNum(10, "Freedom random priority bump");

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224190[ebp], eax
	push	OFFSET ??_C@_0BN@ECFBKOLO@Freedom?5random?5priority?5bump?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T224190[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, DWORD PTR _iFreedomPriority$[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], eax

; 569  : 	iAutocracyPriority += GC.getGame().getJonRandNum(10, "Autocracy random priority bump");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224194[ebp], ecx
	push	OFFSET ??_C@_0BP@MIILPLFJ@Autocracy?5random?5priority?5bump?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T224194[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, DWORD PTR _iAutocracyPriority$[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], eax

; 570  : 	iOrderPriority += GC.getGame().getJonRandNum(10, "Order random priority bump");

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224198[ebp], edx
	push	OFFSET ??_C@_0BL@FKPNCDOG@Order?5random?5priority?5bump?$AA@
	push	10					; 0000000aH
	mov	ecx, DWORD PTR $T224198[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	add	eax, DWORD PTR _iOrderPriority$[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], eax

; 571  : 
; 572  : 	stage = "After Random (1 to 10)";

	mov	eax, OFFSET ??_C@_0BH@PCNEDEBJ@After?5Random?5?$CI1?5to?510?$CJ?$AA@
	test	eax, eax
	je	SHORT $LN166@DoChooseId
	push	OFFSET ??_C@_0BH@PCNEDEBJ@After?5Random?5?$CI1?5to?510?$CJ?$AA@
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN167@DoChooseId
$LN166@DoChooseId:
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN167@DoChooseId:

; 573  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	ecx, DWORD PTR _iOrderPriority$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iAutocracyPriority$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFreedomPriority$[ebp]
	push	eax
	lea	ecx, DWORD PTR _stage$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 574  : 
; 575  : 	// Rule out any branches that are totally out of consideration
; 576  : 	iFreedomPriority = iFreedomPriority * iFreedomMultiplier;

	mov	edx, DWORD PTR _iFreedomPriority$[ebp]
	imul	edx, DWORD PTR _iFreedomMultiplier$[ebp]
	mov	DWORD PTR _iFreedomPriority$[ebp], edx

; 577  : 	iAutocracyPriority = iAutocracyPriority * iAutocracyMultiplier;

	mov	eax, DWORD PTR _iAutocracyPriority$[ebp]
	imul	eax, DWORD PTR _iAutocracyMultiplier$[ebp]
	mov	DWORD PTR _iAutocracyPriority$[ebp], eax

; 578  : 	iOrderPriority = iOrderPriority * iOrderMultiplier;

	mov	ecx, DWORD PTR _iOrderPriority$[ebp]
	imul	ecx, DWORD PTR _iOrderMultiplier$[ebp]
	mov	DWORD PTR _iOrderPriority$[ebp], ecx

; 579  : 
; 580  : 	stage = "Final (after Clear Victory Preference)";

	mov	edx, OFFSET ??_C@_0CH@HBOAPKPC@Final?5?$CIafter?5Clear?5Victory?5Prefe@
	test	edx, edx
	je	SHORT $LN170@DoChooseId
	push	OFFSET ??_C@_0CH@HBOAPKPC@Final?5?$CIafter?5Clear?5Victory?5Prefe@
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN171@DoChooseId
$LN170@DoChooseId:
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN171@DoChooseId:

; 581  : 	LogIdeologyChoice(stage, iFreedomPriority, iAutocracyPriority, iOrderPriority);

	mov	eax, DWORD PTR _iOrderPriority$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iFreedomPriority$[ebp]
	push	edx
	lea	eax, DWORD PTR _stage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ; CvPolicyAI::LogIdeologyChoice

; 582  : 
; 583  : 	// Pick the ideology
; 584  : 	PolicyBranchTypes eChosenBranch;
; 585  : 	if (iFreedomPriority >= iAutocracyPriority && iFreedomPriority >= iOrderPriority)

	mov	ecx, DWORD PTR _iFreedomPriority$[ebp]
	cmp	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	jl	SHORT $LN4@DoChooseId
	mov	edx, DWORD PTR _iFreedomPriority$[ebp]
	cmp	edx, DWORD PTR _iOrderPriority$[ebp]
	jl	SHORT $LN4@DoChooseId

; 586  : 	{
; 587  : 		eChosenBranch = eFreedomBranch;

	mov	eax, DWORD PTR _eFreedomBranch$[ebp]
	mov	DWORD PTR _eChosenBranch$[ebp], eax
	jmp	SHORT $LN3@DoChooseId
$LN4@DoChooseId:

; 588  : 	}
; 589  : 	else if (iAutocracyPriority >= iFreedomPriority && iAutocracyPriority >= iOrderPriority)

	mov	ecx, DWORD PTR _iAutocracyPriority$[ebp]
	cmp	ecx, DWORD PTR _iFreedomPriority$[ebp]
	jl	SHORT $LN2@DoChooseId
	mov	edx, DWORD PTR _iAutocracyPriority$[ebp]
	cmp	edx, DWORD PTR _iOrderPriority$[ebp]
	jl	SHORT $LN2@DoChooseId

; 590  : 	{
; 591  : 		eChosenBranch = eAutocracyBranch;

	mov	eax, DWORD PTR _eAutocracyBranch$[ebp]
	mov	DWORD PTR _eChosenBranch$[ebp], eax

; 592  : 	}
; 593  : 	else

	jmp	SHORT $LN3@DoChooseId
$LN2@DoChooseId:

; 594  : 	{
; 595  : 		eChosenBranch = eOrderBranch;

	mov	ecx, DWORD PTR _eOrderBranch$[ebp]
	mov	DWORD PTR _eChosenBranch$[ebp], ecx
$LN3@DoChooseId:

; 596  : 	}
; 597  : 	pPlayer->GetPlayerPolicies()->SetPolicyBranchUnlocked(eChosenBranch, true, false);

	push	0
	push	1
	mov	edx, DWORD PTR _eChosenBranch$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 598  : 	LogBranchChoice(eChosenBranch);

	mov	eax, DWORD PTR _eChosenBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ; CvPolicyAI::LogBranchChoice

; 599  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _stage$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN47@DoChooseId:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN177@DoChooseId:
	DD	$LN32@DoChooseId
	DD	$LN35@DoChooseId
	DD	$LN26@DoChooseId
	DD	$LN20@DoChooseId
	DD	$LN14@DoChooseId
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z$0:
	lea	ecx, DWORD PTR _stage$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ENDP	; CvPolicyAI::DoChooseIdeology
PUBLIC	?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoConsiderIdeologySwitch
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::DoSwitchIdeologies
EXTRN	?SetAnarchyNumTurns@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::SetAnarchyNumTurns
EXTRN	?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ:PROC ; CvPlayerCulture::GetPublicOpinionBiggestInfluence
EXTRN	?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ:PROC ; CvPlayerCulture::GetPublicOpinionPreferredIdeology
EXTRN	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ:PROC ; CvPlayerCulture::GetPublicOpinionUnhappiness
EXTRN	?GetExcessHappiness@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetExcessHappiness
; Function compile flags: /Odtp
;	COMDAT ?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv232 = -112						; size = 4
_this$ = -108						; size = 4
$T224273 = -104						; size = 4
$T224269 = -100						; size = 4
$T224265 = -96						; size = 4
$T224256 = -92						; size = 4
$T224252 = -88						; size = 4
$T224248 = -84						; size = 4
$T224244 = -80						; size = 4
$T224240 = -76						; size = 4
$T224236 = -72						; size = 4
$T224232 = -68						; size = 4
$T224225 = -64						; size = 4
_bDontSwitchOrder$221738 = -57				; size = 1
_iTechPriority$221742 = -56				; size = 4
_iClearPrefPercent$221744 = -52				; size = 4
_iDiploPriority$221741 = -48				; size = 4
_iHappinessCurrentIdeology$221735 = -44			; size = 4
_bDontSwitchFreedom$221737 = -38			; size = 1
_bDontSwitchAutocracy$221739 = -37			; size = 1
_iTotalHappinessImprovement$221750 = -36		; size = 4
_iConquestPriority$221740 = -32				; size = 4
_iHappinessPreferredIdeology$221736 = -28		; size = 4
_iCulturePriority$221743 = -24				; size = 4
_ePreferredIdeology$ = -20				; size = 4
_eCurrentIdeology$ = -16				; size = 4
_iCurrentHappiness$ = -12				; size = 4
_eMostPressure$ = -8					; size = 4
_iPublicOpinionUnhappiness$ = -4			; size = 4
_pPlayer$ = 8						; size = 4
?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z PROC ; CvPolicyAI::DoConsiderIdeologySwitch, COMDAT
; _this$ = ecx

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 604  : 	// Gather basic Ideology info
; 605  : 	int iCurrentHappiness = pPlayer->GetExcessHappiness();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	DWORD PTR _iCurrentHappiness$[ebp], eax

; 606  : 	int iPublicOpinionUnhappiness = pPlayer->GetCulture()->GetPublicOpinionUnhappiness();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionUnhappiness@CvPlayerCulture@@QBEHXZ ; CvPlayerCulture::GetPublicOpinionUnhappiness
	mov	DWORD PTR _iPublicOpinionUnhappiness$[ebp], eax

; 607  : 	PolicyBranchTypes ePreferredIdeology = pPlayer->GetCulture()->GetPublicOpinionPreferredIdeology();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionPreferredIdeology@CvPlayerCulture@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerCulture::GetPublicOpinionPreferredIdeology
	mov	DWORD PTR _ePreferredIdeology$[ebp], eax

; 608  : 	PolicyBranchTypes eCurrentIdeology = pPlayer->GetPlayerPolicies()->GetLateGamePolicyTree();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eCurrentIdeology$[ebp], eax

; 609  : 	PlayerTypes eMostPressure = pPlayer->GetCulture()->GetPublicOpinionBiggestInfluence();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetPublicOpinionBiggestInfluence@CvPlayerCulture@@QBE?AW4PlayerTypes@@XZ ; CvPlayerCulture::GetPublicOpinionBiggestInfluence
	mov	DWORD PTR _eMostPressure$[ebp], eax

; 610  : 	
; 611  : 	// Possible enough that we need to look at this in detail?
; 612  : 	if (iCurrentHappiness <= GC.getSUPER_UNHAPPY_THRESHOLD() && iPublicOpinionUnhappiness >= 10)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6376
	mov	DWORD PTR $T224225[ebp], eax
	mov	ecx, DWORD PTR _iCurrentHappiness$[ebp]
	cmp	ecx, DWORD PTR $T224225[ebp]
	jg	$LN13@DoConsider
	cmp	DWORD PTR _iPublicOpinionUnhappiness$[ebp], 10 ; 0000000aH
	jl	$LN13@DoConsider

; 613  : 	{
; 614  : 		// How much Happiness could we gain from a switch?
; 615  : 		int iHappinessCurrentIdeology = GetBranchBuildingHappiness(pPlayer, eCurrentIdeology);

	mov	edx, DWORD PTR _eCurrentIdeology$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness
	mov	DWORD PTR _iHappinessCurrentIdeology$221735[ebp], eax

; 616  : 		int iHappinessPreferredIdeology = GetBranchBuildingHappiness(pPlayer, ePreferredIdeology);

	mov	ecx, DWORD PTR _ePreferredIdeology$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ; CvPolicyAI::GetBranchBuildingHappiness
	mov	DWORD PTR _iHappinessPreferredIdeology$221736[ebp], eax

; 617  : 
; 618  : 		// Does the switch fight against our clearly preferred victory path?
; 619  : 		bool bDontSwitchFreedom = false;

	mov	BYTE PTR _bDontSwitchFreedom$221737[ebp], 0

; 620  : 		bool bDontSwitchOrder = false;

	mov	BYTE PTR _bDontSwitchOrder$221738[ebp], 0

; 621  : 		bool bDontSwitchAutocracy = false;

	mov	BYTE PTR _bDontSwitchAutocracy$221739[ebp], 0

; 622  : 		int iConquestPriority = pPlayer->GetGrandStrategyAI()->GetConquestPriority();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetConquestPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetConquestPriority
	mov	DWORD PTR _iConquestPriority$221740[ebp], eax

; 623  : 		int iDiploPriority = pPlayer->GetGrandStrategyAI()->GetUnitedNationsPriority();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetUnitedNationsPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetUnitedNationsPriority
	mov	DWORD PTR _iDiploPriority$221741[ebp], eax

; 624  : 		int iTechPriority = pPlayer->GetGrandStrategyAI()->GetSpaceshipPriority();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetSpaceshipPriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetSpaceshipPriority
	mov	DWORD PTR _iTechPriority$221742[ebp], eax

; 625  : 		int iCulturePriority = pPlayer->GetGrandStrategyAI()->GetCulturePriority();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetCulturePriority@CvGrandStrategyAI@@QAEHXZ ; CvGrandStrategyAI::GetCulturePriority
	mov	DWORD PTR _iCulturePriority$221743[ebp], eax

; 626  : 		int iClearPrefPercent = GC.getIDEOLOGY_PERCENT_CLEAR_VICTORY_PREF();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8344
	mov	DWORD PTR _iClearPrefPercent$221744[ebp], eax

; 627  : 		if (iConquestPriority > (iDiploPriority   * (100 + iClearPrefPercent) / 100) &&
; 628  : 			iConquestPriority > (iTechPriority    * (100 + iClearPrefPercent) / 100) &&
; 629  : 			iConquestPriority > (iCulturePriority * (100 + iClearPrefPercent) / 100))

	mov	ecx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	ecx, 100				; 00000064H
	mov	eax, ecx
	imul	eax, DWORD PTR _iDiploPriority$221741[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iConquestPriority$221740[ebp], eax
	jle	SHORT $LN11@DoConsider
	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iTechPriority$221742[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iConquestPriority$221740[ebp], eax
	jle	SHORT $LN11@DoConsider
	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iCulturePriority$221743[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iConquestPriority$221740[ebp], eax
	jle	SHORT $LN11@DoConsider

; 630  : 		{
; 631  : 			bDontSwitchFreedom = true;

	mov	BYTE PTR _bDontSwitchFreedom$221737[ebp], 1

; 632  : 		}
; 633  : 		else if (iDiploPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	$LN10@DoConsider
$LN11@DoConsider:

; 634  : 			iDiploPriority > (iTechPriority     * (100 + iClearPrefPercent) / 100) &&
; 635  : 			iDiploPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iConquestPriority$221740[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iDiploPriority$221741[ebp], eax
	jle	SHORT $LN9@DoConsider
	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iTechPriority$221742[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iDiploPriority$221741[ebp], eax
	jle	SHORT $LN9@DoConsider
	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iCulturePriority$221743[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iDiploPriority$221741[ebp], eax
	jle	SHORT $LN9@DoConsider

; 636  : 		{
; 637  : 			bDontSwitchOrder = true;

	mov	BYTE PTR _bDontSwitchOrder$221738[ebp], 1

; 638  : 		}
; 639  : 		else if (iTechPriority > (iConquestPriority * (100 + iClearPrefPercent) / 100) &&

	jmp	SHORT $LN10@DoConsider
$LN9@DoConsider:

; 640  : 			iTechPriority > (iDiploPriority    * (100 + iClearPrefPercent) / 100) &&
; 641  : 			iTechPriority > (iCulturePriority  * (100 + iClearPrefPercent) / 100))

	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iConquestPriority$221740[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iTechPriority$221742[ebp], eax
	jle	SHORT $LN10@DoConsider
	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iDiploPriority$221741[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iTechPriority$221742[ebp], eax
	jle	SHORT $LN10@DoConsider
	mov	edx, DWORD PTR _iClearPrefPercent$221744[ebp]
	add	edx, 100				; 00000064H
	mov	eax, edx
	imul	eax, DWORD PTR _iCulturePriority$221743[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	cmp	DWORD PTR _iTechPriority$221742[ebp], eax
	jle	SHORT $LN10@DoConsider

; 642  : 		{
; 643  : 			bDontSwitchAutocracy = true;

	mov	BYTE PTR _bDontSwitchAutocracy$221739[ebp], 1
$LN10@DoConsider:

; 644  : 		}
; 645  : 
; 646  : 		int iTotalHappinessImprovement = iPublicOpinionUnhappiness + iHappinessPreferredIdeology - iHappinessCurrentIdeology;

	mov	edx, DWORD PTR _iPublicOpinionUnhappiness$[ebp]
	add	edx, DWORD PTR _iHappinessPreferredIdeology$221736[ebp]
	sub	edx, DWORD PTR _iHappinessCurrentIdeology$221735[ebp]
	mov	DWORD PTR _iTotalHappinessImprovement$221750[ebp], edx

; 647  : 		if (iTotalHappinessImprovement >= 10)

	cmp	DWORD PTR _iTotalHappinessImprovement$221750[ebp], 10 ; 0000000aH
	jl	$LN13@DoConsider

; 648  : 		{
; 649  : 			if (bDontSwitchFreedom && ePreferredIdeology == GC.getPOLICY_BRANCH_FREEDOM())

	movzx	eax, BYTE PTR _bDontSwitchFreedom$221737[ebp]
	test	eax, eax
	je	SHORT $LN5@DoConsider
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	mov	DWORD PTR $T224232[ebp], ecx
	mov	edx, DWORD PTR _ePreferredIdeology$[ebp]
	cmp	edx, DWORD PTR $T224232[ebp]
	jne	SHORT $LN5@DoConsider

; 650  : 			{
; 651  : 				return;

	jmp	$LN13@DoConsider
$LN5@DoConsider:

; 652  : 			}
; 653  : 			if (bDontSwitchAutocracy && ePreferredIdeology == GC.getPOLICY_BRANCH_AUTOCRACY())

	movzx	eax, BYTE PTR _bDontSwitchAutocracy$221739[ebp]
	test	eax, eax
	je	SHORT $LN4@DoConsider
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380
	mov	DWORD PTR $T224236[ebp], ecx
	mov	edx, DWORD PTR _ePreferredIdeology$[ebp]
	cmp	edx, DWORD PTR $T224236[ebp]
	jne	SHORT $LN4@DoConsider

; 654  : 			{
; 655  : 				return;

	jmp	$LN13@DoConsider
$LN4@DoConsider:

; 656  : 			}
; 657  : 			if (bDontSwitchOrder && ePreferredIdeology == GC.getPOLICY_BRANCH_ORDER())

	movzx	eax, BYTE PTR _bDontSwitchOrder$221738[ebp]
	test	eax, eax
	je	SHORT $LN3@DoConsider
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	mov	DWORD PTR $T224240[ebp], ecx
	mov	edx, DWORD PTR _ePreferredIdeology$[ebp]
	cmp	edx, DWORD PTR $T224240[ebp]
	jne	SHORT $LN3@DoConsider

; 658  : 			{
; 659  : 				return;

	jmp	$LN13@DoConsider
$LN3@DoConsider:

; 660  : 			}
; 661  : 
; 662  : 			// Cleared all obstacles -- REVOLUTION!
; 663  : 			pPlayer->SetAnarchyNumTurns(GC.getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6976
	mov	DWORD PTR $T224244[ebp], eax
	mov	ecx, DWORD PTR $T224244[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?SetAnarchyNumTurns@CvPlayer@@QAEXH@Z	; CvPlayer::SetAnarchyNumTurns

; 664  : 			pPlayer->GetPlayerPolicies()->DoSwitchIdeologies(ePreferredIdeology);	

	mov	edx, DWORD PTR _ePreferredIdeology$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchIdeologies

; 665  : 
; 666  : 			if (ePreferredIdeology == GC.getPOLICY_BRANCH_FREEDOM() && eCurrentIdeology == GC.getPOLICY_BRANCH_ORDER())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	mov	DWORD PTR $T224248[ebp], eax
	mov	ecx, DWORD PTR _ePreferredIdeology$[ebp]
	cmp	ecx, DWORD PTR $T224248[ebp]
	jne	SHORT $LN13@DoConsider
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	mov	DWORD PTR $T224252[ebp], edx
	mov	eax, DWORD PTR _eCurrentIdeology$[ebp]
	cmp	eax, DWORD PTR $T224252[ebp]
	jne	SHORT $LN13@DoConsider

; 667  : 			{
; 668  : 				if (GET_PLAYER(eMostPressure).GetID() == GC.getGame().getActivePlayer())

	mov	ecx, DWORD PTR _eMostPressure$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224256[ebp], ecx
	mov	edx, DWORD PTR $T224256[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T224265[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224269[ebp], ecx
	mov	ecx, DWORD PTR $T224269[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T224265[ebp], eax
	jne	SHORT $LN13@DoConsider

; 669  : 				{
; 670  : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_39);

	mov	edx, DWORD PTR $T224273[ebp]
	mov	DWORD PTR tv232[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv232[ebp], eax
	push	281					; 00000119H
	mov	ecx, DWORD PTR tv232[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv232[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN13@DoConsider:

; 671  : 				}
; 672  : 			}
; 673  : 		}
; 674  : 	}
; 675  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ENDP ; CvPolicyAI::DoConsiderIdeologySwitch
_TEXT	ENDS
EXTRN	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z:PROC ; CvCityBuildings::GetNumBuilding
EXTRN	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ:PROC ; CvCity::GetCityBuildings
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
EXTRN	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z:PROC ; CvPolicyEntry::GetBuildingClassHappiness
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
; Function compile flags: /Odtp
;	COMDAT ?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
_pCity$221784 = -40					; size = 4
_iLoop$221785 = -36					; size = 4
_eBuilding$221781 = -32					; size = 4
_pkBuildingClassInfo$221778 = -28			; size = 4
_pkPolicyInfo$221771 = -24				; size = 4
_ePolicy$221769 = -20					; size = 4
_iPolicyLoop$221765 = -16				; size = 4
_iSpecialPolicyBuildingHappiness$ = -12			; size = 4
_iBuildingClassLoop$ = -8				; size = 4
_eBuildingClass$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_eBranch$ = 12						; size = 4
?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::GetBranchBuildingHappiness, COMDAT
; _this$ = ecx

; 679  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 680  : 	// Policy Building Mods
; 681  : 	int iSpecialPolicyBuildingHappiness = 0;

	mov	DWORD PTR _iSpecialPolicyBuildingHappiness$[ebp], 0

; 682  : #ifdef AUI_WARNING_FIXES
; 683  : 	uint iBuildingClassLoop;
; 684  : #else
; 685  : 	int iBuildingClassLoop;
; 686  : #endif
; 687  : 	BuildingClassTypes eBuildingClass;
; 688  : #ifdef AUI_WARNING_FIXES
; 689  : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 690  : #else
; 691  : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$221765[ebp], 0
	jmp	SHORT $LN15@GetBranchB
$LN14@GetBranchB:
	mov	eax, DWORD PTR _iPolicyLoop$221765[ebp]
	add	eax, 1
	mov	DWORD PTR _iPolicyLoop$221765[ebp], eax
$LN15@GetBranchB:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	DWORD PTR _iPolicyLoop$221765[ebp], eax
	jge	$LN13@GetBranchB

; 692  : #endif
; 693  : 	{
; 694  : 		PolicyTypes ePolicy = (PolicyTypes)iPolicyLoop;

	mov	ecx, DWORD PTR _iPolicyLoop$221765[ebp]
	mov	DWORD PTR _ePolicy$221769[ebp], ecx

; 695  : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	mov	edx, DWORD PTR _ePolicy$221769[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$221771[ebp], eax

; 696  : 		if(pkPolicyInfo)

	cmp	DWORD PTR _pkPolicyInfo$221771[ebp], 0
	je	$LN12@GetBranchB

; 697  : 		{
; 698  : 			if (pkPolicyInfo->GetPolicyBranchType() == eBranch)

	mov	ecx, DWORD PTR _pkPolicyInfo$221771[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[ebp]
	jne	$LN12@GetBranchB

; 699  : 			{
; 700  : 				for(iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	DWORD PTR _iBuildingClassLoop$[ebp], 0
	jmp	SHORT $LN10@GetBranchB
$LN9@GetBranchB:
	mov	eax, DWORD PTR _iBuildingClassLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildingClassLoop$[ebp], eax
$LN10@GetBranchB:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iBuildingClassLoop$[ebp], eax
	jge	$LN12@GetBranchB

; 701  : 				{
; 702  : 					eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;

	mov	ecx, DWORD PTR _iBuildingClassLoop$[ebp]
	mov	DWORD PTR _eBuildingClass$[ebp], ecx

; 703  : 
; 704  : 					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$221778[ebp], eax

; 705  : 					if (!pkBuildingClassInfo)

	cmp	DWORD PTR _pkBuildingClassInfo$221778[ebp], 0
	jne	SHORT $LN7@GetBranchB

; 706  : 					{
; 707  : 						continue;

	jmp	SHORT $LN9@GetBranchB
$LN7@GetBranchB:

; 708  : 					}
; 709  : 
; 710  : 					if (pkPolicyInfo->GetBuildingClassHappiness(eBuildingClass) != 0)

	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPolicyInfo$221771[ebp]
	call	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
	test	eax, eax
	je	SHORT $LN6@GetBranchB

; 711  : 					{
; 712  : 						BuildingTypes eBuilding = (BuildingTypes)pPlayer->getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	mov	ecx, DWORD PTR _eBuildingClass$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$221781[ebp], eax

; 713  : 						if (eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$221781[ebp], -1
	je	SHORT $LN6@GetBranchB

; 714  : 						{
; 715  : 							CvCity *pCity;
; 716  : 							int iLoop;
; 717  : 							for (pCity = pPlayer->firstCity(&iLoop); pCity != NULL; pCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$221785[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$221784[ebp], eax
	jmp	SHORT $LN4@GetBranchB
$LN3@GetBranchB:
	push	0
	lea	eax, DWORD PTR _iLoop$221785[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$221784[ebp], eax
$LN4@GetBranchB:
	cmp	DWORD PTR _pCity$221784[ebp], 0
	je	SHORT $LN6@GetBranchB

; 718  : 							{
; 719  : 								if (pCity->GetCityBuildings()->GetNumBuilding(eBuilding) > 0)

	mov	ecx, DWORD PTR _eBuilding$221781[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pCity$221784[ebp]
	call	?GetCityBuildings@CvCity@@QBEPAVCvCityBuildings@@XZ ; CvCity::GetCityBuildings
	mov	ecx, eax
	call	?GetNumBuilding@CvCityBuildings@@QBEHW4BuildingTypes@@@Z ; CvCityBuildings::GetNumBuilding
	test	eax, eax
	jle	SHORT $LN1@GetBranchB

; 720  : 								{
; 721  : 									iSpecialPolicyBuildingHappiness += pkPolicyInfo->GetBuildingClassHappiness(eBuildingClass);

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPolicyInfo$221771[ebp]
	call	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
	add	eax, DWORD PTR _iSpecialPolicyBuildingHappiness$[ebp]
	mov	DWORD PTR _iSpecialPolicyBuildingHappiness$[ebp], eax
$LN1@GetBranchB:

; 722  : 								}
; 723  : 							}

	jmp	SHORT $LN3@GetBranchB
$LN6@GetBranchB:

; 724  : 						}
; 725  : 					}
; 726  : 				}

	jmp	$LN9@GetBranchB
$LN12@GetBranchB:

; 727  : 			}
; 728  : 		}
; 729  : 	}

	jmp	$LN14@GetBranchB
$LN13@GetBranchB:

; 730  : 	return iSpecialPolicyBuildingHappiness;

	mov	eax, DWORD PTR _iSpecialPolicyBuildingHappiness$[ebp]

; 731  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBranchBuildingHappiness@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::GetBranchBuildingHappiness
_TEXT	ENDS
EXTRN	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ:PROC ; CvBuildingEntry::IsNoOccupiedUnhappiness
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
; Function compile flags: /Odtp
;	COMDAT ?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
_pkEntry$221816 = -36					; size = 4
_eBuilding$221813 = -32					; size = 4
_pkBuildingClassInfo$221811 = -28			; size = 4
_pkPolicyInfo$221804 = -24				; size = 4
_ePolicy$221802 = -20					; size = 4
_iPolicyLoop$221798 = -16				; size = 4
_iRtnValue$ = -12					; size = 4
_iBuildingClassLoop$ = -8				; size = 4
_eBuildingClass$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_eBranch$ = 12						; size = 4
?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::GetNumHappinessPolicies, COMDAT
; _this$ = ecx

; 735  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 737  : #ifdef AUI_WARNING_FIXES
; 738  : 	uint iBuildingClassLoop;
; 739  : 	BuildingClassTypes eBuildingClass;
; 740  : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 741  : #else
; 742  : 	int iBuildingClassLoop;
; 743  : 	BuildingClassTypes eBuildingClass;
; 744  : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$221798[ebp], 0
	jmp	SHORT $LN13@GetNumHapp
$LN12@GetNumHapp:
	mov	eax, DWORD PTR _iPolicyLoop$221798[ebp]
	add	eax, 1
	mov	DWORD PTR _iPolicyLoop$221798[ebp], eax
$LN13@GetNumHapp:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	DWORD PTR _iPolicyLoop$221798[ebp], eax
	jge	$LN11@GetNumHapp

; 745  : #endif
; 746  : 	{
; 747  : 		PolicyTypes ePolicy = (PolicyTypes)iPolicyLoop;

	mov	ecx, DWORD PTR _iPolicyLoop$221798[ebp]
	mov	DWORD PTR _ePolicy$221802[ebp], ecx

; 748  : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	mov	edx, DWORD PTR _ePolicy$221802[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$221804[ebp], eax

; 749  : 		if(pkPolicyInfo)

	cmp	DWORD PTR _pkPolicyInfo$221804[ebp], 0
	je	$LN10@GetNumHapp

; 750  : 		{
; 751  : 			if (pkPolicyInfo->GetPolicyBranchType() == eBranch)

	mov	ecx, DWORD PTR _pkPolicyInfo$221804[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[ebp]
	jne	$LN10@GetNumHapp

; 752  : 			{
; 753  : 				for(iBuildingClassLoop = 0; iBuildingClassLoop < GC.getNumBuildingClassInfos(); iBuildingClassLoop++)

	mov	DWORD PTR _iBuildingClassLoop$[ebp], 0
	jmp	SHORT $LN8@GetNumHapp
$LN7@GetNumHapp:
	mov	eax, DWORD PTR _iBuildingClassLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildingClassLoop$[ebp], eax
$LN8@GetNumHapp:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iBuildingClassLoop$[ebp], eax
	jge	$LN10@GetNumHapp

; 754  : 				{
; 755  : 					eBuildingClass = (BuildingClassTypes) iBuildingClassLoop;

	mov	ecx, DWORD PTR _iBuildingClassLoop$[ebp]
	mov	DWORD PTR _eBuildingClass$[ebp], ecx

; 756  : 
; 757  : 					CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$221811[ebp], eax

; 758  : 					if (!pkBuildingClassInfo)

	cmp	DWORD PTR _pkBuildingClassInfo$221811[ebp], 0
	jne	SHORT $LN5@GetNumHapp

; 759  : 					{
; 760  : 						continue;

	jmp	SHORT $LN7@GetNumHapp
$LN5@GetNumHapp:

; 761  : 					}
; 762  : 
; 763  : 					BuildingTypes eBuilding = (BuildingTypes)pPlayer->getCivilizationInfo().getCivilizationBuildings(eBuildingClass);

	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$221813[ebp], eax

; 764  : 					if (eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$221813[ebp], -1
	je	SHORT $LN4@GetNumHapp

; 765  : 					{
; 766  : 						// Don't count a building that can only be built in conquered cities
; 767  : 						CvBuildingEntry *pkEntry = GC.getBuildingInfo(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$221813[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkEntry$221816[ebp], eax

; 768  : 						if (!pkEntry || pkEntry->IsNoOccupiedUnhappiness())

	cmp	DWORD PTR _pkEntry$221816[ebp], 0
	je	SHORT $LN2@GetNumHapp
	mov	ecx, DWORD PTR _pkEntry$221816[ebp]
	call	?IsNoOccupiedUnhappiness@CvBuildingEntry@@QBE_NXZ ; CvBuildingEntry::IsNoOccupiedUnhappiness
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@GetNumHapp
$LN2@GetNumHapp:

; 769  : 						{
; 770  : 							continue;

	jmp	SHORT $LN7@GetNumHapp
$LN3@GetNumHapp:

; 771  : 						}
; 772  : 
; 773  : 						if (pkPolicyInfo->GetBuildingClassHappiness(eBuildingClass) != 0)

	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPolicyInfo$221804[ebp]
	call	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
	test	eax, eax
	je	SHORT $LN4@GetNumHapp

; 774  : 						{
; 775  : 							iRtnValue++;

	mov	ecx, DWORD PTR _iRtnValue$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iRtnValue$[ebp], ecx

; 776  : 							break;

	jmp	SHORT $LN10@GetNumHapp
$LN4@GetNumHapp:

; 777  : 						}
; 778  : 					}
; 779  : 				}

	jmp	$LN7@GetNumHapp
$LN10@GetNumHapp:

; 780  : 			}
; 781  : 		}
; 782  : 	}

	jmp	$LN12@GetNumHapp
$LN11@GetNumHapp:

; 783  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 784  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNumHappinessPolicies@CvPolicyAI@@QAEHPAVCvPlayer@@W4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::GetNumHappinessPolicies
_TEXT	ENDS
PUBLIC	?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z	; CvPolicyAI::PropagateWeights
; Function compile flags: /Odtp
;	COMDAT ?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iPolicyLoop$ = -4					; size = 4
_paiTempWeights$ = 8					; size = 4
_iPropagationPercent$ = 12				; size = 4
?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z PROC		; CvPolicyAI::WeightPrereqs, COMDAT
; _this$ = ecx

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 797  : 	int iPolicyLoop;
; 798  : #endif
; 799  : 
; 800  : 	// Loop through policies looking for ones that are just getting some new weight
; 801  : 	for(iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$[ebp], 0
	jmp	SHORT $LN4@WeightPrer
$LN3@WeightPrer:
	mov	eax, DWORD PTR _iPolicyLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPolicyLoop$[ebp], eax
$LN4@WeightPrer:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$[ebp], eax
	jge	SHORT $LN5@WeightPrer

; 802  : 	{
; 803  : 		// If found one, call our recursive routine to weight everything to the left in the tree
; 804  : 		if(paiTempWeights[iPolicyLoop] > 0)

	mov	edx, DWORD PTR _iPolicyLoop$[ebp]
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jle	SHORT $LN1@WeightPrer

; 805  : 		{
; 806  : 			PropagateWeights(iPolicyLoop, paiTempWeights[iPolicyLoop], iPropagationPercent, 0);

	push	0
	mov	ecx, DWORD PTR _iPropagationPercent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPolicyLoop$[ebp]
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _iPolicyLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z ; CvPolicyAI::PropagateWeights
$LN1@WeightPrer:

; 807  : 		}

	jmp	SHORT $LN3@WeightPrer
$LN5@WeightPrer:

; 808  : 	}
; 809  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?WeightPrereqs@CvPolicyAI@@AAEXPAHH@Z ENDP		; CvPolicyAI::WeightPrereqs
_TEXT	ENDS
EXTRN	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z:PROC ; CvPolicyEntry::GetPrereqAndPolicies
; Function compile flags: /Odtp
;	COMDAT ?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z
_TEXT	SEGMENT
tv88 = -28						; size = 4
tv133 = -24						; size = 4
_this$ = -20						; size = 4
$T224285 = -16						; size = 4
_iPrereq$221843 = -12					; size = 4
_iI$221839 = -8						; size = 4
_iPropagatedWeight$221838 = -4				; size = 4
_iPolicy$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
_iPropagationLevel$ = 20				; size = 4
?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z PROC		; CvPolicyAI::PropagateWeights, COMDAT
; _this$ = ecx

; 813  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 814  : 	if(iPropagationLevel < m_iPolicyWeightPropagationLevels)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iPropagationLevel$[ebp]
	cmp	ecx, DWORD PTR [eax+1060]
	jge	$LN8@PropagateW

; 815  : 	{
; 816  : 		int iPropagatedWeight = iWeight * iPropagationPercent / 100;

	mov	eax, DWORD PTR _iWeight$[ebp]
	imul	eax, DWORD PTR _iPropagationPercent$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iPropagatedWeight$221838[ebp], eax

; 817  : 
; 818  : 		// Loop through all prerequisites
; 819  : 		for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$221839[ebp], 0
	jmp	SHORT $LN6@PropagateW
$LN5@PropagateW:
	mov	edx, DWORD PTR _iI$221839[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$221839[ebp], edx
$LN6@PropagateW:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	mov	DWORD PTR $T224285[ebp], eax
	mov	ecx, DWORD PTR _iI$221839[ebp]
	cmp	ecx, DWORD PTR $T224285[ebp]
	jge	SHORT $LN8@PropagateW

; 820  : 		{
; 821  : 			// Did we find a prereq?
; 822  : 			int iPrereq = m_pCurrentPolicies->GetPolicies()->GetPolicyEntry(iPolicy)->GetPrereqAndPolicies(iI);

	mov	edx, DWORD PTR _iI$221839[ebp]
	push	edx
	mov	eax, DWORD PTR _iPolicy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetPrereqAndPolicies
	mov	DWORD PTR _iPrereq$221843[ebp], eax

; 823  : 			if(iPrereq != NO_POLICY)

	cmp	DWORD PTR _iPrereq$221843[ebp], -1
	je	SHORT $LN3@PropagateW

; 824  : 			{
; 825  : 				// Apply reduced weight here.  Note that we apply these to the master weight array, not
; 826  : 				// the temporary one.  The temporary one is just used to hold the newly weighted policies
; 827  : 				// (from which this weight propagation must originate).
; 828  : 				m_PolicyAIWeights.IncreaseWeight(iPrereq, iPropagatedWeight);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iPrereq$221843[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR tv133[ebp], edx
	mov	eax, DWORD PTR tv133[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _iPropagatedWeight$221838[ebp]
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR [edx], ecx

; 829  : 
; 830  : 				// Recurse to its prereqs (assuming we have any weight left)
; 831  : 				if(iPropagatedWeight > 0)

	cmp	DWORD PTR _iPropagatedWeight$221838[ebp], 0
	jle	SHORT $LN2@PropagateW

; 832  : 				{
; 833  : 					PropagateWeights(iPrereq, iPropagatedWeight, iPropagationPercent, iPropagationLevel++);

	mov	eax, DWORD PTR _iPropagationLevel$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	ecx, DWORD PTR tv88[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPropagationPercent$[ebp]
	push	edx
	mov	eax, DWORD PTR _iPropagatedWeight$221838[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPrereq$221843[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z ; CvPolicyAI::PropagateWeights
	mov	edx, DWORD PTR _iPropagationLevel$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPropagationLevel$[ebp], edx
$LN2@PropagateW:

; 834  : 				}
; 835  : 			}
; 836  : 			else

	jmp	SHORT $LN1@PropagateW
$LN3@PropagateW:

; 837  : 			{
; 838  : 				break;

	jmp	SHORT $LN8@PropagateW
$LN1@PropagateW:

; 839  : 			}
; 840  : 		}

	jmp	$LN5@PropagateW
$LN8@PropagateW:

; 841  : 	}
; 842  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PropagateWeights@CvPolicyAI@@AAEXHHHH@Z ENDP		; CvPolicyAI::PropagateWeights
_TEXT	ENDS
EXTRN	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ:PROC	; CvPolicyBranchEntry::GetFreePolicy
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
; Function compile flags: /Odtp
;	COMDAT ?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T224324 = -40						; size = 4
_elem$224323 = -36					; size = 8
_elem$224309 = -28					; size = 8
_ePolicyLoop$221858 = -20				; size = 4
_pkLoopPolicyInfo$221860 = -16				; size = 4
_iPolicyLoop$221854 = -12				; size = 4
_pkPolicyBranchInfo$ = -8				; size = 4
_iWeight$ = -4						; size = 4
_eBranch$ = 8						; size = 4
?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::WeighBranch, COMDAT
; _this$ = ecx

; 846  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 	int iWeight = 0;

	mov	DWORD PTR _iWeight$[ebp], 0

; 848  : 
; 849  : 	CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranch);

	mov	eax, DWORD PTR _eBranch$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$[ebp], eax

; 850  : 	if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$[ebp], 0
	je	$LN8@WeighBranc

; 851  : 	{
; 852  : #ifdef AUI_WARNING_FIXES
; 853  : 		for (uint iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 854  : #else
; 855  : 		for(int iPolicyLoop = 0; iPolicyLoop < m_pCurrentPolicies->GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$221854[ebp], 0
	jmp	SHORT $LN7@WeighBranc
$LN6@WeighBranc:
	mov	ecx, DWORD PTR _iPolicyLoop$221854[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPolicyLoop$221854[ebp], ecx
$LN7@WeighBranc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$221854[ebp], eax
	jge	$LN5@WeighBranc

; 856  : #endif
; 857  : 		{
; 858  : 			const PolicyTypes ePolicyLoop = static_cast<PolicyTypes>(iPolicyLoop);

	mov	eax, DWORD PTR _iPolicyLoop$221854[ebp]
	mov	DWORD PTR _ePolicyLoop$221858[ebp], eax

; 859  : 			CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(ePolicyLoop);

	mov	ecx, DWORD PTR _ePolicyLoop$221858[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkLoopPolicyInfo$221860[ebp], eax

; 860  : 			if(pkLoopPolicyInfo)

	cmp	DWORD PTR _pkLoopPolicyInfo$221860[ebp], 0
	je	SHORT $LN4@WeighBranc

; 861  : 			{
; 862  : 				// Policy we don't have?
; 863  : 				if(!m_pCurrentPolicies->HasPolicy(ePolicyLoop))

	mov	edx, DWORD PTR _ePolicyLoop$221858[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@WeighBranc

; 864  : 				{
; 865  : 					// From this branch we are considering opening?
; 866  : 					if(pkLoopPolicyInfo->GetPolicyBranchType() == eBranch)

	mov	ecx, DWORD PTR _pkLoopPolicyInfo$221860[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[ebp]
	jne	SHORT $LN4@WeighBranc

; 867  : 					{
; 868  : 						// With no prereqs?
; 869  : 						if(pkLoopPolicyInfo->GetPrereqAndPolicies(0) == NO_POLICY)

	push	0
	mov	ecx, DWORD PTR _pkLoopPolicyInfo$221860[ebp]
	call	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetPrereqAndPolicies
	cmp	eax, -1
	jne	SHORT $LN4@WeighBranc

; 870  : 						{
; 871  : 							iWeight += m_PolicyAIWeights.GetWeight(iPolicyLoop);

	mov	DWORD PTR _elem$224309[ebp], 0
	mov	DWORD PTR _elem$224309[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iPolicyLoop$221854[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$224309[ebp], edx
	mov	DWORD PTR _elem$224309[ebp+4], eax
	mov	ecx, DWORD PTR _iWeight$[ebp]
	add	ecx, DWORD PTR _elem$224309[ebp+4]
	mov	DWORD PTR _iWeight$[ebp], ecx
$LN4@WeighBranc:

; 872  : 						}
; 873  : 					}
; 874  : 				}
; 875  : 			}
; 876  : 		}

	jmp	$LN6@WeighBranc
$LN5@WeighBranc:

; 877  : 
; 878  : 		// Add weight of free policy from branch
; 879  : 		iWeight += m_PolicyAIWeights.GetWeight(pkPolicyBranchInfo->GetFreePolicy());

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	mov	DWORD PTR $T224324[ebp], eax
	mov	DWORD PTR _elem$224323[ebp], 0
	mov	DWORD PTR _elem$224323[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR $T224324[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$224323[ebp], edx
	mov	DWORD PTR _elem$224323[ebp+4], eax
	mov	ecx, DWORD PTR _iWeight$[ebp]
	add	ecx, DWORD PTR _elem$224323[ebp+4]
	mov	DWORD PTR _iWeight$[ebp], ecx
$LN8@WeighBranc:

; 880  : 	}
; 881  : 
; 882  : 	return iWeight;

	mov	eax, DWORD PTR _iWeight$[ebp]

; 883  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WeighBranch@CvPolicyAI@@AAEHW4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::WeighBranch
_TEXT	ENDS
EXTRN	?GetNumMinorCivsEver@CvGame@@QAEHXZ:PROC	; CvGame::GetNumMinorCivsEver
EXTRN	?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
EXTRN	?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoScience
EXTRN	?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoCulture
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ:PROC ; CvPolicyBranchEntry::IsDelayWhenNoReligion
; Function compile flags: /Odtp
;	COMDAT ?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224342 = -20						; size = 4
$T224338 = -16						; size = 4
$T224334 = -12						; size = 4
$T224330 = -8						; size = 4
_pBranchInfo$ = -4					; size = 4
_eBranch$ = 8						; size = 4
?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::IsBranchEffectiveInGame, COMDAT
; _this$ = ecx

; 887  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 888  : 	CvPolicyBranchEntry* pBranchInfo = GC.getPolicyBranchInfo(eBranch);

	mov	eax, DWORD PTR _eBranch$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pBranchInfo$[ebp], eax

; 889  : 	CvAssertMsg(pBranchInfo, "Branch info not found! Please send Anton your save file and version.");
; 890  : 	if (!pBranchInfo) return false;

	cmp	DWORD PTR _pBranchInfo$[ebp], 0
	jne	SHORT $LN9@IsBranchEf
	xor	al, al
	jmp	$LN10@IsBranchEf
$LN9@IsBranchEf:

; 891  : 	
; 892  : 	if (pBranchInfo->IsDelayWhenNoReligion())

	mov	ecx, DWORD PTR _pBranchInfo$[ebp]
	call	?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoReligion
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@IsBranchEf

; 893  : 		if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224330[ebp], edx
	push	21					; 00000015H
	mov	ecx, DWORD PTR $T224330[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@IsBranchEf

; 894  : 			return false;

	xor	al, al
	jmp	$LN10@IsBranchEf
$LN8@IsBranchEf:

; 895  : 
; 896  : 	if (pBranchInfo->IsDelayWhenNoCulture())

	mov	ecx, DWORD PTR _pBranchInfo$[ebp]
	call	?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCulture
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@IsBranchEf

; 897  : 		if (GC.getGame().isOption(GAMEOPTION_NO_POLICIES))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224334[ebp], edx
	push	18					; 00000012H
	mov	ecx, DWORD PTR $T224334[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@IsBranchEf

; 898  : 			return false;

	xor	al, al
	jmp	SHORT $LN10@IsBranchEf
$LN6@IsBranchEf:

; 899  : 
; 900  : 	if (pBranchInfo->IsDelayWhenNoScience())

	mov	ecx, DWORD PTR _pBranchInfo$[ebp]
	call	?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoScience
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsBranchEf

; 901  : 		if (GC.getGame().isOption(GAMEOPTION_NO_SCIENCE))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224338[ebp], edx
	push	17					; 00000011H
	mov	ecx, DWORD PTR $T224338[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsBranchEf

; 902  : 			return false;

	xor	al, al
	jmp	SHORT $LN10@IsBranchEf
$LN4@IsBranchEf:

; 903  : 
; 904  : 	if (pBranchInfo->IsDelayWhenNoCityStates())

	mov	ecx, DWORD PTR _pBranchInfo$[ebp]
	call	?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsBranchEf

; 905  : 		if (GC.getGame().GetNumMinorCivsEver() <= 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224342[ebp], edx
	mov	ecx, DWORD PTR $T224342[ebp]
	call	?GetNumMinorCivsEver@CvGame@@QAEHXZ	; CvGame::GetNumMinorCivsEver
	test	eax, eax
	jg	SHORT $LN2@IsBranchEf

; 906  : 			return false;

	xor	al, al
	jmp	SHORT $LN10@IsBranchEf
$LN2@IsBranchEf:

; 907  : 
; 908  : 	return true;

	mov	al, 1
$LN10@IsBranchEf:

; 909  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsBranchEffectiveInGame@CvPolicyAI@@AAE_NW4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::IsBranchEffectiveInGame
_TEXT	ENDS
PUBLIC	??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	??_C@_0O@FEIHADIP@Branch?5?$CFd?0?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
PUBLIC	__$ArrayPad$
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ:PROC ; CvPlayerPolicies::GetPlayer
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@ DB '%s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FEIHADIP@Branch?5?$CFd?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@FEIHADIP@Branch?5?$CFd?0?5?$CFd?$AA@ DB 'Branch %d, %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
_TEXT	SEGMENT
tv269 = -332						; size = 4
tv204 = -328						; size = 4
tv239 = -324						; size = 4
tv280 = -320						; size = 4
tv291 = -316						; size = 4
tv95 = -312						; size = 4
_this$ = -308						; size = 4
$T224455 = -304						; size = 4
$T224451 = -300						; size = 4
_elem$224420 = -296					; size = 8
$T224402 = -288						; size = 4
$T224397 = -284						; size = 4
$T224389 = -280						; size = 4
$T224388 = -276						; size = 4
$T224384 = -272						; size = 4
$T224350 = -268						; size = 28
$T224347 = -240						; size = 28
$T224346 = -212						; size = 28
_szPolicyType$221905 = -184				; size = 4
_pPolicyEntry$221904 = -180				; size = 4
_ePolicy$221902 = -176					; size = 4
_iWeight$221898 = -172					; size = 4
_iI$221894 = -168					; size = 4
_strOutBuf$221883 = -164				; size = 28
_playerName$221886 = -136				; size = 28
_iNumBranches$221893 = -108				; size = 4
_strDesc$221887 = -104					; size = 28
_pLog$221888 = -76					; size = 4
_strTemp$221885 = -72					; size = 28
_strBaseString$221884 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogPossiblePolicies@CvPolicyAI@@AAEXXZ PROC		; CvPolicyAI::LogPossiblePolicies, COMDAT
; _this$ = ecx

; 913  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 320				; 00000140H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN7@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN7@LogPossibl

; 915  : 	{
; 916  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$221883[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 917  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$221884[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 918  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$221885[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 919  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$221886[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 920  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$221887[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 921  : 
; 922  : 		// Find the name of this civ and city
; 923  : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T224384[ebp], eax
	cmp	DWORD PTR $T224384[ebp], 0
	je	SHORT $LN35@LogPossibl
	mov	eax, DWORD PTR $T224384[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$221886[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN36@LogPossibl
$LN35@LogPossibl:
	lea	ecx, DWORD PTR _playerName$221886[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN36@LogPossibl:

; 924  : 
; 925  : 		FILogFile* pLog;
; 926  : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv95[ebp], eax
	lea	ecx, DWORD PTR _playerName$221886[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224346[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	DWORD PTR tv291[ebp], eax
	mov	eax, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T224388[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T224388[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224389[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T224389[ebp]
	push	ecx
	mov	edx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$221888[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224346[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 927  : 
; 928  : 		// Get the leading info for this line
; 929  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224397[ebp], eax
	mov	ecx, DWORD PTR $T224397[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$221884[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 930  : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$221886[ebp]
	push	edx
	lea	eax, DWORD PTR $T224347[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv280[ebp], eax
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR tv239[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv239[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$221884[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224347[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 931  : 
; 932  : #ifdef AUI_WARNING_FIXES
; 933  : 		uint iNumBranches = GC.getNumPolicyBranchInfos();
; 934  : #else
; 935  : 		int iNumBranches = GC.getNumPolicyBranchInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyBranchInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumPolicyBranchInfos
	mov	DWORD PTR _iNumBranches$221893[ebp], eax

; 936  : #endif
; 937  : 
; 938  : 		// Dump out the weight of each possible policy
; 939  : 		for(int iI = 0; iI < m_AdoptablePolicies.size(); iI++)

	mov	DWORD PTR _iI$221894[ebp], 0
	jmp	SHORT $LN5@LogPossibl
$LN4@LogPossibl:
	mov	eax, DWORD PTR _iI$221894[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221894[ebp], eax
$LN5@LogPossibl:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+536]
	mov	DWORD PTR $T224402[ebp], edx
	mov	eax, DWORD PTR _iI$221894[ebp]
	cmp	eax, DWORD PTR $T224402[ebp]
	jge	$LN3@LogPossibl

; 940  : 		{
; 941  : 			int iWeight = m_AdoptablePolicies.GetWeight(iI);

	mov	DWORD PTR _elem$224420[ebp], 0
	mov	DWORD PTR _elem$224420[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+532]
	mov	eax, DWORD PTR _iI$221894[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$224420[ebp], ecx
	mov	DWORD PTR _elem$224420[ebp+4], edx
	mov	eax, DWORD PTR _elem$224420[ebp+4]
	mov	DWORD PTR _iWeight$221898[ebp], eax

; 942  : 
; 943  : 			if(m_AdoptablePolicies.GetElement(iI) < iNumBranches)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+532]
	mov	eax, DWORD PTR _iI$221894[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	cmp	ecx, DWORD PTR _iNumBranches$221893[ebp]
	jge	SHORT $LN63@LogPossibl

; 944  : 			{
; 945  : 				strTemp.Format("Branch %d, %d", m_AdoptablePolicies.GetElement(iI), iWeight);

	mov	edx, DWORD PTR _iWeight$221898[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+532]
	mov	edx, DWORD PTR _iI$221894[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	push	eax
	push	OFFSET ??_C@_0O@FEIHADIP@Branch?5?$CFd?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$221885[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 946  : 			}
; 947  : 			else

	jmp	$LN1@LogPossibl

; 948  : 			{
; 949  : 
; 950  : 				PolicyTypes ePolicy = (PolicyTypes)(m_AdoptablePolicies.GetElement(iI) - iNumBranches);

$LN63@LogPossibl:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+532]
	mov	ecx, DWORD PTR _iI$221894[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	sub	edx, DWORD PTR _iNumBranches$221893[ebp]
	mov	DWORD PTR _ePolicy$221902[ebp], edx

; 951  : 				CvPolicyEntry* pPolicyEntry = GC.getPolicyInfo(ePolicy);

	mov	eax, DWORD PTR _ePolicy$221902[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pPolicyEntry$221904[ebp], eax

; 952  : 				const char* szPolicyType = (pPolicyEntry != NULL)? pPolicyEntry->GetType() : "Unknown";

	cmp	DWORD PTR _pPolicyEntry$221904[ebp], 0
	je	SHORT $LN9@LogPossibl
	mov	ecx, DWORD PTR _pPolicyEntry$221904[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv204[ebp], eax
	jmp	SHORT $LN10@LogPossibl
$LN9@LogPossibl:
	mov	DWORD PTR tv204[ebp], OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
$LN10@LogPossibl:
	mov	ecx, DWORD PTR tv204[ebp]
	mov	DWORD PTR _szPolicyType$221905[ebp], ecx

; 953  : 				strTemp.Format("%s, %d", szPolicyType, iWeight);

	mov	edx, DWORD PTR _iWeight$221898[ebp]
	push	edx
	mov	eax, DWORD PTR _szPolicyType$221905[ebp]
	push	eax
	push	OFFSET ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$221885[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN1@LogPossibl:

; 954  : 			}
; 955  : 			strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$221885[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$221884[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224350[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv269[ebp], eax
	mov	edx, DWORD PTR tv269[ebp]
	mov	DWORD PTR $T224451[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T224451[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$221883[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224350[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 956  : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$221883[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224455[ebp], eax
	mov	eax, DWORD PTR $T224455[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$221888[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$221888[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 957  : 		}

	jmp	$LN4@LogPossibl
$LN3@LogPossibl:

; 958  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strDesc$221887[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$221886[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$221885[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$221884[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$221883[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogPossibl:

; 959  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$221883[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$221884[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$221885[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$221886[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strDesc$221887[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T224346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T224347[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T224350[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-324]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPossiblePolicies@CvPolicyAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossiblePolicies@CvPolicyAI@@AAEXXZ ENDP		; CvPolicyAI::LogPossiblePolicies
PUBLIC	??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@		; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@ DB 'CHOSEN, %s', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
_TEXT	SEGMENT
tv239 = -304						; size = 4
tv175 = -300						; size = 4
tv209 = -296						; size = 4
tv250 = -292						; size = 4
tv261 = -288						; size = 4
tv95 = -284						; size = 4
_this$ = -280						; size = 4
$T224547 = -276						; size = 4
$T224543 = -272						; size = 4
$T224536 = -268						; size = 4
$T224528 = -264						; size = 4
$T224527 = -260						; size = 4
$T224523 = -256						; size = 4
$T224489 = -252						; size = 28
$T224486 = -224						; size = 28
$T224485 = -196						; size = 28
_strOutBuf$221913 = -168				; size = 28
_playerName$221916 = -140				; size = 28
_szPolicyType$221922 = -112				; size = 4
_strDesc$221917 = -108					; size = 28
_pLog$221918 = -80					; size = 4
_pPolicyEntry$221921 = -76				; size = 4
_strTemp$221915 = -72					; size = 28
_strBaseString$221914 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ePolicy$ = 8						; size = 4
?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z PROC	; CvPolicyAI::LogPolicyChoice, COMDAT
; _this$ = ecx

; 963  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 964  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogPolicyC
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogPolicyC

; 965  : 	{
; 966  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$221913[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 967  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$221914[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 968  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$221915[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 969  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$221916[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 970  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$221917[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 971  : 
; 972  : 		// Find the name of this civ and city
; 973  : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T224523[ebp], eax
	cmp	DWORD PTR $T224523[ebp], 0
	je	SHORT $LN30@LogPolicyC
	mov	eax, DWORD PTR $T224523[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$221916[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN31@LogPolicyC
$LN30@LogPolicyC:
	lea	ecx, DWORD PTR _playerName$221916[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN31@LogPolicyC:

; 974  : 
; 975  : 		FILogFile* pLog;
; 976  : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv95[ebp], eax
	lea	ecx, DWORD PTR _playerName$221916[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224485[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	DWORD PTR tv261[ebp], eax
	mov	eax, DWORD PTR tv261[ebp]
	mov	DWORD PTR $T224527[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T224527[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224528[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T224528[ebp]
	push	ecx
	mov	edx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$221918[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224485[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 977  : 
; 978  : 		// Get the leading info for this line
; 979  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224536[ebp], eax
	mov	ecx, DWORD PTR $T224536[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$221914[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 980  : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$221916[ebp]
	push	edx
	lea	eax, DWORD PTR $T224486[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv250[ebp], eax
	mov	ecx, DWORD PTR tv250[ebp]
	mov	DWORD PTR tv209[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv209[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$221914[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224486[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 981  : 
; 982  : 		CvPolicyEntry* pPolicyEntry = GC.getPolicyInfo(ePolicy);

	mov	eax, DWORD PTR _ePolicy$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pPolicyEntry$221921[ebp], eax

; 983  : 		const char* szPolicyType = (pPolicyEntry != NULL)? pPolicyEntry->GetType() : "Unknown";

	cmp	DWORD PTR _pPolicyEntry$221921[ebp], 0
	je	SHORT $LN4@LogPolicyC
	mov	ecx, DWORD PTR _pPolicyEntry$221921[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN5@LogPolicyC
$LN4@LogPolicyC:
	mov	DWORD PTR tv175[ebp], OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
$LN5@LogPolicyC:
	mov	ecx, DWORD PTR tv175[ebp]
	mov	DWORD PTR _szPolicyType$221922[ebp], ecx

; 984  : 		strTemp.Format("CHOSEN, %s", szPolicyType);

	mov	edx, DWORD PTR _szPolicyType$221922[ebp]
	push	edx
	push	OFFSET ??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@
	lea	eax, DWORD PTR _strTemp$221915[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 985  : 
; 986  : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$221915[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$221914[ebp]
	push	edx
	lea	eax, DWORD PTR $T224489[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR $T224543[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T224543[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$221913[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224489[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 987  : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$221913[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224547[ebp], eax
	mov	edx, DWORD PTR $T224547[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$221918[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$221918[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 988  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strDesc$221917[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$221916[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$221915[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$221914[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$221913[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogPolicyC:

; 989  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$221913[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$221914[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$221915[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$221916[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$221917[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$5:
	lea	ecx, DWORD PTR $T224485[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$6:
	lea	ecx, DWORD PTR $T224486[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z$7:
	lea	ecx, DWORD PTR $T224489[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPolicyChoice@CvPolicyAI@@AAEXW4PolicyTypes@@@Z ENDP	; CvPolicyAI::LogPolicyChoice
PUBLIC	??_C@_0BC@GOMKNKMF@CHOSEN?0?5Branch?5?$CFd?$AA@	; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0BC@GOMKNKMF@CHOSEN?0?5Branch?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BC@GOMKNKMF@CHOSEN?0?5Branch?5?$CFd?$AA@ DB 'CHOSEN, Branch %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
tv228 = -292						; size = 4
tv198 = -288						; size = 4
tv239 = -284						; size = 4
tv250 = -280						; size = 4
tv95 = -276						; size = 4
_this$ = -272						; size = 4
$T224634 = -268						; size = 4
$T224630 = -264						; size = 4
$T224626 = -260						; size = 4
$T224618 = -256						; size = 4
$T224617 = -252						; size = 4
$T224613 = -248						; size = 4
$T224579 = -244						; size = 28
$T224578 = -216						; size = 28
$T224577 = -188						; size = 28
_strOutBuf$221930 = -160				; size = 28
_playerName$221933 = -132				; size = 28
_strDesc$221934 = -104					; size = 28
_pLog$221935 = -76					; size = 4
_strTemp$221932 = -72					; size = 28
_strBaseString$221931 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eBranch$ = 8						; size = 4
?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z PROC ; CvPolicyAI::LogBranchChoice, COMDAT
; _this$ = ecx

; 993  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 994  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogBranchC
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogBranchC

; 995  : 	{
; 996  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$221930[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 997  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$221931[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 998  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$221932[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 999  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$221933[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1000 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$221934[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1001 : 
; 1002 : 		// Find the name of this civ and city
; 1003 : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T224613[ebp], eax
	cmp	DWORD PTR $T224613[ebp], 0
	je	SHORT $LN28@LogBranchC
	mov	eax, DWORD PTR $T224613[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$221933[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@LogBranchC
$LN28@LogBranchC:
	lea	ecx, DWORD PTR _playerName$221933[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@LogBranchC:

; 1004 : 
; 1005 : 		FILogFile* pLog;
; 1006 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv95[ebp], eax
	lea	ecx, DWORD PTR _playerName$221933[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224577[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	DWORD PTR tv250[ebp], eax
	mov	eax, DWORD PTR tv250[ebp]
	mov	DWORD PTR $T224617[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T224617[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224618[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T224618[ebp]
	push	ecx
	mov	edx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$221935[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224577[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1007 : 
; 1008 : 		// Get the leading info for this line
; 1009 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224626[ebp], eax
	mov	ecx, DWORD PTR $T224626[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$221931[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1010 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$221933[ebp]
	push	edx
	lea	eax, DWORD PTR $T224578[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR tv198[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv198[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$221931[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224578[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1011 : 
; 1012 : 		strTemp.Format("CHOSEN, Branch %d", eBranch);

	mov	eax, DWORD PTR _eBranch$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@GOMKNKMF@CHOSEN?0?5Branch?5?$CFd?$AA@
	lea	ecx, DWORD PTR _strTemp$221932[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1013 : 
; 1014 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$221932[ebp]
	push	edx
	lea	eax, DWORD PTR _strBaseString$221931[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224579[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv228[ebp], eax
	mov	edx, DWORD PTR tv228[ebp]
	mov	DWORD PTR $T224630[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T224630[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$221930[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T224579[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1015 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$221930[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224634[ebp], eax
	mov	eax, DWORD PTR $T224634[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$221935[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$221935[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8

; 1016 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strDesc$221934[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$221933[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$221932[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$221931[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$221930[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogBranchC:

; 1017 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$221930[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$221931[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$221932[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$221933[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$221934[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$5:
	lea	ecx, DWORD PTR $T224577[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$6:
	lea	ecx, DWORD PTR $T224578[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z$7:
	lea	ecx, DWORD PTR $T224579[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogBranchChoice@CvPolicyAI@@AAEXW4PolicyBranchTypes@@@Z ENDP ; CvPolicyAI::LogBranchChoice
PUBLIC	??_C@_0CK@JDFIMOMA@?$CFs?0?5Freedom?3?5?$CFd?0?5Order?3?5?$CFd?0?5Auto@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0CK@JDFIMOMA@?$CFs?0?5Freedom?3?5?$CFd?0?5Order?3?5?$CFd?0?5Auto@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CK@JDFIMOMA@?$CFs?0?5Freedom?3?5?$CFd?0?5Order?3?5?$CFd?0?5Auto@ DB '%'
	DB	's, Freedom: %d, Order: %d, Autocracy: %d', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
_TEXT	SEGMENT
tv222 = -264						; size = 4
tv203 = -260						; size = 4
tv233 = -256						; size = 4
tv244 = -252						; size = 4
tv92 = -248						; size = 4
_this$ = -244						; size = 4
$T224716 = -240						; size = 4
$T224712 = -236						; size = 4
$T224708 = -232						; size = 4
$T224700 = -228						; size = 4
$T224699 = -224						; size = 4
$T224695 = -220						; size = 4
$T224666 = -216						; size = 28
$T224665 = -188						; size = 28
$T224664 = -160						; size = 28
_strOutBuf$221948 = -132				; size = 28
_playerName$221951 = -104				; size = 28
_pLog$221952 = -76					; size = 4
_strTemp$221950 = -72					; size = 28
_strBaseString$221949 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_decisionState$ = 8					; size = 4
_iWeightFreedom$ = 12					; size = 4
_iWeightAutocracy$ = 16					; size = 4
_iWeightOrder$ = 20					; size = 4
?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z PROC ; CvPolicyAI::LogIdeologyChoice, COMDAT
; _this$ = ecx

; 1021 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1022 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogIdeolog
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogIdeolog

; 1023 : 	{
; 1024 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$221948[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1025 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$221949[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1026 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$221950[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1027 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$221951[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1028 : 
; 1029 : 		// Find the name of this civ
; 1030 : 		playerName = m_pCurrentPolicies->GetPlayer()->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T224695[ebp], eax
	cmp	DWORD PTR $T224695[ebp], 0
	je	SHORT $LN24@LogIdeolog
	mov	eax, DWORD PTR $T224695[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$221951[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@LogIdeolog
$LN24@LogIdeolog:
	lea	ecx, DWORD PTR _playerName$221951[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@LogIdeolog:

; 1031 : 
; 1032 : 		FILogFile* pLog;
; 1033 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv92[ebp], eax
	lea	ecx, DWORD PTR _playerName$221951[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224664[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ; CvPolicyAI::GetLogFileName
	mov	DWORD PTR tv244[ebp], eax
	mov	eax, DWORD PTR tv244[ebp]
	mov	DWORD PTR $T224699[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T224699[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224700[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T224700[ebp]
	push	ecx
	mov	edx, DWORD PTR tv92[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv92[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$221952[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T224664[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1034 : 
; 1035 : 		// Get the leading info for this line
; 1036 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T224708[ebp], eax
	mov	ecx, DWORD PTR $T224708[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$221949[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 1037 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$221951[ebp]
	push	edx
	lea	eax, DWORD PTR $T224665[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv233[ebp], eax
	mov	ecx, DWORD PTR tv233[ebp]
	mov	DWORD PTR tv203[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv203[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$221949[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T224665[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1038 : 
; 1039 : 		strTemp.Format("%s, Freedom: %d, Order: %d, Autocracy: %d", decisionState.c_str(), iWeightFreedom, iWeightOrder, iWeightAutocracy);

	mov	eax, DWORD PTR _iWeightAutocracy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iWeightOrder$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iWeightFreedom$[ebp]
	push	edx
	mov	ecx, DWORD PTR _decisionState$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0CK@JDFIMOMA@?$CFs?0?5Freedom?3?5?$CFd?0?5Order?3?5?$CFd?0?5Auto@
	lea	eax, DWORD PTR _strTemp$221950[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1040 : 
; 1041 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$221950[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$221949[ebp]
	push	edx
	lea	eax, DWORD PTR $T224666[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv222[ebp], eax
	mov	ecx, DWORD PTR tv222[ebp]
	mov	DWORD PTR $T224712[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T224712[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$221948[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T224666[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1042 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$221948[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T224716[ebp], eax
	mov	edx, DWORD PTR $T224716[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$221952[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$221952[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 1043 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$221951[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$221950[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$221949[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$221948[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogIdeolog:

; 1044 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$221948[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$1:
	lea	ecx, DWORD PTR _strBaseString$221949[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$2:
	lea	ecx, DWORD PTR _strTemp$221950[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$3:
	lea	ecx, DWORD PTR _playerName$221951[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$4:
	lea	ecx, DWORD PTR $T224664[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$5:
	lea	ecx, DWORD PTR $T224665[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z$6:
	lea	ecx, DWORD PTR $T224666[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogIdeologyChoice@CvPolicyAI@@AAEXAAVCvString@@HHH@Z ENDP ; CvPolicyAI::LogIdeologyChoice
PUBLIC	??_C@_0BA@FFICCKPD@PolicyAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0N@EGNMIKKA@PolicyAILog_?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT ??_C@_0BA@FFICCKPD@PolicyAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BA@FFICCKPD@PolicyAILog?4csv?$AA@ DB 'PolicyAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EGNMIKKA@PolicyAILog_?$AA@
CONST	SEGMENT
??_C@_0N@EGNMIKKA@PolicyAILog_?$AA@ DB 'PolicyAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
tv142 = -124						; size = 4
tv129 = -120						; size = 4
tv169 = -116						; size = 4
_this$ = -112						; size = 4
$T224757 = -108						; size = 4
$T224748 = -104						; size = 4
$T224743 = -100						; size = 28
$T224742 = -72						; size = 28
_strLogName$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z PROC ; CvPolicyAI::GetLogFileName, COMDAT
; _this$ = ecx

; 1048 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T224748[ebp], 0

; 1049 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1050 : 
; 1051 : 	// Open the log file
; 1052 : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetLogFile

; 1053 : 	{
; 1054 : 		strLogName = "PolicyAILog_" + playerName + ".csv";

	mov	ecx, DWORD PTR _playerName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@EGNMIKKA@PolicyAILog_?$AA@
	lea	edx, DWORD PTR $T224742[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	ecx, DWORD PTR tv129[ebp]
	push	ecx
	lea	edx, DWORD PTR $T224743[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv142[ebp], eax
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T224757[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T224757[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T224743[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T224742[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1055 : 	}
; 1056 : 	else

	jmp	SHORT $LN1@GetLogFile
$LN2@GetLogFile:

; 1057 : 	{
; 1058 : 		strLogName = "PolicyAILog.csv";

	mov	ecx, OFFSET ??_C@_0BA@FFICCKPD@PolicyAILog?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN16@GetLogFile
	push	OFFSET ??_C@_0BA@FFICCKPD@PolicyAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@GetLogFile
$LN16@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@GetLogFile:

; 1059 : 	}
; 1060 : 
; 1061 : 	return strLogName;

	lea	edx, DWORD PTR _strLogName$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T224748[ebp]
	or	eax, 1
	mov	DWORD PTR $T224748[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1062 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$0:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T224742[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T224743[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z$3:
	mov	eax, DWORD PTR $T224748[ebp]
	and	eax, 1
	je	$LN9@GetLogFile
	and	DWORD PTR $T224748[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN9@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvPolicyAI@@ABE?AVCvString@@AAV2@@Z ENDP ; CvPolicyAI::GetLogFileName
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ PROC		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@H$0EA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,64,1>::~CvWeightedVector<int,64,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T224834 = -28						; size = 4
$T224821 = -24						; size = 4
$T224817 = -20						; size = 4
$T224812 = -16						; size = 4
_iChoice$ = -12						; size = 4
_elem$ = -8						; size = 8
_rndFcn$ = 8						; size = 4
_szRollName$ = 12					; size = 4
?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<int,64,1>::ChooseAtRandom, COMDAT
; _this$ = ecx

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 186  : 		int iChoice;
; 187  : 
; 188  : 		// Based on the number of elements we have, pick one at random
; 189  : 		iChoice = (*rndFcn)(m_pItems.size(), szRollName);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224812[ebp], ecx
	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224817[ebp], eax
	mov	ecx, DWORD PTR _rndFcn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T224821[ebp], edx
	mov	eax, DWORD PTR _szRollName$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224812[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T224821[ebp]
	call	DWORD PTR $T224817[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 190  : 		WeightedElement elem = m_pItems[iChoice];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iChoice$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T224834[ebp], edx
	mov	eax, DWORD PTR $T224834[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _elem$[ebp], ecx
	mov	edx, DWORD PTR $T224834[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _elem$[ebp+4], eax

; 191  : 
; 192  : 		return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]

; 193  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?ChooseAtRandom@?$CvWeightedVector@H$0EA@$00@@QAEHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<int,64,1>::ChooseAtRandom
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T224859 = -36						; size = 4
$T224855 = -32						; size = 4
$T224844 = -28						; size = 4
$T224840 = -24						; size = 4
_iTotalTopChoicesWeight$ = -20				; size = 4
_iChoice$ = -16						; size = 4
_i$ = -12						; size = 4
_elem$ = -8						; size = 8
_iNumChoices$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<int,64,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224840[ebp], ecx
	mov	edx, DWORD PTR _iNumChoices$[ebp]
	cmp	edx, DWORD PTR $T224840[ebp]
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224844[ebp], ecx
	mov	edx, DWORD PTR $T224844[ebp]
	mov	DWORD PTR _iNumChoices$[ebp], edx
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	mov	DWORD PTR _elem$[ebp], 0
	mov	DWORD PTR _elem$[ebp+4], 0

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], 0

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ChooseFrom
$LN6@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ChooseFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN5@ChooseFrom

; 237  : 		{
; 238  : 			elem = m_pItems[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[ebp], edx
	mov	DWORD PTR _elem$[ebp+4], eax

; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	add	ecx, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], ecx

; 240  : 		}

	jmp	SHORT $LN6@ChooseFrom
$LN5@ChooseFrom:

; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T224855[ebp], eax
	mov	ecx, DWORD PTR _rndFcn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T224859[ebp], edx
	mov	eax, DWORD PTR _szRollName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T224859[ebp]
	call	DWORD PTR $T224855[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ChooseFrom
$LN3@ChooseFrom:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN2@ChooseFrom

; 247  : 		{
; 248  : 			elem = m_pItems[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$[ebp], ecx
	mov	DWORD PTR _elem$[ebp+4], edx

; 249  : 			iChoice -= elem.m_iWeight;

	mov	eax, DWORD PTR _iChoice$[ebp]
	sub	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iChoice$[ebp], eax

; 250  : 			if (iChoice < 0)

	jns	SHORT $LN1@ChooseFrom

; 251  : 			{
; 252  : 				return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
	jmp	SHORT $LN9@ChooseFrom
$LN1@ChooseFrom:

; 253  : 			}
; 254  : 		}

	jmp	SHORT $LN3@ChooseFrom
$LN2@ChooseFrom:

; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
$LN9@ChooseFrom:

; 260  : 	};

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseFromTopChoices@?$CvWeightedVector@H$0EA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<int,64,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T224881 = -20						; size = 4
_pRet$224878 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T224881[ebp], edx
	cmp	DWORD PTR $T224881[ebp], 64		; 00000040H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T224881[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$224878[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T224881[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$224878[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 64			; 00000040H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$224878[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T224912 = -24						; size = 4
$T224911 = -20						; size = 4
_i$224904 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224912[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T224911[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$224904[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$224904[ebp]
	add	eax, 1
	mov	DWORD PTR _i$224904[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$224904[ebp]
	cmp	ecx, DWORD PTR $T224912[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T224911[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T224911[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::~FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T224925 = -8						; size = 4
$T224924 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+524], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T224925[ebp], ecx
	cmp	DWORD PTR $T224925[ebp], 0
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR $T224925[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T224925[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T224925[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T224924[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::push_back
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T225019 = -44						; size = 4
$T225018 = -40						; size = 4
_i$225011 = -36						; size = 4
$T224997 = -32						; size = 4
$T224990 = -28						; size = 4
_pRet$224987 = -24					; size = 4
$T224980 = -20						; size = 4
$T224979 = -16						; size = 4
_i$222093 = -12						; size = 4
_uiNewSize$222085 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$222085[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$222085[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$222085[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224990[ebp], ecx
	cmp	DWORD PTR $T224990[ebp], 64		; 00000040H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T224990[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$224987[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T224990[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$224987[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 64			; 00000040H
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$224987[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$222093[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$222093[ebp]
	add	edx, 1
	mov	DWORD PTR _i$222093[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$222093[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$222093[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T224980[ebp], ecx
	cmp	DWORD PTR $T224980[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$222093[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T224997[ebp], edx
	mov	eax, DWORD PTR $T224980[ebp]
	mov	ecx, DWORD PTR $T224997[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T224980[ebp]
	mov	ecx, DWORD PTR $T224997[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T224980[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T224979[ebp], ecx
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T225019[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T225018[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize
	mov	DWORD PTR _i$225011[ebp], 0
	jmp	SHORT $LN29@GrowSize
$LN28@GrowSize:
	mov	edx, DWORD PTR _i$225011[ebp]
	add	edx, 1
	mov	DWORD PTR _i$225011[ebp], edx
$LN29@GrowSize:
	mov	eax, DWORD PTR _i$225011[ebp]
	cmp	eax, DWORD PTR $T225019[ebp]
	jae	SHORT $LN24@GrowSize
	jmp	SHORT $LN28@GrowSize
$LN24@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T225018[ebp], ecx
	je	SHORT $LN25@GrowSize
	mov	edx, DWORD PTR $T225018[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+524], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$0EA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,64,1>::WeightedElement,64,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0EA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,64,1>::WeightedElement,1>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2030 : FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 

	push	ebp
	mov	ebp, esp

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2032 : }

	pop	ebp
	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z
_TEXT	SEGMENT
$T225183 = -128						; size = 4
__Mid$222214 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$222214[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$222214[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$222214[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$222214[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$222214[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$222214[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$222214[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T225183[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T225183[ebp]
	sub	eax, 8
	mov	DWORD PTR $T225183[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T225183[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T225183[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T225183[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,64,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z
_TEXT	SEGMENT
$T225426 = -124						; size = 4
__Tmp$225424 = -120					; size = 8
$T225406 = -112						; size = 4
$T225405 = -108						; size = 4
__Tmp$225403 = -104					; size = 8
$T225385 = -96						; size = 4
__Tmp$225383 = -92					; size = 8
$T225365 = -84						; size = 4
$T225364 = -80						; size = 4
__Tmp$225362 = -76					; size = 8
$T225344 = -68						; size = 4
$T225343 = -64						; size = 4
__Tmp$225341 = -60					; size = 8
$T225320 = -52						; size = 4
$T225319 = -48						; size = 4
__Tmp$225317 = -44					; size = 8
$T225293 = -36						; size = 4
__Tmp$225286 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T225293[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T225293[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T225293[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225286[ebp], edx
	mov	eax, DWORD PTR $T225293[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$225286[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T225293[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$225286[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$225286[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T225320[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225319[ebp], edx
	mov	eax, DWORD PTR $T225319[ebp]
	cmp	eax, DWORD PTR $T225320[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T225319[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225317[ebp], edx
	mov	eax, DWORD PTR $T225319[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$225317[ebp+4], ecx
	mov	edx, DWORD PTR $T225320[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T225319[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T225320[ebp]
	mov	ecx, DWORD PTR __Tmp$225317[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$225317[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T225344[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225343[ebp], eax
	mov	ecx, DWORD PTR $T225343[ebp]
	cmp	ecx, DWORD PTR $T225344[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T225343[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225341[ebp], eax
	mov	ecx, DWORD PTR $T225343[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225341[ebp+4], edx
	mov	eax, DWORD PTR $T225344[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T225343[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T225344[ebp]
	mov	edx, DWORD PTR __Tmp$225341[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$225341[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T225365[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225364[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T225364[ebp]
	cmp	eax, DWORD PTR $T225365[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T225364[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225362[ebp], edx
	mov	eax, DWORD PTR $T225364[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$225362[ebp+4], ecx
	mov	edx, DWORD PTR $T225365[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T225364[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T225365[ebp]
	mov	ecx, DWORD PTR __Tmp$225362[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$225362[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225385[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T225385[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$225383[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$225383[ebp+4], eax
	mov	ecx, DWORD PTR $T225385[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T225385[ebp]
	mov	eax, DWORD PTR __Tmp$225383[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$225383[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T225406[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225405[ebp], ecx
	mov	edx, DWORD PTR $T225405[ebp]
	cmp	edx, DWORD PTR $T225406[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T225405[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$225403[ebp], ecx
	mov	edx, DWORD PTR $T225405[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$225403[ebp+4], eax
	mov	ecx, DWORD PTR $T225406[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T225405[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T225406[ebp]
	mov	eax, DWORD PTR __Tmp$225403[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$225403[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T225426[ebp], eax
	mov	ecx, DWORD PTR $T225426[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T225426[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225424[ebp], eax
	mov	ecx, DWORD PTR $T225426[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225424[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T225426[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$225424[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$225424[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__Step$222371 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$222371[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$222371[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$222371[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$222371[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$222371[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$222371[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$222371[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$222371[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$222371[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,64,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z
_TEXT	SEGMENT
$T225739 = -20						; size = 4
$T225738 = -16						; size = 4
__Hole$222389 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$222389[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$222389[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$222389[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$222389[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$222389[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T225739[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T225738[ebp], esp
	mov	edx, DWORD PTR $T225738[ebp]
	mov	eax, DWORD PTR $T225739[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T225738[ebp]
	mov	eax, DWORD PTR $T225739[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$222389[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
$T225809 = -52						; size = 4
$T225808 = -48						; size = 4
$T225792 = -42						; size = 1
$T225791 = -41						; size = 1
$T225790 = -40						; size = 4
$T225789 = -36						; size = 4
$T225788 = -32						; size = 4
__Cat$225799 = -24					; size = 1
$T225797 = -23						; size = 1
$T225796 = -22						; size = 1
$T225795 = -21						; size = 1
__First1$222430 = -20					; size = 4
__Val$222420 = -16					; size = 8
__Next1$222419 = -8					; size = 4
__Next$222415 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$222415[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$222415[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$222415[ebp], edx
	mov	eax, DWORD PTR __Next$222415[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$222415[ebp]
	mov	DWORD PTR __Next1$222419[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$222415[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$222420[ebp], eax
	mov	ecx, DWORD PTR __Next$222415[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$222420[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$222420[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$222419[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$222419[ebp], ecx
	mov	edx, DWORD PTR __Next1$222419[ebp]
	mov	DWORD PTR $T225809[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225808[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T225795[ebp], cl
	mov	dl, BYTE PTR __Cat$225799[ebp]
	mov	BYTE PTR $T225796[ebp], dl
	mov	al, BYTE PTR $T225795[ebp]
	mov	BYTE PTR $T225792[ebp], al
	mov	cl, BYTE PTR $T225797[ebp]
	mov	BYTE PTR $T225791[ebp], cl
	mov	edx, DWORD PTR $T225809[ebp]
	mov	DWORD PTR $T225790[ebp], edx
	mov	eax, DWORD PTR __Next$222415[ebp]
	mov	DWORD PTR $T225789[ebp], eax
	mov	ecx, DWORD PTR $T225808[ebp]
	mov	DWORD PTR $T225788[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T225788[ebp]
	cmp	edx, DWORD PTR $T225789[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T225789[ebp]
	sub	eax, 8
	mov	DWORD PTR $T225789[ebp], eax
	mov	ecx, DWORD PTR $T225790[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T225790[ebp], ecx
	mov	edx, DWORD PTR $T225789[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T225790[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$222420[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$222420[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$222419[ebp]
	mov	DWORD PTR __First1$222430[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$222430[ebp]
	mov	DWORD PTR __Next1$222419[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$222430[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$222430[ebp], edx
	mov	eax, DWORD PTR __First1$222430[ebp]
	mov	ecx, DWORD PTR __Val$222420[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$222430[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$222419[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$222419[ebp]
	mov	eax, DWORD PTR __Val$222420[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$222420[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
__Tmp$225877 = -24					; size = 8
__Tmp$225855 = -16					; size = 8
__Tmp$225833 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$225833[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$225833[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$225833[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$225833[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225855[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225855[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$225855[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$225855[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225877[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$225877[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$225877[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$225877[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,64,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z
_TEXT	SEGMENT
$T225904 = -32						; size = 4
$T225903 = -28						; size = 8
__Idx$225896 = -20					; size = 4
$T225890 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T225903[ebp]
	mov	DWORD PTR $T225890[ebp], edx
	mov	eax, DWORD PTR $T225890[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T225890[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T225904[ebp], ecx
	mov	eax, DWORD PTR $T225904[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$225896[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T225904[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$225896[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T225904[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$225896[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T225903[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$225896[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T225904[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$225896[ebp]
	mov	DWORD PTR $T225904[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T225904[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T225903[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T225903[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z
_TEXT	SEGMENT
$T225950 = -60						; size = 8
$T225921 = -20						; size = 4
$T225915 = -12						; size = 4
$T225914 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T225915[ebp], eax
	lea	ecx, DWORD PTR $T225950[ebp]
	mov	DWORD PTR $T225914[ebp], ecx
	mov	edx, DWORD PTR $T225914[ebp]
	mov	eax, DWORD PTR $T225915[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T225914[ebp]
	mov	eax, DWORD PTR $T225915[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T225921[ebp], esp
	mov	eax, DWORD PTR $T225921[ebp]
	mov	ecx, DWORD PTR $T225950[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T225921[ebp]
	mov	eax, DWORD PTR $T225950[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,64,1>::WeightedElement *,int,CvWeightedVector<int,64,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0EA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,64,1>::WeightedElement *,CvWeightedVector<int,64,1>::WeightedElement>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T225981 = -2092					; size = 4
$T225980 = -2088					; size = 4
$T225979 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T225979[ebp], eax
	mov	ecx, DWORD PTR $T225979[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T225980[ebp], eax
	mov	eax, DWORD PTR $T225980[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T225981[ebp], eax
	mov	ecx, DWORD PTR $T225981[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T226013 = -30						; size = 1
$T226000 = -29						; size = 1
$T225996 = -28						; size = 4
$T225989 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T226013[ebp]
	mov	DWORD PTR $T225989[ebp], eax
	lea	ecx, DWORD PTR $T226000[ebp]
	mov	DWORD PTR $T225996[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$226138 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$226138[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$226138[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$226138[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T226204 = -28						; size = 4
$T226203 = -24						; size = 4
$T226199 = -20						; size = 4
$T226198 = -16						; size = 4
$T226187 = -12						; size = 4
$T226186 = -8						; size = 4
__Cat$226194 = -2					; size = 1
$T226192 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226199[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226198[ebp], ecx
	mov	edx, DWORD PTR $T226199[ebp]
	mov	DWORD PTR $T226187[ebp], edx
	mov	eax, DWORD PTR $T226198[ebp]
	mov	DWORD PTR $T226186[ebp], eax
	mov	cl, BYTE PTR __Cat$226194[ebp]
	mov	BYTE PTR $T226192[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T226204[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226203[ebp], eax
	mov	ecx, DWORD PTR $T226203[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T226208 = -80						; size = 28
$T226207 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T226208[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T226207[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T226207[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T226208[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226207[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T226207[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T226207[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T226208[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T226208[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T226207[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T226279 = -16						; size = 4
$T226275 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T226279[ebp], 0
	lea	eax, DWORD PTR $T226279[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226275[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T226275[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T226275[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T226379 = -64						; size = 4
$T226369 = -60						; size = 4
$T226357 = -56						; size = 4
$T226347 = -49						; size = 1
$T226346 = -48						; size = 4
__Cat$226364 = -19					; size = 1
$T226361 = -18						; size = 1
$T226360 = -17						; size = 1
$T226298 = -16						; size = 4
$T226294 = -12						; size = 4
$T226293 = -8						; size = 4
$T226292 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T226298[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@2
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@2:
	mov	ecx, DWORD PTR $T226298[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T226369[ebp], eax
	mov	ecx, DWORD PTR $T226369[ebp]
	mov	DWORD PTR $T226357[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T226360[ebp], dl
	mov	al, BYTE PTR __Cat$226364[ebp]
	mov	BYTE PTR $T226361[ebp], al
	mov	cl, BYTE PTR $T226360[ebp]
	mov	BYTE PTR $T226347[ebp], cl
	mov	edx, DWORD PTR $T226357[ebp]
	mov	DWORD PTR $T226346[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T226346[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T226369[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226379[ebp], edx
	mov	eax, DWORD PTR $T226379[ebp]
	mov	DWORD PTR $T226293[ebp], eax
	mov	ecx, DWORD PTR $T226293[ebp]
	mov	DWORD PTR $T226292[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T226292[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226294[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back@2:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$226504 = -24					; size = 4
$T226482 = -20						; size = 4
$T226463 = -16						; size = 4
$T226450 = -12						; size = 4
$T226447 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226463[ebp], ecx
	mov	edx, DWORD PTR $T226463[ebp]
	mov	DWORD PTR $T226447[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T226447[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226482[ebp], edx
	mov	eax, DWORD PTR $T226482[ebp]
	mov	DWORD PTR $T226450[ebp], eax
	mov	ecx, DWORD PTR $T226450[ebp]
	mov	DWORD PTR __Tmp$226504[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$226504[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$226504[ebp], ecx
	mov	edx, DWORD PTR __Tmp$226504[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T227058 = -412						; size = 4
$T227006 = -368						; size = 4
$T226994 = -364						; size = 4
$T226984 = -357						; size = 1
$T226983 = -356						; size = 4
__Cat$227002 = -327					; size = 1
$T226999 = -326						; size = 1
$T226998 = -325						; size = 1
$T226955 = -324						; size = 4
$T226947 = -320						; size = 4
$T226939 = -316						; size = 4
$T226928 = -312						; size = 4
$T226927 = -308						; size = 4
__Cat$226934 = -302					; size = 1
$T226932 = -301						; size = 1
$T226856 = -276						; size = 4
$T226837 = -272						; size = 4
$T226820 = -265						; size = 1
$T226819 = -264						; size = 4
$T226809 = -260						; size = 4
$T226808 = -256						; size = 4
__Cat$226853 = -250					; size = 1
$T226851 = -249						; size = 1
$T226850 = -248						; size = 1
__Cat$226845 = -247					; size = 1
$T226842 = -246						; size = 1
$T226841 = -245						; size = 1
$T226784 = -244						; size = 4
$T226783 = -240						; size = 4
$T226779 = -236						; size = 4
$T226778 = -232						; size = 4
$T226767 = -228						; size = 4
$T226766 = -224						; size = 4
__Cat$226773 = -218					; size = 1
$T226771 = -217						; size = 1
$T226731 = -216						; size = 4
$T226730 = -212						; size = 4
__Cat$226737 = -206					; size = 1
$T226735 = -205						; size = 1
$T226701 = -204						; size = 4
$T226700 = -200						; size = 4
__Cat$226707 = -194					; size = 1
$T226705 = -193						; size = 1
$T226681 = -192						; size = 4
$T226669 = -188						; size = 4
$T226659 = -181						; size = 1
$T226658 = -180						; size = 4
__Cat$226676 = -175					; size = 1
$T226673 = -174						; size = 1
$T226672 = -173						; size = 1
$T226646 = -172						; size = 4
$T226634 = -168						; size = 4
$T226624 = -161						; size = 1
$T226623 = -160						; size = 4
__Cat$226641 = -155					; size = 1
$T226638 = -154						; size = 1
$T226637 = -153						; size = 1
$T226611 = -152						; size = 4
$T226599 = -148						; size = 4
$T226589 = -141						; size = 1
$T226588 = -140						; size = 4
__Cat$226605 = -135					; size = 1
$T226603 = -134						; size = 1
$T226602 = -133						; size = 1
__Count$226565 = -120					; size = 4
__Count$226539 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$226539[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$226539[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$226539[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$226565[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$226565[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$226565[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T226611[ebp], edx
	mov	eax, DWORD PTR $T226611[ebp]
	mov	DWORD PTR $T226599[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226602[ebp], cl
	mov	dl, BYTE PTR __Cat$226605[ebp]
	mov	BYTE PTR $T226603[ebp], dl
	mov	al, BYTE PTR $T226602[ebp]
	mov	BYTE PTR $T226589[ebp], al
	mov	ecx, DWORD PTR $T226599[ebp]
	mov	DWORD PTR $T226588[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226588[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226646[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T226634[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T226637[ebp], al
	mov	cl, BYTE PTR __Cat$226641[ebp]
	mov	BYTE PTR $T226638[ebp], cl
	mov	dl, BYTE PTR $T226637[ebp]
	mov	BYTE PTR $T226624[ebp], dl
	mov	eax, DWORD PTR $T226634[ebp]
	mov	DWORD PTR $T226623[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226623[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226646[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T226681[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T226669[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T226672[ebp], dl
	mov	al, BYTE PTR __Cat$226676[ebp]
	mov	BYTE PTR $T226673[ebp], al
	mov	cl, BYTE PTR $T226672[ebp]
	mov	BYTE PTR $T226659[ebp], cl
	mov	edx, DWORD PTR $T226669[ebp]
	mov	DWORD PTR $T226658[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226658[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226681[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T226701[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T226700[ebp], ecx
	mov	dl, BYTE PTR __Cat$226707[ebp]
	mov	BYTE PTR $T226705[ebp], dl
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T226731[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T226730[ebp], ecx
	mov	dl, BYTE PTR __Cat$226737[ebp]
	mov	BYTE PTR $T226735[ebp], dl
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T226779[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226778[ebp], edx
	mov	eax, DWORD PTR $T226779[ebp]
	mov	DWORD PTR $T226767[ebp], eax
	mov	ecx, DWORD PTR $T226778[ebp]
	mov	DWORD PTR $T226766[ebp], ecx
	mov	dl, BYTE PTR __Cat$226773[ebp]
	mov	BYTE PTR $T226771[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T226784[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226783[ebp], ecx
	mov	edx, DWORD PTR $T226783[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T226856[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T226837[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226841[ebp], cl
	mov	dl, BYTE PTR __Cat$226845[ebp]
	mov	BYTE PTR $T226842[ebp], dl
	mov	al, BYTE PTR $T226841[ebp]
	mov	BYTE PTR $T226820[ebp], al
	mov	ecx, DWORD PTR $T226837[ebp]
	mov	DWORD PTR $T226819[ebp], ecx
	mov	edx, DWORD PTR $T226819[ebp]
	mov	DWORD PTR $T226809[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T226808[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226850[ebp], cl
	mov	dl, BYTE PTR __Cat$226853[ebp]
	mov	BYTE PTR $T226851[ebp], dl
	movzx	eax, BYTE PTR $T226850[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T226851[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T226809[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226856[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226808[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T226939[ebp], eax
	mov	ecx, DWORD PTR $T226939[ebp]
	mov	DWORD PTR $T226928[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T226927[ebp], ecx
	mov	dl, BYTE PTR __Cat$226934[ebp]
	mov	BYTE PTR $T226932[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T226955[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T226947[ebp], edx
	jmp	SHORT $LN151@Insert_n
$LN150@Insert_n:
	mov	eax, DWORD PTR $T226947[ebp]
	add	eax, 4
	mov	DWORD PTR $T226947[ebp], eax
$LN151@Insert_n:
	mov	ecx, DWORD PTR $T226947[ebp]
	cmp	ecx, DWORD PTR $T226955[ebp]
	je	SHORT $LN147@Insert_n
	mov	edx, DWORD PTR $T226947[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n
$LN147@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T227006[ebp], eax
	mov	ecx, DWORD PTR $T227006[ebp]
	mov	DWORD PTR $T226994[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T226998[ebp], dl
	mov	al, BYTE PTR __Cat$227002[ebp]
	mov	BYTE PTR $T226999[ebp], al
	mov	cl, BYTE PTR $T226998[ebp]
	mov	BYTE PTR $T226984[ebp], cl
	mov	edx, DWORD PTR $T226994[ebp]
	mov	DWORD PTR $T226983[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226983[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T227058[ebp], ecx
	jmp	SHORT $LN186@Insert_n
$LN185@Insert_n:
	mov	edx, DWORD PTR $T227058[ebp]
	add	edx, 4
	mov	DWORD PTR $T227058[ebp], edx
$LN186@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T227058[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR $T227058[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T227129 = -40						; size = 4
$T227119 = -33						; size = 1
$T227118 = -32						; size = 4
__Cat$227125 = -3					; size = 1
$T227123 = -2						; size = 1
$T227122 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T227129[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227122[ebp], cl
	mov	dl, BYTE PTR __Cat$227125[ebp]
	mov	BYTE PTR $T227123[ebp], dl
	mov	al, BYTE PTR $T227122[ebp]
	mov	BYTE PTR $T227119[ebp], al
	mov	ecx, DWORD PTR $T227129[ebp]
	mov	DWORD PTR $T227118[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227118[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T227174 = -38						; size = 1
$T227173 = -37						; size = 1
$T227172 = -36						; size = 4
$T227171 = -32						; size = 4
$T227158 = -25						; size = 1
$T227157 = -24						; size = 4
$T227156 = -20						; size = 4
__Off$227166 = -16					; size = 4
__Result$227167 = -12					; size = 4
__Cat$227163 = -8					; size = 1
$T227161 = -7						; size = 1
$T227160 = -6						; size = 1
__Cat$227138 = -4					; size = 1
$T227134 = -3						; size = 1
$T227133 = -2						; size = 1
$T227132 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T227132[ebp], al
	mov	cl, BYTE PTR __Cat$227138[ebp]
	mov	BYTE PTR $T227133[ebp], cl
	mov	dl, BYTE PTR $T227132[ebp]
	mov	BYTE PTR $T227174[ebp], dl
	mov	al, BYTE PTR $T227134[ebp]
	mov	BYTE PTR $T227173[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227172[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227171[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T227160[ebp], al
	mov	cl, BYTE PTR __Cat$227163[ebp]
	mov	BYTE PTR $T227161[ebp], cl
	mov	dl, BYTE PTR $T227160[ebp]
	mov	BYTE PTR $T227158[ebp], dl
	mov	eax, DWORD PTR $T227172[ebp]
	mov	DWORD PTR $T227157[ebp], eax
	mov	ecx, DWORD PTR $T227171[ebp]
	mov	DWORD PTR $T227156[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T227156[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$227166[ebp], edx
	mov	eax, DWORD PTR __Off$227166[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T227157[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$227167[ebp], ecx
	cmp	DWORD PTR __Off$227166[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$227166[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T227156[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$227166[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$227167[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$227167[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T227204 = -22						; size = 1
$T227203 = -21						; size = 1
$T227202 = -20						; size = 4
$T227193 = -13						; size = 1
$T227192 = -12						; size = 4
$T227191 = -8						; size = 4
$T227196 = -4						; size = 1
$T227178 = -2						; size = 1
$T227177 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T227177[ebp], al
	mov	cl, BYTE PTR $T227177[ebp]
	mov	BYTE PTR $T227204[ebp], cl
	mov	dl, BYTE PTR $T227178[ebp]
	mov	BYTE PTR $T227203[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227202[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227196[ebp], cl
	mov	dl, BYTE PTR $T227196[ebp]
	mov	BYTE PTR $T227193[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T227192[ebp], eax
	mov	ecx, DWORD PTR $T227202[ebp]
	mov	DWORD PTR $T227191[ebp], ecx
	jmp	SHORT $LN9@unchecked_
$LN8@unchecked_:
	mov	edx, DWORD PTR $T227192[ebp]
	sub	edx, 1
	mov	DWORD PTR $T227192[ebp], edx
	mov	eax, DWORD PTR $T227191[ebp]
	add	eax, 4
	mov	DWORD PTR $T227191[ebp], eax
$LN9@unchecked_:
	cmp	DWORD PTR $T227192[ebp], 0
	jbe	SHORT $LN1@unchecked_
	mov	ecx, DWORD PTR $T227191[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_
$LN1@unchecked_:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T227221 = -21						; size = 1
$T227220 = -20						; size = 4
$T227219 = -16						; size = 4
__Result$227216 = -12					; size = 4
__Count$227215 = -8					; size = 4
__Cat$227211 = -3					; size = 1
$T227208 = -2						; size = 1
$T227207 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T227207[ebp], al
	mov	cl, BYTE PTR __Cat$227211[ebp]
	mov	BYTE PTR $T227208[ebp], cl
	mov	dl, BYTE PTR $T227207[ebp]
	mov	BYTE PTR $T227221[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227220[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227219[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T227219[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$227215[ebp], edx
	mov	eax, DWORD PTR __Count$227215[ebp]
	mov	ecx, DWORD PTR $T227220[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$227216[ebp], edx
	cmp	DWORD PTR __Count$227215[ebp], 0
	jbe	SHORT $LN6@unchecked_@2
	mov	eax, DWORD PTR __Count$227215[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T227219[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$227215[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T227220[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@2:
	mov	eax, DWORD PTR __Result$227216[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
END
