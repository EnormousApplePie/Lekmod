; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvArea.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?reset@CvArea@@QAEXH_N0@Z			; CvArea::reset
PUBLIC	??_7CvArea@@6B@					; CvArea::`vftable'
PUBLIC	??0CvArea@@QAE@XZ				; CvArea::CvArea
PUBLIC	?read@CvArea@@UAEXAAVFDataStream@@@Z		; CvArea::read
PUBLIC	?write@CvArea@@UBEXAAVFDataStream@@@Z		; CvArea::write
;	COMDAT ??_7CvArea@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
CONST	SEGMENT
??_7CvArea@@6B@ DD FLAT:?read@CvArea@@UAEXAAVFDataStream@@@Z ; CvArea::`vftable'
	DD	FLAT:?write@CvArea@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvarea.cpp
CONST	ENDS
;	COMDAT ??0CvArea@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T218220 = -12						; size = 4
$T218216 = -8						; size = 4
$T218215 = -4						; size = 4
??0CvArea@@QAE@XZ PROC					; CvArea::CvArea, COMDAT
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvArea@@6B@
	mov	DWORD PTR $T218216[ebp], 80		; 00000050H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1644				; 0000066cH
	mov	DWORD PTR $T218215[ebp], ecx
$LN4@CvArea:
	mov	edx, DWORD PTR $T218216[ebp]
	sub	edx, 1
	mov	DWORD PTR $T218216[ebp], edx
	js	SHORT $LN5@CvArea
	mov	eax, DWORD PTR $T218215[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T218215[ebp]
	mov	DWORD PTR [ecx+4], -1
	mov	edx, DWORD PTR $T218215[ebp]
	add	edx, 8
	mov	DWORD PTR $T218215[ebp], edx
	jmp	SHORT $LN4@CvArea
$LN5@CvArea:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4212				; 00001074H
	mov	DWORD PTR $T218220[ebp], eax
	mov	ecx, DWORD PTR $T218220[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T218220[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T218220[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T218220[ebp]
	mov	DWORD PTR [ecx+12], 0

; 30   : 	m_paiNumResources = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4204], 0

; 31   : 	m_paiNumImprovements = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4208], 0

; 32   : 	reset(0, false, true);

	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvArea@@QAEXH_N0@Z		; CvArea::reset

; 33   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvArea@@QAE@XZ ENDP					; CvArea::CvArea
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?uninit@CvArea@@QAEXXZ				; CvArea::uninit
PUBLIC	??1CvArea@@QAE@XZ				; CvArea::~CvArea
; Function compile flags: /Odtp
;	COMDAT ??1CvArea@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvArea@@QAE@XZ PROC					; CvArea::~CvArea, COMDAT
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvArea@@6B@

; 39   : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvArea@@QAEXXZ			; CvArea::uninit

; 40   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvArea@@QAE@XZ ENDP					; CvArea::~CvArea
_TEXT	ENDS
PUBLIC	?init@CvArea@@QAEXH_N@Z				; CvArea::init
; Function compile flags: /Odtp
;	COMDAT ?init@CvArea@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
_bWater$ = 12						; size = 1
?init@CvArea@@QAEXH_N@Z PROC				; CvArea::init, COMDAT
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	//--------------------------------
; 47   : 	// Init saved data
; 48   : 	reset(iID, bWater);

	push	0
	movzx	eax, BYTE PTR _bWater$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvArea@@QAEXH_N0@Z		; CvArea::reset

; 49   : 
; 50   : 	//--------------------------------
; 51   : 	// Init non-saved data
; 52   : 
; 53   : 	//--------------------------------
; 54   : 	// Init other game data
; 55   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?init@CvArea@@QAEXH_N@Z ENDP				; CvArea::init
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ?uninit@CvArea@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T218240 = -16						; size = 4
$T218238 = -12						; size = 4
$T218234 = -8						; size = 4
$T218232 = -4						; size = 4
?uninit@CvArea@@QAEXXZ PROC				; CvArea::uninit, COMDAT
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 	SAFE_DELETE_ARRAY(m_paiNumResources);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4204				; 0000106cH
	mov	DWORD PTR $T218234[ebp], eax
	mov	ecx, DWORD PTR $T218234[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T218232[ebp], edx
	mov	eax, DWORD PTR $T218232[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T218234[ebp]
	mov	DWORD PTR [ecx], 0

; 62   : 	SAFE_DELETE_ARRAY(m_paiNumImprovements);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4208				; 00001070H
	mov	DWORD PTR $T218240[ebp], edx
	mov	eax, DWORD PTR $T218240[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T218238[ebp], ecx
	mov	edx, DWORD PTR $T218238[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T218240[ebp]
	mov	DWORD PTR [eax], 0

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?uninit@CvArea@@QAEXXZ ENDP				; CvArea::uninit
_TEXT	ENDS
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?reset@CvArea@@QAEXH_N0@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T218248 = -28						; size = 4
$T218244 = -24						; size = 4
$T218243 = -20						; size = 4
_numRIs$217551 = -16					; size = 4
_numIIs$217557 = -12					; size = 4
_iJ$ = -8						; size = 4
_iI$ = -4						; size = 4
_iID$ = 8						; size = 4
_bWater$ = 12						; size = 1
_bConstructorCall$ = 16					; size = 1
?reset@CvArea@@QAEXH_N0@Z PROC				; CvArea::reset, COMDAT
; _this$ = ecx

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 	int iI, iJ;
; 72   : 
; 73   : 	//--------------------------------
; 74   : 	// Uninit class
; 75   : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvArea@@QAEXXZ			; CvArea::uninit

; 76   : 
; 77   : 	m_iID = iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 78   : 	m_iNumTiles = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 79   : 	m_iNumOwnedTiles = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 80   : 	m_iNumRiverEdges = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 81   : 	m_iNumUnits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 82   : 	m_iNumCities = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 83   : 	m_iTotalPopulation = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 84   : 	m_iNumStartingPlots = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 85   : 	m_iNumNaturalWonders = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 86   : 	m_iTotalFoundValue = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 87   : 	m_Boundaries.m_iNorthEdge = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4212], 0

; 88   : 	m_Boundaries.m_iSouthEdge = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4216], 0

; 89   : 	m_Boundaries.m_iEastEdge = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4220], 0

; 90   : 	m_Boundaries.m_iWestEdge = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4224], 0

; 91   : 
; 92   : 	m_bWater = bWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bWater$[ebp]
	mov	BYTE PTR [eax+4228], cl

; 93   : 	m_bMountains = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4229], 0

; 94   : 
; 95   : 	for(iI = 0; iI < REALLY_MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN22@reset
$LN21@reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN22@reset:
	cmp	DWORD PTR _iI$[ebp], 80			; 00000050H
	jge	SHORT $LN20@reset

; 96   : 	{
; 97   : 		m_aiUnitsPerPlayer[iI] = 0;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+44], 0

; 98   : 		m_aiCitiesPerPlayer[iI] = 0;

	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+364], 0

; 99   : 		m_aiPopulationPerPlayer[iI] = 0;

	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+684], 0

; 100  : 		m_aiFreeSpecialist[iI] = 0;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+1004], 0

; 101  : 	}

	jmp	SHORT $LN21@reset
$LN20@reset:

; 102  : 
; 103  : 	for(iI = 0; iI < REALLY_MAX_TEAMS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN19@reset
$LN18@reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN19@reset:
	cmp	DWORD PTR _iI$[ebp], 80			; 00000050H
	jge	SHORT $LN17@reset

; 104  : 	{
; 105  : 		m_aiNumRevealedTiles[iI] = 0;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+1324], 0

; 106  : 	}

	jmp	SHORT $LN18@reset
$LN17@reset:

; 107  : 
; 108  : 	for(iI = 0; iI < REALLY_MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN16@reset
$LN15@reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN16@reset:
	cmp	DWORD PTR _iI$[ebp], 80			; 00000050H
	jge	SHORT $LN14@reset

; 109  : 	{
; 110  : 		m_aTargetCities[iI].reset();

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+1644]
	mov	DWORD PTR $T218248[ebp], eax
	mov	ecx, DWORD PTR $T218248[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T218248[ebp]
	mov	DWORD PTR [edx+4], -1

; 111  : 	}

	jmp	SHORT $LN15@reset
$LN14@reset:

; 112  : 
; 113  : 	for(iI = 0; iI < REALLY_MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@reset
$LN12@reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN13@reset:
	cmp	DWORD PTR _iI$[ebp], 80			; 00000050H
	jge	SHORT $LN11@reset

; 114  : 	{
; 115  : 		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)

	mov	DWORD PTR _iJ$[ebp], 0
	jmp	SHORT $LN10@reset
$LN9@reset:
	mov	ecx, DWORD PTR _iJ$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iJ$[ebp], ecx
$LN10@reset:
	cmp	DWORD PTR _iJ$[ebp], 6
	jge	SHORT $LN8@reset

; 116  : 		{
; 117  : 			m_aaiYieldRateModifier[iI][iJ] = 0;

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2284]
	mov	edx, DWORD PTR _iJ$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 118  : 		}

	jmp	SHORT $LN9@reset
$LN8@reset:

; 119  : 	}

	jmp	SHORT $LN12@reset
$LN11@reset:

; 120  : 
; 121  : 	if(!bConstructorCall)

	movzx	eax, BYTE PTR _bConstructorCall$[ebp]
	test	eax, eax
	jne	$LN23@reset

; 122  : 	{
; 123  : 		CvAssertMsg((0 < GC.getNumResourceInfos()) && "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvArea::reset", "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvArea::reset");
; 124  : 		int numRIs = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _numRIs$217551[ebp], eax

; 125  : 		m_paiNumResources = FNEW(int[numRIs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _numRIs$217551[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T218243[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T218243[ebp]
	mov	DWORD PTR [eax+4204], ecx

; 126  : 		for(iI = 0; iI < numRIs; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@reset
$LN5@reset:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN6@reset:
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR _numRIs$217551[ebp]
	jge	SHORT $LN4@reset

; 127  : 		{
; 128  : 			m_paiNumResources[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4204]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 129  : 		}

	jmp	SHORT $LN5@reset
$LN4@reset:

; 130  : 
; 131  : 		CvAssertMsg((0 < GC.getNumImprovementInfos()) && "GC.getNumImprovementInfos() is not greater than zero but an array is being allocated in CvArea::reset", "GC.getNumImprovementInfos() is not greater than zero but an array is being allocated in CvArea::reset");
; 132  : 		int numIIs = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	DWORD PTR _numIIs$217557[ebp], eax

; 133  : 		m_paiNumImprovements = FNEW(int[numIIs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _numIIs$217557[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T218244[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T218244[ebp]
	mov	DWORD PTR [eax+4208], ecx

; 134  : 		for(iI = 0; iI < numIIs; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@reset
$LN2@reset:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN3@reset:
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR _numIIs$217557[ebp]
	jge	SHORT $LN23@reset

; 135  : 		{
; 136  : 			m_paiNumImprovements[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4208]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 137  : 		}

	jmp	SHORT $LN2@reset
$LN23@reset:

; 138  : 	}
; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?reset@CvArea@@QAEXH_N0@Z ENDP				; CvArea::reset
_TEXT	ENDS
PUBLIC	?SetID@CvArea@@QAEXH@Z				; CvArea::SetID
; Function compile flags: /Odtp
;	COMDAT ?SetID@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?SetID@CvArea@@QAEXH@Z PROC				; CvArea::SetID, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 	m_iID = iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 145  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetID@CvArea@@QAEXH@Z ENDP				; CvArea::SetID
_TEXT	ENDS
PUBLIC	?calculateTotalBestNatureYield@CvArea@@QBEHXZ	; CvArea::calculateTotalBestNatureYield
EXTRN	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::calculateTotalBestNatureYield
; Function compile flags: /Odtp
;	COMDAT ?calculateTotalBestNatureYield@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T218269 = -28						; size = 4
$T218265 = -24						; size = 4
_iCount$ = -20						; size = 4
_theMap$ = -16						; size = 4
_iI$ = -12						; size = 4
_pLoopPlot$ = -8					; size = 4
_iNumPlots$ = -4					; size = 4
?calculateTotalBestNatureYield@CvArea@@QBEHXZ PROC	; CvArea::calculateTotalBestNatureYield, COMDAT
; _this$ = ecx

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 	CvPlot* pLoopPlot;
; 151  : 	int iCount;
; 152  : 	int iI;
; 153  : 
; 154  : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 155  : 
; 156  : 	CvMap& theMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _theMap$[ebp], eax

; 157  : 	int iNumPlots = theMap.numPlots();

	mov	ecx, DWORD PTR _theMap$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iNumPlots$[ebp], edx

; 158  : 	for(iI = 0; iI < iNumPlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@calculateT
$LN3@calculateT:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN4@calculateT:
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR _iNumPlots$[ebp]
	jge	SHORT $LN2@calculateT

; 159  : 	{
; 160  : 		pLoopPlot = theMap.plotByIndexUnchecked(iI);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _theMap$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], edx

; 161  : 
; 162  : 		if(pLoopPlot->getArea() == GetID())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T218265[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T218269[ebp], ecx
	mov	edx, DWORD PTR $T218265[ebp]
	cmp	edx, DWORD PTR $T218269[ebp]
	jne	SHORT $LN1@calculateT

; 163  : 		{
; 164  : 			iCount += pLoopPlot->calculateTotalBestNatureYield(NO_TEAM);

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::calculateTotalBestNatureYield
	add	eax, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR _iCount$[ebp], eax
$LN1@calculateT:

; 165  : 		}
; 166  : 	}

	jmp	SHORT $LN3@calculateT
$LN2@calculateT:

; 167  : 
; 168  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 169  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?calculateTotalBestNatureYield@CvArea@@QBEHXZ ENDP	; CvArea::calculateTotalBestNatureYield
_TEXT	ENDS
PUBLIC	?isWater@CvArea@@QBE_NXZ			; CvArea::isWater
PUBLIC	?countCoastalLand@CvArea@@QBEHXZ		; CvArea::countCoastalLand
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
; Function compile flags: /Odtp
;	COMDAT ?countCoastalLand@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T218288 = -28						; size = 4
$T218284 = -24						; size = 4
_iCount$ = -20						; size = 4
_theMap$ = -16						; size = 4
_iI$ = -12						; size = 4
_pLoopPlot$ = -8					; size = 4
_iNumPlots$ = -4					; size = 4
?countCoastalLand@CvArea@@QBEHXZ PROC			; CvArea::countCoastalLand, COMDAT
; _this$ = ecx

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 	CvPlot* pLoopPlot;
; 176  : 	int iCount;
; 177  : 	int iI;
; 178  : 
; 179  : 	if(isWater())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@countCoast

; 180  : 	{
; 181  : 		return 0;

	xor	eax, eax
	jmp	$LN7@countCoast
$LN6@countCoast:

; 182  : 	}
; 183  : 
; 184  : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 185  : 
; 186  : 	CvMap& theMap = GC.getMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _theMap$[ebp], ecx

; 187  : 	int iNumPlots = theMap.numPlots();

	mov	edx, DWORD PTR _theMap$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iNumPlots$[ebp], eax

; 188  : 	for(iI = 0; iI < iNumPlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@countCoast
$LN4@countCoast:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN5@countCoast:
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iNumPlots$[ebp]
	jge	SHORT $LN3@countCoast

; 189  : 	{
; 190  : 		pLoopPlot = theMap.plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _theMap$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 191  : 
; 192  : 		if(pLoopPlot->getArea() == GetID())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T218284[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T218288[ebp], edx
	mov	eax, DWORD PTR $T218284[ebp]
	cmp	eax, DWORD PTR $T218288[ebp]
	jne	SHORT $LN2@countCoast

; 193  : 		{
; 194  : 			if(pLoopPlot->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@countCoast

; 195  : 			{
; 196  : 				iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$LN2@countCoast:

; 197  : 			}
; 198  : 		}
; 199  : 	}

	jmp	SHORT $LN4@countCoast
$LN3@countCoast:

; 200  : 
; 201  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]
$LN7@countCoast:

; 202  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?countCoastalLand@CvArea@@QBEHXZ ENDP			; CvArea::countCoastalLand
_TEXT	ENDS
PUBLIC	?countNumUniqueResourceTypes@CvArea@@QBEHXZ	; CvArea::countNumUniqueResourceTypes
EXTRN	?isOneArea@CvResourceInfo@@QBE_NXZ:PROC		; CvResourceInfo::isOneArea
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
; Function compile flags: /Odtp
;	COMDAT ?countNumUniqueResourceTypes@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_resource$217602 = -16					; size = 4
_iI$217598 = -12					; size = 4
_iCount$ = -8						; size = 4
_numRIs$ = -4						; size = 4
?countNumUniqueResourceTypes@CvArea@@QBEHXZ PROC	; CvArea::countNumUniqueResourceTypes, COMDAT
; _this$ = ecx

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 208  : 	int numRIs = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _numRIs$[ebp], eax

; 209  : 
; 210  : 	for(int iI = 0; iI < numRIs; iI++)

	mov	DWORD PTR _iI$217598[ebp], 0
	jmp	SHORT $LN4@countNumUn
$LN3@countNumUn:
	mov	eax, DWORD PTR _iI$217598[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$217598[ebp], eax
$LN4@countNumUn:
	mov	ecx, DWORD PTR _iI$217598[ebp]
	cmp	ecx, DWORD PTR _numRIs$[ebp]
	jge	SHORT $LN2@countNumUn

; 211  : 	{
; 212  : 		CvResourceInfo* resource = GC.getResourceInfo((ResourceTypes)iI);

	mov	edx, DWORD PTR _iI$217598[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _resource$217602[ebp], eax

; 213  : 		if(NULL != resource && resource->isOneArea())

	cmp	DWORD PTR _resource$217602[ebp], 0
	je	SHORT $LN1@countNumUn
	mov	ecx, DWORD PTR _resource$217602[ebp]
	call	?isOneArea@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isOneArea
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@countNumUn

; 214  : 		{
; 215  : 			iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN1@countNumUn:

; 216  : 		}
; 217  : 	}

	jmp	SHORT $LN3@countNumUn
$LN2@countNumUn:

; 218  : 
; 219  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?countNumUniqueResourceTypes@CvArea@@QBEHXZ ENDP	; CvArea::countNumUniqueResourceTypes
_TEXT	ENDS
PUBLIC	?getNumTiles@CvArea@@QBEHXZ			; CvArea::getNumTiles
; Function compile flags: /Odtp
;	COMDAT ?getNumTiles@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumTiles@CvArea@@QBEHXZ PROC			; CvArea::getNumTiles, COMDAT
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	return m_iNumTiles;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumTiles@CvArea@@QBEHXZ ENDP			; CvArea::getNumTiles
_TEXT	ENDS
PUBLIC	?changeNumTiles@CvArea@@QAEXH@Z			; CvArea::changeNumTiles
; Function compile flags: /Odtp
;	COMDAT ?changeNumTiles@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumTiles@CvArea@@QAEXH@Z PROC			; CvArea::changeNumTiles, COMDAT
; _this$ = ecx

; 230  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 	m_iNumTiles = (m_iNumTiles + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 232  : 	CvAssert(m_iNumTiles >= 0);
; 233  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumTiles@CvArea@@QAEXH@Z ENDP			; CvArea::changeNumTiles
_TEXT	ENDS
PUBLIC	?getNumOwnedTiles@CvArea@@QBEHXZ		; CvArea::getNumOwnedTiles
; Function compile flags: /Odtp
;	COMDAT ?getNumOwnedTiles@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumOwnedTiles@CvArea@@QBEHXZ PROC			; CvArea::getNumOwnedTiles, COMDAT
; _this$ = ecx

; 238  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 	return m_iNumOwnedTiles;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 240  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumOwnedTiles@CvArea@@QBEHXZ ENDP			; CvArea::getNumOwnedTiles
_TEXT	ENDS
PUBLIC	?getNumUnownedTiles@CvArea@@QBEHXZ		; CvArea::getNumUnownedTiles
; Function compile flags: /Odtp
;	COMDAT ?getNumUnownedTiles@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumUnownedTiles@CvArea@@QBEHXZ PROC			; CvArea::getNumUnownedTiles, COMDAT
; _this$ = ecx

; 245  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	return (m_iNumTiles - getNumOwnedTiles());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumOwnedTiles@CvArea@@QBEHXZ	; CvArea::getNumOwnedTiles
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	eax, edx

; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumUnownedTiles@CvArea@@QBEHXZ ENDP			; CvArea::getNumUnownedTiles
_TEXT	ENDS
PUBLIC	?changeNumOwnedTiles@CvArea@@QAEXH@Z		; CvArea::changeNumOwnedTiles
; Function compile flags: /Odtp
;	COMDAT ?changeNumOwnedTiles@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumOwnedTiles@CvArea@@QAEXH@Z PROC		; CvArea::changeNumOwnedTiles, COMDAT
; _this$ = ecx

; 252  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 253  : 	m_iNumOwnedTiles = (m_iNumOwnedTiles + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 254  : 	CvAssert(getNumOwnedTiles() >= 0);
; 255  : 	CvAssert(getNumUnownedTiles() >= 0);
; 256  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumOwnedTiles@CvArea@@QAEXH@Z ENDP		; CvArea::changeNumOwnedTiles
_TEXT	ENDS
PUBLIC	?getNumRiverEdges@CvArea@@QBEHXZ		; CvArea::getNumRiverEdges
; Function compile flags: /Odtp
;	COMDAT ?getNumRiverEdges@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumRiverEdges@CvArea@@QBEHXZ PROC			; CvArea::getNumRiverEdges, COMDAT
; _this$ = ecx

; 261  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 	return m_iNumRiverEdges;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 263  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumRiverEdges@CvArea@@QBEHXZ ENDP			; CvArea::getNumRiverEdges
_TEXT	ENDS
PUBLIC	?changeNumRiverEdges@CvArea@@QAEXH@Z		; CvArea::changeNumRiverEdges
; Function compile flags: /Odtp
;	COMDAT ?changeNumRiverEdges@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumRiverEdges@CvArea@@QAEXH@Z PROC		; CvArea::changeNumRiverEdges, COMDAT
; _this$ = ecx

; 268  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 	m_iNumRiverEdges = (m_iNumRiverEdges + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 270  : 	CvAssert(getNumRiverEdges() >= 0);
; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumRiverEdges@CvArea@@QAEXH@Z ENDP		; CvArea::changeNumRiverEdges
_TEXT	ENDS
PUBLIC	?getNumUnits@CvArea@@QBEHXZ			; CvArea::getNumUnits
; Function compile flags: /Odtp
;	COMDAT ?getNumUnits@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumUnits@CvArea@@QBEHXZ PROC			; CvArea::getNumUnits, COMDAT
; _this$ = ecx

; 276  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 	return m_iNumUnits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 278  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumUnits@CvArea@@QBEHXZ ENDP			; CvArea::getNumUnits
_TEXT	ENDS
PUBLIC	?getNumCities@CvArea@@QBEHXZ			; CvArea::getNumCities
; Function compile flags: /Odtp
;	COMDAT ?getNumCities@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumCities@CvArea@@QBEHXZ PROC			; CvArea::getNumCities, COMDAT
; _this$ = ecx

; 283  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 284  : 	return m_iNumCities;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 285  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumCities@CvArea@@QBEHXZ ENDP			; CvArea::getNumCities
_TEXT	ENDS
PUBLIC	?getTotalPopulation@CvArea@@QBEHXZ		; CvArea::getTotalPopulation
; Function compile flags: /Odtp
;	COMDAT ?getTotalPopulation@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTotalPopulation@CvArea@@QBEHXZ PROC			; CvArea::getTotalPopulation, COMDAT
; _this$ = ecx

; 290  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 291  : 	return m_iTotalPopulation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTotalPopulation@CvArea@@QBEHXZ ENDP			; CvArea::getTotalPopulation
_TEXT	ENDS
PUBLIC	?getNumStartingPlots@CvArea@@QBEHXZ		; CvArea::getNumStartingPlots
; Function compile flags: /Odtp
;	COMDAT ?getNumStartingPlots@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumStartingPlots@CvArea@@QBEHXZ PROC		; CvArea::getNumStartingPlots, COMDAT
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	return m_iNumStartingPlots;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]

; 299  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumStartingPlots@CvArea@@QBEHXZ ENDP		; CvArea::getNumStartingPlots
_TEXT	ENDS
PUBLIC	?changeNumStartingPlots@CvArea@@QAEXH@Z		; CvArea::changeNumStartingPlots
; Function compile flags: /Odtp
;	COMDAT ?changeNumStartingPlots@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeNumStartingPlots@CvArea@@QAEXH@Z PROC		; CvArea::changeNumStartingPlots, COMDAT
; _this$ = ecx

; 304  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 305  : 	m_iNumStartingPlots = m_iNumStartingPlots + iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 306  : 	CvAssert(getNumStartingPlots() >= 0);
; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumStartingPlots@CvArea@@QAEXH@Z ENDP		; CvArea::changeNumStartingPlots
_TEXT	ENDS
PUBLIC	?GetNumNaturalWonders@CvArea@@QBEHXZ		; CvArea::GetNumNaturalWonders
; Function compile flags: /Odtp
;	COMDAT ?GetNumNaturalWonders@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumNaturalWonders@CvArea@@QBEHXZ PROC		; CvArea::GetNumNaturalWonders, COMDAT
; _this$ = ecx

; 313  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 314  : 	return m_iNumNaturalWonders;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 315  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumNaturalWonders@CvArea@@QBEHXZ ENDP		; CvArea::GetNumNaturalWonders
_TEXT	ENDS
PUBLIC	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z	; CvArea::ChangeNumNaturalWonders
; Function compile flags: /Odtp
;	COMDAT ?ChangeNumNaturalWonders@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeNumNaturalWonders@CvArea@@QAEXH@Z PROC		; CvArea::ChangeNumNaturalWonders, COMDAT
; _this$ = ecx

; 320  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 	m_iNumNaturalWonders += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 322  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeNumNaturalWonders@CvArea@@QAEXH@Z ENDP		; CvArea::ChangeNumNaturalWonders
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isWater@CvArea@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isWater@CvArea@@QBE_NXZ PROC				; CvArea::isWater, COMDAT
; _this$ = ecx

; 327  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 328  : 	return m_bWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4228]

; 329  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isWater@CvArea@@QBE_NXZ ENDP				; CvArea::isWater
_TEXT	ENDS
PUBLIC	?IsMountains@CvArea@@QBE_NXZ			; CvArea::IsMountains
; Function compile flags: /Odtp
;	COMDAT ?IsMountains@CvArea@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMountains@CvArea@@QBE_NXZ PROC			; CvArea::IsMountains, COMDAT
; _this$ = ecx

; 334  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 335  : 	return m_bMountains;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4229]

; 336  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMountains@CvArea@@QBE_NXZ ENDP			; CvArea::IsMountains
_TEXT	ENDS
PUBLIC	?SetMountains@CvArea@@QAEX_N@Z			; CvArea::SetMountains
; Function compile flags: /Odtp
;	COMDAT ?SetMountains@CvArea@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bValue$ = 8						; size = 1
?SetMountains@CvArea@@QAEX_N@Z PROC			; CvArea::SetMountains, COMDAT
; _this$ = ecx

; 340  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 	if(m_bMountains != bValue)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4229]
	movzx	edx, BYTE PTR _bValue$[ebp]
	cmp	ecx, edx
	je	SHORT $LN2@SetMountai

; 342  : 	{
; 343  : 		m_bMountains = bValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+4229], cl
$LN2@SetMountai:

; 344  : 	}
; 345  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMountains@CvArea@@QAEX_N@Z ENDP			; CvArea::SetMountains
_TEXT	ENDS
PUBLIC	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getUnitsPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getUnitsPerPlayer, COMDAT
; _this$ = ecx

; 351  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 353  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 354  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0; // as set during reset()

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@getUnitsPe
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@getUnitsPe
$LN1@getUnitsPe:
	xor	eax, eax
	jmp	SHORT $LN3@getUnitsPe
$LN2@getUnitsPe:

; 355  : 
; 356  : 	return m_aiUnitsPerPlayer[eIndex];

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+44]
$LN3@getUnitsPe:

; 357  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getUnitsPerPlayer
_TEXT	ENDS
PUBLIC	?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeUnitsPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changeUnitsPerPlayer, COMDAT
; _this$ = ecx

; 362  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 363  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 364  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 365  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@changeUnit
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@changeUnit
$LN1@changeUnit:
	jmp	SHORT $LN3@changeUnit
$LN2@changeUnit:

; 366  : 	m_iNumUnits = (m_iNumUnits + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 367  : 	CvAssert(getNumUnits() >= 0);
; 368  : 	m_aiUnitsPerPlayer[eIndex] = (m_aiUnitsPerPlayer[eIndex] + iChange);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+44]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+44], edx
$LN3@changeUnit:

; 369  : 	CvAssert(getUnitsPerPlayer(eIndex) >= 0);
; 370  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changeUnitsPerPlayer
_TEXT	ENDS
PUBLIC	?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z	; CvArea::getEnemyUnits
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
;	COMDAT ?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T218354 = -24						; size = 4
$T218334 = -20						; size = 4
_kPlayer$217686 = -16					; size = 4
_iI$217682 = -12					; size = 4
_iRtnValue$ = -8					; size = 4
_eTeam$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getEnemyUnits, COMDAT
; _this$ = ecx

; 375  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 377  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 378  : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 379  : 
; 380  : 	TeamTypes eTeam = GET_PLAYER(eIndex).getTeam();

	mov	eax, DWORD PTR _eIndex$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218334[ebp], eax
	mov	ecx, DWORD PTR $T218334[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 381  : 
; 382  : 	// Loop through each player
; 383  : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$217682[ebp], 0
	jmp	SHORT $LN4@getEnemyUn
$LN3@getEnemyUn:
	mov	eax, DWORD PTR _iI$217682[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$217682[ebp], eax
$LN4@getEnemyUn:
	cmp	DWORD PTR _iI$217682[ebp], 64		; 00000040H
	jge	SHORT $LN2@getEnemyUn

; 384  : 	{
; 385  : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$217682[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$217686[ebp], ecx

; 386  : 		if(atWar(kPlayer.getTeam(), eTeam))

	mov	edx, DWORD PTR _kPlayer$217686[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T218354[ebp], eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T218354[ebp]
	push	edx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@getEnemyUn

; 387  : 		{
; 388  : 			iRtnValue += getUnitsPerPlayer((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$217682[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getUnitsPerPlayer
	add	eax, DWORD PTR _iRtnValue$[ebp]
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN1@getEnemyUn:

; 389  : 		}
; 390  : 	}

	jmp	SHORT $LN3@getEnemyUn
$LN2@getEnemyUn:

; 391  : 
; 392  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 393  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getEnemyUnits
_TEXT	ENDS
PUBLIC	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getCitiesPerPlayer, COMDAT
; _this$ = ecx

; 398  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 399  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 400  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 401  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@getCitiesP
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@getCitiesP
$LN1@getCitiesP:
	xor	eax, eax
	jmp	SHORT $LN3@getCitiesP
$LN2@getCitiesP:

; 402  : 
; 403  : 	return m_aiCitiesPerPlayer[eIndex];

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+364]
$LN3@getCitiesP:

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getCitiesPerPlayer
_TEXT	ENDS
PUBLIC	?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeCitiesPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changeCitiesPerPlayer, COMDAT
; _this$ = ecx

; 409  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 411  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 412  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@changeCiti
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@changeCiti
$LN1@changeCiti:
	jmp	SHORT $LN3@changeCiti
$LN2@changeCiti:

; 413  : 
; 414  : 	m_iNumCities = (m_iNumCities + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 415  : 	CvAssert(getNumCities() >= 0);
; 416  : 	m_aiCitiesPerPlayer[eIndex] = (m_aiCitiesPerPlayer[eIndex] + iChange);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+364]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+364], edx
$LN3@changeCiti:

; 417  : 	CvAssert(getCitiesPerPlayer(eIndex) >= 0);
; 418  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changeCitiesPerPlayer
_TEXT	ENDS
PUBLIC	?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getPopulationPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z PROC ; CvArea::getPopulationPerPlayer, COMDAT
; _this$ = ecx

; 424  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 425  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 426  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 427  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@getPopulat
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@getPopulat
$LN1@getPopulat:
	xor	eax, eax
	jmp	SHORT $LN3@getPopulat
$LN2@getPopulat:

; 428  : 
; 429  : 	return m_aiPopulationPerPlayer[eIndex];

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+684]
$LN3@getPopulat:

; 430  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ENDP ; CvArea::getPopulationPerPlayer
_TEXT	ENDS
PUBLIC	?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changePopulationPerPlayer
; Function compile flags: /Odtp
;	COMDAT ?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changePopulationPerPlayer, COMDAT
; _this$ = ecx

; 435  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 436  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 437  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 438  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@changePopu
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@changePopu
$LN1@changePopu:
	jmp	SHORT $LN3@changePopu
$LN2@changePopu:

; 439  : 
; 440  : 	m_iTotalPopulation = (m_iTotalPopulation + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 441  : 	CvAssert(getTotalPopulation() >= 0);
; 442  : 	m_aiPopulationPerPlayer[eIndex] = (m_aiPopulationPerPlayer[eIndex] + iChange);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+684]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+684], edx
$LN3@changePopu:

; 443  : 	CvAssert(getPopulationPerPlayer(eIndex) >= 0);
; 444  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changePopulationPerPlayer
_TEXT	ENDS
PUBLIC	?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getFreeSpecialist
; Function compile flags: /Odtp
;	COMDAT ?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getFreeSpecialist, COMDAT
; _this$ = ecx

; 450  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 451  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 452  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 453  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@getFreeSpe
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@getFreeSpe
$LN1@getFreeSpe:
	xor	eax, eax
	jmp	SHORT $LN3@getFreeSpe
$LN2@getFreeSpe:

; 454  : 
; 455  : 	return m_aiFreeSpecialist[eIndex];

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1004]
$LN3@getFreeSpe:

; 456  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getFreeSpecialist
_TEXT	ENDS
PUBLIC	?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeFreeSpecialist
; Function compile flags: /Odtp
;	COMDAT ?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changeFreeSpecialist, COMDAT
; _this$ = ecx

; 461  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 463  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 464  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN2@changeFree
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN3@changeFree
$LN2@changeFree:
	jmp	SHORT $LN4@changeFree
$LN3@changeFree:

; 465  : 
; 466  : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN4@changeFree

; 467  : 	{
; 468  : 		m_aiFreeSpecialist[eIndex] = (m_aiFreeSpecialist[eIndex] + iChange);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1004]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1004], edx
$LN4@changeFree:

; 469  : 		CvAssert(getFreeSpecialist(eIndex) >= 0);
; 470  : 	}
; 471  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changeFreeSpecialist
_TEXT	ENDS
PUBLIC	?getTotalFoundValue@CvArea@@QBEHXZ		; CvArea::getTotalFoundValue
; Function compile flags: /Odtp
;	COMDAT ?getTotalFoundValue@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTotalFoundValue@CvArea@@QBEHXZ PROC			; CvArea::getTotalFoundValue, COMDAT
; _this$ = ecx

; 477  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 478  : 	return m_iTotalFoundValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 479  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTotalFoundValue@CvArea@@QBEHXZ ENDP			; CvArea::getTotalFoundValue
_TEXT	ENDS
PUBLIC	?setTotalFoundValue@CvArea@@QAEXH@Z		; CvArea::setTotalFoundValue
; Function compile flags: /Odtp
;	COMDAT ?setTotalFoundValue@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iNewValue$ = 8						; size = 4
?setTotalFoundValue@CvArea@@QAEXH@Z PROC		; CvArea::setTotalFoundValue, COMDAT
; _this$ = ecx

; 484  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 485  : 	m_iTotalFoundValue = iNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iNewValue$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 486  : 	CvAssert(m_iTotalFoundValue >= 0);
; 487  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setTotalFoundValue@CvArea@@QAEXH@Z ENDP		; CvArea::setTotalFoundValue
_TEXT	ENDS
PUBLIC	?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ; CvArea::getNumRevealedTiles
; Function compile flags: /Odtp
;	COMDAT ?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z PROC	; CvArea::getNumRevealedTiles, COMDAT
; _this$ = ecx

; 492  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 493  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 494  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 495  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@getNumReve
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@getNumReve
$LN1@getNumReve:
	xor	eax, eax
	jmp	SHORT $LN3@getNumReve
$LN2@getNumReve:

; 496  : 
; 497  : 	return m_aiNumRevealedTiles[eIndex];

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1324]
$LN3@getNumReve:

; 498  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ENDP	; CvArea::getNumRevealedTiles
_TEXT	ENDS
PUBLIC	?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ; CvArea::getNumUnrevealedTiles
; Function compile flags: /Odtp
;	COMDAT ?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z PROC	; CvArea::getNumUnrevealedTiles, COMDAT
; _this$ = ecx

; 503  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 504  : 	return (m_iNumTiles - getNumRevealedTiles(eIndex));

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ; CvArea::getNumRevealedTiles
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	eax, edx

; 505  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ENDP	; CvArea::getNumUnrevealedTiles
_TEXT	ENDS
PUBLIC	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ; CvArea::changeNumRevealedTiles
; Function compile flags: /Odtp
;	COMDAT ?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z PROC ; CvArea::changeNumRevealedTiles, COMDAT
; _this$ = ecx

; 510  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 512  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 513  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@changeNumR
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@changeNumR
$LN1@changeNumR:
	jmp	SHORT $LN3@changeNumR
$LN2@changeNumR:

; 514  : 
; 515  : 	m_aiNumRevealedTiles[eIndex] = (m_aiNumRevealedTiles[eIndex] + iChange);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1324]
	add	edx, DWORD PTR _iChange$[ebp]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1324], edx
$LN3@changeNumR:

; 516  : 	CvAssert(getNumRevealedTiles(eIndex) >= 0);
; 517  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ENDP ; CvArea::changeNumRevealedTiles
_TEXT	ENDS
PUBLIC	?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvArea::getTargetCity
EXTRN	?getCity@@YAPAVCvCity@@UIDInfo@@@Z:PROC		; getCity
; Function compile flags: /Odtp
;	COMDAT ?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvArea::getTargetCity, COMDAT
; _this$ = ecx

; 522  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 523  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 524  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 525  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN1@getTargetC
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN2@getTargetC
$LN1@getTargetC:
	xor	eax, eax
	jmp	SHORT $LN3@getTargetC
$LN2@getTargetC:

; 526  : 
; 527  : 	return getCity(m_aTargetCities[eIndex]);

	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+1648]
	push	edx
	mov	eax, DWORD PTR [ecx+eax*8+1644]
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8
$LN3@getTargetC:

; 528  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvArea::getTargetCity
_TEXT	ENDS
PUBLIC	?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z ; CvArea::setTargetCity
EXTRN	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ:PROC	; CvCity::GetIDInfo
; Function compile flags: /Odtp
;	COMDAT ?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T218385 = -12						; size = 4
$T218381 = -8						; size = 8
_eIndex$ = 8						; size = 4
_pNewValue$ = 12					; size = 4
?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z PROC ; CvArea::setTargetCity, COMDAT
; _this$ = ecx

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 535  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 536  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex$[ebp], 0
	jl	SHORT $LN3@setTargetC
	cmp	DWORD PTR _eIndex$[ebp], 64		; 00000040H
	jl	SHORT $LN4@setTargetC
$LN3@setTargetC:
	jmp	SHORT $LN5@setTargetC
$LN4@setTargetC:

; 537  : 
; 538  : 	if(pNewValue != NULL)

	cmp	DWORD PTR _pNewValue$[ebp], 0
	je	SHORT $LN2@setTargetC

; 539  : 	{
; 540  : 		m_aTargetCities[eIndex] = pNewValue->GetIDInfo();

	lea	eax, DWORD PTR $T218381[ebp]
	push	eax
	mov	ecx, DWORD PTR _pNewValue$[ebp]
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [esi+eax*8+1644], ecx
	mov	DWORD PTR [esi+eax*8+1648], edx

; 541  : 	}
; 542  : 	else

	jmp	SHORT $LN5@setTargetC
$LN2@setTargetC:

; 543  : 	{
; 544  : 		m_aTargetCities[eIndex].reset();

	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+1644]
	mov	DWORD PTR $T218385[ebp], eax
	mov	ecx, DWORD PTR $T218385[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T218385[ebp]
	mov	DWORD PTR [edx+4], -1
$LN5@setTargetC:

; 545  : 	}
; 546  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z ENDP ; CvArea::setTargetCity
_TEXT	ENDS
PUBLIC	?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z ; CvArea::getYieldRateModifier
; Function compile flags: /Odtp
;	COMDAT ?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z PROC ; CvArea::getYieldRateModifier, COMDAT
; _this$ = ecx

; 551  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 552  : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be >= 0");
; 553  : 	CvAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be < MAX_PLAYERS");
; 554  : 	if(eIndex1 < 0 || eIndex1 >= MAX_PLAYERS) return 0;

	cmp	DWORD PTR _eIndex1$[ebp], 0
	jl	SHORT $LN3@getYieldRa
	cmp	DWORD PTR _eIndex1$[ebp], 64		; 00000040H
	jl	SHORT $LN4@getYieldRa
$LN3@getYieldRa:
	xor	eax, eax
	jmp	SHORT $LN5@getYieldRa
$LN4@getYieldRa:

; 555  : 
; 556  : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be >= 0");
; 557  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be < NUM_YIELD_TYPES");
; 558  : 	if(eIndex2 < 0 || eIndex2 >= MAX_PLAYERS) return 0;

	cmp	DWORD PTR _eIndex2$[ebp], 0
	jl	SHORT $LN1@getYieldRa
	cmp	DWORD PTR _eIndex2$[ebp], 64		; 00000040H
	jl	SHORT $LN2@getYieldRa
$LN1@getYieldRa:
	xor	eax, eax
	jmp	SHORT $LN5@getYieldRa
$LN2@getYieldRa:

; 559  : 
; 560  : 	return m_aaiYieldRateModifier[eIndex1][eIndex2];

	mov	eax, DWORD PTR _eIndex1$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2284]
	mov	eax, DWORD PTR _eIndex2$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
$LN5@getYieldRa:

; 561  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z ENDP ; CvArea::getYieldRateModifier
_TEXT	ENDS
PUBLIC	?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z ; CvArea::changeYieldRateModifier
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
EXTRN	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z:PROC ; CvPlayer::invalidateYieldRankCache
; Function compile flags: /Odtp
;	COMDAT ?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
tv134 = -24						; size = 4
_this$ = -20						; size = 4
$T218409 = -16						; size = 4
$T218405 = -12						; size = 4
$T218401 = -8						; size = 4
_thisPlayer$217790 = -4					; size = 4
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z PROC ; CvArea::changeYieldRateModifier, COMDAT
; _this$ = ecx

; 566  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 567  : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be >= 0");
; 568  : 	CvAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be < MAX_PLAYERS");
; 569  : 	if(eIndex1 < 0 || eIndex1 >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex1$[ebp], 0
	jl	SHORT $LN5@changeYiel
	cmp	DWORD PTR _eIndex1$[ebp], 64		; 00000040H
	jl	SHORT $LN6@changeYiel
$LN5@changeYiel:
	jmp	$LN7@changeYiel
$LN6@changeYiel:

; 570  : 
; 571  : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be >= 0");
; 572  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be < NUM_YIELD_TYPES");
; 573  : 	if(eIndex2 < 0 || eIndex2 >= MAX_PLAYERS) return;

	cmp	DWORD PTR _eIndex2$[ebp], 0
	jl	SHORT $LN3@changeYiel
	cmp	DWORD PTR _eIndex2$[ebp], 64		; 00000040H
	jl	SHORT $LN4@changeYiel
$LN3@changeYiel:
	jmp	$LN7@changeYiel
$LN4@changeYiel:

; 574  : 
; 575  : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	$LN7@changeYiel

; 576  : 	{
; 577  : 		m_aaiYieldRateModifier[eIndex1][eIndex2] = (m_aaiYieldRateModifier[eIndex1][eIndex2] + iChange);

	mov	eax, DWORD PTR _eIndex1$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2284]
	mov	eax, DWORD PTR _eIndex2$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _eIndex1$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [eax+edx+2284]
	mov	eax, DWORD PTR _eIndex2$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 578  : 
; 579  : 		CvPlayer& thisPlayer = GET_PLAYER(eIndex1);

	mov	ecx, DWORD PTR _eIndex1$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$217790[ebp], ecx

; 580  : 		thisPlayer.invalidateYieldRankCache(eIndex2);

	mov	edx, DWORD PTR _eIndex2$[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisPlayer$217790[ebp]
	call	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z ; CvPlayer::invalidateYieldRankCache

; 581  : 
; 582  : 		if(thisPlayer.getTeam() == GC.getGame().getActiveTeam())

	mov	eax, DWORD PTR _thisPlayer$217790[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T218401[ebp], eax
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T218405[ebp], edx
	mov	ecx, DWORD PTR $T218405[ebp]
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	DWORD PTR $T218401[ebp], eax
	jne	SHORT $LN7@changeYiel

; 583  : 		{
; 584  : 			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T218409[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv134[ebp], ecx
	push	1
	push	18					; 00000012H
	mov	edx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx
$LN7@changeYiel:

; 585  : 		}
; 586  : 	}
; 587  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z ENDP ; CvArea::changeYieldRateModifier
_TEXT	ENDS
PUBLIC	?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z ; CvArea::getNumResources
; Function compile flags: /Odtp
;	COMDAT ?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eResource$ = 8						; size = 4
?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z PROC	; CvArea::getNumResources, COMDAT
; _this$ = ecx

; 593  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 594  : 	CvAssertMsg(eResource >= 0, "eResource expected to be >= 0");
; 595  : 	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource expected to be < GC.getNumResourceInfos");
; 596  : 	return m_paiNumResources[eResource];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4204]
	mov	edx, DWORD PTR _eResource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 597  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z ENDP	; CvArea::getNumResources
_TEXT	ENDS
PUBLIC	?getNumTotalResources@CvArea@@QBEHXZ		; CvArea::getNumTotalResources
; Function compile flags: /Odtp
;	COMDAT ?getNumTotalResources@CvArea@@QBEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_iI$217801 = -12					; size = 4
_iTotal$ = -8						; size = 4
_iNumResourceInfos$ = -4				; size = 4
?getNumTotalResources@CvArea@@QBEHXZ PROC		; CvArea::getNumTotalResources, COMDAT
; _this$ = ecx

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 604  : 	int iTotal = 0;

	mov	DWORD PTR _iTotal$[ebp], 0

; 605  : 
; 606  : 	int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResourceInfos$[ebp], eax

; 607  : 	for(int iI = 0; iI < iNumResourceInfos; iI++)

	mov	DWORD PTR _iI$217801[ebp], 0
	jmp	SHORT $LN3@getNumTota
$LN2@getNumTota:
	mov	eax, DWORD PTR _iI$217801[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$217801[ebp], eax
$LN3@getNumTota:
	mov	ecx, DWORD PTR _iI$217801[ebp]
	cmp	ecx, DWORD PTR _iNumResourceInfos$[ebp]
	jge	SHORT $LN1@getNumTota

; 608  : 	{
; 609  : 		iTotal += m_paiNumResources[iI];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4204]
	mov	ecx, DWORD PTR _iI$217801[ebp]
	mov	edx, DWORD PTR _iTotal$[ebp]
	add	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _iTotal$[ebp], edx

; 610  : 	}

	jmp	SHORT $LN2@getNumTota
$LN1@getNumTota:

; 611  : 
; 612  : 	return iTotal;

	mov	eax, DWORD PTR _iTotal$[ebp]

; 613  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumTotalResources@CvArea@@QBEHXZ ENDP		; CvArea::getNumTotalResources
_TEXT	ENDS
PUBLIC	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
; Function compile flags: /Odtp
;	COMDAT ?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eResource$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z PROC ; CvArea::changeNumResources, COMDAT
; _this$ = ecx

; 618  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 619  : 	CvAssertMsg(eResource >= 0, "eResource expected to be >= 0");
; 620  : 	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource expected to be < GC.getNumResourceInfos");
; 621  : 	m_paiNumResources[eResource] = (m_paiNumResources[eResource] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4204]
	mov	edx, DWORD PTR _eResource$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4204]
	mov	ecx, DWORD PTR _eResource$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 622  : 	CvAssert(getNumResources(eResource) >= 0);
; 623  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ENDP ; CvArea::changeNumResources
_TEXT	ENDS
PUBLIC	?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z ; CvArea::getNumImprovements
; Function compile flags: /Odtp
;	COMDAT ?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eImprovement$ = 8					; size = 4
?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z PROC ; CvArea::getNumImprovements, COMDAT
; _this$ = ecx

; 629  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 	CvAssertMsg(eImprovement >= 0, "eImprovement expected to be >= 0");
; 631  : 	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eImprovement expected to be < GC.getNumImprovementInfos");
; 632  : 	return m_paiNumImprovements[eImprovement];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4208]
	mov	edx, DWORD PTR _eImprovement$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 633  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z ENDP ; CvArea::getNumImprovements
_TEXT	ENDS
PUBLIC	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
; Function compile flags: /Odtp
;	COMDAT ?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eImprovement$ = 8					; size = 4
_iChange$ = 12						; size = 4
?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z PROC ; CvArea::changeNumImprovements, COMDAT
; _this$ = ecx

; 638  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 639  : 	CvAssertMsg(eImprovement >= 0, "eImprovement expected to be >= 0");
; 640  : 	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eImprovement expected to be < GC.getNumImprovementInfos");
; 641  : 	m_paiNumImprovements[eImprovement] = (m_paiNumImprovements[eImprovement] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4208]
	mov	edx, DWORD PTR _eImprovement$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4208]
	mov	ecx, DWORD PTR _eImprovement$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 642  : 	CvAssert(getNumImprovements(eImprovement) >= 0);
; 643  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ENDP ; CvArea::changeNumImprovements
_TEXT	ENDS
PUBLIC	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
; Function compile flags: /Odtp
;	COMDAT ?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ PROC ; CvArea::getAreaBoundaries, COMDAT
; _this$ = ecx

; 647  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 648  : 	return m_Boundaries;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4212				; 00001074H
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 649  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ENDP ; CvArea::getAreaBoundaries
_TEXT	ENDS
PUBLIC	?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z ; CvArea::setAreaBoundaries
; Function compile flags: /Odtp
;	COMDAT ?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_newBoundaries$ = 8					; size = 16
?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z PROC ; CvArea::setAreaBoundaries, COMDAT
; _this$ = ecx

; 657  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 658  : 	m_Boundaries = newBoundaries;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4212				; 00001074H
	mov	ecx, DWORD PTR _newBoundaries$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newBoundaries$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newBoundaries$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newBoundaries$[ebp+12]
	mov	DWORD PTR [eax+12], edx

; 659  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z ENDP ; CvArea::setAreaBoundaries
_TEXT	ENDS
PUBLIC	?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z	; CvArea::GetTopAndBottomLatitudes
EXTRN	?getBottomLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getBottomLatitude
EXTRN	?getTopLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getTopLatitude
; Function compile flags: /Odtp
;	COMDAT ?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T218456 = -40						; size = 4
$T218452 = -36						; size = 4
$T218448 = -29						; size = 1
$T218444 = -28						; size = 4
$T218440 = -21						; size = 1
$T218436 = -20						; size = 4
$T218429 = -16						; size = 4
_iMapTop$ = -12						; size = 4
_iGridHeight$ = -8					; size = 4
_iMapBottom$ = -4					; size = 4
_iTopLatitude$ = 8					; size = 4
_iBottomLatitude$ = 12					; size = 4
?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z PROC	; CvArea::GetTopAndBottomLatitudes, COMDAT
; _this$ = ecx

; 664  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 	int iGridHeight = GC.getMap().getGridHeight();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218429[ebp], eax
	mov	ecx, DWORD PTR $T218429[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR _iGridHeight$[ebp], edx

; 666  : 	if(GC.getMap().isWrapX() || !(GC.getMap().isWrapY()))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218436[ebp], eax
	mov	ecx, DWORD PTR $T218436[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T218440[ebp], dl
	movzx	eax, BYTE PTR $T218440[ebp]
	test	eax, eax
	jne	SHORT $LN2@GetTopAndB
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218444[ebp], ecx
	mov	edx, DWORD PTR $T218444[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T218448[ebp], al
	movzx	ecx, BYTE PTR $T218448[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@GetTopAndB
$LN2@GetTopAndB:

; 667  : 	{
; 668  : 		iTopLatitude = ((m_Boundaries.m_iNorthEdge * 100) / iGridHeight);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4212]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iGridHeight$[ebp]
	mov	ecx, DWORD PTR _iTopLatitude$[ebp]
	mov	DWORD PTR [ecx], eax

; 669  : 		iBottomLatitude = ((m_Boundaries.m_iSouthEdge * 100) / iGridHeight);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4216]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iGridHeight$[ebp]
	mov	ecx, DWORD PTR _iBottomLatitude$[ebp]
	mov	DWORD PTR [ecx], eax

; 670  : 	}
; 671  : 	else

	jmp	SHORT $LN1@GetTopAndB
$LN3@GetTopAndB:

; 672  : 	{
; 673  : 		iTopLatitude = ((m_Boundaries.m_iEastEdge * 100) / iGridHeight);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4220]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iGridHeight$[ebp]
	mov	ecx, DWORD PTR _iTopLatitude$[ebp]
	mov	DWORD PTR [ecx], eax

; 674  : 		iBottomLatitude = ((m_Boundaries.m_iWestEdge * 100) / iGridHeight);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4224]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iGridHeight$[ebp]
	mov	ecx, DWORD PTR _iBottomLatitude$[ebp]
	mov	DWORD PTR [ecx], eax
$LN1@GetTopAndB:

; 675  : 	}
; 676  : 
; 677  : 	int iMapTop = GC.getMap().getTopLatitude();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218452[ebp], edx
	mov	ecx, DWORD PTR $T218452[ebp]
	call	?getTopLatitude@CvMap@@QAEHXZ		; CvMap::getTopLatitude
	mov	DWORD PTR _iMapTop$[ebp], eax

; 678  : 	int iMapBottom = GC.getMap().getBottomLatitude();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218456[ebp], eax
	mov	ecx, DWORD PTR $T218456[ebp]
	call	?getBottomLatitude@CvMap@@QAEHXZ	; CvMap::getBottomLatitude
	mov	DWORD PTR _iMapBottom$[ebp], eax

; 679  : 
; 680  : 	iTopLatitude = ((iTopLatitude * (iMapTop - iMapBottom)) / 100);

	mov	ecx, DWORD PTR _iMapTop$[ebp]
	sub	ecx, DWORD PTR _iMapBottom$[ebp]
	mov	edx, DWORD PTR _iTopLatitude$[ebp]
	mov	eax, ecx
	imul	eax, DWORD PTR [edx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iTopLatitude$[ebp]
	mov	DWORD PTR [edx], eax

; 681  : 	iBottomLatitude = ((iBottomLatitude * (iMapTop - iMapBottom)) / 100);

	mov	eax, DWORD PTR _iMapTop$[ebp]
	sub	eax, DWORD PTR _iMapBottom$[ebp]
	mov	ecx, DWORD PTR _iBottomLatitude$[ebp]
	imul	eax, DWORD PTR [ecx]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iBottomLatitude$[ebp]
	mov	DWORD PTR [edx], eax

; 682  : 
; 683  : 	iTopLatitude = abs(iTopLatitude + iMapBottom);

	mov	eax, DWORD PTR _iTopLatitude$[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR _iMapBottom$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	ecx, DWORD PTR _iTopLatitude$[ebp]
	mov	DWORD PTR [ecx], eax

; 684  : 	iBottomLatitude = abs(iBottomLatitude + iMapBottom);

	mov	edx, DWORD PTR _iBottomLatitude$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _iMapBottom$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	ecx, DWORD PTR _iBottomLatitude$[ebp]
	mov	DWORD PTR [ecx], eax

; 685  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z ENDP	; CvArea::GetTopAndBottomLatitudes
_TEXT	ENDS
PUBLIC	?GetAreaMaxLatitude@CvArea@@QAEHXZ		; CvArea::GetAreaMaxLatitude
; Function compile flags: /Odtp
;	COMDAT ?GetAreaMaxLatitude@CvArea@@QAEHXZ
_TEXT	SEGMENT
tv71 = -20						; size = 4
_this$ = -16						; size = 4
$T218464 = -12						; size = 4
_iBottomLatitude$ = -8					; size = 4
_iTopLatitude$ = -4					; size = 4
?GetAreaMaxLatitude@CvArea@@QAEHXZ PROC			; CvArea::GetAreaMaxLatitude, COMDAT
; _this$ = ecx

; 690  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 691  : 	int iTopLatitude, iBottomLatitude;
; 692  : 	GetTopAndBottomLatitudes(iTopLatitude, iBottomLatitude);

	lea	eax, DWORD PTR _iBottomLatitude$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTopLatitude$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z ; CvArea::GetTopAndBottomLatitudes

; 693  : 
; 694  : 	return max(iTopLatitude, iBottomLatitude);

	mov	edx, DWORD PTR _iTopLatitude$[ebp]
	cmp	edx, DWORD PTR _iBottomLatitude$[ebp]
	jge	SHORT $LN5@GetAreaMax
	lea	eax, DWORD PTR _iBottomLatitude$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN6@GetAreaMax
$LN5@GetAreaMax:
	lea	ecx, DWORD PTR _iTopLatitude$[ebp]
	mov	DWORD PTR tv71[ebp], ecx
$LN6@GetAreaMax:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T218464[ebp], edx
	mov	eax, DWORD PTR $T218464[ebp]
	mov	eax, DWORD PTR [eax]

; 695  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAreaMaxLatitude@CvArea@@QAEHXZ ENDP			; CvArea::GetAreaMaxLatitude
_TEXT	ENDS
PUBLIC	?GetAreaMinLatitude@CvArea@@QAEHXZ		; CvArea::GetAreaMinLatitude
; Function compile flags: /Odtp
;	COMDAT ?GetAreaMinLatitude@CvArea@@QAEHXZ
_TEXT	SEGMENT
tv71 = -20						; size = 4
_this$ = -16						; size = 4
$T218475 = -12						; size = 4
_iBottomLatitude$ = -8					; size = 4
_iTopLatitude$ = -4					; size = 4
?GetAreaMinLatitude@CvArea@@QAEHXZ PROC			; CvArea::GetAreaMinLatitude, COMDAT
; _this$ = ecx

; 700  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 701  : 	int iTopLatitude, iBottomLatitude;
; 702  : 	GetTopAndBottomLatitudes(iTopLatitude, iBottomLatitude);

	lea	eax, DWORD PTR _iBottomLatitude$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iTopLatitude$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z ; CvArea::GetTopAndBottomLatitudes

; 703  : 
; 704  : 	return min(iTopLatitude, iBottomLatitude);

	mov	edx, DWORD PTR _iBottomLatitude$[ebp]
	cmp	edx, DWORD PTR _iTopLatitude$[ebp]
	jge	SHORT $LN5@GetAreaMin
	lea	eax, DWORD PTR _iBottomLatitude$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN6@GetAreaMin
$LN5@GetAreaMin:
	lea	ecx, DWORD PTR _iTopLatitude$[ebp]
	mov	DWORD PTR tv71[ebp], ecx
$LN6@GetAreaMin:
	mov	edx, DWORD PTR tv71[ebp]
	mov	DWORD PTR $T218475[ebp], edx
	mov	eax, DWORD PTR $T218475[ebp]
	mov	eax, DWORD PTR [eax]

; 705  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAreaMinLatitude@CvArea@@QAEHXZ ENDP			; CvArea::GetAreaMinLatitude
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
PUBLIC	??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z	; operator>><int,6>
PUBLIC	??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z	; operator>><int,80>
EXTRN	?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; ImprovementArrayHelpers::Read
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?read@CvArea@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiVersion$ = -8					; size = 4
_iI$ = -4						; size = 4
_kStream$ = 8						; size = 4
?read@CvArea@@UAEXAAVFDataStream@@@Z PROC		; CvArea::read, COMDAT
; _this$ = ecx

; 709  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 710  : 	int iI;
; 711  : 
; 712  : 	// Init saved data
; 713  : 	reset();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvArea@@QAEXH_N0@Z		; CvArea::reset

; 714  : 
; 715  : 	// Version number to maintain backwards compatibility
; 716  : 	uint uiVersion;
; 717  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 718  : 
; 719  : 	kStream >> m_iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 720  : 	kStream >> m_iNumTiles;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 721  : 	kStream >> m_iNumOwnedTiles;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 722  : 	kStream >> m_iNumRiverEdges;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 723  : 	kStream >> m_iNumUnits;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 724  : 	kStream >> m_iNumCities;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 725  : 	kStream >> m_iTotalPopulation;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 726  : 	kStream >> m_iNumStartingPlots;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 727  : 	kStream >> m_iNumNaturalWonders;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 728  : 	kStream >> m_iTotalFoundValue;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 729  : 
; 730  : 	kStream >> m_Boundaries.m_iNorthEdge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4212				; 00001074H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 731  : 	kStream >> m_Boundaries.m_iSouthEdge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4216				; 00001078H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 732  : 	kStream >> m_Boundaries.m_iEastEdge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4220				; 0000107cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 733  : 	kStream >> m_Boundaries.m_iWestEdge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4224				; 00001080H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 734  : 
; 735  : 	kStream >> m_bWater;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4228				; 00001084H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 736  : 	kStream >> m_bMountains;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4229				; 00001085H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 737  : 
; 738  : 	kStream >> m_aiUnitsPerPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z ; operator>><int,80>
	add	esp, 8

; 739  : 	kStream >> m_aiCitiesPerPlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 364				; 0000016cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z ; operator>><int,80>
	add	esp, 8

; 740  : 	kStream >> m_aiPopulationPerPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 684				; 000002acH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z ; operator>><int,80>
	add	esp, 8

; 741  : 	kStream >> m_aiFreeSpecialist;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1004				; 000003ecH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z ; operator>><int,80>
	add	esp, 8

; 742  : 	kStream >> m_aiNumRevealedTiles;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1324				; 0000052cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z ; operator>><int,80>
	add	esp, 8

; 743  : 
; 744  : 	for(iI=0; iI<MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@read
$LN5@read:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@read:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN4@read

; 745  : 	{
; 746  : 		kStream >> (int&)m_aTargetCities[iI].eOwner;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+1644]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 747  : 		kStream >> m_aTargetCities[iI].iID;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+1648]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 748  : 	}

	jmp	SHORT $LN5@read
$LN4@read:

; 749  : 
; 750  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@read
$LN2@read:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN3@read:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN1@read

; 751  : 	{
; 752  : 		kStream >> m_aaiYieldRateModifier[iI];

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2284]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z ; operator>><int,6>
	add	esp, 8

; 753  : 	}

	jmp	SHORT $LN2@read
$LN1@read:

; 754  : 
; 755  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiNumResources, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4204]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 756  : 
; 757  : 	ImprovementArrayHelpers::Read(kStream, m_paiNumImprovements);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4208]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; ImprovementArrayHelpers::Read
	add	esp, 8

; 758  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?read@CvArea@@UAEXAAVFDataStream@@@Z ENDP		; CvArea::read
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
PUBLIC	??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z	; operator<<<int,6>
PUBLIC	??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ; operator<<<int,80>
EXTRN	?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; ImprovementArrayHelpers::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?write@CvArea@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiVersion$ = -8					; size = 4
_iI$ = -4						; size = 4
_kStream$ = 8						; size = 4
?write@CvArea@@UBEXAAVFDataStream@@@Z PROC		; CvArea::write, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	int iI;
; 765  : 
; 766  : 	// Current version number
; 767  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 768  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 769  : 
; 770  : 	kStream << m_iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 771  : 	kStream << m_iNumTiles;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 772  : 	kStream << m_iNumOwnedTiles;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 773  : 	kStream << m_iNumRiverEdges;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 774  : 	kStream << m_iNumUnits;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 775  : 	kStream << m_iNumCities;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 776  : 	kStream << m_iTotalPopulation;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 777  : 	kStream << m_iNumStartingPlots;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 778  : 	kStream << m_iNumNaturalWonders;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 779  : 	kStream << m_iTotalFoundValue;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 780  : 
; 781  : 	kStream << m_Boundaries.m_iNorthEdge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4212				; 00001074H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 782  : 	kStream << m_Boundaries.m_iSouthEdge;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4216				; 00001078H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 783  : 	kStream << m_Boundaries.m_iEastEdge;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4220				; 0000107cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 784  : 	kStream << m_Boundaries.m_iWestEdge;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4224				; 00001080H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 785  : 
; 786  : 	kStream << m_bWater;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4228				; 00001084H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 787  : 	kStream << m_bMountains;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4229				; 00001085H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 788  : 
; 789  : 	kStream << m_aiUnitsPerPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ; operator<<<int,80>
	add	esp, 8

; 790  : 	kStream << m_aiCitiesPerPlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 364				; 0000016cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ; operator<<<int,80>
	add	esp, 8

; 791  : 	kStream << m_aiPopulationPerPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 684				; 000002acH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ; operator<<<int,80>
	add	esp, 8

; 792  : 	kStream << m_aiFreeSpecialist;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1004				; 000003ecH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ; operator<<<int,80>
	add	esp, 8

; 793  : 	kStream << m_aiNumRevealedTiles;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1324				; 0000052cH
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ; operator<<<int,80>
	add	esp, 8

; 794  : 
; 795  : 	for(iI=0; iI<MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@write
$LN5@write:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN6@write:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN4@write

; 796  : 	{
; 797  : 		kStream << m_aTargetCities[iI].eOwner;

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8+1644]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 798  : 		kStream << m_aTargetCities[iI].iID;

	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8+1648]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 799  : 	}

	jmp	SHORT $LN5@write
$LN4@write:

; 800  : 
; 801  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@write
$LN2@write:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN3@write:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	SHORT $LN1@write

; 802  : 	{
; 803  : 		kStream << m_aaiYieldRateModifier[iI];

	mov	eax, DWORD PTR _iI$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+2284]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z ; operator<<<int,6>
	add	esp, 8

; 804  : 	}

	jmp	SHORT $LN2@write
$LN1@write:

; 805  : 
; 806  : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_paiNumResources, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4204]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
	add	esp, 12					; 0000000cH

; 807  : 	ImprovementArrayHelpers::Write(kStream, m_paiNumImprovements, GC.getNumImprovementInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4208]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; ImprovementArrayHelpers::Write
	add	esp, 12					; 0000000cH

; 808  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write@CvArea@@UBEXAAVFDataStream@@@Z ENDP		; CvArea::write
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z	; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z PROC		; operator<<, COMDAT

; 812  : {

	push	ebp
	mov	ebp, esp

; 813  : 	readFrom.write(saveTo);

	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 814  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 815  : }

	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z	; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z PROC		; operator>>, COMDAT

; 819  : {

	push	ebp
	mov	ebp, esp

; 820  : 	writeTo.read(loadFrom);

	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax

; 821  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 822  : }

	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z ENDP		; operator>>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z PROC	; operator>><int,80>, COMDAT

; 234  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 235  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 236  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator:
	cmp	DWORD PTR _i$[ebp], 80			; 00000050H
	jae	SHORT $LN1@operator

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 239  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 240  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z ENDP	; operator>><int,80>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z PROC		; operator>><int,6>, COMDAT

; 234  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 235  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 236  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator@2:
	cmp	DWORD PTR _i$[ebp], 6
	jae	SHORT $LN1@operator@2

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _writeTo$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 239  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 240  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z ENDP		; operator>><int,6>
_TEXT	ENDS
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_tValue$217978 = -24					; size = 4
_tValue$217973 = -20					; size = 4
_iType$217971 = -16					; size = 4
_bValid$217970 = -9					; size = 1
_iI$217966 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$217966[ebp], 0
	jmp	SHORT $LN7@ReadHashed
$LN6@ReadHashed:
	mov	ecx, DWORD PTR _iI$217966[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$217966[ebp], ecx
$LN7@ReadHashed:
	mov	edx, DWORD PTR _iI$217966[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$217970[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$217971[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$217971[ebp], -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$217973[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$217971[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _iType$217971[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	mov	eax, DWORD PTR _tValue$217973[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN3@ReadHashed:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	movzx	ecx, BYTE PTR _bValid$217970[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$217978[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN2@ReadHashed:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed
$LN8@ReadHashed:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z PROC	; operator<<<int,80>, COMDAT

; 223  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 224  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 225  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator@3:
	cmp	DWORD PTR _i$[ebp], 80			; 00000050H
	jae	SHORT $LN1@operator@3

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _readFrom$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 228  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 229  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ENDP	; operator<<<int,80>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z PROC	; operator<<<int,6>, COMDAT

; 223  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 224  : 	size_t i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 225  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@operator@4:
	cmp	DWORD PTR _i$[ebp], 6
	jae	SHORT $LN1@operator@4

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _readFrom$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 228  : 	}

	jmp	SHORT $LN2@operator@4
$LN1@operator@4:

; 229  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 230  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z ENDP	; operator<<<int,6>
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$217994 = -8					; size = 4
_iI$217990 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$217990[ebp], 0
	jmp	SHORT $LN4@WriteHashe
$LN3@WriteHashe:
	mov	ecx, DWORD PTR _iI$217990[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$217990[ebp], ecx
$LN4@WriteHashe:
	mov	edx, DWORD PTR _iI$217990[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$217990[ebp]
	mov	DWORD PTR _eType$217994[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$217994[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$217990[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe
$LN5@WriteHashe:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
END
