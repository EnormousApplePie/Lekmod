; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTacticalAnalysisMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?Clear@CvTacticalAnalysisCell@@QAEXXZ		; CvTacticalAnalysisCell::Clear
PUBLIC	??0CvTacticalAnalysisCell@@QAE@XZ		; CvTacticalAnalysisCell::CvTacticalAnalysisCell
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ??0CvTacticalAnalysisCell@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvTacticalAnalysisCell@@QAE@XZ PROC			; CvTacticalAnalysisCell::CvTacticalAnalysisCell, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], -1

; 33   : 	Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@CvTacticalAnalysisCell@@QAEXXZ	; CvTacticalAnalysisCell::Clear

; 34   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvTacticalAnalysisCell@@QAE@XZ ENDP			; CvTacticalAnalysisCell::CvTacticalAnalysisCell
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Clear@CvTacticalAnalysisCell@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CvTacticalAnalysisCell@@QAEXXZ PROC		; CvTacticalAnalysisCell::Clear, COMDAT
; _this$ = ecx

; 38   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 	ClearFlags();

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 40   : 	m_pEnemyMilitary = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 41   : 	m_pEnemyCivilian = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 42   : 	m_pNeutralMilitary = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 43   : 	m_pNeutralCivilian = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 44   : 	m_pFriendlyMilitary = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 45   : 	m_pFriendlyCivilian = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 46   : 	m_iDefenseModifier = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 47   : 	m_iDeploymentScore = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 48   : 	m_eTargetType = AI_TACTICAL_TARGET_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 49   : 	m_iDominanceZoneID = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], -1

; 50   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@CvTacticalAnalysisCell@@QAEXXZ ENDP		; CvTacticalAnalysisCell::Clear
_TEXT	ENDS
PUBLIC	?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::CanUseForOperationGathering
; Function compile flags: /Odtp
;	COMDAT ?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T223586 = -12						; size = 4
$T223582 = -8						; size = 4
$T223578 = -4						; size = 4
?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::CanUseForOperationGathering, COMDAT
; _this$ = ecx

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 54   : 	if(IsImpassableTerrain() || IsImpassableTerritory() || GetEnemyMilitaryUnit() || GetNeutralMilitaryUnit() || GetNeutralCivilianUnit() || IsFriendlyTurnEndTile() || IsEnemyCity() || IsNeutralCity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 4
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	$LN1@CanUseForO
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 8
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@CanUseForO
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223578[ebp], ecx
	cmp	DWORD PTR $T223578[ebp], 0
	jne	SHORT $LN1@CanUseForO
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T223582[ebp], eax
	cmp	DWORD PTR $T223582[ebp], 0
	jne	SHORT $LN1@CanUseForO
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T223586[ebp], edx
	cmp	DWORD PTR $T223586[ebp], 0
	jne	SHORT $LN1@CanUseForO
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 128				; 00000080H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@CanUseForO
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 512				; 00000200H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN1@CanUseForO
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1024				; 00000400H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@CanUseForO
$LN1@CanUseForO:

; 55   : 	{
; 56   : 		return false;

	xor	al, al
	jmp	SHORT $LN3@CanUseForO
$LN2@CanUseForO:

; 57   : 	}
; 58   : 
; 59   : 	return true;

	mov	al, 1
$LN3@CanUseForO:

; 60   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::CanUseForOperationGathering
_TEXT	ENDS
PUBLIC	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
; Function compile flags: /Odtp
;	COMDAT ?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T223648 = -12						; size = 4
$T223644 = -8						; size = 4
$T223640 = -4						; size = 4
_bWater$ = 8						; size = 1
?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z PROC ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater, COMDAT
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 	if(bWater != IsWater() || IsImpassableTerrain() || IsImpassableTerritory() || GetEnemyMilitaryUnit() || GetNeutralMilitaryUnit() || GetNeutralCivilianUnit() || IsFriendlyTurnEndTile() || IsEnemyCity() || IsNeutralCity())

	movzx	eax, BYTE PTR _bWater$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 2048				; 00000800H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	ecx, dl
	cmp	eax, ecx
	jne	$LN1@CanUseForO@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 4
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN1@CanUseForO@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@CanUseForO@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223640[ebp], eax
	cmp	DWORD PTR $T223640[ebp], 0
	jne	SHORT $LN1@CanUseForO@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T223644[ebp], edx
	cmp	DWORD PTR $T223644[ebp], 0
	jne	SHORT $LN1@CanUseForO@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T223648[ebp], ecx
	cmp	DWORD PTR $T223648[ebp], 0
	jne	SHORT $LN1@CanUseForO@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 128				; 00000080H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@CanUseForO@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 512				; 00000200H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@CanUseForO@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1024				; 00000400H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@CanUseForO@2
$LN1@CanUseForO@2:

; 65   : 	{
; 66   : 		return false;

	xor	al, al
	jmp	SHORT $LN3@CanUseForO@2
$LN2@CanUseForO@2:

; 67   : 	}
; 68   : 
; 69   : 	return true;

	mov	al, 1
$LN3@CanUseForO@2:

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ENDP ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
_TEXT	ENDS
PUBLIC	??0CvTacticalDominanceZone@@QAE@XZ		; CvTacticalDominanceZone::CvTacticalDominanceZone
; Function compile flags: /Odtp
;	COMDAT ??0CvTacticalDominanceZone@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvTacticalDominanceZone@@QAE@XZ PROC			; CvTacticalDominanceZone::CvTacticalDominanceZone, COMDAT
; _this$ = ecx

; 77   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 	m_iDominanceZoneID = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], -1

; 79   : 	m_eTerritoryType = TACTICAL_TERRITORY_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 80   : 	m_eDominanceFlag = TACTICAL_DOMINANCE_NO_UNITS_VISIBLE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 81   : 	m_eOwner = NO_PLAYER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -1

; 82   : 	m_iCityID = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], -1

; 83   : 	m_iAreaID = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 84   : 	m_iFriendlyStrength = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 85   : 	m_iEnemyStrength = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 86   : 	m_iFriendlyRangedStrength = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 87   : 	m_iEnemyRangedStrength = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 88   : 	m_iFriendlyUnitCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 89   : 	m_iEnemyUnitCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 90   : 	m_iFriendlyRangedUnitCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 91   : 	m_iEnemyRangedUnitCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 92   : 	m_iEnemyNavalUnitCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 93   : 	m_iZoneValue = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 94   : 	m_iRangeClosestEnemyUnit = MAX_INT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 2147483647		; 7fffffffH

; 95   : 	m_bIsWater = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+68], 0

; 96   : 	m_bIsNavalInvasion = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+69], 0

; 97   : 	m_pTempZoneCenter = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 98   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvTacticalDominanceZone@@QAE@XZ ENDP			; CvTacticalDominanceZone::CvTacticalDominanceZone
_TEXT	ENDS
PUBLIC	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
;	COMDAT ?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T223680 = -4						; size = 4
?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ PROC ; CvTacticalDominanceZone::GetClosestCity, COMDAT
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	if(m_eOwner != NO_PLAYER)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], -1
	je	SHORT $LN1@GetClosest

; 104  : 	{
; 105  : 		return GET_PLAYER(m_eOwner).getCity(m_iCityID);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T223680[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR $T223680[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@GetClosest
$LN1@GetClosest:

; 106  : 	}
; 107  : 
; 108  : 	return NULL;

	xor	eax, eax
$LN2@GetClosest:

; 109  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ENDP ; CvTacticalDominanceZone::GetClosestCity
_TEXT	ENDS
PUBLIC	?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z ; CvTacticalDominanceZone::SetClosestCity
; Function compile flags: /Odtp
;	COMDAT ?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T223691 = -4						; size = 4
_pCity$ = 8						; size = 4
?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z PROC ; CvTacticalDominanceZone::SetClosestCity, COMDAT
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 	if(pCity != NULL)

	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN2@SetClosest

; 115  : 	{
; 116  : 		m_iCityID = pCity->GetID();

	mov	eax, DWORD PTR _pCity$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	DWORD PTR $T223691[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T223691[ebp]
	mov	DWORD PTR [edx+16], eax

; 117  : 	}
; 118  : 	else

	jmp	SHORT $LN3@SetClosest
$LN2@SetClosest:

; 119  : 	{
; 120  : 		m_iCityID = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], -1
$LN3@SetClosest:

; 121  : 	}
; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z ENDP ; CvTacticalDominanceZone::SetClosestCity
_TEXT	ENDS
PUBLIC	?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit
; Function compile flags: /Odtp
;	COMDAT ?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit, COMDAT
; _this$ = ecx

; 126  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 	return m_iRangeClosestEnemyUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 128  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit
_TEXT	ENDS
PUBLIC	?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::SetRangeClosestEnemyUnit
; Function compile flags: /Odtp
;	COMDAT ?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iRange$ = 8						; size = 4
?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::SetRangeClosestEnemyUnit, COMDAT
; _this$ = ecx

; 132  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 	m_iRangeClosestEnemyUnit = iRange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iRange$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 134  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::SetRangeClosestEnemyUnit
_TEXT	ENDS
PUBLIC	?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ ; CvTacticalDominanceZone::GetZoneType
; Function compile flags: /Odtp
;	COMDAT ?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ PROC ; CvTacticalDominanceZone::GetZoneType, COMDAT
; _this$ = ecx

; 138  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 	if(m_eTerritoryType == TACTICAL_TERRITORY_FRIENDLY)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $LN12@GetZoneTyp

; 140  : 	{
; 141  : 		if(m_eDominanceFlag == TACTICAL_DOMINANCE_FRIENDLY)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 1
	jne	SHORT $LN11@GetZoneTyp

; 142  : 		{
; 143  : 			return AI_TACTICAL_MOVE_ZONE_FRIENDLY_WINNING;

	xor	eax, eax
	jmp	SHORT $LN13@GetZoneTyp
	jmp	SHORT $LN10@GetZoneTyp
$LN11@GetZoneTyp:

; 144  : 		}
; 145  : 		else if(m_eDominanceFlag == TACTICAL_DOMINANCE_EVEN)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 3
	jne	SHORT $LN9@GetZoneTyp

; 146  : 		{
; 147  : 			return AI_TACTICAL_MOVE_ZONE_FRIENDLY_EVEN;

	mov	eax, 1
	jmp	SHORT $LN13@GetZoneTyp

; 148  : 		}
; 149  : 		else

	jmp	SHORT $LN10@GetZoneTyp
$LN9@GetZoneTyp:

; 150  : 		{
; 151  : 			return AI_TACTICAL_MOVE_ZONE_FRIENDLY_LOSING;

	mov	eax, 2
	jmp	SHORT $LN13@GetZoneTyp
$LN10@GetZoneTyp:

; 152  : 		}

	jmp	SHORT $LN13@GetZoneTyp
$LN12@GetZoneTyp:

; 153  : 	}
; 154  : 
; 155  : 	else if(m_eTerritoryType == TACTICAL_TERRITORY_ENEMY)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 3
	jne	SHORT $LN6@GetZoneTyp

; 156  : 	{
; 157  : 		if(m_eDominanceFlag == TACTICAL_DOMINANCE_FRIENDLY)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 1
	jne	SHORT $LN5@GetZoneTyp

; 158  : 		{
; 159  : 			return AI_TACTICAL_MOVE_ZONE_ENEMY_WINNING;

	mov	eax, 3
	jmp	SHORT $LN13@GetZoneTyp
	jmp	SHORT $LN4@GetZoneTyp
$LN5@GetZoneTyp:

; 160  : 		}
; 161  : 		else if(m_eDominanceFlag == TACTICAL_DOMINANCE_EVEN)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 3
	jne	SHORT $LN3@GetZoneTyp

; 162  : 		{
; 163  : 			return AI_TACTICAL_MOVE_ZONE_ENEMY_EVEN;

	mov	eax, 4
	jmp	SHORT $LN13@GetZoneTyp

; 164  : 		}
; 165  : 		else

	jmp	SHORT $LN4@GetZoneTyp
$LN3@GetZoneTyp:

; 166  : 		{
; 167  : 			return AI_TACTICAL_MOVE_ZONE_ENEMY_LOSING;

	mov	eax, 5
	jmp	SHORT $LN13@GetZoneTyp
$LN4@GetZoneTyp:

; 168  : 		}
; 169  : 	}
; 170  : 
; 171  : 	else

	jmp	SHORT $LN13@GetZoneTyp
$LN6@GetZoneTyp:

; 172  : 	{
; 173  : 		return AI_TACTICAL_MOVE_ZONE_UNOWNED;

	mov	eax, 6
$LN13@GetZoneTyp:

; 174  : 	}
; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ ENDP ; CvTacticalDominanceZone::GetZoneType
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
PUBLIC	??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvUnit *,250,1,297,0>::FStaticVector<CvUnit *,250,1,297,0>
PUBLIC	??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::FStaticVector<CvTacticalDominanceZone,110,1,297,0>
PUBLIC	??0CvTacticalAnalysisMap@@QAE@XZ		; CvTacticalAnalysisMap::CvTacticalAnalysisMap
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvTacticalAnalysisMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTacticalAnalysisMap@@QAE@XZ$0
__ehfuncinfo$??0CvTacticalAnalysisMap@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTacticalAnalysisMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ??0CvTacticalAnalysisMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T223744 = -36						; size = 4
_i$223739 = -32						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTacticalAnalysisMap@@QAE@XZ PROC			; CvTacticalAnalysisMap::CvTacticalAnalysisMap, COMDAT
; _this$ = ecx

; 189  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTacticalAnalysisMap@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 25			; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+32], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0CvTacticalDominanceZone@@QAE@XZ	; CvTacticalDominanceZone::CvTacticalDominanceZone
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::FStaticVector<CvTacticalDominanceZone,110,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8488				; 00002128H
	call	??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvUnit *,250,1,297,0>::FStaticVector<CvUnit *,250,1,297,0>

; 190  : 	m_bIsBuilt = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+34], 0

; 191  : 	m_iTurnBuilt = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], -1

; 192  : 	m_bAtWar = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+33], 0

; 193  : 	m_DominanceZones.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	mov	DWORD PTR $T223744[ebp], edx
	xor	eax, eax
	je	SHORT $LN29@CvTactical
	mov	DWORD PTR _i$223739[ebp], 0
	jmp	SHORT $LN27@CvTactical
$LN26@CvTactical:
	mov	ecx, DWORD PTR _i$223739[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$223739[ebp], ecx
$LN27@CvTactical:
	mov	edx, DWORD PTR $T223744[ebp]
	mov	eax, DWORD PTR _i$223739[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN29@CvTactical
	jmp	SHORT $LN26@CvTactical
$LN29@CvTactical:
	mov	ecx, DWORD PTR $T223744[ebp]
	mov	DWORD PTR [ecx+4], 0

; 194  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTacticalAnalysisMap@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
__ehhandler$??0CvTacticalAnalysisMap@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTacticalAnalysisMap@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTacticalAnalysisMap@@QAE@XZ ENDP			; CvTacticalAnalysisMap::CvTacticalAnalysisMap
PUBLIC	??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvUnit *,250,1,297,0>::~FStaticVector<CvUnit *,250,1,297,0>
PUBLIC	??1CvTacticalAnalysisMap@@QAE@XZ		; CvTacticalAnalysisMap::~CvTacticalAnalysisMap
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvTacticalAnalysisMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTacticalAnalysisMap@@QAE@XZ$0
__ehfuncinfo$??1CvTacticalAnalysisMap@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTacticalAnalysisMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ??1CvTacticalAnalysisMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T223765 = -20						; size = 4
$T223763 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTacticalAnalysisMap@@QAE@XZ PROC			; CvTacticalAnalysisMap::~CvTacticalAnalysisMap, COMDAT
; _this$ = ecx

; 198  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTacticalAnalysisMap@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 199  : 	SAFE_DELETE_ARRAY(m_pPlots);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T223765[ebp], eax
	mov	ecx, DWORD PTR $T223765[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T223763[ebp], edx
	mov	eax, DWORD PTR $T223763[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T223765[ebp]
	mov	DWORD PTR [ecx], 0

; 200  : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8488				; 00002128H
	call	??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvUnit *,250,1,297,0>::~FStaticVector<CvUnit *,250,1,297,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTacticalAnalysisMap@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
__ehhandler$??1CvTacticalAnalysisMap@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTacticalAnalysisMap@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTacticalAnalysisMap@@QAE@XZ ENDP			; CvTacticalAnalysisMap::~CvTacticalAnalysisMap
PUBLIC	?Init@CvTacticalAnalysisMap@@QAEXH@Z		; CvTacticalAnalysisMap::Init
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?Init@CvTacticalAnalysisMap@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvTacticalAnalysisMap@@QAEXH@Z$0
__ehfuncinfo$?Init@CvTacticalAnalysisMap@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Init@CvTacticalAnalysisMap@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvTacticalAnalysisMap@@QAEXH@Z
_TEXT	SEGMENT
tv83 = -52						; size = 4
_this$ = -48						; size = 4
$T223850 = -44						; size = 4
$T223846 = -40						; size = 4
$T223845 = -36						; size = 4
$T223839 = -32						; size = 4
$T223837 = -28						; size = 4
$T223830 = -24						; size = 4
$T223829 = -20						; size = 4
$T223828 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iNumPlots$ = 8						; size = 4
?Init@CvTacticalAnalysisMap@@QAEXH@Z PROC		; CvTacticalAnalysisMap::Init, COMDAT
; _this$ = ecx

; 204  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Init@CvTacticalAnalysisMap@@QAEXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 205  : 	// Time building of these maps
; 206  : 	AI_PERF("AI-perf-tact.csv", "CvTacticalAnalysisMap::Init()" );
; 207  : 
; 208  : 	if(m_pPlots)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Init

; 209  : 	{
; 210  : 		SAFE_DELETE_ARRAY(m_pPlots);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T223839[ebp], ecx
	mov	edx, DWORD PTR $T223839[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223837[ebp], eax
	mov	ecx, DWORD PTR $T223837[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T223839[ebp]
	mov	DWORD PTR [edx], 0
$LN1@Init:

; 211  : 	}
; 212  : 	m_pPlots = FNEW(CvTacticalAnalysisCell[iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _iNumPlots$[ebp]
	mov	DWORD PTR $T223828[ebp], eax
	xor	ecx, ecx
	mov	eax, DWORD PTR $T223828[ebp]
	mov	edx, 44					; 0000002cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T223830[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T223830[ebp], 0
	je	SHORT $LN4@Init
	mov	eax, DWORD PTR $T223828[ebp]
	mov	DWORD PTR $T223846[ebp], eax
	mov	ecx, DWORD PTR $T223830[ebp]
	mov	DWORD PTR $T223845[ebp], ecx
$LN10@Init:
	mov	edx, DWORD PTR $T223846[ebp]
	sub	edx, 1
	mov	DWORD PTR $T223846[ebp], edx
	js	SHORT $LN11@Init
	mov	ecx, DWORD PTR $T223845[ebp]
	call	??0CvTacticalAnalysisCell@@QAE@XZ	; CvTacticalAnalysisCell::CvTacticalAnalysisCell
	mov	eax, DWORD PTR $T223845[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T223845[ebp], eax
	jmp	SHORT $LN10@Init
$LN11@Init:
	mov	ecx, DWORD PTR $T223830[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN5@Init
$LN4@Init:
	mov	DWORD PTR tv83[ebp], 0
$LN5@Init:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T223829[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T223829[ebp]
	mov	DWORD PTR [eax+12], ecx

; 213  : 	m_iNumPlots = iNumPlots;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iNumPlots$[ebp]
	mov	DWORD PTR [edx+16], eax

; 214  : 
; 215  : 	m_iDominancePercentage = GC.getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2444
	mov	DWORD PTR $T223850[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T223850[ebp]
	mov	DWORD PTR [edx], eax

; 216  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvTacticalAnalysisMap@@QAEXH@Z$0:
	mov	eax, DWORD PTR $T223830[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?Init@CvTacticalAnalysisMap@@QAEXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Init@CvTacticalAnalysisMap@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvTacticalAnalysisMap@@QAEXH@Z ENDP		; CvTacticalAnalysisMap::Init
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $LN2@vector
$LN3@vector:
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::MarkCellsNearEnemy
PUBLIC	?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::BuildEnemyUnitList
PUBLIC	?LogZones@CvTacticalAnalysisMap@@IAEXXZ		; CvTacticalAnalysisMap::LogZones
PUBLIC	?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ	; CvTacticalAnalysisMap::PrioritizeZones
PUBLIC	?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::CalculateMilitaryStrengths
PUBLIC	?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z ; CvTacticalAnalysisMap::AddToDominanceZones
PUBLIC	?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z ; CvTacticalAnalysisMap::PopulateCell
PUBLIC	?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::AddTemporaryZones
PUBLIC	?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z ; CvTacticalAnalysisMap::RefreshDataForNextPlayer
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?getCurrentEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getCurrentEra
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Odtp
;	COMDAT ?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T223911 = -48						; size = 4
$T223907 = -44						; size = 4
$T223903 = -40						; size = 4
$T223899 = -36						; size = 4
_i$223894 = -32						; size = 4
$T223880 = -28						; size = 4
$T223876 = -24						; size = 4
$T223872 = -20						; size = 4
$T223868 = -16						; size = 4
$T223864 = -12						; size = 4
_pPlot$221471 = -8					; size = 4
_iI$221467 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z PROC ; CvTacticalAnalysisMap::RefreshDataForNextPlayer, COMDAT
; _this$ = ecx

; 220  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 	if(m_pPlots)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$LN11@RefreshDat

; 222  : 	{
; 223  : 		if(pPlayer != m_pPlayer || m_iTurnBuilt < GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pPlayer$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	jne	SHORT $LN8@RefreshDat
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223864[ebp], eax
	mov	ecx, DWORD PTR $T223864[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	jge	$LN11@RefreshDat
$LN8@RefreshDat:

; 224  : 		{
; 225  : 			m_pPlayer = pPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [edx+20], eax

; 226  : 			m_iTurnBuilt = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223868[ebp], ecx
	mov	ecx, DWORD PTR $T223868[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], eax

; 227  : 			m_iTacticalRange = ((GC.getAI_TACTICAL_RECRUIT_RANGE() + GC.getGame().getCurrentEra()) * 2) / 3;  // Have this increase as game goes on

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2460
	mov	DWORD PTR $T223872[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T223876[ebp], ecx
	mov	ecx, DWORD PTR $T223876[ebp]
	call	?getCurrentEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getCurrentEra
	add	eax, DWORD PTR $T223872[ebp]
	shl	eax, 1
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 228  : 			m_iUnitStrengthMultiplier = GC.getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER() * m_iTacticalRange;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2440
	mov	DWORD PTR $T223880[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T223880[ebp]
	imul	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 229  : 
; 230  : #ifdef AUI_PERF_LOGGING_FORMATTING_TWEAKS
; 231  : 			AI_PERF_FORMAT("AI-perf.csv", ("Tactical Analysis Map, Turn %03d, %s", GC.getGame().getGameTurn(), m_pPlayer->getCivilizationShortDescription()));
; 232  : #else
; 233  : 			AI_PERF_FORMAT("AI-perf.csv", ("Tactical Analysis Map, Turn %d, %s", GC.getGame().getGameTurn(), m_pPlayer->getCivilizationShortDescription()) );
; 234  : #endif
; 235  : 
; 236  : 			m_bIsBuilt = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+34], 0

; 237  : 
; 238  : 			// AI civs build this map every turn
; 239  : 			//if (!m_pPlayer->isHuman() && !m_pPlayer->isBarbarian())
; 240  : 			if(!m_pPlayer->isBarbarian())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	$LN11@RefreshDat

; 241  : 			{
; 242  : 				m_DominanceZones.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T223899[ebp], ecx
	xor	edx, edx
	je	SHORT $LN29@RefreshDat
	mov	DWORD PTR _i$223894[ebp], 0
	jmp	SHORT $LN27@RefreshDat
$LN26@RefreshDat:
	mov	eax, DWORD PTR _i$223894[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223894[ebp], eax
$LN27@RefreshDat:
	mov	ecx, DWORD PTR $T223899[ebp]
	mov	edx, DWORD PTR _i$223894[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN29@RefreshDat
	jmp	SHORT $LN26@RefreshDat
$LN29@RefreshDat:
	mov	eax, DWORD PTR $T223899[ebp]
	mov	DWORD PTR [eax+4], 0

; 243  : 
; 244  : 				AddTemporaryZones();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::AddTemporaryZones

; 245  : 
; 246  : #ifdef AUI_WARNING_FIXES
; 247  : 				for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 248  : #else
; 249  : 				for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$221467[ebp], 0
	jmp	SHORT $LN6@RefreshDat
$LN5@RefreshDat:
	mov	ecx, DWORD PTR _iI$221467[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221467[ebp], ecx
$LN6@RefreshDat:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223903[ebp], edx
	mov	eax, DWORD PTR $T223903[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T223907[ebp], ecx
	mov	edx, DWORD PTR _iI$221467[ebp]
	cmp	edx, DWORD PTR $T223907[ebp]
	jge	SHORT $LN4@RefreshDat

; 250  : #endif
; 251  : 				{
; 252  : 					CvAssertMsg((iI < m_iNumPlots), "Plot to be accessed exceeds allocation!");
; 253  : 
; 254  : 					CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T223911[ebp], eax
	mov	ecx, DWORD PTR _iI$221467[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T223911[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$221471[ebp], ecx

; 255  : 					if(pPlot == NULL)

	jne	SHORT $LN3@RefreshDat

; 256  : 					{
; 257  : 						// Erase this cell
; 258  : 						m_pPlots[iI].Clear();

	mov	ecx, DWORD PTR _iI$221467[ebp]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+12]
	call	?Clear@CvTacticalAnalysisCell@@QAEXXZ	; CvTacticalAnalysisCell::Clear

; 259  : 					}
; 260  : 					else

	jmp	SHORT $LN2@RefreshDat
$LN3@RefreshDat:

; 261  : 					{
; 262  : 						if(PopulateCell(iI, pPlot))

	mov	ecx, DWORD PTR _pPlot$221471[ebp]
	push	ecx
	mov	edx, DWORD PTR _iI$221467[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z ; CvTacticalAnalysisMap::PopulateCell
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@RefreshDat

; 263  : 						{
; 264  : 							AddToDominanceZones(iI, &m_pPlots[iI]);

	mov	ecx, DWORD PTR _iI$221467[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+12]
	push	ecx
	mov	eax, DWORD PTR _iI$221467[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z ; CvTacticalAnalysisMap::AddToDominanceZones
$LN2@RefreshDat:

; 265  : 						}
; 266  : 					}
; 267  : 				}

	jmp	$LN5@RefreshDat
$LN4@RefreshDat:

; 268  : 
; 269  : 				CalculateMilitaryStrengths();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::CalculateMilitaryStrengths

; 270  : 				PrioritizeZones();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::PrioritizeZones

; 271  : 				LogZones();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogZones@CvTacticalAnalysisMap@@IAEXXZ	; CvTacticalAnalysisMap::LogZones

; 272  : 				BuildEnemyUnitList();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::BuildEnemyUnitList

; 273  : 				MarkCellsNearEnemy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::MarkCellsNearEnemy

; 274  : 
; 275  : 				m_bIsBuilt = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+34], 1
$LN11@RefreshDat:

; 276  : 			}
; 277  : 		}
; 278  : 	}
; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z ENDP ; CvTacticalAnalysisMap::RefreshDataForNextPlayer
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z ; FStaticVector<CvUnit *,250,1,297,0>::push_back
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Odtp
;	COMDAT ?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T223972 = -52						; size = 4
$T223968 = -48						; size = 4
$T223967 = -44						; size = 4
$T223958 = -37						; size = 1
$T223938 = -36						; size = 4
_i$223933 = -32						; size = 4
_pLoopUnit$221489 = -28					; size = 4
_iLoop$221488 = -24					; size = 4
_ePlayer$221483 = -20					; size = 4
_eTeam$221486 = -16					; size = 4
_kPlayer$221485 = -12					; size = 4
_iPlayer$221479 = -8					; size = 4
_enemy$ = -4						; size = 4
?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::BuildEnemyUnitList, COMDAT
; _this$ = ecx

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 284  : 	CvTacticalAnalysisEnemy enemy;

	mov	DWORD PTR _enemy$[ebp], 0

; 285  : 	m_EnemyUnits.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8488				; 00002128H
	mov	DWORD PTR $T223938[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN19@BuildEnemy
	mov	DWORD PTR _i$223933[ebp], 0
	jmp	SHORT $LN17@BuildEnemy
$LN16@BuildEnemy:
	mov	edx, DWORD PTR _i$223933[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223933[ebp], edx
$LN17@BuildEnemy:
	mov	eax, DWORD PTR $T223938[ebp]
	mov	ecx, DWORD PTR _i$223933[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN19@BuildEnemy
	jmp	SHORT $LN16@BuildEnemy
$LN19@BuildEnemy:
	mov	edx, DWORD PTR $T223938[ebp]
	mov	DWORD PTR [edx+4], 0

; 286  : 
; 287  : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)

	mov	DWORD PTR _iPlayer$221479[ebp], 0
	jmp	SHORT $LN8@BuildEnemy
$LN7@BuildEnemy:
	mov	eax, DWORD PTR _iPlayer$221479[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayer$221479[ebp], eax
$LN8@BuildEnemy:
	cmp	DWORD PTR _iPlayer$221479[ebp], 64	; 00000040H
	jge	$LN9@BuildEnemy

; 288  : 	{
; 289  : 		const PlayerTypes ePlayer = (PlayerTypes)iPlayer;

	mov	ecx, DWORD PTR _iPlayer$221479[ebp]
	mov	DWORD PTR _ePlayer$221483[ebp], ecx

; 290  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	edx, DWORD PTR _ePlayer$221483[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$221485[ebp], edx

; 291  : 		const TeamTypes eTeam = kPlayer.getTeam();

	mov	eax, DWORD PTR _kPlayer$221485[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$221486[ebp], eax

; 292  : 
; 293  : 		// for each opposing civ
; 294  : 		if(kPlayer.isAlive() && GET_TEAM(eTeam).isAtWar(m_pPlayer->getTeam()))

	mov	edx, DWORD PTR _kPlayer$221485[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T223958[ebp], al
	movzx	ecx, BYTE PTR $T223958[ebp]
	test	ecx, ecx
	je	$LN5@BuildEnemy
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T223967[ebp], eax
	mov	ecx, DWORD PTR $T223967[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T223968[ebp], eax
	mov	eax, DWORD PTR _eTeam$221486[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T223972[ebp], eax
	mov	ecx, DWORD PTR $T223968[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T223972[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@BuildEnemy

; 295  : 		{
; 296  : 			int iLoop;
; 297  : 			CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$221489[ebp], 0

; 298  : 			for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$221488[ebp]
	push	eax
	mov	ecx, DWORD PTR _kPlayer$221485[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$221489[ebp], eax
	jmp	SHORT $LN4@BuildEnemy
$LN3@BuildEnemy:
	push	0
	lea	ecx, DWORD PTR _iLoop$221488[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$221485[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$221489[ebp], eax
$LN4@BuildEnemy:
	cmp	DWORD PTR _pLoopUnit$221489[ebp], 0
	je	SHORT $LN5@BuildEnemy

; 299  : 			{
; 300  : 				// Make sure this unit can attack
; 301  : 				if(pLoopUnit->IsCanAttack())

	mov	ecx, DWORD PTR _pLoopUnit$221489[ebp]
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@BuildEnemy

; 302  : 				{
; 303  : 					m_EnemyUnits.push_back(pLoopUnit);

	lea	eax, DWORD PTR _pLoopUnit$221489[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8488				; 00002128H
	call	?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z ; FStaticVector<CvUnit *,250,1,297,0>::push_back
$LN1@BuildEnemy:

; 304  : 				}

	jmp	SHORT $LN3@BuildEnemy
$LN5@BuildEnemy:

; 305  : 			}

	jmp	$LN7@BuildEnemy
$LN9@BuildEnemy:

; 306  : 		}
; 307  : 	}
; 308  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::BuildEnemyUnitList
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
EXTRN	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetNearbyEnemyDamage
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
EXTRN	?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isVisibleToEnemyTeam
; Function compile flags: /Odtp
;	COMDAT ?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
tv290 = -272						; size = 4
tv289 = -268						; size = 4
_this$ = -264						; size = 4
$T224437 = -260						; size = 4
$T224424 = -256						; size = 4
$T224423 = -252						; size = 4
$T224414 = -248						; size = 4
$T224405 = -244						; size = 4
$T224401 = -240						; size = 4
$T224241 = -164						; size = 4
$T224237 = -160						; size = 4
$T224225 = -156						; size = 4
$T224212 = -152						; size = 4
$T224199 = -148						; size = 4
$T224189 = -144						; size = 4
$T224176 = -140						; size = 4
$T224126 = -92						; size = 4
$T224117 = -88						; size = 4
$T224108 = -84						; size = 4
$T224104 = -80						; size = 4
$T224100 = -76						; size = 4
$T224093 = -72						; size = 4
$T224089 = -68						; size = 4
$T224076 = -64						; size = 4
$T224075 = -60						; size = 4
$T224031 = -56						; size = 4
$T224027 = -52						; size = 4
$T224023 = -48						; size = 4
$T224018 = -44						; size = 4
_eImprovement$221530 = -40				; size = 4
_jJ$221523 = -36					; size = 4
_pAdjacentPlot$221522 = -32				; size = 4
_iTurnsToReach$221517 = -28				; size = 4
_pUnit$221512 = -24					; size = 4
_iUnitIndex$221508 = -20				; size = 4
_pPlot$221503 = -16					; size = 4
_bMarkedIt$221502 = -9					; size = 1
_iI$221498 = -8						; size = 4
_iDistance$ = -4					; size = 4
?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::MarkCellsNearEnemy, COMDAT
; _this$ = ecx

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 	int iDistance;
; 314  : 
; 315  : 	// Look at every cell on the map
; 316  : #ifdef AUI_WARNING_FIXES
; 317  : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 318  : #else
; 319  : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$221498[ebp], 0
	jmp	SHORT $LN23@MarkCellsN
$LN22@MarkCellsN:
	mov	eax, DWORD PTR _iI$221498[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221498[ebp], eax
$LN23@MarkCellsN:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224023[ebp], ecx
	mov	edx, DWORD PTR $T224023[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T224027[ebp], eax
	mov	ecx, DWORD PTR _iI$221498[ebp]
	cmp	ecx, DWORD PTR $T224027[ebp]
	jge	$LN24@MarkCellsN

; 320  : #endif
; 321  : 	{
; 322  : 		bool bMarkedIt = false;   // Set true once we've found one that enemy can move past (worst case)

	mov	BYTE PTR _bMarkedIt$221502[ebp], 0

; 323  : 
; 324  : 		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224031[ebp], edx
	mov	eax, DWORD PTR _iI$221498[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T224031[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pPlot$221503[ebp], eax

; 325  : 		if(m_pPlots[iI].IsRevealed() && !m_pPlots[iI].IsImpassableTerrain() && !m_pPlots[iI].IsImpassableTerritory())

	mov	edx, DWORD PTR _iI$221498[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 1
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN20@MarkCellsN
	mov	ecx, DWORD PTR _iI$221498[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	and	ecx, 4
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	$LN20@MarkCellsN
	mov	eax, DWORD PTR _iI$221498[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN20@MarkCellsN

; 326  : 		{
; 327  : 			// Friendly cities always safe
; 328  : 			if(!m_pPlots[iI].IsFriendlyCity())

	mov	edx, DWORD PTR _iI$221498[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 256				; 00000100H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	$LN20@MarkCellsN

; 329  : 			{
; 330  : 				if(!pPlot->isVisibleToEnemyTeam(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T224075[ebp], edx
	mov	eax, DWORD PTR $T224075[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224076[ebp], eax
	mov	edx, DWORD PTR $T224076[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$221503[ebp]
	call	?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isVisibleToEnemyTeam
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@MarkCellsN

; 331  : 				{
; 332  : 					m_pPlots[iI].SetNotVisibleToEnemy(true);

	mov	ecx, DWORD PTR _iI$221498[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR $T224089[ebp], ecx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN58@MarkCellsN
	mov	ecx, DWORD PTR $T224089[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR $T224089[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN55@MarkCellsN
$LN58@MarkCellsN:
	mov	ecx, 16					; 00000010H
	not	ecx
	mov	edx, DWORD PTR $T224089[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR $T224089[ebp]
	mov	DWORD PTR [eax], ecx
$LN55@MarkCellsN:

; 333  : 				}
; 334  : 				else

	jmp	$LN20@MarkCellsN
$LN18@MarkCellsN:

; 335  : 				{
; 336  : 					for(unsigned int iUnitIndex = 0;  iUnitIndex < m_EnemyUnits.size() && !bMarkedIt; iUnitIndex++)

	mov	DWORD PTR _iUnitIndex$221508[ebp], 0
	jmp	SHORT $LN16@MarkCellsN
$LN15@MarkCellsN:
	mov	ecx, DWORD PTR _iUnitIndex$221508[ebp]
	add	ecx, 1
	mov	DWORD PTR _iUnitIndex$221508[ebp], ecx
$LN16@MarkCellsN:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8492]
	mov	DWORD PTR $T224093[ebp], eax
	mov	ecx, DWORD PTR _iUnitIndex$221508[ebp]
	cmp	ecx, DWORD PTR $T224093[ebp]
	jae	$LN132@MarkCellsN
	movzx	edx, BYTE PTR _bMarkedIt$221502[ebp]
	test	edx, edx
	jne	$LN132@MarkCellsN

; 337  : 					{
; 338  : 						CvUnit* pUnit = m_EnemyUnits[iUnitIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8488]
	mov	edx, DWORD PTR _iUnitIndex$221508[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _pUnit$221512[ebp], eax

; 339  : 						if(pUnit->getArea() == pPlot->getArea())

	mov	ecx, DWORD PTR _pPlot$221503[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T224100[ebp], edx
	mov	ecx, DWORD PTR _pUnit$221512[ebp]
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	cmp	eax, DWORD PTR $T224100[ebp]
	jne	$LN13@MarkCellsN

; 340  : 						{
; 341  : 							// Distance check before hitting pathfinder
; 342  : 							iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$221503[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224104[ebp], ecx
	mov	edx, DWORD PTR _pPlot$221503[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224108[ebp], eax
	mov	ecx, DWORD PTR _pUnit$221512[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T224117[ebp], edx
	mov	eax, DWORD PTR _pUnit$221512[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T224126[ebp], ecx
	mov	edx, DWORD PTR $T224104[ebp]
	push	edx
	mov	eax, DWORD PTR $T224108[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224117[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224126[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$[ebp], eax

; 343  : 							if(iDistance == 0)

	cmp	DWORD PTR _iDistance$[ebp], 0
	jne	$LN12@MarkCellsN

; 344  : 							{
; 345  : 								m_pPlots[iI].SetSubjectToAttack(true);

	mov	eax, DWORD PTR _iI$221498[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T224176[ebp], eax
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN106@MarkCellsN
	mov	eax, DWORD PTR $T224176[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR $T224176[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN103@MarkCellsN
$LN106@MarkCellsN:
	mov	eax, 32					; 00000020H
	not	eax
	mov	ecx, DWORD PTR $T224176[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR $T224176[ebp]
	mov	DWORD PTR [edx], eax
$LN103@MarkCellsN:

; 346  : 								m_pPlots[iI].SetEnemyCanMovePast(true);

	mov	eax, DWORD PTR _iI$221498[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T224189[ebp], eax
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN112@MarkCellsN
	mov	eax, DWORD PTR $T224189[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR $T224189[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN109@MarkCellsN
$LN112@MarkCellsN:
	mov	eax, 64					; 00000040H
	not	eax
	mov	ecx, DWORD PTR $T224189[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR $T224189[ebp]
	mov	DWORD PTR [edx], eax
$LN109@MarkCellsN:

; 347  : 								bMarkedIt = true;

	mov	BYTE PTR _bMarkedIt$221502[ebp], 1
	jmp	$LN13@MarkCellsN
$LN12@MarkCellsN:

; 348  : 							}
; 349  : 
; 350  : 							// TEMPORARY OPTIMIZATION: Assumes can't use roads or RR
; 351  : 							else if(iDistance <= pUnit->baseMoves())

	push	-1
	mov	ecx, DWORD PTR _pUnit$221512[ebp]
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	cmp	DWORD PTR _iDistance$[ebp], eax
	jg	$LN13@MarkCellsN

; 352  : 							{
; 353  : 								int iTurnsToReach;
; 354  : 								iTurnsToReach = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, true /*bIgnoreUnits*/);	// Its ok to reuse paths because when ignoring units, we don't use the tactical analysis map (which we are building)

	push	0
	push	1
	push	1
	mov	eax, DWORD PTR _pPlot$221503[ebp]
	push	eax
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T224018[ebp], esp
	mov	DWORD PTR $T224199[ebp], ecx
	mov	edx, DWORD PTR $T224199[ebp]
	mov	eax, DWORD PTR _pUnit$221512[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T224199[ebp]
	mov	BYTE PTR [ecx+4], 0
	mov	edx, DWORD PTR $T224199[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN116@MarkCellsN
	mov	eax, DWORD PTR $T224199[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN116@MarkCellsN:
	mov	ecx, DWORD PTR $T224199[ebp]
	mov	DWORD PTR tv289[ebp], ecx
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv290[ebp], eax
	mov	edx, DWORD PTR tv290[ebp]
	mov	DWORD PTR _iTurnsToReach$221517[ebp], edx

; 355  : 								if(iTurnsToReach <= 1)

	cmp	DWORD PTR _iTurnsToReach$221517[ebp], 1
	jg	SHORT $LN9@MarkCellsN

; 356  : 								{
; 357  : 									m_pPlots[iI].SetSubjectToAttack(true);

	mov	eax, DWORD PTR _iI$221498[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T224212[ebp], eax
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN123@MarkCellsN
	mov	eax, DWORD PTR $T224212[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR $T224212[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN9@MarkCellsN
$LN123@MarkCellsN:
	mov	eax, 32					; 00000020H
	not	eax
	mov	ecx, DWORD PTR $T224212[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR $T224212[ebp]
	mov	DWORD PTR [edx], eax
$LN9@MarkCellsN:

; 358  : 								}
; 359  : 								if(iTurnsToReach == 0)

	cmp	DWORD PTR _iTurnsToReach$221517[ebp], 0
	jne	SHORT $LN13@MarkCellsN

; 360  : 								{
; 361  : 									m_pPlots[iI].SetEnemyCanMovePast(true);

	mov	eax, DWORD PTR _iI$221498[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T224225[ebp], eax
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN129@MarkCellsN
	mov	eax, DWORD PTR $T224225[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR $T224225[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN126@MarkCellsN
$LN129@MarkCellsN:
	mov	eax, 64					; 00000040H
	not	eax
	mov	ecx, DWORD PTR $T224225[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR $T224225[ebp]
	mov	DWORD PTR [edx], eax
$LN126@MarkCellsN:

; 362  : 									bMarkedIt = true;

	mov	BYTE PTR _bMarkedIt$221502[ebp], 1
$LN13@MarkCellsN:

; 363  : 								}
; 364  : 							}
; 365  : 						}
; 366  : 					}

	jmp	$LN15@MarkCellsN

; 367  : 
; 368  : 					// Check adjacent plots for enemy citadels
; 369  : 					if(!m_pPlots[iI].IsSubjectToAttack())

$LN132@MarkCellsN:
	mov	eax, DWORD PTR _iI$221498[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN20@MarkCellsN

; 370  : 					{
; 371  : 						CvPlot* pAdjacentPlot;
; 372  : 						for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	DWORD PTR _jJ$221523[ebp], 0
	jmp	SHORT $LN6@MarkCellsN
$LN5@MarkCellsN:
	mov	edx, DWORD PTR _jJ$221523[ebp]
	add	edx, 1
	mov	DWORD PTR _jJ$221523[ebp], edx
$LN6@MarkCellsN:
	cmp	DWORD PTR _jJ$221523[ebp], 6
	jge	$LN20@MarkCellsN

; 373  : 						{
; 374  : 							pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)jJ));

	mov	eax, DWORD PTR _pPlot$221503[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224237[ebp], ecx
	mov	edx, DWORD PTR _pPlot$221503[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224241[ebp], eax
	mov	ecx, DWORD PTR _jJ$221523[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224237[ebp]
	push	edx
	mov	eax, DWORD PTR $T224241[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$221522[ebp], eax

; 375  : 							if(pAdjacentPlot != NULL && pAdjacentPlot->getOwner() != NO_PLAYER)

	cmp	DWORD PTR _pAdjacentPlot$221522[ebp], 0
	je	$LN3@MarkCellsN
	mov	ecx, DWORD PTR _pAdjacentPlot$221522[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, -1
	je	$LN3@MarkCellsN

; 376  : 							{
; 377  : 								if(atWar(m_pPlayer->getTeam(), GET_PLAYER(pAdjacentPlot->getOwner()).getTeam()))

	mov	eax, DWORD PTR _pAdjacentPlot$221522[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T224401[ebp], ecx
	mov	edx, DWORD PTR $T224401[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T224405[ebp], edx
	mov	eax, DWORD PTR $T224405[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224414[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T224423[ebp], eax
	mov	ecx, DWORD PTR $T224423[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T224424[ebp], eax
	mov	eax, DWORD PTR $T224414[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224424[ebp]
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@MarkCellsN

; 378  : 								{
; 379  : 									ImprovementTypes eImprovement = pAdjacentPlot->getImprovementType();

	mov	ecx, DWORD PTR _pAdjacentPlot$221522[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	mov	DWORD PTR _eImprovement$221530[ebp], eax

; 380  : 									if(eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement)->GetNearbyEnemyDamage() > 0)

	cmp	DWORD PTR _eImprovement$221530[ebp], -1
	je	SHORT $LN3@MarkCellsN
	mov	eax, DWORD PTR _eImprovement$221530[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
	test	eax, eax
	jle	SHORT $LN3@MarkCellsN

; 381  : 									{
; 382  : 										m_pPlots[iI].SetSubjectToAttack(true);

	mov	ecx, DWORD PTR _iI$221498[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR $T224437[ebp], ecx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN225@MarkCellsN
	mov	ecx, DWORD PTR $T224437[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR $T224437[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN222@MarkCellsN
$LN225@MarkCellsN:
	mov	ecx, 32					; 00000020H
	not	ecx
	mov	edx, DWORD PTR $T224437[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR $T224437[ebp]
	mov	DWORD PTR [eax], ecx
$LN222@MarkCellsN:

; 383  : 										break;

	jmp	SHORT $LN20@MarkCellsN
$LN3@MarkCellsN:

; 384  : 									}
; 385  : 								}
; 386  : 							}
; 387  : 						}

	jmp	$LN5@MarkCellsN
$LN20@MarkCellsN:

; 388  : 					}
; 389  : 				}
; 390  : 			}
; 391  : 		}

	jmp	$LN22@MarkCellsN
$LN24@MarkCellsN:

; 392  : 	}
; 393  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::MarkCellsNearEnemy
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T224520 = -80						; size = 4
$T224494 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T224494[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T224494[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T224494[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T224520[ebp], edx
	mov	eax, DWORD PTR $T224520[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T224544 = -16						; size = 4
$T224536 = -12						; size = 4
$T224532 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T224532[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224536[ebp], ecx
	movzx	edx, BYTE PTR $T224532[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T224536[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T224536[ebp]
	mov	DWORD PTR $T224544[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T224536[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T224536[ebp]
	mov	DWORD PTR $T224544[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T224544[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T224544[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T224565 = -16						; size = 4
$T224557 = -12						; size = 4
$T224553 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T224553[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T224557[ebp], ecx
	movzx	edx, BYTE PTR $T224553[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T224557[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T224557[ebp]
	mov	DWORD PTR $T224565[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T224557[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T224557[ebp]
	mov	DWORD PTR $T224565[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T224565[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T224565[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T224772 = -80						; size = 4
$T224727 = -76						; size = 4
$T224714 = -72						; size = 4
$T224710 = -68						; size = 4
$T224696 = -64						; size = 4
$T224692 = -57						; size = 1
$T224681 = -56						; size = 4
$T224677 = -49						; size = 1
_iMapY$224771 = -48					; size = 4
_iMapX$224770 = -44					; size = 4
$T224670 = -40						; size = 4
$T224646 = -36						; size = 4
$T224609 = -32						; size = 4
$T224597 = -28						; size = 4
$T224593 = -21						; size = 1
$T224582 = -20						; size = 4
$T224578 = -13						; size = 1
_iMapY$224645 = -12					; size = 4
_iMapX$224644 = -8					; size = 4
$T224571 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224571[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T224646[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T224571[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T224578[ebp], dl
	mov	eax, DWORD PTR $T224571[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224582[ebp], ecx
	movzx	edx, BYTE PTR $T224578[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T224582[ebp]
	add	edx, DWORD PTR $T224582[ebp]
	mov	DWORD PTR _iMapX$224644[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T224582[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T224582[ebp]
	mov	DWORD PTR _iMapX$224644[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$224644[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T224571[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T224593[ebp], al
	mov	ecx, DWORD PTR $T224571[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T224597[ebp], edx
	movzx	eax, BYTE PTR $T224593[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T224597[ebp]
	add	edx, DWORD PTR $T224597[ebp]
	mov	DWORD PTR _iMapY$224645[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T224597[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T224597[ebp]
	mov	DWORD PTR _iMapY$224645[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$224645[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$224645[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$224644[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T224571[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T224571[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T224609[ebp], eax
	mov	ecx, DWORD PTR _iMapY$224645[ebp]
	imul	ecx, DWORD PTR $T224609[ebp]
	add	ecx, DWORD PTR _iMapX$224644[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T224571[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T224646[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T224646[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224670[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T224772[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T224670[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T224677[ebp], dl
	mov	eax, DWORD PTR $T224670[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224681[ebp], ecx
	movzx	edx, BYTE PTR $T224677[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T224681[ebp]
	add	edx, DWORD PTR $T224681[ebp]
	mov	DWORD PTR _iMapX$224770[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T224681[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T224681[ebp]
	mov	DWORD PTR _iMapX$224770[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$224770[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T224670[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T224692[ebp], al
	mov	ecx, DWORD PTR $T224670[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T224696[ebp], edx
	movzx	eax, BYTE PTR $T224692[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T224696[ebp]
	add	edx, DWORD PTR $T224696[ebp]
	mov	DWORD PTR _iMapY$224771[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T224696[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T224696[ebp]
	mov	DWORD PTR _iMapY$224771[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$224771[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$224770[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T224670[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224710[ebp], ecx
	mov	edx, DWORD PTR _iMapX$224770[ebp]
	cmp	edx, DWORD PTR $T224710[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$224771[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T224670[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T224714[ebp], ecx
	mov	edx, DWORD PTR _iMapY$224771[ebp]
	cmp	edx, DWORD PTR $T224714[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T224670[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T224727[ebp], ecx
	mov	edx, DWORD PTR _iMapY$224771[ebp]
	imul	edx, DWORD PTR $T224727[ebp]
	add	edx, DWORD PTR _iMapX$224770[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T224670[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T224772[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T224772[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T224825 = -28						; size = 4
$T224821 = -24						; size = 4
$T224808 = -20						; size = 4
$T224795 = -16						; size = 4
$T224782 = -12						; size = 4
$T224778 = -8						; size = 4
_iI$221535 = -4						; size = 4
?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ PROC	; CvTacticalAnalysisMap::ClearDynamicFlags, COMDAT
; _this$ = ecx

; 397  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 398  : #ifdef AUI_WARNING_FIXES
; 399  : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 400  : #else
; 401  : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$221535[ebp], 0
	jmp	SHORT $LN3@ClearDynam
$LN2@ClearDynam:
	mov	eax, DWORD PTR _iI$221535[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221535[ebp], eax
$LN3@ClearDynam:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224778[ebp], ecx
	mov	edx, DWORD PTR $T224778[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T224782[ebp], eax
	mov	ecx, DWORD PTR _iI$221535[ebp]
	cmp	ecx, DWORD PTR $T224782[ebp]
	jge	$LN4@ClearDynam

; 402  : #endif
; 403  : 	{
; 404  : 		// Erase this cell
; 405  : 		m_pPlots[iI].SetWithinRangeOfTarget(false);

	mov	edx, DWORD PTR _iI$221535[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T224795[ebp], edx
	xor	ecx, ecx
	je	SHORT $LN13@ClearDynam
	mov	edx, DWORD PTR $T224795[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR $T224795[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN10@ClearDynam
$LN13@ClearDynam:
	mov	edx, 131072				; 00020000H
	not	edx
	mov	eax, DWORD PTR $T224795[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T224795[ebp]
	mov	DWORD PTR [ecx], edx
$LN10@ClearDynam:

; 406  : 		m_pPlots[iI].SetHelpsProvidesFlankBonus(false);

	mov	edx, DWORD PTR _iI$221535[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T224808[ebp], edx
	xor	ecx, ecx
	je	SHORT $LN19@ClearDynam
	mov	edx, DWORD PTR $T224808[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 262144				; 00040000H
	mov	ecx, DWORD PTR $T224808[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN16@ClearDynam
$LN19@ClearDynam:
	mov	edx, 262144				; 00040000H
	not	edx
	mov	eax, DWORD PTR $T224808[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T224808[ebp]
	mov	DWORD PTR [ecx], edx
$LN16@ClearDynam:

; 407  : 		m_pPlots[iI].SetSafeForDeployment(false);

	mov	edx, DWORD PTR _iI$221535[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T224821[ebp], edx
	xor	ecx, ecx
	je	SHORT $LN25@ClearDynam
	mov	edx, DWORD PTR $T224821[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 524288				; 00080000H
	mov	ecx, DWORD PTR $T224821[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN22@ClearDynam
$LN25@ClearDynam:
	mov	edx, 524288				; 00080000H
	not	edx
	mov	eax, DWORD PTR $T224821[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T224821[ebp]
	mov	DWORD PTR [ecx], edx
$LN22@ClearDynam:

; 408  : 		m_pPlots[iI].SetDeploymentScore(0);

	mov	edx, DWORD PTR _iI$221535[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T224825[ebp], edx
	mov	ecx, DWORD PTR $T224825[ebp]
	mov	DWORD PTR [ecx+32], 0

; 409  : 	}

	jmp	$LN2@ClearDynam
$LN4@ClearDynam:

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ENDP	; CvTacticalAnalysisMap::ClearDynamicFlags
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
PUBLIC	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells
EXTRN	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z:PROC ; CvPlot::canSeePlot
; Function compile flags: /Odtp
;	COMDAT ?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z
_TEXT	SEGMENT
_this$ = -176						; size = 4
$T225067 = -172						; size = 4
$T225054 = -168						; size = 4
$T225053 = -164						; size = 4
$T225000 = -160						; size = 4
$T224995 = -156						; size = 4
$T224991 = -152						; size = 4
$T224987 = -148						; size = 4
$T224946 = -100						; size = 4
$T224942 = -96						; size = 4
$T224938 = -92						; size = 4
$T224934 = -88						; size = 4
$T224835 = -28						; size = 4
$T224831 = -24						; size = 4
_iDY$ = -20						; size = 4
_iDX$ = -16						; size = 4
_iPlotIndex$ = -12					; size = 4
_iPlotDistance$ = -8					; size = 4
_pLoopPlot$ = -4					; size = 4
_pTarget$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bIgnoreLOS$ = 16					; size = 1
?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z PROC ; CvTacticalAnalysisMap::SetTargetBombardCells, COMDAT
; _this$ = ecx

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	DWORD PTR _this$[ebp], ecx

; 415  : 	int iDX, iDY;
; 416  : 	CvPlot* pLoopPlot;
; 417  : 	int iPlotIndex;
; 418  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 419  : 	int iMaxDX;
; 420  : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 421  : 	{
; 422  : 		iMaxDX = iRange - MAX(0, iDY);
; 423  : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 424  : #else
; 425  : 	int iPlotDistance;
; 426  : 
; 427  : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	eax, DWORD PTR _iRange$[ebp]
	neg	eax
	mov	DWORD PTR _iDX$[ebp], eax
	jmp	SHORT $LN12@SetTargetB
$LN11@SetTargetB:
	mov	ecx, DWORD PTR _iDX$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDX$[ebp], ecx
$LN12@SetTargetB:
	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iRange$[ebp]
	jg	$LN13@SetTargetB

; 428  : 	{
; 429  : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	eax, DWORD PTR _iRange$[ebp]
	neg	eax
	mov	DWORD PTR _iDY$[ebp], eax
	jmp	SHORT $LN9@SetTargetB
$LN8@SetTargetB:
	mov	ecx, DWORD PTR _iDY$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$[ebp], ecx
$LN9@SetTargetB:
	mov	edx, DWORD PTR _iDY$[ebp]
	cmp	edx, DWORD PTR _iRange$[ebp]
	jg	$LN7@SetTargetB

; 430  : #endif
; 431  : 		{
; 432  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 433  : 			if (iDX == 0 && iDY == 0)
; 434  : 				continue;
; 435  : #endif
; 436  : 			pLoopPlot = plotXY(pTarget->getX(), pTarget->getY(), iDX, iDY);

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224831[ebp], ecx
	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224835[ebp], eax
	mov	ecx, DWORD PTR _iDY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDX$[ebp]
	push	edx
	mov	eax, DWORD PTR $T224831[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224835[ebp]
	push	ecx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 437  : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	$LN6@SetTargetB

; 438  : 			{
; 439  : #ifndef AUI_HEXSPACE_DX_LOOPS
; 440  : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 441  : 				iPlotDistance = hexDistance(iDX, iDY);
; 442  : #else
; 443  : 				iPlotDistance = plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), pTarget->getX(), pTarget->getY());

	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T224934[ebp], eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T224938[ebp], edx
	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224942[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224946[ebp], eax
	mov	ecx, DWORD PTR $T224934[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224938[ebp]
	push	edx
	mov	eax, DWORD PTR $T224942[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224946[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$[ebp], eax

; 444  : #endif
; 445  : 				if(iPlotDistance > 0 && iPlotDistance <= iRange)

	cmp	DWORD PTR _iPlotDistance$[ebp], 0
	jle	$LN6@SetTargetB
	mov	edx, DWORD PTR _iPlotDistance$[ebp]
	cmp	edx, DWORD PTR _iRange$[ebp]
	jg	$LN6@SetTargetB

; 446  : #endif
; 447  : 				{
; 448  : 					iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T224987[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T224991[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T224995[ebp], ecx
	mov	edx, DWORD PTR $T224995[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T225000[ebp], eax
	mov	ecx, DWORD PTR $T224987[ebp]
	imul	ecx, DWORD PTR $T225000[ebp]
	add	ecx, DWORD PTR $T224991[ebp]
	mov	DWORD PTR _iPlotIndex$[ebp], ecx

; 449  : 					if(m_pPlots[iPlotIndex].IsRevealed() && !m_pPlots[iPlotIndex].IsImpassableTerrain() && !m_pPlots[iPlotIndex].IsImpassableTerritory())

	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 1
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN6@SetTargetB
	mov	ecx, DWORD PTR _iPlotIndex$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	and	ecx, 4
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	$LN6@SetTargetB
	mov	eax, DWORD PTR _iPlotIndex$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN6@SetTargetB

; 450  : 					{
; 451  : 						if(!m_pPlots[iPlotIndex].IsEnemyCity() && !m_pPlots[iPlotIndex].IsNeutralCity())

	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 512				; 00000200H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	$LN6@SetTargetB
	mov	ecx, DWORD PTR _iPlotIndex$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	and	ecx, 1024				; 00000400H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	$LN6@SetTargetB

; 452  : 						{
; 453  : 							if(bIgnoreLOS || pLoopPlot->canSeePlot(pTarget, m_pPlayer->getTeam(), iRange, NO_DIRECTION))

	movzx	eax, BYTE PTR _bIgnoreLOS$[ebp]
	test	eax, eax
	jne	SHORT $LN1@SetTargetB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T225053[ebp], edx
	mov	eax, DWORD PTR $T225053[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225054[ebp], eax
	push	-1
	mov	edx, DWORD PTR _iRange$[ebp]
	push	edx
	mov	eax, DWORD PTR $T225054[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@SetTargetB
$LN1@SetTargetB:

; 454  : 							{
; 455  : 								m_pPlots[iPlotIndex].SetWithinRangeOfTarget(true);

	mov	eax, DWORD PTR _iPlotIndex$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR $T225067[ebp], eax
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN126@SetTargetB
	mov	eax, DWORD PTR $T225067[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 131072				; 00020000H
	mov	edx, DWORD PTR $T225067[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN6@SetTargetB
$LN126@SetTargetB:
	mov	eax, 131072				; 00020000H
	not	eax
	mov	ecx, DWORD PTR $T225067[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR $T225067[ebp]
	mov	DWORD PTR [edx], eax
$LN6@SetTargetB:

; 456  : 							}
; 457  : 						}
; 458  : 					}
; 459  : 				}
; 460  : 			}
; 461  : 		}

	jmp	$LN8@SetTargetB
$LN7@SetTargetB:

; 462  : 	}

	jmp	$LN11@SetTargetB
$LN13@SetTargetB:

; 463  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ENDP ; CvTacticalAnalysisMap::SetTargetBombardCells
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T225189 = -56						; size = 4
$T225144 = -52						; size = 4
$T225131 = -48						; size = 4
$T225127 = -44						; size = 4
$T225113 = -40						; size = 4
$T225109 = -33						; size = 1
$T225098 = -32						; size = 4
$T225094 = -25						; size = 1
_iMapY$225153 = -24					; size = 4
_iMapX$225152 = -20					; size = 4
$T225087 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225087[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T225189[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T225087[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T225094[ebp], dl
	mov	eax, DWORD PTR $T225087[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225098[ebp], ecx
	movzx	edx, BYTE PTR $T225094[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T225098[ebp]
	add	edx, DWORD PTR $T225098[ebp]
	mov	DWORD PTR _iMapX$225152[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T225098[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T225098[ebp]
	mov	DWORD PTR _iMapX$225152[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$225152[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T225087[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T225109[ebp], al
	mov	ecx, DWORD PTR $T225087[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T225113[ebp], edx
	movzx	eax, BYTE PTR $T225109[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T225113[ebp]
	add	edx, DWORD PTR $T225113[ebp]
	mov	DWORD PTR _iMapY$225153[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T225113[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T225113[ebp]
	mov	DWORD PTR _iMapY$225153[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$225153[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$225152[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T225087[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225127[ebp], ecx
	mov	edx, DWORD PTR _iMapX$225152[ebp]
	cmp	edx, DWORD PTR $T225127[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$225153[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T225087[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T225131[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225153[ebp]
	cmp	edx, DWORD PTR $T225131[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T225087[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225144[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225153[ebp]
	imul	edx, DWORD PTR $T225144[ebp]
	add	edx, DWORD PTR _iMapX$225152[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T225087[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T225189[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T225189[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z ; CvTacticalAnalysisMap::SetTargetFlankBonusCells
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -128						; size = 4
$T225450 = -124						; size = 4
$T225437 = -120						; size = 4
$T225373 = -116						; size = 4
$T225368 = -112						; size = 4
$T225364 = -108						; size = 4
$T225360 = -104						; size = 4
$T225202 = -20						; size = 4
$T225198 = -16						; size = 4
_iI$221569 = -12					; size = 4
_iPlotIndex$ = -8					; size = 4
_pLoopPlot$ = -4					; size = 4
_pTarget$ = 8						; size = 4
?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::SetTargetFlankBonusCells, COMDAT
; _this$ = ecx

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	CvPlot* pLoopPlot;
; 469  : 	int iPlotIndex;
; 470  : 
; 471  : 	// No flank attacks on units at sea (where all combat is bombards)
; 472  : 	if(pTarget->isWater())

	mov	eax, DWORD PTR _pTarget$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN8@SetTargetF

; 473  : 	{
; 474  : 		return;

	jmp	$LN9@SetTargetF
$LN8@SetTargetF:

; 475  : 	}
; 476  : 
; 477  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$221569[ebp], 0
	jmp	SHORT $LN7@SetTargetF
$LN6@SetTargetF:
	mov	ecx, DWORD PTR _iI$221569[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221569[ebp], ecx
$LN7@SetTargetF:
	cmp	DWORD PTR _iI$221569[ebp], 6
	jge	$LN9@SetTargetF

; 478  : 	{
; 479  : 		pLoopPlot = plotDirection(pTarget->getX(), pTarget->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _pTarget$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T225198[ebp], eax
	mov	ecx, DWORD PTR _pTarget$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T225202[ebp], edx
	mov	eax, DWORD PTR _iI$221569[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225198[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225202[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 480  : 		if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	$LN4@SetTargetF

; 481  : 		{
; 482  : 			iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T225360[ebp], ecx
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T225364[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225368[ebp], ecx
	mov	edx, DWORD PTR $T225368[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T225373[ebp], eax
	mov	ecx, DWORD PTR $T225360[ebp]
	imul	ecx, DWORD PTR $T225373[ebp]
	add	ecx, DWORD PTR $T225364[ebp]
	mov	DWORD PTR _iPlotIndex$[ebp], ecx

; 483  : 			if(m_pPlots[iPlotIndex].IsRevealed() && !m_pPlots[iPlotIndex].IsImpassableTerrain() && !m_pPlots[iPlotIndex].IsImpassableTerritory())

	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 1
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	je	$LN4@SetTargetF
	mov	ecx, DWORD PTR _iPlotIndex$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	and	ecx, 4
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	$LN4@SetTargetF
	mov	eax, DWORD PTR _iPlotIndex$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN4@SetTargetF

; 484  : 			{
; 485  : 				if(!m_pPlots[iPlotIndex].IsFriendlyCity() && !m_pPlots[iPlotIndex].IsEnemyCity() && !m_pPlots[iPlotIndex].IsNeutralCity())

	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 256				; 00000100H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	$LN4@SetTargetF
	mov	ecx, DWORD PTR _iPlotIndex$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	and	ecx, 512				; 00000200H
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	movzx	edx, cl
	test	edx, edx
	jne	$LN4@SetTargetF
	mov	eax, DWORD PTR _iPlotIndex$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+eax]
	and	eax, 1024				; 00000400H
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@SetTargetF

; 486  : 				{
; 487  : 					if(!m_pPlots[iPlotIndex].IsFriendlyTurnEndTile() && m_pPlots[iPlotIndex].GetEnemyMilitaryUnit() == NULL)

	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+edx]
	and	edx, 128				; 00000080H
	neg	edx
	sbb	edx, edx
	neg	edx
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN4@SetTargetF
	mov	ecx, DWORD PTR _iPlotIndex$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR $T225437[ebp], ecx
	cmp	DWORD PTR $T225437[ebp], 0
	jne	SHORT $LN4@SetTargetF

; 488  : 					{
; 489  : 						m_pPlots[iPlotIndex].SetHelpsProvidesFlankBonus(true);

	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T225450[ebp], edx
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN124@SetTargetF
	mov	edx, DWORD PTR $T225450[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 262144				; 00040000H
	mov	ecx, DWORD PTR $T225450[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN4@SetTargetF
$LN124@SetTargetF:
	mov	edx, 262144				; 00040000H
	not	edx
	mov	eax, DWORD PTR $T225450[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T225450[ebp]
	mov	DWORD PTR [ecx], edx
$LN4@SetTargetF:

; 490  : 					}
; 491  : 				}
; 492  : 			}
; 493  : 		}

	jmp	$LN6@SetTargetF
$LN9@SetTargetF:

; 494  : 	}
; 495  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::SetTargetFlankBonusCells
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
EXTRN	?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ:PROC ; CvTacticalAI::GetNextTemporaryZone
EXTRN	?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ:PROC ; CvTacticalAI::GetFirstTemporaryZone
EXTRN	?DropObsoleteZones@CvTacticalAI@@QAEXXZ:PROC	; CvTacticalAI::DropObsoleteZones
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
; Function compile flags: /Odtp
;	COMDAT ?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
tv180 = -200						; size = 4
_this$ = -196						; size = 4
$T225563 = -150						; size = 1
$T225556 = -149						; size = 1
$T225546 = -148						; size = 4
$T225533 = -144						; size = 4
$T225499 = -140						; size = 4
$T225494 = -136						; size = 4
$T225490 = -129						; size = 1
$T225479 = -128						; size = 4
$T225475 = -121						; size = 1
_iMapY$225529 = -120					; size = 4
_iMapX$225528 = -116					; size = 4
$T225468 = -112						; size = 4
$T225464 = -108						; size = 4
$T225460 = -104						; size = 4
$T225456 = -100						; size = 4
_newZone$221590 = -96					; size = 76
_pPlot$221588 = -12					; size = 4
_pZone$ = -8						; size = 4
_pTacticalAI$ = -4					; size = 4
?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::AddTemporaryZones, COMDAT
; _this$ = ecx

; 501  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	DWORD PTR _this$[ebp], ecx

; 502  : 	CvTemporaryZone* pZone;
; 503  : 	CvTacticalAI* pTacticalAI = m_pPlayer->GetTacticalAI();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	DWORD PTR _pTacticalAI$[ebp], eax

; 504  : 
; 505  : 	if(pTacticalAI)

	cmp	DWORD PTR _pTacticalAI$[ebp], 0
	je	$LN6@AddTempora

; 506  : 	{
; 507  : 		pTacticalAI->DropObsoleteZones();

	mov	ecx, DWORD PTR _pTacticalAI$[ebp]
	call	?DropObsoleteZones@CvTacticalAI@@QAEXXZ	; CvTacticalAI::DropObsoleteZones

; 508  : 
; 509  : 		pZone = pTacticalAI->GetFirstTemporaryZone();

	mov	ecx, DWORD PTR _pTacticalAI$[ebp]
	call	?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ; CvTacticalAI::GetFirstTemporaryZone
	mov	DWORD PTR _pZone$[ebp], eax
$LN4@AddTempora:

; 510  : 		while(pZone)

	cmp	DWORD PTR _pZone$[ebp], 0
	je	$LN6@AddTempora

; 511  : 		{
; 512  : 			// Can't be a city zone (which is just used to boost priority but not establish a new zone)
; 513  : 			if(pZone->GetTargetType() != AI_TACTICAL_TARGET_CITY)

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T225456[ebp], edx
	cmp	DWORD PTR $T225456[ebp], 1
	je	$LN2@AddTempora

; 514  : 			{
; 515  : 				CvPlot* pPlot = GC.getMap().plot(pZone->GetX(), pZone->GetY());

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225460[ebp], ecx
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225464[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225468[ebp], ecx
	cmp	DWORD PTR $T225464[ebp], -2147483647	; 80000001H
	je	SHORT $LN16@AddTempora
	cmp	DWORD PTR $T225460[ebp], -2147483647	; 80000001H
	jne	SHORT $LN17@AddTempora
$LN16@AddTempora:
	mov	DWORD PTR _pPlot$221588[ebp], 0
	jmp	$LN18@AddTempora
$LN17@AddTempora:
	mov	edx, DWORD PTR $T225468[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T225475[ebp], al
	mov	ecx, DWORD PTR $T225468[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T225479[ebp], edx
	movzx	eax, BYTE PTR $T225475[ebp]
	test	eax, eax
	je	SHORT $LN29@AddTempora
	cmp	DWORD PTR $T225464[ebp], 0
	jge	SHORT $LN28@AddTempora
	mov	eax, DWORD PTR $T225464[ebp]
	cdq
	idiv	DWORD PTR $T225479[ebp]
	add	edx, DWORD PTR $T225479[ebp]
	mov	DWORD PTR _iMapX$225528[ebp], edx
	jmp	SHORT $LN30@AddTempora
	jmp	SHORT $LN29@AddTempora
$LN28@AddTempora:
	mov	ecx, DWORD PTR $T225464[ebp]
	cmp	ecx, DWORD PTR $T225479[ebp]
	jl	SHORT $LN29@AddTempora
	mov	eax, DWORD PTR $T225464[ebp]
	cdq
	idiv	DWORD PTR $T225479[ebp]
	mov	DWORD PTR _iMapX$225528[ebp], edx
	jmp	SHORT $LN30@AddTempora
$LN29@AddTempora:
	mov	edx, DWORD PTR $T225464[ebp]
	mov	DWORD PTR _iMapX$225528[ebp], edx
$LN30@AddTempora:
	mov	eax, DWORD PTR $T225468[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T225490[ebp], cl
	mov	edx, DWORD PTR $T225468[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T225494[ebp], eax
	movzx	ecx, BYTE PTR $T225490[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225494[ebp]
	push	edx
	mov	eax, DWORD PTR $T225460[ebp]
	push	eax
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$225529[ebp], eax
	mov	ecx, DWORD PTR _iMapY$225529[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMapX$225528[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225468[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN20@AddTempora
	mov	eax, DWORD PTR $T225468[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T225499[ebp], ecx
	mov	edx, DWORD PTR _iMapY$225529[ebp]
	imul	edx, DWORD PTR $T225499[ebp]
	add	edx, DWORD PTR _iMapX$225528[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T225468[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv180[ebp], edx
	jmp	SHORT $LN21@AddTempora
$LN20@AddTempora:
	mov	DWORD PTR tv180[ebp], 0
$LN21@AddTempora:
	mov	ecx, DWORD PTR tv180[ebp]
	mov	DWORD PTR _pPlot$221588[ebp], ecx
$LN18@AddTempora:

; 516  : 				if(pPlot)

	cmp	DWORD PTR _pPlot$221588[ebp], 0
	je	$LN2@AddTempora

; 517  : 				{
; 518  : 					CvTacticalDominanceZone newZone;

	lea	ecx, DWORD PTR _newZone$221590[ebp]
	call	??0CvTacticalDominanceZone@@QAE@XZ	; CvTacticalDominanceZone::CvTacticalDominanceZone

; 519  : 					newZone.SetDominanceZoneID(m_DominanceZones.size());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR $T225533[ebp], eax
	mov	ecx, DWORD PTR $T225533[ebp]
	mov	DWORD PTR _newZone$221590[ebp], ecx

; 520  : 					newZone.SetTerritoryType(TACTICAL_TERRITORY_TEMP_ZONE);

	mov	DWORD PTR _newZone$221590[ebp+4], 5

; 521  : 					newZone.SetOwner(NO_PLAYER);

	mov	DWORD PTR _newZone$221590[ebp+12], -1

; 522  : 					newZone.SetAreaID(pPlot->getArea());

	mov	edx, DWORD PTR _pPlot$221588[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T225546[ebp], eax
	mov	ecx, DWORD PTR $T225546[ebp]
	mov	DWORD PTR _newZone$221590[ebp+20], ecx

; 523  : 					newZone.SetWater(pPlot->isWater());

	mov	edx, DWORD PTR _pPlot$221588[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR $T225556[ebp], cl
	mov	dl, BYTE PTR $T225556[ebp]
	mov	BYTE PTR _newZone$221590[ebp+68], dl

; 524  : 					newZone.SetTempZoneCenter(pPlot);

	mov	eax, DWORD PTR _pPlot$221588[ebp]
	mov	DWORD PTR _newZone$221590[ebp+72], eax

; 525  : 					newZone.SetNavalInvasion(pZone->IsNavalInvasion());

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	dl, BYTE PTR [ecx+16]
	mov	BYTE PTR $T225563[ebp], dl
	mov	al, BYTE PTR $T225563[ebp]
	mov	BYTE PTR _newZone$221590[ebp+69], al

; 526  : 					m_DominanceZones.push_back(newZone);

	lea	ecx, DWORD PTR _newZone$221590[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back
$LN2@AddTempora:

; 527  : 				}
; 528  : 			}
; 529  : 
; 530  : 			pZone = pTacticalAI->GetNextTemporaryZone();

	mov	ecx, DWORD PTR _pTacticalAI$[ebp]
	call	?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ; CvTacticalAI::GetNextTemporaryZone
	mov	DWORD PTR _pZone$[ebp], eax

; 531  : 		}

	jmp	$LN4@AddTempora
$LN6@AddTempora:

; 532  : 	}
; 533  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::AddTemporaryZones
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
EXTRN	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::isFriendlyTerritory
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
; Function compile flags: /Odtp
;	COMDAT ?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T225941 = -116						; size = 4
$T225940 = -112						; size = 4
$T225917 = -108						; size = 4
$T225908 = -104						; size = 4
$T225899 = -100						; size = 4
$T225859 = -96						; size = 4
$T225843 = -92						; size = 4
$T225824 = -88						; size = 4
$T225791 = -84						; size = 4
$T225775 = -80						; size = 4
$T225766 = -76						; size = 4
$T225757 = -68						; size = 4
$T225753 = -64						; size = 4
_playerID$225747 = -60					; size = 4
$T225733 = -56						; size = 4
$T225724 = -52						; size = 1
$T225708 = -51						; size = 1
$T225692 = -50						; size = 1
$T225661 = -49						; size = 1
$T225651 = -48						; size = 4
$T225650 = -44						; size = 4
$T225641 = -37						; size = 1
$T225625 = -36						; size = 4
$T225624 = -32						; size = 4
_eMyTeam$221601 = -28					; size = 4
_ePlotTeam$221602 = -24					; size = 4
_cell$ = -20						; size = 4
_bImpassableTerritory$ = -13				; size = 1
_pLoopUnit$ = -12					; size = 4
_iUnitLoop$ = -8					; size = 4
_bAdd$ = -1						; size = 1
_iIndex$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::PopulateCell, COMDAT
; _this$ = ecx

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 538  : 	CvUnit* pLoopUnit;
; 539  : #ifdef AUI_WARNING_FIXES
; 540  : 	uint iUnitLoop;
; 541  : #else
; 542  : 	int iUnitLoop;
; 543  : #endif
; 544  : 	CvTacticalAnalysisCell& cell = m_pPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _cell$[ebp], eax

; 545  : 
; 546  : 	cell.Clear();

	mov	ecx, DWORD PTR _cell$[ebp]
	call	?Clear@CvTacticalAnalysisCell@@QAEXXZ	; CvTacticalAnalysisCell::Clear

; 547  : 
; 548  : 	cell.SetRevealed(pPlot->isRevealed(m_pPlayer->getTeam()));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T225624[ebp], eax
	mov	ecx, DWORD PTR $T225624[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225625[ebp], eax
	mov	eax, DWORD PTR $T225625[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	add	ecx, 8
	call	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z	; CvPlot::PlotBoolField::GetBit
	mov	BYTE PTR $T225641[ebp], al
	movzx	ecx, BYTE PTR $T225641[ebp]
	test	ecx, ecx
	je	SHORT $LN45@PopulateCe
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN42@PopulateCe
$LN45@PopulateCe:
	mov	edx, 1
	not	edx
	mov	eax, DWORD PTR _cell$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], edx
$LN42@PopulateCe:

; 549  : 	cell.SetVisible(pPlot->isVisible(m_pPlayer->getTeam()));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T225650[ebp], eax
	mov	ecx, DWORD PTR $T225650[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225651[ebp], eax
	cmp	DWORD PTR $T225651[ebp], -1
	jne	SHORT $LN55@PopulateCe
	mov	BYTE PTR $T225661[ebp], 0
	jmp	SHORT $LN53@PopulateCe
$LN55@PopulateCe:
	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR $T225651[ebp]
	movsx	eax, WORD PTR [ecx+edx*2]
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR $T225661[ebp], cl
$LN53@PopulateCe:
	movzx	edx, BYTE PTR $T225661[ebp]
	test	edx, edx
	je	SHORT $LN60@PopulateCe
	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN63@PopulateCe
$LN60@PopulateCe:
	mov	eax, 2
	not	eax
	mov	ecx, DWORD PTR _cell$[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], eax

; 550  : 	cell.SetImpassableTerrain(pPlot->isImpassable() || pPlot->isMountain());

$LN63@PopulateCe:
	mov	eax, DWORD PTR _pPlot$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN32@PopulateCe
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN32@PopulateCe
	mov	BYTE PTR $T225692[ebp], 0
	jmp	SHORT $LN33@PopulateCe
$LN32@PopulateCe:
	mov	BYTE PTR $T225692[ebp], 1
$LN33@PopulateCe:
	movzx	eax, BYTE PTR $T225692[ebp]
	test	eax, eax
	je	SHORT $LN70@PopulateCe
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 4
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN73@PopulateCe
$LN70@PopulateCe:
	mov	ecx, 4
	not	ecx
	mov	edx, DWORD PTR _cell$[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], ecx

; 551  : 	cell.SetWater(pPlot->isWater());

$LN73@PopulateCe:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	mov	BYTE PTR $T225708[ebp], al
	movzx	ecx, BYTE PTR $T225708[ebp]
	test	ecx, ecx
	je	SHORT $LN78@PopulateCe
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 2048				; 00000800H
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN81@PopulateCe
$LN78@PopulateCe:
	mov	edx, 2048				; 00000800H
	not	edx
	mov	eax, DWORD PTR _cell$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], edx

; 552  : 	cell.SetOcean(pPlot->isWater() && !pPlot->isShallowWater());

$LN81@PopulateCe:
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN34@PopulateCe
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN34@PopulateCe
	mov	BYTE PTR $T225724[ebp], 1
	jmp	SHORT $LN35@PopulateCe
$LN34@PopulateCe:
	mov	BYTE PTR $T225724[ebp], 0
$LN35@PopulateCe:
	movzx	ecx, BYTE PTR $T225724[ebp]
	test	ecx, ecx
	je	SHORT $LN86@PopulateCe
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN83@PopulateCe
$LN86@PopulateCe:
	mov	edx, 4096				; 00001000H
	not	edx
	mov	eax, DWORD PTR _cell$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], edx
$LN83@PopulateCe:

; 553  : 
; 554  : 	bool bImpassableTerritory = false;

	mov	BYTE PTR _bImpassableTerritory$[ebp], 0

; 555  : 	if(pPlot->isOwned())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	je	$LN29@PopulateCe

; 556  : 	{
; 557  : 		TeamTypes eMyTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T225733[ebp], ecx
	mov	edx, DWORD PTR $T225733[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eMyTeam$221601[ebp], eax

; 558  : 		TeamTypes ePlotTeam = pPlot->getTeam();

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$225747[ebp], edx
	cmp	DWORD PTR _playerID$225747[ebp], -1
	je	SHORT $LN94@PopulateCe
	mov	eax, DWORD PTR _playerID$225747[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlotTeam$221602[ebp], eax
	jmp	SHORT $LN95@PopulateCe
	jmp	SHORT $LN95@PopulateCe
$LN94@PopulateCe:
	mov	DWORD PTR _ePlotTeam$221602[ebp], -1
$LN95@PopulateCe:

; 559  : 
; 560  : 		if(eMyTeam != ePlotTeam && !GET_TEAM(eMyTeam).isAtWar(ePlotTeam) && !GET_TEAM(ePlotTeam).IsAllowsOpenBordersToTeam(eMyTeam))

	mov	ecx, DWORD PTR _eMyTeam$221601[ebp]
	cmp	ecx, DWORD PTR _ePlotTeam$221602[ebp]
	je	SHORT $LN28@PopulateCe
	mov	edx, DWORD PTR _eMyTeam$221601[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225753[ebp], edx
	mov	eax, DWORD PTR _ePlotTeam$221602[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225753[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN28@PopulateCe
	mov	edx, DWORD PTR _ePlotTeam$221602[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225757[ebp], edx
	mov	eax, DWORD PTR _eMyTeam$221601[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225757[ebp]
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN28@PopulateCe

; 561  : 		{
; 562  : 			bImpassableTerritory = true;

	mov	BYTE PTR _bImpassableTerritory$[ebp], 1
	jmp	$LN138@PopulateCe
$LN28@PopulateCe:

; 563  : 		}
; 564  : 		else if(pPlot->isCity())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	je	$LN138@PopulateCe

; 565  : 		{
; 566  : 			if(pPlot->getOwner() == m_pPlayer->GetID())

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR $T225766[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T225775[ebp], ecx
	mov	edx, DWORD PTR $T225766[ebp]
	cmp	edx, DWORD PTR $T225775[ebp]
	jne	SHORT $LN25@PopulateCe

; 567  : 			{
; 568  : 				cell.SetFriendlyCity(true);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN119@PopulateCe
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN116@PopulateCe
$LN119@PopulateCe:
	mov	ecx, 256				; 00000100H
	not	ecx
	mov	edx, DWORD PTR _cell$[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], ecx
$LN116@PopulateCe:

; 569  : 			}
; 570  : 			else if(GET_TEAM(eMyTeam).isAtWar(ePlotTeam))

	jmp	SHORT $LN138@PopulateCe
$LN25@PopulateCe:
	mov	ecx, DWORD PTR _eMyTeam$221601[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225791[ebp], ecx
	mov	edx, DWORD PTR _ePlotTeam$221602[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225791[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@PopulateCe

; 571  : 			{
; 572  : 				cell.SetEnemyCity(true);

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN127@PopulateCe
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 512				; 00000200H
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN124@PopulateCe
$LN127@PopulateCe:
	mov	edx, 512				; 00000200H
	not	edx
	mov	eax, DWORD PTR _cell$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], edx
$LN124@PopulateCe:

; 573  : 			}
; 574  : 			else

	jmp	SHORT $LN138@PopulateCe
$LN23@PopulateCe:

; 575  : 			{
; 576  : 				cell.SetNeutralCity(true);

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN133@PopulateCe
	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 1024				; 00000400H
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN138@PopulateCe
$LN133@PopulateCe:
	mov	eax, 1024				; 00000400H
	not	eax
	mov	ecx, DWORD PTR _cell$[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], eax

; 577  : 			}
; 578  : 		}
; 579  : 
; 580  : 		if(m_pPlayer->GetID() == pPlot->getOwner())

$LN138@PopulateCe:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T225824[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	DWORD PTR $T225824[ebp], ecx
	jne	SHORT $LN21@PopulateCe

; 581  : 		{
; 582  : 			cell.SetOwnTerritory(true);

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN145@PopulateCe
	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN21@PopulateCe
$LN145@PopulateCe:
	mov	eax, 8192				; 00002000H
	not	eax
	mov	ecx, DWORD PTR _cell$[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], eax
$LN21@PopulateCe:

; 583  : 		}
; 584  : 
; 585  : 		if(GET_TEAM(eMyTeam).isFriendlyTerritory(ePlotTeam))

	mov	eax, DWORD PTR _eMyTeam$221601[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225843[ebp], eax
	mov	ecx, DWORD PTR _ePlotTeam$221602[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T225843[ebp]
	call	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isFriendlyTerritory
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN20@PopulateCe

; 586  : 		{
; 587  : 			cell.SetFriendlyTerritory(true);

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN153@PopulateCe
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 16384				; 00004000H
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN20@PopulateCe
$LN153@PopulateCe:
	mov	ecx, 16384				; 00004000H
	not	ecx
	mov	edx, DWORD PTR _cell$[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], ecx
$LN20@PopulateCe:

; 588  : 		}
; 589  : 
; 590  : 		if(GET_TEAM(ePlotTeam).isAtWar(ePlotTeam))

	mov	ecx, DWORD PTR _ePlotTeam$221602[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T225859[ebp], ecx
	mov	edx, DWORD PTR _ePlotTeam$221602[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225859[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@PopulateCe

; 591  : 		{
; 592  : 			cell.SetEnemyTerritory(true);

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN161@PopulateCe
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN19@PopulateCe
$LN161@PopulateCe:
	mov	edx, 32768				; 00008000H
	not	edx
	mov	eax, DWORD PTR _cell$[ebp]
	and	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [ecx], edx
$LN19@PopulateCe:

; 593  : 		}
; 594  : 	}
; 595  : 	else

	jmp	SHORT $LN18@PopulateCe
$LN29@PopulateCe:

; 596  : 	{
; 597  : 		cell.SetUnclaimedTerritory(true);

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN167@PopulateCe
	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN18@PopulateCe
$LN167@PopulateCe:
	mov	eax, 65536				; 00010000H
	not	eax
	mov	ecx, DWORD PTR _cell$[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [edx], eax
$LN18@PopulateCe:

; 598  : 	}
; 599  : 
; 600  : 	cell.SetImpassableTerritory(bImpassableTerritory);

	movzx	eax, BYTE PTR _bImpassableTerritory$[ebp]
	test	eax, eax
	je	SHORT $LN173@PopulateCe
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 8
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN170@PopulateCe
$LN173@PopulateCe:
	mov	ecx, 8
	not	ecx
	mov	edx, DWORD PTR _cell$[ebp]
	and	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _cell$[ebp]
	mov	DWORD PTR [eax], ecx
$LN170@PopulateCe:

; 601  : 	cell.SetDefenseModifier(pPlot->defenseModifier(NO_TEAM, true));

	push	0
	push	1
	push	-1
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier
	mov	DWORD PTR $T225899[ebp], eax
	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR $T225899[ebp]
	mov	DWORD PTR [ecx+28], edx

; 602  : 
; 603  : 	if(pPlot->getNumUnits() > 0)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN17@PopulateCe

; 604  : 	{
; 605  : 		for(iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)

	mov	DWORD PTR _iUnitLoop$[ebp], 0
	jmp	SHORT $LN16@PopulateCe
$LN15@PopulateCe:
	mov	eax, DWORD PTR _iUnitLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iUnitLoop$[ebp], eax
$LN16@PopulateCe:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	DWORD PTR _iUnitLoop$[ebp], eax
	jge	$LN17@PopulateCe

; 606  : 		{
; 607  : 			pLoopUnit = pPlot->getUnitByIndex(iUnitLoop);

	mov	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	DWORD PTR _pLoopUnit$[ebp], eax

; 608  : 			if(!pLoopUnit) continue;

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	jne	SHORT $LN180@PopulateCe
	jmp	SHORT $LN15@PopulateCe

; 609  : 			if(pLoopUnit->getOwner() == m_pPlayer->GetID())

$LN180@PopulateCe:
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T225908[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T225917[ebp], eax
	mov	ecx, DWORD PTR $T225908[ebp]
	cmp	ecx, DWORD PTR $T225917[ebp]
	jne	SHORT $LN12@PopulateCe

; 610  : 			{
; 611  : 				if(pLoopUnit->IsCombatUnit())

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+1044], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@PopulateCe

; 612  : 				{
; 613  : 					// CvAssertMsg(!cell.GetFriendlyMilitaryUnit(), "Two friendly military units in a hex, please show Ed and send save.");
; 614  : 					cell.SetFriendlyMilitaryUnit(pLoopUnit);

	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR [edx+20], eax

; 615  : 				}
; 616  : 				else

	jmp	SHORT $LN10@PopulateCe
$LN11@PopulateCe:

; 617  : 				{
; 618  : 					// CvAssertMsg(!cell.GetFriendlyCivilianUnit(), "Two friendly civilian units in a hex, please show Ed and send save.");
; 619  : 					cell.SetFriendlyCivilianUnit(pLoopUnit);

	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR [ecx+24], edx
$LN10@PopulateCe:

; 620  : 				}

	jmp	$LN9@PopulateCe
$LN12@PopulateCe:

; 621  : 			}
; 622  : 			else if(pLoopUnit->isEnemy(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T225940[ebp], ecx
	mov	edx, DWORD PTR $T225940[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T225941[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T225941[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN206@PopulateCe

; 623  : 			{
; 624  : 				if(pLoopUnit->IsCombatUnit())

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN7@PopulateCe

; 625  : 				{
; 626  : 					// CvAssertMsg(!cell.GetEnemyMilitaryUnit(), "Two enemy military units in a hex, please show Ed and send save.");
; 627  : 					cell.SetEnemyMilitaryUnit(pLoopUnit);

	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 628  : 				}
; 629  : 				else

	jmp	SHORT $LN6@PopulateCe
$LN7@PopulateCe:

; 630  : 				{
; 631  : 					// CvAssertMsg(!cell.GetEnemyCivilianUnit(), "Two enemy civilian units in a hex, please show Ed and send save.");
; 632  : 					cell.SetEnemyCivilianUnit(pLoopUnit);

	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN6@PopulateCe:

; 633  : 				}
; 634  : 			}
; 635  : 			else

	jmp	SHORT $LN9@PopulateCe

; 636  : 			{
; 637  : 				if(pLoopUnit->IsCombatUnit())

$LN206@PopulateCe:
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@PopulateCe

; 638  : 				{
; 639  : 					// CvAssertMsg(!cell.GetNeutralMilitaryUnit(), "Two neutral military units in a hex, please show Ed and send save.");
; 640  : 					cell.SetNeutralMilitaryUnit(pLoopUnit);

	mov	ecx, DWORD PTR _cell$[ebp]
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 641  : 				}
; 642  : 				else

	jmp	SHORT $LN9@PopulateCe
$LN4@PopulateCe:

; 643  : 				{
; 644  : 					// CvAssertMsg(!cell.GetNeutralCivilianUnit(), "Two neutral civilian units in a hex, please show Ed and send save.");
; 645  : 					cell.SetNeutralCivilianUnit(pLoopUnit);

	mov	eax, DWORD PTR _cell$[ebp]
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN9@PopulateCe:

; 646  : 				}
; 647  : 			}
; 648  : 		}

	jmp	$LN15@PopulateCe
$LN17@PopulateCe:

; 649  : 	}
; 650  : 
; 651  : 	// Figure out whether or not to add this to a dominance zone
; 652  : 	bool bAdd = true;

	mov	BYTE PTR _bAdd$[ebp], 1

; 653  : 	if(cell.IsImpassableTerrain() || cell.IsImpassableTerritory() || !cell.IsRevealed())

	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 4
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@PopulateCe
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 8
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@PopulateCe
	mov	edx, DWORD PTR _cell$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@PopulateCe
$LN1@PopulateCe:

; 654  : 	{
; 655  : 		bAdd = false;

	mov	BYTE PTR _bAdd$[ebp], 0
$LN2@PopulateCe:

; 656  : 	}
; 657  : 	return bAdd;

	mov	al, BYTE PTR _bAdd$[ebp]

; 658  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::PopulateCell
_TEXT	ENDS
PUBLIC	?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z ; CvTacticalAnalysisMap::FindExistingZone
EXTRN	?isRanged@CvUnit@@QBE_NXZ:PROC			; CvUnit::isRanged
EXTRN	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsRangeAttackIgnoreLOS
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z:PROC ; CvUnit::GetMaxRangedCombatStrength
EXTRN	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z:PROC	; CvUnit::GetBaseCombatStrength
EXTRN	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ:PROC ; CvUnit::GetBaseCombatStrengthConsideringDamage
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Odtp
;	COMDAT ?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z
_TEXT	SEGMENT
tv389 = -248						; size = 4
_this$ = -244						; size = 4
$T226316 = -240						; size = 4
$T226303 = -236						; size = 4
$T226299 = -232						; size = 4
$T226295 = -228						; size = 1
$T226291 = -227						; size = 1
$T226282 = -226						; size = 1
$T226278 = -225						; size = 1
$T226262 = -224						; size = 4
$T226258 = -220						; size = 4
$T226254 = -216						; size = 4
$T226250 = -212						; size = 4
$T226246 = -208						; size = 1
$T226242 = -207						; size = 1
$T226233 = -206						; size = 1
$T226229 = -205						; size = 1
$T226222 = -204						; size = 4
$T226218 = -200						; size = 4
$T226211 = -196						; size = 4
$T226197 = -188						; size = 4
$T226156 = -140						; size = 4
$T226147 = -136						; size = 4
$T226138 = -132						; size = 4
$T226134 = -128						; size = 4
$T226130 = -124						; size = 4
$T226126 = -120						; size = 4
$T226122 = -116						; size = 4
$T226118 = -112						; size = 4
$T226114 = -108						; size = 4
$T226110 = -104						; size = 4
$T226106 = -100						; size = 4
$T226096 = -96						; size = 4
$T226092 = -92						; size = 4
$T226091 = -88						; size = 4
$T226082 = -84						; size = 4
_playerID$226074 = -80					; size = 4
$T226062 = -76						; size = 4
$T226053 = -72						; size = 4
_playerID$226045 = -68					; size = 4
$T226033 = -61						; size = 1
$T226026 = -60						; size = 4
$T226016 = -56						; size = 4
$T226006 = -52						; size = 4
$T225999 = -48						; size = 4
_iStrength$221675 = -44					; size = 4
_iStrength$221665 = -40					; size = 4
_pFriendlyUnit$221660 = -36				; size = 4
_pEnemyUnit$221670 = -32				; size = 4
_iDistance$221653 = -28					; size = 4
_pLoopCity$221649 = -24					; size = 4
_iBestDistance$221647 = -20				; size = 4
_pBestCity$221648 = -16					; size = 4
_iLoop$221646 = -12					; size = 4
_pZone$ = -8						; size = 4
_pPlot$ = -4						; size = 4
_iIndex$ = 8						; size = 4
_pCell$ = 12						; size = 4
?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z PROC ; CvTacticalAnalysisMap::AddToDominanceZones, COMDAT
; _this$ = ecx

; 662  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	DWORD PTR _this$[ebp], ecx

; 663  : 	CvPlot* pPlot = GC.getMap().plotByIndex(iIndex);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T225999[ebp], eax
	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN38@AddToDomin
	mov	ecx, DWORD PTR $T225999[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T226006[ebp], edx
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR $T226006[ebp]
	jge	SHORT $LN38@AddToDomin
	mov	ecx, DWORD PTR _iIndex$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T225999[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv389[ebp], ecx
	jmp	SHORT $LN36@AddToDomin
$LN38@AddToDomin:
	mov	DWORD PTR tv389[ebp], 0
$LN36@AddToDomin:
	mov	eax, DWORD PTR tv389[ebp]
	mov	DWORD PTR _pPlot$[ebp], eax

; 664  : 
; 665  : 	// Compute zone data for this cell
; 666  : 	m_TempZone.SetAreaID(pPlot->getArea());

	mov	ecx, DWORD PTR _pPlot$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T226016[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226016[ebp]
	mov	DWORD PTR [eax+56], ecx

; 667  : 	m_TempZone.SetOwner(pPlot->getOwner());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	DWORD PTR $T226026[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T226026[ebp]
	mov	DWORD PTR [ecx+48], edx

; 668  : 	m_TempZone.SetWater(pPlot->isWater());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	mov	BYTE PTR $T226033[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR $T226033[ebp]
	mov	BYTE PTR [eax+104], cl

; 669  : 	if(!pPlot->isOwned())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN60@AddToDomin

; 670  : 	{
; 671  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_NO_OWNER);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 1

; 672  : 	}
; 673  : 	else if(pPlot->getTeam() == m_pPlayer->getTeam())

	jmp	$LN30@AddToDomin
$LN60@AddToDomin:
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR _playerID$226045[ebp], edx
	cmp	DWORD PTR _playerID$226045[ebp], -1
	je	SHORT $LN57@AddToDomin
	mov	eax, DWORD PTR _playerID$226045[ebp]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226053[ebp], eax
	jmp	SHORT $LN58@AddToDomin
	jmp	SHORT $LN58@AddToDomin
$LN57@AddToDomin:
	mov	DWORD PTR $T226053[ebp], -1
$LN58@AddToDomin:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T226062[ebp], edx
	mov	eax, DWORD PTR $T226062[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	DWORD PTR $T226053[ebp], eax
	jne	SHORT $LN74@AddToDomin

; 674  : 	{
; 675  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_FRIENDLY);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 2

; 676  : 	}
; 677  : 	else if(GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

	jmp	$LN30@AddToDomin
$LN74@AddToDomin:
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	mov	DWORD PTR _playerID$226074[ebp], ecx
	cmp	DWORD PTR _playerID$226074[ebp], -1
	je	SHORT $LN71@AddToDomin
	mov	edx, DWORD PTR _playerID$226074[ebp]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226082[ebp], eax
	jmp	SHORT $LN72@AddToDomin
	jmp	SHORT $LN72@AddToDomin
$LN71@AddToDomin:
	mov	DWORD PTR $T226082[ebp], -1
$LN72@AddToDomin:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T226091[ebp], ecx
	mov	edx, DWORD PTR $T226091[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226092[ebp], eax
	mov	ecx, DWORD PTR $T226092[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T226096[ebp], ecx
	mov	edx, DWORD PTR $T226082[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226096[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@AddToDomin

; 678  : 	{
; 679  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_ENEMY);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 3

; 680  : 	}
; 681  : 	else

	jmp	SHORT $LN30@AddToDomin
$LN27@AddToDomin:

; 682  : 	{
; 683  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_NEUTRAL);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 4
$LN30@AddToDomin:

; 684  : 	}
; 685  : 	m_TempZone.SetClosestCity(NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z ; CvTacticalDominanceZone::SetClosestCity

; 686  : 	if(m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_ENEMY ||
; 687  : 	        m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL ||
; 688  : 	        m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T226106[ebp], ecx
	cmp	DWORD PTR $T226106[ebp], 3
	je	SHORT $LN24@AddToDomin
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T226110[ebp], eax
	cmp	DWORD PTR $T226110[ebp], 4
	je	SHORT $LN24@AddToDomin
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T226114[ebp], edx
	cmp	DWORD PTR $T226114[ebp], 2
	jne	$LN25@AddToDomin
$LN24@AddToDomin:

; 689  : 	{
; 690  : 		int iLoop;
; 691  : 		int iBestDistance = MAX_INT;

	mov	DWORD PTR _iBestDistance$221647[ebp], 2147483647 ; 7fffffffH

; 692  : 		CvCity* pBestCity = NULL;

	mov	DWORD PTR _pBestCity$221648[ebp], 0

; 693  : 
; 694  : 		for(CvCity* pLoopCity = GET_PLAYER(m_TempZone.GetOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(m_TempZone.GetOwner()).nextCity(&iLoop))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T226118[ebp], ecx
	mov	edx, DWORD PTR $T226118[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226122[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$221646[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226122[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$221649[ebp], eax
	jmp	SHORT $LN23@AddToDomin
$LN22@AddToDomin:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T226126[ebp], edx
	mov	eax, DWORD PTR $T226126[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T226130[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$221646[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T226130[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$221649[ebp], eax
$LN23@AddToDomin:
	cmp	DWORD PTR _pLoopCity$221649[ebp], 0
	je	SHORT $LN21@AddToDomin

; 695  : 		{
; 696  : 			int iDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), pPlot->getX(), pPlot->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T226134[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T226138[ebp], edx
	mov	eax, DWORD PTR _pLoopCity$221649[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T226147[ebp], ecx
	mov	edx, DWORD PTR _pLoopCity$221649[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T226156[ebp], eax
	mov	ecx, DWORD PTR $T226134[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226138[ebp]
	push	edx
	mov	eax, DWORD PTR $T226147[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226156[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$221653[ebp], eax

; 697  : 			if(iDistance < iBestDistance)

	mov	edx, DWORD PTR _iDistance$221653[ebp]
	cmp	edx, DWORD PTR _iBestDistance$221647[ebp]
	jge	SHORT $LN20@AddToDomin

; 698  : 			{
; 699  : 				iBestDistance = iDistance;

	mov	eax, DWORD PTR _iDistance$221653[ebp]
	mov	DWORD PTR _iBestDistance$221647[ebp], eax

; 700  : 				pBestCity = pLoopCity;

	mov	ecx, DWORD PTR _pLoopCity$221649[ebp]
	mov	DWORD PTR _pBestCity$221648[ebp], ecx
$LN20@AddToDomin:

; 701  : 			}
; 702  : 		}

	jmp	$LN22@AddToDomin
$LN21@AddToDomin:

; 703  : 
; 704  : 		if(pBestCity != NULL)

	cmp	DWORD PTR _pBestCity$221648[ebp], 0
	je	SHORT $LN25@AddToDomin

; 705  : 		{
; 706  : 			m_TempZone.SetClosestCity(pBestCity);

	mov	edx, DWORD PTR _pBestCity$221648[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z ; CvTacticalDominanceZone::SetClosestCity
$LN25@AddToDomin:

; 707  : 		}
; 708  : 	}
; 709  : 
; 710  : 	// Now see if we already have a matching zone
; 711  : 	CvTacticalDominanceZone* pZone = FindExistingZone(pPlot);

	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z ; CvTacticalAnalysisMap::FindExistingZone
	mov	DWORD PTR _pZone$[ebp], eax

; 712  : 	if(!pZone)

	cmp	DWORD PTR _pZone$[ebp], 0
	jne	SHORT $LN18@AddToDomin

; 713  : 	{
; 714  : 		// Data populated, now add to vector
; 715  : 		m_TempZone.SetDominanceZoneID(m_DominanceZones.size());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR $T226197[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T226197[ebp]
	mov	DWORD PTR [eax+36], ecx

; 716  : 		m_DominanceZones.push_back(m_TempZone);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back

; 717  : 		pZone = &m_DominanceZones[m_DominanceZones.size() - 1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR $T226211[ebp], ecx
	mov	edx, DWORD PTR $T226211[ebp]
	sub	edx, 1
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+112]
	mov	DWORD PTR _pZone$[ebp], edx
$LN18@AddToDomin:

; 718  : 	}
; 719  : 
; 720  : 	// If this isn't owned territory, update zone with military strength info
; 721  : 	if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER ||
; 722  : 	        pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE)

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226218[ebp], edx
	cmp	DWORD PTR $T226218[ebp], 1
	je	SHORT $LN16@AddToDomin
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226222[ebp], ecx
	cmp	DWORD PTR $T226222[ebp], 5
	jne	$LN17@AddToDomin
$LN16@AddToDomin:

; 723  : 	{
; 724  : 		CvUnit* pFriendlyUnit = pCell->GetFriendlyMilitaryUnit();

	mov	edx, DWORD PTR _pCell$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _pFriendlyUnit$221660[ebp], eax

; 725  : 		if(pFriendlyUnit)

	cmp	DWORD PTR _pFriendlyUnit$221660[ebp], 0
	je	$LN15@AddToDomin

; 726  : 		{
; 727  : 			if(pFriendlyUnit->getDomainType() == DOMAIN_AIR ||
; 728  : 			        (pFriendlyUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 729  : 			        (pFriendlyUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN13@AddToDomin
	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN12@AddToDomin
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	dl, BYTE PTR [ecx+68]
	mov	BYTE PTR $T226229[ebp], dl
	movzx	eax, BYTE PTR $T226229[ebp]
	test	eax, eax
	je	SHORT $LN13@AddToDomin
$LN12@AddToDomin:
	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN15@AddToDomin
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	dl, BYTE PTR [ecx+68]
	mov	BYTE PTR $T226233[ebp], dl
	movzx	eax, BYTE PTR $T226233[ebp]
	test	eax, eax
	je	$LN15@AddToDomin
$LN13@AddToDomin:

; 730  : 			{
; 731  : 				int iStrength = pFriendlyUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	mov	DWORD PTR _iStrength$221665[ebp], eax

; 732  : 				if(iStrength == 0 && pFriendlyUnit->isEmbarked() && !pZone->IsWater())

	cmp	DWORD PTR _iStrength$221665[ebp], 0
	jne	SHORT $LN11@AddToDomin
	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	mov	dl, BYTE PTR [ecx+1652]
	mov	BYTE PTR $T226242[ebp], dl
	movzx	eax, BYTE PTR $T226242[ebp]
	test	eax, eax
	je	SHORT $LN11@AddToDomin
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	dl, BYTE PTR [ecx+68]
	mov	BYTE PTR $T226246[ebp], dl
	movzx	eax, BYTE PTR $T226246[ebp]
	test	eax, eax
	jne	SHORT $LN11@AddToDomin

; 733  : 				{
; 734  : 					iStrength = pFriendlyUnit->GetBaseCombatStrength(true);

	push	1
	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	DWORD PTR _iStrength$221665[ebp], eax
$LN11@AddToDomin:

; 735  : 				}
; 736  : 				pZone->AddFriendlyStrength(iStrength * m_iUnitStrengthMultiplier);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iStrength$221665[ebp]
	imul	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226250[ebp], edx
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR $T226250[ebp]
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 737  : 				pZone->AddFriendlyRangedStrength(pFriendlyUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true));

	push	1
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	mov	DWORD PTR $T226254[ebp], eax
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, DWORD PTR $T226254[ebp]
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 738  : 				if(pFriendlyUnit->GetRange() > GetBestFriendlyRange())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T226258[ebp], ecx
	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	eax, DWORD PTR $T226258[ebp]
	jle	SHORT $LN10@AddToDomin

; 739  : 				{
; 740  : 					SetBestFriendlyRange(pFriendlyUnit->GetRange());

	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	mov	DWORD PTR $T226262[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T226262[ebp]
	mov	DWORD PTR [edx+28], eax
$LN10@AddToDomin:

; 741  : 				}
; 742  : 				if(pFriendlyUnit->IsRangeAttackIgnoreLOS())

	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ	; CvUnit::IsRangeAttackIgnoreLOS
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@AddToDomin

; 743  : 				{
; 744  : 					SetIgnoreLOS(true);

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+32], 1
$LN9@AddToDomin:

; 745  : 				}
; 746  : 				pZone->AddFriendlyUnitCount(1);

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, 1
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 747  : 				if(pFriendlyUnit->isRanged())

	mov	ecx, DWORD PTR _pFriendlyUnit$221660[ebp]
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@AddToDomin

; 748  : 				{
; 749  : 					pZone->AddFriendlyRangedUnitCount(1);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	add	edx, 1
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+48], edx
$LN15@AddToDomin:

; 750  : 				}
; 751  : 			}
; 752  : 		}
; 753  : 
; 754  : 		CvUnit* pEnemyUnit = pCell->GetEnemyMilitaryUnit();

	mov	ecx, DWORD PTR _pCell$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pEnemyUnit$221670[ebp], edx

; 755  : 		if(pEnemyUnit)

	cmp	DWORD PTR _pEnemyUnit$221670[ebp], 0
	je	$LN17@AddToDomin

; 756  : 		{
; 757  : 			if(pEnemyUnit->getDomainType() == DOMAIN_AIR ||
; 758  : 			        (pEnemyUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 759  : 			        (pEnemyUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN5@AddToDomin
	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@AddToDomin
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	cl, BYTE PTR [eax+68]
	mov	BYTE PTR $T226278[ebp], cl
	movzx	edx, BYTE PTR $T226278[ebp]
	test	edx, edx
	je	SHORT $LN5@AddToDomin
$LN4@AddToDomin:
	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN17@AddToDomin
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	cl, BYTE PTR [eax+68]
	mov	BYTE PTR $T226282[ebp], cl
	movzx	edx, BYTE PTR $T226282[ebp]
	test	edx, edx
	je	$LN17@AddToDomin
$LN5@AddToDomin:

; 760  : 			{
; 761  : 				int iStrength = pEnemyUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	mov	DWORD PTR _iStrength$221675[ebp], eax

; 762  : 				if(iStrength == 0 && pEnemyUnit->isEmbarked() && !pZone->IsWater())

	cmp	DWORD PTR _iStrength$221675[ebp], 0
	jne	SHORT $LN3@AddToDomin
	mov	eax, DWORD PTR _pEnemyUnit$221670[ebp]
	mov	cl, BYTE PTR [eax+1652]
	mov	BYTE PTR $T226291[ebp], cl
	movzx	edx, BYTE PTR $T226291[ebp]
	test	edx, edx
	je	SHORT $LN3@AddToDomin
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	cl, BYTE PTR [eax+68]
	mov	BYTE PTR $T226295[ebp], cl
	movzx	edx, BYTE PTR $T226295[ebp]
	test	edx, edx
	jne	SHORT $LN3@AddToDomin

; 763  : 				{
; 764  : 					iStrength = pEnemyUnit->GetBaseCombatStrength(true);

	push	1
	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	DWORD PTR _iStrength$221675[ebp], eax
$LN3@AddToDomin:

; 765  : 				}
; 766  : 				pZone->AddEnemyStrength(iStrength * m_iUnitStrengthMultiplier);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iStrength$221675[ebp]
	imul	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226299[ebp], ecx
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, DWORD PTR $T226299[ebp]
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 767  : 				pZone->AddEnemyRangedStrength(pEnemyUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true));

	push	1
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	mov	DWORD PTR $T226303[ebp], eax
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR $T226303[ebp]
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 768  : 				pZone->AddEnemyUnitCount(1);

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+44]
	add	eax, 1
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 769  : 				if(pEnemyUnit->isRanged())

	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@AddToDomin

; 770  : 				{
; 771  : 					pZone->AddEnemyRangedUnitCount(1);

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	add	ecx, 1
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+52], ecx
$LN2@AddToDomin:

; 772  : 				}
; 773  : 				if (pEnemyUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, DWORD PTR _pEnemyUnit$221670[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN17@AddToDomin

; 774  : 				{
; 775  : 					pZone->AddEnemyNavalUnitCount(1);

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	add	ecx, 1
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+56], ecx
$LN17@AddToDomin:

; 776  : 				}
; 777  : 			}
; 778  : 		}
; 779  : 	}
; 780  : 
; 781  : 	// Set zone for this cell
; 782  : 	pCell->SetDominanceZone(pZone->GetDominanceZoneID());

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226316[ebp], ecx
	mov	edx, DWORD PTR _pCell$[ebp]
	mov	eax, DWORD PTR $T226316[ebp]
	mov	DWORD PTR [edx+40], eax

; 783  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z ENDP ; CvTacticalAnalysisMap::AddToDominanceZones
_TEXT	ENDS
EXTRN	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentVisible
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
; Function compile flags: /Odtp
;	COMDAT ?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_this$ = -288						; size = 4
$T226646 = -284						; size = 4
$T226642 = -279						; size = 1
$T226638 = -278						; size = 1
$T226629 = -277						; size = 1
$T226558 = -208						; size = 4
$T226549 = -204						; size = 4
$T226540 = -200						; size = 4
$T226531 = -196						; size = 4
$T226522 = -190						; size = 1
$T226518 = -189						; size = 1
$T226506 = -188						; size = 4
$T226502 = -184						; size = 4
$T226481 = -180						; size = 4
$T226477 = -176						; size = 4
$T226473 = -172						; size = 4
$T226469 = -168						; size = 4
$T226465 = -162						; size = 1
$T226461 = -161						; size = 1
$T226415 = -116						; size = 4
$T226406 = -112						; size = 4
$T226397 = -108						; size = 4
$T226388 = -104						; size = 4
$T226379 = -98						; size = 1
$T226375 = -97						; size = 1
$T226363 = -96						; size = 4
$T226356 = -92						; size = 4
$T226349 = -88						; size = 4
$T226345 = -84						; size = 4
$T226341 = -80						; size = 4
$T226334 = -76						; size = 4
$T226330 = -72						; size = 4
_iRangedStrength$221736 = -68				; size = 4
_iUnitStrength$221733 = -64				; size = 4
_bVisible$221729 = -57					; size = 1
_pPlot$221727 = -56					; size = 4
_kPlayer$221717 = -52					; size = 4
_iPlayerLoop$221713 = -48				; size = 4
_iUnitStrength$221708 = -44				; size = 4
_iCityHitPoints$221695 = -40				; size = 4
_iStrength$221696 = -36					; size = 4
_iI$221689 = -32					; size = 4
_iDistance$ = -28					; size = 4
_pZone$ = -24						; size = 4
_pLoopUnit$ = -20					; size = 4
_pClosestCity$ = -16					; size = 4
_eTeam$ = -12						; size = 4
_iMultiplier$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ PROC ; CvTacticalAnalysisMap::CalculateMilitaryStrengths, COMDAT
; _this$ = ecx

; 787  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 788  : 	// Loop through the dominance zones
; 789  : 	CvTacticalDominanceZone* pZone;
; 790  : 	CvCity* pClosestCity = NULL;

	mov	DWORD PTR _pClosestCity$[ebp], 0

; 791  : 	int iDistance;
; 792  : 	int iMultiplier;
; 793  : 	int iLoop;
; 794  : 	CvUnit* pLoopUnit;
; 795  : 	TeamTypes eTeam;
; 796  : 
; 797  : 	eTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T226330[ebp], ecx
	mov	edx, DWORD PTR $T226330[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 798  : 
; 799  : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	DWORD PTR _iI$221689[ebp], 0
	jmp	SHORT $LN42@CalculateM
$LN41@CalculateM:
	mov	ecx, DWORD PTR _iI$221689[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221689[ebp], ecx
$LN42@CalculateM:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR $T226334[ebp], eax
	mov	ecx, DWORD PTR _iI$221689[ebp]
	cmp	ecx, DWORD PTR $T226334[ebp]
	jae	$LN43@CalculateM

; 800  : 	{
; 801  : 		pZone = &m_DominanceZones[iI];

	mov	edx, DWORD PTR _iI$221689[ebp]
	imul	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+112]
	mov	DWORD PTR _pZone$[ebp], edx

; 802  : 
; 803  : 		if(pZone->GetTerritoryType() != TACTICAL_TERRITORY_NO_OWNER)

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226341[ebp], edx
	cmp	DWORD PTR $T226341[ebp], 1
	je	$LN39@CalculateM

; 804  : 		{
; 805  : 			pClosestCity = pZone->GetClosestCity();

	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	DWORD PTR _pClosestCity$[ebp], eax

; 806  : 			if(pClosestCity)

	cmp	DWORD PTR _pClosestCity$[ebp], 0
	je	$LN39@CalculateM

; 807  : 			{
; 808  : 				// Start with strength of the city itself
; 809  : 				int iCityHitPoints = pClosestCity->GetMaxHitPoints() - pClosestCity->getDamage();

	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	esi, eax
	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	sub	esi, eax
	mov	DWORD PTR _iCityHitPoints$221695[ebp], esi

; 810  : 				int iStrength = m_iTacticalRange * pClosestCity->getStrengthValue() * iCityHitPoints / GC.getMAX_CITY_HIT_POINTS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7372
	mov	DWORD PTR $T226345[ebp], eax
	push	0
	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR _iCityHitPoints$221695[ebp]
	cdq
	idiv	DWORD PTR $T226345[ebp]
	mov	DWORD PTR _iStrength$221696[ebp], eax

; 811  : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226349[ebp], eax
	cmp	DWORD PTR $T226349[ebp], 2
	jne	SHORT $LN37@CalculateM

; 812  : 				{
; 813  : 					pZone->AddFriendlyStrength(iStrength);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _iStrength$221696[ebp]
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+24], edx

; 814  : 					pZone->AddFriendlyRangedStrength(pClosestCity->getStrengthValue());

	push	0
	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	DWORD PTR $T226356[ebp], eax
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, DWORD PTR $T226356[ebp]
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+32], edx

; 815  : 				}
; 816  : 				else

	jmp	SHORT $LN36@CalculateM
$LN37@CalculateM:

; 817  : 				{
; 818  : 					pZone->AddEnemyStrength(iStrength);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, DWORD PTR _iStrength$221696[ebp]
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+28], edx

; 819  : 					pZone->AddEnemyRangedStrength(pClosestCity->getStrengthValue());

	push	0
	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	DWORD PTR $T226363[ebp], eax
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR $T226363[ebp]
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN36@CalculateM:

; 820  : 				}
; 821  : 
; 822  : 				// Loop through all of OUR units first
; 823  : 				for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN35@CalculateM
$LN34@CalculateM:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN35@CalculateM:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN33@CalculateM

; 824  : 				{
; 825  : 					if(pLoopUnit->IsCombatUnit())

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+1044], 0
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	$LN32@CalculateM

; 826  : 					{
; 827  : 						if(pLoopUnit->getDomainType() == DOMAIN_AIR ||
; 828  : 						        (pLoopUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 829  : 						        (pLoopUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN77@CalculateM
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN29@CalculateM
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	al, BYTE PTR [edx+68]
	mov	BYTE PTR $T226375[ebp], al
	movzx	ecx, BYTE PTR $T226375[ebp]
	test	ecx, ecx
	je	SHORT $LN77@CalculateM
$LN29@CalculateM:
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN32@CalculateM
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	al, BYTE PTR [edx+68]
	mov	BYTE PTR $T226379[ebp], al
	movzx	ecx, BYTE PTR $T226379[ebp]
	test	ecx, ecx
	je	$LN32@CalculateM

; 830  : 						{
; 831  : 							iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pClosestCity->getX(), pClosestCity->getY());

$LN77@CalculateM:
	mov	edx, DWORD PTR _pClosestCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T226388[ebp], eax
	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T226397[ebp], edx
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T226406[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T226415[ebp], eax
	mov	ecx, DWORD PTR $T226388[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226397[ebp]
	push	edx
	mov	eax, DWORD PTR $T226406[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226415[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$[ebp], eax

; 832  : 							if (iDistance <= m_iTacticalRange)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iDistance$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jg	$LN32@CalculateM

; 833  : 							{
; 834  : 								iMultiplier = (m_iTacticalRange + 4 - iDistance);  // "4" so unit strength isn't totally dominated by proximity to city

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 4
	sub	edx, DWORD PTR _iDistance$[ebp]
	mov	DWORD PTR _iMultiplier$[ebp], edx

; 835  : 								if(iMultiplier > 0)

	cmp	DWORD PTR _iMultiplier$[ebp], 0
	jle	$LN32@CalculateM

; 836  : 								{
; 837  : 									int iUnitStrength = pLoopUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	mov	DWORD PTR _iUnitStrength$221708[ebp], eax

; 838  : 									if(iUnitStrength == 0 && pLoopUnit->isEmbarked() && !pZone->IsWater())

	cmp	DWORD PTR _iUnitStrength$221708[ebp], 0
	jne	SHORT $LN26@CalculateM
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	cl, BYTE PTR [eax+1652]
	mov	BYTE PTR $T226461[ebp], cl
	movzx	edx, BYTE PTR $T226461[ebp]
	test	edx, edx
	je	SHORT $LN26@CalculateM
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	cl, BYTE PTR [eax+68]
	mov	BYTE PTR $T226465[ebp], cl
	movzx	edx, BYTE PTR $T226465[ebp]
	test	edx, edx
	jne	SHORT $LN26@CalculateM

; 839  : 									{
; 840  : 										iUnitStrength = pLoopUnit->GetBaseCombatStrength(true);

	push	1
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	DWORD PTR _iUnitStrength$221708[ebp], eax
$LN26@CalculateM:

; 841  : 									}
; 842  : 									pZone->AddFriendlyStrength(iUnitStrength * iMultiplier * m_iUnitStrengthMultiplier);

	mov	eax, DWORD PTR _iUnitStrength$221708[ebp]
	imul	eax, DWORD PTR _iMultiplier$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226469[ebp], eax
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR $T226469[ebp]
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 843  : 									pZone->AddFriendlyRangedStrength(pLoopUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true));

	push	1
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	mov	DWORD PTR $T226473[ebp], eax
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	eax, DWORD PTR $T226473[ebp]
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 844  : 									if(pLoopUnit->GetRange() > GetBestFriendlyRange())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T226477[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	eax, DWORD PTR $T226477[ebp]
	jle	SHORT $LN25@CalculateM

; 845  : 									{
; 846  : 										SetBestFriendlyRange(pLoopUnit->GetRange());

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	mov	DWORD PTR $T226481[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T226481[ebp]
	mov	DWORD PTR [ecx+28], edx
$LN25@CalculateM:

; 847  : 									}
; 848  : 									if(pLoopUnit->IsRangeAttackIgnoreLOS())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ	; CvUnit::IsRangeAttackIgnoreLOS
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@CalculateM

; 849  : 									{
; 850  : 										SetIgnoreLOS(true);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+32], 1
$LN24@CalculateM:

; 851  : 									}
; 852  : 									pZone->AddFriendlyUnitCount(1);

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+40]
	add	eax, 1
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 853  : 									if(pLoopUnit->isRanged())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN32@CalculateM

; 854  : 									{
; 855  : 										pZone->AddFriendlyRangedUnitCount(1);

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	add	ecx, 1
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+48], ecx
$LN32@CalculateM:

; 856  : 									}
; 857  : 								}
; 858  : 							}
; 859  : 						}
; 860  : 					}
; 861  : 				}

	jmp	$LN34@CalculateM
$LN33@CalculateM:

; 862  : 
; 863  : 				// Repeat for all visible enemy units (or adjacent to visible)
; 864  : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	DWORD PTR _iPlayerLoop$221713[ebp], 0
	jmp	SHORT $LN22@CalculateM
$LN21@CalculateM:
	mov	eax, DWORD PTR _iPlayerLoop$221713[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlayerLoop$221713[ebp], eax
$LN22@CalculateM:
	cmp	DWORD PTR _iPlayerLoop$221713[ebp], 63	; 0000003fH
	jge	$LN39@CalculateM

; 865  : 				{
; 866  : 					CvPlayer& kPlayer = GET_PLAYER((PlayerTypes) iPlayerLoop);

	mov	ecx, DWORD PTR _iPlayerLoop$221713[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$221717[ebp], ecx

; 867  : 					if(GET_TEAM(eTeam).isAtWar(kPlayer.getTeam()))

	mov	edx, DWORD PTR _kPlayer$221717[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226502[ebp], eax
	mov	ecx, DWORD PTR _eTeam$[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T226506[ebp], ecx
	mov	edx, DWORD PTR $T226502[ebp]
	push	edx
	mov	ecx, DWORD PTR $T226506[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	movzx	eax, al
	test	eax, eax
	je	$LN19@CalculateM

; 868  : 					{
; 869  : 						for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$221717[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN18@CalculateM
$LN17@CalculateM:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$221717[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN18@CalculateM:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN19@CalculateM

; 870  : 						{
; 871  : 							if(pLoopUnit->IsCombatUnit())

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+1044], 0
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN15@CalculateM

; 872  : 							{
; 873  : 								if(pLoopUnit->getDomainType() == DOMAIN_AIR ||
; 874  : 								        (pLoopUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 875  : 								        (pLoopUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN13@CalculateM
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN12@CalculateM
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	cl, BYTE PTR [eax+68]
	mov	BYTE PTR $T226518[ebp], cl
	movzx	edx, BYTE PTR $T226518[ebp]
	test	edx, edx
	je	SHORT $LN13@CalculateM
$LN12@CalculateM:
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN15@CalculateM
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	cl, BYTE PTR [eax+68]
	mov	BYTE PTR $T226522[ebp], cl
	movzx	edx, BYTE PTR $T226522[ebp]
	test	edx, edx
	je	$LN15@CalculateM
$LN13@CalculateM:

; 876  : 								{
; 877  : 									CvPlot* pPlot;
; 878  : 									pPlot = pLoopUnit->plot();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	DWORD PTR _pPlot$221727[ebp], eax

; 879  : 									if(pPlot)

	cmp	DWORD PTR _pPlot$221727[ebp], 0
	je	$LN15@CalculateM

; 880  : 									{
; 881  : 										bool bVisible = true;

	mov	BYTE PTR _bVisible$221729[ebp], 1

; 882  : 										iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pClosestCity->getX(), pClosestCity->getY());

	mov	eax, DWORD PTR _pClosestCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T226531[ebp], ecx
	mov	edx, DWORD PTR _pClosestCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T226540[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T226549[ebp], edx
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T226558[ebp], ecx
	mov	edx, DWORD PTR $T226531[ebp]
	push	edx
	mov	eax, DWORD PTR $T226540[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226549[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226558[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$[ebp], eax

; 883  : 										if (iDistance <= m_iTacticalRange)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iDistance$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jg	$LN15@CalculateM

; 884  : 										{
; 885  : 											iMultiplier = (m_iTacticalRange + 4 - iDistance);  // "4" so unit strength isn't totally dominated by proximity to city

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 4
	sub	eax, DWORD PTR _iDistance$[ebp]
	mov	DWORD PTR _iMultiplier$[ebp], eax

; 886  : 											if(!pPlot->isVisible(eTeam) && !pPlot->isAdjacentVisible(eTeam, false))

	cmp	DWORD PTR _eTeam$[ebp], -1
	jne	SHORT $LN210@CalculateM
	mov	BYTE PTR $T226629[ebp], 0
	jmp	SHORT $LN208@CalculateM
$LN210@CalculateM:
	mov	ecx, DWORD PTR _pPlot$221727[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _eTeam$[ebp]
	movsx	ecx, WORD PTR [edx+eax*2]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	mov	BYTE PTR $T226629[ebp], dl
$LN208@CalculateM:
	movzx	eax, BYTE PTR $T226629[ebp]
	test	eax, eax
	jne	SHORT $LN9@CalculateM
	push	0
	mov	ecx, DWORD PTR _eTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$221727[ebp]
	call	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentVisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@CalculateM

; 887  : 											{
; 888  : 												bVisible = false;

	mov	BYTE PTR _bVisible$221729[ebp], 0
$LN9@CalculateM:

; 889  : 											}
; 890  : 											if(iMultiplier > 0)

	cmp	DWORD PTR _iMultiplier$[ebp], 0
	jle	$LN15@CalculateM

; 891  : 											{
; 892  : 												int iUnitStrength = pLoopUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	mov	DWORD PTR _iUnitStrength$221733[ebp], eax

; 893  : 												if(iUnitStrength == 0 && pLoopUnit->isEmbarked() && !pZone->IsWater())

	cmp	DWORD PTR _iUnitStrength$221733[ebp], 0
	jne	SHORT $LN7@CalculateM
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	cl, BYTE PTR [eax+1652]
	mov	BYTE PTR $T226638[ebp], cl
	movzx	edx, BYTE PTR $T226638[ebp]
	test	edx, edx
	je	SHORT $LN7@CalculateM
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	cl, BYTE PTR [eax+68]
	mov	BYTE PTR $T226642[ebp], cl
	movzx	edx, BYTE PTR $T226642[ebp]
	test	edx, edx
	jne	SHORT $LN7@CalculateM

; 894  : 												{
; 895  : 													iUnitStrength = pLoopUnit->GetBaseCombatStrength(true);

	push	1
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	DWORD PTR _iUnitStrength$221733[ebp], eax
$LN7@CalculateM:

; 896  : 												}
; 897  : 
; 898  : 												if(!bVisible)

	movzx	eax, BYTE PTR _bVisible$221729[ebp]
	test	eax, eax
	jne	SHORT $LN6@CalculateM

; 899  : 												{
; 900  : 													iUnitStrength /= 2;

	mov	eax, DWORD PTR _iUnitStrength$221733[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iUnitStrength$221733[ebp], eax
$LN6@CalculateM:

; 901  : 												}
; 902  : 
; 903  : 												pZone->AddEnemyStrength(iUnitStrength * iMultiplier * m_iUnitStrengthMultiplier);

	mov	ecx, DWORD PTR _iUnitStrength$221733[ebp]
	imul	ecx, DWORD PTR _iMultiplier$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	imul	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T226646[ebp], ecx
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, DWORD PTR $T226646[ebp]
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 904  : 
; 905  : 												int iRangedStrength = pLoopUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true);

	push	1
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	mov	DWORD PTR _iRangedStrength$221736[ebp], eax

; 906  : 												if(!bVisible)

	movzx	eax, BYTE PTR _bVisible$221729[ebp]
	test	eax, eax
	jne	SHORT $LN5@CalculateM

; 907  : 												{
; 908  : 													iRangedStrength /= 2;

	mov	eax, DWORD PTR _iRangedStrength$221736[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iRangedStrength$221736[ebp], eax
$LN5@CalculateM:

; 909  : 												}
; 910  : 
; 911  : 												pZone->AddEnemyRangedStrength(iRangedStrength);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, DWORD PTR _iRangedStrength$221736[ebp]
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+36], edx

; 912  : 
; 913  : 												if(bVisible)

	movzx	ecx, BYTE PTR _bVisible$221729[ebp]
	test	ecx, ecx
	je	SHORT $LN15@CalculateM

; 914  : 												{
; 915  : 													pZone->AddEnemyUnitCount(1);

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+44]
	add	eax, 1
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 916  : 													if(iDistance < pZone->GetRangeClosestEnemyUnit())

	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit
	cmp	DWORD PTR _iDistance$[ebp], eax
	jge	SHORT $LN3@CalculateM

; 917  : 													{
; 918  : 														pZone->SetRangeClosestEnemyUnit(iDistance);

	mov	edx, DWORD PTR _iDistance$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::SetRangeClosestEnemyUnit
$LN3@CalculateM:

; 919  : 													}
; 920  : 													if(pLoopUnit->isRanged())

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@CalculateM

; 921  : 													{
; 922  : 														pZone->AddEnemyRangedUnitCount(1);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	add	edx, 1
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+52], edx
$LN2@CalculateM:

; 923  : 													}
; 924  : 													if(pLoopUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN15@CalculateM

; 925  : 													{
; 926  : 														pZone->AddEnemyNavalUnitCount(1);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	add	edx, 1
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+56], edx
$LN15@CalculateM:

; 927  : 													}
; 928  : 												}
; 929  : 											}
; 930  : 										}
; 931  : 									}
; 932  : 								}
; 933  : 							}
; 934  : 						}

	jmp	$LN17@CalculateM
$LN19@CalculateM:

; 935  : 
; 936  : 					}
; 937  : 				}

	jmp	$LN21@CalculateM
$LN39@CalculateM:

; 938  : 			}
; 939  : 		}

	jmp	$LN41@CalculateM
$LN43@CalculateM:

; 940  : 	}
; 941  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ ENDP ; CvTacticalAnalysisMap::CalculateMilitaryStrengths
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
PUBLIC	?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAnalysisMap::ComputeDominance
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?isVisible@CvCity@@QBE_NW4TeamTypes@@_N@Z:PROC	; CvCity::isVisible
EXTRN	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z:PROC ; CvTacticalAI::IsTemporaryZoneCity
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ:PROC	; CvCity::GetPlayer
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
;	COMDAT ?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_this$ = -244						; size = 4
$T226738 = -100						; size = 4
$T226734 = -96						; size = 4
$T226733 = -92						; size = 4
$T226726 = -88						; size = 4
$T226722 = -84						; size = 4
$T226718 = -80						; size = 4
$T226714 = -76						; size = 4
$T226710 = -72						; size = 4
$T226706 = -68						; size = 4
$T226702 = -64						; size = 4
$T226698 = -60						; size = 4
$T226694 = -53						; size = 1
$T226690 = -52						; size = 4
$T226689 = -48						; size = 4
$T226680 = -44						; size = 4
$T226671 = -40						; size = 4
$T226664 = -36						; size = 4
_iDamage$221764 = -32					; size = 4
_iMaxDamageMultiplier$221763 = -28			; size = 4
_eDominance$221753 = -24				; size = 4
_iI$221749 = -20					; size = 4
_pZone$ = -16						; size = 4
_iBaseValue$ = -12					; size = 4
_pClosestCity$ = -8					; size = 4
_iMultiplier$ = -4					; size = 4
?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::PrioritizeZones, COMDAT
; _this$ = ecx

; 945  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 946  : 	// Loop through the dominance zones
; 947  : 	CvTacticalDominanceZone* pZone;
; 948  : 	int iBaseValue;
; 949  : 	int iMultiplier;
; 950  : 	CvCity* pClosestCity = NULL;

	mov	DWORD PTR _pClosestCity$[ebp], 0

; 951  : 
; 952  : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	DWORD PTR _iI$221749[ebp], 0
	jmp	SHORT $LN33@Prioritize
$LN32@Prioritize:
	mov	eax, DWORD PTR _iI$221749[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221749[ebp], eax
$LN33@Prioritize:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR $T226664[ebp], edx
	mov	eax, DWORD PTR _iI$221749[ebp]
	cmp	eax, DWORD PTR $T226664[ebp]
	jae	$LN31@Prioritize

; 953  : 	{
; 954  : 		// Find the zone and compute dominance here
; 955  : 		pZone = &m_DominanceZones[iI];

	mov	ecx, DWORD PTR _iI$221749[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+112]
	mov	DWORD PTR _pZone$[ebp], ecx

; 956  : 		eTacticalDominanceFlags eDominance = ComputeDominance(pZone);

	mov	eax, DWORD PTR _pZone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAnalysisMap::ComputeDominance
	mov	DWORD PTR _eDominance$221753[ebp], eax

; 957  : 
; 958  : 		// Establish a base value for the region
; 959  : 		iBaseValue = 1;

	mov	DWORD PTR _iBaseValue$[ebp], 1

; 960  : 
; 961  : 		// Temporary zone?
; 962  : 		if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE)

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226671[ebp], edx
	cmp	DWORD PTR $T226671[ebp], 5
	jne	SHORT $LN30@Prioritize

; 963  : 		{
; 964  : 			iMultiplier = 1000;

	mov	DWORD PTR _iMultiplier$[ebp], 1000	; 000003e8H

; 965  : 		}
; 966  : 		else

	jmp	$LN2@Prioritize
$LN30@Prioritize:

; 967  : 		{
; 968  : 			pClosestCity = pZone->GetClosestCity();

	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	DWORD PTR _pClosestCity$[ebp], eax

; 969  : 
; 970  : 			if(pClosestCity)

	cmp	DWORD PTR _pClosestCity$[ebp], 0
	je	$LN23@Prioritize

; 971  : 			{
; 972  : 				iBaseValue += (1 + (int)sqrt((float)pZone->GetClosestCity()->getPopulation()));

	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cvtsi2ss xmm0, eax
	movss	DWORD PTR $T226680[ebp], xmm0
	sqrtss	xmm0, DWORD PTR $T226680[ebp]
	cvttss2si eax, xmm0
	mov	ecx, DWORD PTR _iBaseValue$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _iBaseValue$[ebp], edx

; 973  : 
; 974  : 				if(pClosestCity->isCapital() && !pClosestCity->GetPlayer()->isMinorCiv())

	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN27@Prioritize
	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN27@Prioritize

; 975  : 				{
; 976  : 					iBaseValue *= 2;

	mov	edx, DWORD PTR _iBaseValue$[ebp]
	shl	edx, 1
	mov	DWORD PTR _iBaseValue$[ebp], edx
$LN27@Prioritize:

; 977  : 				}
; 978  : 
; 979  : 				if(m_pPlayer->GetTacticalAI()->IsTemporaryZoneCity(pClosestCity))

	mov	eax, DWORD PTR _pClosestCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ; CvTacticalAI::IsTemporaryZoneCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN26@Prioritize

; 980  : 				{
; 981  : 					iBaseValue *= 20;

	mov	eax, DWORD PTR _iBaseValue$[ebp]
	imul	eax, 20					; 00000014H
	mov	DWORD PTR _iBaseValue$[ebp], eax
	jmp	$LN23@Prioritize
$LN26@Prioritize:

; 982  : 				}
; 983  : 
; 984  : 				else if (pZone->GetClosestCity()->isVisible(m_pPlayer->getTeam(), false))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T226689[ebp], edx
	mov	eax, DWORD PTR $T226689[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T226690[ebp], eax
	push	0
	mov	edx, DWORD PTR $T226690[ebp]
	push	edx
	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?isVisible@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isVisible
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN23@Prioritize

; 985  : 				{
; 986  : 					iBaseValue *= 4;

	mov	ecx, DWORD PTR _iBaseValue$[ebp]
	shl	ecx, 2
	mov	DWORD PTR _iBaseValue$[ebp], ecx

; 987  : 
; 988  : 					// How damaged is this visible city?
; 989  : 					int iMaxDamageMultiplier = 10;

	mov	DWORD PTR _iMaxDamageMultiplier$221763[ebp], 10 ; 0000000aH

; 990  : 					int iDamage = pClosestCity->getDamage();

	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	DWORD PTR _iDamage$221764[ebp], eax

; 991  : 					if (iDamage > (pClosestCity->GetMaxHitPoints() / iMaxDamageMultiplier))

	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	cdq
	idiv	DWORD PTR _iMaxDamageMultiplier$221763[ebp]
	cmp	DWORD PTR _iDamage$221764[ebp], eax
	jle	SHORT $LN23@Prioritize

; 992  : 					{
; 993  : 						iBaseValue *= (int)((iDamage + 1) * 10 / pClosestCity->GetMaxHitPoints());

	mov	esi, DWORD PTR _iDamage$221764[ebp]
	add	esi, 1
	imul	esi, 10					; 0000000aH
	mov	ecx, DWORD PTR _pClosestCity$[ebp]
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	imul	eax, DWORD PTR _iBaseValue$[ebp]
	mov	DWORD PTR _iBaseValue$[ebp], eax
$LN23@Prioritize:

; 994  : 					}
; 995  : 				}
; 996  : 			}
; 997  : 
; 998  : 			if(!pZone->IsWater())

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	al, BYTE PTR [edx+68]
	mov	BYTE PTR $T226694[ebp], al
	movzx	ecx, BYTE PTR $T226694[ebp]
	test	ecx, ecx
	jne	SHORT $LN22@Prioritize

; 999  : 			{
; 1000 : 				iBaseValue *= 3;

	mov	edx, DWORD PTR _iBaseValue$[ebp]
	imul	edx, 3
	mov	DWORD PTR _iBaseValue$[ebp], edx
$LN22@Prioritize:

; 1001 : 			}
; 1002 : 
; 1003 : 			// Now compute a multiplier based on current conditions here
; 1004 : 			iMultiplier = 1;

	mov	DWORD PTR _iMultiplier$[ebp], 1

; 1005 : 			if(eDominance == TACTICAL_DOMINANCE_ENEMY)

	cmp	DWORD PTR _eDominance$221753[ebp], 2
	jne	SHORT $LN21@Prioritize

; 1006 : 			{
; 1007 : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226698[ebp], ecx
	cmp	DWORD PTR $T226698[ebp], 3
	jne	SHORT $LN20@Prioritize

; 1008 : 				{
; 1009 : 					iMultiplier = 2;

	mov	DWORD PTR _iMultiplier$[ebp], 2
	jmp	SHORT $LN18@Prioritize
$LN20@Prioritize:

; 1010 : 				}
; 1011 : 				else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226702[ebp], eax
	cmp	DWORD PTR $T226702[ebp], 2
	jne	SHORT $LN18@Prioritize

; 1012 : 				{
; 1013 : 					iMultiplier = 6;

	mov	DWORD PTR _iMultiplier$[ebp], 6
$LN18@Prioritize:

; 1014 : 				}
; 1015 : 			}

	jmp	SHORT $LN8@Prioritize
$LN21@Prioritize:

; 1016 : 			else if(eDominance == TACTICAL_DOMINANCE_EVEN)

	cmp	DWORD PTR _eDominance$221753[ebp], 3
	jne	SHORT $LN16@Prioritize

; 1017 : 			{
; 1018 : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226706[ebp], edx
	cmp	DWORD PTR $T226706[ebp], 3
	jne	SHORT $LN15@Prioritize

; 1019 : 				{
; 1020 : 					iMultiplier = 4;

	mov	DWORD PTR _iMultiplier$[ebp], 4
	jmp	SHORT $LN13@Prioritize
$LN15@Prioritize:

; 1021 : 				}
; 1022 : 				else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226710[ebp], ecx
	cmp	DWORD PTR $T226710[ebp], 2
	jne	SHORT $LN13@Prioritize

; 1023 : 				{
; 1024 : 					iMultiplier = 4;

	mov	DWORD PTR _iMultiplier$[ebp], 4
$LN13@Prioritize:

; 1025 : 				}
; 1026 : 			}

	jmp	SHORT $LN8@Prioritize
$LN16@Prioritize:

; 1027 : 			else if(eDominance == TACTICAL_DOMINANCE_FRIENDLY)

	cmp	DWORD PTR _eDominance$221753[ebp], 1
	jne	SHORT $LN8@Prioritize

; 1028 : 			{
; 1029 : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226714[ebp], eax
	cmp	DWORD PTR $T226714[ebp], 3
	jne	SHORT $LN10@Prioritize

; 1030 : 				{
; 1031 : 					iMultiplier = 8;

	mov	DWORD PTR _iMultiplier$[ebp], 8
	jmp	SHORT $LN8@Prioritize
$LN10@Prioritize:

; 1032 : 				}
; 1033 : 				else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226718[ebp], edx
	cmp	DWORD PTR $T226718[ebp], 2
	jne	SHORT $LN8@Prioritize

; 1034 : 				{
; 1035 : 					iMultiplier = 1;

	mov	DWORD PTR _iMultiplier$[ebp], 1
$LN8@Prioritize:

; 1036 : 				}
; 1037 : 			}
; 1038 : 			if(!m_pPlayer->isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@Prioritize

; 1039 : 			{
; 1040 : 				if(m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	SHORT $LN6@Prioritize

; 1041 : 				{
; 1042 : 					if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226722[ebp], ecx
	cmp	DWORD PTR $T226722[ebp], 3
	jne	SHORT $LN5@Prioritize

; 1043 : 					{
; 1044 : 						iMultiplier *= 2;

	mov	edx, DWORD PTR _iMultiplier$[ebp]
	shl	edx, 1
	mov	DWORD PTR _iMultiplier$[ebp], edx
$LN5@Prioritize:

; 1045 : 					}
; 1046 : 				}

	jmp	SHORT $LN2@Prioritize
$LN6@Prioritize:

; 1047 : 				else if(m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	SHORT $LN2@Prioritize

; 1048 : 				{
; 1049 : 					if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T226726[ebp], edx
	cmp	DWORD PTR $T226726[ebp], 2
	jne	SHORT $LN2@Prioritize

; 1050 : 					{
; 1051 : 						iMultiplier *= 4;

	mov	eax, DWORD PTR _iMultiplier$[ebp]
	shl	eax, 2
	mov	DWORD PTR _iMultiplier$[ebp], eax
$LN2@Prioritize:

; 1052 : 					}
; 1053 : 				}
; 1054 : 			}
; 1055 : 		}
; 1056 : 
; 1057 : 		// Save off the value for this zone
; 1058 : 		if((iBaseValue * iMultiplier) <= 0)
; 1059 : 		{
; 1060 : 			FAssertMsg((iBaseValue * iMultiplier) > 0, "Invalid Dominance Zone Value");
; 1061 : 		}
; 1062 : 		pZone->SetDominanceZoneValue(iBaseValue * iMultiplier);

	mov	edx, DWORD PTR _iBaseValue$[ebp]
	imul	edx, DWORD PTR _iMultiplier$[ebp]
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+60], edx

; 1063 : 	}

	jmp	$LN32@Prioritize
$LN31@Prioritize:

; 1064 : 
; 1065 : 	std::stable_sort(m_DominanceZones.begin(), m_DominanceZones.end());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR $T226733[ebp], ecx
	mov	edx, DWORD PTR $T226733[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR $T226733[ebp]
	add	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T226734[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR $T226738[ebp], eax
	mov	ecx, DWORD PTR $T226738[ebp]
	cmp	ecx, DWORD PTR $T226734[ebp]
	je	SHORT $LN74@Prioritize
	push	0
	push	0
	mov	edx, DWORD PTR $T226734[ebp]
	push	edx
	mov	eax, DWORD PTR $T226738[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H
$LN74@Prioritize:

; 1066 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::PrioritizeZones
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_07IAMPFPIC@?5?$CITemp?$CJ?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0BB@FKBOJJDN@?0?5Temporary?5Zone?$AA@	; `string'
PUBLIC	??_C@_06DAGDBLPI@?0?5Land?$AA@			; `string'
PUBLIC	??_C@_07PJCICNNF@?0?5Water?$AA@			; `string'
PUBLIC	??_C@_0BD@PCFJBCFG@?0?5No?5Units?5Visible?$AA@	; `string'
PUBLIC	??_C@_06GAHBBME@?0?5Even?$AA@			; `string'
PUBLIC	??_C@_07DACEKBBN@?0?5Enemy?$AA@			; `string'
PUBLIC	??_C@_0L@HPDPHCOP@?0?5Friendly?$AA@		; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_0IE@KBCDNJJP@Zone?5ID?3?5?$CFd?0?5Area?5ID?3?5?$CFd?0?5Value?3@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z:PROC ; CvTacticalAI::LogTacticalMessage
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_07IAMPFPIC@?5?$CITemp?$CJ?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_07IAMPFPIC@?5?$CITemp?$CJ?$AA@ DB ' (Temp)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FKBOJJDN@?0?5Temporary?5Zone?$AA@
CONST	SEGMENT
??_C@_0BB@FKBOJJDN@?0?5Temporary?5Zone?$AA@ DB ', Temporary Zone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DAGDBLPI@?0?5Land?$AA@
CONST	SEGMENT
??_C@_06DAGDBLPI@?0?5Land?$AA@ DB ', Land', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PJCICNNF@?0?5Water?$AA@
CONST	SEGMENT
??_C@_07PJCICNNF@?0?5Water?$AA@ DB ', Water', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCFJBCFG@?0?5No?5Units?5Visible?$AA@
CONST	SEGMENT
??_C@_0BD@PCFJBCFG@?0?5No?5Units?5Visible?$AA@ DB ', No Units Visible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GAHBBME@?0?5Even?$AA@
CONST	SEGMENT
??_C@_06GAHBBME@?0?5Even?$AA@ DB ', Even', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DACEKBBN@?0?5Enemy?$AA@
CONST	SEGMENT
??_C@_07DACEKBBN@?0?5Enemy?$AA@ DB ', Enemy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPDPHCOP@?0?5Friendly?$AA@
CONST	SEGMENT
??_C@_0L@HPDPHCOP@?0?5Friendly?$AA@ DB ', Friendly', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IE@KBCDNJJP@Zone?5ID?3?5?$CFd?0?5Area?5ID?3?5?$CFd?0?5Value?3@
CONST	SEGMENT
??_C@_0IE@KBCDNJJP@Zone?5ID?3?5?$CFd?0?5Area?5ID?3?5?$CFd?0?5Value?3@ DB 'Z'
	DB	'one ID: %d, Area ID: %d, Value: %d, FRIENDLY Str: %d (%d), Ra'
	DB	'nged: %d (%d), ENEMY Str: %d (%d), Ranged: %d (%d), Closest E'
	DB	'nemy: %d', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogZones@CvTacticalAnalysisMap@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$2
__ehfuncinfo$?LogZones@CvTacticalAnalysisMap@@IAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LogZones@CvTacticalAnalysisMap@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ?LogZones@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
tv275 = -200						; size = 4
tv74 = -196						; size = 4
tv273 = -192						; size = 4
tv281 = -188						; size = 4
_this$ = -184						; size = 4
$T227015 = -180						; size = 4
$T227011 = -173						; size = 1
$T227007 = -172						; size = 4
$T227003 = -168						; size = 4
$T226999 = -164						; size = 4
$T226995 = -160						; size = 4
$T226991 = -156						; size = 4
$T226987 = -152						; size = 4
$T226983 = -148						; size = 4
$T226979 = -144						; size = 4
$T226975 = -140						; size = 4
$T226971 = -136						; size = 4
$T226967 = -132						; size = 4
$T226963 = -128						; size = 4
$T226959 = -124						; size = 4
$T226955 = -120						; size = 4
$T226951 = -116						; size = 4
$T226944 = -112						; size = 4
$T226933 = -108						; size = 28
$T226932 = -80						; size = 28
_iI$221800 = -52					; size = 4
_pZone$221799 = -48					; size = 4
_szLogMsg$221798 = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogZones@CvTacticalAnalysisMap@@IAEXXZ PROC		; CvTacticalAnalysisMap::LogZones, COMDAT
; _this$ = ecx

; 1070 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogZones@CvTacticalAnalysisMap@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1071 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN18@LogZones
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN18@LogZones

; 1072 : 	{
; 1073 : 		CvString szLogMsg;

	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1074 : 		CvTacticalDominanceZone* pZone;
; 1075 : 
; 1076 : 		for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	DWORD PTR _iI$221800[ebp], 0
	jmp	SHORT $LN16@LogZones
$LN15@LogZones:
	mov	edx, DWORD PTR _iI$221800[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$221800[ebp], edx
$LN16@LogZones:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR $T226944[ebp], ecx
	mov	edx, DWORD PTR _iI$221800[ebp]
	cmp	edx, DWORD PTR $T226944[ebp]
	jae	$LN14@LogZones

; 1077 : 		{
; 1078 : 			pZone = &m_DominanceZones[iI];

	mov	eax, DWORD PTR _iI$221800[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+112]
	mov	DWORD PTR _pZone$221799[ebp], eax

; 1079 : 
; 1080 : 			szLogMsg.Format("Zone ID: %d, Area ID: %d, Value: %d, FRIENDLY Str: %d (%d), Ranged: %d (%d), ENEMY Str: %d (%d), Ranged: %d (%d), Closest Enemy: %d",
; 1081 : 			                pZone->GetDominanceZoneID(), pZone->GetAreaID(), pZone->GetDominanceZoneValue(),
; 1082 : 			                pZone->GetFriendlyStrength(), pZone->GetFriendlyUnitCount(), pZone->GetFriendlyRangedStrength(), pZone->GetFriendlyRangedUnitCount(),
; 1083 : 			                pZone->GetEnemyStrength(), pZone->GetEnemyUnitCount(), pZone->GetEnemyRangedStrength(), pZone->GetEnemyRangedUnitCount(), pZone->GetRangeClosestEnemyUnit());

	mov	edx, DWORD PTR _pZone$221799[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR $T226951[ebp], eax
	mov	ecx, DWORD PTR _pZone$221799[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR $T226955[ebp], edx
	mov	eax, DWORD PTR _pZone$221799[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T226959[ebp], ecx
	mov	edx, DWORD PTR _pZone$221799[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T226963[ebp], eax
	mov	ecx, DWORD PTR _pZone$221799[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T226967[ebp], edx
	mov	eax, DWORD PTR _pZone$221799[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T226971[ebp], ecx
	mov	edx, DWORD PTR _pZone$221799[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T226975[ebp], eax
	mov	ecx, DWORD PTR _pZone$221799[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR $T226979[ebp], edx
	mov	eax, DWORD PTR _pZone$221799[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR $T226983[ebp], ecx
	mov	edx, DWORD PTR _pZone$221799[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR $T226987[ebp], eax
	mov	ecx, DWORD PTR _pZone$221799[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T226991[ebp], edx
	mov	ecx, DWORD PTR _pZone$221799[ebp]
	call	?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit
	push	eax
	mov	eax, DWORD PTR $T226951[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226955[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226959[ebp]
	push	edx
	mov	eax, DWORD PTR $T226963[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226967[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226971[ebp]
	push	edx
	mov	eax, DWORD PTR $T226975[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226979[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226983[ebp]
	push	edx
	mov	eax, DWORD PTR $T226987[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226991[ebp]
	push	ecx
	push	OFFSET ??_C@_0IE@KBCDNJJP@Zone?5ID?3?5?$CFd?0?5Area?5ID?3?5?$CFd?0?5Value?3@
	lea	edx, DWORD PTR _szLogMsg$221798[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 56					; 00000038H

; 1084 : 			if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY)

	mov	eax, DWORD PTR _pZone$221799[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T226995[ebp], ecx
	cmp	DWORD PTR $T226995[ebp], 1
	jne	SHORT $LN13@LogZones

; 1085 : 			{
; 1086 : 				szLogMsg += ", Friendly";

	push	OFFSET ??_C@_0L@HPDPHCOP@?0?5Friendly?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN12@LogZones
$LN13@LogZones:

; 1087 : 			}
; 1088 : 			else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_ENEMY)

	mov	edx, DWORD PTR _pZone$221799[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T226999[ebp], eax
	cmp	DWORD PTR $T226999[ebp], 2
	jne	SHORT $LN11@LogZones

; 1089 : 			{
; 1090 : 				szLogMsg += ", Enemy";

	push	OFFSET ??_C@_07DACEKBBN@?0?5Enemy?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN12@LogZones
$LN11@LogZones:

; 1091 : 			}
; 1092 : 			else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_EVEN)

	mov	ecx, DWORD PTR _pZone$221799[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227003[ebp], edx
	cmp	DWORD PTR $T227003[ebp], 3
	jne	SHORT $LN9@LogZones

; 1093 : 			{
; 1094 : 				szLogMsg += ", Even";

	push	OFFSET ??_C@_06GAHBBME@?0?5Even?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN12@LogZones
$LN9@LogZones:

; 1095 : 			}
; 1096 : 			else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_NO_UNITS_VISIBLE)

	mov	eax, DWORD PTR _pZone$221799[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T227007[ebp], ecx
	cmp	DWORD PTR $T227007[ebp], 0
	jne	SHORT $LN12@LogZones

; 1097 : 			{
; 1098 : 				szLogMsg += ", No Units Visible";

	push	OFFSET ??_C@_0BD@PCFJBCFG@?0?5No?5Units?5Visible?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN12@LogZones:

; 1099 : 			}
; 1100 : 
; 1101 : 			if(pZone->IsWater())

	mov	edx, DWORD PTR _pZone$221799[ebp]
	mov	al, BYTE PTR [edx+68]
	mov	BYTE PTR $T227011[ebp], al
	movzx	ecx, BYTE PTR $T227011[ebp]
	test	ecx, ecx
	je	SHORT $LN6@LogZones

; 1102 : 			{
; 1103 : 				szLogMsg += ", Water";

	push	OFFSET ??_C@_07PJCICNNF@?0?5Water?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1104 : 			}
; 1105 : 			else

	jmp	SHORT $LN5@LogZones
$LN6@LogZones:

; 1106 : 			{
; 1107 : 				szLogMsg += ", Land";

	push	OFFSET ??_C@_06DAGDBLPI@?0?5Land?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN5@LogZones:

; 1108 : 			}
; 1109 : 
; 1110 : 			if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE)

	mov	edx, DWORD PTR _pZone$221799[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227015[ebp], eax
	cmp	DWORD PTR $T227015[ebp], 5
	jne	SHORT $LN4@LogZones

; 1111 : 			{
; 1112 : 				szLogMsg += ", Temporary Zone";

	push	OFFSET ??_C@_0BB@FKBOJJDN@?0?5Temporary?5Zone?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	$LN3@LogZones
$LN4@LogZones:

; 1113 : 			}
; 1114 : 			else if(pZone->GetClosestCity())

	mov	ecx, DWORD PTR _pZone$221799[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	test	eax, eax
	je	$LN3@LogZones

; 1115 : 			{
; 1116 : 				szLogMsg += ", " + pZone->GetClosestCity()->getName();

	lea	ecx, DWORD PTR $T226932[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pZone$221799[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv281[ebp], eax
	mov	edx, DWORD PTR tv281[ebp]
	mov	DWORD PTR tv273[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv273[ebp]
	push	eax
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR $T226933[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv74[ebp], eax
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv275[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv275[ebp]
	push	eax
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T226933[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T226932[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1117 : 				if (m_pPlayer->GetTacticalAI()->IsTemporaryZoneCity(pZone->GetClosestCity()))

	mov	ecx, DWORD PTR _pZone$221799[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ; CvTacticalAI::IsTemporaryZoneCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@LogZones

; 1118 : 				{
; 1119 : 					szLogMsg += " (Temp)";

	push	OFFSET ??_C@_07IAMPFPIC@?5?$CITemp?$CJ?$AA@
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN3@LogZones:

; 1120 : 				}
; 1121 : 			}
; 1122 : 
; 1123 : 			m_pPlayer->GetTacticalAI()->LogTacticalMessage(szLogMsg, true /*bSkipLogDominanceZone*/);

	push	1
	lea	eax, DWORD PTR _szLogMsg$221798[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage

; 1124 : 		}

	jmp	$LN15@LogZones
$LN14@LogZones:

; 1125 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@LogZones:

; 1126 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$0:
	lea	ecx, DWORD PTR _szLogMsg$221798[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$1:
	lea	ecx, DWORD PTR $T226932[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$2:
	lea	ecx, DWORD PTR $T226933[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogZones@CvTacticalAnalysisMap@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-192]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogZones@CvTacticalAnalysisMap@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogZones@CvTacticalAnalysisMap@@IAEXXZ ENDP		; CvTacticalAnalysisMap::LogZones
; Function compile flags: /Odtp
;	COMDAT ?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -144						; size = 4
$T227159 = -140						; size = 4
$T227155 = -136						; size = 4
$T227151 = -132						; size = 4
$T227147 = -128						; size = 4
$T227143 = -124						; size = 4
$T227139 = -120						; size = 4
$T227135 = -116						; size = 4
$T227131 = -112						; size = 4
$T227127 = -108						; size = 4
$T227123 = -104						; size = 4
$T227119 = -100						; size = 4
$T227115 = -96						; size = 4
$T227074 = -48						; size = 4
$T227070 = -44						; size = 4
$T227066 = -40						; size = 4
$T227062 = -36						; size = 4
$T227058 = -32						; size = 4
$T227054 = -28						; size = 4
$T227050 = -24						; size = 4
$T227046 = -20						; size = 4
$T227042 = -16						; size = 4
$T227035 = -12						; size = 4
_iI$221834 = -8						; size = 4
_pZone$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::FindExistingZone, COMDAT
; _this$ = ecx

; 1130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1131 : 	CvTacticalDominanceZone* pZone;
; 1132 : 
; 1133 : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	DWORD PTR _iI$221834[ebp], 0
	jmp	SHORT $LN10@FindExisti
$LN9@FindExisti:
	mov	eax, DWORD PTR _iI$221834[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221834[ebp], eax
$LN10@FindExisti:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR $T227035[ebp], edx
	mov	eax, DWORD PTR _iI$221834[ebp]
	cmp	eax, DWORD PTR $T227035[ebp]
	jae	$LN8@FindExisti

; 1134 : 	{
; 1135 : 		pZone = &m_DominanceZones[iI];

	mov	ecx, DWORD PTR _iI$221834[ebp]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+112]
	mov	DWORD PTR _pZone$[ebp], ecx

; 1136 : 
; 1137 : 		// If this is a temporary zone, matches if unowned and close enough
; 1138 : 		if((pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE) &&
; 1139 : 		        (m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER || m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL) &&
; 1140 : 		        (plotDistance(pPlot->getX(), pPlot->getY(), pZone->GetTempZoneCenter()->getX(), pZone->GetTempZoneCenter()->getY()) <= m_iTacticalRange))

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227042[ebp], ecx
	cmp	DWORD PTR $T227042[ebp], 5
	jne	$LN7@FindExisti
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T227046[ebp], eax
	cmp	DWORD PTR $T227046[ebp], 1
	je	SHORT $LN6@FindExisti
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T227050[ebp], edx
	cmp	DWORD PTR $T227050[ebp], 4
	jne	SHORT $LN7@FindExisti
$LN6@FindExisti:
	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR $T227054[ebp], ecx
	mov	edx, DWORD PTR $T227054[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T227058[ebp], eax
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR $T227062[ebp], edx
	mov	eax, DWORD PTR $T227062[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T227066[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T227070[ebp], eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T227074[ebp], edx
	mov	eax, DWORD PTR $T227058[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227066[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227070[ebp]
	push	edx
	mov	eax, DWORD PTR $T227074[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+8]
	jg	SHORT $LN7@FindExisti

; 1141 : 		{
; 1142 : 			return pZone;

	mov	eax, DWORD PTR _pZone$[ebp]
	jmp	$LN11@FindExisti
$LN7@FindExisti:

; 1143 : 		}
; 1144 : 
; 1145 : 		// If not friendly or enemy, just 1 zone per area
; 1146 : 		if((pZone->GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER || pZone->GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL) &&
; 1147 : 		        (m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER || m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL))

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227115[ebp], eax
	cmp	DWORD PTR $T227115[ebp], 1
	je	SHORT $LN4@FindExisti
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T227119[ebp], edx
	cmp	DWORD PTR $T227119[ebp], 4
	jne	SHORT $LN5@FindExisti
$LN4@FindExisti:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T227123[ebp], ecx
	cmp	DWORD PTR $T227123[ebp], 1
	je	SHORT $LN3@FindExisti
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T227127[ebp], eax
	cmp	DWORD PTR $T227127[ebp], 4
	jne	SHORT $LN5@FindExisti
$LN3@FindExisti:

; 1148 : 		{
; 1149 : 			if(pZone->GetAreaID() == m_TempZone.GetAreaID())

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T227131[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR $T227135[ebp], ecx
	mov	edx, DWORD PTR $T227131[ebp]
	cmp	edx, DWORD PTR $T227135[ebp]
	jne	SHORT $LN5@FindExisti

; 1150 : 			{
; 1151 : 				return pZone;

	mov	eax, DWORD PTR _pZone$[ebp]
	jmp	$LN11@FindExisti
$LN5@FindExisti:

; 1152 : 			}
; 1153 : 		}
; 1154 : 
; 1155 : 		// Otherwise everything needs to match
; 1156 : 		if(pZone->GetTerritoryType() == m_TempZone.GetTerritoryType() &&
; 1157 : 		        pZone->GetOwner() == m_TempZone.GetOwner() &&
; 1158 : 		        pZone->GetAreaID() == m_TempZone.GetAreaID() &&
; 1159 : 		        pZone->GetClosestCity() == m_TempZone.GetClosestCity())

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227139[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T227143[ebp], eax
	mov	ecx, DWORD PTR $T227139[ebp]
	cmp	ecx, DWORD PTR $T227143[ebp]
	jne	SHORT $LN1@FindExisti
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T227147[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T227151[ebp], edx
	mov	eax, DWORD PTR $T227147[ebp]
	cmp	eax, DWORD PTR $T227151[ebp]
	jne	SHORT $LN1@FindExisti
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T227155[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR $T227159[ebp], ecx
	mov	edx, DWORD PTR $T227155[ebp]
	cmp	edx, DWORD PTR $T227159[ebp]
	jne	SHORT $LN1@FindExisti
	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	cmp	esi, eax
	jne	SHORT $LN1@FindExisti

; 1160 : 		{
; 1161 : 			return pZone;

	mov	eax, DWORD PTR _pZone$[ebp]
	jmp	SHORT $LN11@FindExisti
$LN1@FindExisti:

; 1162 : 		}
; 1163 : 	}

	jmp	$LN9@FindExisti
$LN8@FindExisti:

; 1164 : 
; 1165 : 	return NULL;

	xor	eax, eax
$LN11@FindExisti:

; 1166 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::FindExistingZone
_TEXT	ENDS
PUBLIC	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
; Function compile flags: /Odtp
;	COMDAT ?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T227165 = -4						; size = 4
_iIndex$ = 8						; size = 4
?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z PROC ; CvTacticalAnalysisMap::GetZone, COMDAT
; _this$ = ecx

; 1170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1171 : 	if(iIndex < 0 || iIndex >= (int)m_DominanceZones.size())

	cmp	DWORD PTR _iIndex$[ebp], 0
	jl	SHORT $LN1@GetZone
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR $T227165[ebp], ecx
	mov	edx, DWORD PTR _iIndex$[ebp]
	cmp	edx, DWORD PTR $T227165[ebp]
	jl	SHORT $LN7@GetZone
$LN1@GetZone:

; 1172 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@GetZone

; 1173 : 	return &m_DominanceZones[iIndex];

$LN7@GetZone:
	mov	eax, DWORD PTR _iIndex$[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+112]
$LN3@GetZone:

; 1174 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ENDP ; CvTacticalAnalysisMap::GetZone
_TEXT	ENDS
PUBLIC	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ; CvTacticalAnalysisMap::GetZoneByCity
; Function compile flags: /Odtp
;	COMDAT ?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T227183 = -13						; size = 1
$T227175 = -12						; size = 4
_iI$221858 = -8						; size = 4
_pZone$ = -4						; size = 4
_pCity$ = 8						; size = 4
_bWater$ = 12						; size = 1
?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z PROC ; CvTacticalAnalysisMap::GetZoneByCity, COMDAT
; _this$ = ecx

; 1178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1179 : 	CvTacticalDominanceZone* pZone;
; 1180 : 	for(int iI = 0; iI < GetNumZones(); iI++)

	mov	DWORD PTR _iI$221858[ebp], 0
	jmp	SHORT $LN4@GetZoneByC
$LN3@GetZoneByC:
	mov	eax, DWORD PTR _iI$221858[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$221858[ebp], eax
$LN4@GetZoneByC:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR $T227175[ebp], edx
	mov	eax, DWORD PTR _iI$221858[ebp]
	cmp	eax, DWORD PTR $T227175[ebp]
	jge	SHORT $LN2@GetZoneByC

; 1181 : 	{
; 1182 : 		pZone = GetZone(iI);

	mov	ecx, DWORD PTR _iI$221858[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	DWORD PTR _pZone$[ebp], eax

; 1183 : 		if(pZone->GetClosestCity() == pCity && pZone->IsWater() == bWater)

	mov	ecx, DWORD PTR _pZone$[ebp]
	call	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
	cmp	eax, DWORD PTR _pCity$[ebp]
	jne	SHORT $LN1@GetZoneByC
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	al, BYTE PTR [edx+68]
	mov	BYTE PTR $T227183[ebp], al
	movzx	ecx, BYTE PTR $T227183[ebp]
	movzx	edx, BYTE PTR _bWater$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN1@GetZoneByC

; 1184 : 		{
; 1185 : 			return pZone;

	mov	eax, DWORD PTR _pZone$[ebp]
	jmp	SHORT $LN5@GetZoneByC
$LN1@GetZoneByC:

; 1186 : 		}
; 1187 : 	}

	jmp	SHORT $LN3@GetZoneByC
$LN2@GetZoneByC:

; 1188 : 
; 1189 : 	return NULL;

	xor	eax, eax
$LN5@GetZoneByC:

; 1190 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ENDP ; CvTacticalAnalysisMap::GetZoneByCity
_TEXT	ENDS
PUBLIC	?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z ; CvTacticalAnalysisMap::IsInEnemyDominatedZone
; Function compile flags: /Odtp
;	COMDAT ?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T227230 = -48						; size = 4
$T227226 = -44						; size = 4
$T227222 = -40						; size = 4
$T227214 = -36						; size = 4
$T227202 = -32						; size = 4
$T227197 = -28						; size = 4
$T227193 = -24						; size = 4
$T227189 = -20						; size = 4
_iI$221870 = -16					; size = 4
_iPlotIndex$ = -12					; size = 4
_pZone$ = -8						; size = 4
_pCell$ = -4						; size = 4
_pPlot$ = 8						; size = 4
?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::IsInEnemyDominatedZone, COMDAT
; _this$ = ecx

; 1194 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1195 : 	CvTacticalAnalysisCell* pCell;
; 1196 : 	int iPlotIndex;
; 1197 : 	CvTacticalDominanceZone* pZone;
; 1198 : 
; 1199 : 	iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T227189[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T227193[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T227197[ebp], ecx
	mov	edx, DWORD PTR $T227197[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T227202[ebp], eax
	mov	ecx, DWORD PTR $T227189[ebp]
	imul	ecx, DWORD PTR $T227202[ebp]
	add	ecx, DWORD PTR $T227193[ebp]
	mov	DWORD PTR _iPlotIndex$[ebp], ecx

; 1200 : 	pCell = GetCell(iPlotIndex);

	mov	edx, DWORD PTR _iPlotIndex$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _pCell$[ebp], edx

; 1201 : 
; 1202 : 	for(int iI = 0; iI < GetNumZones(); iI++)

	mov	DWORD PTR _iI$221870[ebp], 0
	jmp	SHORT $LN4@IsInEnemyD
$LN3@IsInEnemyD:
	mov	ecx, DWORD PTR _iI$221870[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$221870[ebp], ecx
$LN4@IsInEnemyD:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR $T227214[ebp], eax
	mov	ecx, DWORD PTR _iI$221870[ebp]
	cmp	ecx, DWORD PTR $T227214[ebp]
	jge	SHORT $LN2@IsInEnemyD

; 1203 : 	{
; 1204 : 		pZone = GetZone(iI);

	mov	edx, DWORD PTR _iI$221870[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
	mov	DWORD PTR _pZone$[ebp], eax

; 1205 : 		if(pZone->GetDominanceZoneID() == pCell->GetDominanceZone())

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T227222[ebp], ecx
	mov	edx, DWORD PTR _pCell$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T227226[ebp], eax
	mov	ecx, DWORD PTR $T227222[ebp]
	cmp	ecx, DWORD PTR $T227226[ebp]
	jne	SHORT $LN1@IsInEnemyD

; 1206 : 		{
; 1207 : 			return (pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_ENEMY);

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T227230[ebp], eax
	xor	eax, eax
	cmp	DWORD PTR $T227230[ebp], 2
	sete	al
	jmp	SHORT $LN5@IsInEnemyD
$LN1@IsInEnemyD:

; 1208 : 		}
; 1209 : 	}

	jmp	SHORT $LN3@IsInEnemyD
$LN2@IsInEnemyD:

; 1210 : 
; 1211 : 	return false;

	xor	al, al
$LN5@IsInEnemyD:

; 1212 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::IsInEnemyDominatedZone
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T227271 = -28						; size = 4
$T227258 = -24						; size = 4
$T227254 = -20						; size = 4
$T227247 = -16						; size = 4
$T227240 = -12						; size = 4
$T227236 = -8						; size = 4
_iRatio$221883 = -4					; size = 4
_pZone$ = 8						; size = 4
?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z PROC ; CvTacticalAnalysisMap::ComputeDominance, COMDAT
; _this$ = ecx

; 1216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1217 : 	// Look at ratio of friendly to enemy strength
; 1218 : 	if(pZone->GetTerritoryType() != TACTICAL_TERRITORY_ENEMY && pZone->GetEnemyUnitCount() <= 0)

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227236[ebp], ecx
	cmp	DWORD PTR $T227236[ebp], 3
	je	SHORT $LN8@ComputeDom
	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T227240[ebp], eax
	cmp	DWORD PTR $T227240[ebp], 0
	jg	SHORT $LN8@ComputeDom

; 1219 : 	{
; 1220 : 		pZone->SetDominanceFlag(TACTICAL_DOMINANCE_NO_UNITS_VISIBLE);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1221 : 	}
; 1222 : 
; 1223 : 	else

	jmp	SHORT $LN7@ComputeDom
$LN8@ComputeDom:

; 1224 : 	{
; 1225 : 		// Otherwise compute it by strength
; 1226 : 		if(pZone->GetEnemyStrength() <= 0)

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T227247[ebp], eax
	cmp	DWORD PTR $T227247[ebp], 0
	jg	SHORT $LN6@ComputeDom

; 1227 : 		{
; 1228 : 			pZone->SetDominanceFlag(TACTICAL_DOMINANCE_FRIENDLY);

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 1229 : 		}
; 1230 : 		else

	jmp	SHORT $LN7@ComputeDom
$LN6@ComputeDom:

; 1231 : 		{
; 1232 : 			int iRatio = (pZone->GetFriendlyStrength()  * 100) / pZone->GetEnemyStrength();

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR $T227254[ebp], eax
	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR $T227258[ebp], edx
	mov	eax, DWORD PTR $T227254[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR $T227258[ebp]
	mov	DWORD PTR _iRatio$221883[ebp], eax

; 1233 : 			if(iRatio > 100 + m_iDominancePercentage)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 100				; 00000064H
	cmp	DWORD PTR _iRatio$221883[ebp], ecx
	jle	SHORT $LN4@ComputeDom

; 1234 : 			{
; 1235 : 				pZone->SetDominanceFlag(TACTICAL_DOMINANCE_FRIENDLY);

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+8], 1

; 1236 : 			}
; 1237 : 			else if(iRatio < 100 - m_iDominancePercentage)

	jmp	SHORT $LN7@ComputeDom
$LN4@ComputeDom:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, 100				; 00000064H
	sub	ecx, DWORD PTR [eax]
	cmp	DWORD PTR _iRatio$221883[ebp], ecx
	jge	SHORT $LN2@ComputeDom

; 1238 : 			{
; 1239 : 				pZone->SetDominanceFlag(TACTICAL_DOMINANCE_ENEMY);

	mov	edx, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [edx+8], 2

; 1240 : 			}
; 1241 : 			else

	jmp	SHORT $LN7@ComputeDom
$LN2@ComputeDom:

; 1242 : 			{
; 1243 : 				pZone->SetDominanceFlag(TACTICAL_DOMINANCE_EVEN);

	mov	eax, DWORD PTR _pZone$[ebp]
	mov	DWORD PTR [eax+8], 3
$LN7@ComputeDom:

; 1244 : 			}
; 1245 : 		}
; 1246 : 	}
; 1247 : 
; 1248 : 	return pZone->GetDominanceFlag();

	mov	ecx, DWORD PTR _pZone$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227271[ebp], edx
	mov	eax, DWORD PTR $T227271[ebp]

; 1249 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z ENDP ; CvTacticalAnalysisMap::ComputeDominance
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T227284 = -20						; size = 4
_pRet$227280 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::FStaticVector<CvTacticalDominanceZone,110,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 110			; 0000006eH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227284[ebp], edx
	cmp	DWORD PTR $T227284[ebp], 110		; 0000006eH
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T227284[ebp]
	imul	eax, 76					; 0000004cH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227280[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T227284[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$227280[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 110			; 0000006eH
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$227280[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>
__ehhandler$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::FStaticVector<CvTacticalDominanceZone,110,1,297,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T227315 = -24						; size = 4
$T227314 = -20						; size = 4
_i$227309 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227315[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227314[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$227309[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$227309[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227309[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$227309[ebp]
	cmp	ecx, DWORD PTR $T227315[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T227314[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T227314[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>
__ehhandler$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T227327 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8372], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T227327[ebp], ecx
	je	SHORT $LN4@push_back
	mov	esi, DWORD PTR _element$[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T227327[ebp]
	rep movsd
	mov	eax, DWORD PTR $T227327[ebp]
	mov	DWORD PTR tv132[ebp], eax
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv141[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ		; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T227381 = -20						; size = 4
_pRet$227378 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvUnit *,250,1,297,0>::FStaticVector<CvUnit *,250,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 250			; 000000faH

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T227381[ebp], edx
	cmp	DWORD PTR $T227381[ebp], 250		; 000000faH
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T227381[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227378[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T227381[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$227378[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 250			; 000000faH
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$227378[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ	; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>
__ehhandler$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvUnit *,250,1,297,0>::FStaticVector<CvUnit *,250,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T227412 = -24						; size = 4
$T227411 = -20						; size = 4
_i$227404 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvUnit *,250,1,297,0>::~FStaticVector<CvUnit *,250,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227412[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227411[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$227404[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$227404[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227404[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$227404[ebp]
	cmp	ecx, DWORD PTR $T227412[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T227411[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T227411[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ	; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>
__ehhandler$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvUnit *,250,1,297,0>::~FStaticVector<CvUnit *,250,1,297,0>
PUBLIC	?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z
_TEXT	SEGMENT
tv140 = -52						; size = 4
tv131 = -48						; size = 4
_this$ = -44						; size = 4
$T227424 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z PROC ; FStaticVector<CvUnit *,250,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+1012], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T227424[ebp], ecx
	cmp	DWORD PTR $T227424[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR $T227424[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T227424[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z ENDP ; FStaticVector<CvUnit *,250,1,297,0>::push_back
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T227502 = -36						; size = 4
$T227501 = -32						; size = 4
_i$227494 = -28						; size = 4
$T227477 = -24						; size = 4
_pRet$227474 = -20					; size = 4
$T227468 = -16						; size = 4
_i$221950 = -12						; size = 4
_uiNewSize$221942 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$221942[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$221942[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$221942[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T227477[ebp], ecx
	cmp	DWORD PTR $T227477[ebp], 110		; 0000006eH
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T227477[ebp]
	imul	edx, 76					; 0000004cH
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227474[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T227477[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize
$LN15@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$227474[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 110			; 0000006eH
$LN16@GrowSize:
	mov	ecx, DWORD PTR _pRet$227474[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 76					; 0000004cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$221950[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$221950[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221950[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$221950[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$221950[ebp]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T227468[ebp], edx
	je	SHORT $LN12@GrowSize
	mov	eax, DWORD PTR _i$221950[ebp]
	imul	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx]
	add	esi, eax
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T227468[ebp]
	rep movsd
	mov	edx, DWORD PTR $T227468[ebp]
	mov	DWORD PTR tv179[ebp], edx
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize:
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227502[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227501[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize
	xor	edx, edx
	je	SHORT $LN21@GrowSize
	mov	DWORD PTR _i$227494[ebp], 0
	jmp	SHORT $LN26@GrowSize
$LN25@GrowSize:
	mov	eax, DWORD PTR _i$227494[ebp]
	add	eax, 1
	mov	DWORD PTR _i$227494[ebp], eax
$LN26@GrowSize:
	mov	ecx, DWORD PTR _i$227494[ebp]
	cmp	ecx, DWORD PTR $T227502[ebp]
	jae	SHORT $LN21@GrowSize
	jmp	SHORT $LN25@GrowSize
$LN21@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T227501[ebp], edx
	je	SHORT $LN22@GrowSize
	mov	eax, DWORD PTR $T227501[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8372], 1

; 772  : 	};

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ PROC ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv178 = -44						; size = 4
_this$ = -40						; size = 4
$T227542 = -36						; size = 4
$T227541 = -32						; size = 4
_i$227534 = -28						; size = 4
$T227517 = -24						; size = 4
_pRet$227514 = -20					; size = 4
$T227508 = -16						; size = 4
_i$221997 = -12						; size = 4
_uiNewSize$221989 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@2

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$221989[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$221989[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@2

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@2
$LN6@GrowSize@2:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$221989[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@2
$LN7@GrowSize@2:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T227517[ebp], ecx
	cmp	DWORD PTR $T227517[ebp], 250		; 000000faH
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T227517[ebp]
	shl	edx, 2
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227514[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T227517[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@2
$LN15@GrowSize@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$227514[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 250			; 000000faH
$LN16@GrowSize@2:
	mov	ecx, DWORD PTR _pRet$227514[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@2

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@2
$LN5@GrowSize@2:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$221997[ebp], 0
	jmp	SHORT $LN3@GrowSize@2
$LN2@GrowSize@2:
	mov	edx, DWORD PTR _i$221997[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221997[ebp], edx
$LN3@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$221997[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@2

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$221997[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T227508[ebp], ecx
	cmp	DWORD PTR $T227508[ebp], 0
	je	SHORT $LN12@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T227508[ebp]
	mov	edx, DWORD PTR _i$221997[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T227508[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	jmp	SHORT $LN13@GrowSize@2
$LN12@GrowSize@2:
	mov	DWORD PTR tv178[ebp], 0
$LN13@GrowSize@2:
	jmp	SHORT $LN2@GrowSize@2
$LN4@GrowSize@2:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227542[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T227541[ebp], edx
	xor	eax, eax
	je	SHORT $LN21@GrowSize@2
	xor	ecx, ecx
	je	SHORT $LN21@GrowSize@2
	mov	DWORD PTR _i$227534[ebp], 0
	jmp	SHORT $LN26@GrowSize@2
$LN25@GrowSize@2:
	mov	edx, DWORD PTR _i$227534[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227534[ebp], edx
$LN26@GrowSize@2:
	mov	eax, DWORD PTR _i$227534[ebp]
	cmp	eax, DWORD PTR $T227542[ebp]
	jae	SHORT $LN21@GrowSize@2
	jmp	SHORT $LN25@GrowSize@2
$LN21@GrowSize@2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T227541[ebp], ecx
	je	SHORT $LN22@GrowSize@2
	mov	edx, DWORD PTR $T227541[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+1012], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ PROC		; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ ENDP		; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
PUBLIC	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
_TEXT	SEGMENT
$T227652 = -112						; size = 4
__Next$227660 = -108					; size = 4
$T227569 = -48						; size = 4
$T227565 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z PROC ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3411 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3412 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227565[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T227565[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T227569[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T227569[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H

; 3415 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$227660[ebp], edx
	jmp	SHORT $LN62@Stable_sor
$LN61@Stable_sor:
	mov	eax, DWORD PTR __Next$227660[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next$227660[ebp], eax
$LN62@Stable_sor:
	mov	ecx, DWORD PTR __Next$227660[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor
	jmp	SHORT $LN61@Stable_sor
$LN60@Stable_sor:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T227652[ebp], edx
	mov	eax, DWORD PTR $T227652[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z ENDP ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T227678 = -8						; size = 4
__Next$222146 = -4					; size = 4
??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$222146[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$222146[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next$222146[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$222146[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T227678[ebp], ecx
	mov	edx, DWORD PTR $T227678[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
PUBLIC	??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
PUBLIC	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
__Count2$222205 = -8					; size = 4
__Mid$222206 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 396				; 0000018cH

; 3382 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
	add	esp, 12					; 0000000cH

; 3384 : 	else

	jmp	$LN5@Stable_sor@2
$LN4@Stable_sor@2:

; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$222205[ebp], eax

; 3387 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$222206[ebp], edx

; 3388 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$222205[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __Mid$222206[ebp]
	mov	DWORD PTR __Mid$222206[ebp], eax

; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	DWORD PTR __Count2$222205[ebp], eax
	jg	SHORT $LN2@Stable_sor@2

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$222205[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$222206[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$222205[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$222206[ebp]
	push	edx
	call	??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN1@Stable_sor@2
$LN2@Stable_sor@2:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$222205[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$222206[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$222205[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$222206[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H
$LN1@Stable_sor@2:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$222205[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$222205[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$222206[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 24					; 00000018H
$LN5@Stable_sor@2:

; 3403 : 		}
; 3404 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalDominanceZone>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$222271 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$222271[ebp]
	push	ecx
	call	??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalDominanceZone>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$222271[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$222271[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$222271[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$222271[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
tv139 = -352						; size = 4
$T228273 = -237						; size = 1
$T228110 = -236						; size = 4
$T228106 = -232						; size = 4
$T228069 = -208						; size = 4
$T228042 = -116						; size = 4
$T228008 = -20						; size = 4
__Chunk$222339 = -16					; size = 4
__Midend$222337 = -12					; size = 4
__Nleft$222333 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 3355 : 	{	// sort using temp buffer for merges, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$222333[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$222333[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$222333[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$222333[ebp], 32	; 00000020H
	jl	SHORT $LN36@Buffered_m

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midend$222337[ebp], eax

; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR __Midend$222337[ebp]
	mov	DWORD PTR __Midend$222337[ebp], ecx

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	mov	edx, DWORD PTR __Midend$222337[ebp]
	mov	DWORD PTR $T228042[ebp], edx
	push	0
	mov	eax, DWORD PTR $T228042[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
	add	esp, 12					; 0000000cH

; 3363 : 		_Mid = _Midend;

	mov	edx, DWORD PTR __Midend$222337[ebp]
	mov	DWORD PTR __Mid$[ebp], edx

; 3364 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

$LN36@Buffered_m:
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
	add	esp, 12					; 0000000cH

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$222339[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	edx, DWORD PTR __Chunk$222339[ebp]
	shl	edx, 1
	mov	DWORD PTR __Chunk$222339[ebp], edx
$LN3@Buffered_m:
	mov	eax, DWORD PTR __Chunk$222339[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$222339[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T228008[ebp], esp
	mov	DWORD PTR $T228069[ebp], edx
	mov	eax, DWORD PTR $T228069[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T228069[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T228069[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T228069[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T228069[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T228069[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
	add	esp, 36					; 00000024H

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	ecx, DWORD PTR __Chunk$222339[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$222339[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T228106[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T228110[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T228273[ebp], dl
	movzx	eax, BYTE PTR $T228273[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$222339[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228106[ebp]
	push	ecx
	mov	edx, DWORD PTR $T228110[ebp]
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
	add	esp, 24					; 00000018H

; 3373 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3374 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
PUBLIC	??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
PUBLIC	??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
PUBLIC	??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
PUBLIC	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
tv221 = -364						; size = 4
tv220 = -360						; size = 4
tv217 = -356						; size = 4
tv216 = -352						; size = 4
$T228529 = -280						; size = 4
$T228511 = -272						; size = 4
$T228510 = -268						; size = 4
$T228445 = -236						; size = 4
$T228427 = -228						; size = 4
$T228426 = -224						; size = 4
$T228399 = -217						; size = 1
$T228395 = -216						; size = 4
$T228391 = -212						; size = 4
$T228376 = -208						; size = 4
__Next$228384 = -204					; size = 4
$T228368 = -200						; size = 4
$T228355 = -188						; size = 4
$T228354 = -184						; size = 4
$T228353 = -180						; size = 4
$T228349 = -174						; size = 1
$T228348 = -173						; size = 1
$T228338 = -172						; size = 4
$T228334 = -168						; size = 4
$T228319 = -164						; size = 4
__Next$228322 = -160					; size = 4
$T228311 = -156						; size = 4
__Tmp$228297 = -144					; size = 76
$T228279 = -68						; size = 20
$T228278 = -48						; size = 4
$T228277 = -44						; size = 20
$T228276 = -24						; size = 4
__Firstn$222409 = -20					; size = 4
__Count2n$222412 = -16					; size = 4
__Midn$222429 = -12					; size = 4
__Lastn$222410 = -8					; size = 4
__Count1n$222411 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	push	esi
	push	edi

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+60]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN8@Buffered_m@2

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, 19					; 00000013H
	lea	edi, DWORD PTR __Tmp$228297[ebp]
	rep movsd
	mov	esi, DWORD PTR __Mid$[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd
	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR __Tmp$228297[ebp]
	mov	edi, DWORD PTR __Mid$[ebp]
	rep movsd
$LN8@Buffered_m@2:

; 2764 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Count1$[ebp]
	cmp	ecx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T228276[ebp], esp
	mov	DWORD PTR $T228311[ebp], ecx
	mov	edx, DWORD PTR $T228311[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T228311[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T228311[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T228311[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T228311[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T228311[ebp]
	mov	DWORD PTR tv216[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T228277[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv217[ebp], eax
	cmp	DWORD PTR $T228277[ebp], 0
	je	SHORT $LN36@Buffered_m@2
	mov	ecx, DWORD PTR $T228277[ebp]
	mov	DWORD PTR __Next$228322[ebp], ecx
	jmp	SHORT $LN34@Buffered_m@2
$LN33@Buffered_m@2:
	mov	edx, DWORD PTR __Next$228322[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Next$228322[ebp], edx
$LN34@Buffered_m@2:
	mov	eax, DWORD PTR __Next$228322[ebp]
	cmp	eax, DWORD PTR $T228277[ebp+8]
	je	SHORT $LN32@Buffered_m@2
	jmp	SHORT $LN33@Buffered_m@2
$LN32@Buffered_m@2:
	mov	ecx, DWORD PTR $T228277[ebp]
	mov	DWORD PTR $T228319[ebp], ecx
	mov	edx, DWORD PTR $T228319[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN36@Buffered_m@2:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228334[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T228338[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228355[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T228354[ebp], ecx
	mov	edx, DWORD PTR $T228338[ebp]
	mov	DWORD PTR $T228353[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T228348[ebp], al
	movzx	ecx, BYTE PTR $T228348[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T228349[ebp]
	push	edx
	mov	eax, DWORD PTR $T228355[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T228354[ebp]
	push	edx
	mov	eax, DWORD PTR $T228334[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228353[ebp]
	push	ecx
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T228278[ebp], esp
	mov	DWORD PTR $T228368[ebp], ecx
	mov	edx, DWORD PTR $T228368[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T228368[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T228368[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T228368[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T228368[ebp]
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T228368[ebp]
	mov	DWORD PTR tv220[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	lea	eax, DWORD PTR $T228279[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR $T228279[ebp], 0
	je	SHORT $LN63@Buffered_m@2
	mov	ecx, DWORD PTR $T228279[ebp]
	mov	DWORD PTR __Next$228384[ebp], ecx
	jmp	SHORT $LN61@Buffered_m@2
$LN60@Buffered_m@2:
	mov	edx, DWORD PTR __Next$228384[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Next$228384[ebp], edx
$LN61@Buffered_m@2:
	mov	eax, DWORD PTR __Next$228384[ebp]
	cmp	eax, DWORD PTR $T228279[ebp+8]
	je	SHORT $LN59@Buffered_m@2
	jmp	SHORT $LN60@Buffered_m@2
$LN59@Buffered_m@2:
	mov	ecx, DWORD PTR $T228279[ebp]
	mov	DWORD PTR $T228376[ebp], ecx
	mov	edx, DWORD PTR $T228376[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN63@Buffered_m@2:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T228391[ebp], edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T228395[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T228399[ebp], al
	movzx	ecx, BYTE PTR $T228399[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T228391[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228395[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
	add	esp, 24					; 00000018H

; 2775 : 		}
; 2776 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	ecx, DWORD PTR __Count2$[ebp]
	cmp	ecx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@2

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$222411[ebp], eax
	mov	DWORD PTR __Count2n$222412[ebp], 0

; 2784 : 			_Firstn = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$222409[ebp], edx

; 2785 : 			std::advance(_Firstn, _Count1n);

	mov	eax, DWORD PTR __Count1n$222411[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __Firstn$222409[ebp]
	mov	DWORD PTR __Firstn$222409[ebp], eax

; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	mov	ecx, DWORD PTR __Firstn$222409[ebp]
	mov	DWORD PTR $T228427[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T228426[ebp], edx
	push	0
	mov	eax, DWORD PTR $T228427[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T228426[ebp]
	push	edx
	call	??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T228426[ebp], eax
	mov	eax, DWORD PTR $T228426[ebp]
	mov	DWORD PTR __Lastn$222410[ebp], eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T228445[ebp], ecx
	mov	eax, DWORD PTR __Lastn$222410[ebp]
	sub	eax, DWORD PTR $T228445[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	add	eax, DWORD PTR __Count2n$222412[ebp]
	mov	DWORD PTR __Count2n$222412[ebp], eax

; 2788 : 			}
; 2789 : 		else

	jmp	$LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$222411[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$222412[ebp], eax

; 2792 : 			_Lastn = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$222410[ebp], edx

; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Count2n$222412[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __Lastn$222410[ebp]
	mov	DWORD PTR __Lastn$222410[ebp], eax

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	ecx, DWORD PTR __Lastn$222410[ebp]
	mov	DWORD PTR $T228511[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228510[ebp], edx
	push	0
	mov	eax, DWORD PTR $T228511[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T228510[ebp]
	push	edx
	call	??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T228510[ebp], eax
	mov	eax, DWORD PTR $T228510[ebp]
	mov	DWORD PTR __Firstn$222409[ebp], eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228529[ebp], ecx
	mov	eax, DWORD PTR __Firstn$222409[ebp]
	sub	eax, DWORD PTR $T228529[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	add	eax, DWORD PTR __Count1n$222411[ebp]
	mov	DWORD PTR __Count1n$222411[ebp], eax
$LN1@Buffered_m@2:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$222412[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$222411[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$222410[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$222409[ebp]
	push	ecx
	call	??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$222429[ebp], eax

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$222412[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1n$222411[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$222429[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$222409[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 24					; 00000018H

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$[ebp]
	sub	eax, DWORD PTR __Count2n$222412[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$222411[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$222410[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$222429[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 24					; 00000018H
$LN10@Buffered_m@2:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
CONST	ENDS
;	COMDAT ??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z
_TEXT	SEGMENT
$T228584 = -20						; size = 4
$T228580 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z PROC ; std::get_temporary_buffer<CvTacticalDominanceZone>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 76					; 0000004cH
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T228584[ebp], 0
	lea	eax, DWORD PTR $T228584[ebp]
	push	eax
	lea	ecx, DWORD PTR $T228580[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T228580[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T228580[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 76					; 0000004cH
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvTacticalDominanceZone>
_TEXT	ENDS
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z
_TEXT	SEGMENT
$T228638 = -124						; size = 4
$T228637 = -120						; size = 4
$T228621 = -114						; size = 1
$T228620 = -113						; size = 1
$T228619 = -112						; size = 4
$T228618 = -108						; size = 4
$T228617 = -104						; size = 4
__Cat$228628 = -96					; size = 1
$T228625 = -95						; size = 1
$T228624 = -94						; size = 1
$T228623 = -93						; size = 1
__First1$222491 = -92					; size = 4
__Val$222481 = -88					; size = 76
__Next1$222480 = -8					; size = 4
__Next$222476 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z PROC ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	esi
	push	edi

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$222476[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$222476[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Next$222476[ebp], edx
	mov	eax, DWORD PTR __Next$222476[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$222476[ebp]
	mov	DWORD PTR __Next1$222480[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR __Next$222476[ebp]
	mov	ecx, 19					; 00000013H
	lea	edi, DWORD PTR __Val$222481[ebp]
	rep movsd

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$222481[ebp+60]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+60]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, DWORD PTR __Next1$222480[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next1$222480[ebp], eax
	mov	ecx, DWORD PTR __Next1$222480[ebp]
	mov	DWORD PTR $T228638[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228637[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T228623[ebp], al
	mov	cl, BYTE PTR __Cat$228628[ebp]
	mov	BYTE PTR $T228624[ebp], cl
	mov	dl, BYTE PTR $T228623[ebp]
	mov	BYTE PTR $T228621[ebp], dl
	mov	al, BYTE PTR $T228625[ebp]
	mov	BYTE PTR $T228620[ebp], al
	mov	ecx, DWORD PTR $T228638[ebp]
	mov	DWORD PTR $T228619[ebp], ecx
	mov	edx, DWORD PTR __Next$222476[ebp]
	mov	DWORD PTR $T228618[ebp], edx
	mov	eax, DWORD PTR $T228637[ebp]
	mov	DWORD PTR $T228617[ebp], eax
$LN20@Insertion_:
	mov	ecx, DWORD PTR $T228617[ebp]
	cmp	ecx, DWORD PTR $T228618[ebp]
	je	SHORT $LN13@Insertion_
	mov	edx, DWORD PTR $T228618[ebp]
	sub	edx, 76					; 0000004cH
	mov	DWORD PTR $T228618[ebp], edx
	mov	eax, DWORD PTR $T228619[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR $T228619[ebp], eax
	mov	esi, DWORD PTR $T228618[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T228619[ebp]
	rep movsd
	jmp	SHORT $LN20@Insertion_
$LN13@Insertion_:

; 2977 : 				*_First = _Val;

	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR __Val$222481[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	ecx, DWORD PTR __Next1$222480[ebp]
	mov	DWORD PTR __First1$222491[ebp], ecx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	edx, DWORD PTR __First1$222491[ebp]
	mov	DWORD PTR __Next1$222480[ebp], edx
$LN3@Insertion_:
	mov	eax, DWORD PTR __First1$222491[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR __First1$222491[ebp], eax
	mov	ecx, DWORD PTR __First1$222491[ebp]
	mov	edx, DWORD PTR __Val$222481[ebp+60]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+60]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	esi, DWORD PTR __First1$222491[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR __Next1$222480[ebp]
	rep movsd
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR __Val$222481[ebp]
	mov	edi, DWORD PTR __Next1$222480[ebp]
	rep movsd
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ENDP ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z
_TEXT	SEGMENT
tv92 = -164						; size = 4
$T228798 = -160						; size = 4
__Next$228806 = -156					; size = 4
$T228656 = -24						; size = 4
$T228645 = -20						; size = 4
$T228644 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>, COMDAT

; 5252 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T228644[ebp], al
	movzx	ecx, BYTE PTR $T228644[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T228645[ebp], esp
	mov	DWORD PTR $T228656[ebp], ecx
	mov	edx, DWORD PTR $T228656[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T228656[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T228656[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T228656[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T228656[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T228656[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
	add	esp, 40					; 00000028H

; 5254 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$228806[ebp], edx
	jmp	SHORT $LN77@Unchecked_
$LN76@Unchecked_:
	mov	eax, DWORD PTR __Next$228806[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next$228806[ebp], eax
$LN77@Unchecked_:
	mov	ecx, DWORD PTR __Next$228806[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN75@Unchecked_
	jmp	SHORT $LN76@Unchecked_
$LN75@Unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228798[ebp], edx
	mov	eax, DWORD PTR $T228798[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
PUBLIC	??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T228851 = -40						; size = 4
__Next$228859 = -36					; size = 4
$T228843 = -32						; size = 4
__Cat$228830 = -25					; size = 1
$T228825 = -24						; size = 4
$T228821 = -20						; size = 4
$T228820 = -15						; size = 1
$T228819 = -14						; size = 1
$T228818 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z PROC ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T228825[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T228818[ebp], al
	mov	cl, BYTE PTR __Cat$228830[ebp]
	mov	BYTE PTR $T228819[ebp], cl
	movzx	edx, BYTE PTR $T228818[ebp]
	push	edx
	movzx	eax, BYTE PTR $T228819[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T228820[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T228821[ebp], esp
	mov	DWORD PTR $T228843[ebp], edx
	mov	eax, DWORD PTR $T228843[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T228843[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T228843[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T228843[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T228843[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T228843[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T228825[ebp]
	or	ecx, 1
	mov	DWORD PTR $T228825[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$228859[ebp], edx
	jmp	SHORT $LN17@unchecked_
$LN16@unchecked_:
	mov	eax, DWORD PTR __Next$228859[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next$228859[ebp], eax
$LN17@unchecked_:
	mov	ecx, DWORD PTR __Next$228859[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_
	jmp	SHORT $LN16@unchecked_
$LN15@unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228851[ebp], edx
	mov	eax, DWORD PTR $T228851[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ENDP ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
PUBLIC	??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
tv178 = -260						; size = 4
tv177 = -256						; size = 4
tv174 = -252						; size = 4
tv173 = -248						; size = 4
$T229151 = -240						; size = 4
$T229137 = -233						; size = 1
$T229136 = -232						; size = 4
$T229139 = -225						; size = 1
$T229116 = -224						; size = 4
$T229115 = -220						; size = 4
$T229098 = -214						; size = 1
$T229097 = -213						; size = 1
$T229096 = -212						; size = 4
$T229095 = -208						; size = 4
__Cat$229105 = -200					; size = 1
$T229102 = -199						; size = 1
$T229101 = -198						; size = 1
$T229100 = -197						; size = 1
$T229076 = -196						; size = 4
$T229072 = -192						; size = 4
$T229068 = -188						; size = 4
$T229067 = -184						; size = 4
$T229051 = -178						; size = 1
$T229050 = -177						; size = 1
$T229049 = -176						; size = 4
$T229048 = -172						; size = 4
$T229047 = -168						; size = 4
__Cat$229059 = -160					; size = 1
$T229056 = -159						; size = 1
$T229055 = -158						; size = 1
$T229054 = -157						; size = 1
$T229018 = -156						; size = 4
__Next$229026 = -152					; size = 4
$T229010 = -148						; size = 4
$T228997 = -136						; size = 4
$T228996 = -132						; size = 4
$T228980 = -126						; size = 1
$T228979 = -125						; size = 1
$T228978 = -124						; size = 4
$T228977 = -120						; size = 4
$T228976 = -116						; size = 4
__Cat$228988 = -108					; size = 1
$T228985 = -107						; size = 1
$T228984 = -106						; size = 1
$T228983 = -105						; size = 1
$T228958 = -104						; size = 4
$T228954 = -100						; size = 4
$T228950 = -96						; size = 4
$T228949 = -92						; size = 4
$T228932 = -86						; size = 1
$T228931 = -85						; size = 1
$T228930 = -84						; size = 4
$T228929 = -80						; size = 4
__Cat$228939 = -72					; size = 1
$T228936 = -71						; size = 1
$T228935 = -70						; size = 1
$T228934 = -69						; size = 1
$T228899 = -68						; size = 4
__Next$228907 = -64					; size = 4
$T228891 = -60						; size = 4
$T228874 = -48						; size = 20
$T228873 = -28						; size = 4
$T228872 = -24						; size = 20
$T228871 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	esi
	push	edi

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T228871[ebp], esp
	mov	DWORD PTR $T228891[ebp], eax
	mov	ecx, DWORD PTR $T228891[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T228891[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T228891[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T228891[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T228891[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T228891[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T228872[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv174[ebp], eax
	cmp	DWORD PTR $T228872[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T228872[ebp]
	mov	DWORD PTR __Next$228907[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$228907[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR __Next$228907[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$228907[ebp]
	cmp	edx, DWORD PTR $T228872[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T228872[ebp]
	mov	DWORD PTR $T228899[ebp], eax
	mov	ecx, DWORD PTR $T228899[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228950[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T228949[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T228934[ebp], cl
	mov	dl, BYTE PTR __Cat$228939[ebp]
	mov	BYTE PTR $T228935[ebp], dl
	mov	al, BYTE PTR $T228934[ebp]
	mov	BYTE PTR $T228932[ebp], al
	mov	cl, BYTE PTR $T228936[ebp]
	mov	BYTE PTR $T228931[ebp], cl
	mov	edx, DWORD PTR $T228950[ebp]
	mov	DWORD PTR $T228930[ebp], edx
	mov	eax, DWORD PTR $T228949[ebp]
	mov	DWORD PTR $T228929[ebp], eax
	jmp	SHORT $LN38@Buffered_r
$LN37@Buffered_r:
	mov	ecx, DWORD PTR $T228930[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR $T228930[ebp], ecx
	mov	edx, DWORD PTR $T228929[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR $T228929[ebp], edx
$LN38@Buffered_r:
	mov	eax, DWORD PTR $T228929[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN30@Buffered_r
	mov	esi, DWORD PTR $T228929[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T228930[ebp]
	rep movsd
	jmp	SHORT $LN37@Buffered_r
$LN30@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T228954[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T228958[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T228997[ebp], ecx
	mov	edx, DWORD PTR $T228958[ebp]
	mov	DWORD PTR $T228996[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T228983[ebp], al
	mov	cl, BYTE PTR __Cat$228988[ebp]
	mov	BYTE PTR $T228984[ebp], cl
	mov	dl, BYTE PTR $T228983[ebp]
	mov	BYTE PTR $T228980[ebp], dl
	mov	al, BYTE PTR $T228985[ebp]
	mov	BYTE PTR $T228979[ebp], al
	mov	ecx, DWORD PTR $T228997[ebp]
	mov	DWORD PTR $T228978[ebp], ecx
	mov	edx, DWORD PTR $T228954[ebp]
	mov	DWORD PTR $T228977[ebp], edx
	mov	eax, DWORD PTR $T228996[ebp]
	mov	DWORD PTR $T228976[ebp], eax
$LN52@Buffered_r:
	mov	ecx, DWORD PTR $T228976[ebp]
	cmp	ecx, DWORD PTR $T228977[ebp]
	je	SHORT $LN45@Buffered_r
	mov	edx, DWORD PTR $T228977[ebp]
	sub	edx, 76					; 0000004cH
	mov	DWORD PTR $T228977[ebp], edx
	mov	eax, DWORD PTR $T228978[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR $T228978[ebp], eax
	mov	esi, DWORD PTR $T228977[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T228978[ebp]
	rep movsd
	jmp	SHORT $LN52@Buffered_r
$LN45@Buffered_r:
	mov	eax, DWORD PTR $T228978[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T228873[ebp], esp
	mov	DWORD PTR $T229010[ebp], eax
	mov	ecx, DWORD PTR $T229010[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T229010[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T229010[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T229010[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T229010[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T229010[ebp]
	mov	DWORD PTR tv177[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T228874[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv178[ebp], eax
	cmp	DWORD PTR $T228874[ebp], 0
	je	SHORT $LN68@Buffered_r
	mov	eax, DWORD PTR $T228874[ebp]
	mov	DWORD PTR __Next$229026[ebp], eax
	jmp	SHORT $LN66@Buffered_r
$LN65@Buffered_r:
	mov	ecx, DWORD PTR __Next$229026[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR __Next$229026[ebp], ecx
$LN66@Buffered_r:
	mov	edx, DWORD PTR __Next$229026[ebp]
	cmp	edx, DWORD PTR $T228874[ebp+8]
	je	SHORT $LN64@Buffered_r
	jmp	SHORT $LN65@Buffered_r
$LN64@Buffered_r:
	mov	eax, DWORD PTR $T228874[ebp]
	mov	DWORD PTR $T229018[ebp], eax
	mov	ecx, DWORD PTR $T229018[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T229068[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229067[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229054[ebp], cl
	mov	dl, BYTE PTR __Cat$229059[ebp]
	mov	BYTE PTR $T229055[ebp], dl
	mov	al, BYTE PTR $T229054[ebp]
	mov	BYTE PTR $T229051[ebp], al
	mov	cl, BYTE PTR $T229056[ebp]
	mov	BYTE PTR $T229050[ebp], cl
	mov	edx, DWORD PTR $T229068[ebp]
	mov	DWORD PTR $T229049[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T229048[ebp], eax
	mov	ecx, DWORD PTR $T229067[ebp]
	mov	DWORD PTR $T229047[ebp], ecx
$LN81@Buffered_r:
	mov	edx, DWORD PTR $T229047[ebp]
	cmp	edx, DWORD PTR $T229048[ebp]
	je	SHORT $LN74@Buffered_r
	mov	eax, DWORD PTR $T229048[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR $T229048[ebp], eax
	mov	ecx, DWORD PTR $T229049[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR $T229049[ebp], ecx
	mov	esi, DWORD PTR $T229048[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229049[ebp]
	rep movsd
	jmp	SHORT $LN81@Buffered_r
$LN74@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T229072[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T229076[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229116[ebp], edx
	mov	eax, DWORD PTR $T229076[ebp]
	mov	DWORD PTR $T229115[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229100[ebp], cl
	mov	dl, BYTE PTR __Cat$229105[ebp]
	mov	BYTE PTR $T229101[ebp], dl
	mov	al, BYTE PTR $T229100[ebp]
	mov	BYTE PTR $T229098[ebp], al
	mov	cl, BYTE PTR $T229102[ebp]
	mov	BYTE PTR $T229097[ebp], cl
	mov	edx, DWORD PTR $T229116[ebp]
	mov	DWORD PTR $T229096[ebp], edx
	mov	eax, DWORD PTR $T229115[ebp]
	mov	DWORD PTR $T229095[ebp], eax
	jmp	SHORT $LN96@Buffered_r
$LN95@Buffered_r:
	mov	ecx, DWORD PTR $T229096[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR $T229096[ebp], ecx
	mov	edx, DWORD PTR $T229095[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR $T229095[ebp], edx
$LN96@Buffered_r:
	mov	eax, DWORD PTR $T229095[ebp]
	cmp	eax, DWORD PTR $T229072[ebp]
	je	SHORT $LN88@Buffered_r
	mov	esi, DWORD PTR $T229095[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229096[ebp]
	rep movsd
	jmp	SHORT $LN95@Buffered_r
$LN88@Buffered_r:
	mov	eax, DWORD PTR $T229096[ebp]
	jmp	SHORT $LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	SHORT $LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229151[ebp], ecx
	mov	edx, DWORD PTR $T229151[ebp]
	cmp	edx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	cl, BYTE PTR $T229139[ebp]
	mov	BYTE PTR $T229137[ebp], cl
	mov	edx, DWORD PTR $T229151[ebp]
	mov	DWORD PTR $T229136[ebp], edx
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229136[ebp]
	push	edx
	call	??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN112@Buffered_r:
	mov	eax, DWORD PTR __Count2$[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 2701 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv183 = -180						; size = 4
tv182 = -176						; size = 4
tv179 = -172						; size = 4
tv178 = -168						; size = 4
tv174 = -164						; size = 4
tv173 = -160						; size = 4
$T229330 = -156						; size = 4
__Next$229333 = -152					; size = 4
$T229311 = -148						; size = 4
__Next$229319 = -144					; size = 4
$T229303 = -140						; size = 4
$T229266 = -132						; size = 4
__Next$229274 = -128					; size = 4
$T229258 = -124						; size = 4
$T229238 = -120						; size = 4
__Next$229246 = -116					; size = 4
$T229230 = -112						; size = 4
$T229226 = -108						; size = 4
$T229176 = -100						; size = 20
$T229175 = -80						; size = 4
$T229174 = -76						; size = 20
$T229173 = -56						; size = 4
$T229172 = -52						; size = 20
$T229171 = -32						; size = 4
__Mid$222883 = -28					; size = 4
__Mid2$222866 = -24					; size = 4
__Mid1$222865 = -20					; size = 4
__Chunk2$222861 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$222861[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$222861[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$222861[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$222865[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR __Mid1$222865[ebp]
	mov	DWORD PTR __Mid1$222865[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$222865[ebp]
	mov	DWORD PTR __Mid2$222866[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __Mid2$222866[ebp]
	mov	DWORD PTR __Mid2$222866[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T229171[ebp], esp
	mov	DWORD PTR $T229226[ebp], ecx
	mov	edx, DWORD PTR $T229226[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T229226[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T229226[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T229226[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T229226[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T229226[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid2$222866[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$222865[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$222865[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229172[ebp]
	push	ecx
	call	??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv174[ebp], eax
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T229230[ebp], edx
	mov	eax, DWORD PTR $T229230[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T229172[ebp], 0
	je	SHORT $LN37@Chunked_me
	mov	edx, DWORD PTR $T229172[ebp]
	mov	DWORD PTR __Next$229246[ebp], edx
	jmp	SHORT $LN35@Chunked_me
$LN34@Chunked_me:
	mov	eax, DWORD PTR __Next$229246[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next$229246[ebp], eax
$LN35@Chunked_me:
	mov	ecx, DWORD PTR __Next$229246[ebp]
	cmp	ecx, DWORD PTR $T229172[ebp+8]
	je	SHORT $LN33@Chunked_me
	jmp	SHORT $LN34@Chunked_me
$LN33@Chunked_me:
	mov	edx, DWORD PTR $T229172[ebp]
	mov	DWORD PTR $T229238[ebp], edx
	mov	eax, DWORD PTR $T229238[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me:

; 3297 : 		_First = _Mid2;

	mov	ecx, DWORD PTR __Mid2$222866[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 3298 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	edx, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T229173[ebp], esp
	mov	DWORD PTR $T229258[ebp], eax
	mov	ecx, DWORD PTR $T229258[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T229258[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T229258[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T229258[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T229258[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T229258[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229174[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR $T229174[ebp], 0
	je	SHORT $LN51@Chunked_me
	mov	edx, DWORD PTR $T229174[ebp]
	mov	DWORD PTR __Next$229274[ebp], edx
	jmp	SHORT $LN49@Chunked_me
$LN48@Chunked_me:
	mov	eax, DWORD PTR __Next$229274[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next$229274[ebp], eax
$LN49@Chunked_me:
	mov	ecx, DWORD PTR __Next$229274[ebp]
	cmp	ecx, DWORD PTR $T229174[ebp+8]
	je	SHORT $LN47@Chunked_me
	jmp	SHORT $LN48@Chunked_me
$LN47@Chunked_me:
	mov	edx, DWORD PTR $T229174[ebp]
	mov	DWORD PTR $T229266[ebp], edx
	mov	eax, DWORD PTR $T229266[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me:

; 3302 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$222883[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR __Mid$222883[ebp]
	mov	DWORD PTR __Mid$222883[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T229175[ebp], esp
	mov	DWORD PTR $T229303[ebp], eax
	mov	ecx, DWORD PTR $T229303[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T229303[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T229303[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T229303[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T229303[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T229303[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$222883[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$222883[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T229176[ebp]
	push	eax
	call	??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR $T229176[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	ecx, DWORD PTR $T229176[ebp]
	mov	DWORD PTR __Next$229319[ebp], ecx
	jmp	SHORT $LN69@Chunked_me
$LN68@Chunked_me:
	mov	edx, DWORD PTR __Next$229319[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Next$229319[ebp], edx
$LN69@Chunked_me:
	mov	eax, DWORD PTR __Next$229319[ebp]
	cmp	eax, DWORD PTR $T229176[ebp+8]
	je	SHORT $LN67@Chunked_me
	jmp	SHORT $LN68@Chunked_me
$LN67@Chunked_me:
	mov	ecx, DWORD PTR $T229176[ebp]
	mov	DWORD PTR $T229311[ebp], ecx
	mov	edx, DWORD PTR $T229311[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3308 : 		}
; 3309 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$229333[ebp], eax
	jmp	SHORT $LN79@Chunked_me
$LN78@Chunked_me:
	mov	ecx, DWORD PTR __Next$229333[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR __Next$229333[ebp], ecx
$LN79@Chunked_me:
	mov	edx, DWORD PTR __Next$229333[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me
	jmp	SHORT $LN78@Chunked_me
$LN77@Chunked_me:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229330[ebp], eax
	mov	ecx, DWORD PTR $T229330[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229615 = -176						; size = 4
$T229614 = -172						; size = 4
$T229613 = -168						; size = 4
$T229612 = -164						; size = 4
$T229607 = -104						; size = 1
$T229606 = -103						; size = 1
$T229496 = -100						; size = 4
$T229495 = -96						; size = 4
$T229478 = -90						; size = 1
$T229477 = -89						; size = 1
$T229476 = -88						; size = 4
$T229475 = -84						; size = 4
__Cat$229485 = -76					; size = 1
$T229482 = -75						; size = 1
$T229481 = -74						; size = 1
$T229480 = -73						; size = 1
$T229456 = -72						; size = 4
$T229455 = -68						; size = 4
$T229454 = -64						; size = 4
$T229453 = -60						; size = 4
$T229452 = -56						; size = 4
$T229447 = -22						; size = 1
$T229446 = -21						; size = 1
__Mid$222895 = -16					; size = 4
__Mid2$222892 = -12					; size = 4
__Mid1$222891 = -8					; size = 4
__Chunk2$222887 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	esi
	push	edi

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$222887[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$222887[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$222887[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$222891[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR __Mid1$222891[ebp]
	mov	DWORD PTR __Mid1$222891[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$222891[ebp]
	mov	DWORD PTR __Mid2$222892[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __Mid2$222892[ebp]
	mov	DWORD PTR __Mid2$222892[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229456[ebp], ecx
	mov	edx, DWORD PTR __Mid2$222892[ebp]
	mov	DWORD PTR $T229455[ebp], edx
	mov	eax, DWORD PTR __Mid1$222891[ebp]
	mov	DWORD PTR $T229454[ebp], eax
	mov	ecx, DWORD PTR __Mid1$222891[ebp]
	mov	DWORD PTR $T229453[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229452[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229446[ebp], al
	movzx	ecx, BYTE PTR $T229446[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229447[ebp]
	push	edx
	mov	eax, DWORD PTR $T229456[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229455[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229454[ebp]
	push	edx
	mov	eax, DWORD PTR $T229453[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229452[ebp]
	push	ecx
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], eax

; 3297 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$222892[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3298 : 		}

	jmp	$LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229496[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229495[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229480[ebp], al
	mov	cl, BYTE PTR __Cat$229485[ebp]
	mov	BYTE PTR $T229481[ebp], cl
	mov	dl, BYTE PTR $T229480[ebp]
	mov	BYTE PTR $T229478[ebp], dl
	mov	al, BYTE PTR $T229482[ebp]
	mov	BYTE PTR $T229477[ebp], al
	mov	ecx, DWORD PTR $T229496[ebp]
	mov	DWORD PTR $T229476[ebp], ecx
	mov	edx, DWORD PTR $T229495[ebp]
	mov	DWORD PTR $T229475[ebp], edx
	jmp	SHORT $LN53@Chunked_me@2
$LN52@Chunked_me@2:
	mov	eax, DWORD PTR $T229476[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR $T229476[ebp], eax
	mov	ecx, DWORD PTR $T229475[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR $T229475[ebp], ecx
$LN53@Chunked_me@2:
	mov	edx, DWORD PTR $T229475[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN45@Chunked_me@2
	mov	esi, DWORD PTR $T229475[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229476[ebp]
	rep movsd
	jmp	SHORT $LN52@Chunked_me@2
$LN45@Chunked_me@2:

; 3302 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$222895[ebp], eax

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR __Mid$222895[ebp]
	mov	DWORD PTR __Mid$222895[ebp], ecx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229615[ebp], edx
	mov	eax, DWORD PTR __Mid$222895[ebp]
	mov	DWORD PTR $T229614[ebp], eax
	mov	ecx, DWORD PTR __Mid$222895[ebp]
	mov	DWORD PTR $T229613[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229612[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229606[ebp], al
	movzx	ecx, BYTE PTR $T229606[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229607[ebp]
	push	edx
	mov	eax, DWORD PTR $T229615[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T229614[ebp]
	push	edx
	mov	eax, DWORD PTR $T229613[ebp]
	push	eax
	mov	ecx, DWORD PTR $T229612[ebp]
	push	ecx
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN6@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229659 = -36						; size = 4
__Next$229667 = -32					; size = 4
$T229620 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T229620[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T229620[ebp]
	or	eax, 1
	mov	DWORD PTR $T229620[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN31@Copy_opt
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$229667[ebp], ecx
	jmp	SHORT $LN29@Copy_opt
$LN28@Copy_opt:
	mov	edx, DWORD PTR __Next$229667[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Next$229667[ebp], edx
$LN29@Copy_opt:
	mov	eax, DWORD PTR __Next$229667[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN27@Copy_opt
	jmp	SHORT $LN28@Copy_opt
$LN27@Copy_opt:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229659[ebp], ecx
	mov	edx, DWORD PTR $T229659[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229761 = -56						; size = 4
$T229760 = -52						; size = 4
$T229743 = -46						; size = 1
$T229742 = -45						; size = 1
$T229741 = -44						; size = 4
$T229740 = -40						; size = 4
__Cat$229750 = -32					; size = 1
$T229747 = -31						; size = 1
$T229746 = -30						; size = 1
$T229745 = -29						; size = 1
$T229721 = -28						; size = 4
$T229720 = -24						; size = 4
$T229703 = -18						; size = 1
$T229702 = -17						; size = 1
$T229701 = -16						; size = 4
$T229700 = -12						; size = 4
__Cat$229710 = -4					; size = 1
$T229707 = -3						; size = 1
$T229706 = -2						; size = 1
$T229705 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+60]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+60]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	esi, DWORD PTR __First2$[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	esi, DWORD PTR __First1$[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	mov	eax, DWORD PTR __First1$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __First1$[ebp], eax
$LN1@Merge:
	jmp	SHORT $LN4@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229721[ebp], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T229720[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229705[ebp], al
	mov	cl, BYTE PTR __Cat$229710[ebp]
	mov	BYTE PTR $T229706[ebp], cl
	mov	dl, BYTE PTR $T229705[ebp]
	mov	BYTE PTR $T229703[ebp], dl
	mov	al, BYTE PTR $T229707[ebp]
	mov	BYTE PTR $T229702[ebp], al
	mov	ecx, DWORD PTR $T229721[ebp]
	mov	DWORD PTR $T229701[ebp], ecx
	mov	edx, DWORD PTR $T229720[ebp]
	mov	DWORD PTR $T229700[ebp], edx
	jmp	SHORT $LN18@Merge
$LN17@Merge:
	mov	eax, DWORD PTR $T229701[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR $T229701[ebp], eax
	mov	ecx, DWORD PTR $T229700[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR $T229700[ebp], ecx
$LN18@Merge:
	mov	edx, DWORD PTR $T229700[ebp]
	cmp	edx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN10@Merge
	mov	esi, DWORD PTR $T229700[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229701[ebp]
	rep movsd
	jmp	SHORT $LN17@Merge
$LN10@Merge:
	mov	eax, DWORD PTR $T229701[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229761[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T229760[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229745[ebp], al
	mov	cl, BYTE PTR __Cat$229750[ebp]
	mov	BYTE PTR $T229746[ebp], cl
	mov	dl, BYTE PTR $T229745[ebp]
	mov	BYTE PTR $T229743[ebp], dl
	mov	al, BYTE PTR $T229747[ebp]
	mov	BYTE PTR $T229742[ebp], al
	mov	ecx, DWORD PTR $T229761[ebp]
	mov	DWORD PTR $T229741[ebp], ecx
	mov	edx, DWORD PTR $T229760[ebp]
	mov	DWORD PTR $T229740[ebp], edx
	jmp	SHORT $LN29@Merge
$LN28@Merge:
	mov	eax, DWORD PTR $T229741[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR $T229741[ebp], eax
	mov	ecx, DWORD PTR $T229740[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR $T229740[ebp], ecx
$LN29@Merge:
	mov	edx, DWORD PTR $T229740[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN21@Merge
	mov	esi, DWORD PTR $T229740[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229741[ebp]
	rep movsd
	jmp	SHORT $LN28@Merge
$LN21@Merge:
	mov	eax, DWORD PTR $T229741[ebp]

; 2521 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229841 = -64						; size = 4
$T229840 = -60						; size = 4
$T229824 = -54						; size = 1
$T229823 = -53						; size = 1
$T229822 = -52						; size = 4
$T229821 = -48						; size = 4
$T229820 = -44						; size = 4
__Cat$229831 = -36					; size = 1
$T229828 = -35						; size = 1
$T229827 = -34						; size = 1
$T229826 = -33						; size = 1
$T229802 = -32						; size = 4
$T229801 = -28						; size = 4
$T229785 = -22						; size = 1
$T229784 = -21						; size = 1
$T229783 = -20						; size = 4
$T229782 = -16						; size = 4
$T229781 = -12						; size = 4
__Cat$229792 = -4					; size = 1
$T229789 = -3						; size = 1
$T229788 = -2						; size = 1
$T229787 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
$LN8@Merge_back:

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	SHORT $LN6@Merge_back

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229802[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T229801[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T229787[ebp], al
	mov	cl, BYTE PTR __Cat$229792[ebp]
	mov	BYTE PTR $T229788[ebp], cl
	mov	dl, BYTE PTR $T229787[ebp]
	mov	BYTE PTR $T229785[ebp], dl
	mov	al, BYTE PTR $T229789[ebp]
	mov	BYTE PTR $T229784[ebp], al
	mov	ecx, DWORD PTR $T229802[ebp]
	mov	DWORD PTR $T229783[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T229782[ebp], edx
	mov	eax, DWORD PTR $T229801[ebp]
	mov	DWORD PTR $T229781[ebp], eax
$LN18@Merge_back:
	mov	ecx, DWORD PTR $T229781[ebp]
	cmp	ecx, DWORD PTR $T229782[ebp]
	je	SHORT $LN11@Merge_back
	mov	edx, DWORD PTR $T229782[ebp]
	sub	edx, 76					; 0000004cH
	mov	DWORD PTR $T229782[ebp], edx
	mov	eax, DWORD PTR $T229783[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR $T229783[ebp], eax
	mov	esi, DWORD PTR $T229782[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229783[ebp]
	rep movsd
	jmp	SHORT $LN18@Merge_back
$LN11@Merge_back:
	mov	eax, DWORD PTR $T229783[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229841[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T229840[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229826[ebp], cl
	mov	dl, BYTE PTR __Cat$229831[ebp]
	mov	BYTE PTR $T229827[ebp], dl
	mov	al, BYTE PTR $T229826[ebp]
	mov	BYTE PTR $T229824[ebp], al
	mov	cl, BYTE PTR $T229828[ebp]
	mov	BYTE PTR $T229823[ebp], cl
	mov	edx, DWORD PTR $T229841[ebp]
	mov	DWORD PTR $T229822[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T229821[ebp], eax
	mov	ecx, DWORD PTR $T229840[ebp]
	mov	DWORD PTR $T229820[ebp], ecx
$LN28@Merge_back:
	mov	edx, DWORD PTR $T229820[ebp]
	cmp	edx, DWORD PTR $T229821[ebp]
	je	SHORT $LN21@Merge_back
	mov	eax, DWORD PTR $T229821[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR $T229821[ebp], eax
	mov	ecx, DWORD PTR $T229822[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR $T229822[ebp], ecx
	mov	esi, DWORD PTR $T229821[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229822[ebp]
	rep movsd
	jmp	SHORT $LN28@Merge_back
$LN21@Merge_back:
	mov	eax, DWORD PTR $T229822[ebp]
	jmp	SHORT $LN9@Merge_back
	jmp	SHORT $LN5@Merge_back
$LN4@Merge_back:

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	edx, DWORD PTR __Last1$[ebp]
	sub	edx, 76					; 0000004cH
	mov	DWORD PTR __Last1$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR __Last2$[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+60]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Merge_back

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 76					; 0000004cH
	mov	DWORD PTR __Dest$[ebp], eax
	mov	esi, DWORD PTR __Last1$[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	mov	ecx, DWORD PTR __Last2$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR __Last2$[ebp], ecx

; 2718 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 76					; 0000004cH
	mov	DWORD PTR __Dest$[ebp], edx
	mov	esi, DWORD PTR __Last2$[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	mov	eax, DWORD PTR __Last1$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Last1$[ebp], eax
$LN5@Merge_back:
	jmp	$LN8@Merge_back
$LN9@Merge_back:

; 2720 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T229864 = -20						; size = 4
__Count2$222945 = -12					; size = 4
__Mid$222946 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2255 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229864[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T229864[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$222945[ebp], eax

; 2260 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$222946[ebp], edx

; 2261 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$222945[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __Mid$222946[ebp]
	mov	DWORD PTR __Mid$222946[ebp], eax

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	ecx, DWORD PTR __Mid$222946[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+60]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$222946[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Mid$222946[ebp], eax
	mov	ecx, DWORD PTR __Mid$222946[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$222945[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$222945[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Lower_boun:

; 2268 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2269 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2270 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T229904 = -20						; size = 4
__Count2$222954 = -12					; size = 4
__Mid$222955 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2327 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229904[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T229904[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$222954[ebp], eax

; 2331 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$222955[ebp], edx

; 2332 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$222954[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __Mid$222955[ebp]
	mov	DWORD PTR __Mid$222955[ebp], eax

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR __Mid$222955[ebp]
	mov	eax, DWORD PTR [ecx+60]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+60]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$222955[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Mid$222955[ebp], eax
	mov	ecx, DWORD PTR __Mid$222955[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$222954[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$222954[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Upper_boun:

; 2339 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2340 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2341 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T229935 = -12						; size = 4
__Vptr$229941 = -8					; size = 4
__Ptr$223012 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	esi, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edi, DWORD PTR [eax+4]
	mov	ecx, 19					; 00000013H
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 76					; 0000004cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+4], eax

; 565  : 		else

	jmp	SHORT $LN1@operator
$LN2@operator:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Ptr$223012[ebp], edx

; 569  : 			_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$223012[ebp]
	mov	DWORD PTR __Vptr$229941[ebp], eax
	mov	ecx, DWORD PTR __Vptr$229941[ebp]
	mov	DWORD PTR $T229935[ebp], ecx
	cmp	DWORD PTR $T229935[ebp], 0
	je	SHORT $LN7@operator
	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR $T229935[ebp]
	rep movsd
	mov	edx, DWORD PTR $T229935[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator
$LN7@operator:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 76					; 0000004cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv132 = -44						; size = 4
$T229972 = -40						; size = 4
__Next$229980 = -36					; size = 4
$T229964 = -32						; size = 4
$T229950 = -24						; size = 4
$T229946 = -20						; size = 4
$T229945 = -14						; size = 1
$T229944 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z PROC ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T229950[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T229944[ebp], al
	movzx	ecx, BYTE PTR $T229944[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229945[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T229946[ebp], esp
	mov	DWORD PTR $T229964[ebp], eax
	mov	ecx, DWORD PTR $T229964[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T229964[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T229964[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T229964[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T229964[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T229964[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR $T229950[ebp]
	or	ecx, 1
	mov	DWORD PTR $T229950[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@2
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$229980[ebp], edx
	jmp	SHORT $LN15@unchecked_@2
$LN14@unchecked_@2:
	mov	eax, DWORD PTR __Next$229980[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR __Next$229980[ebp], eax
$LN15@unchecked_@2:
	mov	ecx, DWORD PTR __Next$229980[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@2
	jmp	SHORT $LN14@unchecked_@2
$LN13@unchecked_@2:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229972[ebp], edx
	mov	eax, DWORD PTR $T229972[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ENDP ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -112						; size = 4
tv163 = -108						; size = 4
tv159 = -104						; size = 4
tv158 = -100						; size = 4
$T230094 = -96						; size = 4
__Next$230102 = -92					; size = 4
$T230086 = -88						; size = 4
$T230066 = -84						; size = 4
__Next$230074 = -80					; size = 4
$T230058 = -76						; size = 4
$T230054 = -72						; size = 4
$T230000 = -44						; size = 4
$T229994 = -40						; size = 4
$T229993 = -36						; size = 20
$T229992 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T230000[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+60]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN30@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN30@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@2:
	jmp	SHORT $LN5@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T229992[ebp], esp
	mov	DWORD PTR $T230054[ebp], edx
	mov	eax, DWORD PTR $T230054[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T230054[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T230054[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T230054[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T230054[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T230054[ebp]
	mov	DWORD PTR tv158[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T229993[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T230058[ebp], ecx
	mov	edx, DWORD PTR $T230058[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Dest$[ebp+16], eax
	cmp	DWORD PTR $T229993[ebp], 0
	je	SHORT $LN52@Merge@2
	mov	ecx, DWORD PTR $T229993[ebp]
	mov	DWORD PTR __Next$230074[ebp], ecx
	jmp	SHORT $LN50@Merge@2
$LN49@Merge@2:
	mov	edx, DWORD PTR __Next$230074[ebp]
	add	edx, 76					; 0000004cH
	mov	DWORD PTR __Next$230074[ebp], edx
$LN50@Merge@2:
	mov	eax, DWORD PTR __Next$230074[ebp]
	cmp	eax, DWORD PTR $T229993[ebp+8]
	je	SHORT $LN48@Merge@2
	jmp	SHORT $LN49@Merge@2
$LN48@Merge@2:
	mov	ecx, DWORD PTR $T229993[ebp]
	mov	DWORD PTR $T230066[ebp], ecx
	mov	edx, DWORD PTR $T230066[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T229994[ebp], esp
	mov	DWORD PTR $T230086[ebp], eax
	mov	ecx, DWORD PTR $T230086[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T230086[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T230086[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T230086[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T230086[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T230086[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv164[ebp], eax
	mov	edx, DWORD PTR $T230000[ebp]
	or	edx, 1
	mov	DWORD PTR $T230000[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN66@Merge@2
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$230102[ebp], eax
	jmp	SHORT $LN64@Merge@2
$LN63@Merge@2:
	mov	ecx, DWORD PTR __Next$230102[ebp]
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR __Next$230102[ebp], ecx
$LN64@Merge@2:
	mov	edx, DWORD PTR __Next$230102[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN62@Merge@2
	jmp	SHORT $LN63@Merge@2
$LN62@Merge@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T230094[ebp], eax
	mov	ecx, DWORD PTR $T230094[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN66@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z
_TEXT	SEGMENT
tv128 = -116						; size = 4
tv83 = -112						; size = 4
__Hole$223133 = -108					; size = 4
__Holeval$223135 = -104					; size = 76
__Next1$223136 = -24					; size = 4
__Next$223134 = -20					; size = 4
__Tmp$223128 = -16					; size = 4
__Factor$223124 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z PROC ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	esi
	push	edi

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	mov	DWORD PTR __Count$[ebp], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$223124[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$223124[ebp], 0
	je	SHORT $LN7@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$223124[ebp]
	mov	DWORD PTR __Tmp$223128[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$223124[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$223128[ebp]
	mov	DWORD PTR __Factor$223124[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate
$LN7@Rotate:

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	cmp	DWORD PTR __Count$[ebp], eax
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Hole$223133[ebp], eax

; 1695 : 			_RanIt _Next = _Hole;

	mov	ecx, DWORD PTR __Hole$223133[ebp]
	mov	DWORD PTR __Next$223134[ebp], ecx

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	esi, DWORD PTR __Hole$223133[ebp]
	mov	ecx, 19					; 00000013H
	lea	edi, DWORD PTR __Holeval$223135[ebp]
	rep movsd

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	edx, DWORD PTR __Shift$[ebp]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR __Next$223134[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN11@Rotate
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	ecx, DWORD PTR __Shift$[ebp]
	imul	ecx, 76					; 0000004cH
	add	ecx, DWORD PTR __Next$223134[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN12@Rotate:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR __Next1$223136[ebp], edx
$LN2@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	mov	eax, DWORD PTR __Next1$223136[ebp]
	cmp	eax, DWORD PTR __Hole$223133[ebp]
	je	SHORT $LN1@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	esi, DWORD PTR __Next1$223136[ebp]
	mov	ecx, 19					; 00000013H
	mov	edi, DWORD PTR __Next$223134[ebp]
	rep movsd

; 1701 : 				_Next = _Next1;

	mov	ecx, DWORD PTR __Next1$223136[ebp]
	mov	DWORD PTR __Next$223134[ebp], ecx

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$223136[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	cmp	DWORD PTR __Shift$[ebp], eax
	jge	SHORT $LN13@Rotate
	mov	edx, DWORD PTR __Shift$[ebp]
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR __Next1$223136[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$223136[ebp]
	cdq
	mov	ecx, 76					; 0000004cH
	idiv	ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	sub	edx, eax
	imul	edx, 76					; 0000004cH
	add	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv128[ebp], edx
$LN14@Rotate:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR __Next1$223136[ebp], eax

; 1704 : 				}

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 1705 : 			*_Next = _Holeval;

	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR __Holeval$223135[ebp]
	mov	edi, DWORD PTR __Next$223134[ebp]
	rep movsd

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ENDP ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T230148 = -2092					; size = 4
$T230147 = -2088					; size = 4
$T230146 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T230146[ebp], eax
	mov	ecx, DWORD PTR $T230146[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230147[ebp], eax
	mov	eax, DWORD PTR $T230147[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T230148[ebp], eax
	mov	ecx, DWORD PTR $T230148[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
_TEXT	ENDS
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T230159 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T230159[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T230159[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiOffset$ = -4						; size = 4
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	eax, DWORD PTR _uiEntry$[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$[ebp], eax

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	ecx, DWORD PTR _uiOffset$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _uiEntry$[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [edx+ecx*4]
	setne	al

; 770  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T230175 = -8						; size = 4
$T230171 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T230171[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T230171[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T230175[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T230175[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
