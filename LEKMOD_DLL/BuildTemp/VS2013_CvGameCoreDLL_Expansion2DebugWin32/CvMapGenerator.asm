; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvMapGenerator.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@PIJHIFGM@Map?5Script?$AA@		; `string'
PUBLIC	??_7CvMapGenerator@@6B@				; CvMapGenerator::`vftable'
PUBLIC	??0CvMapGenerator@@QAE@PBD@Z			; CvMapGenerator::CvMapGenerator
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	??_ECvMapGenerator@@UAEPAXI@Z:PROC		; CvMapGenerator::`vector deleting destructor'
;	COMDAT ??_C@_0L@PIJHIFGM@Map?5Script?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0L@PIJHIFGM@Map?5Script?$AA@ DB 'Map Script', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CvMapGenerator@@6B@
CONST	SEGMENT
??_7CvMapGenerator@@6B@ DD FLAT:??_ECvMapGenerator@@UAEPAXI@Z ; CvMapGenerator::`vftable'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmapgenerator.cpp
CONST	ENDS
;	COMDAT ??0CvMapGenerator@@QAE@PBD@Z
_TEXT	SEGMENT
tv72 = -20						; size = 4
_this$ = -16						; size = 4
$T216983 = -12						; size = 4
_bLoaded$ = -5						; size = 1
_pkScriptSystem$ = -4					; size = 4
_szMapScriptName$ = 8					; size = 4
??0CvMapGenerator@@QAE@PBD@Z PROC			; CvMapGenerator::CvMapGenerator, COMDAT
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvMapGenerator@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 34   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T216983[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv72[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 35   : 	m_pkLuaState = pkScriptSystem->CreateLuaThread("Map Script");

	push	OFFSET ??_C@_0L@PIJHIFGM@Map?5Script?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 36   : 	const bool bLoaded = pkScriptSystem->LoadFile(m_pkLuaState, szMapScriptName);

	mov	edx, DWORD PTR _szMapScriptName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	BYTE PTR _bLoaded$[ebp], al

; 37   : 	DEBUG_VARIABLE(bLoaded);
; 38   : 	CvAssertMsg(bLoaded, "Cannot load mapscript.");
; 39   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CvMapGenerator@@QAE@PBD@Z ENDP			; CvMapGenerator::CvMapGenerator
_TEXT	ENDS
PUBLIC	??1CvMapGenerator@@UAE@XZ			; CvMapGenerator::~CvMapGenerator
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvMapGenerator@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvMapGenerator@@UAEPAXI@Z PROC			; CvMapGenerator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvMapGenerator@@UAE@XZ		; CvMapGenerator::~CvMapGenerator
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvMapGenerator@@UAEPAXI@Z ENDP			; CvMapGenerator::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvMapGenerator@@UAE@XZ
_TEXT	SEGMENT
tv71 = -16						; size = 4
_this$ = -12						; size = 4
$T216991 = -8						; size = 4
_pkScriptSystem$ = -4					; size = 4
??1CvMapGenerator@@UAE@XZ PROC				; CvMapGenerator::~CvMapGenerator, COMDAT
; _this$ = ecx

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvMapGenerator@@6B@

; 43   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR $T216991[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR tv71[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 44   : 	pkScriptSystem->FreeLuaThread(m_pkLuaState);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvMapGenerator@@UAE@XZ ENDP				; CvMapGenerator::~CvMapGenerator
_TEXT	ENDS
PUBLIC	??1CvWorldInfo@@QAE@XZ				; CvWorldInfo::~CvWorldInfo
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetMapInitData
PUBLIC	??_C@_0CK@MKFNPDFK@SELECT?5?$CK?5from?5Worlds?5where?5ID?5?$DN?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z ; CvMapGenerator::GetMapInitData
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	?getGridWidth@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridWidth
EXTRN	?getGridHeight@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridHeight
EXTRN	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z:PROC ; CvBaseInfo::CacheResult
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHH@Z:PROC
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
EXTRN	??0CvWorldInfo@@QAE@XZ:PROC			; CvWorldInfo::CvWorldInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CK@MKFNPDFK@SELECT?5?$CK?5from?5Worlds?5where?5ID?5?$DN?5@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CK@MKFNPDFK@SELECT?5?$CK?5from?5Worlds?5where?5ID?5?$DN?5@ DB 'SEL'
	DB	'ECT * from Worlds where ID = ? LIMIT 1', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$1
__ehfuncinfo$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmapgenerator.cpp
xdata$x	ENDS
;	COMDAT ?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
_TEXT	SEGMENT
tv129 = -508						; size = 4
_this$ = -504						; size = 4
$T217008 = -464						; size = 4
$T217004 = -460						; size = 4
$T216995 = -453						; size = 1
_kQuery$ = -452						; size = 64
_pkScriptSystem$ = -384					; size = 4
_kWorldInfo$ = -380					; size = 340
__$ArrayPad$ = -36					; size = 4
_db$ = -32						; size = 4
_args$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_kData$ = 8						; size = 4
_eWorldSize$ = 12					; size = 4
?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z PROC ; CvMapGenerator::GetMapInitData, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 496				; 000001f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 	CvWorldInfo	kWorldInfo;

	lea	ecx, DWORD PTR _kWorldInfo$[ebp]
	call	??0CvWorldInfo@@QAE@XZ			; CvWorldInfo::CvWorldInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 50   : 	Database::Connection& db = *GC.GetGameDatabase();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR _db$[ebp], eax

; 51   : 
; 52   : 	//Query
; 53   : 	Database::Results kQuery;

	push	0
	lea	ecx, DWORD PTR _kQuery$[ebp]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 54   : 	db.Execute(kQuery, "SELECT * from Worlds where ID = ? LIMIT 1");

	push	-1
	push	OFFSET ??_C@_0CK@MKFNPDFK@SELECT?5?$CK?5from?5Worlds?5where?5ID?5?$DN?5@
	lea	ecx, DWORD PTR _kQuery$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _db$[ebp]
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z

; 55   : 	kQuery.Bind(1, eWorldSize);

	mov	edx, DWORD PTR _eWorldSize$[ebp]
	push	edx
	push	1
	lea	ecx, DWORD PTR _kQuery$[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHH@Z

; 56   : 
; 57   : 	if(kQuery.Step())

	lea	ecx, DWORD PTR _kQuery$[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetMapInit

; 58   : 	{
; 59   : 		kWorldInfo.CacheResult(kQuery);

	lea	ecx, DWORD PTR _kQuery$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _kWorldInfo$[ebp]
	call	?CacheResult@CvBaseInfo@@QAE_NAAVResults@Database@@@Z ; CvBaseInfo::CacheResult
$LN1@GetMapInit:

; 60   : 	}
; 61   : 	else
; 62   : 	{
; 63   : 		CvAssertMsg(false, "Could not find world size entry.")
; 64   : 	}
; 65   : 
; 66   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T217004[ebp]
	mov	DWORD PTR tv129[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR tv129[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv129[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 67   : 
; 68   : 	kData.m_iGridH = kWorldInfo.getGridHeight();

	lea	ecx, DWORD PTR _kWorldInfo$[ebp]
	call	?getGridHeight@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridHeight
	mov	ecx, DWORD PTR _kData$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 69   : 	kData.m_iGridW = kWorldInfo.getGridWidth();

	lea	ecx, DWORD PTR _kWorldInfo$[ebp]
	call	?getGridWidth@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridWidth
	mov	edx, DWORD PTR _kData$[ebp]
	mov	DWORD PTR [edx], eax

; 70   : 
; 71   : 	GetMapInitDataArgs args;
; 72   : 	args.pkScriptSystem = pkScriptSystem;

	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	mov	DWORD PTR _args$[ebp], eax

; 73   : 	args.pkMapInitData = &kData;

	mov	ecx, DWORD PTR _kData$[ebp]
	mov	DWORD PTR _args$[ebp+4], ecx

; 74   : 	args.WorldSize = kWorldInfo.GetID();

	mov	edx, DWORD PTR _kWorldInfo$[ebp+4]
	mov	DWORD PTR $T217008[ebp], edx
	mov	eax, DWORD PTR $T217008[ebp]
	mov	DWORD PTR _args$[ebp+8], eax

; 75   : 	args.bSuccess = false;

	mov	BYTE PTR _args$[ebp+12], 0

; 76   : 
; 77   : 	pkScriptSystem->CallCFunction(m_pkLuaState, pGetMapInitData, &args);

	lea	ecx, DWORD PTR _args$[ebp]
	push	ecx
	push	OFFSET ?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetMapInitData
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 78   : 	return args.bSuccess;

	mov	cl, BYTE PTR _args$[ebp+12]
	mov	BYTE PTR $T216995[ebp], cl
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _kQuery$[ebp]
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kWorldInfo$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	al, BYTE PTR $T216995[ebp]

; 79   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$0:
	lea	ecx, DWORD PTR _kWorldInfo$[ebp]
	jmp	??1CvWorldInfo@@QAE@XZ
__unwindfunclet$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z$1:
	lea	ecx, DWORD PTR _kQuery$[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-500]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMapInitData@CvMapGenerator@@QAE_NAAUCvMapInitData@@W4WorldSizeTypes@@@Z ENDP ; CvMapGenerator::GetMapInitData
; Function compile flags: /Odtp
;	COMDAT ??1CvWorldInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
??1CvWorldInfo@@QAE@XZ PROC				; CvWorldInfo::~CvWorldInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvWorldInfo@@QAE@XZ ENDP				; CvWorldInfo::~CvWorldInfo
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T217192 = -48						; size = 4
$T217187 = -44						; size = 4
$T217182 = -40						; size = 4
$T217177 = -36						; size = 4
$T217172 = -32						; size = 4
$T217167 = -28						; size = 4
$T217162 = -24						; size = 4
$T217157 = -20						; size = 4
$T217152 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T217152[ebp], eax
	mov	ecx, DWORD PTR $T217152[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T217157[ebp], ecx
	mov	ecx, DWORD PTR $T217157[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T217162[ebp], edx
	mov	ecx, DWORD PTR $T217162[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T217167[ebp], eax
	mov	ecx, DWORD PTR $T217167[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T217172[ebp], ecx
	mov	ecx, DWORD PTR $T217172[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T217177[ebp], edx
	mov	ecx, DWORD PTR $T217177[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T217182[ebp], eax
	mov	ecx, DWORD PTR $T217182[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T217187[ebp], ecx
	mov	ecx, DWORD PTR $T217187[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T217192[ebp], edx
	mov	ecx, DWORD PTR $T217192[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGenerateRandomMap
PUBLIC	?GenerateRandomMap@CvMapGenerator@@QAEXXZ	; CvMapGenerator::GenerateRandomMap
EXTRN	_lua_gc:PROC
; Function compile flags: /Odtp
;	COMDAT ?GenerateRandomMap@CvMapGenerator@@QAEXXZ
_TEXT	SEGMENT
tv71 = -16						; size = 4
_this$ = -12						; size = 4
$T217204 = -8						; size = 4
_pkScriptSystem$ = -4					; size = 4
?GenerateRandomMap@CvMapGenerator@@QAEXXZ PROC		; CvMapGenerator::GenerateRandomMap, COMDAT
; _this$ = ecx

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T217204[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 84   : 
; 85   : 	pkScriptSystem->CallCFunction(m_pkLuaState, pGenerateRandomMap, pkScriptSystem);

	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	push	eax
	push	OFFSET ?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGenerateRandomMap
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 86   : 
; 87   : 	lua_gc(m_pkLuaState, LUA_GCCOLLECT, 0);

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_lua_gc
	add	esp, 12					; 0000000cH

; 88   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GenerateRandomMap@CvMapGenerator@@QAEXXZ ENDP		; CvMapGenerator::GenerateRandomMap
_TEXT	ENDS
PUBLIC	?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetGameInitialItemsOverrides
PUBLIC	?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z ; CvMapGenerator::GetGameInitialItemsOverrides
; Function compile flags: /Odtp
;	COMDAT ?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z
_TEXT	SEGMENT
tv71 = -28						; size = 4
_this$ = -24						; size = 4
$T217210 = -20						; size = 4
_pkScriptSystem$ = -16					; size = 4
_args$ = -12						; size = 12
_kOverrides$ = 8					; size = 4
?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z PROC ; CvMapGenerator::GetGameInitialItemsOverrides, COMDAT
; _this$ = ecx

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T217210[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv71[ebp], ecx
	mov	edx, DWORD PTR tv71[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv71[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 93   : 
; 94   : 	GetGameInitialItemsOverridesArgs args;
; 95   : 	args.pkScriptSystem = pkScriptSystem;

	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	mov	DWORD PTR _args$[ebp], eax

; 96   : 	args.pkOverrides = &kOverrides;

	mov	ecx, DWORD PTR _kOverrides$[ebp]
	mov	DWORD PTR _args$[ebp+4], ecx

; 97   : 	args.bSuccess = false;

	mov	BYTE PTR _args$[ebp+8], 0

; 98   : 
; 99   : 	pkScriptSystem->CallCFunction(m_pkLuaState, pGetGameInitialItemsOverrides, &args);

	lea	edx, DWORD PTR _args$[ebp]
	push	edx
	push	OFFSET ?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z ; CvMapGenerator::pGetGameInitialItemsOverrides
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax+24]
	call	edx

; 100  : 	return args.bSuccess;

	mov	al, BYTE PTR _args$[ebp+8]

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetGameInitialItemsOverrides@CvMapGenerator@@QAE_NAAVCvGameInitialItemsOverrides@@@Z ENDP ; CvMapGenerator::GetGameInitialItemsOverrides
_TEXT	ENDS
PUBLIC	??_C@_0P@DOPAFMKP@BottomLatitude?$AA@		; `string'
PUBLIC	??_C@_0M@JKOOKPKG@TopLatitude?$AA@		; `string'
PUBLIC	??_C@_05GALGMLJH@WrapY?$AA@			; `string'
PUBLIC	??_C@_05HJKNPKNG@WrapX?$AA@			; `string'
PUBLIC	??_C@_06HCAKHJJK@Height?$AA@			; `string'
PUBLIC	??_C@_05IBAMDCFI@Width?$AA@			; `string'
PUBLIC	??_C@_0P@PKAALAOG@GetMapInitData?$AA@		; `string'
PUBLIC	??_C@_0CC@CLJOABAB@CvMapGenerator?5?9?5GetMapInitData?$CI@ ; `string'
EXTRN	??1cvStopWatch@@QAE@XZ:PROC			; cvStopWatch::~cvStopWatch
EXTRN	_lua_toboolean:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_tointeger:PROC
EXTRN	_lua_gettop:PROC
EXTRN	_lua_pushinteger:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
EXTRN	_lua_touserdata:PROC
EXTRN	??0cvStopWatch@@QAE@PBD0I_N1@Z:PROC		; cvStopWatch::cvStopWatch
;	COMDAT ??_C@_0P@DOPAFMKP@BottomLatitude?$AA@
CONST	SEGMENT
??_C@_0P@DOPAFMKP@BottomLatitude?$AA@ DB 'BottomLatitude', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JKOOKPKG@TopLatitude?$AA@
CONST	SEGMENT
??_C@_0M@JKOOKPKG@TopLatitude?$AA@ DB 'TopLatitude', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GALGMLJH@WrapY?$AA@
CONST	SEGMENT
??_C@_05GALGMLJH@WrapY?$AA@ DB 'WrapY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HJKNPKNG@WrapX?$AA@
CONST	SEGMENT
??_C@_05HJKNPKNG@WrapX?$AA@ DB 'WrapX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HCAKHJJK@Height?$AA@
CONST	SEGMENT
??_C@_06HCAKHJJK@Height?$AA@ DB 'Height', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IBAMDCFI@Width?$AA@
CONST	SEGMENT
??_C@_05IBAMDCFI@Width?$AA@ DB 'Width', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PKAALAOG@GetMapInitData?$AA@
CONST	SEGMENT
??_C@_0P@PKAALAOG@GetMapInitData?$AA@ DB 'GetMapInitData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CLJOABAB@CvMapGenerator?5?9?5GetMapInitData?$CI@
CONST	SEGMENT
??_C@_0CC@CLJOABAB@CvMapGenerator?5?9?5GetMapInitData?$CI@ DB 'CvMapGener'
	DB	'ator - GetMapInitData()', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T217213 = -68						; size = 4
_t$216800 = -64						; size = 4
_stopWatch$ = -60					; size = 40
_pArgs$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z PROC ; CvMapGenerator::pGetMapInitData, COMDAT

; 104  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 105  : 	cvStopWatch stopWatch("CvMapGenerator - GetMapInitData()");

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CC@CLJOABAB@CvMapGenerator?5?9?5GetMapInitData?$CI@
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	call	??0cvStopWatch@@QAE@PBD0I_N1@Z		; cvStopWatch::cvStopWatch
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 	GetMapInitDataArgs* pArgs = (GetMapInitDataArgs*)lua_touserdata(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pArgs$[ebp], eax

; 107  : 
; 108  : 	pArgs->bSuccess = false;

	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	BYTE PTR [ecx+12], 0

; 109  : 	lua_getglobal(L, "GetMapInitData");

	push	OFFSET ??_C@_0P@PKAALAOG@GetMapInitData?$AA@
	push	-10002					; ffffd8eeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 110  : 	if(lua_isfunction(L, -1))

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	cmp	eax, 6
	jne	$LN8@pGetMapIni

; 111  : 	{
; 112  : 		lua_pushinteger(L, pArgs->WorldSize);

	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 113  : 		pArgs->pkScriptSystem->CallFunction(L, 1, 1);

	push	1
	push	1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 114  : 		const int t = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _t$216800[ebp], eax

; 115  : 		if(lua_istable(L, t))

	mov	edx, DWORD PTR _t$216800[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	$LN8@pGetMapIni

; 116  : 		{
; 117  : 			lua_getfield(L, t, "Width");

	push	OFFSET ??_C@_05IBAMDCFI@Width?$AA@
	mov	ecx, DWORD PTR _t$216800[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 118  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN6@pGetMapIni

; 119  : 				pArgs->pkMapInitData->m_iGridW = lua_tointeger(L, -1);

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
$LN6@pGetMapIni:

; 120  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 121  : 
; 122  : 			lua_getfield(L, t, "Height");

	push	OFFSET ??_C@_06HCAKHJJK@Height?$AA@
	mov	eax, DWORD PTR _t$216800[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 123  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN5@pGetMapIni

; 124  : 				pArgs->pkMapInitData->m_iGridH = lua_tointeger(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN5@pGetMapIni:

; 125  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 126  : 
; 127  : 			lua_getfield(L, t, "WrapX");

	push	OFFSET ??_C@_05HJKNPKNG@WrapX?$AA@
	mov	ecx, DWORD PTR _t$216800[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 128  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN4@pGetMapIni

; 129  : 				pArgs->pkMapInitData->m_bWrapX = lua_toboolean(L, -1);

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	dl
	mov	eax, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+16], dl
$LN4@pGetMapIni:

; 130  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_settop
	add	esp, 8

; 131  : 
; 132  : 			lua_getfield(L, t, "WrapY");

	push	OFFSET ??_C@_05GALGMLJH@WrapY?$AA@
	mov	eax, DWORD PTR _t$216800[ebp]
	push	eax
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 133  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN3@pGetMapIni

; 134  : 				pArgs->pkMapInitData->m_bWrapY = lua_toboolean(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	cl
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+17], cl
$LN3@pGetMapIni:

; 135  : 
; 136  : 			lua_getfield(L, t, "TopLatitude");

	push	OFFSET ??_C@_0M@JKOOKPKG@TopLatitude?$AA@
	mov	ecx, DWORD PTR _t$216800[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 137  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN2@pGetMapIni

; 138  : 				pArgs->pkMapInitData->m_iTopLatitude = lua_tointeger(L, -1);

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_tointeger
	add	esp, 8
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN2@pGetMapIni:

; 139  : 
; 140  : 			lua_getfield(L, t, "BottomLatitude");

	push	OFFSET ??_C@_0P@DOPAFMKP@BottomLatitude?$AA@
	mov	edx, DWORD PTR _t$216800[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 141  : 			if(!lua_isnoneornil(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN1@pGetMapIni

; 142  : 				pArgs->pkMapInitData->m_iBottomLatitude = lua_tointeger(L, -1);

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+12], eax
$LN1@pGetMapIni:

; 143  : 
; 144  : 			pArgs->bSuccess = true;

	mov	eax, DWORD PTR _pArgs$[ebp]
	mov	BYTE PTR [eax+12], 1
$LN8@pGetMapIni:

; 145  : 		}
; 146  : 	}
; 147  : 
; 148  : 	return 0;

	mov	DWORD PTR $T217213[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	call	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
	mov	eax, DWORD PTR $T217213[ebp]

; 149  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	jmp	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
__ehhandler$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pGetMapInitData@CvMapGenerator@@KAHPAUlua_State@@@Z ENDP ; CvMapGenerator::pGetMapInitData
PUBLIC	??_C@_0BL@FLNGLDGI@GrantInitialUnitsPerPlayer?$AA@ ; `string'
PUBLIC	??_C@_0BM@HNDJKCDJ@ClearResearchQueuePerPlayer?$AA@ ; `string'
PUBLIC	??_C@_0BN@POBJDMPB@GrantInitialCulturePerPlayer?$AA@ ; `string'
PUBLIC	??_C@_0BK@DKKDHIGM@GrantInitialGoldPerPlayer?$AA@ ; `string'
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC	??_C@_0BN@OBCLLCKM@GrantInitialFreeTechsPerTeam?$AA@ ; `string'
PUBLIC	??_C@_0BN@IIPMKMKH@GetGameInitialItemsOverrides?$AA@ ; `string'
PUBLIC	??_C@_0DA@LKMPMLEP@CvMapGenerator?5?9?5GetGameInitialI@ ; `string'
EXTRN	_lua_isnumber:PROC
EXTRN	_lua_next:PROC
EXTRN	_lua_pushnil:PROC
;	COMDAT ??_C@_0BL@FLNGLDGI@GrantInitialUnitsPerPlayer?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
CONST	SEGMENT
??_C@_0BL@FLNGLDGI@GrantInitialUnitsPerPlayer?$AA@ DB 'GrantInitialUnitsP'
	DB	'erPlayer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HNDJKCDJ@ClearResearchQueuePerPlayer?$AA@
CONST	SEGMENT
??_C@_0BM@HNDJKCDJ@ClearResearchQueuePerPlayer?$AA@ DB 'ClearResearchQueu'
	DB	'ePerPlayer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@POBJDMPB@GrantInitialCulturePerPlayer?$AA@
CONST	SEGMENT
??_C@_0BN@POBJDMPB@GrantInitialCulturePerPlayer?$AA@ DB 'GrantInitialCult'
	DB	'urePerPlayer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DKKDHIGM@GrantInitialGoldPerPlayer?$AA@
CONST	SEGMENT
??_C@_0BK@DKKDHIGM@GrantInitialGoldPerPlayer?$AA@ DB 'GrantInitialGoldPer'
	DB	'Player', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OBCLLCKM@GrantInitialFreeTechsPerTeam?$AA@
CONST	SEGMENT
??_C@_0BN@OBCLLCKM@GrantInitialFreeTechsPerTeam?$AA@ DB 'GrantInitialFree'
	DB	'TechsPerTeam', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIPMKMKH@GetGameInitialItemsOverrides?$AA@
CONST	SEGMENT
??_C@_0BN@IIPMKMKH@GetGameInitialItemsOverrides?$AA@ DB 'GetGameInitialIt'
	DB	'emsOverrides', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@LKMPMLEP@CvMapGenerator?5?9?5GetGameInitialI@
CONST	SEGMENT
??_C@_0DA@LKMPMLEP@CvMapGenerator?5?9?5GetGameInitialI@ DB 'CvMapGenerato'
	DB	'r - GetGameInitialItemsOverrides()', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmapgenerator.cpp
xdata$x	ENDS
;	COMDAT ?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
tv705 = -464						; size = 4
tv655 = -460						; size = 4
tv606 = -456						; size = 4
tv593 = -452						; size = 4
tv544 = -448						; size = 4
tv531 = -444						; size = 4
tv482 = -440						; size = 4
tv469 = -436						; size = 4
tv420 = -432						; size = 4
tv375 = -428						; size = 4
$T217760 = -424						; size = 4
$T217744 = -420						; size = 4
$T217737 = -416						; size = 4
$T217653 = -368						; size = 4
$T217637 = -364						; size = 4
$T217630 = -360						; size = 4
$T217547 = -312						; size = 4
$T217531 = -308						; size = 4
$T217524 = -304						; size = 4
$T217441 = -256						; size = 4
$T217425 = -252						; size = 4
$T217418 = -248						; size = 4
$T217335 = -200						; size = 4
$T217319 = -196						; size = 4
$T217312 = -192						; size = 4
$T217228 = -144						; size = 4
$T217227 = -140						; size = 8
$T217226 = -132						; size = 8
$T217225 = -124						; size = 8
$T217224 = -116						; size = 8
$T217223 = -108						; size = 8
_ePlayer$216876 = -100					; size = 4
_bOverride$216878 = -93					; size = 1
_ePlayer$216865 = -92					; size = 4
_bOverride$216867 = -85					; size = 1
_ePlayer$216854 = -84					; size = 4
_bOverride$216856 = -77					; size = 1
_ePlayer$216843 = -76					; size = 4
_bOverride$216845 = -70					; size = 1
_bOverride$216834 = -69					; size = 1
_eTeam$216832 = -68					; size = 4
_t$216824 = -64						; size = 4
_stopWatch$ = -60					; size = 40
_pArgs$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z PROC ; CvMapGenerator::pGetGameInitialItemsOverrides, COMDAT

; 152  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 452				; 000001c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 153  : 	cvStopWatch stopWatch("CvMapGenerator - GetGameInitialItemsOverrides()");

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0DA@LKMPMLEP@CvMapGenerator?5?9?5GetGameInitialI@
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	call	??0cvStopWatch@@QAE@PBD0I_N1@Z		; cvStopWatch::cvStopWatch
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 154  : 	GetGameInitialItemsOverridesArgs* pArgs = (GetGameInitialItemsOverridesArgs*)lua_touserdata(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pArgs$[ebp], eax

; 155  : 
; 156  : 	pArgs->bSuccess = false;

	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	BYTE PTR [ecx+8], 0

; 157  : 	lua_getglobal(L, "GetGameInitialItemsOverrides");

	push	OFFSET ??_C@_0BN@IIPMKMKH@GetGameInitialItemsOverrides?$AA@
	push	-10002					; ffffd8eeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 158  : 	if(lua_isfunction(L, -1))

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	cmp	eax, 6
	jne	$LN27@pGetGameIn

; 159  : 	{
; 160  : 		pArgs->pkScriptSystem->CallFunction(L, 0, 1);

	push	1
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+28]
	call	eax

; 161  : 		const int t = lua_gettop(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_gettop
	add	esp, 4
	mov	DWORD PTR _t$216824[ebp], eax

; 162  : 		if(lua_istable(L, t))

	mov	edx, DWORD PTR _t$216824[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	$LN27@pGetGameIn

; 163  : 		{
; 164  : 
; 165  : 			//Initial Free Techs per Team
; 166  : 			lua_getfield(L, t, "GrantInitialFreeTechsPerTeam");

	push	OFFSET ??_C@_0BN@OBCLLCKM@GrantInitialFreeTechsPerTeam?$AA@
	mov	ecx, DWORD PTR _t$216824[ebp]
	push	ecx
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 167  : 			if(lua_istable(L, -1))

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	$LN25@pGetGameIn

; 168  : 			{
; 169  : 				lua_pushnil(L);  /* first key */

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_pushnil
	add	esp, 4
$LN24@pGetGameIn:

; 170  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_next
	add	esp, 8
	test	eax, eax
	je	$LN25@pGetGameIn

; 171  : 				{
; 172  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	$LN22@pGetGameIn
	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	$LN22@pGetGameIn

; 173  : 					{
; 174  : 						const TeamTypes eTeam = static_cast<TeamTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _eTeam$216832[ebp], eax

; 175  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	cl
	mov	BYTE PTR _bOverride$216834[ebp], cl

; 176  : 						if(eTeam >= 0 && eTeam < MAX_TEAMS)

	cmp	DWORD PTR _eTeam$216832[ebp], 0
	jl	$LN22@pGetGameIn
	cmp	DWORD PTR _eTeam$216832[ebp], 64	; 00000040H
	jge	$LN22@pGetGameIn

; 177  : 						{
; 178  : 							pArgs->pkOverrides->GrantInitialFreeTechsPerTeam[eTeam] = bOverride;

	mov	edx, DWORD PTR _eTeam$216832[ebp]
	push	edx
	lea	eax, DWORD PTR $T217223[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T217335[ebp], eax
	movzx	edx, BYTE PTR _bOverride$216834[ebp]
	test	edx, edx
	je	SHORT $LN58@pGetGameIn
	mov	eax, DWORD PTR $T217312[ebp]
	mov	DWORD PTR tv375[ebp], eax
	mov	ecx, DWORD PTR $T217335[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv375[ebp], edx
	mov	eax, DWORD PTR $T217335[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv375[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv375[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN22@pGetGameIn
$LN58@pGetGameIn:
	mov	edx, DWORD PTR $T217319[ebp]
	mov	DWORD PTR tv420[ebp], edx
	mov	eax, DWORD PTR $T217335[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv420[ebp], ecx
	mov	edx, DWORD PTR $T217335[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv420[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv420[ebp]
	mov	DWORD PTR [edx], eax
$LN22@pGetGameIn:

; 179  : 						}
; 180  : 					}
; 181  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 182  : 				}

	jmp	$LN24@pGetGameIn
$LN25@pGetGameIn:

; 183  : 			}
; 184  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_settop
	add	esp, 8

; 185  : 
; 186  : 			//Initial Gold per Player
; 187  : 			lua_getfield(L, t, "GrantInitialGoldPerPlayer");

	push	OFFSET ??_C@_0BK@DKKDHIGM@GrantInitialGoldPerPlayer?$AA@
	mov	edx, DWORD PTR _t$216824[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 188  : 			if(lua_istable(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	$LN20@pGetGameIn

; 189  : 			{
; 190  : 				lua_pushnil(L);  /* first key */

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN19@pGetGameIn:

; 191  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_next
	add	esp, 8
	test	eax, eax
	je	$LN20@pGetGameIn

; 192  : 				{
; 193  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	$LN17@pGetGameIn
	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	$LN17@pGetGameIn

; 194  : 					{
; 195  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$216843[ebp], eax

; 196  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bOverride$216845[ebp], dl

; 197  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	DWORD PTR _ePlayer$216843[ebp], 0
	jl	$LN17@pGetGameIn
	cmp	DWORD PTR _ePlayer$216843[ebp], 64	; 00000040H
	jge	$LN17@pGetGameIn

; 198  : 						{
; 199  : 							pArgs->pkOverrides->GrantInitialGoldPerPlayer[ePlayer] = bOverride;

	mov	eax, DWORD PTR _ePlayer$216843[ebp]
	push	eax
	lea	ecx, DWORD PTR $T217224[ebp]
	push	ecx
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 20					; 00000014H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T217441[ebp], eax
	movzx	eax, BYTE PTR _bOverride$216845[ebp]
	test	eax, eax
	je	SHORT $LN96@pGetGameIn
	mov	ecx, DWORD PTR $T217418[ebp]
	mov	DWORD PTR tv469[ebp], ecx
	mov	edx, DWORD PTR $T217441[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv469[ebp], eax
	mov	ecx, DWORD PTR $T217441[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv469[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv469[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN17@pGetGameIn
$LN96@pGetGameIn:
	mov	edx, DWORD PTR $T217425[ebp]
	mov	DWORD PTR tv482[ebp], edx
	mov	eax, DWORD PTR $T217441[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv482[ebp], ecx
	mov	edx, DWORD PTR $T217441[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv482[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv482[ebp]
	mov	DWORD PTR [edx], eax
$LN17@pGetGameIn:

; 200  : 						}
; 201  : 					}
; 202  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 203  : 				}

	jmp	$LN19@pGetGameIn
$LN20@pGetGameIn:

; 204  : 			}
; 205  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_settop
	add	esp, 8

; 206  : 
; 207  : 			//Initial Culture per Player
; 208  : 			lua_getfield(L, t, "GrantInitialCulturePerPlayer");

	push	OFFSET ??_C@_0BN@POBJDMPB@GrantInitialCulturePerPlayer?$AA@
	mov	edx, DWORD PTR _t$216824[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 209  : 			if(lua_istable(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	$LN15@pGetGameIn

; 210  : 			{
; 211  : 				lua_pushnil(L);  /* first key */

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN14@pGetGameIn:

; 212  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_next
	add	esp, 8
	test	eax, eax
	je	$LN15@pGetGameIn

; 213  : 				{
; 214  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	$LN12@pGetGameIn
	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	$LN12@pGetGameIn

; 215  : 					{
; 216  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$216854[ebp], eax

; 217  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bOverride$216856[ebp], dl

; 218  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	DWORD PTR _ePlayer$216854[ebp], 0
	jl	$LN12@pGetGameIn
	cmp	DWORD PTR _ePlayer$216854[ebp], 64	; 00000040H
	jge	$LN12@pGetGameIn

; 219  : 						{
; 220  : 							pArgs->pkOverrides->GrantInitialCulturePerPlayer[ePlayer] = bOverride;

	mov	eax, DWORD PTR _ePlayer$216854[ebp]
	push	eax
	lea	ecx, DWORD PTR $T217225[ebp]
	push	ecx
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 40					; 00000028H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T217547[ebp], eax
	movzx	eax, BYTE PTR _bOverride$216856[ebp]
	test	eax, eax
	je	SHORT $LN134@pGetGameIn
	mov	ecx, DWORD PTR $T217524[ebp]
	mov	DWORD PTR tv531[ebp], ecx
	mov	edx, DWORD PTR $T217547[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv531[ebp], eax
	mov	ecx, DWORD PTR $T217547[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv531[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv531[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN12@pGetGameIn
$LN134@pGetGameIn:
	mov	edx, DWORD PTR $T217531[ebp]
	mov	DWORD PTR tv544[ebp], edx
	mov	eax, DWORD PTR $T217547[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv544[ebp], ecx
	mov	edx, DWORD PTR $T217547[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv544[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv544[ebp]
	mov	DWORD PTR [edx], eax
$LN12@pGetGameIn:

; 221  : 						}
; 222  : 					}
; 223  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 224  : 				}

	jmp	$LN14@pGetGameIn
$LN15@pGetGameIn:

; 225  : 			}
; 226  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_settop
	add	esp, 8

; 227  : 
; 228  : 			//Clear research queue per Player
; 229  : 			lua_getfield(L, t, "ClearResearchQueuePerPlayer");

	push	OFFSET ??_C@_0BM@HNDJKCDJ@ClearResearchQueuePerPlayer?$AA@
	mov	edx, DWORD PTR _t$216824[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 230  : 			if(lua_istable(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	$LN10@pGetGameIn

; 231  : 			{
; 232  : 				lua_pushnil(L);  /* first key */

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN9@pGetGameIn:

; 233  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_next
	add	esp, 8
	test	eax, eax
	je	$LN10@pGetGameIn

; 234  : 				{
; 235  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	$LN7@pGetGameIn
	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	$LN7@pGetGameIn

; 236  : 					{
; 237  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$216865[ebp], eax

; 238  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bOverride$216867[ebp], dl

; 239  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	DWORD PTR _ePlayer$216865[ebp], 0
	jl	$LN7@pGetGameIn
	cmp	DWORD PTR _ePlayer$216865[ebp], 64	; 00000040H
	jge	$LN7@pGetGameIn

; 240  : 						{
; 241  : 							pArgs->pkOverrides->ClearResearchQueuePerPlayer[ePlayer] = bOverride;

	mov	eax, DWORD PTR _ePlayer$216865[ebp]
	push	eax
	lea	ecx, DWORD PTR $T217226[ebp]
	push	ecx
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T217653[ebp], eax
	movzx	eax, BYTE PTR _bOverride$216867[ebp]
	test	eax, eax
	je	SHORT $LN172@pGetGameIn
	mov	ecx, DWORD PTR $T217630[ebp]
	mov	DWORD PTR tv593[ebp], ecx
	mov	edx, DWORD PTR $T217653[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv593[ebp], eax
	mov	ecx, DWORD PTR $T217653[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv593[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv593[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN7@pGetGameIn
$LN172@pGetGameIn:
	mov	edx, DWORD PTR $T217637[ebp]
	mov	DWORD PTR tv606[ebp], edx
	mov	eax, DWORD PTR $T217653[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv606[ebp], ecx
	mov	edx, DWORD PTR $T217653[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv606[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv606[ebp]
	mov	DWORD PTR [edx], eax
$LN7@pGetGameIn:

; 242  : 						}
; 243  : 					}
; 244  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 245  : 				}

	jmp	$LN9@pGetGameIn
$LN10@pGetGameIn:

; 246  : 			}
; 247  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_settop
	add	esp, 8

; 248  : 
; 249  : 			//Initial Units per Player
; 250  : 			lua_getfield(L, t, "GrantInitialUnitsPerPlayer");

	push	OFFSET ??_C@_0BL@FLNGLDGI@GrantInitialUnitsPerPlayer?$AA@
	mov	edx, DWORD PTR _t$216824[ebp]
	push	edx
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 251  : 			if(lua_istable(L, -1))

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_type
	add	esp, 8
	cmp	eax, 5
	jne	$LN5@pGetGameIn

; 252  : 			{
; 253  : 				lua_pushnil(L);  /* first key */

	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_pushnil
	add	esp, 4
$LN4@pGetGameIn:

; 254  : 				while(lua_next(L, -2) != 0)

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_next
	add	esp, 8
	test	eax, eax
	je	$LN5@pGetGameIn

; 255  : 				{
; 256  : 					if(lua_isnumber(L, -2) && lua_isboolean(L, -1))

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_isnumber
	add	esp, 8
	test	eax, eax
	je	$LN2@pGetGameIn
	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	cmp	eax, 1
	jne	$LN2@pGetGameIn

; 257  : 					{
; 258  : 						const PlayerTypes ePlayer = static_cast<PlayerTypes>(lua_tointeger(L, -2));

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_tointeger
	add	esp, 8
	mov	DWORD PTR _ePlayer$216876[ebp], eax

; 259  : 						const bool bOverride = lua_toboolean(L, -1);

	push	-1
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	dl
	mov	BYTE PTR _bOverride$216878[ebp], dl

; 260  : 						if(ePlayer >= 0 && ePlayer < MAX_PLAYERS)

	cmp	DWORD PTR _ePlayer$216876[ebp], 0
	jl	$LN2@pGetGameIn
	cmp	DWORD PTR _ePlayer$216876[ebp], 64	; 00000040H
	jge	$LN2@pGetGameIn

; 261  : 						{
; 262  : 							pArgs->pkOverrides->GrantInitialUnitsPerPlayer[ePlayer] = bOverride;

	mov	eax, DWORD PTR _ePlayer$216876[ebp]
	push	eax
	lea	ecx, DWORD PTR $T217227[ebp]
	push	ecx
	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 80					; 00000050H
	call	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
	mov	DWORD PTR $T217760[ebp], eax
	movzx	eax, BYTE PTR _bOverride$216878[ebp]
	test	eax, eax
	je	SHORT $LN217@pGetGameIn
	mov	ecx, DWORD PTR $T217737[ebp]
	mov	DWORD PTR tv655[ebp], ecx
	mov	edx, DWORD PTR $T217760[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv655[ebp], eax
	mov	ecx, DWORD PTR $T217760[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [ecx+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv655[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv655[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN2@pGetGameIn
$LN217@pGetGameIn:
	mov	edx, DWORD PTR $T217744[ebp]
	mov	DWORD PTR tv705[ebp], edx
	mov	eax, DWORD PTR $T217760[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv705[ebp], ecx
	mov	edx, DWORD PTR $T217760[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv705[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv705[ebp]
	mov	DWORD PTR [edx], eax
$LN2@pGetGameIn:

; 263  : 						}
; 264  : 					}
; 265  : 					lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_settop
	add	esp, 8

; 266  : 				}

	jmp	$LN4@pGetGameIn
$LN5@pGetGameIn:

; 267  : 			}
; 268  : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_settop
	add	esp, 8

; 269  : 			pArgs->bSuccess = true;

	mov	edx, DWORD PTR _pArgs$[ebp]
	mov	BYTE PTR [edx+8], 1
$LN27@pGetGameIn:

; 270  : 		}
; 271  : 	}
; 272  : 
; 273  : 	return 0;

	mov	DWORD PTR $T217228[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	call	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
	mov	eax, DWORD PTR $T217228[ebp]

; 274  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	jmp	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
__ehhandler$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-456]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pGetGameInitialItemsOverrides@CvMapGenerator@@KAHPAUlua_State@@@Z ENDP ; CvMapGenerator::pGetGameInitialItemsOverrides
PUBLIC	??_C@_0DB@HJLIMLJD@Cannot?5find?5map?5script?5entry?5poi@ ; `string'
PUBLIC	??_C@_0M@DFAJJDOK@GenerateMap?$AA@		; `string'
PUBLIC	??_C@_0CF@FFHGIKPI@CvMapGenerator?5?9?5GenerateRandomM@ ; `string'
EXTRN	_luaL_error:PROC
;	COMDAT ??_C@_0DB@HJLIMLJD@Cannot?5find?5map?5script?5entry?5poi@
CONST	SEGMENT
??_C@_0DB@HJLIMLJD@Cannot?5find?5map?5script?5entry?5poi@ DB 'Cannot find'
	DB	' map script entry point GenerateMap()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DFAJJDOK@GenerateMap?$AA@
CONST	SEGMENT
??_C@_0M@DFAJJDOK@GenerateMap?$AA@ DB 'GenerateMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FFHGIKPI@CvMapGenerator?5?9?5GenerateRandomM@
CONST	SEGMENT
??_C@_0CF@FFHGIKPI@CvMapGenerator?5?9?5GenerateRandomM@ DB 'CvMapGenerato'
	DB	'r - GenerateRandomMap()', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z$0
__ehfuncinfo$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
$T217769 = -64						; size = 4
_stopWatch$ = -60					; size = 40
_pkScriptSystem$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_L$ = 8							; size = 4
?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z PROC ; CvMapGenerator::pGenerateRandomMap, COMDAT

; 277  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 278  : 	cvStopWatch stopWatch("CvMapGenerator - GenerateRandomMap()");

	push	0
	push	0
	push	0
	push	0
	push	OFFSET ??_C@_0CF@FFHGIKPI@CvMapGenerator?5?9?5GenerateRandomM@
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	call	??0cvStopWatch@@QAE@PBD0I_N1@Z		; cvStopWatch::cvStopWatch
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 279  : 	ICvEngineScriptSystem1* pkScriptSystem = (ICvEngineScriptSystem1*)lua_touserdata(L, 1);

	push	1
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_lua_touserdata
	add	esp, 8
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 280  : 
; 281  : 	lua_getglobal(L, "GenerateMap");

	push	OFFSET ??_C@_0M@DFAJJDOK@GenerateMap?$AA@
	push	-10002					; ffffd8eeH
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_lua_getfield
	add	esp, 12					; 0000000cH

; 282  : 	if(lua_isnil(L, -1))

	push	-1
	mov	edx, DWORD PTR _L$[ebp]
	push	edx
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@pGenerateR

; 283  : 		luaL_error(L, "Cannot find map script entry point GenerateMap()");

	push	OFFSET ??_C@_0DB@HJLIMLJD@Cannot?5find?5map?5script?5entry?5poi@
	mov	eax, DWORD PTR _L$[ebp]
	push	eax
	call	_luaL_error
	add	esp, 8
$LN1@pGenerateR:

; 284  : 
; 285  : 	pkScriptSystem->CallFunction(L, 0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	mov	edx, DWORD PTR [eax+28]
	call	edx

; 286  : 
; 287  : 	return 0;

	mov	DWORD PTR $T217769[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	call	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
	mov	eax, DWORD PTR $T217769[ebp]

; 288  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z$0:
	lea	ecx, DWORD PTR _stopWatch$[ebp]
	jmp	??1cvStopWatch@@QAE@XZ			; cvStopWatch::~cvStopWatch
__ehhandler$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?pGenerateRandomMap@CvMapGenerator@@KAHPAUlua_State@@@Z ENDP ; CvMapGenerator::pGenerateRandomMap
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T217846 = -44						; size = 4
$T217845 = -40						; size = 4
__Tmp$217836 = -36					; size = 8
$T217814 = -28						; size = 4
$T217792 = -24						; size = 4
$T217817 = -20						; size = 4
$T217780 = -16						; size = 8
$T217779 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2090 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2091 : 		return (*(begin() + _Off));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T217792[ebp], ecx
	mov	edx, DWORD PTR $T217792[ebp]
	mov	DWORD PTR $T217817[ebp], edx
	mov	eax, DWORD PTR $T217817[ebp]
	mov	DWORD PTR $T217814[ebp], eax
	mov	ecx, DWORD PTR $T217814[ebp]
	mov	DWORD PTR $T217779[ebp], ecx
	mov	DWORD PTR $T217779[ebp+4], 0
	mov	edx, DWORD PTR $T217779[ebp]
	mov	eax, DWORD PTR $T217779[ebp+4]
	mov	DWORD PTR __Tmp$217836[ebp], edx
	mov	DWORD PTR __Tmp$217836[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$217836[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$217836[ebp]
	mov	eax, DWORD PTR __Tmp$217836[ebp+4]
	mov	DWORD PTR $T217780[ebp], edx
	mov	DWORD PTR $T217780[ebp+4], eax
	mov	ecx, DWORD PTR $T217780[ebp+4]
	mov	DWORD PTR $T217846[ebp], ecx
	mov	edx, DWORD PTR $T217780[ebp]
	mov	DWORD PTR $T217845[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T217845[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T217846[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2092 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1603 : 		if (_Off == 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jne	SHORT $LN3@operator

; 1604 : 			return (*this); // early out

	mov	eax, DWORD PTR _this$[ebp]
	jmp	$LN6@operator
$LN3@operator:

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	cmp	DWORD PTR __Off$[ebp], 0
	jge	SHORT $LN2@operator
	xor	eax, eax
	sub	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jae	SHORT $LN2@operator

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	or	eax, -1
	sub	eax, DWORD PTR [edx+4]
	shr	eax, 5
	lea	ecx, DWORD PTR [eax*4+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1618 : 			this->_Myoff %= _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1619 : 			}
; 1620 : 		else

	jmp	SHORT $LN1@operator
$LN2@operator:

; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN1@operator:

; 1625 : 			}
; 1626 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@operator:

; 1627 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
END
