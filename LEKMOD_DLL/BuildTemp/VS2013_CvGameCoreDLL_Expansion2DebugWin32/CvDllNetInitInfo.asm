; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDllNetInitInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05OCFELOIJ@1?40?40?$AA@			; `string'
CONST	SEGMENT
_guidICvUnknown DD 0d89ba82fH
	DW	09fa3H
	DW	04696H
	DB	0b3H
	DB	0f4H
	DB	052H
	DB	0bdH
	DB	0b1H
	DB	01H
	DB	0cfH
	DB	0b2H
_guidICvNetInitInfo1 DD 07917c933H
	DW	02edcH
	DW	049afH
	DB	0b7H
	DB	0f3H
	DB	0c0H
	DB	065H
	DB	0cbH
	DB	0b5H
	DB	0ebH
	DB	02cH
CONST	ENDS
_DATA	SEGMENT
_CIV5_XP2_DLL_VERSION DD FLAT:??_C@_05OCFELOIJ@1?40?40?$AA@
_DATA	ENDS
;	COMDAT ??_C@_05OCFELOIJ@1?40?40?$AA@
CONST	SEGMENT
??_C@_05OCFELOIJ@1?40?40?$AA@ DB '1.0.0', 00H		; `string'
CONST	ENDS
PUBLIC	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=
PUBLIC	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
PUBLIC	??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??_7CvDllNetInitInfo@@6B@			; CvDllNetInitInfo::`vftable'
PUBLIC	??_7ICvNetInitInfo1@@6B@			; ICvNetInitInfo1::`vftable'
PUBLIC	??_7ICvUnknown@@6B@				; ICvUnknown::`vftable'
PUBLIC	??0CvDllNetInitInfo@@QAE@XZ			; CvDllNetInitInfo::CvDllNetInitInfo
PUBLIC	?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z ; CvDllNetInitInfo::QueryInterface
PUBLIC	?Destroy@CvDllNetInitInfo@@EAGXXZ		; CvDllNetInitInfo::Destroy
PUBLIC	?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ	; CvDllNetInitInfo::GetDebugString
PUBLIC	?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z	; CvDllNetInitInfo::Read
PUBLIC	?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z ; CvDllNetInitInfo::Write
PUBLIC	?Commit@CvDllNetInitInfo@@UAG_NXZ		; CvDllNetInitInfo::Commit
EXTRN	?gameMode@CvPreGame@@YA?AW4GameMode@@XZ:PROC	; CvPreGame::gameMode
EXTRN	?advancedStartPoints@CvPreGame@@YAHXZ:PROC	; CvPreGame::advancedStartPoints
EXTRN	?numMinorCivs@CvPreGame@@YAHXZ:PROC		; CvPreGame::numMinorCivs
EXTRN	?maxCityElimination@CvPreGame@@YAHXZ:PROC	; CvPreGame::maxCityElimination
EXTRN	?maxTurns@CvPreGame@@YAHXZ:PROC			; CvPreGame::maxTurns
EXTRN	?multiplayerOptions@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ:PROC ; CvPreGame::multiplayerOptions
EXTRN	?GetMapOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ:PROC ; CvPreGame::GetMapOptions
EXTRN	?GetGameOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ:PROC ; CvPreGame::GetGameOptions
EXTRN	?victories@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ:PROC ; CvPreGame::victories
EXTRN	?mapRandomSeed@CvPreGame@@YAIXZ:PROC		; CvPreGame::mapRandomSeed
EXTRN	?syncRandomSeed@CvPreGame@@YAIXZ:PROC		; CvPreGame::syncRandomSeed
EXTRN	?gameName@CvPreGame@@YAABVCvString@@XZ:PROC	; CvPreGame::gameName
EXTRN	?pitBossTurnTime@CvPreGame@@YAHXZ:PROC		; CvPreGame::pitBossTurnTime
EXTRN	?turnTimer@CvPreGame@@YA?AW4TurnTimerTypes@@XZ:PROC ; CvPreGame::turnTimer
EXTRN	?gameSpeed@CvPreGame@@YA?AW4GameSpeedTypes@@XZ:PROC ; CvPreGame::gameSpeed
EXTRN	?gameStarted@CvPreGame@@YA_NXZ:PROC		; CvPreGame::gameStarted
EXTRN	?gameTurn@CvPreGame@@YAHXZ:PROC			; CvPreGame::gameTurn
EXTRN	?calendar@CvPreGame@@YA?AW4CalendarTypes@@XZ:PROC ; CvPreGame::calendar
EXTRN	?era@CvPreGame@@YA?AW4EraTypes@@XZ:PROC		; CvPreGame::era
EXTRN	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ:PROC ; CvPreGame::seaLevel
EXTRN	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ:PROC	; CvPreGame::climate
EXTRN	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ:PROC ; CvPreGame::worldSize
EXTRN	?mapNoPlayers@CvPreGame@@YA_NXZ:PROC		; CvPreGame::mapNoPlayers
EXTRN	?randomWorldSize@CvPreGame@@YA_NXZ:PROC		; CvPreGame::randomWorldSize
EXTRN	?randomMapScript@CvPreGame@@YA_NXZ:PROC		; CvPreGame::randomMapScript
EXTRN	?mapScriptName@CvPreGame@@YAABVCvString@@XZ:PROC ; CvPreGame::mapScriptName
EXTRN	?loadFileStorage@CvPreGame@@YA?AW4StorageLocation@@XZ:PROC ; CvPreGame::loadFileStorage
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?loadFileName@CvPreGame@@YAABVCvString@@XZ:PROC	; CvPreGame::loadFileName
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	__purecall:PROC
;	COMDAT ??_7CvDllNetInitInfo@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_7CvDllNetInitInfo@@6B@ DD FLAT:?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z ; CvDllNetInitInfo::`vftable'
	DD	FLAT:?Destroy@CvDllNetInitInfo@@EAGXXZ
	DD	FLAT:?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ
	DD	FLAT:?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
	DD	FLAT:?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
	DD	FLAT:?Commit@CvDllNetInitInfo@@UAG_NXZ
CONST	ENDS
;	COMDAT ??_7ICvNetInitInfo1@@6B@
CONST	SEGMENT
??_7ICvNetInitInfo1@@6B@ DD FLAT:__purecall		; ICvNetInitInfo1::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7ICvUnknown@@6B@
CONST	SEGMENT
??_7ICvUnknown@@6B@ DD FLAT:__purecall			; ICvUnknown::`vftable'
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CvDllNetInitInfo@@QAE@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??0CvDllNetInitInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvDllNetInitInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$10
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$3
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$4
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$5
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$14
	DD	06H
	DD	FLAT:__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
xdata$x	ENDS
;	COMDAT ??0CvDllNetInitInfo@@QAE@XZ
_TEXT	SEGMENT
tv353 = -124						; size = 4
tv301 = -120						; size = 4
_this$ = -116						; size = 4
$T219731 = -112						; size = 4
$T219730 = -108						; size = 4
$T219721 = -104						; size = 4
$T219720 = -100						; size = 4
$T219711 = -96						; size = 4
$T219710 = -92						; size = 4
$T219706 = -88						; size = 4
$T219705 = -84						; size = 4
$T219701 = -80						; size = 4
$T219700 = -76						; size = 4
$T219696 = -72						; size = 4
$T219688 = -65						; size = 1
$T219684 = -64						; size = 4
$T219662 = -40						; size = 4
$T219654 = -33						; size = 1
$T219650 = -32						; size = 4
$T219642 = -24						; size = 4
$T219637 = -20						; size = 4
$T219632 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvDllNetInitInfo@@QAE@XZ PROC			; CvDllNetInitInfo::CvDllNetInitInfo, COMDAT
; _this$ = ecx

; 15   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvDllNetInitInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ICvUnknown@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ICvNetInitInfo1@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7CvDllNetInitInfo@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T219632[ebp], eax
	mov	ecx, DWORD PTR $T219632[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T219637[ebp], ecx
	mov	ecx, DWORD PTR $T219637[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 108				; 0000006cH
	mov	DWORD PTR $T219642[ebp], edx
	mov	ecx, DWORD PTR $T219642[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T219662[ebp], eax
	lea	ecx, DWORD PTR $T219654[ebp]
	mov	DWORD PTR $T219650[ebp], ecx
	mov	edx, DWORD PTR $T219662[ebp]
	mov	DWORD PTR tv301[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR $T219662[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T219662[ebp]
	add	ecx, 4
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	mov	DWORD PTR $T219696[ebp], ecx
	lea	edx, DWORD PTR $T219688[ebp]
	mov	DWORD PTR $T219684[ebp], edx
	mov	eax, DWORD PTR $T219696[ebp]
	mov	DWORD PTR tv353[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T219696[ebp]
	mov	DWORD PTR [ecx], 0
	mov	ecx, DWORD PTR $T219696[ebp]
	add	ecx, 4
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+760], 1

; 16   : 	m_szLoadFileName = CvPreGame::loadFileName();

	call	?loadFileName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::loadFileName
	mov	DWORD PTR $T219701[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR $T219700[ebp], eax
	mov	ecx, DWORD PTR $T219701[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219700[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 17   : 	m_eLoadFileStorage = CvPreGame::loadFileStorage();

	call	?loadFileStorage@CvPreGame@@YA?AW4StorageLocation@@XZ ; CvPreGame::loadFileStorage
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], eax

; 18   : 	m_szMapScriptName = CvPreGame::mapScriptName();

	call	?mapScriptName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::mapScriptName
	mov	DWORD PTR $T219706[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR $T219705[ebp], eax
	mov	ecx, DWORD PTR $T219706[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219705[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 19   : 	m_bIsEarthMap = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+64], 0

; 20   : 	m_bIsRandomMapScript = CvPreGame::randomMapScript();

	call	?randomMapScript@CvPreGame@@YA_NXZ	; CvPreGame::randomMapScript
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+65], al

; 21   : 	m_bIsRandomWorldSize = CvPreGame::randomWorldSize();

	call	?randomWorldSize@CvPreGame@@YA_NXZ	; CvPreGame::randomWorldSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+66], al

; 22   : 	m_bWBMapNoPlayers = CvPreGame::mapNoPlayers();

	call	?mapNoPlayers@CvPreGame@@YA_NXZ		; CvPreGame::mapNoPlayers
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+67], al

; 23   : 	m_eWorldSize = CvPreGame::worldSize();

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], eax

; 24   : 	m_eClimate = CvPreGame::climate();

	call	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 25   : 	m_eSeaLevel = CvPreGame::seaLevel();

	call	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], eax

; 26   : 	m_eEra = CvPreGame::era();

	call	?era@CvPreGame@@YA?AW4EraTypes@@XZ	; CvPreGame::era
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 27   : 	m_eCalendar = CvPreGame::calendar();

	call	?calendar@CvPreGame@@YA?AW4CalendarTypes@@XZ ; CvPreGame::calendar
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], eax

; 28   : 	m_iGameTurn = CvPreGame::gameTurn();

	call	?gameTurn@CvPreGame@@YAHXZ		; CvPreGame::gameTurn
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], eax

; 29   : 	m_bGameStarted = CvPreGame::gameStarted();

	call	?gameStarted@CvPreGame@@YA_NXZ		; CvPreGame::gameStarted
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+92], al

; 30   : 	m_eGameSpeed = CvPreGame::gameSpeed();

	call	?gameSpeed@CvPreGame@@YA?AW4GameSpeedTypes@@XZ ; CvPreGame::gameSpeed
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], eax

; 31   : 	m_eTurnTimerEnabled = CvPreGame::turnTimer();

	call	?turnTimer@CvPreGame@@YA?AW4TurnTimerTypes@@XZ ; CvPreGame::turnTimer
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], eax

; 32   : 	m_iTurnTimerTime = CvPreGame::pitBossTurnTime();

	call	?pitBossTurnTime@CvPreGame@@YAHXZ	; CvPreGame::pitBossTurnTime
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 33   : 	m_szGameName = CvPreGame::gameName();

	call	?gameName@CvPreGame@@YAABVCvString@@XZ	; CvPreGame::gameName
	mov	DWORD PTR $T219711[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 108				; 0000006cH
	mov	DWORD PTR $T219710[ebp], edx
	mov	eax, DWORD PTR $T219711[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219710[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 34   : 	m_uiSyncRandSeed = CvPreGame::syncRandomSeed();

	call	?syncRandomSeed@CvPreGame@@YAIXZ	; CvPreGame::syncRandomSeed
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], eax

; 35   : 	m_uiMapRandSeed = CvPreGame::mapRandomSeed();

	call	?mapRandomSeed@CvPreGame@@YAIXZ		; CvPreGame::mapRandomSeed
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+140], eax

; 36   : 
; 37   : 	m_abVictories = CvPreGame::victories();

	call	?victories@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ ; CvPreGame::victories
	mov	DWORD PTR $T219721[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T219720[ebp], eax
	mov	ecx, DWORD PTR $T219720[ebp]
	mov	edx, DWORD PTR $T219721[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T219721[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR $T219720[ebp]
	add	ecx, 4
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=

; 38   : 
; 39   : 	m_aGameOptions = CvPreGame::GetGameOptions();

	call	?GetGameOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ ; CvPreGame::GetGameOptions
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=

; 40   : 	m_aMapOptions = CvPreGame::GetMapOptions();

	call	?GetMapOptions@CvPreGame@@YAABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@XZ ; CvPreGame::GetMapOptions
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	call	??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=

; 41   : 	m_abMPOptions = CvPreGame::multiplayerOptions();

	call	?multiplayerOptions@CvPreGame@@YAABV?$vector@_NV?$allocator@_N@std@@@std@@XZ ; CvPreGame::multiplayerOptions
	mov	DWORD PTR $T219731[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	mov	DWORD PTR $T219730[ebp], edx
	mov	eax, DWORD PTR $T219730[ebp]
	mov	ecx, DWORD PTR $T219731[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T219731[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR $T219730[ebp]
	add	ecx, 4
	call	??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=

; 42   : 
; 43   : 	m_iMaxTurns = CvPreGame::maxTurns();

	call	?maxTurns@CvPreGame@@YAHXZ		; CvPreGame::maxTurns
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+220], eax

; 44   : 	m_iMaxCityElimination = CvPreGame::maxCityElimination();

	call	?maxCityElimination@CvPreGame@@YAHXZ	; CvPreGame::maxCityElimination
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+228], eax

; 45   : 	m_iNumMinorCivs = CvPreGame::numMinorCivs();

	call	?numMinorCivs@CvPreGame@@YAHXZ		; CvPreGame::numMinorCivs
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+232], eax

; 46   : 	m_iNumAdvancedStartPoints = CvPreGame::advancedStartPoints();

	call	?advancedStartPoints@CvPreGame@@YAHXZ	; CvPreGame::advancedStartPoints
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+236], eax

; 47   : 	m_eMode = CvPreGame::gameMode();

	call	?gameMode@CvPreGame@@YA?AW4GameMode@@XZ	; CvPreGame::gameMode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+240], eax

; 48   : 
; 49   : #ifdef AUI_WARNING_FIXES
; 50   : 	m_iNumVictories = 0;
; 51   : 	m_iPitbossTurnTime = m_iTurnTimerTime;
; 52   : 	m_bStatReporting = false;
; 53   : #endif
; 54   : 
; 55   : 	ZeroMemory(m_szDebugString, sizeof m_szDebugString);

	push	512					; 00000200H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 245				; 000000f5H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 56   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$10:
	mov	ecx, DWORD PTR $T219662[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	jmp	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$14:
	mov	ecx, DWORD PTR $T219696[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??0CvDllNetInitInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__ehhandler$??0CvDllNetInitInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvDllNetInitInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvDllNetInitInfo@@QAE@XZ ENDP			; CvDllNetInitInfo::CvDllNetInitInfo
PUBLIC	??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	??1CvDllNetInitInfo@@QAE@XZ			; CvDllNetInitInfo::~CvDllNetInitInfo
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvDllNetInitInfo@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??1CvDllNetInitInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvDllNetInitInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$9
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$11
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$13
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$15
	DD	0aH
	DD	FLAT:__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$17
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
xdata$x	ENDS
;	COMDAT ??1CvDllNetInitInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T220009 = -112						; size = 4
$T220004 = -108						; size = 4
$T219999 = -104						; size = 4
$T219994 = -100						; size = 4
$T219980 = -96						; size = 4
$T219959 = -92						; size = 4
$T219873 = -56						; size = 4
$T219787 = -20						; size = 4
$T219773 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvDllNetInitInfo@@QAE@XZ PROC			; CvDllNetInitInfo::~CvDllNetInitInfo, COMDAT
; _this$ = ecx

; 59   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvDllNetInitInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvDllNetInitInfo@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 60   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	mov	DWORD PTR $T219787[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR $T219787[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T219787[ebp]
	add	eax, 4
	mov	DWORD PTR $T219773[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T219773[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	mov	DWORD PTR $T219873[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T219873[ebp]
	call	?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 168				; 000000a8H
	mov	DWORD PTR $T219959[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T219959[ebp]
	call	?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T219994[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T219994[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T219994[ebp]
	add	edx, 4
	mov	DWORD PTR $T219980[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T219980[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	mov	DWORD PTR $T219999[ebp], eax
	mov	ecx, DWORD PTR $T219999[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T220004[ebp], ecx
	mov	ecx, DWORD PTR $T220004[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T220009[ebp], edx
	mov	ecx, DWORD PTR $T220009[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	jmp	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	jmp	??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR $T219787[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$9:
	mov	ecx, DWORD PTR $T219773[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$11:
	mov	ecx, DWORD PTR $T219873[ebp]
	jmp	??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$13:
	mov	ecx, DWORD PTR $T219959[ebp]
	jmp	??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$15:
	mov	ecx, DWORD PTR $T219994[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1CvDllNetInitInfo@@QAE@XZ$17:
	mov	ecx, DWORD PTR $T219980[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1CvDllNetInitInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvDllNetInitInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvDllNetInitInfo@@QAE@XZ ENDP			; CvDllNetInitInfo::~CvDllNetInitInfo
PUBLIC	?IncrementReference@CvDllNetInitInfo@@QAEIXZ	; CvDllNetInitInfo::IncrementReference
; Function compile flags: /Odtp
;	COMDAT ?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z
_TEXT	SEGMENT
tv90 = -88						; size = 4
tv161 = -84						; size = 4
tv85 = -80						; size = 4
tv137 = -76						; size = 4
$T220022 = -72						; size = 16
$T220021 = -56						; size = 16
$T220020 = -40						; size = 16
$T220019 = -20						; size = 16
_this$ = 8						; size = 4
_guidInterface$ = 12					; size = 16
?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z PROC	; CvDllNetInitInfo::QueryInterface, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi

; 64   : 	if(guidInterface == ICvUnknown::GetInterfaceId() ||
; 65   : 	        guidInterface == ICvNetInitInfo1::GetInterfaceId())

	mov	eax, DWORD PTR _guidICvUnknown
	mov	DWORD PTR $T220020[ebp], eax
	mov	ecx, DWORD PTR _guidICvUnknown+4
	mov	DWORD PTR $T220020[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvUnknown+8
	mov	DWORD PTR $T220020[ebp+8], edx
	mov	eax, DWORD PTR _guidICvUnknown+12
	mov	DWORD PTR $T220020[ebp+12], eax
	mov	ecx, DWORD PTR $T220020[ebp]
	mov	DWORD PTR $T220019[ebp], ecx
	mov	edx, DWORD PTR $T220020[ebp+4]
	mov	DWORD PTR $T220019[ebp+4], edx
	mov	eax, DWORD PTR $T220020[ebp+8]
	mov	DWORD PTR $T220019[ebp+8], eax
	mov	ecx, DWORD PTR $T220020[ebp+12]
	mov	DWORD PTR $T220019[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T220019[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv137[ebp], edx
	repe cmpsb
	je	SHORT $LN17@QueryInter
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv137[ebp], eax
$LN17@QueryInter:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv85[ebp], 0
	sete	dl
	test	edx, edx
	jne	SHORT $LN1@QueryInter
	mov	eax, DWORD PTR _guidICvNetInitInfo1
	mov	DWORD PTR $T220022[ebp], eax
	mov	ecx, DWORD PTR _guidICvNetInitInfo1+4
	mov	DWORD PTR $T220022[ebp+4], ecx
	mov	edx, DWORD PTR _guidICvNetInitInfo1+8
	mov	DWORD PTR $T220022[ebp+8], edx
	mov	eax, DWORD PTR _guidICvNetInitInfo1+12
	mov	DWORD PTR $T220022[ebp+12], eax
	mov	ecx, DWORD PTR $T220022[ebp]
	mov	DWORD PTR $T220021[ebp], ecx
	mov	edx, DWORD PTR $T220022[ebp+4]
	mov	DWORD PTR $T220021[ebp+4], edx
	mov	eax, DWORD PTR $T220022[ebp+8]
	mov	DWORD PTR $T220021[ebp+8], eax
	mov	ecx, DWORD PTR $T220022[ebp+12]
	mov	DWORD PTR $T220021[ebp+12], ecx
	mov	ecx, 16					; 00000010H
	lea	edi, DWORD PTR $T220021[ebp]
	lea	esi, DWORD PTR _guidInterface$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv161[ebp], edx
	repe cmpsb
	je	SHORT $LN18@QueryInter
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv161[ebp], eax
$LN18@QueryInter:
	mov	ecx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	xor	edx, edx
	cmp	DWORD PTR tv90[ebp], 0
	sete	dl
	test	edx, edx
	je	SHORT $LN2@QueryInter
$LN1@QueryInter:

; 66   : 	{
; 67   : 		IncrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IncrementReference@CvDllNetInitInfo@@QAEIXZ ; CvDllNetInitInfo::IncrementReference

; 68   : 		return this;

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $LN3@QueryInter
$LN2@QueryInter:

; 69   : 	}
; 70   : 
; 71   : 	return NULL;

	xor	eax, eax
$LN3@QueryInter:

; 72   : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?QueryInterface@CvDllNetInitInfo@@UAGPAXU_GUID@@@Z ENDP	; CvDllNetInitInfo::QueryInterface
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IncrementReference@CvDllNetInitInfo@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncrementReference@CvDllNetInitInfo@@QAEIXZ PROC	; CvDllNetInitInfo::IncrementReference, COMDAT
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 	++m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+760], ecx

; 77   : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+760]

; 78   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncrementReference@CvDllNetInitInfo@@QAEIXZ ENDP	; CvDllNetInitInfo::IncrementReference
_TEXT	ENDS
PUBLIC	??3CvDllNetInitInfo@@SAXPAX@Z			; CvDllNetInitInfo::operator delete
PUBLIC	?DecrementReference@CvDllNetInitInfo@@QAEIXZ	; CvDllNetInitInfo::DecrementReference
; Function compile flags: /Odtp
;	COMDAT ?DecrementReference@CvDllNetInitInfo@@QAEIXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T220054 = -8						; size = 4
$T220053 = -4						; size = 4
?DecrementReference@CvDllNetInitInfo@@QAEIXZ PROC	; CvDllNetInitInfo::DecrementReference, COMDAT
; _this$ = ecx

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	if(m_uiRefCount == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+760], 1
	jne	SHORT $LN2@DecrementR

; 83   : 	{
; 84   : 		delete this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T220054[ebp], ecx
	mov	edx, DWORD PTR $T220054[ebp]
	mov	DWORD PTR $T220053[ebp], edx
	cmp	DWORD PTR $T220053[ebp], 0
	je	SHORT $LN5@DecrementR
	mov	ecx, DWORD PTR $T220053[ebp]
	call	??1CvDllNetInitInfo@@QAE@XZ		; CvDllNetInitInfo::~CvDllNetInitInfo
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN8@DecrementR
	mov	ecx, DWORD PTR $T220053[ebp]
	push	ecx
	call	??3CvDllNetInitInfo@@SAXPAX@Z		; CvDllNetInitInfo::operator delete
	add	esp, 4
$LN8@DecrementR:
	mov	edx, DWORD PTR $T220053[ebp]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $LN6@DecrementR
$LN5@DecrementR:
	mov	DWORD PTR tv70[ebp], 0
$LN6@DecrementR:

; 85   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@DecrementR

; 86   : 	}
; 87   : 	else

	jmp	SHORT $LN3@DecrementR
$LN2@DecrementR:

; 88   : 	{
; 89   : 		--m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+760]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+760], ecx

; 90   : 		return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+760]
$LN3@DecrementR:

; 91   : 	}
; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecrementReference@CvDllNetInitInfo@@QAEIXZ ENDP	; CvDllNetInitInfo::DecrementReference
_TEXT	ENDS
PUBLIC	?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ	; CvDllNetInitInfo::GetReferenceCount
; Function compile flags: /Odtp
;	COMDAT ?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ PROC	; CvDllNetInitInfo::GetReferenceCount, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	return m_uiRefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+760]

; 97   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetReferenceCount@CvDllNetInitInfo@@QAEIXZ ENDP	; CvDllNetInitInfo::GetReferenceCount
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@CvDllNetInitInfo@@EAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Destroy@CvDllNetInitInfo@@EAGXXZ PROC			; CvDllNetInitInfo::Destroy, COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp

; 101  : 	DecrementReference();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecrementReference@CvDllNetInitInfo@@QAEIXZ ; CvDllNetInitInfo::DecrementReference

; 102  : }

	pop	ebp
	ret	4
?Destroy@CvDllNetInitInfo@@EAGXXZ ENDP			; CvDllNetInitInfo::Destroy
_TEXT	ENDS
EXTRN	?Free@CvDllGameContext@@SAXPAX@Z:PROC		; CvDllGameContext::Free
; Function compile flags: /Odtp
;	COMDAT ??3CvDllNetInitInfo@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CvDllNetInitInfo@@SAXPAX@Z PROC			; CvDllNetInitInfo::operator delete, COMDAT

; 105  : {

	push	ebp
	mov	ebp, esp

; 106  : 	CvDllGameContext::Free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 107  : }

	pop	ebp
	ret	0
??3CvDllNetInitInfo@@SAXPAX@Z ENDP			; CvDllNetInitInfo::operator delete
_TEXT	ENDS
PUBLIC	??2CvDllNetInitInfo@@SAPAXI@Z			; CvDllNetInitInfo::operator new
EXTRN	?Allocate@CvDllGameContext@@SAPAXI@Z:PROC	; CvDllGameContext::Allocate
; Function compile flags: /Odtp
;	COMDAT ??2CvDllNetInitInfo@@SAPAXI@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
??2CvDllNetInitInfo@@SAPAXI@Z PROC			; CvDllNetInitInfo::operator new, COMDAT

; 110  : {

	push	ebp
	mov	ebp, esp

; 111  : 	return CvDllGameContext::Allocate(bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	call	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
	add	esp, 4

; 112  : }

	pop	ebp
	ret	0
??2CvDllNetInitInfo@@SAPAXI@Z ENDP			; CvDllNetInitInfo::operator new
_TEXT	ENDS
PUBLIC	??_C@_0BBG@LGGBLDDN@NetInitInfo?5?3?5m_szLoadFileName?$DN?$CC@ ; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
EXTRN	__imp__sprintf:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
;	COMDAT ??_C@_0BBG@LGGBLDDN@NetInitInfo?5?3?5m_szLoadFileName?$DN?$CC@
CONST	SEGMENT
??_C@_0BBG@LGGBLDDN@NetInitInfo?5?3?5m_szLoadFileName?$DN?$CC@ DB 'NetIni'
	DB	'tInfo : m_szLoadFileName="%s", m_szMapScriptName="%s", m_bWBM'
	DB	'apNoPlayers="%s", m_eWorldSize=%d, m_eClimate=%d m_eSeaLevel='
	DB	'%d m_eEra=%d m_eCalendar=%d m_iGameTurn=%d m_bGameStarted=%i '
	DB	'm_eGameSpeed=%d m_eTurnTimer=%d m_szGameName="%s" m_uiSyncRan'
	DB	'dSeed=%d m_uiMapRandSeed=%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ
_TEXT	SEGMENT
tv131 = -4						; size = 4
_this$ = 8						; size = 4
?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ PROC		; CvDllNetInitInfo::GetDebugString, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 116  : 	sprintf(m_szDebugString, "NetInitInfo : m_szLoadFileName=\"%s\", "\
; 117  : 	        "m_szMapScriptName=\"%s\", "\
; 118  : 	        "m_bWBMapNoPlayers=\"%s\", "\
; 119  : 	        "m_eWorldSize=%d, "\
; 120  : 	        "m_eClimate=%d "\
; 121  : 	        "m_eSeaLevel=%d "\
; 122  : 	        "m_eEra=%d "\
; 123  : 	        "m_eCalendar=%d "\
; 124  : 	        "m_iGameTurn=%d "\
; 125  : 					"m_bGameStarted=%i "\
; 126  : 	        "m_eGameSpeed=%d "\
; 127  : 	        "m_eTurnTimer=%d "\
; 128  : 	        "m_szGameName=\"%s\" "\
; 129  : 	        "m_uiSyncRandSeed=%d "\
; 130  : 	        "m_uiMapRandSeed=%d"
; 131  : 	        , CvPreGame::loadFileName().c_str()
; 132  : 	        , CvPreGame::mapScriptName().c_str()
; 133  : 	        , CvPreGame::mapNoPlayers() ? "true" : "false"
; 134  : 	        , static_cast<int>(CvPreGame::worldSize())
; 135  : 	        , static_cast<int>(CvPreGame::climate())
; 136  : 	        , static_cast<int>(CvPreGame::seaLevel())
; 137  : 	        , static_cast<int>(CvPreGame::era())
; 138  : 	        , static_cast<int>(CvPreGame::calendar())
; 139  : 	        , CvPreGame::gameTurn()
; 140  : #ifdef AUI_WARNING_FIXES
; 141  : 		, CvPreGame::gameStarted() ? 1 : 0
; 142  : #else
; 143  : 					, CvPreGame::gameStarted()
; 144  : #endif
; 145  : 	        , static_cast<int>(CvPreGame::gameSpeed())
; 146  : 	        , static_cast<int>(CvPreGame::turnTimer())
; 147  : 	        , CvPreGame::gameName().c_str()
; 148  : #ifdef AUI_WARNING_FIXES
; 149  : 		, (int)CvPreGame::syncRandomSeed()
; 150  : 		, (int)CvPreGame::mapRandomSeed()
; 151  : #else
; 152  : 	        , CvPreGame::syncRandomSeed()
; 153  : 	        , CvPreGame::mapRandomSeed()
; 154  : #endif
; 155  : 	       );

	call	?mapNoPlayers@CvPreGame@@YA_NXZ		; CvPreGame::mapNoPlayers
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@GetDebugSt
	mov	DWORD PTR tv131[ebp], OFFSET ??_C@_04LOAJBDKD@true?$AA@
	jmp	SHORT $LN4@GetDebugSt
$LN3@GetDebugSt:
	mov	DWORD PTR tv131[ebp], OFFSET ??_C@_05LAPONLG@false?$AA@
$LN4@GetDebugSt:
	call	?mapRandomSeed@CvPreGame@@YAIXZ		; CvPreGame::mapRandomSeed
	push	eax
	call	?syncRandomSeed@CvPreGame@@YAIXZ	; CvPreGame::syncRandomSeed
	push	eax
	call	?gameName@CvPreGame@@YAABVCvString@@XZ	; CvPreGame::gameName
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	?turnTimer@CvPreGame@@YA?AW4TurnTimerTypes@@XZ ; CvPreGame::turnTimer
	push	eax
	call	?gameSpeed@CvPreGame@@YA?AW4GameSpeedTypes@@XZ ; CvPreGame::gameSpeed
	push	eax
	call	?gameStarted@CvPreGame@@YA_NXZ		; CvPreGame::gameStarted
	movzx	ecx, al
	push	ecx
	call	?gameTurn@CvPreGame@@YAHXZ		; CvPreGame::gameTurn
	push	eax
	call	?calendar@CvPreGame@@YA?AW4CalendarTypes@@XZ ; CvPreGame::calendar
	push	eax
	call	?era@CvPreGame@@YA?AW4EraTypes@@XZ	; CvPreGame::era
	push	eax
	call	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel
	push	eax
	call	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate
	push	eax
	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	push	eax
	mov	edx, DWORD PTR tv131[ebp]
	push	edx
	call	?mapScriptName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::mapScriptName
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	?loadFileName@CvPreGame@@YAABVCvString@@XZ ; CvPreGame::loadFileName
	mov	ecx, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BBG@LGGBLDDN@NetInitInfo?5?3?5m_szLoadFileName?$DN?$CC@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 245				; 000000f5H
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 68					; 00000044H

; 156  : 
; 157  : 	return m_szDebugString;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 245				; 000000f5H

; 158  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetDebugString@CvDllNetInitInfo@@UAGPBDXZ ENDP		; CvDllNetInitInfo::GetDebugString
_TEXT	ENDS
PUBLIC	??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator>><CvPreGame::CustomOption>
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator>><bool>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameMode@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TurnTimerTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z:PROC ; operator>>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4StorageLocation@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_kStream$ = 12						; size = 4
?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z PROC	; CvDllNetInitInfo::Read, COMDAT

; 161  : {

	push	ebp
	mov	ebp, esp

; 162  : 	kStream >> m_szLoadFileName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 163  : 	kStream >> m_eLoadFileStorage;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4StorageLocation@@@Z ; operator>>
	add	esp, 8

; 164  : 	kStream >> m_szMapScriptName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 165  : 	kStream >> m_bIsEarthMap;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 166  : 	kStream >> m_bIsRandomMapScript;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 65					; 00000041H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 167  : 	kStream >> m_bIsRandomWorldSize;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 66					; 00000042H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 168  : 	kStream >> m_bWBMapNoPlayers;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 67					; 00000043H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 169  : 	kStream >> m_eWorldSize;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4WorldSizeTypes@@@Z ; operator>>
	add	esp, 8

; 170  : 	kStream >> m_eClimate;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4ClimateTypes@@@Z ; operator>>
	add	esp, 8

; 171  : 	kStream >> m_eSeaLevel;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4SeaLevelTypes@@@Z ; operator>>
	add	esp, 8

; 172  : 	kStream >> m_eEra;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4EraTypes@@@Z ; operator>>
	add	esp, 8

; 173  : 	kStream >> m_eCalendar;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4CalendarTypes@@@Z ; operator>>
	add	esp, 8

; 174  : 	kStream >> m_iGameTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 175  : 	kStream >> m_bGameStarted;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 176  : 	kStream >> m_eGameSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameSpeedTypes@@@Z ; operator>>
	add	esp, 8

; 177  : 	kStream >> m_eTurnTimerEnabled;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TurnTimerTypes@@@Z ; operator>>
	add	esp, 8

; 178  : 	kStream >> m_iTurnTimerTime;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 179  : 	kStream >> m_szGameName;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 180  : 	kStream >> m_uiSyncRandSeed;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 181  : 	kStream >> m_uiMapRandSeed;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 182  : 
; 183  : 	kStream >> m_iNumVictories;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 184  : 	kStream >> m_abVictories;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator>><bool>
	add	esp, 8

; 185  : 
; 186  : 	kStream >> m_aGameOptions;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator>><CvPreGame::CustomOption>
	add	esp, 8

; 187  : 	kStream >> m_aMapOptions;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 184				; 000000b8H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator>><CvPreGame::CustomOption>
	add	esp, 8

; 188  : 	kStream >> m_abMPOptions;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator>><bool>
	add	esp, 8

; 189  : 	kStream >> m_iMaxTurns;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 220				; 000000dcH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 190  : 	kStream >> m_iPitbossTurnTime;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 224				; 000000e0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 191  : 	kStream >> m_iMaxCityElimination;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 228				; 000000e4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 192  : 	kStream >> m_iNumMinorCivs;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 193  : 	kStream >> m_iNumAdvancedStartPoints;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 236				; 000000ecH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 194  : 	kStream >> m_eMode;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 240				; 000000f0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4GameMode@@@Z ; operator>>
	add	esp, 8

; 195  : 	kStream >> m_bStatReporting;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 244				; 000000f4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 196  : 
; 197  : 	return true;

	mov	al, 1

; 198  : }

	pop	ebp
	ret	8
?Read@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z ENDP	; CvDllNetInitInfo::Read
_TEXT	ENDS
PUBLIC	??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator<<<CvPreGame::CustomOption>
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator<<<bool>
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameMode@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TurnTimerTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z:PROC ; operator<<
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4StorageLocation@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_kStream$ = 12						; size = 4
?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z PROC	; CvDllNetInitInfo::Write, COMDAT

; 201  : {

	push	ebp
	mov	ebp, esp

; 202  : 	kStream << m_szLoadFileName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 203  : 	kStream << m_eLoadFileStorage;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4StorageLocation@@@Z ; operator<<
	add	esp, 8

; 204  : 	kStream << m_szMapScriptName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 205  : 	kStream << m_bIsEarthMap;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 206  : 	kStream << m_bIsRandomMapScript;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 65					; 00000041H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 207  : 	kStream << m_bIsRandomWorldSize;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 66					; 00000042H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 208  : 	kStream << m_bWBMapNoPlayers;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 67					; 00000043H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 209  : 	kStream << m_eWorldSize;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4WorldSizeTypes@@@Z ; operator<<
	add	esp, 8

; 210  : 	kStream << m_eClimate;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ClimateTypes@@@Z ; operator<<
	add	esp, 8

; 211  : 	kStream << m_eSeaLevel;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4SeaLevelTypes@@@Z ; operator<<
	add	esp, 8

; 212  : 	kStream << m_eEra;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4EraTypes@@@Z ; operator<<
	add	esp, 8

; 213  : 	kStream << m_eCalendar;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4CalendarTypes@@@Z ; operator<<
	add	esp, 8

; 214  : 	kStream << m_iGameTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 215  : 	kStream << m_bGameStarted;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 216  : 	kStream << m_eGameSpeed;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 96					; 00000060H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameSpeedTypes@@@Z ; operator<<
	add	esp, 8

; 217  : 	kStream << m_eTurnTimerEnabled;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4TurnTimerTypes@@@Z ; operator<<
	add	esp, 8

; 218  : 	kStream << m_iTurnTimerTime;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 219  : 	kStream << m_szGameName;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 220  : 	kStream << m_uiSyncRandSeed;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 221  : 	kStream << m_uiMapRandSeed;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 222  : 	kStream << m_iNumVictories;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 144				; 00000090H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 223  : 	kStream << m_abVictories;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator<<<bool>
	add	esp, 8

; 224  : 	kStream << m_aGameOptions;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator<<<CvPreGame::CustomOption>
	add	esp, 8

; 225  : 	kStream << m_aMapOptions;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 184				; 000000b8H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; operator<<<CvPreGame::CustomOption>
	add	esp, 8

; 226  : 	kStream << m_abMPOptions;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; operator<<<bool>
	add	esp, 8

; 227  : 	kStream << m_iMaxTurns;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 220				; 000000dcH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 228  : 	kStream << m_iPitbossTurnTime;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 224				; 000000e0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 229  : 	kStream << m_iMaxCityElimination;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 228				; 000000e4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 230  : 	kStream << m_iNumMinorCivs;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 231  : 	kStream << m_iNumAdvancedStartPoints;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 236				; 000000ecH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 232  : 	kStream << m_eMode;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 240				; 000000f0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABW4GameMode@@@Z ; operator<<
	add	esp, 8

; 233  : 	kStream << m_bStatReporting;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 244				; 000000f4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 234  : 
; 235  : 	return true;

	mov	al, 1

; 236  : }

	pop	ebp
	ret	8
?Write@CvDllNetInitInfo@@UAG_NAAVFDataStream@@@Z ENDP	; CvDllNetInitInfo::Write
_TEXT	ENDS
PUBLIC	??_C@_0DJ@NADDLKPA@Evaluating?5Map?5Path?3?5?$CI?$CFs?$CJ?6Origin@ ; `string'
PUBLIC	??_C@_06CMLPEGNC@Failed?$AA@			; `string'
PUBLIC	??_C@_07PBILKAFL@Success?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BG@HGKFLJFE@net_message_debug?4log?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?setGameMode@CvPreGame@@YAXW4GameMode@@@Z:PROC	; CvPreGame::setGameMode
EXTRN	?setAdvancedStartPoints@CvPreGame@@YAXH@Z:PROC	; CvPreGame::setAdvancedStartPoints
EXTRN	?setNumMinorCivs@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setNumMinorCivs
EXTRN	?setMaxCityElimination@CvPreGame@@YAXH@Z:PROC	; CvPreGame::setMaxCityElimination
EXTRN	?setMaxTurns@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setMaxTurns
EXTRN	?setMultiplayerOptions@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z:PROC ; CvPreGame::setMultiplayerOptions
EXTRN	?SetMapOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z:PROC ; CvPreGame::SetMapOptions
EXTRN	?SetGameOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z:PROC ; CvPreGame::SetGameOptions
EXTRN	?setVictories@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z:PROC ; CvPreGame::setVictories
EXTRN	?setMapRandomSeed@CvPreGame@@YAXI@Z:PROC	; CvPreGame::setMapRandomSeed
EXTRN	?setSyncRandomSeed@CvPreGame@@YAXI@Z:PROC	; CvPreGame::setSyncRandomSeed
EXTRN	?setGameName@CvPreGame@@YAXABVCvString@@@Z:PROC	; CvPreGame::setGameName
EXTRN	?setPitBossTurnTime@CvPreGame@@YAXH@Z:PROC	; CvPreGame::setPitBossTurnTime
EXTRN	?setTurnTimer@CvPreGame@@YAXW4TurnTimerTypes@@@Z:PROC ; CvPreGame::setTurnTimer
EXTRN	?setGameSpeed@CvPreGame@@YAXW4GameSpeedTypes@@@Z:PROC ; CvPreGame::setGameSpeed
EXTRN	?setGameStarted@CvPreGame@@YAX_N@Z:PROC		; CvPreGame::setGameStarted
EXTRN	?setGameTurn@CvPreGame@@YAXH@Z:PROC		; CvPreGame::setGameTurn
EXTRN	?setCalendar@CvPreGame@@YAXW4CalendarTypes@@@Z:PROC ; CvPreGame::setCalendar
EXTRN	?setEra@CvPreGame@@YAXW4EraTypes@@@Z:PROC	; CvPreGame::setEra
EXTRN	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z:PROC ; CvPreGame::setSeaLevel
EXTRN	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z:PROC ; CvPreGame::setClimate
EXTRN	?setRandomWorldSize@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setRandomWorldSize
EXTRN	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z:PROC ; CvPreGame::setWorldSize
EXTRN	?setMapNoPlayers@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setMapNoPlayers
EXTRN	?setLoadFileName@CvPreGame@@YAXABVCvString@@W4StorageLocation@@@Z:PROC ; CvPreGame::setLoadFileName
EXTRN	?setTransferredMap@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setTransferredMap
EXTRN	?setRandomMapScript@CvPreGame@@YAX_N@Z:PROC	; CvPreGame::setRandomMapScript
EXTRN	?setMapScriptName@CvPreGame@@YAXABVCvString@@@Z:PROC ; CvPreGame::setMapScriptName
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
;	COMDAT ??_C@_0DJ@NADDLKPA@Evaluating?5Map?5Path?3?5?$CI?$CFs?$CJ?6Origin@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DJ@NADDLKPA@Evaluating?5Map?5Path?3?5?$CI?$CFs?$CJ?6Origin@ DB 'Ev'
	DB	'aluating Map Path: (%s)', 0aH, 'Original Path: %s', 0aH, 'New'
	DB	' Path: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06CMLPEGNC@Failed?$AA@
CONST	SEGMENT
??_C@_06CMLPEGNC@Failed?$AA@ DB 'Failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBILKAFL@Success?$AA@
CONST	SEGMENT
??_C@_07PBILKAFL@Success?$AA@ DB 'Success', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGKFLJFE@net_message_debug?4log?$AA@
CONST	SEGMENT
??_C@_0BG@HGKFLJFE@net_message_debug?4log?$AA@ DB 'net_message_debug.log', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Commit@CvDllNetInitInfo@@UAG_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Commit@CvDllNetInitInfo@@UAG_NXZ$0
__ehfuncinfo$?Commit@CvDllNetInitInfo@@UAG_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Commit@CvDllNetInitInfo@@UAG_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdllnetinitinfo.cpp
xdata$x	ENDS
;	COMDAT ?Commit@CvDllNetInitInfo@@UAG_NXZ
_TEXT	SEGMENT
tv149 = -1116						; size = 4
tv217 = -1112						; size = 4
tv79 = -1108						; size = 4
tv66 = -1104						; size = 4
$T220201 = -1100					; size = 4
$T220196 = -1094					; size = 1
_bResult$ = -1093					; size = 1
_logFile$ = -1092					; size = 4
_strMapScriptPath$ = -1088				; size = 28
_szMapScriptPath$ = -1060				; size = 1040
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?Commit@CvDllNetInitInfo@@UAG_NXZ PROC			; CvDllNetInitInfo::Commit, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Commit@CvDllNetInitInfo@@UAG_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1104				; 00000450H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 240  : 	// Copy the settings into our initialization data structure
; 241  : 
; 242  : 	//The map script path cannot be trusted since this structure is sent over the network.
; 243  : 	//Have the app search for the best candidate.
; 244  : 	FILogFile* logFile = LOGFILEMGR.GetLog("net_message_debug.log", 0);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv66[ebp], eax
	push	0
	push	0
	push	OFFSET ??_C@_0BG@HGKFLJFE@net_message_debug?4log?$AA@
	mov	eax, DWORD PTR tv66[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv66[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _logFile$[ebp], eax

; 245  : 
; 246  : 	char szMapScriptPath[1040] = {0};

	mov	BYTE PTR _szMapScriptPath$[ebp], 0
	push	1039					; 0000040fH
	push	0
	lea	ecx, DWORD PTR _szMapScriptPath$[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 247  : 	const bool bResult = gDLL->GetEvaluatedMapScriptPath(m_szMapScriptName.c_str(), szMapScriptPath, 1040);

	mov	edx, DWORD PTR $T220201[ebp]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv79[ebp], eax
	push	1040					; 00000410H
	lea	ecx, DWORD PTR _szMapScriptPath$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	mov	eax, DWORD PTR tv79[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+1036]
	call	edx
	mov	BYTE PTR _bResult$[ebp], al

; 248  : 
; 249  : 	CvString strMapScriptPath = szMapScriptPath;

	lea	eax, DWORD PTR _szMapScriptPath$[ebp]
	test	eax, eax
	je	SHORT $LN10@Commit
	lea	ecx, DWORD PTR _szMapScriptPath$[ebp]
	mov	DWORD PTR tv217[ebp], ecx
	jmp	SHORT $LN11@Commit
$LN10@Commit:
	mov	DWORD PTR tv217[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN11@Commit:
	mov	edx, DWORD PTR tv217[ebp]
	push	edx
	lea	ecx, DWORD PTR _strMapScriptPath$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 250  : 
; 251  : 	logFile->DebugMsg("Evaluating Map Path: (%s)\nOriginal Path: %s\nNew Path: %s", (bResult)? "Success": "Failed", m_szMapScriptName.c_str(), strMapScriptPath.c_str());

	movzx	eax, BYTE PTR _bResult$[ebp]
	test	eax, eax
	je	SHORT $LN3@Commit
	mov	DWORD PTR tv149[ebp], OFFSET ??_C@_07PBILKAFL@Success?$AA@
	jmp	SHORT $LN4@Commit
$LN3@Commit:
	mov	DWORD PTR tv149[ebp], OFFSET ??_C@_06CMLPEGNC@Failed?$AA@
$LN4@Commit:
	lea	ecx, DWORD PTR _strMapScriptPath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR tv149[ebp]
	push	ecx
	push	OFFSET ??_C@_0DJ@NADDLKPA@Evaluating?5Map?5Path?3?5?$CI?$CFs?$CJ?6Origin@
	mov	edx, DWORD PTR _logFile$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _logFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+4]
	call	edx
	add	esp, 20					; 00000014H

; 252  : 
; 253  : 	CvPreGame::setMapScriptName(strMapScriptPath);

	lea	eax, DWORD PTR _strMapScriptPath$[ebp]
	push	eax
	call	?setMapScriptName@CvPreGame@@YAXABVCvString@@@Z ; CvPreGame::setMapScriptName
	add	esp, 4

; 254  : 	CvPreGame::setRandomMapScript(m_bIsRandomMapScript);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+65]
	push	edx
	call	?setRandomMapScript@CvPreGame@@YAX_N@Z	; CvPreGame::setRandomMapScript
	add	esp, 4

; 255  : 	CvPreGame::setTransferredMap(false);		// We'll always set this manually

	push	0
	call	?setTransferredMap@CvPreGame@@YAX_N@Z	; CvPreGame::setTransferredMap
	add	esp, 4

; 256  : 	CvPreGame::setLoadFileName(m_szLoadFileName, m_eLoadFileStorage);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	?setLoadFileName@CvPreGame@@YAXABVCvString@@W4StorageLocation@@@Z ; CvPreGame::setLoadFileName
	add	esp, 8

; 257  : 	CvPreGame::setMapNoPlayers(m_bWBMapNoPlayers);

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+67]
	push	ecx
	call	?setMapNoPlayers@CvPreGame@@YAX_N@Z	; CvPreGame::setMapNoPlayers
	add	esp, 4

; 258  : 	CvPreGame::setWorldSize(m_eWorldSize,false);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	call	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z ; CvPreGame::setWorldSize
	add	esp, 8

; 259  : 	CvPreGame::setRandomWorldSize(m_bIsRandomWorldSize);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+66]
	push	edx
	call	?setRandomWorldSize@CvPreGame@@YAX_N@Z	; CvPreGame::setRandomWorldSize
	add	esp, 4

; 260  : 	CvPreGame::setClimate(m_eClimate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z ; CvPreGame::setClimate
	add	esp, 4

; 261  : 	CvPreGame::setSeaLevel(m_eSeaLevel);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z ; CvPreGame::setSeaLevel
	add	esp, 4

; 262  : 	CvPreGame::setEra(m_eEra);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	call	?setEra@CvPreGame@@YAXW4EraTypes@@@Z	; CvPreGame::setEra
	add	esp, 4

; 263  : 	CvPreGame::setCalendar(m_eCalendar);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	?setCalendar@CvPreGame@@YAXW4CalendarTypes@@@Z ; CvPreGame::setCalendar
	add	esp, 4

; 264  : 	CvPreGame::setGameTurn(m_iGameTurn);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	call	?setGameTurn@CvPreGame@@YAXH@Z		; CvPreGame::setGameTurn
	add	esp, 4

; 265  : 	CvPreGame::setGameStarted(m_bGameStarted);

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+92]
	push	edx
	call	?setGameStarted@CvPreGame@@YAX_N@Z	; CvPreGame::setGameStarted
	add	esp, 4

; 266  : 	CvPreGame::setGameSpeed(m_eGameSpeed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	call	?setGameSpeed@CvPreGame@@YAXW4GameSpeedTypes@@@Z ; CvPreGame::setGameSpeed
	add	esp, 4

; 267  : 	CvPreGame::setTurnTimer(m_eTurnTimerEnabled);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	push	eax
	call	?setTurnTimer@CvPreGame@@YAXW4TurnTimerTypes@@@Z ; CvPreGame::setTurnTimer
	add	esp, 4

; 268  : 	CvPreGame::setPitBossTurnTime(m_iTurnTimerTime);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	call	?setPitBossTurnTime@CvPreGame@@YAXH@Z	; CvPreGame::setPitBossTurnTime
	add	esp, 4

; 269  : 	CvPreGame::setGameName(m_szGameName);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 108				; 0000006cH
	push	eax
	call	?setGameName@CvPreGame@@YAXABVCvString@@@Z ; CvPreGame::setGameName
	add	esp, 4

; 270  : 	CvPreGame::setSyncRandomSeed(m_uiSyncRandSeed);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	push	edx
	call	?setSyncRandomSeed@CvPreGame@@YAXI@Z	; CvPreGame::setSyncRandomSeed
	add	esp, 4

; 271  : 	CvPreGame::setMapRandomSeed(m_uiMapRandSeed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+140]
	push	ecx
	call	?setMapRandomSeed@CvPreGame@@YAXI@Z	; CvPreGame::setMapRandomSeed
	add	esp, 4

; 272  : 	CvPreGame::setVictories(m_abVictories);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 148				; 00000094H
	push	edx
	call	?setVictories@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; CvPreGame::setVictories
	add	esp, 4

; 273  : 	CvPreGame::SetGameOptions(m_aGameOptions);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	call	?SetGameOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; CvPreGame::SetGameOptions
	add	esp, 4

; 274  : 	CvPreGame::SetMapOptions(m_aMapOptions);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 184				; 000000b8H
	push	ecx
	call	?SetMapOptions@CvPreGame@@YA_NABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; CvPreGame::SetMapOptions
	add	esp, 4

; 275  : 	CvPreGame::setMultiplayerOptions(m_abMPOptions);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	push	edx
	call	?setMultiplayerOptions@CvPreGame@@YAXABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; CvPreGame::setMultiplayerOptions
	add	esp, 4

; 276  : 	CvPreGame::setMaxTurns(m_iMaxTurns);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	call	?setMaxTurns@CvPreGame@@YAXH@Z		; CvPreGame::setMaxTurns
	add	esp, 4

; 277  : 	CvPreGame::setMaxCityElimination(m_iMaxCityElimination);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+228]
	push	eax
	call	?setMaxCityElimination@CvPreGame@@YAXH@Z ; CvPreGame::setMaxCityElimination
	add	esp, 4

; 278  : 	CvPreGame::setNumMinorCivs(m_iNumMinorCivs);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+232]
	push	edx
	call	?setNumMinorCivs@CvPreGame@@YAXH@Z	; CvPreGame::setNumMinorCivs
	add	esp, 4

; 279  : 	CvPreGame::setAdvancedStartPoints(m_iNumAdvancedStartPoints);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+236]
	push	ecx
	call	?setAdvancedStartPoints@CvPreGame@@YAXH@Z ; CvPreGame::setAdvancedStartPoints
	add	esp, 4

; 280  : 	CvPreGame::setGameMode(m_eMode);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+240]
	push	eax
	call	?setGameMode@CvPreGame@@YAXW4GameMode@@@Z ; CvPreGame::setGameMode
	add	esp, 4

; 281  : 
; 282  : 	return true;

	mov	BYTE PTR $T220196[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMapScriptPath$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T220196[ebp]

; 283  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Commit@CvDllNetInitInfo@@UAG_NXZ$0:
	lea	ecx, DWORD PTR _strMapScriptPath$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?Commit@CvDllNetInitInfo@@UAG_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Commit@CvDllNetInitInfo@@UAG_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Commit@CvDllNetInitInfo@@UAG_NXZ ENDP			; CvDllNetInitInfo::Commit
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z	; stdext::unchecked_copy<unsigned int *,unsigned int *>
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__CxxThrowException@8:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv224 = -308						; size = 4
_this$ = -304						; size = 4
$T220499 = -300						; size = 4
$T220498 = -296						; size = 4
$T220497 = -292						; size = 4
$T220442 = -176						; size = 4
$T220438 = -172						; size = 4
$T220437 = -168						; size = 4
$T220433 = -164						; size = 4
$T220432 = -160						; size = 4
$T220421 = -156						; size = 4
$T220420 = -152						; size = 4
__Cat$220428 = -146					; size = 1
$T220426 = -145						; size = 1
$T220401 = -144						; size = 4
$T220400 = -140						; size = 4
$T220348 = -84						; size = 4
$T220341 = -80						; size = 4
$T220330 = -76						; size = 4
$T220329 = -72						; size = 4
__Cat$220337 = -68					; size = 1
$T220335 = -67						; size = 1
$T220285 = -40						; size = 4
$T220256 = -36						; size = 4
$T220240 = -32						; size = 4
$T220268 = -28						; size = 4
$T220267 = -24						; size = 4
$T220266 = -20						; size = 4
$T220265 = -16						; size = 4
$T220264 = -12						; size = 4
__Ptr$218418 = -8					; size = 4
__Ptr$218415 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	test	eax, eax
	jne	SHORT $LN8@operator

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220240[ebp], edx
	mov	eax, DWORD PTR $T220240[ebp]
	mov	DWORD PTR $T220265[ebp], eax
	mov	ecx, DWORD PTR $T220265[ebp]
	mov	DWORD PTR $T220264[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220256[ebp], eax
	mov	ecx, DWORD PTR $T220256[ebp]
	mov	DWORD PTR $T220267[ebp], ecx
	mov	edx, DWORD PTR $T220267[ebp]
	mov	DWORD PTR $T220266[ebp], edx
	mov	eax, DWORD PTR $T220264[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220266[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220268[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator
$LN8@operator:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T220285[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR $T220285[ebp], edx
	ja	SHORT $LN6@operator

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$218415[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220341[ebp], ecx
	mov	edx, DWORD PTR $T220341[ebp]
	mov	DWORD PTR $T220330[ebp], edx
	mov	eax, DWORD PTR __Ptr$218415[ebp]
	mov	DWORD PTR $T220329[ebp], eax
	mov	cl, BYTE PTR __Cat$220337[ebp]
	mov	BYTE PTR $T220335[ebp], cl

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	jmp	$LN9@operator
$LN6@operator:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T220348[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN55@operator
	mov	DWORD PTR tv224[ebp], 0
	jmp	SHORT $LN53@operator
$LN55@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv224[ebp], eax
$LN53@operator:
	mov	ecx, DWORD PTR $T220348[ebp]
	cmp	ecx, DWORD PTR tv224[ebp]
	ja	$LN4@operator

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR __Ptr$218418[ebp], ecx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Ptr$218418[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220401[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220400[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220401[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220400[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$218418[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator
$LN4@operator:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN2@operator

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220433[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220432[ebp], eax
	mov	ecx, DWORD PTR $T220433[ebp]
	mov	DWORD PTR $T220421[ebp], ecx
	mov	edx, DWORD PTR $T220432[ebp]
	mov	DWORD PTR $T220420[ebp], edx
	mov	al, BYTE PTR __Cat$220428[ebp]
	mov	BYTE PTR $T220426[ebp], al

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T220438[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220437[ebp], edx
	mov	eax, DWORD PTR $T220437[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T220442[ebp], eax
	mov	ecx, DWORD PTR $T220442[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@operator

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220499[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220498[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220497[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220499[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220498[ebp]
	push	edx
	mov	eax, DWORD PTR $T220497[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN9@operator:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T220531 = -30						; size = 1
$T220518 = -29						; size = 1
$T220514 = -28						; size = 4
$T220507 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T220531[ebp]
	mov	DWORD PTR $T220507[ebp], eax
	lea	ecx, DWORD PTR $T220518[ebp]
	mov	DWORD PTR $T220514[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
PUBLIC	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
PUBLIC	?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase
EXTRN	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z:PROC ; CvPreGame::CustomOption::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv241 = -300						; size = 4
_this$ = -296						; size = 4
$T221054 = -292						; size = 4
$T221053 = -288						; size = 4
$T221052 = -284						; size = 4
$T221042 = -280						; size = 4
$T221041 = -276						; size = 4
__Cat$221050 = -271					; size = 1
$T221048 = -270						; size = 1
$T221047 = -269						; size = 1
$T220991 = -180						; size = 4
$T220987 = -176						; size = 4
$T220986 = -172						; size = 4
$T220982 = -168						; size = 4
$T220981 = -164						; size = 4
$T220963 = -160						; size = 4
$T220962 = -156						; size = 4
$T220946 = -152						; size = 4
__Cat$220971 = -146					; size = 1
$T220968 = -145						; size = 1
$T220920 = -144						; size = 4
$T220919 = -140						; size = 4
$T220909 = -136						; size = 4
$T220908 = -132						; size = 4
__Cat$220916 = -127					; size = 1
$T220913 = -126						; size = 1
$T220912 = -125						; size = 1
$T220892 = -124						; size = 4
$T220891 = -120						; size = 4
$T220874 = -114						; size = 1
$T220873 = -113						; size = 1
$T220872 = -112						; size = 4
$T220871 = -108						; size = 4
__Cat$220882 = -100					; size = 1
$T220879 = -99						; size = 1
$T220878 = -98						; size = 1
$T220877 = -97						; size = 1
$T220842 = -96						; size = 4
$T220835 = -92						; size = 4
$T220817 = -88						; size = 4
$T220816 = -84						; size = 4
$T220800 = -80						; size = 4
__Cat$220824 = -74					; size = 1
$T220821 = -73						; size = 1
$T220774 = -72						; size = 4
$T220773 = -68						; size = 4
$T220772 = -64						; size = 4
$T220755 = -58						; size = 1
$T220754 = -57						; size = 1
$T220753 = -56						; size = 4
$T220752 = -52						; size = 4
__Cat$220762 = -44					; size = 1
$T220759 = -43						; size = 1
$T220758 = -42						; size = 1
$T220757 = -41						; size = 1
$T220730 = -40						; size = 4
$T220701 = -36						; size = 4
$T220685 = -32						; size = 4
$T220714 = -28						; size = 4
$T220713 = -24						; size = 4
$T220712 = -20						; size = 4
$T220711 = -16						; size = 4
$T220710 = -12						; size = 4
__Ptr$218455 = -8					; size = 4
__Ptr$218445 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@2

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN8@operator@2

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220685[ebp], eax
	mov	ecx, DWORD PTR $T220685[ebp]
	mov	DWORD PTR $T220711[ebp], ecx
	mov	edx, DWORD PTR $T220711[ebp]
	mov	DWORD PTR $T220710[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220701[ebp], ecx
	mov	edx, DWORD PTR $T220701[ebp]
	mov	DWORD PTR $T220713[ebp], edx
	mov	eax, DWORD PTR $T220713[ebp]
	mov	DWORD PTR $T220712[ebp], eax
	mov	ecx, DWORD PTR $T220710[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220712[ebp]
	push	edx
	lea	eax, DWORD PTR $T220714[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase

; 573  : 			else if (_Right.size() <= size())

	jmp	$LN9@operator@2
$LN8@operator@2:
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T220730[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	cmp	DWORD PTR $T220730[ebp], eax
	ja	$LN6@operator@2

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220774[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220773[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220772[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220757[ebp], dl
	mov	al, BYTE PTR __Cat$220762[ebp]
	mov	BYTE PTR $T220758[ebp], al
	mov	cl, BYTE PTR $T220757[ebp]
	mov	BYTE PTR $T220755[ebp], cl
	mov	dl, BYTE PTR $T220759[ebp]
	mov	BYTE PTR $T220754[ebp], dl
	mov	eax, DWORD PTR $T220774[ebp]
	mov	DWORD PTR $T220753[ebp], eax
	mov	ecx, DWORD PTR $T220772[ebp]
	mov	DWORD PTR $T220752[ebp], ecx
	jmp	SHORT $LN40@operator@2
$LN39@operator@2:
	mov	edx, DWORD PTR $T220753[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T220753[ebp], edx
	mov	eax, DWORD PTR $T220752[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR $T220752[ebp], eax
$LN40@operator@2:
	mov	ecx, DWORD PTR $T220752[ebp]
	cmp	ecx, DWORD PTR $T220773[ebp]
	je	SHORT $LN32@operator@2
	mov	edx, DWORD PTR $T220752[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220753[ebp]
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	jmp	SHORT $LN39@operator@2
$LN32@operator@2:
	mov	eax, DWORD PTR $T220753[ebp]
	mov	DWORD PTR __Ptr$218445[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220835[ebp], edx
	mov	eax, DWORD PTR $T220835[ebp]
	mov	DWORD PTR $T220817[ebp], eax
	mov	ecx, DWORD PTR __Ptr$218445[ebp]
	mov	DWORD PTR $T220816[ebp], ecx
	mov	dl, BYTE PTR __Cat$220824[ebp]
	mov	BYTE PTR $T220821[ebp], dl
	mov	eax, DWORD PTR $T220816[ebp]
	mov	DWORD PTR $T220800[ebp], eax
	jmp	SHORT $LN51@operator@2
$LN50@operator@2:
	mov	ecx, DWORD PTR $T220800[ebp]
	add	ecx, 68					; 00000044H
	mov	DWORD PTR $T220800[ebp], ecx
$LN51@operator@2:
	mov	edx, DWORD PTR $T220800[ebp]
	cmp	edx, DWORD PTR $T220817[ebp]
	je	SHORT $LN58@operator@2
	jmp	SHORT $LN50@operator@2

; 578  : 				_Mylast = _Myfirst + _Right.size();

$LN58@operator@2:
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	imul	eax, 68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
	jmp	$LN9@operator@2
$LN6@operator@2:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T220842[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN64@operator@2
	mov	DWORD PTR tv241[ebp], 0
	jmp	SHORT $LN62@operator@2
$LN64@operator@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR tv241[ebp], eax
$LN62@operator@2:
	mov	edx, DWORD PTR $T220842[ebp]
	cmp	edx, DWORD PTR tv241[ebp]
	ja	$LN4@operator@2

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	imul	eax, 68					; 00000044H
	mov	edx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$218455[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T220892[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220891[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220877[ebp], cl
	mov	dl, BYTE PTR __Cat$220882[ebp]
	mov	BYTE PTR $T220878[ebp], dl
	mov	al, BYTE PTR $T220877[ebp]
	mov	BYTE PTR $T220874[ebp], al
	mov	cl, BYTE PTR $T220879[ebp]
	mov	BYTE PTR $T220873[ebp], cl
	mov	edx, DWORD PTR $T220892[ebp]
	mov	DWORD PTR $T220872[ebp], edx
	mov	eax, DWORD PTR $T220891[ebp]
	mov	DWORD PTR $T220871[ebp], eax
	jmp	SHORT $LN76@operator@2
$LN75@operator@2:
	mov	ecx, DWORD PTR $T220872[ebp]
	add	ecx, 68					; 00000044H
	mov	DWORD PTR $T220872[ebp], ecx
	mov	edx, DWORD PTR $T220871[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T220871[ebp], edx
$LN76@operator@2:
	mov	eax, DWORD PTR $T220871[ebp]
	cmp	eax, DWORD PTR __Ptr$218455[ebp]
	je	SHORT $LN68@operator@2
	mov	ecx, DWORD PTR $T220871[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T220872[ebp]
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	jmp	SHORT $LN75@operator@2
$LN68@operator@2:

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220920[ebp], eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220919[ebp], edx
	mov	eax, DWORD PTR $T220920[ebp]
	mov	DWORD PTR $T220909[ebp], eax
	mov	ecx, DWORD PTR __Ptr$218455[ebp]
	mov	DWORD PTR $T220908[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220912[ebp], dl
	mov	al, BYTE PTR __Cat$220916[ebp]
	mov	BYTE PTR $T220913[ebp], al
	movzx	ecx, BYTE PTR $T220912[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T220913[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220909[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220919[ebp]
	push	edx
	mov	eax, DWORD PTR $T220908[ebp]
	push	eax
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@2
$LN4@operator@2:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN2@operator@2

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220982[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220981[ebp], eax
	mov	ecx, DWORD PTR $T220982[ebp]
	mov	DWORD PTR $T220963[ebp], ecx
	mov	edx, DWORD PTR $T220981[ebp]
	mov	DWORD PTR $T220962[ebp], edx
	mov	al, BYTE PTR __Cat$220971[ebp]
	mov	BYTE PTR $T220968[ebp], al
	mov	ecx, DWORD PTR $T220962[ebp]
	mov	DWORD PTR $T220946[ebp], ecx
	jmp	SHORT $LN93@operator@2
$LN92@operator@2:
	mov	edx, DWORD PTR $T220946[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T220946[ebp], edx
$LN93@operator@2:
	mov	eax, DWORD PTR $T220946[ebp]
	cmp	eax, DWORD PTR $T220963[ebp]
	je	SHORT $LN85@operator@2
	jmp	SHORT $LN92@operator@2
$LN85@operator@2:

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T220987[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220986[ebp], eax
	mov	ecx, DWORD PTR $T220986[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@operator@2:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T220991[ebp], eax
	mov	edx, DWORD PTR $T220991[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	$LN9@operator@2

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221054[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221053[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221052[ebp], eax
	mov	ecx, DWORD PTR $T221054[ebp]
	mov	DWORD PTR $T221042[ebp], ecx
	mov	edx, DWORD PTR $T221052[ebp]
	mov	DWORD PTR $T221041[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T221047[ebp], al
	mov	cl, BYTE PTR __Cat$221050[ebp]
	mov	BYTE PTR $T221048[ebp], cl
	movzx	edx, BYTE PTR $T221047[ebp]
	push	edx
	movzx	eax, BYTE PTR $T221048[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221042[ebp]
	push	edx
	mov	eax, DWORD PTR $T221053[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221041[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN9@operator@2:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::~_Vector_val<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
_TEXT	ENDS
PUBLIC	??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ; std::_Allocate<CvPreGame::CustomOption>
PUBLIC	?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$221075 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$221075[ebp], 63161283	; 03c3c3c3H
	cmp	DWORD PTR __Count$221075[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$221075[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ; std::_Allocate<CvPreGame::CustomOption>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T221171 = -32						; size = 4
$T221170 = -28						; size = 4
$T221166 = -24						; size = 4
$T221165 = -20						; size = 4
$T221147 = -16						; size = 4
$T221146 = -12						; size = 4
$T221130 = -8						; size = 4
__Cat$221154 = -2					; size = 1
$T221152 = -1						; size = 1
?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221166[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221165[ebp], ecx
	mov	edx, DWORD PTR $T221166[ebp]
	mov	DWORD PTR $T221147[ebp], edx
	mov	eax, DWORD PTR $T221165[ebp]
	mov	DWORD PTR $T221146[ebp], eax
	mov	cl, BYTE PTR __Cat$221154[ebp]
	mov	BYTE PTR $T221152[ebp], cl
	mov	edx, DWORD PTR $T221146[ebp]
	mov	DWORD PTR $T221130[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T221130[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR $T221130[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T221130[ebp]
	cmp	ecx, DWORD PTR $T221147[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T221171[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221170[ebp], eax
	mov	ecx, DWORD PTR $T221170[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T221313 = -64						; size = 4
$T221295 = -60						; size = 4
$T221294 = -56						; size = 4
$T221278 = -52						; size = 4
__Cat$221301 = -46					; size = 1
$T221298 = -45						; size = 1
$T221252 = -44						; size = 4
$T221251 = -40						; size = 4
$T221250 = -36						; size = 4
$T221233 = -30						; size = 1
$T221232 = -29						; size = 1
$T221231 = -28						; size = 4
$T221230 = -24						; size = 4
__Cat$221240 = -16					; size = 1
$T221237 = -15						; size = 1
$T221236 = -14						; size = 1
$T221235 = -13						; size = 1
__Ptr$218676 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T221252[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221251[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T221250[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T221235[ebp], cl
	mov	dl, BYTE PTR __Cat$221240[ebp]
	mov	BYTE PTR $T221236[ebp], dl
	mov	al, BYTE PTR $T221235[ebp]
	mov	BYTE PTR $T221233[ebp], al
	mov	cl, BYTE PTR $T221237[ebp]
	mov	BYTE PTR $T221232[ebp], cl
	mov	edx, DWORD PTR $T221252[ebp]
	mov	DWORD PTR $T221231[ebp], edx
	mov	eax, DWORD PTR $T221250[ebp]
	mov	DWORD PTR $T221230[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T221231[ebp]
	add	ecx, 68					; 00000044H
	mov	DWORD PTR $T221231[ebp], ecx
	mov	edx, DWORD PTR $T221230[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T221230[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T221230[ebp]
	cmp	eax, DWORD PTR $T221251[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T221230[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221231[ebp]
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	edx, DWORD PTR $T221231[ebp]
	mov	DWORD PTR __Ptr$218676[ebp], edx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221313[ebp], ecx
	mov	edx, DWORD PTR $T221313[ebp]
	mov	DWORD PTR $T221295[ebp], edx
	mov	eax, DWORD PTR __Ptr$218676[ebp]
	mov	DWORD PTR $T221294[ebp], eax
	mov	cl, BYTE PTR __Cat$221301[ebp]
	mov	BYTE PTR $T221298[ebp], cl
	mov	edx, DWORD PTR $T221294[ebp]
	mov	DWORD PTR $T221278[ebp], edx
	jmp	SHORT $LN39@erase
$LN38@erase:
	mov	eax, DWORD PTR $T221278[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR $T221278[ebp], eax
$LN39@erase:
	mov	ecx, DWORD PTR $T221278[ebp]
	cmp	ecx, DWORD PTR $T221295[ebp]
	je	SHORT $LN31@erase
	jmp	SHORT $LN38@erase
$LN31@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$218676[ebp]
	mov	DWORD PTR [edx+8], eax
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221317 = -80						; size = 28
$T221316 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221317[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T221316[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T221316[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T221317[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221316[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T221316[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221316[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T221317[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221317[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221316[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen
PUBLIC	??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z PROC ; operator>><CvPreGame::CustomOption>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ENDP ; operator>><CvPreGame::CustomOption>
_TEXT	ENDS
EXTRN	??6CvPreGame@@YAAAVFDataStream@@AAV1@ABVCustomOption@0@@Z:PROC ; CvPreGame::operator<<
; Function compile flags: /Odtp
;	COMDAT ??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z
_TEXT	SEGMENT
$T221416 = -68						; size = 8
$T221415 = -60						; size = 4
$T221414 = -56						; size = 4
$T221396 = -52						; size = 4
__ChkFirst$221409 = -48					; size = 4
__ChkLast$221410 = -44					; size = 4
$T221373 = -40						; size = 4
$T221364 = -36						; size = 4
$T221352 = -32						; size = 4
$T221354 = -28						; size = 4
$T221343 = -24						; size = 8
$T221342 = -16						; size = 4
$T221341 = -12						; size = 4
$T221340 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z PROC ; operator<<<CvPreGame::CustomOption>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T221340[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T221340[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T221354[ebp], eax
	mov	edx, DWORD PTR $T221340[ebp]
	mov	DWORD PTR $T221352[ebp], edx
	lea	eax, DWORD PTR $T221354[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221352[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221364[ebp], edx
	mov	eax, DWORD PTR $T221364[ebp]
	mov	DWORD PTR $T221341[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221373[ebp], edx
	mov	eax, DWORD PTR $T221373[ebp]
	mov	DWORD PTR $T221342[ebp], eax
	mov	ecx, DWORD PTR $T221340[ebp]
	mov	DWORD PTR $T221416[ebp], ecx
	mov	edx, DWORD PTR $T221340[ebp+4]
	mov	DWORD PTR $T221416[ebp+4], edx
	mov	eax, DWORD PTR $T221341[ebp]
	mov	DWORD PTR $T221415[ebp], eax
	mov	ecx, DWORD PTR $T221342[ebp]
	mov	DWORD PTR $T221414[ebp], ecx
	mov	edx, DWORD PTR $T221414[ebp]
	mov	DWORD PTR __ChkFirst$221409[ebp], edx
	mov	eax, DWORD PTR $T221415[ebp]
	mov	DWORD PTR __ChkLast$221410[ebp], eax
	jmp	SHORT $LN24@operator@3
$LN18@operator@3:
	mov	ecx, DWORD PTR __ChkFirst$221409[ebp]
	add	ecx, 68					; 00000044H
	mov	DWORD PTR __ChkFirst$221409[ebp], ecx
$LN24@operator@3:
	mov	edx, DWORD PTR __ChkFirst$221409[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __ChkLast$221410[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN17@operator@3
	mov	eax, DWORD PTR __ChkFirst$221409[ebp]
	mov	DWORD PTR $T221396[ebp], eax
	mov	ecx, DWORD PTR $T221396[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221416[ebp]
	push	edx
	call	??6CvPreGame@@YAAAVFDataStream@@AAV1@ABVCustomOption@0@@Z ; CvPreGame::operator<<
	add	esp, 8
	jmp	SHORT $LN18@operator@3
$LN17@operator@3:
	mov	eax, DWORD PTR $T221416[ebp]
	mov	DWORD PTR $T221343[ebp], eax
	mov	ecx, DWORD PTR $T221416[ebp+4]
	mov	DWORD PTR $T221343[ebp+4], ecx

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6VCustomOption@CvPreGame@@@@YAAAVFDataStream@@AAV0@ABV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ENDP ; operator<<<CvPreGame::CustomOption>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z
_TEXT	SEGMENT
$T221423 = -16						; size = 4
$T221419 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z PROC ; std::_Allocate<CvPreGame::CustomOption>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 68					; 00000044H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T221423[ebp], 0
	lea	eax, DWORD PTR $T221423[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221419[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T221419[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221419[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 68					; 00000044H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ENDP ; std::_Allocate<CvPreGame::CustomOption>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
PUBLIC	?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back
PUBLIC	__$ArrayPad$
EXTRN	??5CvPreGame@@YAAAVFDataStream@@AAV1@AAVCustomOption@0@@Z:PROC ; CvPreGame::operator>>
EXTRN	??0CustomOption@CvPreGame@@QAE@XZ:PROC		; CvPreGame::CustomOption::CustomOption
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z
_TEXT	SEGMENT
$T221460 = -116						; size = 4
$T221444 = -112						; size = 4
$T221613 = -108						; size = 4
$T221612 = -104						; size = 4
$T221611 = -100						; size = 4
$T221610 = -96						; size = 4
$T221609 = -92						; size = 4
_v$218916 = -88						; size = 68
__$ArrayPad$ = -12					; size = 4
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 84   : 	container.clear();

	mov	eax, DWORD PTR _container$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221444[ebp], ecx
	mov	edx, DWORD PTR $T221444[ebp]
	mov	DWORD PTR $T221610[ebp], edx
	mov	eax, DWORD PTR $T221610[ebp]
	mov	DWORD PTR $T221609[ebp], eax
	mov	ecx, DWORD PTR _container$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T221460[ebp], edx
	mov	eax, DWORD PTR $T221460[ebp]
	mov	DWORD PTR $T221612[ebp], eax
	mov	ecx, DWORD PTR $T221612[ebp]
	mov	DWORD PTR $T221611[ebp], ecx
	mov	edx, DWORD PTR $T221609[ebp]
	push	edx
	mov	eax, DWORD PTR $T221611[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221613[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?erase@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@0@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::erase

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	edx, DWORD PTR _count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT
$LN2@SerializeT:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@SerializeT:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT

; 89   : 	{
; 90   : 		ElementType v;

	lea	ecx, DWORD PTR _v$218916[ebp]
	call	??0CustomOption@CvPreGame@@QAE@XZ	; CvPreGame::CustomOption::CustomOption

; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$218916[ebp]
	push	edx
	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	call	??5CvPreGame@@YAAAVFDataStream@@AAV1@AAVCustomOption@0@@Z ; CvPreGame::operator>>
	add	esp, 8

; 92   : 		container.push_back(v);

	lea	ecx, DWORD PTR _v$218916[ebp]
	push	ecx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back

; 93   : 	}

	jmp	SHORT $LN2@SerializeT
$LN4@SerializeT:

; 94   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@VCustomOption@CvPreGame@@V?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<CvPreGame::CustomOption,std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert
PUBLIC	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T221802 = -32						; size = 4
$T221792 = -28						; size = 4
$T221782 = -24						; size = 4
__Cat$221789 = -19					; size = 1
$T221786 = -18						; size = 1
$T221785 = -17						; size = 1
$T221759 = -16						; size = 4
$T221755 = -12						; size = 4
$T221754 = -8						; size = 4
$T221753 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T221759[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	edx, DWORD PTR $T221759[ebp]
	cmp	edx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221792[ebp], ecx
	mov	edx, DWORD PTR $T221792[ebp]
	mov	DWORD PTR $T221782[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T221785[ebp], al
	mov	cl, BYTE PTR __Cat$221789[ebp]
	mov	BYTE PTR $T221786[ebp], cl
	movzx	edx, BYTE PTR $T221785[ebp]
	push	edx
	movzx	eax, BYTE PTR $T221786[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR $T221782[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H
	mov	ecx, 1
	imul	ecx, 68					; 00000044H
	add	ecx, DWORD PTR $T221792[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T221802[ebp], ecx
	mov	edx, DWORD PTR $T221802[ebp]
	mov	DWORD PTR $T221754[ebp], edx
	mov	eax, DWORD PTR $T221754[ebp]
	mov	DWORD PTR $T221753[ebp], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T221753[ebp]
	push	edx
	lea	eax, DWORD PTR $T221755[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAEXABVCustomOption@CvPreGame@@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$221927 = -24					; size = 4
$T221905 = -20						; size = 4
$T221886 = -16						; size = 4
$T221873 = -12						; size = 4
$T221870 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221886[ebp], eax
	mov	ecx, DWORD PTR $T221886[ebp]
	mov	DWORD PTR $T221870[ebp], ecx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T221870[ebp]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], edx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221905[ebp], eax
	mov	ecx, DWORD PTR $T221905[ebp]
	mov	DWORD PTR $T221873[ebp], ecx
	mov	edx, DWORD PTR $T221873[ebp]
	mov	DWORD PTR __Tmp$221927[ebp], edx
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 68					; 00000044H
	add	eax, DWORD PTR __Tmp$221927[ebp]
	mov	DWORD PTR __Tmp$221927[ebp], eax
	mov	ecx, DWORD PTR __Tmp$221927[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@QAE?AV?$_Vector_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@V?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@ABVCustomOption@CvPreGame@@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
PUBLIC	??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
PUBLIC	__$ArrayPad$
EXTRN	??0CustomOption@CvPreGame@@QAE@ABV01@@Z:PROC	; CvPreGame::CustomOption::CustomOption
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$2
__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$0
__unwindtable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
_TEXT	SEGMENT
tv84 = -564						; size = 4
tv306 = -560						; size = 4
tv292 = -556						; size = 4
tv284 = -552						; size = 4
_this$ = -548						; size = 4
$T222588 = -544						; size = 4
$T222537 = -504						; size = 4
$T222518 = -500						; size = 4
$T222501 = -493						; size = 1
$T222500 = -492						; size = 4
$T222490 = -488						; size = 4
$T222489 = -484						; size = 4
__Cat$222534 = -478					; size = 1
$T222531 = -477						; size = 1
$T222530 = -476						; size = 1
__Cat$222525 = -475					; size = 1
$T222523 = -474						; size = 1
$T222522 = -473						; size = 1
$T222465 = -472						; size = 4
$T222457 = -468						; size = 4
$T222449 = -464						; size = 4
$T222431 = -460						; size = 4
$T222430 = -456						; size = 4
$T222414 = -452						; size = 4
__Cat$222437 = -446					; size = 1
$T222434 = -445						; size = 1
$T222388 = -444						; size = 4
$T222387 = -440						; size = 4
$T222377 = -436						; size = 4
__Cat$222384 = -431					; size = 1
$T222381 = -430						; size = 1
$T222380 = -429						; size = 1
$T222361 = -428						; size = 4
$T222342 = -424						; size = 4
$T222325 = -417						; size = 1
$T222324 = -416						; size = 4
$T222314 = -412						; size = 4
$T222313 = -408						; size = 4
__Cat$222357 = -402					; size = 1
$T222354 = -401						; size = 1
$T222353 = -400						; size = 1
__Cat$222349 = -399					; size = 1
$T222347 = -398						; size = 1
$T222346 = -397						; size = 1
$T222289 = -396						; size = 4
$T222288 = -392						; size = 4
$T222284 = -388						; size = 4
$T222283 = -384						; size = 4
$T222265 = -380						; size = 4
$T222264 = -376						; size = 4
$T222248 = -372						; size = 4
__Cat$222271 = -366					; size = 1
$T222268 = -365						; size = 1
$T222199 = -364						; size = 4
$T222198 = -360						; size = 4
$T222182 = -356						; size = 4
__Cat$222206 = -350					; size = 1
$T222204 = -349						; size = 1
$T222139 = -348						; size = 4
$T222138 = -344						; size = 4
$T222122 = -340						; size = 4
__Cat$222146 = -334					; size = 1
$T222144 = -333						; size = 1
$T222096 = -332						; size = 4
$T222084 = -328						; size = 4
$T222074 = -321						; size = 1
$T222073 = -320						; size = 4
__Cat$222091 = -315					; size = 1
$T222089 = -314						; size = 1
$T222088 = -313						; size = 1
$T222061 = -312						; size = 4
$T222049 = -308						; size = 4
$T222039 = -301						; size = 1
$T222038 = -300						; size = 4
__Cat$222056 = -295					; size = 1
$T222054 = -294						; size = 1
$T222053 = -293						; size = 1
$T222026 = -292						; size = 4
$T222016 = -288						; size = 4
__Cat$222023 = -283					; size = 1
$T222020 = -282						; size = 1
$T222019 = -281						; size = 1
__Count$221986 = -268					; size = 4
__Count$221960 = -196					; size = 4
__Tmp$219052 = -192					; size = 68
__Oldend$219053 = -116					; size = 4
__Tmp$219042 = -112					; size = 68
__$ArrayPad$ = -36					; size = 4
__Ncopied$219029 = -32					; size = 4
__Newvec$219027 = -28					; size = 4
__Whereoff$219028 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z PROC ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 548				; 00000224H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv284[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR tv284[ebp], eax
$LN27@Insert_n:
	mov	edx, DWORD PTR tv284[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$221960[ebp], 63161283	; 03c3c3c3H
	cmp	DWORD PTR __Count$221960[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	eax, DWORD PTR __Count$221960[ebp]
	mov	DWORD PTR tv292[ebp], eax
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv292[ebp], 1
$LN37@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	edx, DWORD PTR tv292[ebp]
	sub	edx, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@KAXXZ ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$221986[ebp], 63161283	; 03c3c3c3H
	cmp	DWORD PTR __Count$221986[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	edx, DWORD PTR __Count$221986[ebp]
	mov	DWORD PTR tv306[ebp], edx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv306[ebp], 1
$LN44@Insert_n:
	mov	eax, DWORD PTR __Capacity$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR tv306[ebp]
	sub	ecx, eax
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@VCustomOption@CvPreGame@@@std@@YAPAVCustomOption@CvPreGame@@IPAV12@@Z ; std::_Allocate<CvPreGame::CustomOption>
	add	esp, 8
	mov	DWORD PTR __Newvec$219027[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR __Whereoff$219028[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$219029[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Whereoff$219028[ebp]
	imul	edx, 68					; 00000044H
	add	edx, DWORD PTR __Newvec$219027[ebp]
	mov	DWORD PTR $T222026[ebp], edx
	mov	eax, DWORD PTR $T222026[ebp]
	mov	DWORD PTR $T222016[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222019[ebp], cl
	mov	dl, BYTE PTR __Cat$222023[ebp]
	mov	BYTE PTR $T222020[ebp], dl
	movzx	eax, BYTE PTR $T222019[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T222020[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222016[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$219029[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$219029[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T222061[ebp], edx
	mov	eax, DWORD PTR __Newvec$219027[ebp]
	mov	DWORD PTR $T222049[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222053[ebp], cl
	mov	dl, BYTE PTR __Cat$222056[ebp]
	mov	BYTE PTR $T222054[ebp], dl
	mov	al, BYTE PTR $T222053[ebp]
	mov	BYTE PTR $T222039[ebp], al
	mov	ecx, DWORD PTR $T222049[ebp]
	mov	DWORD PTR $T222038[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T222038[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222061[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$219029[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$219029[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T222096[ebp], edx
	mov	eax, DWORD PTR __Whereoff$219028[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	imul	eax, 68					; 00000044H
	add	eax, DWORD PTR __Newvec$219027[ebp]
	mov	DWORD PTR $T222084[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T222088[ebp], cl
	mov	dl, BYTE PTR __Cat$222091[ebp]
	mov	BYTE PTR $T222089[ebp], dl
	mov	al, BYTE PTR $T222088[ebp]
	mov	BYTE PTR $T222074[ebp], al
	mov	ecx, DWORD PTR $T222084[ebp]
	mov	DWORD PTR $T222073[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T222073[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222096[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$219029[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$219028[ebp]
	imul	eax, 68					; 00000044H
	add	eax, DWORD PTR __Newvec$219027[ebp]
	mov	DWORD PTR $T222139[ebp], eax
	mov	ecx, DWORD PTR __Newvec$219027[ebp]
	mov	DWORD PTR $T222138[ebp], ecx
	mov	dl, BYTE PTR __Cat$222146[ebp]
	mov	BYTE PTR $T222144[ebp], dl
	mov	eax, DWORD PTR $T222138[ebp]
	mov	DWORD PTR $T222122[ebp], eax
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	ecx, DWORD PTR $T222122[ebp]
	add	ecx, 68					; 00000044H
	mov	DWORD PTR $T222122[ebp], ecx
$LN91@Insert_n:
	mov	edx, DWORD PTR $T222122[ebp]
	cmp	edx, DWORD PTR $T222139[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$219029[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 68					; 00000044H
	mov	ecx, DWORD PTR __Whereoff$219028[ebp]
	imul	ecx, 68					; 00000044H
	add	ecx, DWORD PTR __Newvec$219027[ebp]
	add	ecx, eax
	mov	DWORD PTR $T222199[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$219028[ebp]
	imul	edx, 68					; 00000044H
	add	edx, DWORD PTR __Newvec$219027[ebp]
	mov	DWORD PTR $T222198[ebp], edx
	mov	al, BYTE PTR __Cat$222206[ebp]
	mov	BYTE PTR $T222204[ebp], al
	mov	ecx, DWORD PTR $T222198[ebp]
	mov	DWORD PTR $T222182[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T222182[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T222182[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T222182[ebp]
	cmp	eax, DWORD PTR $T222199[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$219027[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222284[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T222283[ebp], eax
	mov	ecx, DWORD PTR $T222284[ebp]
	mov	DWORD PTR $T222265[ebp], ecx
	mov	edx, DWORD PTR $T222283[ebp]
	mov	DWORD PTR $T222264[ebp], edx
	mov	al, BYTE PTR __Cat$222271[ebp]
	mov	BYTE PTR $T222268[ebp], al
	mov	ecx, DWORD PTR $T222264[ebp]
	mov	DWORD PTR $T222248[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T222248[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T222248[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T222248[ebp]
	cmp	eax, DWORD PTR $T222265[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	DWORD PTR $T222289[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T222288[ebp], eax
	mov	ecx, DWORD PTR $T222288[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 68					; 00000044H
	add	edx, DWORD PTR __Newvec$219027[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 68					; 00000044H
	add	ecx, DWORD PTR __Newvec$219027[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$219027[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$219042[ebp]
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222361[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 68					; 00000044H
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222342[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222346[ebp], al
	mov	cl, BYTE PTR __Cat$222349[ebp]
	mov	BYTE PTR $T222347[ebp], cl
	mov	dl, BYTE PTR $T222346[ebp]
	mov	BYTE PTR $T222325[ebp], dl
	mov	eax, DWORD PTR $T222342[ebp]
	mov	DWORD PTR $T222324[ebp], eax
	mov	ecx, DWORD PTR $T222324[ebp]
	mov	DWORD PTR $T222314[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222313[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222353[ebp], al
	mov	cl, BYTE PTR __Cat$222357[ebp]
	mov	BYTE PTR $T222354[ebp], cl
	movzx	edx, BYTE PTR $T222353[ebp]
	push	edx
	movzx	eax, BYTE PTR $T222354[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222314[ebp]
	push	edx
	mov	eax, DWORD PTR $T222361[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222313[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	cdq
	mov	ecx, 68					; 00000044H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	DWORD PTR $T222388[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222387[ebp], ecx
	mov	edx, DWORD PTR $T222387[ebp]
	mov	DWORD PTR $T222377[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222380[ebp], al
	mov	cl, BYTE PTR __Cat$222384[ebp]
	mov	BYTE PTR $T222381[ebp], cl
	movzx	edx, BYTE PTR $T222380[ebp]
	push	edx
	movzx	eax, BYTE PTR $T222381[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Tmp$219042[ebp]
	push	edx
	mov	eax, DWORD PTR $T222388[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222377[ebp]
	push	ecx
	call	??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	DWORD PTR $T222449[ebp], edx
	mov	ecx, DWORD PTR $T222449[ebp]
	mov	DWORD PTR $T222431[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 68					; 00000044H
	add	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222430[ebp], edx
	mov	al, BYTE PTR __Cat$222437[ebp]
	mov	BYTE PTR $T222434[ebp], al
	mov	ecx, DWORD PTR $T222430[ebp]
	mov	DWORD PTR $T222414[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T222414[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T222414[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T222414[ebp]
	cmp	eax, DWORD PTR $T222431[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	mov	DWORD PTR $T222465[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222457[ebp], ecx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	edx, DWORD PTR $T222457[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T222457[ebp], edx
$LN171@Insert_n:
	mov	eax, DWORD PTR $T222457[ebp]
	cmp	eax, DWORD PTR $T222465[ebp]
	je	SHORT $LN167@Insert_n
	lea	ecx, DWORD PTR __Tmp$219042[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222457[ebp]
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$219052[ebp]
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$219053[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T222537[ebp], eax
	mov	ecx, DWORD PTR $T222537[ebp]
	mov	DWORD PTR $T222518[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T222522[ebp], dl
	mov	al, BYTE PTR __Cat$222525[ebp]
	mov	BYTE PTR $T222523[ebp], al
	mov	cl, BYTE PTR $T222522[ebp]
	mov	BYTE PTR $T222501[ebp], cl
	mov	edx, DWORD PTR $T222518[ebp]
	mov	DWORD PTR $T222500[ebp], edx
	mov	eax, DWORD PTR $T222500[ebp]
	mov	DWORD PTR $T222490[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 68					; 00000044H
	mov	edx, DWORD PTR __Oldend$219053[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T222489[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222530[ebp], al
	mov	cl, BYTE PTR __Cat$222534[ebp]
	mov	BYTE PTR $T222531[ebp], cl
	movzx	edx, BYTE PTR $T222530[ebp]
	push	edx
	movzx	eax, BYTE PTR $T222531[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T222490[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$219053[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222489[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$219053[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 68					; 00000044H
	mov	edx, DWORD PTR __Oldend$219053[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T222588[ebp], ecx
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	edx, DWORD PTR $T222588[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR $T222588[ebp], edx
$LN204@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 68					; 00000044H
	add	eax, DWORD PTR __Where$[ebp]
	cmp	DWORD PTR $T222588[ebp], eax
	je	SHORT $LN16@Insert_n
	lea	ecx, DWORD PTR __Tmp$219052[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222588[ebp]
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-568]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCustomOption@CvPreGame@@V?$allocator@VCustomOption@CvPreGame@@@std@@@2@IABVCustomOption@CvPreGame@@@Z ENDP ; std::vector<CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z
_TEXT	SEGMENT
__Cat$222614 = -3					; size = 1
$T222610 = -2						; size = 1
$T222609 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T222609[ebp], al
	mov	cl, BYTE PTR __Cat$222614[ebp]
	mov	BYTE PTR $T222610[ebp], cl
	movzx	edx, BYTE PTR $T222609[ebp]
	push	edx
	movzx	eax, BYTE PTR $T222610[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -40						; size = 4
tv68 = -36						; size = 4
$T222668 = -32						; size = 4
$T222667 = -28						; size = 4
__Vptr$222665 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 68					; 00000044H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$222665[ebp], ecx
	mov	edx, DWORD PTR __Vptr$222665[ebp]
	mov	DWORD PTR $T222668[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T222668[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222668[ebp]
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], ecx
	jmp	SHORT $LN19@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_cop:
	mov	edx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T222667[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 68					; 00000044H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$222665[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222668[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCustomOption@CvPreGame@@PAV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAPAVCustomOption@CvPreGame@@PAV12@00AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvPreGame::CustomOption *,CvPreGame::CustomOption *,std::allocator<CvPreGame::CustomOption> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z
_TEXT	SEGMENT
$T222735 = -34						; size = 1
$T222734 = -33						; size = 1
$T222733 = -32						; size = 4
$T222732 = -28						; size = 4
$T222720 = -21						; size = 1
$T222719 = -20						; size = 4
$T222718 = -16						; size = 4
$T222717 = -12						; size = 4
__Cat$222727 = -8					; size = 1
$T222724 = -7						; size = 1
$T222723 = -6						; size = 1
__Cat$222699 = -4					; size = 1
$T222696 = -3						; size = 1
$T222695 = -2						; size = 1
$T222694 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T222694[ebp], al
	mov	cl, BYTE PTR __Cat$222699[ebp]
	mov	BYTE PTR $T222695[ebp], cl
	mov	dl, BYTE PTR $T222694[ebp]
	mov	BYTE PTR $T222735[ebp], dl
	mov	al, BYTE PTR $T222696[ebp]
	mov	BYTE PTR $T222734[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T222733[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T222732[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T222723[ebp], al
	mov	cl, BYTE PTR __Cat$222727[ebp]
	mov	BYTE PTR $T222724[ebp], cl
	mov	dl, BYTE PTR $T222723[ebp]
	mov	BYTE PTR $T222720[ebp], dl
	mov	eax, DWORD PTR $T222733[ebp]
	mov	DWORD PTR $T222719[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T222718[ebp], ecx
	mov	edx, DWORD PTR $T222732[ebp]
	mov	DWORD PTR $T222717[ebp], edx
$LN12@Unchecked_:
	mov	eax, DWORD PTR $T222717[ebp]
	cmp	eax, DWORD PTR $T222718[ebp]
	je	SHORT $LN7@Unchecked_
	mov	ecx, DWORD PTR $T222718[ebp]
	sub	ecx, 68					; 00000044H
	mov	DWORD PTR $T222718[ebp], ecx
	mov	edx, DWORD PTR $T222719[ebp]
	sub	edx, 68					; 00000044H
	mov	DWORD PTR $T222719[ebp], edx
	mov	eax, DWORD PTR $T222718[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222719[ebp]
	call	??4CustomOption@CvPreGame@@QAEAAV01@ABV01@@Z ; CvPreGame::CustomOption::operator=
	jmp	SHORT $LN12@Unchecked_
$LN7@Unchecked_:
	mov	eax, DWORD PTR $T222719[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAVCustomOption@CvPreGame@@PAV12@@stdext@@YAPAVCustomOption@CvPreGame@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<CvPreGame::CustomOption *,CvPreGame::CustomOption *>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv89 = -40						; size = 4
tv68 = -36						; size = 4
$T222767 = -32						; size = 4
$T222766 = -28						; size = 4
__Vptr$222764 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$222764[ebp], eax
	mov	ecx, DWORD PTR __Vptr$222764[ebp]
	mov	DWORD PTR $T222767[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T222767[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T222767[ebp]
	call	??0CustomOption@CvPreGame@@QAE@ABV01@@Z	; CvPreGame::CustomOption::CustomOption
	mov	DWORD PTR tv68[ebp], eax
	mov	eax, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN19@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv89[ebp], 0
$LN19@Uninit_fil:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T222766[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$222764[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222767[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCustomOption@CvPreGame@@IV12@V?$allocator@VCustomOption@CvPreGame@@@std@@@std@@YAXPAVCustomOption@CvPreGame@@IABV12@AAV?$allocator@VCustomOption@CvPreGame@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvPreGame::CustomOption *,unsigned int,CvPreGame::CustomOption,std::allocator<CvPreGame::CustomOption> >
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2
__ehfuncinfo$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T222878 = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 1957 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1958 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1959 : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T222878[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T222878[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
__unwindfunclet$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T222878[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@_N@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<bool> >::~_Container_base_aux_alloc_empty<std::allocator<bool> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T222921 = -30						; size = 1
$T222908 = -29						; size = 1
$T222904 = -28						; size = 4
$T222897 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T222921[ebp]
	mov	DWORD PTR $T222897[ebp], eax
	lea	ecx, DWORD PTR $T222908[ebp]
	mov	DWORD PTR $T222904[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$222989 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$222989[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$222989[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$222989[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T223055 = -28						; size = 4
$T223054 = -24						; size = 4
$T223050 = -20						; size = 4
$T223049 = -16						; size = 4
$T223038 = -12						; size = 4
$T223037 = -8						; size = 4
__Cat$223045 = -2					; size = 1
$T223043 = -1						; size = 1
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223050[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223049[ebp], ecx
	mov	edx, DWORD PTR $T223050[ebp]
	mov	DWORD PTR $T223038[ebp], edx
	mov	eax, DWORD PTR $T223049[ebp]
	mov	DWORD PTR $T223037[ebp], eax
	mov	cl, BYTE PTR __Cat$223045[ebp]
	mov	BYTE PTR $T223043[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T223055[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223054[ebp], eax
	mov	ecx, DWORD PTR $T223054[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T223148 = -52						; size = 4
$T223137 = -48						; size = 4
$T223136 = -44						; size = 4
__Cat$223144 = -40					; size = 1
$T223142 = -39						; size = 1
__Ptr$211089 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::unchecked_copy<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$211089[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223148[ebp], edx
	mov	eax, DWORD PTR $T223148[ebp]
	mov	DWORD PTR $T223137[ebp], eax
	mov	ecx, DWORD PTR __Ptr$211089[ebp]
	mov	DWORD PTR $T223136[ebp], ecx
	mov	dl, BYTE PTR __Cat$223144[ebp]
	mov	BYTE PTR $T223142[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$211089[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T223152 = -80						; size = 28
$T223151 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T223152[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T223151[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T223151[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T223152[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223151[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T223151[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T223151[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T223152[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T223152[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T223151[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z PROC ; operator>><bool>, COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	push	ecx
	call	??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 233  : }

	pop	ebp
	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ENDP ; operator>><bool>
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Odtp
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z
_TEXT	SEGMENT
$T223248 = -76						; size = 4
$T223235 = -72						; size = 4
$T223259 = -68						; size = 4
$T223188 = -44						; size = 4
$T223184 = -40						; size = 4
$T223191 = -36						; size = 4
$T223178 = -32						; size = 8
$T223177 = -24						; size = 8
$T223176 = -16						; size = 8
$T223175 = -8						; size = 8
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z PROC ; operator<<<bool>, COMDAT

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	eax, DWORD PTR _saveTo$[ebp]
	mov	DWORD PTR $T223175[ebp], eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	DWORD PTR $T223175[ebp+4], ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223184[ebp], eax
	mov	ecx, DWORD PTR $T223184[ebp]
	mov	DWORD PTR $T223191[ebp], ecx
	mov	edx, DWORD PTR $T223175[ebp]
	mov	DWORD PTR $T223188[ebp], edx
	lea	eax, DWORD PTR $T223191[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223188[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223235[ebp], edx
	mov	eax, DWORD PTR $T223235[ebp]
	mov	DWORD PTR $T223259[ebp], eax
	mov	ecx, DWORD PTR $T223259[ebp]
	mov	DWORD PTR $T223248[ebp], ecx
	mov	edx, DWORD PTR $T223248[ebp]
	mov	DWORD PTR $T223177[ebp], edx
	mov	DWORD PTR $T223177[ebp+4], 0
	mov	eax, DWORD PTR $T223175[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T223175[ebp]
	push	ecx
	lea	edx, DWORD PTR $T223176[ebp]
	push	edx
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR $T223177[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T223177[ebp]
	push	ecx
	lea	edx, DWORD PTR $T223178[ebp]
	push	edx
	call	??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >
	add	esp, 28					; 0000001cH

; 200  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$vector@_NV?$allocator@_N@std@@@std@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T223345 = -26						; size = 1
$T223344 = -25						; size = 1
$T223343 = -24						; size = 4
$T223342 = -20						; size = 4
__Off$223339 = -16					; size = 4
__Result$223340 = -12					; size = 4
__Cat$223331 = -4					; size = 1
$T223327 = -3						; size = 1
$T223326 = -2						; size = 1
$T223325 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z PROC	; stdext::unchecked_copy<unsigned int *,unsigned int *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T223325[ebp], al
	mov	cl, BYTE PTR __Cat$223331[ebp]
	mov	BYTE PTR $T223326[ebp], cl
	mov	dl, BYTE PTR $T223325[ebp]
	mov	BYTE PTR $T223345[ebp], dl
	mov	al, BYTE PTR $T223327[ebp]
	mov	BYTE PTR $T223344[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T223343[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T223342[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T223342[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$223339[ebp], eax
	mov	ecx, DWORD PTR __Off$223339[ebp]
	mov	edx, DWORD PTR $T223343[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$223340[ebp], eax
	cmp	DWORD PTR __Off$223339[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$223339[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T223342[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$223339[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T223343[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$223340[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAIPAI@stdext@@YAPAIPAI00@Z ENDP	; stdext::unchecked_copy<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T223352 = -16						; size = 4
$T223348 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T223352[ebp], 0
	lea	eax, DWORD PTR $T223352[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223348[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T223348[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T223348[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
_TEXT	ENDS
PUBLIC	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T223374 = -20						; size = 4
$T223361 = -16						; size = 4
$T223376 = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 2003 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2004 : 		const_iterator _Tmp = begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T223361[ebp], ecx
	mov	edx, DWORD PTR $T223361[ebp]
	mov	DWORD PTR $T223376[ebp], edx
	mov	eax, DWORD PTR $T223376[ebp]
	mov	DWORD PTR $T223374[ebp], eax
	mov	ecx, DWORD PTR $T223374[ebp]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], 0

; 2005 : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN1@end

; 2006 : 			_Tmp += _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN1@end:

; 2007 : 		return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2008 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QBE?AV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=, COMDAT
; _this$ = ecx

; 1602 : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1603 : 		if (_Off == 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jne	SHORT $LN3@operator@4

; 1604 : 			return (*this); // early out

	mov	eax, DWORD PTR _this$[ebp]
	jmp	$LN6@operator@4
$LN3@operator@4:

; 1605 : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Myptr != NULL);
; 1606 : 		if (_Off < 0)
; 1607 : 			{
; 1608 : 			_SCL_SECURE_VALIDATE_RANGE(this->_My_actual_offset() >= ((size_type)-_Off));
; 1609 : 			}
; 1610 : 		else
; 1611 : 			{
; 1612 : 			_SCL_SECURE_VALIDATE_RANGE((this->_My_actual_offset() + _Off) <= ((_MycontTy *)this->_Getmycont())->_Mysize);
; 1613 : 			}
; 1614 : 		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)

	cmp	DWORD PTR __Off$[ebp], 0
	jge	SHORT $LN2@operator@4
	xor	eax, eax
	sub	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], eax
	jae	SHORT $LN2@operator@4

; 1615 : 			{	/* add negative increment */
; 1616 : 			this->_Myoff += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1617 : 			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	or	eax, -1
	sub	eax, DWORD PTR [edx+4]
	shr	eax, 5
	lea	ecx, DWORD PTR [eax*4+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1618 : 			this->_Myoff %= _VBITS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1619 : 			}
; 1620 : 		else

	jmp	SHORT $LN1@operator@4
$LN2@operator@4:

; 1621 : 			{	/* add non-negative increment */
; 1622 : 			this->_Myoff += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1623 : 			this->_Myptr += this->_Myoff / _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shr	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 1624 : 			this->_Myoff %= _VBITS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN1@operator@4:

; 1625 : 			}
; 1626 : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$LN6@operator@4:

; 1627 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
_TEXT	ENDS
PUBLIC	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert
PUBLIC	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
PUBLIC	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z
_TEXT	SEGMENT
$T223826 = -289						; size = 1
$T223824 = -112						; size = 8
$T223823 = -104						; size = 8
$T223822 = -96						; size = 8
_v$213801 = -9						; size = 1
_i$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z PROC ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H

; 84   : 	container.clear();

	mov	ecx, DWORD PTR _container$[ebp]
	call	?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ; std::vector<bool,std::allocator<bool> >::clear

; 85   : 	ContainerType::size_type count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 86   : 	loadFrom >> count;

	lea	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 88   : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@SerializeT@2
$LN2@SerializeT@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@SerializeT@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jae	SHORT $LN4@SerializeT@2

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	eax, DWORD PTR _v$213801[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	mov	cl, BYTE PTR _v$213801[ebp]
	mov	BYTE PTR $T223826[ebp], cl
	lea	edx, DWORD PTR $T223823[ebp]
	push	edx
	mov	ecx, DWORD PTR _container$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223822[ebp], ecx
	mov	DWORD PTR $T223822[ebp+4], edx
	movzx	eax, BYTE PTR $T223826[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223822[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T223822[ebp]
	push	edx
	lea	eax, DWORD PTR $T223824[ebp]
	push	eax
	mov	ecx, DWORD PTR _container$[ebp]
	call	?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ; std::vector<bool,std::allocator<bool> >::insert

; 93   : 	}

	jmp	SHORT $LN2@SerializeT@2
$LN4@SerializeT@2:

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$SerializeToSequenceContainer@_NV?$vector@_NV?$allocator@_N@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@_NV?$allocator@_N@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<bool,std::vector<bool,std::allocator<bool> > >
_TEXT	ENDS
PUBLIC	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -356						; size = 4
$T223922 = -76						; size = 4
$T223900 = -72						; size = 4
$T223925 = -68						; size = 4
$T223833 = -40						; size = 8
$T223832 = -32						; size = 8
$T223831 = -24						; size = 8
$T223830 = -16						; size = 8
$T223829 = -8						; size = 8
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ PROC ; std::vector<bool,std::allocator<bool> >::clear, COMDAT
; _this$ = ecx

; 2243 : 		{	// erase all elements

	push	ebp
	mov	ebp, esp
	sub	esp, 356				; 00000164H
	mov	DWORD PTR _this$[ebp], ecx

; 2244 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T223830[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223829[ebp], ecx
	mov	DWORD PTR $T223829[ebp+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T223900[ebp], ecx
	mov	edx, DWORD PTR $T223900[ebp]
	mov	DWORD PTR $T223925[ebp], edx
	mov	eax, DWORD PTR $T223925[ebp]
	mov	DWORD PTR $T223922[ebp], eax
	mov	ecx, DWORD PTR $T223922[ebp]
	mov	DWORD PTR $T223832[ebp], ecx
	mov	DWORD PTR $T223832[ebp+4], 0
	mov	edx, DWORD PTR $T223832[ebp]
	mov	eax, DWORD PTR $T223832[ebp+4]
	mov	DWORD PTR $T223831[ebp], edx
	mov	DWORD PTR $T223831[ebp+4], eax
	mov	ecx, DWORD PTR $T223829[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T223829[ebp]
	push	edx
	mov	eax, DWORD PTR $T223831[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T223831[ebp]
	push	ecx
	lea	edx, DWORD PTR $T223833[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ; std::vector<bool,std::allocator<bool> >::erase

; 2245 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@_NV?$allocator@_N@std@@@std@@QAEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T224451 = -24						; size = 4
$T224431 = -20						; size = 4
$T224409 = -16						; size = 4
$T224433 = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::end, COMDAT
; _this$ = ecx

; 1995 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1996 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224409[ebp], ecx
	mov	edx, DWORD PTR $T224409[ebp]
	mov	DWORD PTR $T224433[ebp], edx
	mov	eax, DWORD PTR $T224433[ebp]
	mov	DWORD PTR $T224431[ebp], eax
	mov	ecx, DWORD PTR $T224431[ebp]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], 0

; 1997 : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN1@end@2

; 1998 : 			_Tmp += _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224451[ebp], ecx
	mov	edx, DWORD PTR $T224451[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN1@end@2:

; 1999 : 		return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2000 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::end
_TEXT	ENDS
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
PUBLIC	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
PUBLIC	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -372						; size = 4
__Tmp$224968 = -368					; size = 8
$T224947 = -360						; size = 4
$T224925 = -356						; size = 4
$T224950 = -352						; size = 4
$T224790 = -228						; size = 4
$T224768 = -224						; size = 4
$T224793 = -220						; size = 4
$T224756 = -216						; size = 8
$T224755 = -208						; size = 8
$T224754 = -200						; size = 8
__Cat$224749 = -164					; size = 1
$T224747 = -163						; size = 1
$T224746 = -162						; size = 1
$T224745 = -161						; size = 1
$T224601 = -136						; size = 4
$T224579 = -132						; size = 4
$T224603 = -128						; size = 4
$T224457 = -60						; size = 8
$T224456 = -52						; size = 8
$T224455 = -44						; size = 8
$T224454 = -36						; size = 8
__Off$ = -28						; size = 4
__Last$ = -24						; size = 8
__First$ = -16						; size = 8
__Next$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z PROC ; std::vector<bool,std::allocator<bool> >::erase, COMDAT
; _this$ = ecx

; 2221 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	mov	DWORD PTR _this$[ebp], ecx

; 2222 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2223 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ; std::vector<bool,std::allocator<bool> >::_Make_iter

; 2224 : 		size_type _Off = _First - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224579[ebp], ecx
	mov	edx, DWORD PTR $T224579[ebp]
	mov	DWORD PTR $T224603[ebp], edx
	mov	eax, DWORD PTR $T224603[ebp]
	mov	DWORD PTR $T224601[ebp], eax
	mov	ecx, DWORD PTR $T224601[ebp]
	mov	DWORD PTR $T224454[ebp], ecx
	mov	DWORD PTR $T224454[ebp+4], 0
	mov	edx, DWORD PTR __First$[ebp]
	sub	edx, DWORD PTR $T224454[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __First$[ebp+4]
	sub	edx, DWORD PTR $T224454[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2225 : 
; 2226 :  #if _HAS_ITERATOR_DEBUGGING
; 2227 : 		if (_Last < _First || end() < _Last)
; 2228 : 			_DEBUG_ERROR("vector<bool> erase iterator outside range");
; 2229 : 		iterator _Next = std::copy(_Last, end(), _First);
; 2230 : 		size_type _Newsize = _Next - begin();
; 2231 : 		_Orphan_range(_Newsize, _Mysize);
; 2232 : 		_Trim(_Newsize);
; 2233 : 
; 2234 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 2235 : 		iterator _Next = std::copy(_Last, end(), _First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T224756[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T224756[ebp+4], ecx
	lea	edx, DWORD PTR $T224455[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224755[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224755[ebp+4], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T224754[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR $T224754[ebp+4], ecx
	xor	edx, edx
	mov	BYTE PTR $T224745[ebp], dl
	mov	al, BYTE PTR __Cat$224749[ebp]
	mov	BYTE PTR $T224746[ebp], al
	movzx	ecx, BYTE PTR $T224745[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T224746[ebp]
	push	edx
	movzx	eax, BYTE PTR $T224747[ebp]
	push	eax
	mov	ecx, DWORD PTR $T224756[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T224756[ebp]
	push	edx
	mov	eax, DWORD PTR $T224755[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T224755[ebp]
	push	ecx
	mov	edx, DWORD PTR $T224754[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T224754[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H

; 2236 : 		_Trim(_Next - begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T224768[ebp], eax
	mov	ecx, DWORD PTR $T224768[ebp]
	mov	DWORD PTR $T224793[ebp], ecx
	mov	edx, DWORD PTR $T224793[ebp]
	mov	DWORD PTR $T224790[ebp], edx
	mov	eax, DWORD PTR $T224790[ebp]
	mov	DWORD PTR $T224456[ebp], eax
	mov	DWORD PTR $T224456[ebp+4], 0
	mov	ecx, DWORD PTR __Next$[ebp]
	sub	ecx, DWORD PTR $T224456[ebp]
	sar	ecx, 2
	shl	ecx, 5
	add	ecx, DWORD PTR __Next$[ebp+4]
	sub	ecx, DWORD PTR $T224456[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2237 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2238 : 
; 2239 : 		return (begin() + _Off);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T224925[ebp], eax
	mov	ecx, DWORD PTR $T224925[ebp]
	mov	DWORD PTR $T224950[ebp], ecx
	mov	edx, DWORD PTR $T224950[ebp]
	mov	DWORD PTR $T224947[ebp], edx
	mov	eax, DWORD PTR $T224947[ebp]
	mov	DWORD PTR $T224457[ebp], eax
	mov	DWORD PTR $T224457[ebp+4], 0
	mov	ecx, DWORD PTR $T224457[ebp]
	mov	edx, DWORD PTR $T224457[ebp+4]
	mov	DWORD PTR __Tmp$224968[ebp], ecx
	mov	DWORD PTR __Tmp$224968[ebp+4], edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$224968[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$224968[ebp]
	mov	edx, DWORD PTR __Tmp$224968[ebp+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2240 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@0@Z ENDP ; std::vector<bool,std::allocator<bool> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T225080 = -44						; size = 4
$T225057 = -40						; size = 4
$T225035 = -36						; size = 4
$T225060 = -32						; size = 4
$T225008 = -28						; size = 4
$T224986 = -24						; size = 4
$T225011 = -20						; size = 4
$T224974 = -16						; size = 8
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z PROC ; std::vector<bool,std::allocator<bool> >::_Make_iter, COMDAT
; _this$ = ecx

; 2011 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 2012 : 		iterator _Tmp = begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224986[ebp], ecx
	mov	edx, DWORD PTR $T224986[ebp]
	mov	DWORD PTR $T225011[ebp], edx
	mov	eax, DWORD PTR $T225011[ebp]
	mov	DWORD PTR $T225008[ebp], eax
	mov	ecx, DWORD PTR $T225008[ebp]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], 0

; 2013 : 		if (0 < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jbe	SHORT $LN1@Make_iter

; 2014 : 			_Tmp += _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T225035[ebp], ecx
	mov	edx, DWORD PTR $T225035[ebp]
	mov	DWORD PTR $T225060[ebp], edx
	mov	eax, DWORD PTR $T225060[ebp]
	mov	DWORD PTR $T225057[ebp], eax
	mov	ecx, DWORD PTR $T225057[ebp]
	mov	DWORD PTR $T224974[ebp], ecx
	mov	DWORD PTR $T224974[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T224974[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T224974[ebp+4]
	mov	DWORD PTR $T225080[ebp], edx
	mov	eax, DWORD PTR $T225080[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
$LN1@Make_iter:

; 2015 : 		return (_Tmp);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2016 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
tv142 = -188						; size = 4
tv149 = -184						; size = 4
tv158 = -180						; size = 4
_this$ = -176						; size = 4
__Tmp$225177 = -120					; size = 4
$T225160 = -116						; size = 4
$T225144 = -112						; size = 4
$T225134 = -108						; size = 4
__Count$225116 = -36					; size = 4
__Maxsize$225109 = -32					; size = 4
$T225088 = -28						; size = 4
$T225087 = -24						; size = 4
$T225086 = -20						; size = 4
$T225085 = -16						; size = 4
$T225084 = -12						; size = 4
$T225083 = -8						; size = 4
__Words$ = -4						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 2360 : 		{	// trim base vector to exact length in bits

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	DWORD PTR _this$[ebp], ecx

; 2361 : 		if (max_size() < _Size)

	mov	DWORD PTR __Count$225116[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$225116[ebp], 0
	jbe	SHORT $LN14@Trim
	mov	eax, DWORD PTR __Count$225116[ebp]
	mov	DWORD PTR tv158[ebp], eax
	jmp	SHORT $LN10@Trim
$LN14@Trim:
	mov	DWORD PTR tv158[ebp], 1
$LN10@Trim:
	mov	ecx, DWORD PTR tv158[ebp]
	mov	DWORD PTR __Maxsize$225109[ebp], ecx
	cmp	DWORD PTR __Maxsize$225109[ebp], 134217727 ; 07ffffffH
	jae	SHORT $LN8@Trim
	mov	edx, DWORD PTR __Maxsize$225109[ebp]
	shl	edx, 5
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN6@Trim
$LN8@Trim:
	mov	DWORD PTR tv149[ebp], -1
$LN6@Trim:
	mov	eax, DWORD PTR tv149[ebp]
	cmp	eax, DWORD PTR __Size$[ebp]
	jae	SHORT $LN22@Trim

; 2362 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen

; 2363 : 		size_type _Words = _Nw(_Size);

$LN22@Trim:
	mov	ecx, DWORD PTR __Size$[ebp]
	add	ecx, 31					; 0000001fH
	shr	ecx, 5
	mov	DWORD PTR __Words$[ebp], ecx

; 2364 : 
; 2365 : 		if (_Words < _Myvec.size())

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T225134[ebp], edx
	mov	eax, DWORD PTR $T225134[ebp]
	mov	ecx, DWORD PTR $T225134[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	DWORD PTR __Words$[ebp], edx
	jae	SHORT $LN2@Trim

; 2366 : 			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T225144[ebp], ecx
	mov	edx, DWORD PTR $T225144[ebp]
	mov	DWORD PTR $T225084[ebp], edx
	mov	eax, DWORD PTR $T225084[ebp]
	mov	DWORD PTR $T225083[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T225160[ebp], edx
	mov	eax, DWORD PTR $T225160[ebp]
	mov	DWORD PTR $T225086[ebp], eax
	mov	ecx, DWORD PTR $T225086[ebp]
	mov	DWORD PTR __Tmp$225177[ebp], ecx
	mov	edx, DWORD PTR __Words$[ebp]
	mov	eax, DWORD PTR __Tmp$225177[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$225177[ebp], ecx
	mov	edx, DWORD PTR __Tmp$225177[ebp]
	mov	DWORD PTR $T225087[ebp], edx
	mov	eax, DWORD PTR $T225087[ebp]
	mov	DWORD PTR $T225085[ebp], eax
	mov	ecx, DWORD PTR $T225083[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225085[ebp]
	push	edx
	lea	eax, DWORD PTR $T225088[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN2@Trim:

; 2367 : 		_Mysize = _Size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Size$[ebp]
	mov	DWORD PTR [ecx], edx

; 2368 : 		_Size %= _VBITS;

	mov	eax, DWORD PTR __Size$[ebp]
	xor	edx, edx
	mov	ecx, 32					; 00000020H
	div	ecx
	mov	DWORD PTR __Size$[ebp], edx

; 2369 : 		if (0 < _Size)

	cmp	DWORD PTR __Size$[ebp], 0
	jbe	SHORT $LN4@Trim

; 2370 : 			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Words$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR tv142[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR __Size$[ebp]
	shl	eax, cl
	sub	eax, 1
	mov	ecx, DWORD PTR tv142[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR [edx], eax
$LN4@Trim:

; 2371 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@IAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@ DB 'vector<bool> to'
	DB	'o long', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2
__ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T225281 = -80						; size = 28
$T225280 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 2374 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2375 : 		_THROW(length_error, "vector<bool> too long");

	push	OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T225281[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T225280[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T225280[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T225281[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225280[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T225280[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T225280[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T225281[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 2376 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$0:
	lea	ecx, DWORD PTR $T225281[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ$2:
	lea	ecx, DWORD PTR $T225280[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
tv158 = -48						; size = 4
$T225359 = -44						; size = 4
$T225302 = -17						; size = 1
__ChkFirst$ = -16					; size = 8
__ChkLast$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Func$ = 28						; size = 8
??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __ChkFirst$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR __ChkFirst$[ebp+4], ecx

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __ChkLast$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR __ChkLast$[ebp+4], eax

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	jmp	SHORT $LN3@for_each
$LN2@for_each:
	cmp	DWORD PTR __ChkFirst$[ebp+4], 31	; 0000001fH
	jae	SHORT $LN9@for_each
	mov	ecx, DWORD PTR __ChkFirst$[ebp+4]
	add	ecx, 1
	mov	DWORD PTR __ChkFirst$[ebp+4], ecx
	jmp	SHORT $LN3@for_each
$LN9@for_each:
	mov	DWORD PTR __ChkFirst$[ebp+4], 0
	mov	edx, DWORD PTR __ChkFirst$[ebp]
	add	edx, 4
	mov	DWORD PTR __ChkFirst$[ebp], edx
$LN3@for_each:
	mov	eax, DWORD PTR __ChkFirst$[ebp]
	cmp	eax, DWORD PTR __ChkLast$[ebp]
	jne	SHORT $LN16@for_each
	mov	ecx, DWORD PTR __ChkFirst$[ebp+4]
	cmp	ecx, DWORD PTR __ChkLast$[ebp+4]
	jne	SHORT $LN16@for_each
	mov	DWORD PTR tv158[ebp], 1
	jmp	SHORT $LN12@for_each
$LN16@for_each:
	mov	DWORD PTR tv158[ebp], 0
$LN12@for_each:
	movzx	edx, BYTE PTR tv158[ebp]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@for_each

; 29   : 		_Func(*_ChkFirst);

	lea	ecx, DWORD PTR __ChkFirst$[ebp]
	call	??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
	mov	BYTE PTR $T225302[ebp], al
	mov	ecx, DWORD PTR __Func$[ebp]
	mov	DWORD PTR $T225359[ebp], ecx
	lea	edx, DWORD PTR $T225302[ebp]
	push	edx
	mov	ecx, DWORD PTR $T225359[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	jmp	SHORT $LN2@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Func$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Func$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 31   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$for_each@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CB_N$$CBV?$vector@_NV?$allocator@_N@std@@@std@@@@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,SerializeFromSequenceContainer<bool const ,std::vector<bool,std::allocator<bool> > const > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T225381 = -20						; size = 4
$T225372 = -16						; size = 4
$T225371 = -12						; size = 4
$T225366 = -8						; size = 8
??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*, COMDAT
; _this$ = ecx

; 1571 : 		{	// return (reference to) designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1572 : 		return (_Reft(*this));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225372[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225371[ebp], eax
	mov	ecx, DWORD PTR $T225371[ebp]
	mov	DWORD PTR $T225366[ebp], ecx
	mov	edx, DWORD PTR $T225372[ebp]
	mov	DWORD PTR $T225366[ebp+4], edx
	mov	eax, DWORD PTR $T225366[ebp]
	mov	DWORD PTR $T225381[ebp], eax
	mov	eax, 1
	mov	ecx, DWORD PTR $T225366[ebp+4]
	shl	eax, cl
	mov	ecx, DWORD PTR $T225381[ebp]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax

; 1573 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator*
_TEXT	ENDS
PUBLIC	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv202 = -44						; size = 4
$T225474 = -32						; size = 4
$T225473 = -28						; size = 4
$T225457 = -24						; size = 4
$T225456 = -20						; size = 4
$T225394 = -16						; size = 8
$T225393 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN2@Copy_opt:
	cmp	DWORD PTR __Dest$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN11@Copy_opt
	mov	eax, DWORD PTR __Dest$[ebp+4]
	add	eax, 1
	mov	DWORD PTR __Dest$[ebp+4], eax
	jmp	SHORT $LN6@Copy_opt
$LN11@Copy_opt:
	mov	DWORD PTR __Dest$[ebp+4], 0
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
$LN6@Copy_opt:
	cmp	DWORD PTR __First$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN19@Copy_opt
	mov	edx, DWORD PTR __First$[ebp+4]
	add	edx, 1
	mov	DWORD PTR __First$[ebp+4], edx
	jmp	SHORT $LN3@Copy_opt
$LN19@Copy_opt:
	mov	DWORD PTR __First$[ebp+4], 0
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN26@Copy_opt
	mov	edx, DWORD PTR __First$[ebp+4]
	cmp	edx, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN26@Copy_opt
	mov	DWORD PTR tv202[ebp], 1
	jmp	SHORT $LN22@Copy_opt
$LN26@Copy_opt:
	mov	DWORD PTR tv202[ebp], 0
$LN22@Copy_opt:
	movzx	eax, BYTE PTR tv202[ebp]
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T225457[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225456[ebp], eax
	mov	ecx, DWORD PTR $T225456[ebp]
	mov	DWORD PTR $T225394[ebp], ecx
	mov	edx, DWORD PTR $T225457[ebp]
	mov	DWORD PTR $T225394[ebp+4], edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR $T225474[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T225473[ebp], ecx
	mov	edx, DWORD PTR $T225473[ebp]
	mov	DWORD PTR $T225393[ebp], edx
	mov	eax, DWORD PTR $T225474[ebp]
	mov	DWORD PTR $T225393[ebp+4], eax
	lea	ecx, DWORD PTR $T225394[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T225393[ebp]
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
	jmp	$LN2@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv130 = -28						; size = 4
tv91 = -24						; size = 4
_this$ = -20						; size = 4
$T225554 = -16						; size = 4
$T225547 = -12						; size = 4
$T225542 = -5						; size = 1
$T225532 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=, COMDAT
; _this$ = ecx

; 1470 : 		{	// assign _Vb_reference _Right to bit

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1471 : 		return (*this = bool(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225532[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	mov	ecx, DWORD PTR $T225532[ebp]
	and	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR $T225542[ebp], al
	movzx	edx, BYTE PTR $T225542[ebp]
	test	edx, edx
	je	SHORT $LN10@operator@5
	mov	eax, DWORD PTR $T225547[ebp]
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv91[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, 1
	mov	ecx, DWORD PTR [eax+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv91[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv91[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN11@operator@5
$LN10@operator@5:
	mov	edx, DWORD PTR $T225554[ebp]
	mov	DWORD PTR tv130[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv130[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, 1
	mov	ecx, DWORD PTR [edx+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv130[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR [edx], eax
$LN11@operator@5:
	mov	eax, DWORD PTR _this$[ebp]

; 1472 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z
_TEXT	SEGMENT
_this$ = -224						; size = 4
__Tmp$225821 = -220					; size = 8
$T225799 = -212						; size = 4
$T225777 = -208						; size = 4
$T225802 = -204						; size = 4
$T225607 = -32						; size = 4
$T225585 = -28						; size = 4
$T225609 = -24						; size = 4
$T225573 = -20						; size = 8
$T225572 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 1
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z PROC ; std::vector<bool,std::allocator<bool> >::insert, COMDAT
; _this$ = ecx

; 2150 : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	DWORD PTR _this$[ebp], ecx

; 2151 : 		size_type _Off = _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T225585[ebp], ecx
	mov	edx, DWORD PTR $T225585[ebp]
	mov	DWORD PTR $T225609[ebp], edx
	mov	eax, DWORD PTR $T225609[ebp]
	mov	DWORD PTR $T225607[ebp], eax
	mov	ecx, DWORD PTR $T225607[ebp]
	mov	DWORD PTR $T225572[ebp], ecx
	mov	DWORD PTR $T225572[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T225572[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T225572[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2152 : 		_Insert_n(_Where, (size_type)1, _Val);

	movzx	eax, BYTE PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ; std::vector<bool,std::allocator<bool> >::_Insert_n

; 2153 : 		return (begin() + _Off);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T225777[ebp], ecx
	mov	edx, DWORD PTR $T225777[ebp]
	mov	DWORD PTR $T225802[ebp], edx
	mov	eax, DWORD PTR $T225802[ebp]
	mov	DWORD PTR $T225799[ebp], eax
	mov	ecx, DWORD PTR $T225799[ebp]
	mov	DWORD PTR $T225573[ebp], ecx
	mov	DWORD PTR $T225573[ebp+4], 0
	mov	edx, DWORD PTR $T225573[ebp]
	mov	eax, DWORD PTR $T225573[ebp+4]
	mov	DWORD PTR __Tmp$225821[ebp], edx
	mov	DWORD PTR __Tmp$225821[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$225821[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$225821[ebp]
	mov	eax, DWORD PTR __Tmp$225821[ebp+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2154 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@V?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::insert
_TEXT	ENDS
PUBLIC	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
PUBLIC	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
; Function compile flags: /Odtp
;	COMDAT ?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z
_TEXT	SEGMENT
_this$ = -212						; size = 4
$T226146 = -208						; size = 8
$T226145 = -200						; size = 8
__Tmp$226058 = -172					; size = 8
$T226036 = -164						; size = 4
$T226014 = -160						; size = 4
$T226039 = -156						; size = 4
__Tmp$225999 = -152					; size = 8
$T225978 = -144						; size = 4
$T225956 = -140						; size = 4
$T225981 = -136						; size = 4
$T225830 = -36						; size = 8
$T225829 = -28						; size = 8
$T225828 = -20						; size = 8
$T225827 = -12						; size = 8
__Off$ = -4						; size = 4
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 1
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_n, COMDAT
; _this$ = ecx

; 2290 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	DWORD PTR _this$[ebp], ecx

; 2291 : 		size_type _Off = _Insert_x(_Where, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::_Insert_x
	mov	DWORD PTR __Off$[ebp], eax

; 2292 : 		std::fill(begin() + _Off, begin() + (_Off + _Count), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T225956[ebp], ecx
	mov	edx, DWORD PTR $T225956[ebp]
	mov	DWORD PTR $T225981[ebp], edx
	mov	eax, DWORD PTR $T225981[ebp]
	mov	DWORD PTR $T225978[ebp], eax
	mov	ecx, DWORD PTR $T225978[ebp]
	mov	DWORD PTR $T225827[ebp], ecx
	mov	DWORD PTR $T225827[ebp+4], 0
	mov	edx, DWORD PTR $T225827[ebp]
	mov	eax, DWORD PTR $T225827[ebp+4]
	mov	DWORD PTR __Tmp$225999[ebp], edx
	mov	DWORD PTR __Tmp$225999[ebp+4], eax
	mov	ecx, DWORD PTR __Off$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$225999[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	edx, DWORD PTR __Tmp$225999[ebp]
	mov	eax, DWORD PTR __Tmp$225999[ebp+4]
	mov	DWORD PTR $T225828[ebp], edx
	mov	DWORD PTR $T225828[ebp+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226014[ebp], edx
	mov	eax, DWORD PTR $T226014[ebp]
	mov	DWORD PTR $T226039[ebp], eax
	mov	ecx, DWORD PTR $T226039[ebp]
	mov	DWORD PTR $T226036[ebp], ecx
	mov	edx, DWORD PTR $T226036[ebp]
	mov	DWORD PTR $T225829[ebp], edx
	mov	DWORD PTR $T225829[ebp+4], 0
	mov	eax, DWORD PTR $T225829[ebp]
	mov	ecx, DWORD PTR $T225829[ebp+4]
	mov	DWORD PTR __Tmp$226058[ebp], eax
	mov	DWORD PTR __Tmp$226058[ebp+4], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$226058[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	eax, DWORD PTR __Tmp$226058[ebp]
	mov	ecx, DWORD PTR __Tmp$226058[ebp+4]
	mov	DWORD PTR $T225830[ebp], eax
	mov	DWORD PTR $T225830[ebp+4], ecx
	mov	edx, DWORD PTR $T225828[ebp]
	mov	DWORD PTR $T226146[ebp], edx
	mov	eax, DWORD PTR $T225828[ebp+4]
	mov	DWORD PTR $T226146[ebp+4], eax
	mov	ecx, DWORD PTR $T225830[ebp]
	mov	DWORD PTR $T226145[ebp], ecx
	mov	edx, DWORD PTR $T225830[ebp+4]
	mov	DWORD PTR $T226145[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226146[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T226146[ebp]
	push	edx
	mov	eax, DWORD PTR $T226145[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T226145[ebp]
	push	ecx
	call	??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
	add	esp, 20					; 00000014H

; 2293 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?_Insert_n@?$vector@_NV?$allocator@_N@std@@@std@@IAEXV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I_N@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_n
_TEXT	ENDS
PUBLIC	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
PUBLIC	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
; Function compile flags: /Odtp
;	COMDAT ?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z
_TEXT	SEGMENT
tv191 = -348						; size = 4
tv200 = -344						; size = 4
_this$ = -340						; size = 4
__Tmp$226505 = -268					; size = 8
$T226483 = -260						; size = 4
$T226461 = -256						; size = 4
$T226485 = -252						; size = 4
$T226341 = -200						; size = 4
$T226252 = -148						; size = 4
$T226240 = -76						; size = 4
__Count$226233 = -72					; size = 4
__Maxsize$226226 = -68					; size = 4
$T226187 = -64						; size = 4
$T226165 = -60						; size = 4
$T226190 = -56						; size = 4
$T226153 = -52						; size = 8
$T226152 = -44						; size = 8
$T226151 = -36						; size = 8
$T226150 = -28						; size = 8
$T226149 = -20						; size = 8
__Oldend$214955 = -12					; size = 8
__Off$ = -4						; size = 4
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::_Insert_x, COMDAT
; _this$ = ecx

; 2296 : 		{	// make room to insert _Count elements at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	DWORD PTR _this$[ebp], ecx

; 2297 : 		size_type _Off = _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T226165[ebp], ecx
	mov	edx, DWORD PTR $T226165[ebp]
	mov	DWORD PTR $T226190[ebp], edx
	mov	eax, DWORD PTR $T226190[ebp]
	mov	DWORD PTR $T226187[ebp], eax
	mov	ecx, DWORD PTR $T226187[ebp]
	mov	DWORD PTR $T226149[ebp], ecx
	mov	DWORD PTR $T226149[ebp+4], 0
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR $T226149[ebp]
	sar	edx, 2
	shl	edx, 5
	add	edx, DWORD PTR __Where$[ebp+4]
	sub	edx, DWORD PTR $T226149[ebp+4]
	mov	DWORD PTR __Off$[ebp], edx

; 2298 : 
; 2299 :  #if _HAS_ITERATOR_DEBUGGING
; 2300 : 		if (end() < _Where)
; 2301 : 			_DEBUG_ERROR("vector<bool> insert iterator outside range");
; 2302 : 		bool _Realloc = capacity() - size() < _Count;
; 2303 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2304 : 
; 2305 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN6@Insert_x
	jmp	$LN5@Insert_x
$LN6@Insert_x:

; 2306 : 			;
; 2307 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$226233[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$226233[ebp], 0
	jbe	SHORT $LN33@Insert_x
	mov	eax, DWORD PTR __Count$226233[ebp]
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN29@Insert_x
$LN33@Insert_x:
	mov	DWORD PTR tv200[ebp], 1
$LN29@Insert_x:
	mov	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR __Maxsize$226226[ebp], ecx
	cmp	DWORD PTR __Maxsize$226226[ebp], 134217727 ; 07ffffffH
	jae	SHORT $LN27@Insert_x
	mov	edx, DWORD PTR __Maxsize$226226[ebp]
	shl	edx, 5
	mov	DWORD PTR tv191[ebp], edx
	jmp	SHORT $LN25@Insert_x
$LN27@Insert_x:
	mov	DWORD PTR tv191[ebp], -1
$LN25@Insert_x:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226240[ebp], ecx
	mov	edx, DWORD PTR tv191[ebp]
	sub	edx, DWORD PTR $T226240[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Insert_x

; 2308 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@IBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen

; 2309 : 		else

	jmp	$LN5@Insert_x
$LN4@Insert_x:

; 2310 : 			{	// worth doing
; 2311 : 			_Myvec.resize(_Nw(size() + _Count), 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226252[ebp], ecx
	push	0
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR $T226252[ebp]
	lea	ecx, DWORD PTR [eax+edx+31]
	shr	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::resize

; 2312 : 			if (size() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226341[ebp], eax
	cmp	DWORD PTR $T226341[ebp], 0
	jne	SHORT $LN2@Insert_x

; 2313 : 				_Mysize += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 2314 : 			else

	jmp	$LN5@Insert_x
$LN2@Insert_x:

; 2315 : 				{	// make room and copy down suffix
; 2316 : 				iterator _Oldend = end();

	lea	ecx, DWORD PTR __Oldend$214955[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end

; 2317 : 				_Mysize += _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 2318 : 				std::copy_backward(begin() + _Off, _Oldend, end());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T226461[ebp], eax
	mov	ecx, DWORD PTR $T226461[ebp]
	mov	DWORD PTR $T226485[ebp], ecx
	mov	edx, DWORD PTR $T226485[ebp]
	mov	DWORD PTR $T226483[ebp], edx
	mov	eax, DWORD PTR $T226483[ebp]
	mov	DWORD PTR $T226151[ebp], eax
	mov	DWORD PTR $T226151[ebp+4], 0
	mov	ecx, DWORD PTR $T226151[ebp]
	mov	edx, DWORD PTR $T226151[ebp+4]
	mov	DWORD PTR __Tmp$226505[ebp], ecx
	mov	DWORD PTR __Tmp$226505[ebp+4], edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$226505[ebp]
	call	??Y?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vb_const_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator+=
	mov	ecx, DWORD PTR __Tmp$226505[ebp]
	mov	edx, DWORD PTR __Tmp$226505[ebp+4]
	mov	DWORD PTR $T226152[ebp], ecx
	mov	DWORD PTR $T226152[ebp+4], edx
	lea	eax, DWORD PTR $T226150[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Oldend$214955[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Oldend$214955[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226152[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T226152[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226153[ebp]
	push	ecx
	call	??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
	add	esp, 28					; 0000001cH
$LN5@Insert_x:

; 2319 : 				}
; 2320 : 
; 2321 :  #if _HAS_ITERATOR_DEBUGGING
; 2322 : 			_Orphan_range(_Realloc ? 0 : _Off, _Mysize);
; 2323 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2324 : 
; 2325 : 			}
; 2326 : 		return (_Off);

	mov	eax, DWORD PTR __Off$[ebp]

; 2327 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Insert_x@?$vector@_NV?$allocator@_N@std@@@std@@IAEIV?$_Vb_const_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Insert_x
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -104						; size = 4
__Tmp$226710 = -48					; size = 4
$T226693 = -44						; size = 4
$T226677 = -40						; size = 4
$T226655 = -36						; size = 4
$T226642 = -32						; size = 4
$T226641 = -28						; size = 4
$T226640 = -24						; size = 4
$T226639 = -20						; size = 4
$T226638 = -16						; size = 4
$T226637 = -12						; size = 4
$T226636 = -8						; size = 4
$T226635 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN16@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T226655[ebp], ecx
	mov	edx, DWORD PTR $T226655[ebp]
	mov	DWORD PTR $T226636[ebp], edx
	mov	eax, DWORD PTR $T226636[ebp]
	mov	DWORD PTR $T226635[ebp], eax
	lea	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR $T226635[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
	jmp	SHORT $LN4@resize

; 720  : 		else if (_Newsize < size())

$LN16@resize:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 721  : 			erase(begin() + _Newsize, end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T226677[ebp], edx
	mov	eax, DWORD PTR $T226677[ebp]
	mov	DWORD PTR $T226638[ebp], eax
	mov	ecx, DWORD PTR $T226638[ebp]
	mov	DWORD PTR $T226637[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226693[ebp], eax
	mov	ecx, DWORD PTR $T226693[ebp]
	mov	DWORD PTR $T226640[ebp], ecx
	mov	edx, DWORD PTR $T226640[ebp]
	mov	DWORD PTR __Tmp$226710[ebp], edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	ecx, DWORD PTR __Tmp$226710[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Tmp$226710[ebp], edx
	mov	eax, DWORD PTR __Tmp$226710[ebp]
	mov	DWORD PTR $T226641[ebp], eax
	mov	ecx, DWORD PTR $T226641[ebp]
	mov	DWORD PTR $T226639[ebp], ecx
	mov	edx, DWORD PTR $T226637[ebp]
	push	edx
	mov	eax, DWORD PTR $T226639[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226642[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
$LN4@resize:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXII@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::resize
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0
__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T227361 = -412						; size = 4
$T227309 = -368						; size = 4
$T227297 = -364						; size = 4
$T227287 = -357						; size = 1
$T227286 = -356						; size = 4
__Cat$227305 = -327					; size = 1
$T227303 = -326						; size = 1
$T227302 = -325						; size = 1
$T227258 = -324						; size = 4
$T227250 = -320						; size = 4
$T227242 = -316						; size = 4
$T227231 = -312						; size = 4
$T227230 = -308						; size = 4
__Cat$227238 = -302					; size = 1
$T227236 = -301						; size = 1
$T227159 = -276						; size = 4
$T227140 = -272						; size = 4
$T227123 = -265						; size = 1
$T227122 = -264						; size = 4
$T227112 = -260						; size = 4
$T227111 = -256						; size = 4
__Cat$227157 = -250					; size = 1
$T227155 = -249						; size = 1
$T227154 = -248						; size = 1
__Cat$227148 = -247					; size = 1
$T227146 = -246						; size = 1
$T227145 = -245						; size = 1
$T227087 = -244						; size = 4
$T227086 = -240						; size = 4
$T227082 = -236						; size = 4
$T227081 = -232						; size = 4
$T227070 = -228						; size = 4
$T227069 = -224						; size = 4
__Cat$227077 = -218					; size = 1
$T227075 = -217						; size = 1
$T227034 = -216						; size = 4
$T227033 = -212						; size = 4
__Cat$227041 = -206					; size = 1
$T227039 = -205						; size = 1
$T227004 = -204						; size = 4
$T227003 = -200						; size = 4
__Cat$227011 = -194					; size = 1
$T227009 = -193						; size = 1
$T226984 = -192						; size = 4
$T226972 = -188						; size = 4
$T226962 = -181						; size = 1
$T226961 = -180						; size = 4
__Cat$226979 = -175					; size = 1
$T226977 = -174						; size = 1
$T226976 = -173						; size = 1
$T226949 = -172						; size = 4
$T226937 = -168						; size = 4
$T226927 = -161						; size = 1
$T226926 = -160						; size = 4
__Cat$226944 = -155					; size = 1
$T226942 = -154						; size = 1
$T226941 = -153						; size = 1
$T226914 = -152						; size = 4
$T226902 = -148						; size = 4
$T226892 = -141						; size = 1
$T226891 = -140						; size = 4
__Cat$226909 = -135					; size = 1
$T226907 = -134						; size = 1
$T226906 = -133						; size = 1
__Count$226865 = -120					; size = 4
__Count$226839 = -48					; size = 4
__Tmp$215030 = -44					; size = 4
__Oldend$215031 = -40					; size = 4
__Tmp$215020 = -36					; size = 4
__Ncopied$215007 = -32					; size = 4
__Newvec$215005 = -28					; size = 4
__Whereoff$215006 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$226839[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$226839[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$226839[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$226865[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$226865[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$226865[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8
	mov	DWORD PTR __Newvec$215005[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$215006[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$215007[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$215006[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T226914[ebp], edx
	mov	eax, DWORD PTR $T226914[ebp]
	mov	DWORD PTR $T226902[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226906[ebp], cl
	mov	dl, BYTE PTR __Cat$226909[ebp]
	mov	BYTE PTR $T226907[ebp], dl
	mov	al, BYTE PTR $T226906[ebp]
	mov	BYTE PTR $T226892[ebp], al
	mov	ecx, DWORD PTR $T226902[ebp]
	mov	DWORD PTR $T226891[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226891[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$215007[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$215007[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T226949[ebp], ecx
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR $T226937[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T226941[ebp], al
	mov	cl, BYTE PTR __Cat$226944[ebp]
	mov	BYTE PTR $T226942[ebp], cl
	mov	dl, BYTE PTR $T226941[ebp]
	mov	BYTE PTR $T226927[ebp], dl
	mov	eax, DWORD PTR $T226937[ebp]
	mov	DWORD PTR $T226926[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226926[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226949[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$215007[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$215007[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T226984[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$215006[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T226972[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T226976[ebp], dl
	mov	al, BYTE PTR __Cat$226979[ebp]
	mov	BYTE PTR $T226977[ebp], al
	mov	cl, BYTE PTR $T226976[ebp]
	mov	BYTE PTR $T226962[ebp], cl
	mov	edx, DWORD PTR $T226972[ebp]
	mov	DWORD PTR $T226961[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226961[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226984[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$215007[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$215006[ebp]
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T227004[ebp], eax
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR $T227003[ebp], ecx
	mov	dl, BYTE PTR __Cat$227011[ebp]
	mov	BYTE PTR $T227009[ebp], dl
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$215007[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$215006[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T227034[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$215006[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T227033[ebp], ecx
	mov	dl, BYTE PTR __Cat$227041[ebp]
	mov	BYTE PTR $T227039[ebp], dl
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$215005[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T227082[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T227081[ebp], edx
	mov	eax, DWORD PTR $T227082[ebp]
	mov	DWORD PTR $T227070[ebp], eax
	mov	ecx, DWORD PTR $T227081[ebp]
	mov	DWORD PTR $T227069[ebp], ecx
	mov	dl, BYTE PTR __Cat$227077[ebp]
	mov	BYTE PTR $T227075[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T227087[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T227086[ebp], ecx
	mov	edx, DWORD PTR $T227086[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$215005[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$215005[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$215005[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$215020[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T227159[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T227140[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227145[ebp], cl
	mov	dl, BYTE PTR __Cat$227148[ebp]
	mov	BYTE PTR $T227146[ebp], dl
	mov	al, BYTE PTR $T227145[ebp]
	mov	BYTE PTR $T227123[ebp], al
	mov	ecx, DWORD PTR $T227140[ebp]
	mov	DWORD PTR $T227122[ebp], ecx
	mov	edx, DWORD PTR $T227122[ebp]
	mov	DWORD PTR $T227112[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T227111[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227154[ebp], cl
	mov	dl, BYTE PTR __Cat$227157[ebp]
	mov	BYTE PTR $T227155[ebp], dl
	movzx	eax, BYTE PTR $T227154[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T227155[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T227112[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227159[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227111[ebp]
	push	edx
	call	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$215020[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T227242[ebp], eax
	mov	ecx, DWORD PTR $T227242[ebp]
	mov	DWORD PTR $T227231[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T227230[ebp], ecx
	mov	dl, BYTE PTR __Cat$227238[ebp]
	mov	BYTE PTR $T227236[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T227258[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T227250[ebp], edx
	jmp	SHORT $LN151@Insert_n@2
$LN150@Insert_n@2:
	mov	eax, DWORD PTR $T227250[ebp]
	add	eax, 4
	mov	DWORD PTR $T227250[ebp], eax
$LN151@Insert_n@2:
	mov	ecx, DWORD PTR $T227250[ebp]
	cmp	ecx, DWORD PTR $T227258[ebp]
	je	SHORT $LN147@Insert_n@2
	mov	edx, DWORD PTR $T227250[ebp]
	mov	eax, DWORD PTR __Tmp$215020[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@2
$LN147@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$215030[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$215031[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T227309[ebp], eax
	mov	ecx, DWORD PTR $T227309[ebp]
	mov	DWORD PTR $T227297[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T227302[ebp], dl
	mov	al, BYTE PTR __Cat$227305[ebp]
	mov	BYTE PTR $T227303[ebp], al
	mov	cl, BYTE PTR $T227302[ebp]
	mov	BYTE PTR $T227287[ebp], cl
	mov	edx, DWORD PTR $T227297[ebp]
	mov	DWORD PTR $T227286[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227286[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$215031[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$215031[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$215031[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$215031[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T227361[ebp], ecx
	jmp	SHORT $LN186@Insert_n@2
$LN185@Insert_n@2:
	mov	edx, DWORD PTR $T227361[ebp]
	add	edx, 4
	mov	DWORD PTR $T227361[ebp], edx
$LN186@Insert_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T227361[ebp], edx
	je	SHORT $LN16@Insert_n@2
	mov	eax, DWORD PTR $T227361[ebp]
	mov	ecx, DWORD PTR __Tmp$215030[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T227432 = -40						; size = 4
$T227422 = -33						; size = 1
$T227421 = -32						; size = 4
__Cat$227428 = -3					; size = 1
$T227425 = -2						; size = 1
$T227424 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T227432[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227424[ebp], cl
	mov	dl, BYTE PTR __Cat$227428[ebp]
	mov	BYTE PTR $T227425[ebp], dl
	mov	al, BYTE PTR $T227424[ebp]
	mov	BYTE PTR $T227422[ebp], al
	mov	ecx, DWORD PTR $T227432[ebp]
	mov	DWORD PTR $T227421[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227421[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
__Cat$227440 = -4					; size = 1
$T227437 = -3						; size = 1
$T227436 = -2						; size = 1
$T227435 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z PROC ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >, COMDAT

; 2740 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2741 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2742 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T227435[ebp], al
	mov	cl, BYTE PTR __Cat$227440[ebp]
	mov	BYTE PTR $T227436[ebp], cl
	movzx	edx, BYTE PTR $T227435[ebp]
	push	edx
	movzx	eax, BYTE PTR $T227436[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T227437[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2743 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00@Z ENDP ; std::copy_backward<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T227624 = -38						; size = 1
$T227623 = -37						; size = 1
$T227622 = -36						; size = 4
$T227621 = -32						; size = 4
$T227608 = -25						; size = 1
$T227607 = -24						; size = 4
$T227606 = -20						; size = 4
__Off$227618 = -16					; size = 4
__Result$227619 = -12					; size = 4
__Cat$227614 = -8					; size = 1
$T227612 = -7						; size = 1
$T227611 = -6						; size = 1
__Cat$227587 = -4					; size = 1
$T227584 = -3						; size = 1
$T227583 = -2						; size = 1
$T227582 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T227582[ebp], al
	mov	cl, BYTE PTR __Cat$227587[ebp]
	mov	BYTE PTR $T227583[ebp], cl
	mov	dl, BYTE PTR $T227582[ebp]
	mov	BYTE PTR $T227624[ebp], dl
	mov	al, BYTE PTR $T227584[ebp]
	mov	BYTE PTR $T227623[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227622[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227621[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T227611[ebp], al
	mov	cl, BYTE PTR __Cat$227614[ebp]
	mov	BYTE PTR $T227612[ebp], cl
	mov	dl, BYTE PTR $T227611[ebp]
	mov	BYTE PTR $T227608[ebp], dl
	mov	eax, DWORD PTR $T227622[ebp]
	mov	DWORD PTR $T227607[ebp], eax
	mov	ecx, DWORD PTR $T227621[ebp]
	mov	DWORD PTR $T227606[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T227606[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$227618[ebp], edx
	mov	eax, DWORD PTR __Off$227618[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T227607[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$227619[ebp], ecx
	cmp	DWORD PTR __Off$227618[ebp], 0
	jle	SHORT $LN7@Unchecked_@2
	mov	edx, DWORD PTR __Off$227618[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T227606[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$227618[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$227619[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_@2:
	mov	eax, DWORD PTR __Result$227619[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z
_TEXT	SEGMENT
tv190 = -32						; size = 4
tv179 = -28						; size = 4
tv171 = -24						; size = 4
$T227705 = -17						; size = 1
$T227669 = -16						; size = 4
$T227668 = -12						; size = 4
$T227627 = -8						; size = 8
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z PROC ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	cmp	DWORD PTR __First$[ebp+4], 31		; 0000001fH
	jae	SHORT $LN11@Fill
	mov	eax, DWORD PTR __First$[ebp+4]
	add	eax, 1
	mov	DWORD PTR __First$[ebp+4], eax
	jmp	SHORT $LN3@Fill
$LN11@Fill:
	mov	DWORD PTR __First$[ebp+4], 0
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN18@Fill
	mov	eax, DWORD PTR __First$[ebp+4]
	cmp	eax, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN18@Fill
	mov	DWORD PTR tv171[ebp], 1
	jmp	SHORT $LN14@Fill
$LN18@Fill:
	mov	DWORD PTR tv171[ebp], 0
$LN14@Fill:
	movzx	ecx, BYTE PTR tv171[ebp]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR $T227669[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227668[ebp], ecx
	mov	edx, DWORD PTR $T227668[ebp]
	mov	DWORD PTR $T227627[ebp], edx
	mov	eax, DWORD PTR $T227669[ebp]
	mov	DWORD PTR $T227627[ebp+4], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T227705[ebp], dl
	movzx	eax, BYTE PTR $T227705[ebp]
	test	eax, eax
	je	SHORT $LN34@Fill
	mov	ecx, DWORD PTR $T227627[ebp]
	mov	DWORD PTR tv179[ebp], ecx
	mov	edx, 1
	mov	ecx, DWORD PTR $T227627[ebp+4]
	shl	edx, cl
	mov	eax, DWORD PTR tv179[ebp]
	or	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv179[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN28@Fill
$LN34@Fill:
	mov	edx, DWORD PTR $T227627[ebp]
	mov	DWORD PTR tv190[ebp], edx
	mov	eax, 1
	mov	ecx, DWORD PTR $T227627[ebp+4]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR tv190[ebp]
	and	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR tv190[ebp]
	mov	DWORD PTR [edx], eax
$LN28@Fill:
	jmp	$LN2@Fill
$LN4@Fill:

; 3160 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@_N@std@@YAXV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@0AB_N@Z ENDP ; std::_Fill<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv150 = -44						; size = 4
$T227789 = -32						; size = 4
$T227788 = -28						; size = 4
$T227751 = -24						; size = 4
$T227750 = -20						; size = 4
$T227709 = -16						; size = 8
$T227708 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
$LN2@Copy_backw:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN9@Copy_backw
	mov	ecx, DWORD PTR __First$[ebp+4]
	cmp	ecx, DWORD PTR __Last$[ebp+4]
	jne	SHORT $LN9@Copy_backw
	mov	DWORD PTR tv150[ebp], 1
	jmp	SHORT $LN5@Copy_backw
$LN9@Copy_backw:
	mov	DWORD PTR tv150[ebp], 0
$LN5@Copy_backw:
	movzx	edx, BYTE PTR tv150[ebp]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	cmp	DWORD PTR __Last$[ebp+4], 0
	je	SHORT $LN16@Copy_backw
	mov	ecx, DWORD PTR __Last$[ebp+4]
	sub	ecx, 1
	mov	DWORD PTR __Last$[ebp+4], ecx
	jmp	SHORT $LN11@Copy_backw
$LN16@Copy_backw:
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Last$[ebp], edx
	mov	DWORD PTR __Last$[ebp+4], 31		; 0000001fH
$LN11@Copy_backw:
	mov	eax, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR $T227751[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T227750[ebp], ecx
	mov	edx, DWORD PTR $T227750[ebp]
	mov	DWORD PTR $T227709[ebp], edx
	mov	eax, DWORD PTR $T227751[ebp]
	mov	DWORD PTR $T227709[ebp+4], eax
	cmp	DWORD PTR __Dest$[ebp+4], 0
	je	SHORT $LN30@Copy_backw
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	sub	ecx, 1
	mov	DWORD PTR __Dest$[ebp+4], ecx
	jmp	SHORT $LN25@Copy_backw
$LN30@Copy_backw:
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], 31		; 0000001fH
$LN25@Copy_backw:
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR $T227789[ebp], eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227788[ebp], ecx
	mov	edx, DWORD PTR $T227788[ebp]
	mov	DWORD PTR $T227708[ebp], edx
	mov	eax, DWORD PTR $T227789[ebp]
	mov	DWORD PTR $T227708[ebp+4], eax
	lea	ecx, DWORD PTR $T227709[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T227708[ebp]
	call	??4?$_Vb_reference@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Vb_reference<unsigned int,int,std::vector<bool,std::allocator<bool> > >::operator=
	jmp	$LN2@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vb_iterator@IHV?$vector@_NV?$allocator@_N@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::_Vb_iterator<unsigned int,int,std::vector<bool,std::allocator<bool> > >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
$T227870 = -22						; size = 1
$T227869 = -21						; size = 1
$T227868 = -20						; size = 4
$T227859 = -13						; size = 1
$T227858 = -12						; size = 4
$T227857 = -8						; size = 4
$T227861 = -4						; size = 1
$T227844 = -2						; size = 1
$T227843 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T227843[ebp], al
	mov	cl, BYTE PTR $T227843[ebp]
	mov	BYTE PTR $T227870[ebp], cl
	mov	dl, BYTE PTR $T227844[ebp]
	mov	BYTE PTR $T227869[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227868[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227861[ebp], cl
	mov	dl, BYTE PTR $T227861[ebp]
	mov	BYTE PTR $T227859[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T227858[ebp], eax
	mov	ecx, DWORD PTR $T227868[ebp]
	mov	DWORD PTR $T227857[ebp], ecx
	jmp	SHORT $LN9@unchecked_@2
$LN8@unchecked_@2:
	mov	edx, DWORD PTR $T227858[ebp]
	sub	edx, 1
	mov	DWORD PTR $T227858[ebp], edx
	mov	eax, DWORD PTR $T227857[ebp]
	add	eax, 4
	mov	DWORD PTR $T227857[ebp], eax
$LN9@unchecked_@2:
	cmp	DWORD PTR $T227858[ebp], 0
	jbe	SHORT $LN1@unchecked_@2
	mov	ecx, DWORD PTR $T227857[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@2
$LN1@unchecked_@2:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
$T227887 = -21						; size = 1
$T227886 = -20						; size = 4
$T227885 = -16						; size = 4
__Result$227883 = -12					; size = 4
__Count$227882 = -8					; size = 4
__Cat$227877 = -3					; size = 1
$T227874 = -2						; size = 1
$T227873 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T227873[ebp], al
	mov	cl, BYTE PTR __Cat$227877[ebp]
	mov	BYTE PTR $T227874[ebp], cl
	mov	dl, BYTE PTR $T227873[ebp]
	mov	BYTE PTR $T227887[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227886[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227885[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T227885[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$227882[ebp], edx
	mov	eax, DWORD PTR __Count$227882[ebp]
	mov	ecx, DWORD PTR $T227886[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$227883[ebp], edx
	cmp	DWORD PTR __Count$227882[ebp], 0
	jbe	SHORT $LN6@unchecked_@3
	mov	eax, DWORD PTR __Count$227882[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T227885[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$227882[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T227886[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@3:
	mov	eax, DWORD PTR __Result$227883[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
END
