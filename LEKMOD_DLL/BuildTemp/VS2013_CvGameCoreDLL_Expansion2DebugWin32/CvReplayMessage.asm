; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvReplayMessage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?Version@CvReplayMessage@@SAIXZ			; CvReplayMessage::Version
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplaymessage.cpp
;	COMDAT ?Version@CvReplayMessage@@SAIXZ
_TEXT	SEGMENT
?Version@CvReplayMessage@@SAIXZ PROC			; CvReplayMessage::Version, COMDAT

; 17   : {

	push	ebp
	mov	ebp, esp

; 18   : 	return 2;

	mov	eax, 2

; 19   : }

	pop	ebp
	ret	0
?Version@CvReplayMessage@@SAIXZ ENDP			; CvReplayMessage::Version
_TEXT	ENDS
PUBLIC	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
PUBLIC	??_7CvReplayMessage@@6B@			; CvReplayMessage::`vftable'
PUBLIC	??0CvReplayMessage@@QAE@XZ			; CvReplayMessage::CvReplayMessage
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_ECvReplayMessage@@UAEPAXI@Z:PROC		; CvReplayMessage::`vector deleting destructor'
;	COMDAT ??_7CvReplayMessage@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_7CvReplayMessage@@6B@ DD FLAT:??_ECvReplayMessage@@UAEPAXI@Z ; CvReplayMessage::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvReplayMessage@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayMessage@@QAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayMessage@@QAE@XZ$0
__ehfuncinfo$??0CvReplayMessage@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvReplayMessage@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplaymessage.cpp
xdata$x	ENDS
;	COMDAT ??0CvReplayMessage@@QAE@XZ
_TEXT	SEGMENT
tv137 = -140						; size = 4
tv162 = -136						; size = 4
_this$ = -132						; size = 4
$T218393 = -128						; size = 4
$T218388 = -124						; size = 4
$T218338 = -30						; size = 1
$T218325 = -29						; size = 1
$T218321 = -28						; size = 4
$T218314 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvReplayMessage@@QAE@XZ PROC				; CvReplayMessage::CvReplayMessage, COMDAT
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvReplayMessage@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvReplayMessage@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T218388[ebp], eax
	lea	ecx, DWORD PTR $T218338[ebp]
	mov	DWORD PTR $T218314[ebp], ecx
	lea	edx, DWORD PTR $T218325[ebp]
	mov	DWORD PTR $T218321[ebp], edx
	mov	eax, DWORD PTR $T218388[ebp]
	mov	DWORD PTR tv162[ebp], eax
	mov	ecx, DWORD PTR $T218388[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR $T218388[ebp]
	call	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T218393[ebp], eax
	mov	ecx, DWORD PTR $T218393[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 26   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReplayMessage@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T218388[ebp]
	jmp	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CvReplayMessage@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
__ehhandler$??0CvReplayMessage@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvReplayMessage@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReplayMessage@@QAE@XZ ENDP				; CvReplayMessage::CvReplayMessage
PUBLIC	??1CvReplayMessage@@UAE@XZ			; CvReplayMessage::~CvReplayMessage
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvReplayMessage@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvReplayMessage@@UAEPAXI@Z PROC			; CvReplayMessage::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvReplayMessage@@UAE@XZ		; CvReplayMessage::~CvReplayMessage
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvReplayMessage@@UAEPAXI@Z ENDP			; CvReplayMessage::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z ; CvReplayMessage::CvReplayMessage
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z$0
__ehfuncinfo$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplaymessage.cpp
xdata$x	ENDS
;	COMDAT ??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
tv137 = -140						; size = 4
tv162 = -136						; size = 4
_this$ = -132						; size = 4
$T218495 = -128						; size = 4
$T218490 = -124						; size = 4
$T218441 = -30						; size = 1
$T218428 = -29						; size = 1
$T218424 = -28						; size = 4
$T218417 = -20						; size = 4
__$EHRec$ = -12						; size = 12
_iTurn$ = 8						; size = 4
_eType$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z PROC ; CvReplayMessage::CvReplayMessage, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvReplayMessage@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iTurn$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T218490[ebp], edx
	lea	eax, DWORD PTR $T218441[ebp]
	mov	DWORD PTR $T218417[ebp], eax
	lea	ecx, DWORD PTR $T218428[ebp]
	mov	DWORD PTR $T218424[ebp], ecx
	mov	edx, DWORD PTR $T218490[ebp]
	mov	DWORD PTR tv162[ebp], edx
	mov	eax, DWORD PTR $T218490[ebp]
	mov	DWORD PTR tv137[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR $T218490[ebp]
	call	?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [ecx+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T218495[ebp], eax
	mov	ecx, DWORD PTR $T218495[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 33   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z$2:
	mov	ecx, DWORD PTR $T218490[ebp]
	jmp	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
__ehhandler$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvReplayMessage@@QAE@HW4ReplayMessageTypes@@W4PlayerTypes@@@Z ENDP ; CvReplayMessage::CvReplayMessage
PUBLIC	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvReplayMessage@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvReplayMessage@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvReplayMessage@@UAE@XZ$3
__ehfuncinfo$??1CvReplayMessage@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvReplayMessage@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvreplaymessage.cpp
xdata$x	ENDS
;	COMDAT ??1CvReplayMessage@@UAE@XZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T218596 = -52						; size = 4
$T218510 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvReplayMessage@@UAE@XZ PROC				; CvReplayMessage::~CvReplayMessage, COMDAT
; _this$ = ecx

; 36   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvReplayMessage@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvReplayMessage@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 37   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T218510[ebp], ecx
	mov	ecx, DWORD PTR $T218510[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T218596[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T218596[ebp]
	call	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvReplayMessage@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
__unwindfunclet$??1CvReplayMessage@@UAE@XZ$3:
	mov	ecx, DWORD PTR $T218596[ebp]
	jmp	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
__ehhandler$??1CvReplayMessage@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvReplayMessage@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvReplayMessage@@UAE@XZ ENDP				; CvReplayMessage::~CvReplayMessage
PUBLIC	?setTurn@CvReplayMessage@@QAEXH@Z		; CvReplayMessage::setTurn
; Function compile flags: /Odtp
;	COMDAT ?setTurn@CvReplayMessage@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iTurn$ = 8						; size = 4
?setTurn@CvReplayMessage@@QAEXH@Z PROC			; CvReplayMessage::setTurn, COMDAT
; _this$ = ecx

; 40   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	m_iTurn = iTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iTurn$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 42   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setTurn@CvReplayMessage@@QAEXH@Z ENDP			; CvReplayMessage::setTurn
_TEXT	ENDS
PUBLIC	?getTurn@CvReplayMessage@@QBEHXZ		; CvReplayMessage::getTurn
; Function compile flags: /Odtp
;	COMDAT ?getTurn@CvReplayMessage@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTurn@CvReplayMessage@@QBEHXZ PROC			; CvReplayMessage::getTurn, COMDAT
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	return m_iTurn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 47   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTurn@CvReplayMessage@@QBEHXZ ENDP			; CvReplayMessage::getTurn
_TEXT	ENDS
PUBLIC	?setType@CvReplayMessage@@QAEXW4ReplayMessageTypes@@@Z ; CvReplayMessage::setType
; Function compile flags: /Odtp
;	COMDAT ?setType@CvReplayMessage@@QAEXW4ReplayMessageTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eType$ = 8						; size = 4
?setType@CvReplayMessage@@QAEXW4ReplayMessageTypes@@@Z PROC ; CvReplayMessage::setType, COMDAT
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	m_eType = eType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eType$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 52   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setType@CvReplayMessage@@QAEXW4ReplayMessageTypes@@@Z ENDP ; CvReplayMessage::setType
_TEXT	ENDS
PUBLIC	?getType@CvReplayMessage@@QBE?AW4ReplayMessageTypes@@XZ ; CvReplayMessage::getType
; Function compile flags: /Odtp
;	COMDAT ?getType@CvReplayMessage@@QBE?AW4ReplayMessageTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getType@CvReplayMessage@@QBE?AW4ReplayMessageTypes@@XZ PROC ; CvReplayMessage::getType, COMDAT
; _this$ = ecx

; 55   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 	return m_eType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 57   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getType@CvReplayMessage@@QBE?AW4ReplayMessageTypes@@XZ ENDP ; CvReplayMessage::getType
_TEXT	ENDS
PUBLIC	?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z ; CvReplayMessage::setPlayer
; Function compile flags: /Odtp
;	COMDAT ?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePlayer$ = 8						; size = 4
?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z PROC	; CvReplayMessage::setPlayer, COMDAT
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 	m_ePlayer = ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ePlayer$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 62   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setPlayer@CvReplayMessage@@QAEXW4PlayerTypes@@@Z ENDP	; CvReplayMessage::setPlayer
_TEXT	ENDS
PUBLIC	?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ ; CvReplayMessage::getPlayer
; Function compile flags: /Odtp
;	COMDAT ?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ PROC	; CvReplayMessage::getPlayer, COMDAT
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	return m_ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 67   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlayer@CvReplayMessage@@QBE?AW4PlayerTypes@@XZ ENDP	; CvReplayMessage::getPlayer
_TEXT	ENDS
PUBLIC	?setText@CvReplayMessage@@QAEXABVCvString@@@Z	; CvReplayMessage::setText
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?setText@CvReplayMessage@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T218620 = -4						; size = 4
_strText$ = 8						; size = 4
?setText@CvReplayMessage@@QAEXABVCvString@@@Z PROC	; CvReplayMessage::setText, COMDAT
; _this$ = ecx

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 	m_strText = strText;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR $T218620[ebp], eax
	mov	ecx, DWORD PTR _strText$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T218620[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setText@CvReplayMessage@@QAEXABVCvString@@@Z ENDP	; CvReplayMessage::setText
_TEXT	ENDS
PUBLIC	?getText@CvReplayMessage@@QBEABVCvString@@XZ	; CvReplayMessage::getText
; Function compile flags: /Odtp
;	COMDAT ?getText@CvReplayMessage@@QBEABVCvString@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getText@CvReplayMessage@@QBEABVCvString@@XZ PROC	; CvReplayMessage::getText, COMDAT
; _this$ = ecx

; 75   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 	return m_strText;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H

; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getText@CvReplayMessage@@QBEABVCvString@@XZ ENDP	; CvReplayMessage::getText
_TEXT	ENDS
PUBLIC	?push_back@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXABU?$pair@FF@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::push_back
PUBLIC	?addPlot@CvReplayMessage@@QAEXHH@Z		; CvReplayMessage::addPlot
; Function compile flags: /Odtp
;	COMDAT ?addPlot@CvReplayMessage@@QAEXHH@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T218660 = -32						; size = 4
$T218636 = -28						; size = 4
$T218626 = -24						; size = 4
$T218625 = -20						; size = 4
_position$217221 = -16					; size = 4
_it$217215 = -12					; size = 4
_sPlotX$ = -8						; size = 2
_sPlotY$ = -4						; size = 2
_iPlotX$ = 8						; size = 4
_iPlotY$ = 12						; size = 4
?addPlot@CvReplayMessage@@QAEXHH@Z PROC			; CvReplayMessage::addPlot, COMDAT
; _this$ = ecx

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 	short sPlotX = (short)iPlotX;

	mov	ax, WORD PTR _iPlotX$[ebp]
	mov	WORD PTR _sPlotX$[ebp], ax

; 82   : 	short sPlotY = (short)iPlotY;

	mov	cx, WORD PTR _iPlotY$[ebp]
	mov	WORD PTR _sPlotY$[ebp], cx

; 83   : 
; 84   : 	for(PlotPositionList::iterator it = m_Plots.begin(); it != m_Plots.end(); ++it)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T218636[ebp], eax
	mov	ecx, DWORD PTR $T218636[ebp]
	mov	DWORD PTR _it$217215[ebp], ecx
	jmp	SHORT $LN4@addPlot
$LN3@addPlot:
	mov	edx, DWORD PTR _it$217215[ebp]
	add	edx, 4
	mov	DWORD PTR _it$217215[ebp], edx
$LN4@addPlot:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T218660[ebp], ecx
	mov	edx, DWORD PTR $T218660[ebp]
	mov	DWORD PTR $T218625[ebp], edx
	mov	eax, DWORD PTR _it$217215[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T218625[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@addPlot

; 85   : 	{
; 86   : 		const PlotPosition& position = (*it);

	mov	ecx, DWORD PTR _it$217215[ebp]
	mov	DWORD PTR _position$217221[ebp], ecx

; 87   : 		if(position.first == sPlotX && position.second == sPlotY)

	mov	edx, DWORD PTR _position$217221[ebp]
	movsx	eax, WORD PTR [edx]
	movsx	ecx, WORD PTR _sPlotX$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@addPlot
	mov	edx, DWORD PTR _position$217221[ebp]
	movsx	eax, WORD PTR [edx+2]
	movsx	ecx, WORD PTR _sPlotY$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN1@addPlot

; 88   : 			return;

	jmp	SHORT $LN5@addPlot
$LN1@addPlot:

; 89   : 	}

	jmp	SHORT $LN3@addPlot
$LN2@addPlot:

; 90   : 
; 91   : 	m_Plots.push_back(PlotPosition(sPlotX, sPlotY));

	mov	dx, WORD PTR _sPlotX$[ebp]
	mov	WORD PTR $T218626[ebp], dx
	mov	ax, WORD PTR _sPlotY$[ebp]
	mov	WORD PTR $T218626[ebp+2], ax
	lea	ecx, DWORD PTR $T218626[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?push_back@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXABU?$pair@FF@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::push_back
$LN5@addPlot:

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?addPlot@CvReplayMessage@@QAEXHH@Z ENDP			; CvReplayMessage::addPlot
_TEXT	ENDS
PUBLIC	?getPlot@CvReplayMessage@@QBE_NIAAH0@Z		; CvReplayMessage::getPlot
; Function compile flags: /Odtp
;	COMDAT ?getPlot@CvReplayMessage@@QBE_NIAAH0@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T218807 = -8						; size = 4
_position$217257 = -4					; size = 4
_idx$ = 8						; size = 4
_iPlotX$ = 12						; size = 4
_iPlotY$ = 16						; size = 4
?getPlot@CvReplayMessage@@QBE_NIAAH0@Z PROC		; CvReplayMessage::getPlot, COMDAT
; _this$ = ecx

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	if(idx < m_Plots.size())

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T218807[ebp], eax
	mov	ecx, DWORD PTR $T218807[ebp]
	mov	edx, DWORD PTR $T218807[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	cmp	DWORD PTR _idx$[ebp], eax
	jae	SHORT $LN1@getPlot

; 97   : 	{
; 98   : 		const PlotPosition& position = m_Plots[idx];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _idx$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _position$217257[ebp], ecx

; 99   : 		iPlotX = (int)position.first;

	mov	edx, DWORD PTR _position$217257[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _iPlotX$[ebp]
	mov	DWORD PTR [ecx], eax

; 100  : 		iPlotY = (int)position.second;

	mov	edx, DWORD PTR _position$217257[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR [ecx], eax

; 101  : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@getPlot
$LN1@getPlot:

; 102  : 	}
; 103  : 
; 104  : 	return false;

	xor	al, al
$LN2@getPlot:

; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getPlot@CvReplayMessage@@QBE_NIAAH0@Z ENDP		; CvReplayMessage::getPlot
_TEXT	ENDS
PUBLIC	?getNumPlots@CvReplayMessage@@QBEIXZ		; CvReplayMessage::getNumPlots
; Function compile flags: /Odtp
;	COMDAT ?getNumPlots@CvReplayMessage@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T218816 = -4						; size = 4
?getNumPlots@CvReplayMessage@@QBEIXZ PROC		; CvReplayMessage::getNumPlots, COMDAT
; _this$ = ecx

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	return m_Plots.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T218816[ebp], eax
	mov	ecx, DWORD PTR $T218816[ebp]
	mov	edx, DWORD PTR $T218816[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumPlots@CvReplayMessage@@QBEIXZ ENDP		; CvReplayMessage::getNumPlots
_TEXT	ENDS
PUBLIC	?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase
PUBLIC	?clearPlots@CvReplayMessage@@QAEXXZ		; CvReplayMessage::clearPlots
; Function compile flags: /Odtp
;	COMDAT ?clearPlots@CvReplayMessage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T219017 = -96						; size = 4
$T218850 = -28						; size = 4
$T218834 = -24						; size = 4
$T219004 = -20						; size = 4
$T219003 = -16						; size = 4
$T219002 = -12						; size = 4
$T219001 = -8						; size = 4
$T219000 = -4						; size = 4
?clearPlots@CvReplayMessage@@QAEXXZ PROC		; CvReplayMessage::clearPlots, COMDAT
; _this$ = ecx

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 	m_Plots.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T219017[ebp], eax
	mov	ecx, DWORD PTR $T219017[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218834[ebp], edx
	mov	eax, DWORD PTR $T218834[ebp]
	mov	DWORD PTR $T219001[ebp], eax
	mov	ecx, DWORD PTR $T219001[ebp]
	mov	DWORD PTR $T219000[ebp], ecx
	mov	edx, DWORD PTR $T219017[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218850[ebp], eax
	mov	ecx, DWORD PTR $T218850[ebp]
	mov	DWORD PTR $T219003[ebp], ecx
	mov	edx, DWORD PTR $T219003[ebp]
	mov	DWORD PTR $T219002[ebp], edx
	mov	eax, DWORD PTR $T219000[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219002[ebp]
	push	ecx
	lea	edx, DWORD PTR $T219004[ebp]
	push	edx
	mov	ecx, DWORD PTR $T219017[ebp]
	call	?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase

; 115  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clearPlots@CvReplayMessage@@QAEXXZ ENDP		; CvReplayMessage::clearPlots
_TEXT	ENDS
PUBLIC	?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::reserve
PUBLIC	?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z	; CvReplayMessage::read
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAF@Z:PROC		; FDataStream::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ReplayMessageTypes@@@Z:PROC ; operator>>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T219020 = -20						; size = 4
_sPlotX$217280 = -16					; size = 2
_sPlotY$217281 = -12					; size = 2
_i$217276 = -8						; size = 4
_nPlots$ = -4						; size = 4
_kStream$ = 8						; size = 4
_uiVersion$ = 12					; size = 4
?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z PROC	; CvReplayMessage::read, COMDAT
; _this$ = ecx

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 	UNREFERENCED_PARAMETER(uiVersion);
; 120  : 
; 121  : 	kStream >> m_iTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 122  : 	kStream >> m_eType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??5@YAAAVFDataStream@@AAV0@AAW4ReplayMessageTypes@@@Z ; operator>>
	add	esp, 8

; 123  : 
; 124  : 	int nPlots = -1;

	mov	DWORD PTR _nPlots$[ebp], -1

; 125  : 	kStream >> nPlots;

	lea	eax, DWORD PTR _nPlots$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 126  : 	if(nPlots > 0)

	cmp	DWORD PTR _nPlots$[ebp], 0
	jle	SHORT $LN4@read

; 127  : 	{
; 128  : 		m_Plots.reserve(nPlots);

	mov	ecx, DWORD PTR _nPlots$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::reserve

; 129  : 		for(int i = 0; i < nPlots; ++i)

	mov	DWORD PTR _i$217276[ebp], 0
	jmp	SHORT $LN3@read
$LN2@read:
	mov	edx, DWORD PTR _i$217276[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217276[ebp], edx
$LN3@read:
	mov	eax, DWORD PTR _i$217276[ebp]
	cmp	eax, DWORD PTR _nPlots$[ebp]
	jge	SHORT $LN4@read

; 130  : 		{
; 131  : 			short sPlotX, sPlotY;
; 132  : 			kStream >> sPlotX;

	lea	ecx, DWORD PTR _sPlotX$217280[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 133  : 			kStream >> sPlotY;

	lea	edx, DWORD PTR _sPlotY$217281[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAF@Z		; FDataStream::Read

; 134  : 			m_Plots.push_back(PlotPosition(sPlotX, sPlotY));

	mov	ax, WORD PTR _sPlotX$217280[ebp]
	mov	WORD PTR $T219020[ebp], ax
	mov	cx, WORD PTR _sPlotY$217281[ebp]
	mov	WORD PTR $T219020[ebp+2], cx
	lea	edx, DWORD PTR $T219020[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?push_back@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXABU?$pair@FF@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::push_back

; 135  : 		}

	jmp	SHORT $LN2@read
$LN4@read:

; 136  : 	}
; 137  : 
; 138  : 	kStream >> m_ePlayer;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 139  : 	kStream >> m_strText;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 140  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?read@CvReplayMessage@@QAEXAAVFDataStream@@I@Z ENDP	; CvReplayMessage::read
_TEXT	ENDS
PUBLIC	?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z	; CvReplayMessage::write
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABF@Z:PROC		; FDataStream::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ReplayMessageTypes@@@Z:PROC ; operator<<
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T219211 = -32						; size = 4
$T219204 = -28						; size = 4
$T219185 = -24						; size = 4
$T219173 = -20						; size = 4
$T219165 = -16						; size = 4
$T219158 = -12						; size = 4
$T219157 = -8						; size = 4
_it$217300 = -4						; size = 4
_kStream$ = 8						; size = 4
?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z PROC	; CvReplayMessage::write, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 	kStream << m_iTurn;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 145  : 	kStream << m_eType;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ReplayMessageTypes@@@Z ; operator<<
	add	esp, 8

; 146  : 
; 147  : 	kStream << (int)m_Plots.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T219165[ebp], eax
	mov	ecx, DWORD PTR $T219165[ebp]
	mov	edx, DWORD PTR $T219165[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T219157[ebp], eax
	lea	ecx, DWORD PTR $T219157[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 148  : 	for(PlotPositionList::const_iterator it = m_Plots.begin(); it != m_Plots.end(); ++it)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T219173[ebp], eax
	mov	ecx, DWORD PTR $T219173[ebp]
	mov	DWORD PTR _it$217300[ebp], ecx
	jmp	SHORT $LN3@write
$LN2@write:
	mov	edx, DWORD PTR _it$217300[ebp]
	add	edx, 4
	mov	DWORD PTR _it$217300[ebp], edx
$LN3@write:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T219185[ebp], ecx
	mov	edx, DWORD PTR $T219185[ebp]
	mov	DWORD PTR $T219158[ebp], edx
	mov	eax, DWORD PTR _it$217300[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T219158[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@write

; 149  : 	{
; 150  : 		kStream << (*it).first;

	mov	ecx, DWORD PTR _it$217300[ebp]
	mov	DWORD PTR $T219204[ebp], ecx
	mov	edx, DWORD PTR $T219204[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 151  : 		kStream << (*it).second;

	mov	eax, DWORD PTR _it$217300[ebp]
	add	eax, 2
	mov	DWORD PTR $T219211[ebp], eax
	mov	ecx, DWORD PTR $T219211[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABF@Z		; FDataStream::Write

; 152  : 	}

	jmp	SHORT $LN2@write
$LN1@write:

; 153  : 
; 154  : 	kStream << m_ePlayer;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 155  : 	kStream << m_strText;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write@CvReplayMessage@@QBEXAAVFDataStream@@@Z ENDP	; CvReplayMessage::write
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
PUBLIC	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
PUBLIC	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z$4
__ehfuncinfo$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
tv170 = -204						; size = 4
tv168 = -200						; size = 4
_this$ = -196						; size = 4
$T219522 = -192						; size = 4
$T219521 = -188						; size = 4
$T219517 = -184						; size = 4
$T219516 = -180						; size = 4
$T219498 = -176						; size = 4
$T219497 = -172						; size = 4
$T219481 = -168						; size = 4
__Cat$219505 = -162					; size = 1
$T219502 = -161						; size = 1
$T219449 = -160						; size = 4
$T219448 = -156						; size = 4
$T219429 = -152						; size = 4
$T219412 = -145						; size = 1
$T219411 = -144						; size = 4
$T219401 = -140						; size = 4
$T219400 = -136						; size = 4
__Cat$219443 = -130					; size = 1
$T219440 = -129						; size = 1
$T219439 = -128						; size = 1
__Cat$219436 = -127					; size = 1
$T219433 = -126						; size = 1
$T219432 = -125						; size = 1
$T219370 = -124						; size = 4
$T219354 = -120						; size = 4
__Count$219323 = -36					; size = 4
$T219304 = -32						; size = 4
$T219303 = -28						; size = 4
__Size$217340 = -24					; size = 4
__Ptr$217331 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 188				; 000000bcH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	DWORD PTR __Count$219323[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$219323[ebp], 0
	jbe	SHORT $LN16@reserve
	mov	eax, DWORD PTR __Count$219323[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN12@reserve
$LN16@reserve:
	mov	DWORD PTR tv168[ebp], 1
$LN12@reserve:
	mov	ecx, DWORD PTR tv168[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
	jmp	$LN7@reserve
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN26@reserve
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN24@reserve
$LN26@reserve:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR tv170[ebp], edx
$LN24@reserve:
	mov	eax, DWORD PTR tv170[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
	add	esp, 8
	mov	DWORD PTR __Ptr$217331[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219354[ebp], eax
	mov	ecx, DWORD PTR $T219354[ebp]
	mov	DWORD PTR $T219303[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219370[ebp], eax
	mov	ecx, DWORD PTR $T219370[ebp]
	mov	DWORD PTR $T219304[ebp], ecx
	mov	edx, DWORD PTR $T219303[ebp]
	mov	DWORD PTR $T219449[ebp], edx
	mov	eax, DWORD PTR $T219304[ebp]
	mov	DWORD PTR $T219448[ebp], eax
	mov	ecx, DWORD PTR __Ptr$217331[ebp]
	mov	DWORD PTR $T219429[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T219432[ebp], dl
	mov	al, BYTE PTR __Cat$219436[ebp]
	mov	BYTE PTR $T219433[ebp], al
	mov	cl, BYTE PTR $T219432[ebp]
	mov	BYTE PTR $T219412[ebp], cl
	mov	edx, DWORD PTR $T219429[ebp]
	mov	DWORD PTR $T219411[ebp], edx
	mov	eax, DWORD PTR $T219411[ebp]
	mov	DWORD PTR $T219401[ebp], eax
	mov	ecx, DWORD PTR $T219448[ebp]
	mov	DWORD PTR $T219400[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T219439[ebp], dl
	mov	al, BYTE PTR __Cat$219443[ebp]
	mov	BYTE PTR $T219440[ebp], al
	movzx	ecx, BYTE PTR $T219439[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T219440[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219401[ebp]
	push	ecx
	mov	edx, DWORD PTR $T219449[ebp]
	push	edx
	mov	eax, DWORD PTR $T219400[ebp]
	push	eax
	call	??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@reserve
__catch$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Ptr$217331[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@reserve
	ret	0
$LN8@reserve:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 615  : 
; 616  : 			size_type _Size = size();

$LN61@reserve:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR __Size$217340[ebp], ecx

; 617  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN1@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T219517[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219516[ebp], eax
	mov	ecx, DWORD PTR $T219517[ebp]
	mov	DWORD PTR $T219498[ebp], ecx
	mov	edx, DWORD PTR $T219516[ebp]
	mov	DWORD PTR $T219497[ebp], edx
	mov	al, BYTE PTR __Cat$219505[ebp]
	mov	BYTE PTR $T219502[ebp], al
	mov	ecx, DWORD PTR $T219497[ebp]
	mov	DWORD PTR $T219481[ebp], ecx
	jmp	SHORT $LN71@reserve
$LN70@reserve:
	mov	edx, DWORD PTR $T219481[ebp]
	add	edx, 4
	mov	DWORD PTR $T219481[ebp], edx
$LN71@reserve:
	mov	eax, DWORD PTR $T219481[ebp]
	cmp	eax, DWORD PTR $T219498[ebp]
	je	SHORT $LN63@reserve
	jmp	SHORT $LN70@reserve
$LN63@reserve:

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T219522[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T219521[ebp], edx
	mov	eax, DWORD PTR $T219521[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$217331[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 628  : 			_Mylast = _Ptr + _Size;

	mov	edx, DWORD PTR __Size$217340[ebp]
	mov	eax, DWORD PTR __Ptr$217331[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$217331[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::reserve
PUBLIC	?insert@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@ABU?$pair@FF@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::insert
PUBLIC	??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<short,short> *,unsigned int,std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXABU?$pair@FF@2@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T219583 = -32						; size = 4
$T219573 = -28						; size = 4
$T219563 = -24						; size = 4
__Cat$219571 = -19					; size = 1
$T219568 = -18						; size = 1
$T219567 = -17						; size = 1
$T219540 = -16						; size = 4
$T219536 = -12						; size = 4
$T219535 = -8						; size = 4
$T219534 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXABU?$pair@FF@2@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T219540[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T219540[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219573[ebp], eax
	mov	ecx, DWORD PTR $T219573[ebp]
	mov	DWORD PTR $T219563[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T219567[ebp], dl
	mov	al, BYTE PTR __Cat$219571[ebp]
	mov	BYTE PTR $T219568[ebp], al
	movzx	ecx, BYTE PTR $T219567[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T219568[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T219563[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<short,short> *,unsigned int,std::pair<short,short>,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T219573[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219583[ebp], eax
	mov	ecx, DWORD PTR $T219583[ebp]
	mov	DWORD PTR $T219535[ebp], ecx
	mov	edx, DWORD PTR $T219535[ebp]
	mov	DWORD PTR $T219534[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219534[ebp]
	push	ecx
	lea	edx, DWORD PTR $T219536[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@ABU?$pair@FF@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAEXABU?$pair@FF@2@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >::~_Vector_val<std::pair<short,short>,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@ABU?$pair@FF@2@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$219709 = -24					; size = 4
$T219692 = -20						; size = 4
$T219673 = -16						; size = 4
$T219660 = -12						; size = 4
$T219657 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@ABU?$pair@FF@2@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T219673[ebp], ecx
	mov	edx, DWORD PTR $T219673[ebp]
	mov	DWORD PTR $T219657[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T219657[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T219692[ebp], edx
	mov	eax, DWORD PTR $T219692[ebp]
	mov	DWORD PTR $T219660[ebp], eax
	mov	ecx, DWORD PTR $T219660[ebp]
	mov	DWORD PTR __Tmp$219709[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$219709[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$219709[ebp], ecx
	mov	edx, DWORD PTR __Tmp$219709[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@ABU?$pair@FF@2@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T219856 = -64						; size = 4
$T219838 = -60						; size = 4
$T219837 = -56						; size = 4
$T219821 = -52						; size = 4
__Cat$219846 = -46					; size = 1
$T219843 = -45						; size = 1
$T219795 = -44						; size = 4
$T219794 = -40						; size = 4
$T219793 = -36						; size = 4
$T219776 = -30						; size = 1
$T219775 = -29						; size = 1
$T219774 = -28						; size = 4
$T219773 = -24						; size = 4
__Cat$219784 = -16					; size = 1
$T219781 = -15						; size = 1
$T219780 = -14						; size = 1
$T219779 = -13						; size = 1
__Ptr$217413 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	$LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T219795[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219794[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T219793[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T219779[ebp], cl
	mov	dl, BYTE PTR __Cat$219784[ebp]
	mov	BYTE PTR $T219780[ebp], dl
	mov	al, BYTE PTR $T219779[ebp]
	mov	BYTE PTR $T219776[ebp], al
	mov	cl, BYTE PTR $T219781[ebp]
	mov	BYTE PTR $T219775[ebp], cl
	mov	edx, DWORD PTR $T219795[ebp]
	mov	DWORD PTR $T219774[ebp], edx
	mov	eax, DWORD PTR $T219793[ebp]
	mov	DWORD PTR $T219773[ebp], eax
	jmp	SHORT $LN28@erase
$LN27@erase:
	mov	ecx, DWORD PTR $T219774[ebp]
	add	ecx, 4
	mov	DWORD PTR $T219774[ebp], ecx
	mov	edx, DWORD PTR $T219773[ebp]
	add	edx, 4
	mov	DWORD PTR $T219773[ebp], edx
$LN28@erase:
	mov	eax, DWORD PTR $T219773[ebp]
	cmp	eax, DWORD PTR $T219794[ebp]
	je	SHORT $LN20@erase
	mov	ecx, DWORD PTR $T219773[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T219774[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN27@erase
$LN20@erase:
	mov	ecx, DWORD PTR $T219774[ebp]
	mov	DWORD PTR __Ptr$217413[ebp], ecx

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T219856[ebp], eax
	mov	ecx, DWORD PTR $T219856[ebp]
	mov	DWORD PTR $T219838[ebp], ecx
	mov	edx, DWORD PTR __Ptr$217413[ebp]
	mov	DWORD PTR $T219837[ebp], edx
	mov	al, BYTE PTR __Cat$219846[ebp]
	mov	BYTE PTR $T219843[ebp], al
	mov	ecx, DWORD PTR $T219837[ebp]
	mov	DWORD PTR $T219821[ebp], ecx
	jmp	SHORT $LN39@erase
$LN38@erase:
	mov	edx, DWORD PTR $T219821[ebp]
	add	edx, 4
	mov	DWORD PTR $T219821[ebp], edx
$LN39@erase:
	mov	eax, DWORD PTR $T219821[ebp]
	cmp	eax, DWORD PTR $T219838[ebp]
	je	SHORT $LN31@erase
	jmp	SHORT $LN38@erase
$LN31@erase:

; 1049 : 			_Mylast = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$217413[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@0@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$219871 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$219871[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$219871[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$219871[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T219967 = -32						; size = 4
$T219966 = -28						; size = 4
$T219962 = -24						; size = 4
$T219961 = -20						; size = 4
$T219943 = -16						; size = 4
$T219942 = -12						; size = 4
$T219926 = -8						; size = 4
__Cat$219950 = -2					; size = 1
$T219948 = -1						; size = 1
?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T219962[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T219961[ebp], ecx
	mov	edx, DWORD PTR $T219962[ebp]
	mov	DWORD PTR $T219943[ebp], edx
	mov	eax, DWORD PTR $T219961[ebp]
	mov	DWORD PTR $T219942[ebp], eax
	mov	cl, BYTE PTR __Cat$219950[ebp]
	mov	BYTE PTR $T219948[ebp], cl
	mov	edx, DWORD PTR $T219942[ebp]
	mov	DWORD PTR $T219926[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T219926[ebp]
	add	eax, 4
	mov	DWORD PTR $T219926[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T219926[ebp]
	cmp	ecx, DWORD PTR $T219943[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T219967[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T219966[ebp], eax
	mov	ecx, DWORD PTR $T219966[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T219971 = -80						; size = 28
$T219970 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T219971[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T219970[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T219970[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T219971[ebp]
	push	eax
	lea	ecx, DWORD PTR $T219970[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T219970[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T219970[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T219971[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T219971[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T219970[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
PUBLIC	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
PUBLIC	??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$2
__catchsym$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$0
__unwindtable$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv304 = -420						; size = 4
tv290 = -416						; size = 4
tv282 = -412						; size = 4
_this$ = -408						; size = 4
$T220673 = -404						; size = 4
$T220665 = -400						; size = 4
$T220664 = -396						; size = 4
$T220641 = -390						; size = 1
$T220640 = -389						; size = 1
$T220639 = -388						; size = 4
$T220638 = -384						; size = 4
$T220626 = -377						; size = 1
$T220625 = -376						; size = 4
$T220624 = -372						; size = 4
$T220623 = -368						; size = 4
__Cat$220657 = -364					; size = 1
$T220654 = -363						; size = 1
$T220653 = -362						; size = 1
__Cat$220648 = -360					; size = 1
$T220645 = -359						; size = 1
$T220644 = -358						; size = 1
$T220643 = -357						; size = 1
$T220598 = -356						; size = 4
$T220579 = -352						; size = 4
$T220562 = -345						; size = 1
$T220561 = -344						; size = 4
$T220551 = -340						; size = 4
$T220550 = -336						; size = 4
__Cat$220593 = -330					; size = 1
$T220590 = -329						; size = 1
$T220589 = -328						; size = 1
__Cat$220586 = -327					; size = 1
$T220583 = -326						; size = 1
$T220582 = -325						; size = 1
$T220526 = -324						; size = 4
$T220518 = -320						; size = 4
$T220510 = -316						; size = 4
$T220492 = -312						; size = 4
$T220491 = -308						; size = 4
$T220475 = -304						; size = 4
__Cat$220498 = -298					; size = 1
$T220495 = -297						; size = 1
$T220449 = -296						; size = 4
$T220448 = -292						; size = 4
$T220438 = -288						; size = 4
__Cat$220445 = -283					; size = 1
$T220442 = -282						; size = 1
$T220441 = -281						; size = 1
$T220422 = -280						; size = 4
$T220403 = -276						; size = 4
$T220386 = -269						; size = 1
$T220385 = -268						; size = 4
$T220375 = -264						; size = 4
$T220374 = -260						; size = 4
__Cat$220417 = -254					; size = 1
$T220414 = -253						; size = 1
$T220413 = -252						; size = 1
__Cat$220410 = -251					; size = 1
$T220407 = -250						; size = 1
$T220406 = -249						; size = 1
$T220350 = -248						; size = 4
$T220349 = -244						; size = 4
$T220345 = -240						; size = 4
$T220344 = -236						; size = 4
$T220326 = -232						; size = 4
$T220325 = -228						; size = 4
$T220309 = -224						; size = 4
__Cat$220332 = -218					; size = 1
$T220329 = -217						; size = 1
$T220260 = -216						; size = 4
$T220259 = -212						; size = 4
$T220243 = -208						; size = 4
__Cat$220266 = -202					; size = 1
$T220263 = -201						; size = 1
$T220200 = -200						; size = 4
$T220199 = -196						; size = 4
$T220183 = -192						; size = 4
__Cat$220204 = -186					; size = 1
$T220201 = -185						; size = 1
$T220157 = -184						; size = 4
$T220145 = -180						; size = 4
$T220135 = -173						; size = 1
$T220134 = -172						; size = 4
__Cat$220153 = -167					; size = 1
$T220151 = -166						; size = 1
$T220150 = -165						; size = 1
$T220122 = -164						; size = 4
$T220110 = -160						; size = 4
$T220100 = -153						; size = 1
$T220099 = -152						; size = 4
__Cat$220118 = -147					; size = 1
$T220116 = -146						; size = 1
$T220115 = -145						; size = 1
$T220087 = -144						; size = 4
$T220077 = -140						; size = 4
__Cat$220085 = -135					; size = 1
$T220083 = -134						; size = 1
$T220082 = -133						; size = 1
__Count$220047 = -120					; size = 4
__Count$220021 = -48					; size = 4
__Tmp$217524 = -44					; size = 4
__Oldend$217525 = -40					; size = 4
__Tmp$217506 = -36					; size = 4
__Ncopied$217493 = -32					; size = 4
__Newvec$217491 = -28					; size = 4
__Whereoff$217492 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z PROC ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$220021[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$220021[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$220021[ebp]
	mov	DWORD PTR tv290[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv290[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@KAXXZ ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$220047[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$220047[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$220047[ebp]
	mov	DWORD PTR tv304[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv304[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ; std::_Allocate<std::pair<short,short> >
	add	esp, 8
	mov	DWORD PTR __Newvec$217491[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$217492[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$217493[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$217492[ebp]
	mov	ecx, DWORD PTR __Newvec$217491[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T220087[ebp], edx
	mov	eax, DWORD PTR $T220087[ebp]
	mov	DWORD PTR $T220077[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220082[ebp], cl
	mov	dl, BYTE PTR __Cat$220085[ebp]
	mov	BYTE PTR $T220083[ebp], dl
	movzx	eax, BYTE PTR $T220082[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T220083[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220077[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<short,short> *,unsigned int,std::pair<short,short>,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$217493[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$217493[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220122[ebp], edx
	mov	eax, DWORD PTR __Newvec$217491[ebp]
	mov	DWORD PTR $T220110[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220115[ebp], cl
	mov	dl, BYTE PTR __Cat$220118[ebp]
	mov	BYTE PTR $T220116[ebp], dl
	mov	al, BYTE PTR $T220115[ebp]
	mov	BYTE PTR $T220100[ebp], al
	mov	ecx, DWORD PTR $T220110[ebp]
	mov	DWORD PTR $T220099[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T220099[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220122[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$217493[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$217493[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220157[ebp], edx
	mov	eax, DWORD PTR __Whereoff$217492[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$217491[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T220145[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T220150[ebp], al
	mov	cl, BYTE PTR __Cat$220153[ebp]
	mov	BYTE PTR $T220151[ebp], cl
	mov	dl, BYTE PTR $T220150[ebp]
	mov	BYTE PTR $T220135[ebp], dl
	mov	eax, DWORD PTR $T220145[ebp]
	mov	DWORD PTR $T220134[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220134[ebp]
	push	edx
	mov	eax, DWORD PTR $T220157[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$217493[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$217492[ebp]
	mov	eax, DWORD PTR __Newvec$217491[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T220200[ebp], ecx
	mov	edx, DWORD PTR __Newvec$217491[ebp]
	mov	DWORD PTR $T220199[ebp], edx
	mov	al, BYTE PTR __Cat$220204[ebp]
	mov	BYTE PTR $T220201[ebp], al
	mov	ecx, DWORD PTR $T220199[ebp]
	mov	DWORD PTR $T220183[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T220183[ebp]
	add	edx, 4
	mov	DWORD PTR $T220183[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T220183[ebp]
	cmp	eax, DWORD PTR $T220200[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$217493[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$217492[ebp]
	mov	edx, DWORD PTR __Newvec$217491[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T220260[ebp], edx
	mov	eax, DWORD PTR __Whereoff$217492[ebp]
	mov	ecx, DWORD PTR __Newvec$217491[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T220259[ebp], edx
	mov	al, BYTE PTR __Cat$220266[ebp]
	mov	BYTE PTR $T220263[ebp], al
	mov	ecx, DWORD PTR $T220259[ebp]
	mov	DWORD PTR $T220243[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T220243[ebp]
	add	edx, 4
	mov	DWORD PTR $T220243[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T220243[ebp]
	cmp	eax, DWORD PTR $T220260[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$217491[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220345[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T220344[ebp], eax
	mov	ecx, DWORD PTR $T220345[ebp]
	mov	DWORD PTR $T220326[ebp], ecx
	mov	edx, DWORD PTR $T220344[ebp]
	mov	DWORD PTR $T220325[ebp], edx
	mov	al, BYTE PTR __Cat$220332[ebp]
	mov	BYTE PTR $T220329[ebp], al
	mov	ecx, DWORD PTR $T220325[ebp]
	mov	DWORD PTR $T220309[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T220309[ebp]
	add	edx, 4
	mov	DWORD PTR $T220309[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T220309[ebp]
	cmp	eax, DWORD PTR $T220326[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T220350[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220349[ebp], edx
	mov	eax, DWORD PTR $T220349[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$217491[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$217491[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$217491[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$217506[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T220422[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T220403[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220406[ebp], dl
	mov	al, BYTE PTR __Cat$220410[ebp]
	mov	BYTE PTR $T220407[ebp], al
	mov	cl, BYTE PTR $T220406[ebp]
	mov	BYTE PTR $T220386[ebp], cl
	mov	edx, DWORD PTR $T220403[ebp]
	mov	DWORD PTR $T220385[ebp], edx
	mov	eax, DWORD PTR $T220385[ebp]
	mov	DWORD PTR $T220375[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220374[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220413[ebp], dl
	mov	al, BYTE PTR __Cat$220417[ebp]
	mov	BYTE PTR $T220414[ebp], al
	movzx	ecx, BYTE PTR $T220413[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T220414[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220375[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220422[ebp]
	push	edx
	mov	eax, DWORD PTR $T220374[ebp]
	push	eax
	call	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T220449[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T220448[ebp], edx
	mov	eax, DWORD PTR $T220448[ebp]
	mov	DWORD PTR $T220438[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T220441[ebp], cl
	mov	dl, BYTE PTR __Cat$220445[ebp]
	mov	BYTE PTR $T220442[ebp], dl
	movzx	eax, BYTE PTR $T220441[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T220442[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$217506[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220449[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220438[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<short,short> *,unsigned int,std::pair<short,short>,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T220510[ebp], eax
	mov	ecx, DWORD PTR $T220510[ebp]
	mov	DWORD PTR $T220492[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T220491[ebp], ecx
	mov	dl, BYTE PTR __Cat$220498[ebp]
	mov	BYTE PTR $T220495[ebp], dl
	mov	eax, DWORD PTR $T220491[ebp]
	mov	DWORD PTR $T220475[ebp], eax
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	ecx, DWORD PTR $T220475[ebp]
	add	ecx, 4
	mov	DWORD PTR $T220475[ebp], ecx
$LN160@Insert_n:
	mov	edx, DWORD PTR $T220475[ebp]
	cmp	edx, DWORD PTR $T220492[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T220526[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220518[ebp], edx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	eax, DWORD PTR $T220518[ebp]
	add	eax, 4
	mov	DWORD PTR $T220518[ebp], eax
$LN171@Insert_n:
	mov	ecx, DWORD PTR $T220518[ebp]
	cmp	ecx, DWORD PTR $T220526[ebp]
	je	SHORT $LN167@Insert_n
	mov	edx, DWORD PTR __Tmp$217506[ebp]
	mov	eax, DWORD PTR $T220518[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$217524[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$217525[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T220598[ebp], eax
	mov	ecx, DWORD PTR $T220598[ebp]
	mov	DWORD PTR $T220579[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220582[ebp], dl
	mov	al, BYTE PTR __Cat$220586[ebp]
	mov	BYTE PTR $T220583[ebp], al
	mov	cl, BYTE PTR $T220582[ebp]
	mov	BYTE PTR $T220562[ebp], cl
	mov	edx, DWORD PTR $T220579[ebp]
	mov	DWORD PTR $T220561[ebp], edx
	mov	eax, DWORD PTR $T220561[ebp]
	mov	DWORD PTR $T220551[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$217525[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T220550[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T220589[ebp], al
	mov	cl, BYTE PTR __Cat$220593[ebp]
	mov	BYTE PTR $T220590[ebp], cl
	movzx	edx, BYTE PTR $T220589[ebp]
	push	edx
	movzx	eax, BYTE PTR $T220590[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T220551[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$217525[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220550[ebp]
	push	ecx
	call	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$217525[ebp]
	mov	DWORD PTR $T220665[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220664[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220643[ebp], dl
	mov	al, BYTE PTR __Cat$220648[ebp]
	mov	BYTE PTR $T220644[ebp], al
	mov	cl, BYTE PTR $T220643[ebp]
	mov	BYTE PTR $T220641[ebp], cl
	mov	dl, BYTE PTR $T220645[ebp]
	mov	BYTE PTR $T220640[ebp], dl
	mov	eax, DWORD PTR $T220665[ebp]
	mov	DWORD PTR $T220639[ebp], eax
	mov	ecx, DWORD PTR $T220664[ebp]
	mov	DWORD PTR $T220638[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T220653[ebp], dl
	mov	al, BYTE PTR __Cat$220657[ebp]
	mov	BYTE PTR $T220654[ebp], al
	mov	cl, BYTE PTR $T220653[ebp]
	mov	BYTE PTR $T220626[ebp], cl
	mov	edx, DWORD PTR $T220639[ebp]
	mov	DWORD PTR $T220625[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$217525[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T220624[ebp], ecx
	mov	edx, DWORD PTR $T220638[ebp]
	mov	DWORD PTR $T220623[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T220623[ebp]
	cmp	eax, DWORD PTR $T220624[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T220624[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T220624[ebp], ecx
	mov	edx, DWORD PTR $T220625[ebp]
	sub	edx, 4
	mov	DWORD PTR $T220625[ebp], edx
	mov	eax, DWORD PTR $T220624[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T220625[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T220673[ebp], eax
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	ecx, DWORD PTR $T220673[ebp]
	add	ecx, 4
	mov	DWORD PTR $T220673[ebp], ecx
$LN204@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T220673[ebp], ecx
	je	SHORT $LN16@Insert_n
	mov	edx, DWORD PTR __Tmp$217524[ebp]
	mov	eax, DWORD PTR $T220673[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@2@IABU?$pair@FF@2@@Z ENDP ; std::vector<std::pair<short,short>,std::allocator<std::pair<short,short> > >::_Insert_n
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z
_TEXT	SEGMENT
$T220698 = -16						; size = 4
$T220694 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<short,short> >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T220698[ebp], 0
	lea	eax, DWORD PTR $T220698[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220694[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T220694[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T220694[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U?$pair@FF@std@@@std@@YAPAU?$pair@FF@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<short,short> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T220723 = -28						; size = 4
__Vptr$220729 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<short,short> *,unsigned int,std::pair<short,short>,std::allocator<std::pair<short,short> > >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$220729[ebp], eax
	mov	ecx, DWORD PTR __Vptr$220729[ebp]
	mov	DWORD PTR $T220723[ebp], ecx
	cmp	DWORD PTR $T220723[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T220723[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR $T220723[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAU?$pair@FF@std@@IU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAXPAU?$pair@FF@0@IABU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<short,short> *,unsigned int,std::pair<short,short>,std::allocator<std::pair<short,short> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z
_TEXT	SEGMENT
__Cat$220762 = -3					; size = 1
$T220758 = -2						; size = 1
$T220757 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T220757[ebp], al
	mov	cl, BYTE PTR __Cat$220762[ebp]
	mov	BYTE PTR $T220758[ebp], cl
	movzx	edx, BYTE PTR $T220757[ebp]
	push	edx
	movzx	eax, BYTE PTR $T220758[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@stdext@@YAPAU?$pair@FF@std@@PAU12@00AAV?$allocator@U?$pair@FF@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv144 = -36						; size = 4
$T220819 = -32						; size = 4
$T220811 = -28						; size = 4
__Vptr$220817 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN18@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN18@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T220819[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$220817[ebp], edx
	mov	eax, DWORD PTR __Vptr$220817[ebp]
	mov	DWORD PTR $T220811[ebp], eax
	cmp	DWORD PTR $T220811[ebp], 0
	je	SHORT $LN30@Uninit_cop
	mov	ecx, DWORD PTR $T220819[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR $T220811[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR $T220811[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	jmp	SHORT $LN26@Uninit_cop
$LN30@Uninit_cop:
	mov	DWORD PTR tv144[ebp], 0
$LN26@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@std@@PAU?$pair@FF@2@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@V?$_Vector_iterator@U?$pair@FF@std@@V?$allocator@U?$pair@FF@std@@@2@@0@0PAU10@AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<std::pair<short,short>,std::allocator<std::pair<short,short> > >,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T220861 = -28						; size = 4
__Vptr$220867 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$220867[ebp], ecx
	mov	edx, DWORD PTR __Vptr$220867[ebp]
	mov	DWORD PTR $T220861[ebp], edx
	cmp	DWORD PTR $T220861[ebp], 0
	je	SHORT $LN18@Uninit_cop@2
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T220861[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR $T220861[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_cop@2
$LN18@Uninit_cop@2:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop@2:
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAU?$pair@FF@std@@PAU12@V?$allocator@U?$pair@FF@std@@@2@@std@@YAPAU?$pair@FF@0@PAU10@00AAV?$allocator@U?$pair@FF@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<short,short> *,std::pair<short,short> *,std::allocator<std::pair<short,short> > >
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
