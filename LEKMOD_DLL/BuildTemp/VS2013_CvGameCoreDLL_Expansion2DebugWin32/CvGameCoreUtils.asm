; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvGameCoreUtils.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?plotCity@@YAPAVCvPlot@@HHH@Z			; plotCity
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
;	COMDAT ?plotCity@@YAPAVCvPlot@@HHH@Z
_TEXT	SEGMENT
tv177 = -112						; size = 4
tv192 = -108						; size = 4
tv147 = -104						; size = 4
tv143 = -100						; size = 4
tv81 = -96						; size = 4
$T218462 = -92						; size = 4
$T218417 = -88						; size = 4
$T218404 = -84						; size = 4
$T218400 = -80						; size = 4
$T218386 = -76						; size = 4
$T218382 = -69						; size = 1
$T218371 = -68						; size = 4
$T218367 = -61						; size = 1
_iMapY$218461 = -60					; size = 4
_iMapX$218460 = -56					; size = 4
$T218360 = -52						; size = 4
_iOffset$217120 = -48					; size = 4
_iLowestValueOnThisRing$217114 = -44			; size = 4
_iDiff$217118 = -40					; size = 4
_iHighestValueOnThisRing$217113 = -36			; size = 4
_iSide$217119 = -32					; size = 4
_iThisRing$217112 = -28					; size = 4
_iPlotHexX$ = -24					; size = 4
_iPlotY$ = -20						; size = 4
_iCityHexX$ = -16					; size = 4
_iPlotX$ = -12						; size = 4
_iDeltaHexX$ = -8					; size = 4
_iDeltaHexY$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iIndex$ = 16						; size = 4
?plotCity@@YAPAVCvPlot@@HHH@Z PROC			; plotCity, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H

; 38   : 	int iDeltaHexX = 0;

	mov	DWORD PTR _iDeltaHexX$[ebp], 0

; 39   : 	int iDeltaHexY = 0;

	mov	DWORD PTR _iDeltaHexY$[ebp], 0

; 40   : 	if(iIndex < NUM_CITY_PLOTS)

	cmp	DWORD PTR _iIndex$[ebp], 37		; 00000025H
	jge	SHORT $LN13@plotCity

; 41   : 	{
; 42   : 		iDeltaHexX = GC.getCityPlotX()[iIndex]; // getCityPlotX now uses hex-space coords

	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+160]
	mov	DWORD PTR _iDeltaHexX$[ebp], ecx

; 43   : 		iDeltaHexY = GC.getCityPlotY()[iIndex];

	mov	edx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+308]
	mov	DWORD PTR _iDeltaHexY$[ebp], eax

; 44   : 	}
; 45   : 	else

	jmp	$LN12@plotCity
$LN13@plotCity:

; 46   : 	{
; 47   : 		// loop till we find the ring this is on
; 48   : 		int iThisRing = 0;

	mov	DWORD PTR _iThisRing$217112[ebp], 0

; 49   : 		int iHighestValueOnThisRing = 0;

	mov	DWORD PTR _iHighestValueOnThisRing$217113[ebp], 0

; 50   : 		int iLowestValueOnThisRing = 0;

	mov	DWORD PTR _iLowestValueOnThisRing$217114[ebp], 0
$LN11@plotCity:

; 51   : 		while(iHighestValueOnThisRing < iIndex)

	mov	ecx, DWORD PTR _iHighestValueOnThisRing$217113[ebp]
	cmp	ecx, DWORD PTR _iIndex$[ebp]
	jge	SHORT $LN10@plotCity

; 52   : 		{
; 53   : 			iThisRing++;

	mov	edx, DWORD PTR _iThisRing$217112[ebp]
	add	edx, 1
	mov	DWORD PTR _iThisRing$217112[ebp], edx

; 54   : 			iLowestValueOnThisRing = iHighestValueOnThisRing + 1;

	mov	eax, DWORD PTR _iHighestValueOnThisRing$217113[ebp]
	add	eax, 1
	mov	DWORD PTR _iLowestValueOnThisRing$217114[ebp], eax

; 55   : 			iHighestValueOnThisRing += iThisRing*6;

	mov	ecx, DWORD PTR _iThisRing$217112[ebp]
	imul	ecx, 6
	add	ecx, DWORD PTR _iHighestValueOnThisRing$217113[ebp]
	mov	DWORD PTR _iHighestValueOnThisRing$217113[ebp], ecx

; 56   : 		}

	jmp	SHORT $LN11@plotCity
$LN10@plotCity:

; 57   : 		// determine what side of the hex we are on
; 58   : 		int iDiff = (iIndex - iLowestValueOnThisRing);

	mov	edx, DWORD PTR _iIndex$[ebp]
	sub	edx, DWORD PTR _iLowestValueOnThisRing$217114[ebp]
	mov	DWORD PTR _iDiff$217118[ebp], edx

; 59   : 		int iSide = iDiff / iThisRing;

	mov	eax, DWORD PTR _iDiff$217118[ebp]
	cdq
	idiv	DWORD PTR _iThisRing$217112[ebp]
	mov	DWORD PTR _iSide$217119[ebp], eax

; 60   : 		int iOffset = iDiff % iThisRing;

	mov	eax, DWORD PTR _iDiff$217118[ebp]
	cdq
	idiv	DWORD PTR _iThisRing$217112[ebp]
	mov	DWORD PTR _iOffset$217120[ebp], edx

; 61   : 
; 62   : 		switch(iSide)

	mov	eax, DWORD PTR _iSide$217119[ebp]
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 5
	ja	SHORT $LN1@plotCity
	mov	ecx, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $LN68@plotCity[ecx*4]
$LN7@plotCity:

; 63   : 		{
; 64   : 		case 0:
; 65   : 			iDeltaHexX = 0 + iOffset;

	mov	edx, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexX$[ebp], edx

; 66   : 			iDeltaHexY = iThisRing - iOffset;

	mov	eax, DWORD PTR _iThisRing$217112[ebp]
	sub	eax, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexY$[ebp], eax

; 67   : 			break;

	jmp	SHORT $LN12@plotCity
$LN6@plotCity:

; 68   : 		case 1:
; 69   : 			iDeltaHexX = iThisRing;

	mov	ecx, DWORD PTR _iThisRing$217112[ebp]
	mov	DWORD PTR _iDeltaHexX$[ebp], ecx

; 70   : 			iDeltaHexY = 0 - iOffset;

	xor	edx, edx
	sub	edx, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexY$[ebp], edx

; 71   : 			break;

	jmp	SHORT $LN12@plotCity
$LN5@plotCity:

; 72   : 		case 2:
; 73   : 			iDeltaHexX = iThisRing - iOffset;

	mov	eax, DWORD PTR _iThisRing$217112[ebp]
	sub	eax, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexX$[ebp], eax

; 74   : 			iDeltaHexY = -iThisRing;

	mov	ecx, DWORD PTR _iThisRing$217112[ebp]
	neg	ecx
	mov	DWORD PTR _iDeltaHexY$[ebp], ecx

; 75   : 			break;

	jmp	SHORT $LN12@plotCity
$LN4@plotCity:

; 76   : 		case 3:
; 77   : 			iDeltaHexX = 0 - iOffset;

	xor	edx, edx
	sub	edx, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexX$[ebp], edx

; 78   : 			iDeltaHexY = -iThisRing + iOffset;

	mov	eax, DWORD PTR _iThisRing$217112[ebp]
	neg	eax
	add	eax, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexY$[ebp], eax

; 79   : 			break;

	jmp	SHORT $LN12@plotCity
$LN3@plotCity:

; 80   : 		case 4:
; 81   : 			iDeltaHexX = -iThisRing;

	mov	ecx, DWORD PTR _iThisRing$217112[ebp]
	neg	ecx
	mov	DWORD PTR _iDeltaHexX$[ebp], ecx

; 82   : 			iDeltaHexY = 0 + iOffset;

	mov	edx, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexY$[ebp], edx

; 83   : 			break;

	jmp	SHORT $LN12@plotCity
$LN2@plotCity:

; 84   : 		case 5:
; 85   : 			iDeltaHexX = -iThisRing + iOffset;

	mov	eax, DWORD PTR _iThisRing$217112[ebp]
	neg	eax
	add	eax, DWORD PTR _iOffset$217120[ebp]
	mov	DWORD PTR _iDeltaHexX$[ebp], eax

; 86   : 			iDeltaHexY = iThisRing;

	mov	ecx, DWORD PTR _iThisRing$217112[ebp]
	mov	DWORD PTR _iDeltaHexY$[ebp], ecx

; 87   : 			break;

	jmp	SHORT $LN12@plotCity
$LN1@plotCity:

; 88   : 		default:
; 89   : 			return 0;

	xor	eax, eax
	jmp	$LN14@plotCity
$LN12@plotCity:

; 90   : 		}
; 91   : 
; 92   : 	}
; 93   : 	// convert the city coord to hex-space coordinates
; 94   : 	int iCityHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN22@plotCity
	mov	edx, DWORD PTR _iY$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN20@plotCity
$LN22@plotCity:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv143[ebp], eax
$LN20@plotCity:
	mov	eax, DWORD PTR _iX$[ebp]
	sub	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR _iCityHexX$[ebp], eax

; 95   : 
; 96   : 	int iPlotHexX = iCityHexX + iDeltaHexX;

	mov	ecx, DWORD PTR _iCityHexX$[ebp]
	add	ecx, DWORD PTR _iDeltaHexX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], ecx

; 97   : 	int iPlotY = iY + iDeltaHexY; // Y is the same in both coordinate systems

	mov	edx, DWORD PTR _iY$[ebp]
	add	edx, DWORD PTR _iDeltaHexY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], edx

; 98   : 
; 99   : 	// convert from hex-space coordinates to the storage array
; 100  : 	int iPlotX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN26@plotCity
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN24@plotCity
$LN26@plotCity:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv147[ebp], eax
$LN24@plotCity:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	add	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR _iPlotX$[ebp], ecx

; 101  : 
; 102  : 	return GC.getMap().plot(iPlotX , iPlotY);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T218360[ebp], edx
	cmp	DWORD PTR _iPlotX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN30@plotCity
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN31@plotCity
$LN30@plotCity:
	mov	DWORD PTR $T218462[ebp], 0
	jmp	$LN32@plotCity
$LN31@plotCity:
	mov	eax, DWORD PTR $T218360[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T218367[ebp], cl
	mov	edx, DWORD PTR $T218360[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T218371[ebp], eax
	movzx	ecx, BYTE PTR $T218367[ebp]
	test	ecx, ecx
	je	SHORT $LN43@plotCity
	cmp	DWORD PTR _iPlotX$[ebp], 0
	jge	SHORT $LN42@plotCity
	mov	eax, DWORD PTR _iPlotX$[ebp]
	cdq
	idiv	DWORD PTR $T218371[ebp]
	add	edx, DWORD PTR $T218371[ebp]
	mov	DWORD PTR _iMapX$218460[ebp], edx
	jmp	SHORT $LN44@plotCity
	jmp	SHORT $LN43@plotCity
$LN42@plotCity:
	mov	edx, DWORD PTR _iPlotX$[ebp]
	cmp	edx, DWORD PTR $T218371[ebp]
	jl	SHORT $LN43@plotCity
	mov	eax, DWORD PTR _iPlotX$[ebp]
	cdq
	idiv	DWORD PTR $T218371[ebp]
	mov	DWORD PTR _iMapX$218460[ebp], edx
	jmp	SHORT $LN44@plotCity
$LN43@plotCity:
	mov	eax, DWORD PTR _iPlotX$[ebp]
	mov	DWORD PTR _iMapX$218460[ebp], eax
$LN44@plotCity:
	mov	ecx, DWORD PTR $T218360[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T218382[ebp], dl
	mov	eax, DWORD PTR $T218360[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T218386[ebp], ecx
	movzx	edx, BYTE PTR $T218382[ebp]
	test	edx, edx
	je	SHORT $LN53@plotCity
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN52@plotCity
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T218386[ebp]
	add	edx, DWORD PTR $T218386[ebp]
	mov	DWORD PTR _iMapY$218461[ebp], edx
	jmp	SHORT $LN54@plotCity
	jmp	SHORT $LN53@plotCity
$LN52@plotCity:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cmp	eax, DWORD PTR $T218386[ebp]
	jl	SHORT $LN53@plotCity
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T218386[ebp]
	mov	DWORD PTR _iMapY$218461[ebp], edx
	jmp	SHORT $LN54@plotCity
$LN53@plotCity:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$218461[ebp], ecx
$LN54@plotCity:
	cmp	DWORD PTR _iMapX$218460[ebp], 0
	jl	SHORT $LN58@plotCity
	mov	edx, DWORD PTR $T218360[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T218400[ebp], eax
	mov	ecx, DWORD PTR _iMapX$218460[ebp]
	cmp	ecx, DWORD PTR $T218400[ebp]
	jge	SHORT $LN58@plotCity
	cmp	DWORD PTR _iMapY$218461[ebp], 0
	jl	SHORT $LN58@plotCity
	mov	edx, DWORD PTR $T218360[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T218404[ebp], eax
	mov	ecx, DWORD PTR _iMapY$218461[ebp]
	cmp	ecx, DWORD PTR $T218404[ebp]
	jge	SHORT $LN58@plotCity
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN56@plotCity
$LN58@plotCity:
	mov	DWORD PTR tv192[ebp], 0
$LN56@plotCity:
	cmp	DWORD PTR tv192[ebp], 0
	je	SHORT $LN34@plotCity
	mov	edx, DWORD PTR $T218360[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T218417[ebp], eax
	mov	ecx, DWORD PTR _iMapY$218461[ebp]
	imul	ecx, DWORD PTR $T218417[ebp]
	add	ecx, DWORD PTR _iMapX$218460[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T218360[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN35@plotCity
$LN34@plotCity:
	mov	DWORD PTR tv177[ebp], 0
$LN35@plotCity:
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T218462[ebp], eax
$LN32@plotCity:
	mov	eax, DWORD PTR $T218462[ebp]
$LN14@plotCity:

; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN68@plotCity:
	DD	$LN7@plotCity
	DD	$LN6@plotCity
	DD	$LN5@plotCity
	DD	$LN4@plotCity
	DD	$LN3@plotCity
	DD	$LN2@plotCity
?plotCity@@YAPAVCvPlot@@HHH@Z ENDP			; plotCity
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
PUBLIC	?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z	; plotCityXY
EXTRN	?getXYCityPlot@CvGlobals@@QAEHHH@Z:PROC		; CvGlobals::getXYCityPlot
; Function compile flags: /Odtp
;	COMDAT ?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z
_TEXT	SEGMENT
tv166 = -132						; size = 4
tv144 = -128						; size = 4
$T218582 = -92						; size = 4
$T218574 = -88						; size = 4
$T218565 = -84						; size = 4
$T218549 = -80						; size = 4
$T218540 = -76						; size = 4
$T218511 = -56						; size = 4
$T218502 = -52						; size = 4
$T218478 = -32						; size = 4
$T218469 = -28						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iPlotHexX$ = -12					; size = 4
_iCityHexX$ = -8					; size = 4
_iWrappedDY$ = -4					; size = 4
_pCity$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z PROC		; plotCityXY, COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H

; 108  : 
; 109  : 	int iDX;
; 110  : 	int iWrappedDX = dxWrap(pPlot->getX() - pCity->getX());

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T218469[ebp], ecx
	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR $T218478[ebp], eax
	mov	ecx, DWORD PTR $T218469[ebp]
	sub	ecx, DWORD PTR $T218478[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 111  : 	int iWrappedDY = dyWrap(pPlot->getY() - pCity->getY());

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T218502[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T218511[ebp], edx
	mov	eax, DWORD PTR $T218502[ebp]
	sub	eax, DWORD PTR $T218511[ebp]
	push	eax
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 112  : 	int iDY = iWrappedDY;

	mov	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR _iDY$[ebp], ecx

; 113  : 
; 114  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 115  : 	int iCityHexX = xToHexspaceX(pCity->getX(), pCity->getY());

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T218540[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T218549[ebp], edx
	cmp	DWORD PTR $T218540[ebp], 0
	jl	SHORT $LN55@plotCityXY
	mov	eax, DWORD PTR $T218540[ebp]
	sar	eax, 1
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN53@plotCityXY
$LN55@plotCityXY:
	mov	eax, DWORD PTR $T218540[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv144[ebp], eax
$LN53@plotCityXY:
	mov	ecx, DWORD PTR $T218549[ebp]
	sub	ecx, DWORD PTR tv144[ebp]
	mov	DWORD PTR _iCityHexX$[ebp], ecx

; 116  : 	int iPlotHexX = xToHexspaceX(pCity->getX() + iWrappedDX, pCity->getY() + iWrappedDY);

	mov	edx, DWORD PTR _pCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T218565[ebp], eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T218574[ebp], edx
	mov	eax, DWORD PTR $T218565[ebp]
	add	eax, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T218582[ebp], eax
	js	SHORT $LN67@plotCityXY
	mov	ecx, DWORD PTR $T218582[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv166[ebp], ecx
	jmp	SHORT $LN65@plotCityXY
$LN67@plotCityXY:
	mov	eax, DWORD PTR $T218582[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv166[ebp], eax
$LN65@plotCityXY:
	mov	edx, DWORD PTR $T218574[ebp]
	add	edx, DWORD PTR _iWrappedDX$[ebp]
	sub	edx, DWORD PTR tv166[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 117  : 
; 118  : 	iDX = dxWrap(iPlotHexX - iCityHexX);

	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	sub	eax, DWORD PTR _iCityHexX$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iDX$[ebp], eax

; 119  : 
; 120  : 	if(hexDistance(iDX, iDY) > CITY_PLOTS_RADIUS)

	mov	ecx, DWORD PTR _iDY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDX$[ebp]
	push	edx
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	cmp	eax, 3
	jle	SHORT $LN2@plotCityXY

; 121  : 	{
; 122  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN3@plotCityXY

; 123  : 	}
; 124  : 	else

	jmp	SHORT $LN3@plotCityXY
$LN2@plotCityXY:

; 125  : 	{
; 126  : 		return GC.getXYCityPlot((iDX + CITY_PLOTS_RADIUS), (iDY + CITY_PLOTS_RADIUS));

	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, 3
	push	eax
	mov	ecx, DWORD PTR _iDX$[ebp]
	add	ecx, 3
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getXYCityPlot@CvGlobals@@QAEHHH@Z	; CvGlobals::getXYCityPlot
$LN3@plotCityXY:

; 127  : 	}
; 128  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotCityXY@@YAHPBVCvCity@@PBVCvPlot@@@Z ENDP		; plotCityXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T218634 = -16						; size = 4
$T218626 = -12						; size = 4
$T218622 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T218622[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T218626[ebp], ecx
	movzx	edx, BYTE PTR $T218622[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T218626[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T218626[ebp]
	mov	DWORD PTR $T218634[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T218626[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T218626[ebp]
	mov	DWORD PTR $T218634[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T218634[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T218634[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T218655 = -16						; size = 4
$T218647 = -12						; size = 4
$T218643 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T218643[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T218647[ebp], ecx
	movzx	edx, BYTE PTR $T218643[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T218647[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T218647[ebp]
	mov	DWORD PTR $T218655[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T218647[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T218647[ebp]
	mov	DWORD PTR $T218655[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T218655[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T218655[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
tv83 = -36						; size = 4
tv81 = -32						; size = 4
tv78 = -28						; size = 4
tv74 = -24						; size = 4
tv71 = -20						; size = 4
_iAbsDY$216713 = -16					; size = 4
_iAbsDX$216712 = -12					; size = 4
_iAbsDY$216710 = -8					; size = 4
_iAbsDX$216709 = -4					; size = 4
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN5@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN6@hexDistanc
$LN5@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN6@hexDistanc:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216709[ebp], ecx

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN7@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN8@hexDistanc
$LN7@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN8@hexDistanc:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216710[ebp], ecx

; 112  : 		return iAbsDX + iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216709[ebp]
	add	eax, DWORD PTR _iAbsDY$216710[ebp]
	jmp	SHORT $LN3@hexDistanc

; 113  : 	}
; 114  : 	else

	jmp	SHORT $LN3@hexDistanc
$LN2@hexDistanc:

; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN9@hexDistanc
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], edx
	jmp	SHORT $LN10@hexDistanc
$LN9@hexDistanc:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv78[ebp], eax
$LN10@hexDistanc:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216712[ebp], ecx

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN11@hexDistanc
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $LN12@hexDistanc
$LN11@hexDistanc:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv81[ebp], eax
$LN12@hexDistanc:
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216713[ebp], ecx

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216712[ebp]
	cmp	edx, DWORD PTR _iAbsDY$216713[ebp]
	jl	SHORT $LN13@hexDistanc
	mov	eax, DWORD PTR _iAbsDX$216712[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@hexDistanc
$LN13@hexDistanc:
	mov	ecx, DWORD PTR _iAbsDY$216713[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN14@hexDistanc:
	mov	eax, DWORD PTR tv83[ebp]
$LN3@hexDistanc:

; 119  : 	}
; 120  : #endif
; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z	; estimateDirection
EXTRN	__fltused:DWORD
;	COMDAT ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
_DATA	SEGMENT
?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA DQ 03fe0000000000000r ; 0.5 ; `estimateDirection'::`2'::displacements
	DQ	03febb67a0f9096bcr		; 0.866025
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	03fe0000000000000r		; 0.5
	DQ	0bfebb67a0f9096bcr		; -0.866025
	DQ	0bfe0000000000000r		; -0.5
	DQ	0bfebb67a0f9096bcr		; -0.866025
	DQ	0bff0000000000000r		; -1
	DQ	00000000000000000r		; 0
	DQ	0bfe0000000000000r		; -0.5
	DQ	0bfebb67a0f9096bcr		; -0.866025
_DATA	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?estimateDirection@@YA?AW4DirectionTypes@@HH@Z
_TEXT	SEGMENT
_dotProduct$217161 = -32				; size = 8
_i$217157 = -20						; size = 4
_maximum$ = -16						; size = 8
_maximumIndex$ = -8					; size = 4
_displacementSize$ = -4					; size = 4
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?estimateDirection@@YA?AW4DirectionTypes@@HH@Z PROC	; estimateDirection, COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 132  : 	const int displacementSize = 6;

	mov	DWORD PTR _displacementSize$[ebp], 6

; 133  : 	//														NE				E		SE					SW					W			NW
; 134  : 	static double displacements[displacementSize][2] = { {0.5, 0.866025}, {1, 0}, {0.5, -0.866025}, {-0.5, -0.866025}, {-1, 0}, {-0.5, -0.866025}};
; 135  : 	double maximum = 0;

	movsd	xmm0, QWORD PTR __real@0000000000000000
	movsd	QWORD PTR _maximum$[ebp], xmm0

; 136  : 	int maximumIndex = -1;

	mov	DWORD PTR _maximumIndex$[ebp], -1

; 137  : 	for(int i=0; i<displacementSize; i++)

	mov	DWORD PTR _i$217157[ebp], 0
	jmp	SHORT $LN4@estimateDi
$LN3@estimateDi:
	mov	eax, DWORD PTR _i$217157[ebp]
	add	eax, 1
	mov	DWORD PTR _i$217157[ebp], eax
$LN4@estimateDi:
	cmp	DWORD PTR _i$217157[ebp], 6
	jge	SHORT $LN2@estimateDi

; 138  : 	{
; 139  : 		double dotProduct = iDX * displacements[i][0] + iDY * displacements[i][1];

	cvtsi2sd xmm0, DWORD PTR _iDX$[ebp]
	mov	ecx, DWORD PTR _i$217157[ebp]
	shl	ecx, 4
	mulsd	xmm0, QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA[ecx]
	cvtsi2sd xmm1, DWORD PTR _iDY$[ebp]
	mov	edx, DWORD PTR _i$217157[ebp]
	shl	edx, 4
	mulsd	xmm1, QWORD PTR ?displacements@?1??estimateDirection@@YA?AW4DirectionTypes@@HH@Z@4PAY01NA[edx+8]
	addsd	xmm0, xmm1
	movsd	QWORD PTR _dotProduct$217161[ebp], xmm0

; 140  : 		if(dotProduct > maximum)

	movsd	xmm0, QWORD PTR _dotProduct$217161[ebp]
	comisd	xmm0, QWORD PTR _maximum$[ebp]
	jbe	SHORT $LN1@estimateDi

; 141  : 		{
; 142  : 			maximum = dotProduct;

	movsd	xmm0, QWORD PTR _dotProduct$217161[ebp]
	movsd	QWORD PTR _maximum$[ebp], xmm0

; 143  : 			maximumIndex = i;

	mov	eax, DWORD PTR _i$217157[ebp]
	mov	DWORD PTR _maximumIndex$[ebp], eax
$LN1@estimateDi:

; 144  : 		}
; 145  : 	}

	jmp	SHORT $LN3@estimateDi
$LN2@estimateDi:

; 146  : 
; 147  : 	return (DirectionTypes) maximumIndex;

	mov	eax, DWORD PTR _maximumIndex$[ebp]

; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?estimateDirection@@YA?AW4DirectionTypes@@HH@Z ENDP	; estimateDirection
_TEXT	ENDS
PUBLIC	?atWar@@YA_NW4TeamTypes@@0@Z			; atWar
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Odtp
;	COMDAT ?atWar@@YA_NW4TeamTypes@@0@Z
_TEXT	SEGMENT
$T218678 = -4						; size = 4
_eTeamA$ = 8						; size = 4
_eTeamB$ = 12						; size = 4
?atWar@@YA_NW4TeamTypes@@0@Z PROC			; atWar, COMDAT

; 151  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 152  : 	if((eTeamA == NO_TEAM) || (eTeamB == NO_TEAM))

	cmp	DWORD PTR _eTeamA$[ebp], -1
	je	SHORT $LN1@atWar
	cmp	DWORD PTR _eTeamB$[ebp], -1
	jne	SHORT $LN2@atWar
$LN1@atWar:

; 153  : 	{
; 154  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@atWar
$LN2@atWar:

; 155  : 	}
; 156  : 
; 157  : 	CvAssert(GET_TEAM(eTeamA).isAtWar(eTeamB) == GET_TEAM(eTeamB).isAtWar(eTeamA));
; 158  : 	CvAssert((eTeamA != eTeamB) || !(GET_TEAM(eTeamA).isAtWar(eTeamB)));
; 159  : 
; 160  : 	return GET_TEAM(eTeamA).isAtWar(eTeamB);

	mov	eax, DWORD PTR _eTeamA$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T218678[ebp], eax
	mov	ecx, DWORD PTR _eTeamB$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T218678[ebp]
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
$LN3@atWar:

; 161  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?atWar@@YA_NW4TeamTypes@@0@Z ENDP			; atWar
_TEXT	ENDS
PUBLIC	?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z		; isPotentialEnemy
; Function compile flags: /Odtp
;	COMDAT ?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z PROC		; isPotentialEnemy, COMDAT

; 164  : {

	push	ebp
	mov	ebp, esp

; 165  : 	return false;

	xor	al, al

; 166  : }

	pop	ebp
	ret	0
?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z ENDP		; isPotentialEnemy
_TEXT	ENDS
PUBLIC	?getCity@@YAPAVCvCity@@UIDInfo@@@Z		; getCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
;	COMDAT ?getCity@@YAPAVCvCity@@UIDInfo@@@Z
_TEXT	SEGMENT
$T218686 = -4						; size = 4
_city$ = 8						; size = 8
?getCity@@YAPAVCvCity@@UIDInfo@@@Z PROC			; getCity, COMDAT

; 169  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 170  : 	if((city.eOwner >= 0) && city.eOwner < MAX_PLAYERS)

	cmp	DWORD PTR _city$[ebp], 0
	jl	SHORT $LN1@getCity
	cmp	DWORD PTR _city$[ebp], 64		; 00000040H
	jge	SHORT $LN1@getCity

; 171  : 	{
; 172  : 		return (GET_PLAYER((PlayerTypes)city.eOwner).getCity(city.iID));

	mov	eax, DWORD PTR _city$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218686[ebp], eax
	mov	ecx, DWORD PTR _city$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR $T218686[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getCity
$LN1@getCity:

; 173  : 	}
; 174  : 
; 175  : 	return NULL;

	xor	eax, eax
$LN2@getCity:

; 176  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getCity@@YAPAVCvCity@@UIDInfo@@@Z ENDP			; getCity
_TEXT	ENDS
PUBLIC	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z		; getUnit
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
; Function compile flags: /Odtp
;	COMDAT ?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z
_TEXT	SEGMENT
$T218692 = -4						; size = 4
_unit$ = 8						; size = 4
?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z PROC		; getUnit, COMDAT

; 179  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 180  : 	if((unit.eOwner >= 0) && unit.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _unit$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN1@getUnit
	mov	ecx, DWORD PTR _unit$[ebp]
	cmp	DWORD PTR [ecx], 64			; 00000040H
	jge	SHORT $LN1@getUnit

; 181  : 	{
; 182  : 		return (GET_PLAYER((PlayerTypes)unit.eOwner).getUnit(unit.iID));

	mov	edx, DWORD PTR _unit$[ebp]
	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T218692[ebp], eax
	mov	ecx, DWORD PTR _unit$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR $T218692[ebp]
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	jmp	SHORT $LN2@getUnit
$LN1@getUnit:

; 183  : 	}
; 184  : 
; 185  : 	return NULL;

	xor	eax, eax
$LN2@getUnit:

; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z ENDP		; getUnit
_TEXT	ENDS
PUBLIC	?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z		; isBeforeUnitCycle
EXTRN	?getExperience@CvUnit@@QBEHXZ:PROC		; CvUnit::getExperience
EXTRN	?getLevel@CvUnit@@QBEHXZ:PROC			; CvUnit::getLevel
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z:PROC	; CvUnit::GetBaseCombatStrength
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
; Function compile flags: /Odtp
;	COMDAT ?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z
_TEXT	SEGMENT
$T218748 = -24						; size = 4
$T218739 = -20						; size = 4
$T218730 = -16						; size = 4
$T218721 = -12						; size = 4
$T218712 = -8						; size = 4
$T218703 = -4						; size = 4
_pFirstUnit$ = 8					; size = 4
_pSecondUnit$ = 12					; size = 4
?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z PROC		; isBeforeUnitCycle, COMDAT

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 190  : 	CvAssert(pFirstUnit != NULL);
; 191  : 	CvAssert(pSecondUnit != NULL);
; 192  : 	CvAssert(pFirstUnit != pSecondUnit);
; 193  : 
; 194  : 	if(!pFirstUnit || !pSecondUnit)

	cmp	DWORD PTR _pFirstUnit$[ebp], 0
	je	SHORT $LN7@isBeforeUn
	cmp	DWORD PTR _pSecondUnit$[ebp], 0
	jne	SHORT $LN13@isBeforeUn
$LN7@isBeforeUn:

; 195  : 		return false;

	xor	al, al
	jmp	$LN9@isBeforeUn

; 196  : 
; 197  : 	if(pFirstUnit->getOwner() != pSecondUnit->getOwner())

$LN13@isBeforeUn:
	mov	eax, DWORD PTR _pFirstUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T218703[ebp], ecx
	mov	edx, DWORD PTR _pSecondUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T218712[ebp], eax
	mov	ecx, DWORD PTR $T218703[ebp]
	cmp	ecx, DWORD PTR $T218712[ebp]
	je	SHORT $LN6@isBeforeUn

; 198  : 	{
; 199  : 		return (pFirstUnit->getOwner() < pSecondUnit->getOwner());

	mov	edx, DWORD PTR _pFirstUnit$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR $T218721[ebp], eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR $T218730[ebp], edx
	mov	eax, DWORD PTR $T218721[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T218730[ebp]
	setl	cl
	mov	al, cl
	jmp	$LN9@isBeforeUn
$LN6@isBeforeUn:

; 200  : 	}
; 201  : 
; 202  : 	if(pFirstUnit->getDomainType() != pSecondUnit->getDomainType())

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	esi, eax
	je	SHORT $LN5@isBeforeUn

; 203  : 	{
; 204  : 		return (pFirstUnit->getDomainType() < pSecondUnit->getDomainType());

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	xor	edx, edx
	cmp	esi, eax
	setl	dl
	mov	al, dl
	jmp	$LN9@isBeforeUn
$LN5@isBeforeUn:

; 205  : 	}
; 206  : 
; 207  : 	if(pFirstUnit->GetBaseCombatStrength() != pSecondUnit->GetBaseCombatStrength())

	push	0
	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	cmp	esi, eax
	je	SHORT $LN4@isBeforeUn

; 208  : 	{
; 209  : 		return (pFirstUnit->GetBaseCombatStrength() > pSecondUnit->GetBaseCombatStrength());

	push	0
	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	mov	esi, eax
	push	0
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
	xor	ecx, ecx
	cmp	esi, eax
	setg	cl
	mov	al, cl
	jmp	$LN9@isBeforeUn
$LN4@isBeforeUn:

; 210  : 	}
; 211  : 
; 212  : 	if(pFirstUnit->getUnitType() != pSecondUnit->getUnitType())

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	cmp	esi, eax
	je	SHORT $LN3@isBeforeUn

; 213  : 	{
; 214  : 		return (pFirstUnit->getUnitType() > pSecondUnit->getUnitType());

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	xor	edx, edx
	cmp	esi, eax
	setg	dl
	mov	al, dl
	jmp	$LN9@isBeforeUn
$LN3@isBeforeUn:

; 215  : 	}
; 216  : 
; 217  : 	if(pFirstUnit->getLevel() != pSecondUnit->getLevel())

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel
	cmp	esi, eax
	je	SHORT $LN2@isBeforeUn

; 218  : 	{
; 219  : 		return (pFirstUnit->getLevel() > pSecondUnit->getLevel());

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getLevel@CvUnit@@QBEHXZ		; CvUnit::getLevel
	xor	ecx, ecx
	cmp	esi, eax
	setg	cl
	mov	al, cl
	jmp	SHORT $LN9@isBeforeUn
$LN2@isBeforeUn:

; 220  : 	}
; 221  : 
; 222  : 	if(pFirstUnit->getExperience() != pSecondUnit->getExperience())

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	cmp	esi, eax
	je	SHORT $LN29@isBeforeUn

; 223  : 	{
; 224  : 		return (pFirstUnit->getExperience() > pSecondUnit->getExperience());

	mov	ecx, DWORD PTR _pFirstUnit$[ebp]
	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	mov	esi, eax
	mov	ecx, DWORD PTR _pSecondUnit$[ebp]
	call	?getExperience@CvUnit@@QBEHXZ		; CvUnit::getExperience
	xor	edx, edx
	cmp	esi, eax
	setg	dl
	mov	al, dl
	jmp	SHORT $LN9@isBeforeUn

; 225  : 	}
; 226  : 
; 227  : 	return (pFirstUnit->GetID() < pSecondUnit->GetID());

$LN29@isBeforeUn:
	mov	eax, DWORD PTR _pFirstUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T218739[ebp], ecx
	mov	edx, DWORD PTR _pSecondUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR $T218748[ebp], eax
	mov	ecx, DWORD PTR $T218739[ebp]
	xor	eax, eax
	cmp	ecx, DWORD PTR $T218748[ebp]
	setl	al
$LN9@isBeforeUn:

; 228  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?isBeforeUnitCycle@@YA_NPBVCvUnit@@0@Z ENDP		; isBeforeUnitCycle
_TEXT	ENDS
PUBLIC	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForUnitCombatType
EXTRN	?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z:PROC ; CvPromotionEntry::GetUnitCombatClass
EXTRN	?GetUnitCombatType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetUnitCombatType
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
; Function compile flags: /Odtp
;	COMDAT ?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
_promotionInfo$ = -8					; size = 4
_unitInfo$ = -4						; size = 4
_ePromotion$ = 8					; size = 4
_eUnit$ = 12						; size = 4
?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z PROC ; IsPromotionValidForUnitCombatType, COMDAT

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 233  : 	CvUnitEntry* unitInfo = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _unitInfo$[ebp], eax

; 234  : 	CvPromotionEntry* promotionInfo = GC.getPromotionInfo(ePromotion);

	mov	ecx, DWORD PTR _ePromotion$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	DWORD PTR _promotionInfo$[ebp], eax

; 235  : 
; 236  : 	if(unitInfo == NULL || promotionInfo == NULL)

	cmp	DWORD PTR _unitInfo$[ebp], 0
	je	SHORT $LN3@IsPromotio
	cmp	DWORD PTR _promotionInfo$[ebp], 0
	jne	SHORT $LN4@IsPromotio
$LN3@IsPromotio:

; 237  : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsPromotio
$LN4@IsPromotio:

; 238  : 
; 239  : 	// No combat class (civilians)
; 240  : 	if(unitInfo->GetUnitCombatType() == NO_UNITCOMBAT)

	mov	ecx, DWORD PTR _unitInfo$[ebp]
	call	?GetUnitCombatType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitCombatType
	cmp	eax, -1
	jne	SHORT $LN2@IsPromotio

; 241  : 	{
; 242  : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsPromotio
$LN2@IsPromotio:

; 243  : 	}
; 244  : 
; 245  : 	// Combat class not valid for this Promotion
; 246  : 	if(!(promotionInfo->GetUnitCombatClass(unitInfo->GetUnitCombatType())))

	mov	ecx, DWORD PTR _unitInfo$[ebp]
	call	?GetUnitCombatType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitCombatType
	push	eax
	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetUnitCombatClass@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetUnitCombatClass
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@IsPromotio

; 247  : 	{
; 248  : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsPromotio
$LN1@IsPromotio:

; 249  : 	}
; 250  : 
; 251  : 	return true;

	mov	al, 1
$LN5@IsPromotio:

; 252  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ENDP ; IsPromotionValidForUnitCombatType
_TEXT	ENDS
PUBLIC	?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForCivilianUnitType
EXTRN	?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z:PROC ; CvPromotionEntry::GetCivilianUnitType
; Function compile flags: /Odtp
;	COMDAT ?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
_promotionInfo$ = -4					; size = 4
_ePromotion$ = 8					; size = 4
_eUnit$ = 12						; size = 4
?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z PROC ; IsPromotionValidForCivilianUnitType, COMDAT

; 256  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 257  : 	CvPromotionEntry* promotionInfo = GC.getPromotionInfo(ePromotion);

	mov	eax, DWORD PTR _ePromotion$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	DWORD PTR _promotionInfo$[ebp], eax

; 258  : 
; 259  : 	if(promotionInfo == NULL)

	cmp	DWORD PTR _promotionInfo$[ebp], 0
	jne	SHORT $LN2@IsPromotio@2

; 260  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsPromotio@2
$LN2@IsPromotio@2:

; 261  : 
; 262  : 	if(!(promotionInfo->GetCivilianUnitType((int)eUnit)))

	mov	ecx, DWORD PTR _eUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetCivilianUnitType@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetCivilianUnitType
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@IsPromotio@2

; 263  : 	{
; 264  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@IsPromotio@2
$LN1@IsPromotio@2:

; 265  : 	}
; 266  : 
; 267  : 	return true;

	mov	al, 1
$LN3@IsPromotio@2:

; 268  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPromotionValidForCivilianUnitType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ENDP ; IsPromotionValidForCivilianUnitType
_TEXT	ENDS
PUBLIC	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
EXTRN	?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion9
EXTRN	?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion8
EXTRN	?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion7
EXTRN	?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion6
EXTRN	?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion5
EXTRN	?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion4
EXTRN	?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion3
EXTRN	?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion2
EXTRN	?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqOrPromotion1
EXTRN	?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ:PROC ; CvPromotionEntry::GetPrereqPromotion
EXTRN	?IsBlitz@CvPromotionEntry@@QBE_NXZ:PROC		; CvPromotionEntry::IsBlitz
EXTRN	?GetMoves@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetMoves
EXTRN	?IsLeader@CvPromotionEntry@@QBE_NXZ:PROC	; CvPromotionEntry::IsLeader
EXTRN	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetFreePromotions
EXTRN	?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ:PROC ; CvPromotionEntry::IsCannotBeChosen
; Function compile flags: /Odtp
;	COMDAT ?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z
_TEXT	SEGMENT
_bValid$217254 = -45					; size = 1
_ePrereq3$ = -44					; size = 4
_ePrereq7$ = -40					; size = 4
_ePrereq4$ = -36					; size = 4
_ePrereq8$ = -32					; size = 4
_promotionInfo$ = -28					; size = 4
_ePrereq1$ = -24					; size = 4
_ePrereq5$ = -20					; size = 4
_ePrereq9$ = -16					; size = 4
_unitInfo$ = -12					; size = 4
_ePrereq2$ = -8						; size = 4
_ePrereq6$ = -4						; size = 4
_ePromotion$ = 8					; size = 4
_eUnit$ = 12						; size = 4
_bLeader$ = 16						; size = 1
_bTestingPrereq$ = 20					; size = 1
?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z PROC ; isPromotionValid, COMDAT

; 271  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 272  : 	CvUnitEntry* unitInfo = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _unitInfo$[ebp], eax

; 273  : 	CvPromotionEntry* promotionInfo = GC.getPromotionInfo(ePromotion);

	mov	ecx, DWORD PTR _ePromotion$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	DWORD PTR _promotionInfo$[ebp], eax

; 274  : 
; 275  : 	if(unitInfo == NULL || promotionInfo == NULL)

	cmp	DWORD PTR _unitInfo$[ebp], 0
	je	SHORT $LN31@isPromotio
	cmp	DWORD PTR _promotionInfo$[ebp], 0
	jne	SHORT $LN32@isPromotio
$LN31@isPromotio:

; 276  : 		return false;

	xor	al, al
	jmp	$LN33@isPromotio
$LN32@isPromotio:

; 277  : 
; 278  : 	// Can this Promotion not be chosen through normal leveling?
; 279  : 	if(!bTestingPrereq && promotionInfo->IsCannotBeChosen())

	movzx	edx, BYTE PTR _bTestingPrereq$[ebp]
	test	edx, edx
	jne	SHORT $LN30@isPromotio
	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?IsCannotBeChosen@CvPromotionEntry@@QBE_NXZ ; CvPromotionEntry::IsCannotBeChosen
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN30@isPromotio

; 280  : 	{
; 281  : 		return false;

	xor	al, al
	jmp	$LN33@isPromotio
$LN30@isPromotio:

; 282  : 	}
; 283  : 
; 284  : 	// If a Unit gets a Promotion for free then hand it out, no questions asked
; 285  : 	if(unitInfo->GetFreePromotions(ePromotion))

	mov	ecx, DWORD PTR _ePromotion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _unitInfo$[ebp]
	call	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z ; CvUnitEntry::GetFreePromotions
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN29@isPromotio

; 286  : 	{
; 287  : 		return true;

	mov	al, 1
	jmp	$LN33@isPromotio
$LN29@isPromotio:

; 288  : 	}
; 289  : 
; 290  : 	// If this isn't a combat Unit, no Promotion
; 291  : 	if(unitInfo->GetUnitCombatType() == NO_UNITCOMBAT)

	mov	ecx, DWORD PTR _unitInfo$[ebp]
	call	?GetUnitCombatType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetUnitCombatType
	cmp	eax, -1
	jne	SHORT $LN28@isPromotio

; 292  : 	{
; 293  : 		return false;

	xor	al, al
	jmp	$LN33@isPromotio
$LN28@isPromotio:

; 294  : 	}
; 295  : 
; 296  : 	// Is this a valid Promotion for the UnitCombatType?
; 297  : 	if(!::IsPromotionValidForUnitCombatType(ePromotion, eUnit))

	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePromotion$[ebp]
	push	ecx
	call	?IsPromotionValidForUnitCombatType@@YA_NW4PromotionTypes@@W4UnitTypes@@@Z ; IsPromotionValidForUnitCombatType
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN27@isPromotio

; 298  : 	{
; 299  : 		return false;

	xor	al, al
	jmp	$LN33@isPromotio
$LN27@isPromotio:

; 300  : 	}
; 301  : 
; 302  : 	if(!bLeader && promotionInfo->IsLeader())

	movzx	eax, BYTE PTR _bLeader$[ebp]
	test	eax, eax
	jne	SHORT $LN26@isPromotio
	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?IsLeader@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsLeader
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN26@isPromotio

; 303  : 	{
; 304  : 		return false;

	xor	al, al
	jmp	$LN33@isPromotio
$LN26@isPromotio:

; 305  : 	}
; 306  : 
; 307  : 	// If the Unit only has one move then Blitz is not useful
; 308  : 	if(unitInfo->GetMoves() == 1)

	mov	ecx, DWORD PTR _unitInfo$[ebp]
	call	?GetMoves@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetMoves
	cmp	eax, 1
	jne	SHORT $LN25@isPromotio

; 309  : 	{
; 310  : 		if(promotionInfo->IsBlitz())

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?IsBlitz@CvPromotionEntry@@QBE_NXZ	; CvPromotionEntry::IsBlitz
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN25@isPromotio

; 311  : 		{
; 312  : 			return false;

	xor	al, al
	jmp	$LN33@isPromotio
$LN25@isPromotio:

; 313  : 		}
; 314  : 	}
; 315  : 
; 316  : 	// Promotion Prereqs
; 317  : 	if(NO_PROMOTION != promotionInfo->GetPrereqPromotion())

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqPromotion
	cmp	eax, -1
	je	SHORT $LN23@isPromotio

; 318  : 	{
; 319  : 		if(!isPromotionValid((PromotionTypes)promotionInfo->GetPrereqPromotion(), eUnit, bLeader, true))

	push	1
	movzx	eax, BYTE PTR _bLeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqPromotion@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqPromotion
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN23@isPromotio

; 320  : 		{
; 321  : 			return false;

	xor	al, al
	jmp	$LN33@isPromotio
$LN23@isPromotio:

; 322  : 		}
; 323  : 	}
; 324  : 
; 325  : 	PromotionTypes ePrereq1 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion1();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion1@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion1
	mov	DWORD PTR _ePrereq1$[ebp], eax

; 326  : 	PromotionTypes ePrereq2 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion2();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion2@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion2
	mov	DWORD PTR _ePrereq2$[ebp], eax

; 327  : 	PromotionTypes ePrereq3 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion3();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion3@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion3
	mov	DWORD PTR _ePrereq3$[ebp], eax

; 328  : 	PromotionTypes ePrereq4 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion4();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion4@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion4
	mov	DWORD PTR _ePrereq4$[ebp], eax

; 329  : 	PromotionTypes ePrereq5 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion5();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion5@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion5
	mov	DWORD PTR _ePrereq5$[ebp], eax

; 330  : 	PromotionTypes ePrereq6 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion6();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion6@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion6
	mov	DWORD PTR _ePrereq6$[ebp], eax

; 331  : 	PromotionTypes ePrereq7 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion7();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion7@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion7
	mov	DWORD PTR _ePrereq7$[ebp], eax

; 332  : 	PromotionTypes ePrereq8 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion8();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion8@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion8
	mov	DWORD PTR _ePrereq8$[ebp], eax

; 333  : 	PromotionTypes ePrereq9 = (PromotionTypes)promotionInfo->GetPrereqOrPromotion9();

	mov	ecx, DWORD PTR _promotionInfo$[ebp]
	call	?GetPrereqOrPromotion9@CvPromotionEntry@@QBEHXZ ; CvPromotionEntry::GetPrereqOrPromotion9
	mov	DWORD PTR _ePrereq9$[ebp], eax

; 334  : #ifdef AUI_WARNING_FIXES
; 335  : 	if ((ePrereq1 != NO_PROMOTION || ePrereq2 != NO_PROMOTION || ePrereq3 != NO_PROMOTION || ePrereq4 != NO_PROMOTION ||
; 336  : 			ePrereq5 != NO_PROMOTION || ePrereq6 != NO_PROMOTION || ePrereq7 != NO_PROMOTION || ePrereq8 != NO_PROMOTION || ePrereq9 != NO_PROMOTION) &&
; 337  : 		(NO_PROMOTION == ePrereq1 || !isPromotionValid(ePrereq1, eUnit, bLeader, true)) &&
; 338  : 		(NO_PROMOTION == ePrereq2 || !isPromotionValid(ePrereq2, eUnit, bLeader, true)) &&
; 339  : 		(NO_PROMOTION == ePrereq3 || !isPromotionValid(ePrereq3, eUnit, bLeader, true)) &&
; 340  : 		(NO_PROMOTION == ePrereq4 || !isPromotionValid(ePrereq4, eUnit, bLeader, true)) &&
; 341  : 		(NO_PROMOTION == ePrereq5 || !isPromotionValid(ePrereq5, eUnit, bLeader, true)) &&
; 342  : 		(NO_PROMOTION == ePrereq6 || !isPromotionValid(ePrereq6, eUnit, bLeader, true)) &&
; 343  : 		(NO_PROMOTION == ePrereq7 || !isPromotionValid(ePrereq7, eUnit, bLeader, true)) &&
; 344  : 		(NO_PROMOTION == ePrereq8 || !isPromotionValid(ePrereq8, eUnit, bLeader, true)) &&
; 345  : 		(NO_PROMOTION == ePrereq9 || !isPromotionValid(ePrereq9, eUnit, bLeader, true)))
; 346  : 	{
; 347  : 		return false;
; 348  : #else
; 349  : 	if(ePrereq1 != NO_PROMOTION ||
; 350  : 		ePrereq2 != NO_PROMOTION ||
; 351  : 		ePrereq3 != NO_PROMOTION ||
; 352  : 		ePrereq4 != NO_PROMOTION ||
; 353  : 		ePrereq5 != NO_PROMOTION ||
; 354  : 		ePrereq6 != NO_PROMOTION ||
; 355  : 		ePrereq7 != NO_PROMOTION ||
; 356  : 		ePrereq8 != NO_PROMOTION ||
; 357  : 		ePrereq9 != NO_PROMOTION)

	cmp	DWORD PTR _ePrereq1$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq2$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq3$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq4$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq5$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq6$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq7$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq8$[ebp], -1
	jne	SHORT $LN20@isPromotio
	cmp	DWORD PTR _ePrereq9$[ebp], -1
	je	$LN21@isPromotio
$LN20@isPromotio:

; 358  : 	{
; 359  : 		bool bValid = false;

	mov	BYTE PTR _bValid$217254[ebp], 0

; 360  : 		if(!bValid)

	movzx	eax, BYTE PTR _bValid$217254[ebp]
	test	eax, eax
	jne	SHORT $LN19@isPromotio

; 361  : 		{
; 362  : 			if(NO_PROMOTION != ePrereq1 && isPromotionValid(ePrereq1, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq1$[ebp], -1
	je	SHORT $LN19@isPromotio
	push	1
	movzx	ecx, BYTE PTR _bLeader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePrereq1$[ebp]
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@isPromotio

; 363  : 			{
; 364  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN19@isPromotio:

; 365  : 			}
; 366  : 		}
; 367  : 
; 368  : 		if(!bValid)

	movzx	edx, BYTE PTR _bValid$217254[ebp]
	test	edx, edx
	jne	SHORT $LN17@isPromotio

; 369  : 		{
; 370  : 			if(NO_PROMOTION != ePrereq2 && isPromotionValid(ePrereq2, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq2$[ebp], -1
	je	SHORT $LN17@isPromotio
	push	1
	movzx	eax, BYTE PTR _bLeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePrereq2$[ebp]
	push	edx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN17@isPromotio

; 371  : 			{
; 372  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN17@isPromotio:

; 373  : 			}
; 374  : 		}
; 375  : 
; 376  : 		if(!bValid)

	movzx	ecx, BYTE PTR _bValid$217254[ebp]
	test	ecx, ecx
	jne	SHORT $LN15@isPromotio

; 377  : 		{
; 378  : 			if(NO_PROMOTION != ePrereq3 && isPromotionValid(ePrereq3, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq3$[ebp], -1
	je	SHORT $LN15@isPromotio
	push	1
	movzx	edx, BYTE PTR _bLeader$[ebp]
	push	edx
	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePrereq3$[ebp]
	push	ecx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@isPromotio

; 379  : 			{
; 380  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN15@isPromotio:

; 381  : 			}
; 382  : 		}
; 383  : 
; 384  : 		if(!bValid)

	movzx	eax, BYTE PTR _bValid$217254[ebp]
	test	eax, eax
	jne	SHORT $LN13@isPromotio

; 385  : 		{
; 386  : 			if(NO_PROMOTION != ePrereq4 && isPromotionValid(ePrereq4, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq4$[ebp], -1
	je	SHORT $LN13@isPromotio
	push	1
	movzx	ecx, BYTE PTR _bLeader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePrereq4$[ebp]
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@isPromotio

; 387  : 			{
; 388  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN13@isPromotio:

; 389  : 			}
; 390  : 		}
; 391  : 
; 392  : 		if(!bValid)

	movzx	edx, BYTE PTR _bValid$217254[ebp]
	test	edx, edx
	jne	SHORT $LN11@isPromotio

; 393  : 		{
; 394  : 			if(NO_PROMOTION != ePrereq5 && isPromotionValid(ePrereq5, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq5$[ebp], -1
	je	SHORT $LN11@isPromotio
	push	1
	movzx	eax, BYTE PTR _bLeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePrereq5$[ebp]
	push	edx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@isPromotio

; 395  : 			{
; 396  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN11@isPromotio:

; 397  : 			}
; 398  : 		}
; 399  : 
; 400  : 		if(!bValid)

	movzx	ecx, BYTE PTR _bValid$217254[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@isPromotio

; 401  : 		{
; 402  : 			if(NO_PROMOTION != ePrereq6 && isPromotionValid(ePrereq6, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq6$[ebp], -1
	je	SHORT $LN9@isPromotio
	push	1
	movzx	edx, BYTE PTR _bLeader$[ebp]
	push	edx
	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePrereq6$[ebp]
	push	ecx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@isPromotio

; 403  : 			{
; 404  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN9@isPromotio:

; 405  : 			}
; 406  : 		}
; 407  : 
; 408  : 		if(!bValid)

	movzx	eax, BYTE PTR _bValid$217254[ebp]
	test	eax, eax
	jne	SHORT $LN7@isPromotio

; 409  : 		{
; 410  : 			if(NO_PROMOTION != ePrereq7 && isPromotionValid(ePrereq7, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq7$[ebp], -1
	je	SHORT $LN7@isPromotio
	push	1
	movzx	ecx, BYTE PTR _bLeader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _ePrereq7$[ebp]
	push	eax
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN7@isPromotio

; 411  : 			{
; 412  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN7@isPromotio:

; 413  : 			}
; 414  : 		}
; 415  : 
; 416  : 		if(!bValid)

	movzx	edx, BYTE PTR _bValid$217254[ebp]
	test	edx, edx
	jne	SHORT $LN5@isPromotio

; 417  : 		{
; 418  : 			if(NO_PROMOTION != ePrereq8 && isPromotionValid(ePrereq8, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq8$[ebp], -1
	je	SHORT $LN5@isPromotio
	push	1
	movzx	eax, BYTE PTR _bLeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePrereq8$[ebp]
	push	edx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@isPromotio

; 419  : 			{
; 420  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN5@isPromotio:

; 421  : 			}
; 422  : 		}
; 423  : 
; 424  : 		if(!bValid)

	movzx	ecx, BYTE PTR _bValid$217254[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@isPromotio

; 425  : 		{
; 426  : 			if(NO_PROMOTION != ePrereq9 && isPromotionValid(ePrereq9, eUnit, bLeader, true))

	cmp	DWORD PTR _ePrereq9$[ebp], -1
	je	SHORT $LN3@isPromotio
	push	1
	movzx	edx, BYTE PTR _bLeader$[ebp]
	push	edx
	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ePrereq9$[ebp]
	push	ecx
	call	?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ; isPromotionValid
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@isPromotio

; 427  : 			{
; 428  : 				bValid = true;

	mov	BYTE PTR _bValid$217254[ebp], 1
$LN3@isPromotio:

; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 		if(!bValid)

	movzx	eax, BYTE PTR _bValid$217254[ebp]
	test	eax, eax
	jne	SHORT $LN21@isPromotio

; 433  : 		{
; 434  : 			return false;

	xor	al, al
	jmp	SHORT $LN33@isPromotio
$LN21@isPromotio:

; 435  : 		}
; 436  : #endif
; 437  : 	}
; 438  : 
; 439  : 	return true;

	mov	al, 1
$LN33@isPromotio:

; 440  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isPromotionValid@@YA_NW4PromotionTypes@@W4UnitTypes@@_N2@Z ENDP ; isPromotionValid
_TEXT	ENDS
PUBLIC	?getPopulationAsset@@YAHH@Z			; getPopulationAsset
; Function compile flags: /Odtp
;	COMDAT ?getPopulationAsset@@YAHH@Z
_TEXT	SEGMENT
_iPopulation$ = 8					; size = 4
?getPopulationAsset@@YAHH@Z PROC			; getPopulationAsset, COMDAT

; 443  : {

	push	ebp
	mov	ebp, esp

; 444  : 	return (iPopulation * 2);

	mov	eax, DWORD PTR _iPopulation$[ebp]
	shl	eax, 1

; 445  : }

	pop	ebp
	ret	0
?getPopulationAsset@@YAHH@Z ENDP			; getPopulationAsset
_TEXT	ENDS
PUBLIC	?getLandPlotsAsset@@YAHH@Z			; getLandPlotsAsset
; Function compile flags: /Odtp
;	COMDAT ?getLandPlotsAsset@@YAHH@Z
_TEXT	SEGMENT
_iLandPlots$ = 8					; size = 4
?getLandPlotsAsset@@YAHH@Z PROC				; getLandPlotsAsset, COMDAT

; 448  : {

	push	ebp
	mov	ebp, esp

; 449  : 	return iLandPlots;

	mov	eax, DWORD PTR _iLandPlots$[ebp]

; 450  : }

	pop	ebp
	ret	0
?getLandPlotsAsset@@YAHH@Z ENDP				; getLandPlotsAsset
_TEXT	ENDS
PUBLIC	?getPopulationPower@@YAHH@Z			; getPopulationPower
; Function compile flags: /Odtp
;	COMDAT ?getPopulationPower@@YAHH@Z
_TEXT	SEGMENT
_iPopulation$ = 8					; size = 4
?getPopulationPower@@YAHH@Z PROC			; getPopulationPower, COMDAT

; 453  : {

	push	ebp
	mov	ebp, esp

; 454  : 	return (iPopulation / 2);

	mov	eax, DWORD PTR _iPopulation$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1

; 455  : }

	pop	ebp
	ret	0
?getPopulationPower@@YAHH@Z ENDP			; getPopulationPower
_TEXT	ENDS
PUBLIC	?getPopulationScore@@YAHH@Z			; getPopulationScore
; Function compile flags: /Odtp
;	COMDAT ?getPopulationScore@@YAHH@Z
_TEXT	SEGMENT
_iPopulation$ = 8					; size = 4
?getPopulationScore@@YAHH@Z PROC			; getPopulationScore, COMDAT

; 458  : {

	push	ebp
	mov	ebp, esp

; 459  : 	return iPopulation;

	mov	eax, DWORD PTR _iPopulation$[ebp]

; 460  : }

	pop	ebp
	ret	0
?getPopulationScore@@YAHH@Z ENDP			; getPopulationScore
_TEXT	ENDS
PUBLIC	?getLandPlotsScore@@YAHH@Z			; getLandPlotsScore
; Function compile flags: /Odtp
;	COMDAT ?getLandPlotsScore@@YAHH@Z
_TEXT	SEGMENT
_iLandPlots$ = 8					; size = 4
?getLandPlotsScore@@YAHH@Z PROC				; getLandPlotsScore, COMDAT

; 463  : {

	push	ebp
	mov	ebp, esp

; 464  : 	return iLandPlots;

	mov	eax, DWORD PTR _iLandPlots$[ebp]

; 465  : }

	pop	ebp
	ret	0
?getLandPlotsScore@@YAHH@Z ENDP				; getLandPlotsScore
_TEXT	ENDS
PUBLIC	?getTechScore@@YAHW4TechTypes@@@Z		; getTechScore
EXTRN	?GetEra@CvTechEntry@@QBEHXZ:PROC		; CvTechEntry::GetEra
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
; Function compile flags: /Odtp
;	COMDAT ?getTechScore@@YAHW4TechTypes@@@Z
_TEXT	SEGMENT
_pkTechInfo$ = -4					; size = 4
_eTech$ = 8						; size = 4
?getTechScore@@YAHW4TechTypes@@@Z PROC			; getTechScore, COMDAT

; 468  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 469  : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 470  : 	if(pkTechInfo == NULL)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	jne	SHORT $LN2@getTechSco

; 471  : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN3@getTechSco

; 472  : 	else

	jmp	SHORT $LN3@getTechSco
$LN2@getTechSco:

; 473  : 		return pkTechInfo->GetEra() + 1;

	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetEra@CvTechEntry@@QBEHXZ		; CvTechEntry::GetEra
	add	eax, 1
$LN3@getTechSco:

; 474  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTechScore@@YAHW4TechTypes@@@Z ENDP			; getTechScore
_TEXT	ENDS
PUBLIC	?getWonderScore@@YAHW4BuildingClassTypes@@@Z	; getWonderScore
EXTRN	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z:PROC ; isLimitedWonderClass
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
; Function compile flags: /Odtp
;	COMDAT ?getWonderScore@@YAHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_pkBuildingClassInfo$ = -4				; size = 4
_eWonderClass$ = 8					; size = 4
?getWonderScore@@YAHW4BuildingClassTypes@@@Z PROC	; getWonderScore, COMDAT

; 477  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 478  : 	CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eWonderClass);

	mov	eax, DWORD PTR _eWonderClass$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$[ebp], eax

; 479  : 	if(pkBuildingClassInfo)

	cmp	DWORD PTR _pkBuildingClassInfo$[ebp], 0
	je	SHORT $LN2@getWonderS

; 480  : 	{
; 481  : 		if(isLimitedWonderClass(*pkBuildingClassInfo))

	mov	ecx, DWORD PTR _pkBuildingClassInfo$[ebp]
	push	ecx
	call	?isLimitedWonderClass@@YA_NABVCvBuildingClassInfo@@@Z ; isLimitedWonderClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@getWonderS

; 482  : 			return 5;

	mov	eax, 5
	jmp	SHORT $LN3@getWonderS
$LN2@getWonderS:

; 483  : 	}
; 484  : 
; 485  : 	return 0;

	xor	eax, eax
$LN3@getWonderS:

; 486  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getWonderScore@@YAHW4BuildingClassTypes@@@Z ENDP	; getWonderScore
_TEXT	ENDS
PUBLIC	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ; finalImprovementUpgrade
EXTRN	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetImprovementUpgrade
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
; Function compile flags: /Odtp
;	COMDAT ?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z
_TEXT	SEGMENT
_eImprovement$ = 8					; size = 4
_iCount$ = 12						; size = 4
?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z PROC ; finalImprovementUpgrade, COMDAT

; 493  : {

	push	ebp
	mov	ebp, esp

; 494  : 	CvAssertMsg(eImprovement != NO_IMPROVEMENT, "Improvement is not assigned a valid value");
; 495  : 
; 496  : 	if(iCount > GC.getNumImprovementInfos())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	DWORD PTR _iCount$[ebp], eax
	jle	SHORT $LN3@finalImpro

; 497  : 	{
; 498  : 		return NO_IMPROVEMENT;

	or	eax, -1
	jmp	SHORT $LN4@finalImpro
$LN3@finalImpro:

; 499  : 	}
; 500  : 
; 501  : 	if(GC.getImprovementInfo(eImprovement)->GetImprovementUpgrade() != NO_IMPROVEMENT)

	mov	eax, DWORD PTR _eImprovement$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	cmp	eax, -1
	je	SHORT $LN2@finalImpro

; 502  : 	{
; 503  : 		return finalImprovementUpgrade(((ImprovementTypes)(GC.getImprovementInfo(eImprovement)->GetImprovementUpgrade())), (iCount + 1));

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetImprovementUpgrade@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetImprovementUpgrade
	push	eax
	call	?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ; finalImprovementUpgrade
	add	esp, 8
	jmp	SHORT $LN4@finalImpro

; 504  : 	}
; 505  : 	else

	jmp	SHORT $LN4@finalImpro
$LN2@finalImpro:

; 506  : 	{
; 507  : 		return eImprovement;

	mov	eax, DWORD PTR _eImprovement$[ebp]
$LN4@finalImpro:

; 508  : 	}
; 509  : }

	pop	ebp
	ret	0
?finalImprovementUpgrade@@YA?AW4ImprovementTypes@@W41@H@Z ENDP ; finalImprovementUpgrade
_TEXT	ENDS
PUBLIC	?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z ; isTechRequiredForUnit
EXTRN	?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetPrereqAndTechs
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
; Function compile flags: /Odtp
;	COMDAT ?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z
_TEXT	SEGMENT
$T218776 = -12						; size = 4
_iI$217316 = -8						; size = 4
_info$ = -4						; size = 4
_eTech$ = 8						; size = 4
_eUnit$ = 12						; size = 4
?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z PROC ; isTechRequiredForUnit, COMDAT

; 512  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 513  : 	CvUnitEntry* info = GC.getUnitInfo(eUnit);

	mov	eax, DWORD PTR _eUnit$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _info$[ebp], eax

; 514  : 	if(info == NULL)

	cmp	DWORD PTR _info$[ebp], 0
	jne	SHORT $LN6@isTechRequ

; 515  : 	{
; 516  : 		return false;

	xor	al, al
	jmp	SHORT $LN7@isTechRequ
$LN6@isTechRequ:

; 517  : 	}
; 518  : 
; 519  : 	if(info->GetPrereqAndTech() == eTech)

	mov	ecx, DWORD PTR _info$[ebp]
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN5@isTechRequ

; 520  : 	{
; 521  : 		return true;

	mov	al, 1
	jmp	SHORT $LN7@isTechRequ
$LN5@isTechRequ:

; 522  : 	}
; 523  : 
; 524  : 	for(int iI = 0; iI < GC.getNUM_UNIT_AND_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$217316[ebp], 0
	jmp	SHORT $LN4@isTechRequ
$LN3@isTechRequ:
	mov	ecx, DWORD PTR _iI$217316[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$217316[ebp], ecx
$LN4@isTechRequ:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6276
	mov	DWORD PTR $T218776[ebp], edx
	mov	eax, DWORD PTR _iI$217316[ebp]
	cmp	eax, DWORD PTR $T218776[ebp]
	jge	SHORT $LN2@isTechRequ

; 525  : 	{
; 526  : 		if(info->GetPrereqAndTechs(iI) == eTech)

	mov	ecx, DWORD PTR _iI$217316[ebp]
	push	ecx
	mov	ecx, DWORD PTR _info$[ebp]
	call	?GetPrereqAndTechs@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetPrereqAndTechs
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN1@isTechRequ

; 527  : 		{
; 528  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@isTechRequ
$LN1@isTechRequ:

; 529  : 		}
; 530  : 	}

	jmp	SHORT $LN3@isTechRequ
$LN2@isTechRequ:

; 531  : 
; 532  : 	return false;

	xor	al, al
$LN7@isTechRequ:

; 533  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isTechRequiredForUnit@@YA_NW4TechTypes@@W4UnitTypes@@@Z ENDP ; isTechRequiredForUnit
_TEXT	ENDS
PUBLIC	?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z ; isTechRequiredForBuilding
EXTRN	?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z:PROC ; CvBuildingEntry::GetPrereqAndTechs
EXTRN	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetPrereqAndTech
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
; Function compile flags: /Odtp
;	COMDAT ?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z
_TEXT	SEGMENT
$T218782 = -12						; size = 4
_iI$217328 = -8						; size = 4
_info$ = -4						; size = 4
_eTech$ = 8						; size = 4
_eBuilding$ = 12					; size = 4
?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z PROC ; isTechRequiredForBuilding, COMDAT

; 536  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 537  : 	CvBuildingEntry* info = GC.getBuildingInfo(eBuilding);

	mov	eax, DWORD PTR _eBuilding$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _info$[ebp], eax

; 538  : 	if(info)

	cmp	DWORD PTR _info$[ebp], 0
	je	SHORT $LN6@isTechRequ@2

; 539  : 	{
; 540  : 		if(info->GetPrereqAndTech() == eTech)

	mov	ecx, DWORD PTR _info$[ebp]
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN5@isTechRequ@2

; 541  : 		{
; 542  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@isTechRequ@2
$LN5@isTechRequ@2:

; 543  : 		}
; 544  : 
; 545  : 		for(int iI = 0; iI < GC.getNUM_BUILDING_AND_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$217328[ebp], 0
	jmp	SHORT $LN4@isTechRequ@2
$LN3@isTechRequ@2:
	mov	ecx, DWORD PTR _iI$217328[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$217328[ebp], ecx
$LN4@isTechRequ@2:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6280
	mov	DWORD PTR $T218782[ebp], edx
	mov	eax, DWORD PTR _iI$217328[ebp]
	cmp	eax, DWORD PTR $T218782[ebp]
	jge	SHORT $LN6@isTechRequ@2

; 546  : 		{
; 547  : 			if(info->GetPrereqAndTechs(iI) == eTech)

	mov	ecx, DWORD PTR _iI$217328[ebp]
	push	ecx
	mov	ecx, DWORD PTR _info$[ebp]
	call	?GetPrereqAndTechs@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetPrereqAndTechs
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN1@isTechRequ@2

; 548  : 			{
; 549  : 				return true;

	mov	al, 1
	jmp	SHORT $LN7@isTechRequ@2
$LN1@isTechRequ@2:

; 550  : 			}
; 551  : 		}

	jmp	SHORT $LN3@isTechRequ@2
$LN6@isTechRequ@2:

; 552  : 	}
; 553  : 
; 554  : 	return false;

	xor	al, al
$LN7@isTechRequ@2:

; 555  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isTechRequiredForBuilding@@YA_NW4TechTypes@@W4BuildingTypes@@@Z ENDP ; isTechRequiredForBuilding
_TEXT	ENDS
PUBLIC	?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z ; isTechRequiredForProject
EXTRN	?GetTechPrereq@CvProjectEntry@@QBEHXZ:PROC	; CvProjectEntry::GetTechPrereq
EXTRN	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z:PROC ; CvGlobals::getProjectInfo
; Function compile flags: /Odtp
;	COMDAT ?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z
_TEXT	SEGMENT
_pkProjectInfo$ = -4					; size = 4
_eTech$ = 8						; size = 4
_eProject$ = 12						; size = 4
?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z PROC ; isTechRequiredForProject, COMDAT

; 558  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 559  : 	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	mov	eax, DWORD PTR _eProject$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	DWORD PTR _pkProjectInfo$[ebp], eax

; 560  : 	if(pkProjectInfo)

	cmp	DWORD PTR _pkProjectInfo$[ebp], 0
	je	SHORT $LN2@isTechRequ@3

; 561  : 	{
; 562  : 		if(pkProjectInfo->GetTechPrereq() == eTech)

	mov	ecx, DWORD PTR _pkProjectInfo$[ebp]
	call	?GetTechPrereq@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetTechPrereq
	cmp	eax, DWORD PTR _eTech$[ebp]
	jne	SHORT $LN2@isTechRequ@3

; 563  : 		{
; 564  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@isTechRequ@3
$LN2@isTechRequ@3:

; 565  : 		}
; 566  : 	}
; 567  : 
; 568  : 	return false;

	xor	al, al
$LN3@isTechRequ@3:

; 569  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isTechRequiredForProject@@YA_NW4TechTypes@@W4ProjectTypes@@@Z ENDP ; isTechRequiredForProject
_TEXT	ENDS
PUBLIC	?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z	; isWorldUnitClass
EXTRN	?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxGlobalInstances
EXTRN	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z:PROC ; CvGlobals::getUnitClassInfo
; Function compile flags: /Odtp
;	COMDAT ?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_pkUnitClassInfo$ = -4					; size = 4
_eUnitClass$ = 8					; size = 4
?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z PROC	; isWorldUnitClass, COMDAT

; 572  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 573  : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$[ebp], eax

; 574  : 	if(pkUnitClassInfo)

	cmp	DWORD PTR _pkUnitClassInfo$[ebp], 0
	je	SHORT $LN1@isWorldUni

; 575  : 	{
; 576  : 		return (pkUnitClassInfo->getMaxGlobalInstances() != -1);

	mov	ecx, DWORD PTR _pkUnitClassInfo$[ebp]
	call	?getMaxGlobalInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxGlobalInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl
	jmp	SHORT $LN2@isWorldUni
$LN1@isWorldUni:

; 577  : 	}
; 578  : 	return false;

	xor	al, al
$LN2@isWorldUni:

; 579  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP	; isWorldUnitClass
_TEXT	ENDS
PUBLIC	?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z	; isTeamUnitClass
EXTRN	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxTeamInstances
; Function compile flags: /Odtp
;	COMDAT ?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_pkUnitClassInfo$ = -4					; size = 4
_eUnitClass$ = 8					; size = 4
?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z PROC		; isTeamUnitClass, COMDAT

; 582  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 583  : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$[ebp], eax

; 584  : 	if(pkUnitClassInfo)

	cmp	DWORD PTR _pkUnitClassInfo$[ebp], 0
	je	SHORT $LN1@isTeamUnit

; 585  : 	{
; 586  : 		return (pkUnitClassInfo->getMaxTeamInstances() != -1);

	mov	ecx, DWORD PTR _pkUnitClassInfo$[ebp]
	call	?getMaxTeamInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxTeamInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl
	jmp	SHORT $LN2@isTeamUnit
$LN1@isTeamUnit:

; 587  : 	}
; 588  : 	return false;

	xor	al, al
$LN2@isTeamUnit:

; 589  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP		; isTeamUnitClass
_TEXT	ENDS
PUBLIC	?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z	; isNationalUnitClass
EXTRN	?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ:PROC ; CvUnitClassInfo::getMaxPlayerInstances
; Function compile flags: /Odtp
;	COMDAT ?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_pkUnitClassInfo$ = -4					; size = 4
_eUnitClass$ = 8					; size = 4
?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z PROC	; isNationalUnitClass, COMDAT

; 592  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 593  : 	CvUnitClassInfo* pkUnitClassInfo = GC.getUnitClassInfo(eUnitClass);

	mov	eax, DWORD PTR _eUnitClass$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitClassInfo@CvGlobals@@QAEPAVCvUnitClassInfo@@W4UnitClassTypes@@@Z ; CvGlobals::getUnitClassInfo
	mov	DWORD PTR _pkUnitClassInfo$[ebp], eax

; 594  : 	if(pkUnitClassInfo)

	cmp	DWORD PTR _pkUnitClassInfo$[ebp], 0
	je	SHORT $LN1@isNational

; 595  : 	{
; 596  : 		return (pkUnitClassInfo->getMaxPlayerInstances() != -1);

	mov	ecx, DWORD PTR _pkUnitClassInfo$[ebp]
	call	?getMaxPlayerInstances@CvUnitClassInfo@@QBEHXZ ; CvUnitClassInfo::getMaxPlayerInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl
	jmp	SHORT $LN2@isNational
$LN1@isNational:

; 597  : 	}
; 598  : 	return false;

	xor	al, al
$LN2@isNational:

; 599  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP	; isNationalUnitClass
_TEXT	ENDS
PUBLIC	?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z	; isLimitedUnitClass
; Function compile flags: /Odtp
;	COMDAT ?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z
_TEXT	SEGMENT
tv76 = -4						; size = 4
_eUnitClass$ = 8					; size = 4
?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z PROC	; isLimitedUnitClass, COMDAT

; 602  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 603  : 	return (isWorldUnitClass(eUnitClass) || isTeamUnitClass(eUnitClass) || isNationalUnitClass(eUnitClass));

	mov	eax, DWORD PTR _eUnitClass$[ebp]
	push	eax
	call	?isWorldUnitClass@@YA_NW4UnitClassTypes@@@Z ; isWorldUnitClass
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isLimitedU
	mov	edx, DWORD PTR _eUnitClass$[ebp]
	push	edx
	call	?isTeamUnitClass@@YA_NW4UnitClassTypes@@@Z ; isTeamUnitClass
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@isLimitedU
	mov	ecx, DWORD PTR _eUnitClass$[ebp]
	push	ecx
	call	?isNationalUnitClass@@YA_NW4UnitClassTypes@@@Z ; isNationalUnitClass
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@isLimitedU
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@isLimitedU
$LN3@isLimitedU:
	mov	DWORD PTR tv76[ebp], 1
$LN4@isLimitedU:
	mov	al, BYTE PTR tv76[ebp]

; 604  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isLimitedUnitClass@@YA_NW4UnitClassTypes@@@Z ENDP	; isLimitedUnitClass
_TEXT	ENDS
PUBLIC	?isWorldProject@@YA_NW4ProjectTypes@@@Z		; isWorldProject
EXTRN	?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetMaxGlobalInstances
; Function compile flags: /Odtp
;	COMDAT ?isWorldProject@@YA_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
_pkProjectInfo$ = -4					; size = 4
_eProject$ = 8						; size = 4
?isWorldProject@@YA_NW4ProjectTypes@@@Z PROC		; isWorldProject, COMDAT

; 607  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 608  : 	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	mov	eax, DWORD PTR _eProject$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	DWORD PTR _pkProjectInfo$[ebp], eax

; 609  : 	if(pkProjectInfo)

	cmp	DWORD PTR _pkProjectInfo$[ebp], 0
	je	SHORT $LN1@isWorldPro

; 610  : 	{
; 611  : 		return (pkProjectInfo->GetMaxGlobalInstances() != -1);

	mov	ecx, DWORD PTR _pkProjectInfo$[ebp]
	call	?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxGlobalInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl
	jmp	SHORT $LN2@isWorldPro
$LN1@isWorldPro:

; 612  : 	}
; 613  : 	return false;

	xor	al, al
$LN2@isWorldPro:

; 614  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isWorldProject@@YA_NW4ProjectTypes@@@Z ENDP		; isWorldProject
_TEXT	ENDS
PUBLIC	?isTeamProject@@YA_NW4ProjectTypes@@@Z		; isTeamProject
EXTRN	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ:PROC ; CvProjectEntry::GetMaxTeamInstances
; Function compile flags: /Odtp
;	COMDAT ?isTeamProject@@YA_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
_pkProjectInfo$ = -4					; size = 4
_eProject$ = 8						; size = 4
?isTeamProject@@YA_NW4ProjectTypes@@@Z PROC		; isTeamProject, COMDAT

; 617  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 618  : 	CvProjectEntry* pkProjectInfo = GC.getProjectInfo(eProject);

	mov	eax, DWORD PTR _eProject$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getProjectInfo@CvGlobals@@QAEPAVCvProjectEntry@@W4ProjectTypes@@@Z ; CvGlobals::getProjectInfo
	mov	DWORD PTR _pkProjectInfo$[ebp], eax

; 619  : 	if(pkProjectInfo)

	cmp	DWORD PTR _pkProjectInfo$[ebp], 0
	je	SHORT $LN1@isTeamProj

; 620  : 	{
; 621  : 		return (pkProjectInfo->GetMaxTeamInstances() != -1);

	mov	ecx, DWORD PTR _pkProjectInfo$[ebp]
	call	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetMaxTeamInstances
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl
	jmp	SHORT $LN2@isTeamProj
$LN1@isTeamProj:

; 622  : 	}
; 623  : 	return false;

	xor	al, al
$LN2@isTeamProj:

; 624  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isTeamProject@@YA_NW4ProjectTypes@@@Z ENDP		; isTeamProject
_TEXT	ENDS
PUBLIC	?isLimitedProject@@YA_NW4ProjectTypes@@@Z	; isLimitedProject
; Function compile flags: /Odtp
;	COMDAT ?isLimitedProject@@YA_NW4ProjectTypes@@@Z
_TEXT	SEGMENT
tv72 = -4						; size = 4
_eProject$ = 8						; size = 4
?isLimitedProject@@YA_NW4ProjectTypes@@@Z PROC		; isLimitedProject, COMDAT

; 627  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 628  : 	return (isWorldProject(eProject) || isTeamProject(eProject));

	mov	eax, DWORD PTR _eProject$[ebp]
	push	eax
	call	?isWorldProject@@YA_NW4ProjectTypes@@@Z	; isWorldProject
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isLimitedP
	mov	edx, DWORD PTR _eProject$[ebp]
	push	edx
	call	?isTeamProject@@YA_NW4ProjectTypes@@@Z	; isTeamProject
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@isLimitedP
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isLimitedP
$LN3@isLimitedP:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isLimitedP:
	mov	al, BYTE PTR tv72[ebp]

; 629  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isLimitedProject@@YA_NW4ProjectTypes@@@Z ENDP		; isLimitedProject
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z		; OnSameBodyOfWater
; Function compile flags: /Odtp
;	COMDAT ?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z
_TEXT	SEGMENT
$T219201 = -200						; size = 4
$T219197 = -196						; size = 4
$T219010 = -112						; size = 4
$T219001 = -108						; size = 4
$T218822 = -24						; size = 4
$T218813 = -20						; size = 4
_pAdjacentPlot2$217386 = -16				; size = 4
_jJ$217382 = -12					; size = 4
_pAdjacentPlot1$217379 = -8				; size = 4
_iI$217375 = -4						; size = 4
_pCity1$ = 8						; size = 4
_pCity2$ = 12						; size = 4
?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z PROC		; OnSameBodyOfWater, COMDAT

; 632  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H

; 633  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	DWORD PTR _iI$217375[ebp], 0
	jmp	SHORT $LN9@OnSameBody
$LN8@OnSameBody:
	mov	eax, DWORD PTR _iI$217375[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$217375[ebp], eax
$LN9@OnSameBody:
	cmp	DWORD PTR _iI$217375[ebp], 6
	jge	$LN7@OnSameBody

; 634  : 	{
; 635  : 		CvPlot* pAdjacentPlot1 = plotDirection(pCity1->getX(), pCity1->getY(), ((DirectionTypes)iI));

	mov	ecx, DWORD PTR _pCity1$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T218813[ebp], edx
	mov	eax, DWORD PTR _pCity1$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T218822[ebp], ecx
	mov	edx, DWORD PTR _iI$217375[ebp]
	push	edx
	mov	eax, DWORD PTR $T218813[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218822[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot1$217379[ebp], eax

; 636  : 
; 637  : 		if(pAdjacentPlot1 != NULL && pAdjacentPlot1->isWater())

	cmp	DWORD PTR _pAdjacentPlot1$217379[ebp], 0
	je	$LN6@OnSameBody
	mov	edx, DWORD PTR _pAdjacentPlot1$217379[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN6@OnSameBody

; 638  : 		{
; 639  : 			for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	mov	DWORD PTR _jJ$217382[ebp], 0
	jmp	SHORT $LN5@OnSameBody
$LN4@OnSameBody:
	mov	eax, DWORD PTR _jJ$217382[ebp]
	add	eax, 1
	mov	DWORD PTR _jJ$217382[ebp], eax
$LN5@OnSameBody:
	cmp	DWORD PTR _jJ$217382[ebp], 6
	jge	SHORT $LN6@OnSameBody

; 640  : 			{
; 641  : 				CvPlot* pAdjacentPlot2 = plotDirection(pCity2->getX(), pCity2->getY(), ((DirectionTypes)jJ));

	mov	ecx, DWORD PTR _pCity2$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T219001[ebp], edx
	mov	eax, DWORD PTR _pCity2$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T219010[ebp], ecx
	mov	edx, DWORD PTR _jJ$217382[ebp]
	push	edx
	mov	eax, DWORD PTR $T219001[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219010[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot2$217386[ebp], eax

; 642  : 				if(pAdjacentPlot2 != NULL && pAdjacentPlot2->isWater())

	cmp	DWORD PTR _pAdjacentPlot2$217386[ebp], 0
	je	SHORT $LN2@OnSameBody
	mov	edx, DWORD PTR _pAdjacentPlot2$217386[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@OnSameBody

; 643  : 				{
; 644  : 					if(pAdjacentPlot2->getArea() == pAdjacentPlot1->getArea())

	mov	eax, DWORD PTR _pAdjacentPlot2$217386[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T219197[ebp], ecx
	mov	edx, DWORD PTR _pAdjacentPlot1$217379[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T219201[ebp], eax
	mov	ecx, DWORD PTR $T219197[ebp]
	cmp	ecx, DWORD PTR $T219201[ebp]
	jne	SHORT $LN2@OnSameBody

; 645  : 					{
; 646  : 						return true;

	mov	al, 1
	jmp	SHORT $LN10@OnSameBody
$LN2@OnSameBody:

; 647  : 					}
; 648  : 				}
; 649  : 			}

	jmp	$LN4@OnSameBody
$LN6@OnSameBody:

; 650  : 		}
; 651  : 	}

	jmp	$LN8@OnSameBody
$LN7@OnSameBody:

; 652  : 	return false;

	xor	al, al
$LN10@OnSameBody:

; 653  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OnSameBodyOfWater@@YA_NPAVCvCity@@0@Z ENDP		; OnSameBodyOfWater
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T219408 = -80						; size = 4
$T219363 = -76						; size = 4
$T219350 = -72						; size = 4
$T219346 = -68						; size = 4
$T219332 = -64						; size = 4
$T219328 = -57						; size = 1
$T219317 = -56						; size = 4
$T219313 = -49						; size = 1
_iMapY$219407 = -48					; size = 4
_iMapX$219406 = -44					; size = 4
$T219306 = -40						; size = 4
$T219282 = -36						; size = 4
$T219245 = -32						; size = 4
$T219233 = -28						; size = 4
$T219229 = -21						; size = 1
$T219218 = -20						; size = 4
$T219214 = -13						; size = 1
_iMapY$219281 = -12					; size = 4
_iMapX$219280 = -8					; size = 4
$T219207 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219207[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T219282[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T219207[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T219214[ebp], dl
	mov	eax, DWORD PTR $T219207[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219218[ebp], ecx
	movzx	edx, BYTE PTR $T219214[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219218[ebp]
	add	edx, DWORD PTR $T219218[ebp]
	mov	DWORD PTR _iMapX$219280[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T219218[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219218[ebp]
	mov	DWORD PTR _iMapX$219280[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$219280[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T219207[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T219229[ebp], al
	mov	ecx, DWORD PTR $T219207[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T219233[ebp], edx
	movzx	eax, BYTE PTR $T219229[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219233[ebp]
	add	edx, DWORD PTR $T219233[ebp]
	mov	DWORD PTR _iMapY$219281[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T219233[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219233[ebp]
	mov	DWORD PTR _iMapY$219281[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$219281[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$219281[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$219280[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219207[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T219207[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T219245[ebp], eax
	mov	ecx, DWORD PTR _iMapY$219281[ebp]
	imul	ecx, DWORD PTR $T219245[ebp]
	add	ecx, DWORD PTR _iMapX$219280[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T219207[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T219282[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T219282[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T219306[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T219408[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T219306[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T219313[ebp], dl
	mov	eax, DWORD PTR $T219306[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219317[ebp], ecx
	movzx	edx, BYTE PTR $T219313[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219317[ebp]
	add	edx, DWORD PTR $T219317[ebp]
	mov	DWORD PTR _iMapX$219406[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T219317[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T219317[ebp]
	mov	DWORD PTR _iMapX$219406[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$219406[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T219306[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T219328[ebp], al
	mov	ecx, DWORD PTR $T219306[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T219332[ebp], edx
	movzx	eax, BYTE PTR $T219328[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219332[ebp]
	add	edx, DWORD PTR $T219332[ebp]
	mov	DWORD PTR _iMapY$219407[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T219332[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T219332[ebp]
	mov	DWORD PTR _iMapY$219407[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$219407[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$219406[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T219306[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219346[ebp], ecx
	mov	edx, DWORD PTR _iMapX$219406[ebp]
	cmp	edx, DWORD PTR $T219346[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$219407[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T219306[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T219350[ebp], ecx
	mov	edx, DWORD PTR _iMapY$219407[ebp]
	cmp	edx, DWORD PTR $T219350[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T219306[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T219363[ebp], ecx
	mov	edx, DWORD PTR _iMapY$219407[ebp]
	imul	edx, DWORD PTR $T219363[ebp]
	add	edx, DWORD PTR _iMapX$219406[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T219306[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T219408[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T219408[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z ; getDiscoveryTech
EXTRN	?GetFlavorValue@CvUnitEntry@@QBEHH@Z:PROC	; CvUnitEntry::GetFlavorValue
EXTRN	?GetFlavorValue@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetFlavorValue
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
;	COMDAT ?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
$T219417 = -40						; size = 4
_iJ$217409 = -36					; size = 4
_iValue$217408 = -32					; size = 4
_eTech$217403 = -28					; size = 4
_pkTechInfo$217405 = -24				; size = 4
_iI$217399 = -20					; size = 4
_iBestValue$217398 = -16				; size = 4
_eBestTech$ = -12					; size = 4
_pkUnitInfo$ = -8					; size = 4
_kPlayer$ = -4						; size = 4
_eUnit$ = 8						; size = 4
_ePlayer$ = 12						; size = 4
?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z PROC ; getDiscoveryTech, COMDAT

; 656  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 657  : 	TechTypes eBestTech = NO_TECH;

	mov	DWORD PTR _eBestTech$[ebp], -1

; 658  : 	CvPlayerAI& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR _ePlayer$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$[ebp], eax

; 659  : 
; 660  : 	CvUnitEntry* pkUnitInfo = GC.getUnitInfo(eUnit);

	mov	ecx, DWORD PTR _eUnit$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitInfo$[ebp], eax

; 661  : 	if(pkUnitInfo)

	cmp	DWORD PTR _pkUnitInfo$[ebp], 0
	je	$LN10@getDiscove

; 662  : 	{
; 663  : 		int iBestValue = 0;

	mov	DWORD PTR _iBestValue$217398[ebp], 0

; 664  : #ifdef AUI_WARNING_FIXES
; 665  : 		for (uint iI = 0; iI < GC.getNumTechInfos(); iI++)
; 666  : #else
; 667  : 		for(int iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	DWORD PTR _iI$217399[ebp], 0
	jmp	SHORT $LN9@getDiscove
$LN8@getDiscove:
	mov	edx, DWORD PTR _iI$217399[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$217399[ebp], edx
$LN9@getDiscove:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	DWORD PTR _iI$217399[ebp], eax
	jge	$LN10@getDiscove

; 668  : #endif
; 669  : 		{
; 670  : 			const TechTypes eTech = static_cast<TechTypes>(iI);

	mov	eax, DWORD PTR _iI$217399[ebp]
	mov	DWORD PTR _eTech$217403[ebp], eax

; 671  : 			CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	ecx, DWORD PTR _eTech$217403[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pkTechInfo$217405[ebp], eax

; 672  : 			if(pkTechInfo)

	cmp	DWORD PTR _pkTechInfo$217405[ebp], 0
	je	SHORT $LN6@getDiscove

; 673  : 			{
; 674  : 				if(kPlayer.GetPlayerTechs()->CanResearch(eTech))

	push	0
	mov	edx, DWORD PTR _eTech$217403[ebp]
	push	edx
	mov	ecx, DWORD PTR _kPlayer$[ebp]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@getDiscove

; 675  : 				{
; 676  : 					int iValue = 0;

	mov	DWORD PTR _iValue$217408[ebp], 0

; 677  : 
; 678  : 					for(int iJ = 0; iJ < GC.getNumFlavorTypes(); iJ++)

	mov	DWORD PTR _iJ$217409[ebp], 0
	jmp	SHORT $LN4@getDiscove
$LN3@getDiscove:
	mov	ecx, DWORD PTR _iJ$217409[ebp]
	add	ecx, 1
	mov	DWORD PTR _iJ$217409[ebp], ecx
$LN4@getDiscove:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T219417[ebp], edx
	mov	eax, DWORD PTR _iJ$217409[ebp]
	cmp	eax, DWORD PTR $T219417[ebp]
	jge	SHORT $LN2@getDiscove

; 679  : 					{
; 680  : 						iValue += (pkTechInfo->GetFlavorValue(iJ) * pkUnitInfo->GetFlavorValue(iJ));

	mov	ecx, DWORD PTR _iJ$217409[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkTechInfo$217405[ebp]
	call	?GetFlavorValue@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetFlavorValue
	mov	esi, eax
	mov	edx, DWORD PTR _iJ$217409[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkUnitInfo$[ebp]
	call	?GetFlavorValue@CvUnitEntry@@QBEHH@Z	; CvUnitEntry::GetFlavorValue
	imul	esi, eax
	add	esi, DWORD PTR _iValue$217408[ebp]
	mov	DWORD PTR _iValue$217408[ebp], esi

; 681  : 					}

	jmp	SHORT $LN3@getDiscove
$LN2@getDiscove:

; 682  : 
; 683  : 					if(iValue > iBestValue)

	mov	eax, DWORD PTR _iValue$217408[ebp]
	cmp	eax, DWORD PTR _iBestValue$217398[ebp]
	jle	SHORT $LN6@getDiscove

; 684  : 					{
; 685  : 						iBestValue = iValue;

	mov	ecx, DWORD PTR _iValue$217408[ebp]
	mov	DWORD PTR _iBestValue$217398[ebp], ecx

; 686  : 						eBestTech = eTech;

	mov	edx, DWORD PTR _eTech$217403[ebp]
	mov	DWORD PTR _eBestTech$[ebp], edx
$LN6@getDiscove:

; 687  : 					}
; 688  : 				}
; 689  : 			}
; 690  : 		}

	jmp	$LN8@getDiscove
$LN10@getDiscove:

; 691  : 	}
; 692  : 
; 693  : 	return eBestTech;

	mov	eax, DWORD PTR _eBestTech$[ebp]

; 694  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getDiscoveryTech@@YA?AW4TechTypes@@W4UnitTypes@@W4PlayerTypes@@@Z ENDP ; getDiscoveryTech
_TEXT	ENDS
PUBLIC	?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z		; PUF_isPlayer
; Function compile flags: /Odtp
;	COMDAT ?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
$T219428 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_isPlayer, COMDAT

; 698  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 699  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 700  : 	return (pUnit->getOwner() == iData1);

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T219428[ebp], ecx
	mov	edx, DWORD PTR $T219428[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _iData1$[ebp]
	sete	al

; 701  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isPlayer@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_isPlayer
_TEXT	ENDS
PUBLIC	?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z		; PUF_isTeam
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
; Function compile flags: /Odtp
;	COMDAT ?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_isTeam, COMDAT

; 704  : {

	push	ebp
	mov	ebp, esp

; 705  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 706  : 	return (pUnit->getTeam() == iData1);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[ebp]
	sete	cl
	mov	al, cl

; 707  : }

	pop	ebp
	ret	0
?PUF_isTeam@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_isTeam
_TEXT	ENDS
PUBLIC	?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z		; PUF_isCombatTeam
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z:PROC ; CvUnit::getCombatOwner
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
; Function compile flags: /Odtp
;	COMDAT ?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
tv86 = -12						; size = 4
$T219439 = -8						; size = 4
$T219438 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isCombatTeam, COMDAT

; 710  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 711  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 712  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 713  : 
; 714  : 	return (GET_PLAYER(pUnit->getCombatOwner((TeamTypes)iData2, *(pUnit->plot()))).getTeam() == iData1 && !pUnit->isInvisible((TeamTypes)iData2, false, false));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	eax, DWORD PTR _iData2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	mov	DWORD PTR $T219438[ebp], eax
	mov	ecx, DWORD PTR $T219438[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219439[ebp], ecx
	mov	edx, DWORD PTR $T219439[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _iData1$[ebp]
	jne	SHORT $LN3@PUF_isComb
	push	0
	push	0
	mov	ecx, DWORD PTR _iData2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@PUF_isComb
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN4@PUF_isComb
$LN3@PUF_isComb:
	mov	DWORD PTR tv86[ebp], 0
$LN4@PUF_isComb:
	mov	al, BYTE PTR tv86[ebp]

; 715  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isCombatTeam@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isCombatTeam
_TEXT	ENDS
PUBLIC	?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z		; PUF_isOtherPlayer
; Function compile flags: /Odtp
;	COMDAT ?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
$T219458 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isOtherPlayer, COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 719  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 720  : 	return (pUnit->getOwner() != iData1);

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR $T219458[ebp], ecx
	mov	edx, DWORD PTR $T219458[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _iData1$[ebp]
	setne	al

; 721  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isOtherPlayer@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isOtherPlayer
_TEXT	ENDS
PUBLIC	?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z		; PUF_isOtherTeam
EXTRN	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z:PROC ; CvUnit::canCoexistWithEnemyUnit
; Function compile flags: /Odtp
;	COMDAT ?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
$T219464 = -8						; size = 4
_eTeam$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isOtherTeam, COMDAT

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 725  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 726  : 	TeamTypes eTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219464[ebp], eax
	mov	ecx, DWORD PTR $T219464[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eTeam$[ebp], eax

; 727  : 	if(pUnit->canCoexistWithEnemyUnit(eTeam))

	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@PUF_isOthe

; 728  : 	{
; 729  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@PUF_isOthe
$LN1@PUF_isOthe:

; 730  : 	}
; 731  : 
; 732  : 	return (pUnit->getTeam() != eTeam);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	xor	edx, edx
	cmp	eax, DWORD PTR _eTeam$[ebp]
	setne	dl
	mov	al, dl
$LN2@PUF_isOthe:

; 733  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isOtherTeam@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isOtherTeam
_TEXT	ENDS
PUBLIC	?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z		; PUF_isEnemy
; Function compile flags: /Odtp
;	COMDAT ?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
tv130 = -24						; size = 4
$T219493 = -20						; size = 4
$T219492 = -16						; size = 4
$T219480 = -12						; size = 4
_eOurTeam$ = -8						; size = 4
_eOtherTeam$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_isEnemy, COMDAT

; 736  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 737  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 738  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 739  : 
; 740  : 	TeamTypes eOtherTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219480[ebp], eax
	mov	ecx, DWORD PTR $T219480[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOtherTeam$[ebp], eax

; 741  : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	mov	DWORD PTR $T219492[ebp], eax
	mov	ecx, DWORD PTR $T219492[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219493[ebp], ecx
	mov	edx, DWORD PTR $T219493[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOurTeam$[ebp], eax

; 742  : 
; 743  : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	mov	ecx, DWORD PTR _eOtherTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@PUF_isEnem

; 744  : 	{
; 745  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@PUF_isEnem
$LN1@PUF_isEnem:

; 746  : 	}
; 747  : 
; 748  : 	return (iData2 ? eOtherTeam != eOurTeam : atWar(eOtherTeam, eOurTeam));

	cmp	DWORD PTR _iData2$[ebp], 0
	je	SHORT $LN4@PUF_isEnem
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _eOurTeam$[ebp]
	setne	cl
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN5@PUF_isEnem
$LN4@PUF_isEnem:
	mov	edx, DWORD PTR _eOurTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	ecx, al
	mov	DWORD PTR tv130[ebp], ecx
$LN5@PUF_isEnem:
	mov	al, BYTE PTR tv130[ebp]
$LN2@PUF_isEnem:

; 749  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_isEnemy
_TEXT	ENDS
PUBLIC	?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z		; PUF_isVisible
; Function compile flags: /Odtp
;	COMDAT ?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
$T219516 = -8						; size = 4
$T219507 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isVisible, COMDAT

; 752  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 753  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 754  : 	return !(pUnit->isInvisible(GET_PLAYER((PlayerTypes)iData1).getTeam(), false));

	mov	eax, DWORD PTR _iData1$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219507[ebp], eax
	mov	ecx, DWORD PTR $T219507[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T219516[ebp], eax
	push	1
	push	0
	mov	eax, DWORD PTR $T219516[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 755  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isVisible@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isVisible
_TEXT	ENDS
PUBLIC	?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z	; PUF_isVisibleDebug
; Function compile flags: /Odtp
;	COMDAT ?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
$T219531 = -8						; size = 4
$T219522 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isVisibleDebug, COMDAT

; 758  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 759  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 760  : 	return !(pUnit->isInvisible(GET_PLAYER((PlayerTypes)iData1).getTeam(), true));

	mov	eax, DWORD PTR _iData1$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219522[ebp], eax
	mov	ecx, DWORD PTR $T219522[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T219531[ebp], eax
	push	1
	push	1
	mov	eax, DWORD PTR $T219531[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 761  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isVisibleDebug@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isVisibleDebug
_TEXT	ENDS
PUBLIC	?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z		; PUF_canSiege
EXTRN	?canSiege@CvUnit@@QBE_NW4TeamTypes@@@Z:PROC	; CvUnit::canSiege
; Function compile flags: /Odtp
;	COMDAT ?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
$T219546 = -8						; size = 4
$T219537 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z PROC			; PUF_canSiege, COMDAT

; 764  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 765  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 766  : 	return pUnit->canSiege(GET_PLAYER((PlayerTypes)iData1).getTeam());

	mov	eax, DWORD PTR _iData1$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219537[ebp], eax
	mov	ecx, DWORD PTR $T219537[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T219546[ebp], eax
	mov	eax, DWORD PTR $T219546[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canSiege@CvUnit@@QBE_NW4TeamTypes@@@Z	; CvUnit::canSiege

; 767  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_canSiege@@YA_NPBVCvUnit@@HH@Z ENDP			; PUF_canSiege
_TEXT	ENDS
PUBLIC	?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z	; PUF_isPotentialEnemy
; Function compile flags: /Odtp
;	COMDAT ?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
tv130 = -24						; size = 4
$T219567 = -20						; size = 4
$T219566 = -16						; size = 4
$T219554 = -12						; size = 4
_eOurTeam$ = -8						; size = 4
_eOtherTeam$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isPotentialEnemy, COMDAT

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 771  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 772  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 773  : 
; 774  : 	TeamTypes eOtherTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219554[ebp], eax
	mov	ecx, DWORD PTR $T219554[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOtherTeam$[ebp], eax

; 775  : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	mov	DWORD PTR $T219566[ebp], eax
	mov	ecx, DWORD PTR $T219566[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219567[ebp], ecx
	mov	edx, DWORD PTR $T219567[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOurTeam$[ebp], eax

; 776  : 
; 777  : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	mov	ecx, DWORD PTR _eOtherTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@PUF_isPote

; 778  : 	{
; 779  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@PUF_isPote
$LN1@PUF_isPote:

; 780  : 	}
; 781  : 	return (iData2 ? eOtherTeam != eOurTeam : isPotentialEnemy(eOtherTeam, eOurTeam));

	cmp	DWORD PTR _iData2$[ebp], 0
	je	SHORT $LN4@PUF_isPote
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _eOurTeam$[ebp]
	setne	cl
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN5@PUF_isPote
$LN4@PUF_isPote:
	mov	edx, DWORD PTR _eOurTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	push	eax
	call	?isPotentialEnemy@@YA_NW4TeamTypes@@0@Z	; isPotentialEnemy
	add	esp, 8
	movzx	ecx, al
	mov	DWORD PTR tv130[ebp], ecx
$LN5@PUF_isPote:
	mov	al, BYTE PTR tv130[ebp]
$LN2@PUF_isPote:

; 782  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isPotentialEnemy
_TEXT	ENDS
PUBLIC	?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z		; PUF_canDeclareWar
EXTRN	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::canDeclareWar
; Function compile flags: /Odtp
;	COMDAT ?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
tv129 = -25						; size = 1
$T219608 = -24						; size = 4
$T219596 = -20						; size = 4
$T219595 = -16						; size = 4
$T219583 = -12						; size = 4
_eOurTeam$ = -8						; size = 4
_eOtherTeam$ = -4					; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_canDeclareWar, COMDAT

; 785  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 786  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 787  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 788  : 
; 789  : 	TeamTypes eOtherTeam = GET_PLAYER((PlayerTypes)iData1).getTeam();

	mov	eax, DWORD PTR _iData1$[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219583[ebp], eax
	mov	ecx, DWORD PTR $T219583[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOtherTeam$[ebp], eax

; 790  : 	TeamTypes eOurTeam = GET_PLAYER(pUnit->getCombatOwner(eOtherTeam, *(pUnit->plot()))).getTeam();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getCombatOwner@CvUnit@@QBE?AW4PlayerTypes@@W4TeamTypes@@ABVCvPlot@@@Z ; CvUnit::getCombatOwner
	mov	DWORD PTR $T219595[ebp], eax
	mov	ecx, DWORD PTR $T219595[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T219596[ebp], ecx
	mov	edx, DWORD PTR $T219596[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _eOurTeam$[ebp], eax

; 791  : 
; 792  : 	if(pUnit->canCoexistWithEnemyUnit(eOtherTeam))

	mov	ecx, DWORD PTR _eOtherTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?canCoexistWithEnemyUnit@CvUnit@@QBE_NW4TeamTypes@@@Z ; CvUnit::canCoexistWithEnemyUnit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@PUF_canDec

; 793  : 	{
; 794  : 		return false;

	xor	al, al
	jmp	SHORT $LN2@PUF_canDec
$LN1@PUF_canDec:

; 795  : 	}
; 796  : 
; 797  : 	return (iData2 ? false : GET_TEAM(eOtherTeam).canDeclareWar(eOurTeam));

	cmp	DWORD PTR _iData2$[ebp], 0
	je	SHORT $LN4@PUF_canDec
	mov	BYTE PTR tv129[ebp], 0
	jmp	SHORT $LN5@PUF_canDec
$LN4@PUF_canDec:
	mov	eax, DWORD PTR _eOtherTeam$[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T219608[ebp], eax
	mov	ecx, DWORD PTR _eOurTeam$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T219608[ebp]
	call	?canDeclareWar@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::canDeclareWar
	mov	BYTE PTR tv129[ebp], al
$LN5@PUF_canDec:
	mov	al, BYTE PTR tv129[ebp]
$LN2@PUF_canDec:

; 798  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_canDeclareWar@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_canDeclareWar
_TEXT	ENDS
PUBLIC	?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z		; PUF_canDefend
EXTRN	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::IsCanDefend
; Function compile flags: /Odtp
;	COMDAT ?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_canDefend, COMDAT

; 801  : {

	push	ebp
	mov	ebp, esp

; 802  : 	return pUnit->IsCanDefend();

	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend

; 803  : }

	pop	ebp
	ret	0
?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_canDefend
_TEXT	ENDS
PUBLIC	?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z		; PUF_cannotDefend
; Function compile flags: /Odtp
;	COMDAT ?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_cannotDefend, COMDAT

; 806  : {

	push	ebp
	mov	ebp, esp

; 807  : 	return !(pUnit->IsCanDefend());

	push	0
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsCanDefend@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::IsCanDefend
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 808  : }

	pop	ebp
	ret	0
?PUF_cannotDefend@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_cannotDefend
_TEXT	ENDS
PUBLIC	?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z	; PUF_canDefendEnemy
; Function compile flags: /Odtp
;	COMDAT ?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
tv76 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_canDefendEnemy, COMDAT

; 811  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 812  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 813  : 	CvAssertMsg(iData2 != -1, "Invalid data argument, should be >= 0");
; 814  : 	return (PUF_canDefend(pUnit, iData1, iData2) && PUF_isEnemy(pUnit, iData1, iData2));

	mov	eax, DWORD PTR _iData2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	call	?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z	; PUF_canDefend
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@PUF_canDef
	mov	ecx, DWORD PTR _iData2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?PUF_isEnemy@@YA_NPBVCvUnit@@HH@Z	; PUF_isEnemy
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@PUF_canDef
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@PUF_canDef
$LN3@PUF_canDef:
	mov	DWORD PTR tv76[ebp], 0
$LN4@PUF_canDef:
	mov	al, BYTE PTR tv76[ebp]

; 815  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_canDefendEnemy@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_canDefendEnemy
_TEXT	ENDS
PUBLIC	?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ; PUF_canDefendPotentialEnemy
; Function compile flags: /Odtp
;	COMDAT ?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
tv76 = -4						; size = 4
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
_iData2$ = 16						; size = 4
?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z PROC	; PUF_canDefendPotentialEnemy, COMDAT

; 818  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 819  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 820  : 	return (PUF_canDefend(pUnit, iData1, iData2) && PUF_isPotentialEnemy(pUnit, iData1, iData2));

	mov	eax, DWORD PTR _iData2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iData1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	push	edx
	call	?PUF_canDefend@@YA_NPBVCvUnit@@HH@Z	; PUF_canDefend
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@PUF_canDef@2
	mov	ecx, DWORD PTR _iData2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iData1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$[ebp]
	push	eax
	call	?PUF_isPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ; PUF_isPotentialEnemy
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@PUF_canDef@2
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@PUF_canDef@2
$LN3@PUF_canDef@2:
	mov	DWORD PTR tv76[ebp], 0
$LN4@PUF_canDef@2:
	mov	al, BYTE PTR tv76[ebp]

; 821  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_canDefendPotentialEnemy@@YA_NPBVCvUnit@@HH@Z ENDP	; PUF_canDefendPotentialEnemy
_TEXT	ENDS
PUBLIC	?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z		; PUF_isFighting
EXTRN	?isFighting@CvUnit@@QBE_NXZ:PROC		; CvUnit::isFighting
; Function compile flags: /Odtp
;	COMDAT ?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isFighting, COMDAT

; 824  : {

	push	ebp
	mov	ebp, esp

; 825  : 	return pUnit->isFighting();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?isFighting@CvUnit@@QBE_NXZ		; CvUnit::isFighting

; 826  : }

	pop	ebp
	ret	0
?PUF_isFighting@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isFighting
_TEXT	ENDS
PUBLIC	?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z		; PUF_isDomainType
; Function compile flags: /Odtp
;	COMDAT ?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isDomainType, COMDAT

; 829  : {

	push	ebp
	mov	ebp, esp

; 830  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 831  : 	return (pUnit->getDomainType() == iData1);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[ebp]
	sete	cl
	mov	al, cl

; 832  : }

	pop	ebp
	ret	0
?PUF_isDomainType@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isDomainType
_TEXT	ENDS
PUBLIC	?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z		; PUF_isUnitType
; Function compile flags: /Odtp
;	COMDAT ?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isUnitType, COMDAT

; 835  : {

	push	ebp
	mov	ebp, esp

; 836  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 837  : 	return (pUnit->getUnitType() == iData1);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[ebp]
	sete	cl
	mov	al, cl

; 838  : }

	pop	ebp
	ret	0
?PUF_isUnitType@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isUnitType
_TEXT	ENDS
PUBLIC	?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z		; PUF_isUnitAIType
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
; Function compile flags: /Odtp
;	COMDAT ?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_iData1$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isUnitAIType, COMDAT

; 841  : {

	push	ebp
	mov	ebp, esp

; 842  : 	CvAssertMsg(iData1 != -1, "Invalid data argument, should be >= 0");
; 843  : 	return (pUnit->AI_getUnitAIType() == iData1);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iData1$[ebp]
	sete	cl
	mov	al, cl

; 844  : }

	pop	ebp
	ret	0
?PUF_isUnitAIType@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isUnitAIType
_TEXT	ENDS
PUBLIC	?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z		; PUF_isSelected
EXTRN	?IsSelected@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsSelected
; Function compile flags: /Odtp
;	COMDAT ?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isSelected, COMDAT

; 847  : {

	push	ebp
	mov	ebp, esp

; 848  : 	return pUnit->IsSelected();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?IsSelected@CvUnit@@QBE_NXZ		; CvUnit::IsSelected

; 849  : }

	pop	ebp
	ret	0
?PUF_isSelected@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isSelected
_TEXT	ENDS
PUBLIC	?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z	; PUF_makeInfoBarDirty
EXTRN	?setInfoBarDirty@CvUnit@@QAEX_N@Z:PROC		; CvUnit::setInfoBarDirty
; Function compile flags: /Odtp
;	COMDAT ?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z PROC		; PUF_makeInfoBarDirty, COMDAT

; 852  : {

	push	ebp
	mov	ebp, esp

; 853  : 	pUnit->setInfoBarDirty(true);

	push	1
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?setInfoBarDirty@CvUnit@@QAEX_N@Z	; CvUnit::setInfoBarDirty

; 854  : 	return true;

	mov	al, 1

; 855  : }

	pop	ebp
	ret	0
?PUF_makeInfoBarDirty@@YA_NPAVCvUnit@@HH@Z ENDP		; PUF_makeInfoBarDirty
_TEXT	ENDS
PUBLIC	?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z		; PUF_isNoMission
EXTRN	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ:PROC ; CvUnit::GetActivityType
; Function compile flags: /Odtp
;	COMDAT ?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isNoMission, COMDAT

; 858  : {

	push	ebp
	mov	ebp, esp

; 859  : 	return (pUnit->GetActivityType() != ACTIVITY_MISSION);

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?GetActivityType@CvUnit@@QBE?AW4ActivityTypes@@XZ ; CvUnit::GetActivityType
	xor	ecx, ecx
	cmp	eax, 6
	setne	cl
	mov	al, cl

; 860  : }

	pop	ebp
	ret	0
?PUF_isNoMission@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isNoMission
_TEXT	ENDS
PUBLIC	?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z		; PUF_isFiniteRange
EXTRN	?GetRange@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetRange
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
; Function compile flags: /Odtp
;	COMDAT ?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z
_TEXT	SEGMENT
tv72 = -4						; size = 4
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z PROC		; PUF_isFiniteRange, COMDAT

; 863  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 864  : 	return ((pUnit->getDomainType() != DOMAIN_AIR) || (pUnit->getUnitInfo().GetRange() > 0));

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	jne	SHORT $LN3@PUF_isFini
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetRange@CvUnitEntry@@QBEHXZ		; CvUnitEntry::GetRange
	test	eax, eax
	jg	SHORT $LN3@PUF_isFini
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@PUF_isFini
$LN3@PUF_isFini:
	mov	DWORD PTR tv72[ebp], 1
$LN4@PUF_isFini:
	mov	al, BYTE PTR tv72[ebp]

; 865  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PUF_isFiniteRange@@YA_NPBVCvUnit@@HH@Z ENDP		; PUF_isFiniteRange
_TEXT	ENDS
PUBLIC	?baseYieldToSymbol@@YAHHH@Z			; baseYieldToSymbol
; Function compile flags: /Odtp
;	COMDAT ?baseYieldToSymbol@@YAHHH@Z
_TEXT	SEGMENT
$T219644 = -8						; size = 4
_iReturn$ = -4						; size = 4
_iNumYieldTypes$ = 8					; size = 4
_iYieldStack$ = 12					; size = 4
?baseYieldToSymbol@@YAHHH@Z PROC			; baseYieldToSymbol, COMDAT

; 869  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 870  : 	int iReturn;	// holds the return value we will be calculating
; 871  : 
; 872  : 	// get the base value for the iReturn value
; 873  : 	iReturn = iNumYieldTypes * GC.getMAX_YIELD_STACK();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6232
	mov	DWORD PTR $T219644[ebp], eax
	mov	ecx, DWORD PTR _iNumYieldTypes$[ebp]
	imul	ecx, DWORD PTR $T219644[ebp]
	mov	DWORD PTR _iReturn$[ebp], ecx

; 874  : 	// then add the offset to the return value
; 875  : 	iReturn += iYieldStack;

	mov	edx, DWORD PTR _iReturn$[ebp]
	add	edx, DWORD PTR _iYieldStack$[ebp]
	mov	DWORD PTR _iReturn$[ebp], edx

; 876  : 
; 877  : 	// return the value we have calculated
; 878  : 	return iReturn;

	mov	eax, DWORD PTR _iReturn$[ebp]

; 879  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?baseYieldToSymbol@@YAHHH@Z ENDP			; baseYieldToSymbol
_TEXT	ENDS
PUBLIC	??_C@_06DHPHOLDH@NOPICK?$AA@			; `string'
PUBLIC	?isPickableName@@YA_NPBD@Z			; isPickableName
EXTRN	__imp___mbsicmp:PROC
;	COMDAT ??_C@_06DHPHOLDH@NOPICK?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\tchar.h
CONST	SEGMENT
??_C@_06DHPHOLDH@NOPICK?$AA@ DB 'NOPICK', 00H		; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
CONST	ENDS
;	COMDAT ?isPickableName@@YA_NPBD@Z
_TEXT	SEGMENT
tv67 = -20						; size = 4
tv82 = -13						; size = 1
tv79 = -12						; size = 4
tv72 = -8						; size = 4
_iLen$217558 = -4					; size = 4
_szName$ = 8						; size = 4
?isPickableName@@YA_NPBD@Z PROC				; isPickableName, COMDAT

; 883  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 884  : 	if(szName)

	cmp	DWORD PTR _szName$[ebp], 0
	je	SHORT $LN2@isPickable

; 885  : 	{
; 886  : 		int iLen = _tcslen(szName);

	mov	eax, DWORD PTR _szName$[ebp]
	mov	DWORD PTR tv72[ebp], eax
	mov	ecx, DWORD PTR tv72[ebp]
	add	ecx, 1
	mov	DWORD PTR tv79[ebp], ecx
$LL7@isPickable:
	mov	edx, DWORD PTR tv72[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv82[ebp], al
	add	DWORD PTR tv72[ebp], 1
	cmp	BYTE PTR tv82[ebp], 0
	jne	SHORT $LL7@isPickable
	mov	ecx, DWORD PTR tv72[ebp]
	sub	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _iLen$217558[ebp], edx

; 887  : 
; 888  : 		if(!_tcsicmp(&szName[iLen-6], "NOPICK"))

	push	OFFSET ??_C@_06DHPHOLDH@NOPICK?$AA@
	mov	eax, DWORD PTR _iLen$217558[ebp]
	mov	ecx, DWORD PTR _szName$[ebp]
	lea	edx, DWORD PTR [ecx+eax-6]
	push	edx
	call	DWORD PTR __imp___mbsicmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN2@isPickable

; 889  : 		{
; 890  : 			return false;

	xor	al, al
	jmp	SHORT $LN3@isPickable
$LN2@isPickable:

; 891  : 		}
; 892  : 	}
; 893  : 
; 894  : 	return true;

	mov	al, 1
$LN3@isPickable:

; 895  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isPickableName@@YA_NPBD@Z ENDP				; isPickableName
_TEXT	ENDS
PUBLIC	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z		; shuffleArray
EXTRN	?get@CvRandom@@QAEGGPBD@Z:PROC			; CvRandom::get
; Function compile flags: /Odtp
;	COMDAT ?shuffleArray@@YAXPAHHAAVCvRandom@@@Z
_TEXT	SEGMENT
_iTemp$217575 = -12					; size = 4
_iJ$ = -8						; size = 4
_iI$ = -4						; size = 4
_piShuffle$ = 8						; size = 4
_iNum$ = 12						; size = 4
_rand$ = 16						; size = 4
?shuffleArray@@YAXPAHHAAVCvRandom@@@Z PROC		; shuffleArray, COMDAT

; 898  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 899  : 	int iI, iJ;
; 900  : 
; 901  : 	for(iI = 0; iI < iNum; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN7@shuffleArr
$LN6@shuffleArr:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN7@shuffleArr:
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR _iNum$[ebp]
	jge	SHORT $LN5@shuffleArr

; 902  : 	{
; 903  : 		piShuffle[iI] = iI;

	mov	edx, DWORD PTR _iI$[ebp]
	mov	eax, DWORD PTR _piShuffle$[ebp]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 904  : 	}

	jmp	SHORT $LN6@shuffleArr
$LN5@shuffleArr:

; 905  : 
; 906  : 	for(iI = 0; iI < iNum; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@shuffleArr
$LN3@shuffleArr:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN4@shuffleArr:
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR _iNum$[ebp]
	jge	SHORT $LN8@shuffleArr

; 907  : 	{
; 908  : 		iJ = (rand.get(iNum - iI, NULL) + iI);

	push	0
	mov	ecx, DWORD PTR _iNum$[ebp]
	sub	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rand$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	edx, ax
	add	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _iJ$[ebp], edx

; 909  : 
; 910  : 		if(iI != iJ)

	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR _iJ$[ebp]
	je	SHORT $LN1@shuffleArr

; 911  : 		{
; 912  : 			int iTemp = piShuffle[iI];

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _piShuffle$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _iTemp$217575[ebp], eax

; 913  : 			piShuffle[iI] = piShuffle[iJ];

	mov	ecx, DWORD PTR _iI$[ebp]
	mov	edx, DWORD PTR _piShuffle$[ebp]
	mov	eax, DWORD PTR _iJ$[ebp]
	mov	esi, DWORD PTR _piShuffle$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 914  : 			piShuffle[iJ] = iTemp;

	mov	ecx, DWORD PTR _iJ$[ebp]
	mov	edx, DWORD PTR _piShuffle$[ebp]
	mov	eax, DWORD PTR _iTemp$217575[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@shuffleArr:

; 915  : 		}

	jmp	SHORT $LN3@shuffleArr
$LN8@shuffleArr:

; 916  : 	}
; 917  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?shuffleArray@@YAXPAHHAAVCvRandom@@@Z ENDP		; shuffleArray
_TEXT	ENDS
PUBLIC	??_C@_06DOGEMHPN@Months?$AA@			; `string'
PUBLIC	?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ; getTurnMonthForGame
PUBLIC	?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ; getTurnYearForGame
EXTRN	__imp_?Count@Connection@Database@@QAEHPBD_N@Z:PROC
;	COMDAT ??_C@_06DOGEMHPN@Months?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_06DOGEMHPN@Months?$AA@ DB 'Months', 00H		; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
CONST	ENDS
;	COMDAT ?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z
_TEXT	SEGMENT
$T219658 = -4						; size = 4
_iGameTurn$ = 8						; size = 4
_iStartYear$ = 12					; size = 4
_eCalendar$ = 16					; size = 4
_eSpeed$ = 20						; size = 4
?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z PROC ; getTurnYearForGame, COMDAT

; 920  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 921  : 	return (getTurnMonthForGame(iGameTurn, iStartYear, eCalendar, eSpeed) / DB.Count("Months"));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR $T219658[ebp], eax
	mov	ecx, DWORD PTR _eSpeed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eCalendar$[ebp]
	push	edx
	mov	eax, DWORD PTR _iStartYear$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iGameTurn$[ebp]
	push	ecx
	call	?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ; getTurnMonthForGame
	add	esp, 16					; 00000010H
	mov	esi, eax
	push	1
	push	OFFSET ??_C@_06DOGEMHPN@Months?$AA@
	mov	ecx, DWORD PTR $T219658[ebp]
	call	DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx

; 922  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?getTurnYearForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ENDP ; getTurnYearForGame
_TEXT	ENDS
PUBLIC	??_C@_07MADONKFL@Seasons?$AA@			; `string'
EXTRN	?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z:PROC ; CvGameSpeedInfo::getGameTurnInfo
EXTRN	?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getNumTurnIncrements
EXTRN	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z:PROC ; CvGlobals::getGameSpeedInfo
;	COMDAT ??_C@_07MADONKFL@Seasons?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_07MADONKFL@Seasons?$AA@ DB 'Seasons', 00H		; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
CONST	ENDS
;	COMDAT ?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z
_TEXT	SEGMENT
tv75 = -44						; size = 4
$T219672 = -40						; size = 4
$T219668 = -36						; size = 4
$T219664 = -32						; size = 4
_gameTurnInfo$217604 = -28				; size = 4
_iGameSpeedNumTurnIncrements$217600 = -24		; size = 4
_iTurnMonth$ = -20					; size = 4
_iNumMonths$ = -16					; size = 4
_iTurnCount$ = -12					; size = 4
_iI$ = -8						; size = 4
_pkGameSpeedInfo$ = -4					; size = 4
_iGameTurn$ = 8						; size = 4
_iStartYear$ = 12					; size = 4
_eCalendar$ = 16					; size = 4
_eSpeed$ = 20						; size = 4
?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z PROC ; getTurnMonthForGame, COMDAT

; 926  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 927  : 	int iTurnMonth;
; 928  : 	int iTurnCount;
; 929  : 	int iI;
; 930  : 
; 931  : 	CvGameSpeedInfo* pkGameSpeedInfo = GC.getGameSpeedInfo(eSpeed);

	mov	eax, DWORD PTR _eSpeed$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getGameSpeedInfo@CvGlobals@@QAEPAVCvGameSpeedInfo@@W4GameSpeedTypes@@@Z ; CvGlobals::getGameSpeedInfo
	mov	DWORD PTR _pkGameSpeedInfo$[ebp], eax

; 932  : 	if(pkGameSpeedInfo == NULL)

	cmp	DWORD PTR _pkGameSpeedInfo$[ebp], 0
	jne	SHORT $LN16@getTurnMon

; 933  : 	{
; 934  : 		//This function requires a valid game speed type!
; 935  : 		CvAssert(pkGameSpeedInfo);
; 936  : 		return 0;

	xor	eax, eax
	jmp	$LN17@getTurnMon
$LN16@getTurnMon:

; 937  : 	}
; 938  : 
; 939  : 	const int iNumMonths = DB.Count("Months");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR $T219664[ebp], ecx
	push	1
	push	OFFSET ??_C@_06DOGEMHPN@Months?$AA@
	mov	ecx, DWORD PTR $T219664[ebp]
	call	DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z
	mov	DWORD PTR _iNumMonths$[ebp], eax

; 940  : 
; 941  : 	iTurnMonth = iStartYear * iNumMonths;

	mov	edx, DWORD PTR _iStartYear$[ebp]
	imul	edx, DWORD PTR _iNumMonths$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], edx

; 942  : 
; 943  : 	switch(eCalendar)

	mov	eax, DWORD PTR _eCalendar$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	cmp	DWORD PTR tv75[ebp], 6
	ja	$LN14@getTurnMon
	mov	ecx, DWORD PTR tv75[ebp]
	jmp	DWORD PTR $LN25@getTurnMon[ecx*4]
$LN13@getTurnMon:

; 944  : 	{
; 945  : 	case CALENDAR_DEFAULT:
; 946  : 		{
; 947  : 			iTurnCount = 0;

	mov	DWORD PTR _iTurnCount$[ebp], 0

; 948  : 			const int iGameSpeedNumTurnIncrements = pkGameSpeedInfo->getNumTurnIncrements();

	mov	ecx, DWORD PTR _pkGameSpeedInfo$[ebp]
	call	?getNumTurnIncrements@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getNumTurnIncrements
	mov	DWORD PTR _iGameSpeedNumTurnIncrements$217600[ebp], eax

; 949  : 
; 950  : 			for(iI = 0; iI < iGameSpeedNumTurnIncrements; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN12@getTurnMon
$LN11@getTurnMon:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN12@getTurnMon:
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR _iGameSpeedNumTurnIncrements$217600[ebp]
	jge	SHORT $LN10@getTurnMon

; 951  : 			{
; 952  : 				const GameTurnInfo& gameTurnInfo = pkGameSpeedInfo->getGameTurnInfo(iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkGameSpeedInfo$[ebp]
	call	?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z ; CvGameSpeedInfo::getGameTurnInfo
	mov	DWORD PTR _gameTurnInfo$217604[ebp], eax

; 953  : 
; 954  : 				if(iGameTurn > (iTurnCount + gameTurnInfo.iNumGameTurnsPerIncrement))

	mov	edx, DWORD PTR _gameTurnInfo$217604[ebp]
	mov	eax, DWORD PTR _iTurnCount$[ebp]
	add	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR _iGameTurn$[ebp], eax
	jle	SHORT $LN9@getTurnMon

; 955  : 				{
; 956  : 					iTurnMonth += (gameTurnInfo.iMonthIncrement * gameTurnInfo.iNumGameTurnsPerIncrement);

	mov	ecx, DWORD PTR _gameTurnInfo$217604[ebp]
	mov	edx, DWORD PTR _gameTurnInfo$217604[ebp]
	mov	eax, DWORD PTR [ecx]
	imul	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _iTurnMonth$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], eax

; 957  : 					iTurnCount += gameTurnInfo.iNumGameTurnsPerIncrement;

	mov	ecx, DWORD PTR _gameTurnInfo$217604[ebp]
	mov	edx, DWORD PTR _iTurnCount$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _iTurnCount$[ebp], edx

; 958  : 				}
; 959  : 				else

	jmp	SHORT $LN8@getTurnMon
$LN9@getTurnMon:

; 960  : 				{
; 961  : 					iTurnMonth += (gameTurnInfo.iMonthIncrement * (iGameTurn - iTurnCount));

	mov	eax, DWORD PTR _iGameTurn$[ebp]
	sub	eax, DWORD PTR _iTurnCount$[ebp]
	mov	ecx, DWORD PTR _gameTurnInfo$217604[ebp]
	imul	eax, DWORD PTR [ecx]
	add	eax, DWORD PTR _iTurnMonth$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], eax

; 962  : 					iTurnCount += (iGameTurn - iTurnCount);

	mov	edx, DWORD PTR _iGameTurn$[ebp]
	mov	DWORD PTR _iTurnCount$[ebp], edx

; 963  : 					break;

	jmp	SHORT $LN10@getTurnMon
$LN8@getTurnMon:

; 964  : 				}
; 965  : 			}

	jmp	SHORT $LN11@getTurnMon
$LN10@getTurnMon:

; 966  : 
; 967  : 			if(iGameTurn > iTurnCount)

	mov	eax, DWORD PTR _iGameTurn$[ebp]
	cmp	eax, DWORD PTR _iTurnCount$[ebp]
	jle	SHORT $LN7@getTurnMon

; 968  : 			{
; 969  : 				iTurnMonth += (pkGameSpeedInfo->getGameTurnInfo(iGameSpeedNumTurnIncrements - 1).iMonthIncrement * (iGameTurn - iTurnCount));

	mov	ecx, DWORD PTR _iGameSpeedNumTurnIncrements$217600[ebp]
	sub	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _pkGameSpeedInfo$[ebp]
	call	?getGameTurnInfo@CvGameSpeedInfo@@QBEAAUGameTurnInfo@@H@Z ; CvGameSpeedInfo::getGameTurnInfo
	mov	edx, DWORD PTR _iGameTurn$[ebp]
	sub	edx, DWORD PTR _iTurnCount$[ebp]
	imul	edx, DWORD PTR [eax]
	add	edx, DWORD PTR _iTurnMonth$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], edx
$LN7@getTurnMon:

; 970  : 			}
; 971  : 		}
; 972  : 		break;

	jmp	SHORT $LN14@getTurnMon
$LN6@getTurnMon:

; 973  : 
; 974  : 	case CALENDAR_BI_YEARLY:
; 975  : 		iTurnMonth += (2 * iGameTurn * iNumMonths);

	mov	eax, DWORD PTR _iGameTurn$[ebp]
	shl	eax, 1
	imul	eax, DWORD PTR _iNumMonths$[ebp]
	add	eax, DWORD PTR _iTurnMonth$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], eax

; 976  : 		break;

	jmp	SHORT $LN14@getTurnMon
$LN5@getTurnMon:

; 977  : 
; 978  : 	case CALENDAR_YEARS:
; 979  : 	case CALENDAR_TURNS:
; 980  : 		iTurnMonth += iGameTurn * iNumMonths;

	mov	ecx, DWORD PTR _iGameTurn$[ebp]
	imul	ecx, DWORD PTR _iNumMonths$[ebp]
	add	ecx, DWORD PTR _iTurnMonth$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], ecx

; 981  : 		break;

	jmp	SHORT $LN14@getTurnMon
$LN4@getTurnMon:

; 982  : 
; 983  : 	case CALENDAR_SEASONS:
; 984  : 		iTurnMonth += (iGameTurn * iNumMonths) / DB.Count("Seasons");

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR $T219668[ebp], edx
	mov	esi, DWORD PTR _iGameTurn$[ebp]
	imul	esi, DWORD PTR _iNumMonths$[ebp]
	push	1
	push	OFFSET ??_C@_07MADONKFL@Seasons?$AA@
	mov	ecx, DWORD PTR $T219668[ebp]
	call	DWORD PTR __imp_?Count@Connection@Database@@QAEHPBD_N@Z
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	add	eax, DWORD PTR _iTurnMonth$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], eax

; 985  : 		break;

	jmp	SHORT $LN14@getTurnMon
$LN3@getTurnMon:

; 986  : 
; 987  : 	case CALENDAR_MONTHS:
; 988  : 		iTurnMonth += iGameTurn;

	mov	edx, DWORD PTR _iTurnMonth$[ebp]
	add	edx, DWORD PTR _iGameTurn$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], edx

; 989  : 		break;

	jmp	SHORT $LN14@getTurnMon
$LN2@getTurnMon:

; 990  : 
; 991  : 	case CALENDAR_WEEKS:
; 992  : 		iTurnMonth += iGameTurn / GC.getWEEKS_PER_MONTHS();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6184
	mov	DWORD PTR $T219672[ebp], eax
	mov	eax, DWORD PTR _iGameTurn$[ebp]
	cdq
	idiv	DWORD PTR $T219672[ebp]
	add	eax, DWORD PTR _iTurnMonth$[ebp]
	mov	DWORD PTR _iTurnMonth$[ebp], eax
$LN14@getTurnMon:

; 993  : 		break;
; 994  : 
; 995  : 	default:
; 996  : 		CvAssert(false);
; 997  : 	}
; 998  : 
; 999  : 	return iTurnMonth;

	mov	eax, DWORD PTR _iTurnMonth$[ebp]
$LN17@getTurnMon:

; 1000 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN25@getTurnMon:
	DD	$LN13@getTurnMon
	DD	$LN6@getTurnMon
	DD	$LN5@getTurnMon
	DD	$LN5@getTurnMon
	DD	$LN4@getTurnMon
	DD	$LN3@getTurnMon
	DD	$LN2@getTurnMon
?getTurnMonthForGame@@YAHHHW4CalendarTypes@@W4GameSpeedTypes@@@Z ENDP ; getTurnMonthForGame
_TEXT	ENDS
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?boolsToString@@YAXPB_NHPAVCvString@@@Z		; boolsToString
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
CONST	ENDS
;	COMDAT ?boolsToString@@YAXPB_NHPAVCvString@@@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_i$ = -4						; size = 4
_pBools$ = 8						; size = 4
_iNumBools$ = 12					; size = 4
_szOut$ = 16						; size = 4
?boolsToString@@YAXPB_NHPAVCvString@@@Z PROC		; boolsToString, COMDAT

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1005 : 	*szOut = "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	eax, eax
	je	SHORT $LN9@boolsToStr
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _szOut$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN10@boolsToStr
$LN9@boolsToStr:
	mov	ecx, DWORD PTR _szOut$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN10@boolsToStr:

; 1006 : 	int i;
; 1007 : 	for(i=0; i<iNumBools; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@boolsToStr
$LN2@boolsToStr:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@boolsToStr:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _iNumBools$[ebp]
	jge	SHORT $LN4@boolsToStr

; 1008 : 	{
; 1009 : 		*szOut += pBools[i] ? "1" : "0";

	mov	eax, DWORD PTR _pBools$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@boolsToStr
	mov	DWORD PTR tv77[ebp], OFFSET ??_C@_01HIHLOKLC@1?$AA@
	jmp	SHORT $LN7@boolsToStr
$LN6@boolsToStr:
	mov	DWORD PTR tv77[ebp], OFFSET ??_C@_01GBGANLPD@0?$AA@
$LN7@boolsToStr:
	mov	edx, DWORD PTR tv77[ebp]
	push	edx
	mov	ecx, DWORD PTR _szOut$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	SHORT $LN2@boolsToStr
$LN4@boolsToStr:

; 1010 : 	}
; 1011 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?boolsToString@@YAXPB_NHPAVCvString@@@Z ENDP		; boolsToString
_TEXT	ENDS
PUBLIC	?stringToBools@@YAXPBDPAHPAPA_N@Z		; stringToBools
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Odtp
;	COMDAT ?stringToBools@@YAXPBDPAHPAPA_N@Z
_TEXT	SEGMENT
tv67 = -24						; size = 4
tv86 = -17						; size = 1
tv83 = -16						; size = 4
tv80 = -12						; size = 4
$T219685 = -8						; size = 4
_i$217634 = -4						; size = 4
_szString$ = 8						; size = 4
_iNumBools$ = 12					; size = 4
_ppBools$ = 16						; size = 4
?stringToBools@@YAXPBDPAHPAPA_N@Z PROC			; stringToBools, COMDAT

; 1017 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1018 : 	CvAssertMsg(szString, "null string");
; 1019 : 	if(szString)

	cmp	DWORD PTR _szString$[ebp], 0
	je	$LN5@stringToBo

; 1020 : 	{
; 1021 : 		*iNumBools = strlen(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR tv80[ebp]
	add	ecx, 1
	mov	DWORD PTR tv83[ebp], ecx
$LL7@stringToBo:
	mov	edx, DWORD PTR tv80[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv86[ebp], al
	add	DWORD PTR tv80[ebp], 1
	cmp	BYTE PTR tv86[ebp], 0
	jne	SHORT $LL7@stringToBo
	mov	ecx, DWORD PTR tv80[ebp]
	sub	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	mov	edx, DWORD PTR _iNumBools$[ebp]
	mov	eax, DWORD PTR tv67[ebp]
	mov	DWORD PTR [edx], eax

; 1022 : 		*ppBools = FNEW(bool[*iNumBools], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _iNumBools$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T219685[ebp], eax
	mov	eax, DWORD PTR _ppBools$[ebp]
	mov	ecx, DWORD PTR $T219685[ebp]
	mov	DWORD PTR [eax], ecx

; 1023 : 		int i;
; 1024 : 		for(i=0; i<*iNumBools; i++)

	mov	DWORD PTR _i$217634[ebp], 0
	jmp	SHORT $LN3@stringToBo
$LN2@stringToBo:
	mov	edx, DWORD PTR _i$217634[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217634[ebp], edx
$LN3@stringToBo:
	mov	eax, DWORD PTR _iNumBools$[ebp]
	mov	ecx, DWORD PTR _i$217634[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN5@stringToBo

; 1025 : 		{
; 1026 : 			(*ppBools)[i] = (szString[i]=='1');

	mov	edx, DWORD PTR _szString$[ebp]
	add	edx, DWORD PTR _i$217634[ebp]
	movsx	eax, BYTE PTR [edx]
	xor	ecx, ecx
	cmp	eax, 49					; 00000031H
	sete	cl
	mov	edx, DWORD PTR _ppBools$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _i$217634[ebp]
	mov	BYTE PTR [eax+edx], cl

; 1027 : 		}

	jmp	SHORT $LN2@stringToBo
$LN5@stringToBo:

; 1028 : 	}
; 1029 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stringToBools@@YAXPBDPAHPAPA_N@Z ENDP			; stringToBools
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?format@CvString@@SA?AV1@PBDZZ			; CvString::format
PUBLIC	??_C@_0BG@OHMKGNCG@UNKNOWN_DIRECTION?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_09BIJKFDMI@northwest?$AA@			; `string'
PUBLIC	??_C@_04GDDDFJPH@west?$AA@			; `string'
PUBLIC	??_C@_09MAAPFAIJ@southwest?$AA@			; `string'
PUBLIC	??_C@_09FFENADDM@southeast?$AA@			; `string'
PUBLIC	??_C@_04PGHBAKEC@east?$AA@			; `string'
PUBLIC	??_C@_09INNIAAHN@northeast?$AA@			; `string'
PUBLIC	??_C@_0N@ENHODHOO@NO_DIRECTION?$AA@		; `string'
PUBLIC	?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z ; getDirectionTypeString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BG@OHMKGNCG@UNKNOWN_DIRECTION?$CI?$CFd?$CJ?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BG@OHMKGNCG@UNKNOWN_DIRECTION?$CI?$CFd?$CJ?$AA@ DB 'UNKNOWN_DIRECT'
	DB	'ION(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIJKFDMI@northwest?$AA@
CONST	SEGMENT
??_C@_09BIJKFDMI@northwest?$AA@ DB 'northwest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDDDFJPH@west?$AA@
CONST	SEGMENT
??_C@_04GDDDFJPH@west?$AA@ DB 'west', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MAAPFAIJ@southwest?$AA@
CONST	SEGMENT
??_C@_09MAAPFAIJ@southwest?$AA@ DB 'southwest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FFENADDM@southeast?$AA@
CONST	SEGMENT
??_C@_09FFENADDM@southeast?$AA@ DB 'southeast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGHBAKEC@east?$AA@
CONST	SEGMENT
??_C@_04PGHBAKEC@east?$AA@ DB 'east', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09INNIAAHN@northeast?$AA@
CONST	SEGMENT
??_C@_09INNIAAHN@northeast?$AA@ DB 'northeast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ENHODHOO@NO_DIRECTION?$AA@
CONST	SEGMENT
??_C@_0N@ENHODHOO@NO_DIRECTION?$AA@ DB 'NO_DIRECTION', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z$0
__ehfuncinfo$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
_TEXT	SEGMENT
tv85 = -52						; size = 4
tv64 = -48						; size = 4
$T219729 = -44						; size = 4
$T219689 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eDirectionType$ = 12					; size = 4
?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z PROC ; getDirectionTypeString, COMDAT

; 1034 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1035 : 	switch(eDirectionType)

	mov	eax, DWORD PTR _eDirectionType$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 6
	ja	$LN1@getDirecti
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN48@getDirecti[edx*4]
$LN8@getDirecti:

; 1036 : 	{
; 1037 : 	case NO_DIRECTION:
; 1038 : 		strString = "NO_DIRECTION";

	mov	eax, OFFSET ??_C@_0N@ENHODHOO@NO_DIRECTION?$AA@
	test	eax, eax
	je	SHORT $LN15@getDirecti
	push	OFFSET ??_C@_0N@ENHODHOO@NO_DIRECTION?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN16@getDirecti
$LN15@getDirecti:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN16@getDirecti:

; 1039 : 		break;

	jmp	$LN11@getDirecti
$LN7@getDirecti:

; 1040 : 
; 1041 : 		//case DIRECTION_NORTH: strString = "north"; break;
; 1042 : 	case DIRECTION_NORTHEAST:
; 1043 : 		strString = "northeast";

	mov	ecx, OFFSET ??_C@_09INNIAAHN@northeast?$AA@
	test	ecx, ecx
	je	SHORT $LN19@getDirecti
	push	OFFSET ??_C@_09INNIAAHN@northeast?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN20@getDirecti
$LN19@getDirecti:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN20@getDirecti:

; 1044 : 		break;

	jmp	$LN11@getDirecti
$LN6@getDirecti:

; 1045 : 	case DIRECTION_EAST:
; 1046 : 		strString = "east";

	mov	edx, OFFSET ??_C@_04PGHBAKEC@east?$AA@
	test	edx, edx
	je	SHORT $LN23@getDirecti
	push	OFFSET ??_C@_04PGHBAKEC@east?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN24@getDirecti
$LN23@getDirecti:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN24@getDirecti:

; 1047 : 		break;

	jmp	$LN11@getDirecti
$LN5@getDirecti:

; 1048 : 	case DIRECTION_SOUTHEAST:
; 1049 : 		strString = "southeast";

	mov	eax, OFFSET ??_C@_09FFENADDM@southeast?$AA@
	test	eax, eax
	je	SHORT $LN27@getDirecti
	push	OFFSET ??_C@_09FFENADDM@southeast?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN28@getDirecti
$LN27@getDirecti:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN28@getDirecti:

; 1050 : 		break;

	jmp	$LN11@getDirecti
$LN4@getDirecti:

; 1051 : 		//case DIRECTION_SOUTH: strString = "south"; break;
; 1052 : 	case DIRECTION_SOUTHWEST:
; 1053 : 		strString = "southwest";

	mov	ecx, OFFSET ??_C@_09MAAPFAIJ@southwest?$AA@
	test	ecx, ecx
	je	SHORT $LN31@getDirecti
	push	OFFSET ??_C@_09MAAPFAIJ@southwest?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN32@getDirecti
$LN31@getDirecti:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN32@getDirecti:

; 1054 : 		break;

	jmp	$LN11@getDirecti
$LN3@getDirecti:

; 1055 : 	case DIRECTION_WEST:
; 1056 : 		strString = "west";

	mov	edx, OFFSET ??_C@_04GDDDFJPH@west?$AA@
	test	edx, edx
	je	SHORT $LN35@getDirecti
	push	OFFSET ??_C@_04GDDDFJPH@west?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN36@getDirecti
$LN35@getDirecti:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN36@getDirecti:

; 1057 : 		break;

	jmp	SHORT $LN11@getDirecti
$LN2@getDirecti:

; 1058 : 	case DIRECTION_NORTHWEST:
; 1059 : 		strString = "northwest";

	mov	eax, OFFSET ??_C@_09BIJKFDMI@northwest?$AA@
	test	eax, eax
	je	SHORT $LN39@getDirecti
	push	OFFSET ??_C@_09BIJKFDMI@northwest?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN40@getDirecti
$LN39@getDirecti:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN40@getDirecti:

; 1060 : 		break;

	jmp	SHORT $LN11@getDirecti
$LN1@getDirecti:

; 1061 : 
; 1062 : 	default:
; 1063 : 		strString = CvString::format("UNKNOWN_DIRECTION(%d)", eDirectionType);

	mov	ecx, DWORD PTR _eDirectionType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@OHMKGNCG@UNKNOWN_DIRECTION?$CI?$CFd?$CJ?$AA@
	lea	edx, DWORD PTR $T219689[ebp]
	push	edx
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv85[ebp], eax
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR $T219729[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T219729[ebp]
	push	ecx
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T219689[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@getDirecti:

; 1064 : 		break;
; 1065 : 	}
; 1066 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@getDirecti:
	DD	$LN8@getDirecti
	DD	$LN7@getDirecti
	DD	$LN6@getDirecti
	DD	$LN5@getDirecti
	DD	$LN4@getDirecti
	DD	$LN3@getDirecti
	DD	$LN2@getDirecti
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z$0:
	lea	ecx, DWORD PTR $T219689[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getDirectionTypeString@@YAXAAVCvString@@W4DirectionTypes@@@Z ENDP ; getDirectionTypeString
PUBLIC	??_C@_0BF@DHJLHLBO@UNKNOWN_ACTIVITY?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@EBOGBEEG@ACTIVITY_MISSION?$AA@	; `string'
PUBLIC	??_C@_0BA@DKGFPPBI@ACTIVITY_SENTRY?$AA@		; `string'
PUBLIC	??_C@_0O@NFNCNPJD@ACTIVITY_HEAL?$AA@		; `string'
PUBLIC	??_C@_0P@DHNKHBIE@ACTIVITY_SLEEP?$AA@		; `string'
PUBLIC	??_C@_0O@HKGOCGKM@ACTIVITY_HOLD?$AA@		; `string'
PUBLIC	??_C@_0P@NMLNCIMO@ACTIVITY_AWAKE?$AA@		; `string'
PUBLIC	??_C@_0M@JAGCGEHF@NO_ACTIVITY?$AA@		; `string'
PUBLIC	?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z ; getActivityTypeString
;	COMDAT ??_C@_0BF@DHJLHLBO@UNKNOWN_ACTIVITY?$CI?$CFd?$CJ?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BF@DHJLHLBO@UNKNOWN_ACTIVITY?$CI?$CFd?$CJ?$AA@ DB 'UNKNOWN_ACTIVIT'
	DB	'Y(%d)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EBOGBEEG@ACTIVITY_MISSION?$AA@
CONST	SEGMENT
??_C@_0BB@EBOGBEEG@ACTIVITY_MISSION?$AA@ DB 'ACTIVITY_MISSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKGFPPBI@ACTIVITY_SENTRY?$AA@
CONST	SEGMENT
??_C@_0BA@DKGFPPBI@ACTIVITY_SENTRY?$AA@ DB 'ACTIVITY_SENTRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NFNCNPJD@ACTIVITY_HEAL?$AA@
CONST	SEGMENT
??_C@_0O@NFNCNPJD@ACTIVITY_HEAL?$AA@ DB 'ACTIVITY_HEAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHNKHBIE@ACTIVITY_SLEEP?$AA@
CONST	SEGMENT
??_C@_0P@DHNKHBIE@ACTIVITY_SLEEP?$AA@ DB 'ACTIVITY_SLEEP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HKGOCGKM@ACTIVITY_HOLD?$AA@
CONST	SEGMENT
??_C@_0O@HKGOCGKM@ACTIVITY_HOLD?$AA@ DB 'ACTIVITY_HOLD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NMLNCIMO@ACTIVITY_AWAKE?$AA@
CONST	SEGMENT
??_C@_0P@NMLNCIMO@ACTIVITY_AWAKE?$AA@ DB 'ACTIVITY_AWAKE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JAGCGEHF@NO_ACTIVITY?$AA@
CONST	SEGMENT
??_C@_0M@JAGCGEHF@NO_ACTIVITY?$AA@ DB 'NO_ACTIVITY', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z$0
__ehfuncinfo$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
_TEXT	SEGMENT
tv87 = -52						; size = 4
tv64 = -48						; size = 4
$T219793 = -44						; size = 4
$T219748 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eActivityType$ = 12					; size = 4
?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z PROC ; getActivityTypeString, COMDAT

; 1069 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1070 : 	switch(eActivityType)

	mov	eax, DWORD PTR _eActivityType$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 7
	ja	$LN1@getActivit
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN53@getActivit[edx*4]
$LN9@getActivit:

; 1071 : 	{
; 1072 : 	case NO_ACTIVITY:
; 1073 : 		strString			= "NO_ACTIVITY";

	mov	eax, OFFSET ??_C@_0M@JAGCGEHF@NO_ACTIVITY?$AA@
	test	eax, eax
	je	SHORT $LN16@getActivit
	push	OFFSET ??_C@_0M@JAGCGEHF@NO_ACTIVITY?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN17@getActivit
$LN16@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN17@getActivit:

; 1074 : 		break;

	jmp	$LN12@getActivit
$LN8@getActivit:

; 1075 : 	case ACTIVITY_AWAKE:
; 1076 : 		strString		= "ACTIVITY_AWAKE";

	mov	ecx, OFFSET ??_C@_0P@NMLNCIMO@ACTIVITY_AWAKE?$AA@
	test	ecx, ecx
	je	SHORT $LN20@getActivit
	push	OFFSET ??_C@_0P@NMLNCIMO@ACTIVITY_AWAKE?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN21@getActivit
$LN20@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN21@getActivit:

; 1077 : 		break;

	jmp	$LN12@getActivit
$LN7@getActivit:

; 1078 : 	case ACTIVITY_HOLD:
; 1079 : 		strString		= "ACTIVITY_HOLD";

	mov	edx, OFFSET ??_C@_0O@HKGOCGKM@ACTIVITY_HOLD?$AA@
	test	edx, edx
	je	SHORT $LN24@getActivit
	push	OFFSET ??_C@_0O@HKGOCGKM@ACTIVITY_HOLD?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN25@getActivit
$LN24@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN25@getActivit:

; 1080 : 		break;

	jmp	$LN12@getActivit
$LN6@getActivit:

; 1081 : 	case ACTIVITY_SLEEP:
; 1082 : 		strString		= "ACTIVITY_SLEEP";

	mov	eax, OFFSET ??_C@_0P@DHNKHBIE@ACTIVITY_SLEEP?$AA@
	test	eax, eax
	je	SHORT $LN28@getActivit
	push	OFFSET ??_C@_0P@DHNKHBIE@ACTIVITY_SLEEP?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN29@getActivit
$LN28@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN29@getActivit:

; 1083 : 		break;

	jmp	$LN12@getActivit
$LN5@getActivit:

; 1084 : 	case ACTIVITY_HEAL:
; 1085 : 		strString		= "ACTIVITY_HEAL";

	mov	ecx, OFFSET ??_C@_0O@NFNCNPJD@ACTIVITY_HEAL?$AA@
	test	ecx, ecx
	je	SHORT $LN32@getActivit
	push	OFFSET ??_C@_0O@NFNCNPJD@ACTIVITY_HEAL?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN33@getActivit
$LN32@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN33@getActivit:

; 1086 : 		break;

	jmp	$LN12@getActivit
$LN4@getActivit:

; 1087 : 	case ACTIVITY_SENTRY:
; 1088 : 		strString		= "ACTIVITY_SENTRY";

	mov	edx, OFFSET ??_C@_0BA@DKGFPPBI@ACTIVITY_SENTRY?$AA@
	test	edx, edx
	je	SHORT $LN36@getActivit
	push	OFFSET ??_C@_0BA@DKGFPPBI@ACTIVITY_SENTRY?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@getActivit
$LN36@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@getActivit:

; 1089 : 		break;

	jmp	$LN12@getActivit
$LN3@getActivit:

; 1090 : 	case ACTIVITY_INTERCEPT:
; 1091 : 		strString	= "ACTIVITY_SENTRY";

	mov	eax, OFFSET ??_C@_0BA@DKGFPPBI@ACTIVITY_SENTRY?$AA@
	test	eax, eax
	je	SHORT $LN40@getActivit
	push	OFFSET ??_C@_0BA@DKGFPPBI@ACTIVITY_SENTRY?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN41@getActivit
$LN40@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN41@getActivit:

; 1092 : 		break;

	jmp	SHORT $LN12@getActivit
$LN2@getActivit:

; 1093 : 	case ACTIVITY_MISSION:
; 1094 : 		strString	= "ACTIVITY_MISSION";

	mov	ecx, OFFSET ??_C@_0BB@EBOGBEEG@ACTIVITY_MISSION?$AA@
	test	ecx, ecx
	je	SHORT $LN44@getActivit
	push	OFFSET ??_C@_0BB@EBOGBEEG@ACTIVITY_MISSION?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN45@getActivit
$LN44@getActivit:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN45@getActivit:

; 1095 : 		break;

	jmp	SHORT $LN12@getActivit
$LN1@getActivit:

; 1096 : 
; 1097 : 	default:
; 1098 : 		strString = CvString::format("UNKNOWN_ACTIVITY(%d)", eActivityType);

	mov	edx, DWORD PTR _eActivityType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@DHJLHLBO@UNKNOWN_ACTIVITY?$CI?$CFd?$CJ?$AA@
	lea	eax, DWORD PTR $T219748[ebp]
	push	eax
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T219793[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T219793[ebp]
	push	edx
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T219748[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN12@getActivit:

; 1099 : 		break;
; 1100 : 	}
; 1101 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN53@getActivit:
	DD	$LN9@getActivit
	DD	$LN8@getActivit
	DD	$LN7@getActivit
	DD	$LN6@getActivit
	DD	$LN5@getActivit
	DD	$LN4@getActivit
	DD	$LN3@getActivit
	DD	$LN2@getActivit
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z$0:
	lea	ecx, DWORD PTR $T219748[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getActivityTypeString@@YAXAAVCvString@@W4ActivityTypes@@@Z ENDP ; getActivityTypeString
PUBLIC	??_C@_0BG@KHLHLGDM@UNKOWN_MISSION_AI?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@LFPFBHLH@MISSIONAI_PICKUP?$AA@	; `string'
PUBLIC	??_C@_0BC@LJLODJDA@MISSIONAI_CARRIER?$AA@	; `string'
PUBLIC	??_C@_0BC@KEICPJHD@MISSIONAI_ASSAULT?$AA@	; `string'
PUBLIC	??_C@_0BA@JMJGNLKL@MISSIONAI_BUILD?$AA@		; `string'
PUBLIC	??_C@_0BA@DEBMCKNH@MISSIONAI_FOUND?$AA@		; `string'
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
PUBLIC	??_C@_0BC@FNNKHDIA@MISSIONAI_PILLAGE?$AA@	; `string'
PUBLIC	??_C@_0BD@EJKADIC@MISSIONAI_BLOCKADE?$AA@	; `string'
PUBLIC	??_C@_0BC@CGAOAPPN@MISSIONAI_EXPLORE?$AA@	; `string'
PUBLIC	??_C@_0BF@JDIFNBPJ@MISSIONAI_GREAT_WORK?$AA@	; `string'
PUBLIC	??_C@_0BA@FDMBMKDF@MISSIONAI_HURRY?$AA@		; `string'
PUBLIC	??_C@_0BE@JJLGDKKA@MISSIONAI_CONSTRUCT?$AA@	; `string'
PUBLIC	??_C@_0BB@CIBKELIB@MISSIONAI_SPREAD?$AA@	; `string'
PUBLIC	??_C@_0BF@KGGENIFJ@MISSIONAI_ATTACK_SPY?$AA@	; `string'
PUBLIC	??_C@_0BE@KDAHLBLP@MISSIONAI_GUARD_SPY?$AA@	; `string'
PUBLIC	??_C@_0BJ@KAEHIMCF@MISSIONAI_GUARD_RESOURCE?$AA@ ; `string'
PUBLIC	??_C@_0BF@HFCNFDHF@MISSIONAI_GUARD_CITY?$AA@	; `string'
PUBLIC	??_C@_0BG@FMECMDHF@MISSIONAI_LOAD_SPECIA?$AA@	; `string'
PUBLIC	??_C@_0BH@LHMFIJIN@MISSIONAI_LOAD_SETTLER?$AA@	; `string'
PUBLIC	??_C@_0BH@EMMKLKHJ@MISSIONAI_LOAD_ASSAULT?$AA@	; `string'
PUBLIC	??_C@_0BA@GGEJIGHO@MISSIONAI_GROUP?$AA@		; `string'
PUBLIC	??_C@_0BB@DDBCCNNI@MISSIONAI_SHADOW?$AA@	; `string'
PUBLIC	??_C@_0N@BHGMLDMP@NO_MISSIONAI?$AA@		; `string'
PUBLIC	?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z ; getMissionAIString
;	COMDAT ??_C@_0BG@KHLHLGDM@UNKOWN_MISSION_AI?$CI?$CFd?$CJ?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BG@KHLHLGDM@UNKOWN_MISSION_AI?$CI?$CFd?$CJ?$AA@ DB 'UNKOWN_MISSION'
	DB	'_AI(%d)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFPFBHLH@MISSIONAI_PICKUP?$AA@
CONST	SEGMENT
??_C@_0BB@LFPFBHLH@MISSIONAI_PICKUP?$AA@ DB 'MISSIONAI_PICKUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJLODJDA@MISSIONAI_CARRIER?$AA@
CONST	SEGMENT
??_C@_0BC@LJLODJDA@MISSIONAI_CARRIER?$AA@ DB 'MISSIONAI_CARRIER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KEICPJHD@MISSIONAI_ASSAULT?$AA@
CONST	SEGMENT
??_C@_0BC@KEICPJHD@MISSIONAI_ASSAULT?$AA@ DB 'MISSIONAI_ASSAULT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JMJGNLKL@MISSIONAI_BUILD?$AA@
CONST	SEGMENT
??_C@_0BA@JMJGNLKL@MISSIONAI_BUILD?$AA@ DB 'MISSIONAI_BUILD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DEBMCKNH@MISSIONAI_FOUND?$AA@
CONST	SEGMENT
??_C@_0BA@DEBMCKNH@MISSIONAI_FOUND?$AA@ DB 'MISSIONAI_FOUND', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FNNKHDIA@MISSIONAI_PILLAGE?$AA@
CONST	SEGMENT
??_C@_0BC@FNNKHDIA@MISSIONAI_PILLAGE?$AA@ DB 'MISSIONAI_PILLAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EJKADIC@MISSIONAI_BLOCKADE?$AA@
CONST	SEGMENT
??_C@_0BD@EJKADIC@MISSIONAI_BLOCKADE?$AA@ DB 'MISSIONAI_BLOCKADE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CGAOAPPN@MISSIONAI_EXPLORE?$AA@
CONST	SEGMENT
??_C@_0BC@CGAOAPPN@MISSIONAI_EXPLORE?$AA@ DB 'MISSIONAI_EXPLORE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JDIFNBPJ@MISSIONAI_GREAT_WORK?$AA@
CONST	SEGMENT
??_C@_0BF@JDIFNBPJ@MISSIONAI_GREAT_WORK?$AA@ DB 'MISSIONAI_GREAT_WORK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FDMBMKDF@MISSIONAI_HURRY?$AA@
CONST	SEGMENT
??_C@_0BA@FDMBMKDF@MISSIONAI_HURRY?$AA@ DB 'MISSIONAI_HURRY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JJLGDKKA@MISSIONAI_CONSTRUCT?$AA@
CONST	SEGMENT
??_C@_0BE@JJLGDKKA@MISSIONAI_CONSTRUCT?$AA@ DB 'MISSIONAI_CONSTRUCT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CIBKELIB@MISSIONAI_SPREAD?$AA@
CONST	SEGMENT
??_C@_0BB@CIBKELIB@MISSIONAI_SPREAD?$AA@ DB 'MISSIONAI_SPREAD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KGGENIFJ@MISSIONAI_ATTACK_SPY?$AA@
CONST	SEGMENT
??_C@_0BF@KGGENIFJ@MISSIONAI_ATTACK_SPY?$AA@ DB 'MISSIONAI_ATTACK_SPY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDAHLBLP@MISSIONAI_GUARD_SPY?$AA@
CONST	SEGMENT
??_C@_0BE@KDAHLBLP@MISSIONAI_GUARD_SPY?$AA@ DB 'MISSIONAI_GUARD_SPY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KAEHIMCF@MISSIONAI_GUARD_RESOURCE?$AA@
CONST	SEGMENT
??_C@_0BJ@KAEHIMCF@MISSIONAI_GUARD_RESOURCE?$AA@ DB 'MISSIONAI_GUARD_RESO'
	DB	'URCE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HFCNFDHF@MISSIONAI_GUARD_CITY?$AA@
CONST	SEGMENT
??_C@_0BF@HFCNFDHF@MISSIONAI_GUARD_CITY?$AA@ DB 'MISSIONAI_GUARD_CITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMECMDHF@MISSIONAI_LOAD_SPECIA?$AA@
CONST	SEGMENT
??_C@_0BG@FMECMDHF@MISSIONAI_LOAD_SPECIA?$AA@ DB 'MISSIONAI_LOAD_SPECIA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LHMFIJIN@MISSIONAI_LOAD_SETTLER?$AA@
CONST	SEGMENT
??_C@_0BH@LHMFIJIN@MISSIONAI_LOAD_SETTLER?$AA@ DB 'MISSIONAI_LOAD_SETTLER'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EMMKLKHJ@MISSIONAI_LOAD_ASSAULT?$AA@
CONST	SEGMENT
??_C@_0BH@EMMKLKHJ@MISSIONAI_LOAD_ASSAULT?$AA@ DB 'MISSIONAI_LOAD_ASSAULT'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGEJIGHO@MISSIONAI_GROUP?$AA@
CONST	SEGMENT
??_C@_0BA@GGEJIGHO@MISSIONAI_GROUP?$AA@ DB 'MISSIONAI_GROUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DDBCCNNI@MISSIONAI_SHADOW?$AA@
CONST	SEGMENT
??_C@_0BB@DDBCCNNI@MISSIONAI_SHADOW?$AA@ DB 'MISSIONAI_SHADOW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BHGMLDMP@NO_MISSIONAI?$AA@
CONST	SEGMENT
??_C@_0N@BHGMLDMP@NO_MISSIONAI?$AA@ DB 'NO_MISSIONAI', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z$0
__ehfuncinfo$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
_TEXT	SEGMENT
tv147 = -52						; size = 4
tv64 = -48						; size = 4
$T219892 = -44						; size = 4
$T219807 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eMissionAI$ = 12					; size = 4
?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z PROC ; getMissionAIString, COMDAT

; 1104 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1105 : 	switch(eMissionAI)

	mov	eax, DWORD PTR _eMissionAI$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 22			; 00000016H
	ja	$LN1@getMission
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN99@getMission[edx*4]
$LN23@getMission:

; 1106 : 	{
; 1107 : 	case NO_MISSIONAI:
; 1108 : 		strString = "NO_MISSIONAI";

	mov	eax, OFFSET ??_C@_0N@BHGMLDMP@NO_MISSIONAI?$AA@
	test	eax, eax
	je	SHORT $LN30@getMission
	push	OFFSET ??_C@_0N@BHGMLDMP@NO_MISSIONAI?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN31@getMission
$LN30@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN31@getMission:

; 1109 : 		break;

	jmp	$LN26@getMission
$LN22@getMission:

; 1110 : 
; 1111 : 	case MISSIONAI_SHADOW:
; 1112 : 		strString = "MISSIONAI_SHADOW";

	mov	ecx, OFFSET ??_C@_0BB@DDBCCNNI@MISSIONAI_SHADOW?$AA@
	test	ecx, ecx
	je	SHORT $LN34@getMission
	push	OFFSET ??_C@_0BB@DDBCCNNI@MISSIONAI_SHADOW?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN35@getMission
$LN34@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN35@getMission:

; 1113 : 		break;

	jmp	$LN26@getMission
$LN21@getMission:

; 1114 : 	case MISSIONAI_GROUP:
; 1115 : 		strString = "MISSIONAI_GROUP";

	mov	edx, OFFSET ??_C@_0BA@GGEJIGHO@MISSIONAI_GROUP?$AA@
	test	edx, edx
	je	SHORT $LN38@getMission
	push	OFFSET ??_C@_0BA@GGEJIGHO@MISSIONAI_GROUP?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN39@getMission
$LN38@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN39@getMission:

; 1116 : 		break;

	jmp	$LN26@getMission
$LN20@getMission:

; 1117 : 	case MISSIONAI_LOAD_ASSAULT:
; 1118 : 		strString = "MISSIONAI_LOAD_ASSAULT";

	mov	eax, OFFSET ??_C@_0BH@EMMKLKHJ@MISSIONAI_LOAD_ASSAULT?$AA@
	test	eax, eax
	je	SHORT $LN42@getMission
	push	OFFSET ??_C@_0BH@EMMKLKHJ@MISSIONAI_LOAD_ASSAULT?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN43@getMission
$LN42@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN43@getMission:

; 1119 : 		break;

	jmp	$LN26@getMission
$LN19@getMission:

; 1120 : 	case MISSIONAI_LOAD_SETTLER:
; 1121 : 		strString = "MISSIONAI_LOAD_SETTLER";

	mov	ecx, OFFSET ??_C@_0BH@LHMFIJIN@MISSIONAI_LOAD_SETTLER?$AA@
	test	ecx, ecx
	je	SHORT $LN46@getMission
	push	OFFSET ??_C@_0BH@LHMFIJIN@MISSIONAI_LOAD_SETTLER?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN47@getMission
$LN46@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN47@getMission:

; 1122 : 		break;

	jmp	$LN26@getMission
$LN18@getMission:

; 1123 : 	case MISSIONAI_LOAD_SPECIAL:
; 1124 : 		strString = "MISSIONAI_LOAD_SPECIA";

	mov	edx, OFFSET ??_C@_0BG@FMECMDHF@MISSIONAI_LOAD_SPECIA?$AA@
	test	edx, edx
	je	SHORT $LN50@getMission
	push	OFFSET ??_C@_0BG@FMECMDHF@MISSIONAI_LOAD_SPECIA?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN51@getMission
$LN50@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN51@getMission:

; 1125 : 		break;

	jmp	$LN26@getMission
$LN17@getMission:

; 1126 : 	case MISSIONAI_GUARD_CITY:
; 1127 : 		strString = "MISSIONAI_GUARD_CITY";

	mov	eax, OFFSET ??_C@_0BF@HFCNFDHF@MISSIONAI_GUARD_CITY?$AA@
	test	eax, eax
	je	SHORT $LN54@getMission
	push	OFFSET ??_C@_0BF@HFCNFDHF@MISSIONAI_GUARD_CITY?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN55@getMission
$LN54@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN55@getMission:

; 1128 : 		break;

	jmp	$LN26@getMission
$LN16@getMission:

; 1129 : 	case MISSIONAI_GUARD_RESOURCE:
; 1130 : 		strString = "MISSIONAI_GUARD_RESOURCE";

	mov	ecx, OFFSET ??_C@_0BJ@KAEHIMCF@MISSIONAI_GUARD_RESOURCE?$AA@
	test	ecx, ecx
	je	SHORT $LN58@getMission
	push	OFFSET ??_C@_0BJ@KAEHIMCF@MISSIONAI_GUARD_RESOURCE?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN59@getMission
$LN58@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN59@getMission:

; 1131 : 		break;

	jmp	$LN26@getMission
$LN15@getMission:

; 1132 : 	case MISSIONAI_GUARD_SPY:
; 1133 : 		strString = "MISSIONAI_GUARD_SPY";

	mov	edx, OFFSET ??_C@_0BE@KDAHLBLP@MISSIONAI_GUARD_SPY?$AA@
	test	edx, edx
	je	SHORT $LN62@getMission
	push	OFFSET ??_C@_0BE@KDAHLBLP@MISSIONAI_GUARD_SPY?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN63@getMission
$LN62@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN63@getMission:

; 1134 : 		break;

	jmp	$LN26@getMission
$LN14@getMission:

; 1135 : 	case MISSIONAI_ATTACK_SPY:
; 1136 : 		strString = "MISSIONAI_ATTACK_SPY";

	mov	eax, OFFSET ??_C@_0BF@KGGENIFJ@MISSIONAI_ATTACK_SPY?$AA@
	test	eax, eax
	je	SHORT $LN66@getMission
	push	OFFSET ??_C@_0BF@KGGENIFJ@MISSIONAI_ATTACK_SPY?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN67@getMission
$LN66@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN67@getMission:

; 1137 : 		break;

	jmp	$LN26@getMission
$LN13@getMission:

; 1138 : 	case MISSIONAI_SPREAD:
; 1139 : 		strString = "MISSIONAI_SPREAD";

	mov	ecx, OFFSET ??_C@_0BB@CIBKELIB@MISSIONAI_SPREAD?$AA@
	test	ecx, ecx
	je	SHORT $LN70@getMission
	push	OFFSET ??_C@_0BB@CIBKELIB@MISSIONAI_SPREAD?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN71@getMission
$LN70@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN71@getMission:

; 1140 : 		break;

	jmp	$LN26@getMission
$LN12@getMission:

; 1141 : 	case MISSIONAI_CONSTRUCT:
; 1142 : 		strString = "MISSIONAI_CONSTRUCT";

	mov	edx, OFFSET ??_C@_0BE@JJLGDKKA@MISSIONAI_CONSTRUCT?$AA@
	test	edx, edx
	je	SHORT $LN74@getMission
	push	OFFSET ??_C@_0BE@JJLGDKKA@MISSIONAI_CONSTRUCT?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN75@getMission
$LN74@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN75@getMission:

; 1143 : 		break;

	jmp	$LN26@getMission
$LN11@getMission:

; 1144 : 	case MISSIONAI_HURRY:
; 1145 : 		strString = "MISSIONAI_HURRY";

	mov	eax, OFFSET ??_C@_0BA@FDMBMKDF@MISSIONAI_HURRY?$AA@
	test	eax, eax
	je	SHORT $LN78@getMission
	push	OFFSET ??_C@_0BA@FDMBMKDF@MISSIONAI_HURRY?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN79@getMission
$LN78@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN79@getMission:

; 1146 : 		break;

	jmp	$LN26@getMission
$LN10@getMission:

; 1147 : 	case MISSIONAI_GREAT_WORK:
; 1148 : 		strString = "MISSIONAI_GREAT_WORK";

	mov	ecx, OFFSET ??_C@_0BF@JDIFNBPJ@MISSIONAI_GREAT_WORK?$AA@
	test	ecx, ecx
	je	SHORT $LN82@getMission
	push	OFFSET ??_C@_0BF@JDIFNBPJ@MISSIONAI_GREAT_WORK?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN83@getMission
$LN82@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN83@getMission:

; 1149 : 		break;

	jmp	$LN26@getMission
$LN9@getMission:

; 1150 : 	case MISSIONAI_EXPLORE:
; 1151 : 		strString = "MISSIONAI_EXPLORE";

	mov	edx, OFFSET ??_C@_0BC@CGAOAPPN@MISSIONAI_EXPLORE?$AA@
	test	edx, edx
	je	SHORT $LN86@getMission
	push	OFFSET ??_C@_0BC@CGAOAPPN@MISSIONAI_EXPLORE?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN87@getMission
$LN86@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN87@getMission:

; 1152 : 		break;

	jmp	$LN26@getMission
$LN8@getMission:

; 1153 : 	case MISSIONAI_BLOCKADE:
; 1154 : 		strString = "MISSIONAI_BLOCKADE";

	mov	eax, OFFSET ??_C@_0BD@EJKADIC@MISSIONAI_BLOCKADE?$AA@
	test	eax, eax
	je	SHORT $LN90@getMission
	push	OFFSET ??_C@_0BD@EJKADIC@MISSIONAI_BLOCKADE?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN91@getMission
$LN90@getMission:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN91@getMission:

; 1155 : 		break;

	jmp	$LN26@getMission
$LN7@getMission:

; 1156 : 	case MISSIONAI_PILLAGE:
; 1157 : 		strString = "MISSIONAI_PILLAGE";

	push	OFFSET ??_C@_0BC@FNNKHDIA@MISSIONAI_PILLAGE?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1158 : 		break;

	jmp	$LN26@getMission
$LN6@getMission:

; 1159 : 	case MISSIONAI_FOUND:
; 1160 : 		strString = "MISSIONAI_FOUND";

	push	OFFSET ??_C@_0BA@DEBMCKNH@MISSIONAI_FOUND?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1161 : 		break;

	jmp	SHORT $LN26@getMission
$LN5@getMission:

; 1162 : 	case MISSIONAI_BUILD:
; 1163 : 		strString = "MISSIONAI_BUILD";

	push	OFFSET ??_C@_0BA@JMJGNLKL@MISSIONAI_BUILD?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1164 : 		break;

	jmp	SHORT $LN26@getMission
$LN4@getMission:

; 1165 : 	case MISSIONAI_ASSAULT:
; 1166 : 		strString = "MISSIONAI_ASSAULT";

	push	OFFSET ??_C@_0BC@KEICPJHD@MISSIONAI_ASSAULT?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1167 : 		break;

	jmp	SHORT $LN26@getMission
$LN3@getMission:

; 1168 : 	case MISSIONAI_CARRIER:
; 1169 : 		strString = "MISSIONAI_CARRIER";

	push	OFFSET ??_C@_0BC@LJLODJDA@MISSIONAI_CARRIER?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1170 : 		break;

	jmp	SHORT $LN26@getMission
$LN2@getMission:

; 1171 : 	case MISSIONAI_PICKUP:
; 1172 : 		strString = "MISSIONAI_PICKUP";

	push	OFFSET ??_C@_0BB@LFPFBHLH@MISSIONAI_PICKUP?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1173 : 		break;

	jmp	SHORT $LN26@getMission
$LN1@getMission:

; 1174 : 
; 1175 : 	default:
; 1176 : 		strString = CvString::format("UNKOWN_MISSION_AI(%d)", eMissionAI);

	mov	ecx, DWORD PTR _eMissionAI$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BG@KHLHLGDM@UNKOWN_MISSION_AI?$CI?$CFd?$CJ?$AA@
	lea	edx, DWORD PTR $T219807[ebp]
	push	edx
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv147[ebp], eax
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T219892[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T219892[ebp]
	push	ecx
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T219807[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN26@getMission:

; 1177 : 		break;
; 1178 : 	}
; 1179 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN99@getMission:
	DD	$LN23@getMission
	DD	$LN22@getMission
	DD	$LN21@getMission
	DD	$LN20@getMission
	DD	$LN19@getMission
	DD	$LN18@getMission
	DD	$LN17@getMission
	DD	$LN16@getMission
	DD	$LN1@getMission
	DD	$LN15@getMission
	DD	$LN14@getMission
	DD	$LN13@getMission
	DD	$LN12@getMission
	DD	$LN11@getMission
	DD	$LN10@getMission
	DD	$LN9@getMission
	DD	$LN8@getMission
	DD	$LN7@getMission
	DD	$LN6@getMission
	DD	$LN5@getMission
	DD	$LN4@getMission
	DD	$LN3@getMission
	DD	$LN2@getMission
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z$0:
	lea	ecx, DWORD PTR $T219807[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getMissionAIString@@YAXAAVCvString@@W4MissionAITypes@@@Z ENDP ; getMissionAIString
PUBLIC	??_C@_0M@PIPICCLN@unknown?$CI?$CFd?$CJ?$AA@	; `string'
PUBLIC	??_C@_08IIMGNEFI@musician?$AA@			; `string'
PUBLIC	??_C@_06CONMFCKG@writer?$AA@			; `string'
PUBLIC	??_C@_0O@LEJDBDKO@archaeologist?$AA@		; `string'
PUBLIC	??_C@_0L@PDKMEMH@trade?5unit?$AA@		; `string'
PUBLIC	??_C@_07JIEGAMFG@admiral?$AA@			; `string'
PUBLIC	??_C@_0L@MOMCFJMI@inquisitor?$AA@		; `string'
PUBLIC	??_C@_0L@CCKHEAIH@missionary?$AA@		; `string'
PUBLIC	??_C@_07LGNHEHJB@prophet?$AA@			; `string'
PUBLIC	??_C@_08ONIGLJLF@treasure?$AA@			; `string'
PUBLIC	??_C@_0P@MAIDHLBO@spaceship?5part?$AA@		; `string'
PUBLIC	??_C@_08IMHLNJCN@paradrop?$AA@			; `string'
PUBLIC	??_C@_0M@COMBFAMH@carrier?5air?$AA@		; `string'
PUBLIC	??_C@_0M@BMHMFGCO@defense?5air?$AA@		; `string'
PUBLIC	??_C@_0L@ILLHONKN@attack?5air?$AA@		; `string'
PUBLIC	??_C@_0L@EPBDGBKG@pirate?5sea?$AA@		; `string'
PUBLIC	??_C@_0BA@HPFPOFIH@missile?5carrier?$AA@	; `string'
PUBLIC	??_C@_0M@LMCEHHCF@carrier?5sea?$AA@		; `string'
PUBLIC	??_C@_0M@DGABOOPC@settler?5sea?$AA@		; `string'
PUBLIC	??_C@_0M@LENPADJA@assault?5sea?$AA@		; `string'
PUBLIC	??_C@_0M@JMJAPILB@explore?5sea?$AA@		; `string'
PUBLIC	??_C@_0L@KFFFLIAK@escort?5sea?$AA@		; `string'
PUBLIC	??_C@_0M@NFBHHILP@reserve?5sea?$AA@		; `string'
PUBLIC	??_C@_0L@BJFCMKEP@attack?5sea?$AA@		; `string'
PUBLIC	??_C@_0L@CFIMLNPD@worker?5sea?$AA@		; `string'
PUBLIC	??_C@_04BPGMEPJH@icbm?$AA@			; `string'
PUBLIC	??_C@_08NCGGGNGI@engineer?$AA@			; `string'
PUBLIC	??_C@_08PKIEGJLJ@merchant?$AA@			; `string'
PUBLIC	??_C@_07LLDKJBMK@general?$AA@			; `string'
PUBLIC	??_C@_09BHKJDGPG@scientist?$AA@			; `string'
PUBLIC	??_C@_06FOCAFPGH@artist?$AA@			; `string'
PUBLIC	??_C@_07KGALEDAB@explore?$AA@			; `string'
PUBLIC	??_C@_0N@LOHALMON@city?5special?$AA@		; `string'
PUBLIC	??_C@_06BFLCJMIC@ranged?$AA@			; `string'
PUBLIC	??_C@_07HDOCMLOI@counter?$AA@			; `string'
PUBLIC	??_C@_07NEJDADE@defense?$AA@			; `string'
PUBLIC	??_C@_0M@GFHKGOGO@fast?5attack?$AA@		; `string'
PUBLIC	??_C@_0N@GCDBPDIO@bombard?5city?$AA@		; `string'
PUBLIC	??_C@_06JMLBDJHL@attack?$AA@			; `string'
PUBLIC	??_C@_06IONOKCLJ@worker?$AA@			; `string'
PUBLIC	??_C@_06FGGCKILM@settle?$AA@			; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_C@_09FMFCPID@no?5unitAI?$AA@			; `string'
PUBLIC	?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z ; getUnitAIString
;	COMDAT ??_C@_0M@PIPICCLN@unknown?$CI?$CFd?$CJ?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0M@PIPICCLN@unknown?$CI?$CFd?$CJ?$AA@ DB 'unknown(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IIMGNEFI@musician?$AA@
CONST	SEGMENT
??_C@_08IIMGNEFI@musician?$AA@ DB 'musician', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CONMFCKG@writer?$AA@
CONST	SEGMENT
??_C@_06CONMFCKG@writer?$AA@ DB 'writer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LEJDBDKO@archaeologist?$AA@
CONST	SEGMENT
??_C@_0O@LEJDBDKO@archaeologist?$AA@ DB 'archaeologist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDKMEMH@trade?5unit?$AA@
CONST	SEGMENT
??_C@_0L@PDKMEMH@trade?5unit?$AA@ DB 'trade unit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JIEGAMFG@admiral?$AA@
CONST	SEGMENT
??_C@_07JIEGAMFG@admiral?$AA@ DB 'admiral', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOMCFJMI@inquisitor?$AA@
CONST	SEGMENT
??_C@_0L@MOMCFJMI@inquisitor?$AA@ DB 'inquisitor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCKHEAIH@missionary?$AA@
CONST	SEGMENT
??_C@_0L@CCKHEAIH@missionary?$AA@ DB 'missionary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGNHEHJB@prophet?$AA@
CONST	SEGMENT
??_C@_07LGNHEHJB@prophet?$AA@ DB 'prophet', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ONIGLJLF@treasure?$AA@
CONST	SEGMENT
??_C@_08ONIGLJLF@treasure?$AA@ DB 'treasure', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MAIDHLBO@spaceship?5part?$AA@
CONST	SEGMENT
??_C@_0P@MAIDHLBO@spaceship?5part?$AA@ DB 'spaceship part', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IMHLNJCN@paradrop?$AA@
CONST	SEGMENT
??_C@_08IMHLNJCN@paradrop?$AA@ DB 'paradrop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COMBFAMH@carrier?5air?$AA@
CONST	SEGMENT
??_C@_0M@COMBFAMH@carrier?5air?$AA@ DB 'carrier air', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BMHMFGCO@defense?5air?$AA@
CONST	SEGMENT
??_C@_0M@BMHMFGCO@defense?5air?$AA@ DB 'defense air', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ILLHONKN@attack?5air?$AA@
CONST	SEGMENT
??_C@_0L@ILLHONKN@attack?5air?$AA@ DB 'attack air', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EPBDGBKG@pirate?5sea?$AA@
CONST	SEGMENT
??_C@_0L@EPBDGBKG@pirate?5sea?$AA@ DB 'pirate sea', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPFPOFIH@missile?5carrier?$AA@
CONST	SEGMENT
??_C@_0BA@HPFPOFIH@missile?5carrier?$AA@ DB 'missile carrier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMCEHHCF@carrier?5sea?$AA@
CONST	SEGMENT
??_C@_0M@LMCEHHCF@carrier?5sea?$AA@ DB 'carrier sea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DGABOOPC@settler?5sea?$AA@
CONST	SEGMENT
??_C@_0M@DGABOOPC@settler?5sea?$AA@ DB 'settler sea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LENPADJA@assault?5sea?$AA@
CONST	SEGMENT
??_C@_0M@LENPADJA@assault?5sea?$AA@ DB 'assault sea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMJAPILB@explore?5sea?$AA@
CONST	SEGMENT
??_C@_0M@JMJAPILB@explore?5sea?$AA@ DB 'explore sea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KFFFLIAK@escort?5sea?$AA@
CONST	SEGMENT
??_C@_0L@KFFFLIAK@escort?5sea?$AA@ DB 'escort sea', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFBHHILP@reserve?5sea?$AA@
CONST	SEGMENT
??_C@_0M@NFBHHILP@reserve?5sea?$AA@ DB 'reserve sea', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BJFCMKEP@attack?5sea?$AA@
CONST	SEGMENT
??_C@_0L@BJFCMKEP@attack?5sea?$AA@ DB 'attack sea', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CFIMLNPD@worker?5sea?$AA@
CONST	SEGMENT
??_C@_0L@CFIMLNPD@worker?5sea?$AA@ DB 'worker sea', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BPGMEPJH@icbm?$AA@
CONST	SEGMENT
??_C@_04BPGMEPJH@icbm?$AA@ DB 'icbm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCGGGNGI@engineer?$AA@
CONST	SEGMENT
??_C@_08NCGGGNGI@engineer?$AA@ DB 'engineer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PKIEGJLJ@merchant?$AA@
CONST	SEGMENT
??_C@_08PKIEGJLJ@merchant?$AA@ DB 'merchant', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLDKJBMK@general?$AA@
CONST	SEGMENT
??_C@_07LLDKJBMK@general?$AA@ DB 'general', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BHKJDGPG@scientist?$AA@
CONST	SEGMENT
??_C@_09BHKJDGPG@scientist?$AA@ DB 'scientist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOCAFPGH@artist?$AA@
CONST	SEGMENT
??_C@_06FOCAFPGH@artist?$AA@ DB 'artist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGALEDAB@explore?$AA@
CONST	SEGMENT
??_C@_07KGALEDAB@explore?$AA@ DB 'explore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LOHALMON@city?5special?$AA@
CONST	SEGMENT
??_C@_0N@LOHALMON@city?5special?$AA@ DB 'city special', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BFLCJMIC@ranged?$AA@
CONST	SEGMENT
??_C@_06BFLCJMIC@ranged?$AA@ DB 'ranged', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDOCMLOI@counter?$AA@
CONST	SEGMENT
??_C@_07HDOCMLOI@counter?$AA@ DB 'counter', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NEJDADE@defense?$AA@
CONST	SEGMENT
??_C@_07NEJDADE@defense?$AA@ DB 'defense', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GFHKGOGO@fast?5attack?$AA@
CONST	SEGMENT
??_C@_0M@GFHKGOGO@fast?5attack?$AA@ DB 'fast attack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GCDBPDIO@bombard?5city?$AA@
CONST	SEGMENT
??_C@_0N@GCDBPDIO@bombard?5city?$AA@ DB 'bombard city', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMLBDJHL@attack?$AA@
CONST	SEGMENT
??_C@_06JMLBDJHL@attack?$AA@ DB 'attack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IONOKCLJ@worker?$AA@
CONST	SEGMENT
??_C@_06IONOKCLJ@worker?$AA@ DB 'worker', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FGGCKILM@settle?$AA@
CONST	SEGMENT
??_C@_06FGGCKILM@settle?$AA@ DB 'settle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FMFCPID@no?5unitAI?$AA@
CONST	SEGMENT
??_C@_09FMFCPID@no?5unitAI?$AA@ DB 'no unitAI', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z$0
__ehfuncinfo$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.cpp
xdata$x	ENDS
;	COMDAT ?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
_TEXT	SEGMENT
tv187 = -52						; size = 4
tv64 = -48						; size = 4
$T220016 = -44						; size = 4
$T219906 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strString$ = 8						; size = 4
_eUnitAI$ = 12						; size = 4
?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z PROC ; getUnitAIString, COMDAT

; 1182 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1183 : 	// note, GC.getUnitAIInfo(eUnitAI).getDescription() is a international friendly way to get string (but it will be longer)
; 1184 : 
; 1185 : 	switch(eUnitAI)

	mov	eax, DWORD PTR _eUnitAI$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	add	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 42			; 0000002aH
	ja	$LN1@getUnitAIS
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN139@getUnitAIS[edx*4]
$LN43@getUnitAIS:

; 1186 : 	{
; 1187 : 	case NO_UNITAI:
; 1188 : 		strString = "no unitAI";

	mov	eax, OFFSET ??_C@_09FMFCPID@no?5unitAI?$AA@
	test	eax, eax
	je	SHORT $LN50@getUnitAIS
	push	OFFSET ??_C@_09FMFCPID@no?5unitAI?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN51@getUnitAIS
$LN50@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN51@getUnitAIS:

; 1189 : 		break;

	jmp	$LN46@getUnitAIS
$LN42@getUnitAIS:

; 1190 : 
; 1191 : 	case UNITAI_UNKNOWN:
; 1192 : 		strString = "unknown";

	mov	ecx, OFFSET ??_C@_07CIFAGBMG@unknown?$AA@
	test	ecx, ecx
	je	SHORT $LN54@getUnitAIS
	push	OFFSET ??_C@_07CIFAGBMG@unknown?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN55@getUnitAIS
$LN54@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN55@getUnitAIS:

; 1193 : 		break;

	jmp	$LN46@getUnitAIS
$LN41@getUnitAIS:

; 1194 : 	case UNITAI_SETTLE:
; 1195 : 		strString = "settle";

	mov	edx, OFFSET ??_C@_06FGGCKILM@settle?$AA@
	test	edx, edx
	je	SHORT $LN58@getUnitAIS
	push	OFFSET ??_C@_06FGGCKILM@settle?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN59@getUnitAIS
$LN58@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN59@getUnitAIS:

; 1196 : 		break;

	jmp	$LN46@getUnitAIS
$LN40@getUnitAIS:

; 1197 : 	case UNITAI_WORKER:
; 1198 : 		strString = "worker";

	mov	eax, OFFSET ??_C@_06IONOKCLJ@worker?$AA@
	test	eax, eax
	je	SHORT $LN62@getUnitAIS
	push	OFFSET ??_C@_06IONOKCLJ@worker?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN63@getUnitAIS
$LN62@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN63@getUnitAIS:

; 1199 : 		break;

	jmp	$LN46@getUnitAIS
$LN39@getUnitAIS:

; 1200 : 	case UNITAI_ATTACK:
; 1201 : 		strString = "attack";

	mov	ecx, OFFSET ??_C@_06JMLBDJHL@attack?$AA@
	test	ecx, ecx
	je	SHORT $LN66@getUnitAIS
	push	OFFSET ??_C@_06JMLBDJHL@attack?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN67@getUnitAIS
$LN66@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN67@getUnitAIS:

; 1202 : 		break;

	jmp	$LN46@getUnitAIS
$LN38@getUnitAIS:

; 1203 : 	case UNITAI_CITY_BOMBARD:
; 1204 : 		strString = "bombard city";

	mov	edx, OFFSET ??_C@_0N@GCDBPDIO@bombard?5city?$AA@
	test	edx, edx
	je	SHORT $LN70@getUnitAIS
	push	OFFSET ??_C@_0N@GCDBPDIO@bombard?5city?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN71@getUnitAIS
$LN70@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN71@getUnitAIS:

; 1205 : 		break;

	jmp	$LN46@getUnitAIS
$LN37@getUnitAIS:

; 1206 : 	case UNITAI_FAST_ATTACK:
; 1207 : 		strString = "fast attack";

	mov	eax, OFFSET ??_C@_0M@GFHKGOGO@fast?5attack?$AA@
	test	eax, eax
	je	SHORT $LN74@getUnitAIS
	push	OFFSET ??_C@_0M@GFHKGOGO@fast?5attack?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN75@getUnitAIS
$LN74@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN75@getUnitAIS:

; 1208 : 		break;

	jmp	$LN46@getUnitAIS
$LN36@getUnitAIS:

; 1209 : 	case UNITAI_DEFENSE:
; 1210 : 		strString = "defense";

	mov	ecx, OFFSET ??_C@_07NEJDADE@defense?$AA@
	test	ecx, ecx
	je	SHORT $LN78@getUnitAIS
	push	OFFSET ??_C@_07NEJDADE@defense?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN79@getUnitAIS
$LN78@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN79@getUnitAIS:

; 1211 : 		break;

	jmp	$LN46@getUnitAIS
$LN35@getUnitAIS:

; 1212 : 	case UNITAI_COUNTER:
; 1213 : 		strString = "counter";

	mov	edx, OFFSET ??_C@_07HDOCMLOI@counter?$AA@
	test	edx, edx
	je	SHORT $LN82@getUnitAIS
	push	OFFSET ??_C@_07HDOCMLOI@counter?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN83@getUnitAIS
$LN82@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN83@getUnitAIS:

; 1214 : 		break;

	jmp	$LN46@getUnitAIS
$LN34@getUnitAIS:

; 1215 : 	case UNITAI_RANGED:
; 1216 : 		strString = "ranged";

	mov	eax, OFFSET ??_C@_06BFLCJMIC@ranged?$AA@
	test	eax, eax
	je	SHORT $LN86@getUnitAIS
	push	OFFSET ??_C@_06BFLCJMIC@ranged?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN87@getUnitAIS
$LN86@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN87@getUnitAIS:

; 1217 : 		break;

	jmp	$LN46@getUnitAIS
$LN33@getUnitAIS:

; 1218 : 	case UNITAI_CITY_SPECIAL:
; 1219 : 		strString = "city special";

	mov	ecx, OFFSET ??_C@_0N@LOHALMON@city?5special?$AA@
	test	ecx, ecx
	je	SHORT $LN90@getUnitAIS
	push	OFFSET ??_C@_0N@LOHALMON@city?5special?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN91@getUnitAIS
$LN90@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN91@getUnitAIS:

; 1220 : 		break;

	jmp	$LN46@getUnitAIS
$LN32@getUnitAIS:

; 1221 : 	case UNITAI_EXPLORE:
; 1222 : 		strString = "explore";

	mov	edx, OFFSET ??_C@_07KGALEDAB@explore?$AA@
	test	edx, edx
	je	SHORT $LN94@getUnitAIS
	push	OFFSET ??_C@_07KGALEDAB@explore?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN95@getUnitAIS
$LN94@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN95@getUnitAIS:

; 1223 : 		break;

	jmp	$LN46@getUnitAIS
$LN31@getUnitAIS:

; 1224 : 	case UNITAI_ARTIST:
; 1225 : 		strString = "artist";

	mov	eax, OFFSET ??_C@_06FOCAFPGH@artist?$AA@
	test	eax, eax
	je	SHORT $LN98@getUnitAIS
	push	OFFSET ??_C@_06FOCAFPGH@artist?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN99@getUnitAIS
$LN98@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN99@getUnitAIS:

; 1226 : 		break;

	jmp	$LN46@getUnitAIS
$LN30@getUnitAIS:

; 1227 : 	case UNITAI_SCIENTIST:
; 1228 : 		strString = "scientist";

	mov	ecx, OFFSET ??_C@_09BHKJDGPG@scientist?$AA@
	test	ecx, ecx
	je	SHORT $LN102@getUnitAIS
	push	OFFSET ??_C@_09BHKJDGPG@scientist?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN103@getUnitAIS
$LN102@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN103@getUnitAIS:

; 1229 : 		break;

	jmp	$LN46@getUnitAIS
$LN29@getUnitAIS:

; 1230 : 	case UNITAI_GENERAL:
; 1231 : 		strString = "general";

	mov	edx, OFFSET ??_C@_07LLDKJBMK@general?$AA@
	test	edx, edx
	je	SHORT $LN106@getUnitAIS
	push	OFFSET ??_C@_07LLDKJBMK@general?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN107@getUnitAIS
$LN106@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN107@getUnitAIS:

; 1232 : 		break;

	jmp	$LN46@getUnitAIS
$LN28@getUnitAIS:

; 1233 : 	case UNITAI_MERCHANT:
; 1234 : 		strString = "merchant";

	mov	eax, OFFSET ??_C@_08PKIEGJLJ@merchant?$AA@
	test	eax, eax
	je	SHORT $LN110@getUnitAIS
	push	OFFSET ??_C@_08PKIEGJLJ@merchant?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN111@getUnitAIS
$LN110@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN111@getUnitAIS:

; 1235 : 		break;

	jmp	$LN46@getUnitAIS
$LN27@getUnitAIS:

; 1236 : 	case UNITAI_ENGINEER:
; 1237 : 		strString = "engineer";

	mov	ecx, OFFSET ??_C@_08NCGGGNGI@engineer?$AA@
	test	ecx, ecx
	je	SHORT $LN114@getUnitAIS
	push	OFFSET ??_C@_08NCGGGNGI@engineer?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN115@getUnitAIS
$LN114@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN115@getUnitAIS:

; 1238 : 		break;

	jmp	$LN46@getUnitAIS
$LN26@getUnitAIS:

; 1239 : 	case UNITAI_ICBM:
; 1240 : 		strString = "icbm";

	mov	edx, OFFSET ??_C@_04BPGMEPJH@icbm?$AA@
	test	edx, edx
	je	SHORT $LN118@getUnitAIS
	push	OFFSET ??_C@_04BPGMEPJH@icbm?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN119@getUnitAIS
$LN118@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN119@getUnitAIS:

; 1241 : 		break;

	jmp	$LN46@getUnitAIS
$LN25@getUnitAIS:

; 1242 : 	case UNITAI_WORKER_SEA:
; 1243 : 		strString = "worker sea";

	mov	eax, OFFSET ??_C@_0L@CFIMLNPD@worker?5sea?$AA@
	test	eax, eax
	je	SHORT $LN122@getUnitAIS
	push	OFFSET ??_C@_0L@CFIMLNPD@worker?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN123@getUnitAIS
$LN122@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN123@getUnitAIS:

; 1244 : 		break;

	jmp	$LN46@getUnitAIS
$LN24@getUnitAIS:

; 1245 : 	case UNITAI_ATTACK_SEA:
; 1246 : 		strString = "attack sea";

	mov	ecx, OFFSET ??_C@_0L@BJFCMKEP@attack?5sea?$AA@
	test	ecx, ecx
	je	SHORT $LN126@getUnitAIS
	push	OFFSET ??_C@_0L@BJFCMKEP@attack?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN127@getUnitAIS
$LN126@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN127@getUnitAIS:

; 1247 : 		break;

	jmp	$LN46@getUnitAIS
$LN23@getUnitAIS:

; 1248 : 	case UNITAI_RESERVE_SEA:
; 1249 : 		strString = "reserve sea";

	mov	edx, OFFSET ??_C@_0M@NFBHHILP@reserve?5sea?$AA@
	test	edx, edx
	je	SHORT $LN130@getUnitAIS
	push	OFFSET ??_C@_0M@NFBHHILP@reserve?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN131@getUnitAIS
$LN130@getUnitAIS:
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN131@getUnitAIS:

; 1250 : 		break;

	jmp	$LN46@getUnitAIS
$LN22@getUnitAIS:

; 1251 : 	case UNITAI_ESCORT_SEA:
; 1252 : 		strString = "escort sea";

	push	OFFSET ??_C@_0L@KFFFLIAK@escort?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1253 : 		break;

	jmp	$LN46@getUnitAIS
$LN21@getUnitAIS:

; 1254 : 	case UNITAI_EXPLORE_SEA:
; 1255 : 		strString = "explore sea";

	push	OFFSET ??_C@_0M@JMJAPILB@explore?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1256 : 		break;

	jmp	$LN46@getUnitAIS
$LN20@getUnitAIS:

; 1257 : 	case UNITAI_ASSAULT_SEA:
; 1258 : 		strString = "assault sea";

	push	OFFSET ??_C@_0M@LENPADJA@assault?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1259 : 		break;

	jmp	$LN46@getUnitAIS
$LN19@getUnitAIS:

; 1260 : 	case UNITAI_SETTLER_SEA:
; 1261 : 		strString = "settler sea";

	push	OFFSET ??_C@_0M@DGABOOPC@settler?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1262 : 		break;

	jmp	$LN46@getUnitAIS
$LN18@getUnitAIS:

; 1263 : 	case UNITAI_CARRIER_SEA:
; 1264 : 		strString = "carrier sea";

	push	OFFSET ??_C@_0M@LMCEHHCF@carrier?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1265 : 		break;

	jmp	$LN46@getUnitAIS
$LN17@getUnitAIS:

; 1266 : 	case UNITAI_MISSILE_CARRIER_SEA:
; 1267 : 		strString = "missile carrier";

	push	OFFSET ??_C@_0BA@HPFPOFIH@missile?5carrier?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1268 : 		break;

	jmp	$LN46@getUnitAIS
$LN16@getUnitAIS:

; 1269 : 	case UNITAI_PIRATE_SEA:
; 1270 : 		strString = "pirate sea";

	push	OFFSET ??_C@_0L@EPBDGBKG@pirate?5sea?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1271 : 		break;

	jmp	$LN46@getUnitAIS
$LN15@getUnitAIS:

; 1272 : 	case UNITAI_ATTACK_AIR:
; 1273 : 		strString = "attack air";

	push	OFFSET ??_C@_0L@ILLHONKN@attack?5air?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1274 : 		break;

	jmp	$LN46@getUnitAIS
$LN14@getUnitAIS:

; 1275 : 	case UNITAI_DEFENSE_AIR:
; 1276 : 		strString = "defense air";

	push	OFFSET ??_C@_0M@BMHMFGCO@defense?5air?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1277 : 		break;

	jmp	$LN46@getUnitAIS
$LN13@getUnitAIS:

; 1278 : 	case UNITAI_CARRIER_AIR:
; 1279 : 		strString = "carrier air";

	push	OFFSET ??_C@_0M@COMBFAMH@carrier?5air?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1280 : 		break;

	jmp	$LN46@getUnitAIS
$LN12@getUnitAIS:

; 1281 : 	case UNITAI_PARADROP:
; 1282 : 		strString = "paradrop";

	push	OFFSET ??_C@_08IMHLNJCN@paradrop?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1283 : 		break;

	jmp	$LN46@getUnitAIS
$LN11@getUnitAIS:

; 1284 : 	case UNITAI_SPACESHIP_PART:
; 1285 : 		strString = "spaceship part";

	push	OFFSET ??_C@_0P@MAIDHLBO@spaceship?5part?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1286 : 		break;

	jmp	$LN46@getUnitAIS
$LN10@getUnitAIS:

; 1287 : 	case UNITAI_TREASURE:
; 1288 : 		strString = "treasure";

	push	OFFSET ??_C@_08ONIGLJLF@treasure?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1289 : 		break;

	jmp	$LN46@getUnitAIS
$LN9@getUnitAIS:

; 1290 : 	case UNITAI_PROPHET:
; 1291 : 		strString = "prophet";

	push	OFFSET ??_C@_07LGNHEHJB@prophet?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1292 : 		break;

	jmp	$LN46@getUnitAIS
$LN8@getUnitAIS:

; 1293 : 	case UNITAI_MISSIONARY:
; 1294 : 		strString = "missionary";

	push	OFFSET ??_C@_0L@CCKHEAIH@missionary?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1295 : 		break;

	jmp	$LN46@getUnitAIS
$LN7@getUnitAIS:

; 1296 : 	case UNITAI_INQUISITOR:
; 1297 : 		strString = "inquisitor";

	push	OFFSET ??_C@_0L@MOMCFJMI@inquisitor?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1298 : 		break;

	jmp	$LN46@getUnitAIS
$LN6@getUnitAIS:

; 1299 : 	case UNITAI_ADMIRAL:
; 1300 : 		strString = "admiral";

	push	OFFSET ??_C@_07JIEGAMFG@admiral?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1301 : 		break;

	jmp	SHORT $LN46@getUnitAIS
$LN5@getUnitAIS:

; 1302 : 	case UNITAI_TRADE_UNIT:
; 1303 : 		strString = "trade unit";

	push	OFFSET ??_C@_0L@PDKMEMH@trade?5unit?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1304 : 		break;

	jmp	SHORT $LN46@getUnitAIS
$LN4@getUnitAIS:

; 1305 : 	case UNITAI_ARCHAEOLOGIST:
; 1306 : 		strString = "archaeologist";

	push	OFFSET ??_C@_0O@LEJDBDKO@archaeologist?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1307 : 		break;

	jmp	SHORT $LN46@getUnitAIS
$LN3@getUnitAIS:

; 1308 : 	case UNITAI_WRITER:
; 1309 : 		strString = "writer";

	push	OFFSET ??_C@_06CONMFCKG@writer?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1310 : 		break;

	jmp	SHORT $LN46@getUnitAIS
$LN2@getUnitAIS:

; 1311 : 	case UNITAI_MUSICIAN:
; 1312 : 		strString = "musician";

	push	OFFSET ??_C@_08IIMGNEFI@musician?$AA@
	mov	ecx, DWORD PTR _strString$[ebp]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN1@getUnitAIS:

; 1313 : 
; 1314 : 	default:
; 1315 : 		strString = CvString::format("unknown(%d)", eUnitAI);

	mov	eax, DWORD PTR _eUnitAI$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@PIPICCLN@unknown?$CI?$CFd?$CJ?$AA@
	lea	ecx, DWORD PTR $T219906[ebp]
	push	ecx
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv187[ebp], eax
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T220016[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T220016[ebp]
	push	eax
	mov	ecx, DWORD PTR _strString$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T219906[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN46@getUnitAIS:

; 1316 : 		break;
; 1317 : 	}
; 1318 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN139@getUnitAIS:
	DD	$LN43@getUnitAIS
	DD	$LN42@getUnitAIS
	DD	$LN41@getUnitAIS
	DD	$LN40@getUnitAIS
	DD	$LN39@getUnitAIS
	DD	$LN38@getUnitAIS
	DD	$LN37@getUnitAIS
	DD	$LN36@getUnitAIS
	DD	$LN35@getUnitAIS
	DD	$LN34@getUnitAIS
	DD	$LN33@getUnitAIS
	DD	$LN32@getUnitAIS
	DD	$LN31@getUnitAIS
	DD	$LN30@getUnitAIS
	DD	$LN29@getUnitAIS
	DD	$LN28@getUnitAIS
	DD	$LN27@getUnitAIS
	DD	$LN26@getUnitAIS
	DD	$LN25@getUnitAIS
	DD	$LN24@getUnitAIS
	DD	$LN23@getUnitAIS
	DD	$LN22@getUnitAIS
	DD	$LN21@getUnitAIS
	DD	$LN20@getUnitAIS
	DD	$LN19@getUnitAIS
	DD	$LN18@getUnitAIS
	DD	$LN17@getUnitAIS
	DD	$LN16@getUnitAIS
	DD	$LN15@getUnitAIS
	DD	$LN14@getUnitAIS
	DD	$LN13@getUnitAIS
	DD	$LN1@getUnitAIS
	DD	$LN12@getUnitAIS
	DD	$LN11@getUnitAIS
	DD	$LN10@getUnitAIS
	DD	$LN9@getUnitAIS
	DD	$LN8@getUnitAIS
	DD	$LN7@getUnitAIS
	DD	$LN6@getUnitAIS
	DD	$LN5@getUnitAIS
	DD	$LN4@getUnitAIS
	DD	$LN3@getUnitAIS
	DD	$LN2@getUnitAIS
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z$0:
	lea	ecx, DWORD PTR $T219906[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getUnitAIString@@YAXAAVCvString@@W4UnitAITypes@@@Z ENDP ; getUnitAIString
PUBLIC	?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z ; getRotatedPosition
; Function compile flags: /Odtp
;	COMDAT ?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z
_TEXT	SEGMENT
tv86 = -72						; size = 4
tv73 = -68						; size = 4
_ring$ = -32						; size = 4
_spikeX$ = -28						; size = 4
_newSpikeX$ = -24					; size = 4
_newSpikeDirection$ = -20				; size = 4
_spikeDirection$ = -16					; size = 4
_offsetOnThisRing$ = -12				; size = 4
_spikeY$ = -8						; size = 4
_newSpikeY$ = -4					; size = 4
_inHexspaceX$ = 8					; size = 4
_inHexspaceY$ = 12					; size = 4
_rotatedDirection$ = 16					; size = 4
_outRotatedX$ = 20					; size = 4
_outRotatedY$ = 24					; size = 4
?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z PROC	; getRotatedPosition, COMDAT

; 1321 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 1322 : 	outRotatedX = inHexspaceX;

	mov	eax, DWORD PTR _outRotatedX$[ebp]
	mov	ecx, DWORD PTR _inHexspaceX$[ebp]
	mov	DWORD PTR [eax], ecx

; 1323 : 	outRotatedY = inHexspaceY;

	mov	edx, DWORD PTR _outRotatedY$[ebp]
	mov	eax, DWORD PTR _inHexspaceY$[ebp]
	mov	DWORD PTR [edx], eax

; 1324 : 
; 1325 : 	// early out if the facing is NE as that is the base rotation that the data is supposed to be stored in
; 1326 : 	// also early out if we are looking at the pivot
; 1327 : 	if(DIRECTION_NORTHEAST == rotatedDirection || (inHexspaceX == 0 && inHexspaceY == 0))

	cmp	DWORD PTR _rotatedDirection$[ebp], 0
	je	SHORT $LN17@getRotated
	cmp	DWORD PTR _inHexspaceX$[ebp], 0
	jne	SHORT $LN18@getRotated
	cmp	DWORD PTR _inHexspaceY$[ebp], 0
	jne	SHORT $LN18@getRotated
$LN17@getRotated:

; 1328 : 	{
; 1329 : 		return;

	jmp	$LN19@getRotated
$LN18@getRotated:

; 1330 : 	};
; 1331 : 
; 1332 : 	// find the ring that this is on
; 1333 : 	int ring = hexDistance(inHexspaceX, inHexspaceY);

	mov	ecx, DWORD PTR _inHexspaceY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inHexspaceX$[ebp]
	push	edx
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	mov	DWORD PTR _ring$[ebp], eax

; 1334 : 
; 1335 : 	// find the nearest spike direction
; 1336 : 	DirectionTypes spikeDirection = hexspaceSpikeDirection(inHexspaceX, inHexspaceY);

	cmp	DWORD PTR _inHexspaceY$[ebp], 0
	jle	SHORT $LN50@getRotated
	cmp	DWORD PTR _inHexspaceX$[ebp], 0
	jl	SHORT $LN49@getRotated
	mov	DWORD PTR _spikeDirection$[ebp], 0
	jmp	$LN51@getRotated
	jmp	SHORT $LN48@getRotated
$LN49@getRotated:
	mov	eax, DWORD PTR _inHexspaceX$[ebp]
	neg	eax
	cmp	eax, DWORD PTR _inHexspaceY$[ebp]
	jg	SHORT $LN47@getRotated
	mov	DWORD PTR _spikeDirection$[ebp], 5
	jmp	SHORT $LN51@getRotated
	jmp	SHORT $LN48@getRotated
$LN47@getRotated:
	mov	DWORD PTR _spikeDirection$[ebp], 4
	jmp	SHORT $LN51@getRotated
$LN48@getRotated:
	jmp	SHORT $LN51@getRotated
$LN50@getRotated:
	cmp	DWORD PTR _inHexspaceY$[ebp], 0
	jne	SHORT $LN44@getRotated
	cmp	DWORD PTR _inHexspaceX$[ebp], 0
	jle	SHORT $LN43@getRotated
	mov	DWORD PTR _spikeDirection$[ebp], 1
	jmp	SHORT $LN51@getRotated
	jmp	SHORT $LN42@getRotated
$LN43@getRotated:
	cmp	DWORD PTR _inHexspaceX$[ebp], 0
	jne	SHORT $LN41@getRotated
	mov	DWORD PTR _spikeDirection$[ebp], -1
	jmp	SHORT $LN51@getRotated
	jmp	SHORT $LN42@getRotated
$LN41@getRotated:
	mov	DWORD PTR _spikeDirection$[ebp], 4
	jmp	SHORT $LN51@getRotated
$LN42@getRotated:
	jmp	SHORT $LN51@getRotated
$LN44@getRotated:
	mov	ecx, DWORD PTR _inHexspaceY$[ebp]
	neg	ecx
	cmp	DWORD PTR _inHexspaceX$[ebp], ecx
	jle	SHORT $LN38@getRotated
	mov	DWORD PTR _spikeDirection$[ebp], 1
	jmp	SHORT $LN51@getRotated
	jmp	SHORT $LN51@getRotated
$LN38@getRotated:
	cmp	DWORD PTR _inHexspaceX$[ebp], 0
	jle	SHORT $LN36@getRotated
	mov	DWORD PTR _spikeDirection$[ebp], 2
	jmp	SHORT $LN51@getRotated
	jmp	SHORT $LN51@getRotated
$LN36@getRotated:
	mov	DWORD PTR _spikeDirection$[ebp], 3
$LN51@getRotated:

; 1337 : 
; 1338 : 	int spikeX = 0;

	mov	DWORD PTR _spikeX$[ebp], 0

; 1339 : 	int spikeY = 0;

	mov	DWORD PTR _spikeY$[ebp], 0

; 1340 : 	switch(spikeDirection)

	mov	edx, DWORD PTR _spikeDirection$[ebp]
	mov	DWORD PTR tv73[ebp], edx
	cmp	DWORD PTR tv73[ebp], 5
	ja	SHORT $LN15@getRotated
	mov	eax, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN67@getRotated[eax*4]
$LN14@getRotated:

; 1341 : 	{
; 1342 : 	case DIRECTION_NORTHEAST:
; 1343 : 	{
; 1344 : 		spikeY = ring;

	mov	ecx, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _spikeY$[ebp], ecx

; 1345 : 	}
; 1346 : 	break;

	jmp	SHORT $LN15@getRotated
$LN13@getRotated:

; 1347 : 	case DIRECTION_EAST:
; 1348 : 	{
; 1349 : 		spikeX = ring;

	mov	edx, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _spikeX$[ebp], edx

; 1350 : 	}
; 1351 : 	break;

	jmp	SHORT $LN15@getRotated
$LN12@getRotated:

; 1352 : 	case DIRECTION_SOUTHEAST:
; 1353 : 	{
; 1354 : 		spikeX = ring;

	mov	eax, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _spikeX$[ebp], eax

; 1355 : 		spikeY = -ring;

	mov	ecx, DWORD PTR _ring$[ebp]
	neg	ecx
	mov	DWORD PTR _spikeY$[ebp], ecx

; 1356 : 	}
; 1357 : 	break;

	jmp	SHORT $LN15@getRotated
$LN11@getRotated:

; 1358 : 	case DIRECTION_SOUTHWEST:
; 1359 : 	{
; 1360 : 		spikeY = -ring;

	mov	edx, DWORD PTR _ring$[ebp]
	neg	edx
	mov	DWORD PTR _spikeY$[ebp], edx

; 1361 : 	}
; 1362 : 	break;

	jmp	SHORT $LN15@getRotated
$LN10@getRotated:

; 1363 : 	case DIRECTION_WEST:
; 1364 : 	{
; 1365 : 		spikeX = -ring;

	mov	eax, DWORD PTR _ring$[ebp]
	neg	eax
	mov	DWORD PTR _spikeX$[ebp], eax

; 1366 : 	}
; 1367 : 	break;

	jmp	SHORT $LN15@getRotated
$LN9@getRotated:

; 1368 : 	case DIRECTION_NORTHWEST:
; 1369 : 	{
; 1370 : 		spikeX = -ring;

	mov	ecx, DWORD PTR _ring$[ebp]
	neg	ecx
	mov	DWORD PTR _spikeX$[ebp], ecx

; 1371 : 		spikeY = ring;

	mov	edx, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _spikeY$[ebp], edx
$LN15@getRotated:

; 1372 : 	}
; 1373 : 	break;
; 1374 : 	}
; 1375 : 
; 1376 : 	// find the offset of this point from the spike
; 1377 : 	int offsetOnThisRing = hexDistance(spikeX-inHexspaceX,spikeY-inHexspaceY);

	mov	eax, DWORD PTR _spikeY$[ebp]
	sub	eax, DWORD PTR _inHexspaceY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spikeX$[ebp]
	sub	ecx, DWORD PTR _inHexspaceX$[ebp]
	push	ecx
	call	?hexDistance@@YAHHH@Z			; hexDistance
	add	esp, 8
	mov	DWORD PTR _offsetOnThisRing$[ebp], eax

; 1378 : 
; 1379 : 	// find the rotated spike
; 1380 : 	int newSpikeX = 0;

	mov	DWORD PTR _newSpikeX$[ebp], 0

; 1381 : 	int newSpikeY = 0;

	mov	DWORD PTR _newSpikeY$[ebp], 0

; 1382 : 	DirectionTypes newSpikeDirection = (DirectionTypes)((spikeDirection + rotatedDirection) % (NUM_DIRECTION_TYPES));

	mov	eax, DWORD PTR _spikeDirection$[ebp]
	add	eax, DWORD PTR _rotatedDirection$[ebp]
	cdq
	mov	ecx, 6
	idiv	ecx
	mov	DWORD PTR _newSpikeDirection$[ebp], edx

; 1383 : 	switch(newSpikeDirection)

	mov	edx, DWORD PTR _newSpikeDirection$[ebp]
	mov	DWORD PTR tv86[ebp], edx
	cmp	DWORD PTR tv86[ebp], 5
	ja	$LN19@getRotated
	mov	eax, DWORD PTR tv86[ebp]
	jmp	DWORD PTR $LN68@getRotated[eax*4]
$LN6@getRotated:

; 1384 : 	{
; 1385 : 	case DIRECTION_NORTHEAST:
; 1386 : 	{
; 1387 : 		newSpikeY = ring;

	mov	ecx, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _newSpikeY$[ebp], ecx

; 1388 : 		// add in the offset in the appropriate direction
; 1389 : 		outRotatedX = newSpikeX+offsetOnThisRing;

	mov	edx, DWORD PTR _newSpikeX$[ebp]
	add	edx, DWORD PTR _offsetOnThisRing$[ebp]
	mov	eax, DWORD PTR _outRotatedX$[ebp]
	mov	DWORD PTR [eax], edx

; 1390 : 		outRotatedY = newSpikeY-offsetOnThisRing;

	mov	ecx, DWORD PTR _newSpikeY$[ebp]
	sub	ecx, DWORD PTR _offsetOnThisRing$[ebp]
	mov	edx, DWORD PTR _outRotatedY$[ebp]
	mov	DWORD PTR [edx], ecx

; 1391 : 	}
; 1392 : 	break;

	jmp	$LN19@getRotated
$LN5@getRotated:

; 1393 : 	case DIRECTION_EAST:
; 1394 : 	{
; 1395 : 		newSpikeX = ring;

	mov	eax, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _newSpikeX$[ebp], eax

; 1396 : 		// add in the offset in the appropriate direction
; 1397 : 		outRotatedX = newSpikeX;

	mov	ecx, DWORD PTR _outRotatedX$[ebp]
	mov	edx, DWORD PTR _newSpikeX$[ebp]
	mov	DWORD PTR [ecx], edx

; 1398 : 		outRotatedY = newSpikeY-offsetOnThisRing;

	mov	eax, DWORD PTR _newSpikeY$[ebp]
	sub	eax, DWORD PTR _offsetOnThisRing$[ebp]
	mov	ecx, DWORD PTR _outRotatedY$[ebp]
	mov	DWORD PTR [ecx], eax

; 1399 : 	}
; 1400 : 	break;

	jmp	$LN19@getRotated
$LN4@getRotated:

; 1401 : 	case DIRECTION_SOUTHEAST:
; 1402 : 	{
; 1403 : 		newSpikeX = ring;

	mov	edx, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _newSpikeX$[ebp], edx

; 1404 : 		newSpikeY = -ring;

	mov	eax, DWORD PTR _ring$[ebp]
	neg	eax
	mov	DWORD PTR _newSpikeY$[ebp], eax

; 1405 : 		// add in the offset in the appropriate direction
; 1406 : 		outRotatedX = newSpikeX-offsetOnThisRing;

	mov	ecx, DWORD PTR _newSpikeX$[ebp]
	sub	ecx, DWORD PTR _offsetOnThisRing$[ebp]
	mov	edx, DWORD PTR _outRotatedX$[ebp]
	mov	DWORD PTR [edx], ecx

; 1407 : 		outRotatedY = newSpikeY;

	mov	eax, DWORD PTR _outRotatedY$[ebp]
	mov	ecx, DWORD PTR _newSpikeY$[ebp]
	mov	DWORD PTR [eax], ecx

; 1408 : 	}
; 1409 : 	break;

	jmp	SHORT $LN19@getRotated
$LN3@getRotated:

; 1410 : 	case DIRECTION_SOUTHWEST:
; 1411 : 	{
; 1412 : 		newSpikeY = -ring;

	mov	edx, DWORD PTR _ring$[ebp]
	neg	edx
	mov	DWORD PTR _newSpikeY$[ebp], edx

; 1413 : 		// add in the offset in the appropriate direction
; 1414 : 		outRotatedX = newSpikeX-offsetOnThisRing;

	mov	eax, DWORD PTR _newSpikeX$[ebp]
	sub	eax, DWORD PTR _offsetOnThisRing$[ebp]
	mov	ecx, DWORD PTR _outRotatedX$[ebp]
	mov	DWORD PTR [ecx], eax

; 1415 : 		outRotatedY = newSpikeY+offsetOnThisRing;

	mov	edx, DWORD PTR _newSpikeY$[ebp]
	add	edx, DWORD PTR _offsetOnThisRing$[ebp]
	mov	eax, DWORD PTR _outRotatedY$[ebp]
	mov	DWORD PTR [eax], edx

; 1416 : 	}
; 1417 : 	break;

	jmp	SHORT $LN19@getRotated
$LN2@getRotated:

; 1418 : 	case DIRECTION_WEST:
; 1419 : 	{
; 1420 : 		newSpikeX = -ring;

	mov	ecx, DWORD PTR _ring$[ebp]
	neg	ecx
	mov	DWORD PTR _newSpikeX$[ebp], ecx

; 1421 : 		// add in the offset in the appropriate direction
; 1422 : 		outRotatedX = newSpikeX;

	mov	edx, DWORD PTR _outRotatedX$[ebp]
	mov	eax, DWORD PTR _newSpikeX$[ebp]
	mov	DWORD PTR [edx], eax

; 1423 : 		outRotatedY = newSpikeY+offsetOnThisRing;

	mov	ecx, DWORD PTR _newSpikeY$[ebp]
	add	ecx, DWORD PTR _offsetOnThisRing$[ebp]
	mov	edx, DWORD PTR _outRotatedY$[ebp]
	mov	DWORD PTR [edx], ecx

; 1424 : 	}
; 1425 : 	break;

	jmp	SHORT $LN19@getRotated
$LN1@getRotated:

; 1426 : 	case DIRECTION_NORTHWEST:
; 1427 : 	{
; 1428 : 		newSpikeX = -ring;

	mov	eax, DWORD PTR _ring$[ebp]
	neg	eax
	mov	DWORD PTR _newSpikeX$[ebp], eax

; 1429 : 		newSpikeY = ring;

	mov	ecx, DWORD PTR _ring$[ebp]
	mov	DWORD PTR _newSpikeY$[ebp], ecx

; 1430 : 		// add in the offset in the appropriate direction
; 1431 : 		outRotatedX = newSpikeX+offsetOnThisRing;

	mov	edx, DWORD PTR _newSpikeX$[ebp]
	add	edx, DWORD PTR _offsetOnThisRing$[ebp]
	mov	eax, DWORD PTR _outRotatedX$[ebp]
	mov	DWORD PTR [eax], edx

; 1432 : 		outRotatedY = newSpikeY;

	mov	ecx, DWORD PTR _outRotatedY$[ebp]
	mov	edx, DWORD PTR _newSpikeY$[ebp]
	mov	DWORD PTR [ecx], edx
$LN19@getRotated:

; 1433 : 	}
; 1434 : 	break;
; 1435 : 	}
; 1436 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN67@getRotated:
	DD	$LN14@getRotated
	DD	$LN13@getRotated
	DD	$LN12@getRotated
	DD	$LN11@getRotated
	DD	$LN10@getRotated
	DD	$LN9@getRotated
$LN68@getRotated:
	DD	$LN6@getRotated
	DD	$LN5@getRotated
	DD	$LN4@getRotated
	DD	$LN3@getRotated
	DD	$LN2@getRotated
	DD	$LN1@getRotated
?getRotatedPosition@@YAXHHW4DirectionTypes@@AAH1@Z ENDP	; getRotatedPosition
_TEXT	ENDS
PUBLIC	??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z		; GetGUIDSegment<unsigned char>
PUBLIC	??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z		; GetGUIDSegment<unsigned short>
PUBLIC	??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z		; GetGUIDSegment<unsigned long>
PUBLIC	?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z		; ExtractGUID
; Function compile flags: /Odtp
;	COMDAT ?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z
_TEXT	SEGMENT
tv66 = -12						; size = 4
_iByte$217929 = -8					; size = 4
_uiIndex$217913 = -4					; size = 4
_pszGUID$ = 8						; size = 4
_kGUID$ = 12						; size = 4
_puiStartIndex$ = 16					; size = 4
?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z PROC		; ExtractGUID, COMDAT

; 1505 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1506 : 	if(pszGUID)

	cmp	DWORD PTR _pszGUID$[ebp], 0
	je	$LN9@ExtractGUI

; 1507 : 	{
; 1508 : 		UINT uiIndex = (puiStartIndex != NULL)?(*puiStartIndex):0;

	cmp	DWORD PTR _puiStartIndex$[ebp], 0
	je	SHORT $LN12@ExtractGUI
	mov	eax, DWORD PTR _puiStartIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv66[ebp], ecx
	jmp	SHORT $LN13@ExtractGUI
$LN12@ExtractGUI:
	mov	DWORD PTR tv66[ebp], 0
$LN13@ExtractGUI:
	mov	edx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _uiIndex$217913[ebp], edx

; 1509 : 
; 1510 : 		if(GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data1))

	mov	eax, DWORD PTR _kGUID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uiIndex$217913[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszGUID$[ebp]
	push	edx
	call	??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z	; GetGUIDSegment<unsigned long>
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	$LN9@ExtractGUI

; 1511 : 		{
; 1512 : 			if(GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data2))

	mov	ecx, DWORD PTR _kGUID$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR _uiIndex$217913[ebp]
	push	edx
	mov	eax, DWORD PTR _pszGUID$[ebp]
	push	eax
	call	??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z	; GetGUIDSegment<unsigned short>
	add	esp, 12					; 0000000cH
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@ExtractGUI

; 1513 : 			{
; 1514 : 				if(GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data3))

	mov	edx, DWORD PTR _kGUID$[ebp]
	add	edx, 6
	push	edx
	lea	eax, DWORD PTR _uiIndex$217913[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszGUID$[ebp]
	push	ecx
	call	??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z	; GetGUIDSegment<unsigned short>
	add	esp, 12					; 0000000cH
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN9@ExtractGUI

; 1515 : 				{
; 1516 : 					for(int iByte = 0; iByte < 8; ++iByte)

	mov	DWORD PTR _iByte$217929[ebp], 0
	jmp	SHORT $LN5@ExtractGUI
$LN4@ExtractGUI:
	mov	eax, DWORD PTR _iByte$217929[ebp]
	add	eax, 1
	mov	DWORD PTR _iByte$217929[ebp], eax
$LN5@ExtractGUI:
	cmp	DWORD PTR _iByte$217929[ebp], 8
	jge	SHORT $LN3@ExtractGUI

; 1517 : 					{
; 1518 : 						if(!GetGUIDSegment(pszGUID, &uiIndex, kGUID.Data4[iByte]))

	mov	ecx, DWORD PTR _iByte$217929[ebp]
	mov	edx, DWORD PTR _kGUID$[ebp]
	lea	eax, DWORD PTR [edx+ecx+8]
	push	eax
	lea	ecx, DWORD PTR _uiIndex$217913[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszGUID$[ebp]
	push	edx
	call	??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z	; GetGUIDSegment<unsigned char>
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@ExtractGUI

; 1519 : 						{
; 1520 : 							return false;

	xor	al, al
	jmp	SHORT $LN10@ExtractGUI
$LN2@ExtractGUI:

; 1521 : 						}
; 1522 : 					}

	jmp	SHORT $LN4@ExtractGUI
$LN3@ExtractGUI:

; 1523 : 
; 1524 : 					if(puiStartIndex)

	cmp	DWORD PTR _puiStartIndex$[ebp], 0
	je	SHORT $LN1@ExtractGUI

; 1525 : 						*puiStartIndex = uiIndex;

	mov	ecx, DWORD PTR _puiStartIndex$[ebp]
	mov	edx, DWORD PTR _uiIndex$217913[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@ExtractGUI:

; 1526 : 					return true;

	mov	al, 1
	jmp	SHORT $LN10@ExtractGUI
$LN9@ExtractGUI:

; 1527 : 				}
; 1528 : 			}
; 1529 : 		}
; 1530 : 	}
; 1531 : 
; 1532 : 	return false;

	xor	al, al
$LN10@ExtractGUI:

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ExtractGUID@@YA_NPBDAAU_GUID@@PAI@Z ENDP		; ExtractGUID
_TEXT	ENDS
PUBLIC	?ClearGUID@@YAXAAU_GUID@@@Z			; ClearGUID
; Function compile flags: /Odtp
;	COMDAT ?ClearGUID@@YAXAAU_GUID@@@Z
_TEXT	SEGMENT
_kGUID$ = 8						; size = 4
?ClearGUID@@YAXAAU_GUID@@@Z PROC			; ClearGUID, COMDAT

; 1537 : {

	push	ebp
	mov	ebp, esp

; 1538 : 	memset(&kGUID, 0, sizeof(GUID));

	xor	eax, eax
	mov	ecx, DWORD PTR _kGUID$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax

; 1539 : }

	pop	ebp
	ret	0
?ClearGUID@@YAXAAU_GUID@@@Z ENDP			; ClearGUID
_TEXT	ENDS
PUBLIC	?IsGUIDEmpty@@YA_NABU_GUID@@@Z			; IsGUIDEmpty
; Function compile flags: /Odtp
;	COMDAT ?IsGUIDEmpty@@YA_NABU_GUID@@@Z
_TEXT	SEGMENT
tv77 = -4						; size = 4
_kGUID$ = 8						; size = 4
?IsGUIDEmpty@@YA_NABU_GUID@@@Z PROC			; IsGUIDEmpty, COMDAT

; 1543 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1544 : 	return kGUID.Data1 == 0 && kGUID.Data2 == 0 && kGUID.Data3 == 0 && *(INT32*)&kGUID.Data4[0] == 0 && *(INT32*)&kGUID.Data4[4] == 0;

	mov	eax, DWORD PTR _kGUID$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@IsGUIDEmpt
	mov	ecx, DWORD PTR _kGUID$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@IsGUIDEmpt
	mov	eax, DWORD PTR _kGUID$[ebp]
	movzx	ecx, WORD PTR [eax+6]
	test	ecx, ecx
	jne	SHORT $LN3@IsGUIDEmpt
	mov	edx, DWORD PTR _kGUID$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN3@IsGUIDEmpt
	mov	eax, DWORD PTR _kGUID$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@IsGUIDEmpt
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN4@IsGUIDEmpt
$LN3@IsGUIDEmpt:
	mov	DWORD PTR tv77[ebp], 0
$LN4@IsGUIDEmpt:
	mov	al, BYTE PTR tv77[ebp]

; 1545 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGUIDEmpty@@YA_NABU_GUID@@@Z ENDP			; IsGUIDEmpty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv130 = -21						; size = 1
tv95 = -20						; size = 4
tv92 = -16						; size = 4
_uiValue$217965 = -12					; size = 4
_uiDigitCount$217960 = -8				; size = 4
_uiLength$ = -4						; size = 4
_pszGUID$ = 8						; size = 4
_puiIndex$ = 12						; size = 4
_kDest$ = 16						; size = 4
??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z PROC		; GetGUIDSegment<unsigned long>, COMDAT

; 1475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1476 : 	*puiIndex = SkipGUIDSeparators(pszGUID, *puiIndex);

	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pszGUID$[ebp]
	push	edx
	call	?SkipGUIDSeparators@@YAIPBDI@Z		; SkipGUIDSeparators
	add	esp, 8
	mov	ecx, DWORD PTR _puiIndex$[ebp]
	mov	DWORD PTR [ecx], eax

; 1477 : 
; 1478 : 	kDest = 0;

	mov	edx, DWORD PTR _kDest$[ebp]
	mov	DWORD PTR [edx], 0

; 1479 : 	UINT uiLength = strlen(pszGUID);

	mov	eax, DWORD PTR _pszGUID$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	ecx, DWORD PTR tv92[ebp]
	add	ecx, 1
	mov	DWORD PTR tv95[ebp], ecx
$LL11@GetGUIDSeg:
	mov	edx, DWORD PTR tv92[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv130[ebp], al
	add	DWORD PTR tv92[ebp], 1
	cmp	BYTE PTR tv130[ebp], 0
	jne	SHORT $LL11@GetGUIDSeg
	mov	ecx, DWORD PTR tv92[ebp]
	sub	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _uiLength$[ebp], edx

; 1480 : 	if(*puiIndex < uiLength)

	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _uiLength$[ebp]
	jae	SHORT $LN8@GetGUIDSeg

; 1481 : 	{
; 1482 : 		UINT uiDigitCount = sizeof(T) * 2;

	mov	DWORD PTR _uiDigitCount$217960[ebp], 8
$LN7@GetGUIDSeg:

; 1483 : 		do
; 1484 : 		{
; 1485 : 			UINT uiValue = 0;

	mov	DWORD PTR _uiValue$217965[ebp], 0

; 1486 : 			if(GetHexDigitValue(pszGUID[*puiIndex], uiValue))

	lea	edx, DWORD PTR _uiValue$217965[ebp]
	push	edx
	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pszGUID$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?GetHexDigitValue@@YA_NDAAI@Z		; GetHexDigitValue
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@GetGUIDSeg

; 1487 : #ifdef AUI_WARNING_FIXES
; 1488 : 				kDest = T((kDest * 16) + uiValue);
; 1489 : #else
; 1490 : 				kDest = (kDest * 16) + uiValue;

	mov	edx, DWORD PTR _kDest$[ebp]
	mov	eax, DWORD PTR [edx]
	shl	eax, 4
	add	eax, DWORD PTR _uiValue$217965[ebp]
	mov	ecx, DWORD PTR _kDest$[ebp]
	mov	DWORD PTR [ecx], eax

; 1491 : #endif
; 1492 : 			else

	jmp	SHORT $LN3@GetGUIDSeg
$LN4@GetGUIDSeg:

; 1493 : 				return false;

	xor	al, al
	jmp	SHORT $LN9@GetGUIDSeg
$LN3@GetGUIDSeg:

; 1494 : 			*puiIndex += 1;

	mov	edx, DWORD PTR _puiIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _puiIndex$[ebp]
	mov	DWORD PTR [ecx], eax

; 1495 : 		}
; 1496 : 		while(*puiIndex < uiLength  && --uiDigitCount);

	mov	edx, DWORD PTR _puiIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _uiLength$[ebp]
	jae	SHORT $LN5@GetGUIDSeg
	mov	ecx, DWORD PTR _uiDigitCount$217960[ebp]
	sub	ecx, 1
	mov	DWORD PTR _uiDigitCount$217960[ebp], ecx
	jne	SHORT $LN7@GetGUIDSeg
$LN5@GetGUIDSeg:

; 1497 : 
; 1498 : 		return true;

	mov	al, 1
	jmp	SHORT $LN9@GetGUIDSeg

; 1499 : 	}
; 1500 : 	else

	jmp	SHORT $LN9@GetGUIDSeg
$LN8@GetGUIDSeg:

; 1501 : 		return false;

	xor	al, al
$LN9@GetGUIDSeg:

; 1502 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$GetGUIDSegment@K@@YA_NPBDPAIAAK@Z ENDP		; GetGUIDSegment<unsigned long>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SkipGUIDSeparators@@YAIPBDI@Z
_TEXT	SEGMENT
tv66 = -24						; size = 4
tv84 = -17						; size = 1
tv81 = -16						; size = 4
tv78 = -12						; size = 4
_ch$217886 = -5						; size = 1
_uiLength$ = -4						; size = 4
_pszGUID$ = 8						; size = 4
_uiStartIndex$ = 12					; size = 4
?SkipGUIDSeparators@@YAIPBDI@Z PROC			; SkipGUIDSeparators, COMDAT

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1441 : 	UINT uiLength = strlen(pszGUID);

	mov	eax, DWORD PTR _pszGUID$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR tv78[ebp]
	add	ecx, 1
	mov	DWORD PTR tv81[ebp], ecx
$LL10@SkipGUIDSe:
	mov	edx, DWORD PTR tv78[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv84[ebp], al
	add	DWORD PTR tv78[ebp], 1
	cmp	BYTE PTR tv84[ebp], 0
	jne	SHORT $LL10@SkipGUIDSe
	mov	ecx, DWORD PTR tv78[ebp]
	sub	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _uiLength$[ebp], edx

; 1442 : 	if(uiStartIndex < uiLength)

	mov	eax, DWORD PTR _uiStartIndex$[ebp]
	cmp	eax, DWORD PTR _uiLength$[ebp]
	jae	SHORT $LN7@SkipGUIDSe
$LN6@SkipGUIDSe:

; 1443 : 	{
; 1444 : 		do
; 1445 : 		{
; 1446 : 			char ch = pszGUID[uiStartIndex];

	mov	ecx, DWORD PTR _pszGUID$[ebp]
	add	ecx, DWORD PTR _uiStartIndex$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _ch$217886[ebp], dl

; 1447 : 			if(ch == '{' || ch == '-' || ch == ' ')

	movsx	eax, BYTE PTR _ch$217886[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN2@SkipGUIDSe
	movsx	ecx, BYTE PTR _ch$217886[ebp]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN2@SkipGUIDSe
	movsx	edx, BYTE PTR _ch$217886[ebp]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN3@SkipGUIDSe
$LN2@SkipGUIDSe:

; 1448 : 				++uiStartIndex;

	mov	eax, DWORD PTR _uiStartIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _uiStartIndex$[ebp], eax

; 1449 : 			else

	jmp	SHORT $LN5@SkipGUIDSe
$LN3@SkipGUIDSe:

; 1450 : 				break;

	jmp	SHORT $LN7@SkipGUIDSe
$LN5@SkipGUIDSe:

; 1451 : 
; 1452 : 		}
; 1453 : 		while(uiStartIndex < uiLength);

	mov	ecx, DWORD PTR _uiStartIndex$[ebp]
	cmp	ecx, DWORD PTR _uiLength$[ebp]
	jb	SHORT $LN6@SkipGUIDSe
$LN7@SkipGUIDSe:

; 1454 : 	}
; 1455 : 	return uiStartIndex;

	mov	eax, DWORD PTR _uiStartIndex$[ebp]

; 1456 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SkipGUIDSeparators@@YAIPBDI@Z ENDP			; SkipGUIDSeparators
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetHexDigitValue@@YA_NDAAI@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
_uiValue$ = 12						; size = 4
?GetHexDigitValue@@YA_NDAAI@Z PROC			; GetHexDigitValue, COMDAT

; 1460 : {

	push	ebp
	mov	ebp, esp

; 1461 : 	if(ch >= '0' && ch <= '9')

	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 48					; 00000030H
	jl	SHORT $LN6@GetHexDigi
	movsx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $LN6@GetHexDigi

; 1462 : 		uiValue = (uint)(ch - '0');

	movsx	edx, BYTE PTR _ch$[ebp]
	sub	edx, 48					; 00000030H
	mov	eax, DWORD PTR _uiValue$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN5@GetHexDigi
$LN6@GetHexDigi:

; 1463 : 	else if(ch >= 'a' && ch <= 'f')

	movsx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 97					; 00000061H
	jl	SHORT $LN4@GetHexDigi
	movsx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 102				; 00000066H
	jg	SHORT $LN4@GetHexDigi

; 1464 : 		uiValue = (uint)((ch - 'a') + 10);

	movsx	eax, BYTE PTR _ch$[ebp]
	sub	eax, 87					; 00000057H
	mov	ecx, DWORD PTR _uiValue$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN5@GetHexDigi
$LN4@GetHexDigi:

; 1465 : 	else if(ch >= 'A' && ch <= 'F')

	movsx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN2@GetHexDigi
	movsx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 70					; 00000046H
	jg	SHORT $LN2@GetHexDigi

; 1466 : 		uiValue = (uint)((ch - 'A') + 10);

	movsx	ecx, BYTE PTR _ch$[ebp]
	sub	ecx, 55					; 00000037H
	mov	edx, DWORD PTR _uiValue$[ebp]
	mov	DWORD PTR [edx], ecx

; 1467 : 	else

	jmp	SHORT $LN5@GetHexDigi
$LN2@GetHexDigi:

; 1468 : 		return false;

	xor	al, al
	jmp	SHORT $LN7@GetHexDigi
$LN5@GetHexDigi:

; 1469 : 
; 1470 : 	return true;

	mov	al, 1
$LN7@GetHexDigi:

; 1471 : }

	pop	ebp
	ret	0
?GetHexDigitValue@@YA_NDAAI@Z ENDP			; GetHexDigitValue
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv134 = -21						; size = 1
tv131 = -20						; size = 4
tv128 = -16						; size = 4
_uiValue$217978 = -12					; size = 4
_uiDigitCount$217973 = -8				; size = 4
_uiLength$ = -4						; size = 4
_pszGUID$ = 8						; size = 4
_puiIndex$ = 12						; size = 4
_kDest$ = 16						; size = 4
??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z PROC		; GetGUIDSegment<unsigned short>, COMDAT

; 1475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1476 : 	*puiIndex = SkipGUIDSeparators(pszGUID, *puiIndex);

	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pszGUID$[ebp]
	push	edx
	call	?SkipGUIDSeparators@@YAIPBDI@Z		; SkipGUIDSeparators
	add	esp, 8
	mov	ecx, DWORD PTR _puiIndex$[ebp]
	mov	DWORD PTR [ecx], eax

; 1477 : 
; 1478 : 	kDest = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _kDest$[ebp]
	mov	WORD PTR [eax], dx

; 1479 : 	UINT uiLength = strlen(pszGUID);

	mov	ecx, DWORD PTR _pszGUID$[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	mov	edx, DWORD PTR tv128[ebp]
	add	edx, 1
	mov	DWORD PTR tv131[ebp], edx
$LL11@GetGUIDSeg@2:
	mov	eax, DWORD PTR tv128[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv134[ebp], cl
	add	DWORD PTR tv128[ebp], 1
	cmp	BYTE PTR tv134[ebp], 0
	jne	SHORT $LL11@GetGUIDSeg@2
	mov	edx, DWORD PTR tv128[ebp]
	sub	edx, DWORD PTR tv131[ebp]
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _uiLength$[ebp], eax

; 1480 : 	if(*puiIndex < uiLength)

	mov	ecx, DWORD PTR _puiIndex$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _uiLength$[ebp]
	jae	SHORT $LN8@GetGUIDSeg@2

; 1481 : 	{
; 1482 : 		UINT uiDigitCount = sizeof(T) * 2;

	mov	DWORD PTR _uiDigitCount$217973[ebp], 4
$LN7@GetGUIDSeg@2:

; 1483 : 		do
; 1484 : 		{
; 1485 : 			UINT uiValue = 0;

	mov	DWORD PTR _uiValue$217978[ebp], 0

; 1486 : 			if(GetHexDigitValue(pszGUID[*puiIndex], uiValue))

	lea	eax, DWORD PTR _uiValue$217978[ebp]
	push	eax
	mov	ecx, DWORD PTR _puiIndex$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pszGUID$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	call	?GetHexDigitValue@@YA_NDAAI@Z		; GetHexDigitValue
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@GetGUIDSeg@2

; 1487 : #ifdef AUI_WARNING_FIXES
; 1488 : 				kDest = T((kDest * 16) + uiValue);
; 1489 : #else
; 1490 : 				kDest = (kDest * 16) + uiValue;

	mov	eax, DWORD PTR _kDest$[ebp]
	movzx	ecx, WORD PTR [eax]
	shl	ecx, 4
	add	ecx, DWORD PTR _uiValue$217978[ebp]
	mov	edx, DWORD PTR _kDest$[ebp]
	mov	WORD PTR [edx], cx

; 1491 : #endif
; 1492 : 			else

	jmp	SHORT $LN3@GetGUIDSeg@2
$LN4@GetGUIDSeg@2:

; 1493 : 				return false;

	xor	al, al
	jmp	SHORT $LN9@GetGUIDSeg@2
$LN3@GetGUIDSeg@2:

; 1494 : 			*puiIndex += 1;

	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _puiIndex$[ebp]
	mov	DWORD PTR [edx], ecx

; 1495 : 		}
; 1496 : 		while(*puiIndex < uiLength  && --uiDigitCount);

	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _uiLength$[ebp]
	jae	SHORT $LN5@GetGUIDSeg@2
	mov	edx, DWORD PTR _uiDigitCount$217973[ebp]
	sub	edx, 1
	mov	DWORD PTR _uiDigitCount$217973[ebp], edx
	jne	SHORT $LN7@GetGUIDSeg@2
$LN5@GetGUIDSeg@2:

; 1497 : 
; 1498 : 		return true;

	mov	al, 1
	jmp	SHORT $LN9@GetGUIDSeg@2

; 1499 : 	}
; 1500 : 	else

	jmp	SHORT $LN9@GetGUIDSeg@2
$LN8@GetGUIDSeg@2:

; 1501 : 		return false;

	xor	al, al
$LN9@GetGUIDSeg@2:

; 1502 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$GetGUIDSegment@G@@YA_NPBDPAIAAG@Z ENDP		; GetGUIDSegment<unsigned short>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv132 = -21						; size = 1
tv129 = -20						; size = 4
tv94 = -16						; size = 4
_uiValue$217991 = -12					; size = 4
_uiDigitCount$217986 = -8				; size = 4
_uiLength$ = -4						; size = 4
_pszGUID$ = 8						; size = 4
_puiIndex$ = 12						; size = 4
_kDest$ = 16						; size = 4
??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z PROC		; GetGUIDSegment<unsigned char>, COMDAT

; 1475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1476 : 	*puiIndex = SkipGUIDSeparators(pszGUID, *puiIndex);

	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pszGUID$[ebp]
	push	edx
	call	?SkipGUIDSeparators@@YAIPBDI@Z		; SkipGUIDSeparators
	add	esp, 8
	mov	ecx, DWORD PTR _puiIndex$[ebp]
	mov	DWORD PTR [ecx], eax

; 1477 : 
; 1478 : 	kDest = 0;

	mov	edx, DWORD PTR _kDest$[ebp]
	mov	BYTE PTR [edx], 0

; 1479 : 	UINT uiLength = strlen(pszGUID);

	mov	eax, DWORD PTR _pszGUID$[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR tv94[ebp]
	add	ecx, 1
	mov	DWORD PTR tv129[ebp], ecx
$LL11@GetGUIDSeg@3:
	mov	edx, DWORD PTR tv94[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv132[ebp], al
	add	DWORD PTR tv94[ebp], 1
	cmp	BYTE PTR tv132[ebp], 0
	jne	SHORT $LL11@GetGUIDSeg@3
	mov	ecx, DWORD PTR tv94[ebp]
	sub	ecx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv69[ebp], ecx
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR _uiLength$[ebp], edx

; 1480 : 	if(*puiIndex < uiLength)

	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _uiLength$[ebp]
	jae	SHORT $LN8@GetGUIDSeg@3

; 1481 : 	{
; 1482 : 		UINT uiDigitCount = sizeof(T) * 2;

	mov	DWORD PTR _uiDigitCount$217986[ebp], 2
$LN7@GetGUIDSeg@3:

; 1483 : 		do
; 1484 : 		{
; 1485 : 			UINT uiValue = 0;

	mov	DWORD PTR _uiValue$217991[ebp], 0

; 1486 : 			if(GetHexDigitValue(pszGUID[*puiIndex], uiValue))

	lea	edx, DWORD PTR _uiValue$217991[ebp]
	push	edx
	mov	eax, DWORD PTR _puiIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pszGUID$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	?GetHexDigitValue@@YA_NDAAI@Z		; GetHexDigitValue
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@GetGUIDSeg@3

; 1487 : #ifdef AUI_WARNING_FIXES
; 1488 : 				kDest = T((kDest * 16) + uiValue);
; 1489 : #else
; 1490 : 				kDest = (kDest * 16) + uiValue;

	mov	edx, DWORD PTR _kDest$[ebp]
	movzx	eax, BYTE PTR [edx]
	shl	eax, 4
	add	eax, DWORD PTR _uiValue$217991[ebp]
	mov	ecx, DWORD PTR _kDest$[ebp]
	mov	BYTE PTR [ecx], al

; 1491 : #endif
; 1492 : 			else

	jmp	SHORT $LN3@GetGUIDSeg@3
$LN4@GetGUIDSeg@3:

; 1493 : 				return false;

	xor	al, al
	jmp	SHORT $LN9@GetGUIDSeg@3
$LN3@GetGUIDSeg@3:

; 1494 : 			*puiIndex += 1;

	mov	edx, DWORD PTR _puiIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _puiIndex$[ebp]
	mov	DWORD PTR [ecx], eax

; 1495 : 		}
; 1496 : 		while(*puiIndex < uiLength  && --uiDigitCount);

	mov	edx, DWORD PTR _puiIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _uiLength$[ebp]
	jae	SHORT $LN5@GetGUIDSeg@3
	mov	ecx, DWORD PTR _uiDigitCount$217986[ebp]
	sub	ecx, 1
	mov	DWORD PTR _uiDigitCount$217986[ebp], ecx
	jne	SHORT $LN7@GetGUIDSeg@3
$LN5@GetGUIDSeg@3:

; 1497 : 
; 1498 : 		return true;

	mov	al, 1
	jmp	SHORT $LN9@GetGUIDSeg@3

; 1499 : 	}
; 1500 : 	else

	jmp	SHORT $LN9@GetGUIDSeg@3
$LN8@GetGUIDSeg@3:

; 1501 : 		return false;

	xor	al, al
$LN9@GetGUIDSeg@3:

; 1502 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$GetGUIDSegment@E@@YA_NPBDPAIAAE@Z ENDP		; GetGUIDSegment<unsigned char>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $LN2@operator
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@operator
$LN2@operator:
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?format@CvString@@SA?AV1@PBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0
__ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?format@CvString@@SA?AV1@PBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?format@CvString@@SA?AV1@PBDZZ
_TEXT	SEGMENT
$T220107 = -52						; size = 4
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_fmt$ = 12						; size = 4
?format@CvString@@SA?AV1@PBDZZ PROC			; CvString::format, COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?format@CvString@@SA?AV1@PBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2128				; 00000850H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T220107[ebp], 0

; 244  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 245  : 	va_list args;
; 246  : 	va_start(args,fmt);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 247  : 	formatv(result,fmt,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 248  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 249  : 	return CvString(result);

	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T220107[ebp]
	or	edx, 1
	mov	DWORD PTR $T220107[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1:
	mov	eax, DWORD PTR $T220107[ebp]
	and	eax, 1
	je	$LN5@format
	and	DWORD PTR $T220107[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@format:
	ret	0
__ehhandler$?format@CvString@@SA?AV1@PBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?format@CvString@@SA?AV1@PBDZZ ENDP			; CvString::format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T220133 = -2092					; size = 4
$T220132 = -2088					; size = 4
$T220131 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220131[ebp], eax
	mov	ecx, DWORD PTR $T220131[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T220132[ebp], eax
	mov	eax, DWORD PTR $T220132[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T220133[ebp], eax
	mov	ecx, DWORD PTR $T220133[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T220150 = -8						; size = 4
$T220146 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T220146[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T220146[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T220150[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T220150[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
END
