; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTechAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ		; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
PUBLIC	??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z		; CvTechAI::CvTechAI
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z$0
__ehfuncinfo$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T221413 = -36						; size = 4
$T221396 = -24						; size = 4
__$EHRec$ = -12						; size = 12
_currentTechs$ = 8					; size = 4
??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z PROC		; CvTechAI::CvTechAI, COMDAT
; _this$ = ecx

; 19   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currentTechs$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T221396[ebp], edx
	mov	ecx, DWORD PTR $T221396[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 660				; 00000294H
	mov	DWORD PTR $T221413[ebp], eax
	mov	ecx, DWORD PTR $T221413[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>

; 20   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ	; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
__ehhandler$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z ENDP		; CvTechAI::CvTechAI
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
PUBLIC	??1CvTechAI@@QAE@XZ				; CvTechAI::~CvTechAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvTechAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTechAI@@QAE@XZ$0
__ehfuncinfo$??1CvTechAI@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTechAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ??1CvTechAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T221492 = -44						; size = 4
$T221460 = -28						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTechAI@@QAE@XZ PROC				; CvTechAI::~CvTechAI, COMDAT
; _this$ = ecx

; 24   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvTechAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 25   : }

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 660				; 00000294H
	mov	DWORD PTR $T221460[ebp], eax
	mov	ecx, DWORD PTR $T221460[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T221492[ebp], ecx
	mov	ecx, DWORD PTR $T221492[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTechAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ	; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
__ehhandler$??1CvTechAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvTechAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTechAI@@QAE@XZ ENDP				; CvTechAI::~CvTechAI
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back
PUBLIC	?Reset@CvTechAI@@QAEXXZ				; CvTechAI::Reset
EXTRN	?GetNumTechs@CvTechXMLEntries@@QAEHXZ:PROC	; CvTechXMLEntries::GetNumTechs
EXTRN	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ:PROC ; CvPlayerTechs::GetTechs
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvTechAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
_weightedElem$221569 = -20				; size = 8
$T221531 = -12						; size = 4
_i$221526 = -8						; size = 4
_i$217558 = -4						; size = 4
?Reset@CvTechAI@@QAEXXZ PROC				; CvTechAI::Reset, COMDAT
; _this$ = ecx

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 30   : 	CvAssertMsg(m_pCurrentTechs != NULL, "Tech AI init failure: player tech data is NULL");
; 31   : 	if(m_pCurrentTechs != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN5@Reset

; 32   : 	{
; 33   : 		CvAssertMsg(m_pCurrentTechs->GetTechs() != NULL, "Tech AI init failure: no tech data");
; 34   : 
; 35   : 		m_TechAIWeights.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T221531[ebp], ecx
	xor	edx, edx
	je	SHORT $LN15@Reset
	mov	DWORD PTR _i$221526[ebp], 0
	jmp	SHORT $LN13@Reset
$LN12@Reset:
	mov	eax, DWORD PTR _i$221526[ebp]
	add	eax, 1
	mov	DWORD PTR _i$221526[ebp], eax
$LN13@Reset:
	mov	ecx, DWORD PTR $T221531[ebp]
	mov	edx, DWORD PTR _i$221526[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN15@Reset
	jmp	SHORT $LN12@Reset
$LN15@Reset:
	mov	eax, DWORD PTR $T221531[ebp]
	mov	DWORD PTR [eax+4], 0

; 36   : 
; 37   : 		// Loop through reading each one and add an entry with 0 weight to our vector
; 38   : #ifdef AUI_WARNING_FIXES
; 39   : 		for (uint i = 0; i < m_pCurrentTechs->GetTechs()->GetNumTechs(); i++)
; 40   : #else
; 41   : 		for(int i = 0; i < m_pCurrentTechs->GetTechs()->GetNumTechs(); i++)

	mov	DWORD PTR _i$217558[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	ecx, DWORD PTR _i$217558[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$217558[ebp], ecx
$LN3@Reset:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _i$217558[ebp], eax
	jge	SHORT $LN5@Reset

; 42   : #endif
; 43   : 		{
; 44   : 			m_TechAIWeights.push_back(i, 0);

	mov	DWORD PTR _weightedElem$221569[ebp], 0
	mov	DWORD PTR _weightedElem$221569[ebp+4], 0
	mov	eax, DWORD PTR _i$217558[ebp]
	mov	DWORD PTR _weightedElem$221569[ebp], eax
	mov	DWORD PTR _weightedElem$221569[ebp+4], 0
	lea	ecx, DWORD PTR _weightedElem$221569[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back

; 45   : 		}

	jmp	SHORT $LN2@Reset
$LN5@Reset:

; 46   : 	}
; 47   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvTechAI@@QAEXXZ ENDP				; CvTechAI::Reset
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
PUBLIC	?Read@CvTechAI@@QAEXAAVFDataStream@@@Z		; CvTechAI::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvTechAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T221642 = -44						; size = 4
$T221619 = -40						; size = 4
$T221608 = -36						; size = 4
_i$221603 = -32						; size = 4
_iIndex$217579 = -28					; size = 4
_i$217575 = -24						; size = 4
_i$217570 = -20						; size = 4
_iCount$ = -16						; size = 4
_uiVersion$ = -12					; size = 4
_iWeight$ = -8						; size = 4
_iTechCount$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvTechAI@@QAEXAAVFDataStream@@@Z PROC		; CvTechAI::Read, COMDAT
; _this$ = ecx

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 	// Version number to maintain backwards compatibility
; 54   : 	uint uiVersion;
; 55   : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 56   : 
; 57   : 	int iWeight;
; 58   : 
; 59   : 	CvAssertMsg(m_pCurrentTechs->GetTechs() != NULL, "Tech AI serialization failure: no tech data");
; 60   : 	CvAssertMsg(m_pCurrentTechs->GetTechs()->GetNumTechs() > 0, "Tech AI serialization failure: number of techs not greater than 0");
; 61   : 
; 62   : 	// Reset vector
; 63   : 	m_TechAIWeights.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T221608[ebp], ecx
	xor	edx, edx
	je	SHORT $LN20@Read
	mov	DWORD PTR _i$221603[ebp], 0
	jmp	SHORT $LN18@Read
$LN17@Read:
	mov	eax, DWORD PTR _i$221603[ebp]
	add	eax, 1
	mov	DWORD PTR _i$221603[ebp], eax
$LN18@Read:
	mov	ecx, DWORD PTR $T221608[ebp]
	mov	edx, DWORD PTR _i$221603[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN20@Read
	jmp	SHORT $LN17@Read
$LN20@Read:
	mov	eax, DWORD PTR $T221608[ebp]
	mov	DWORD PTR [eax+4], 0

; 64   : 	int iTechCount = m_pCurrentTechs->GetTechs()->GetNumTechs();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	DWORD PTR _iTechCount$[ebp], eax

; 65   : 	m_TechAIWeights.resize(iTechCount);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR $T221619[ebp], edx
	mov	eax, DWORD PTR $T221619[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _iTechCount$[ebp]
	jae	SHORT $LN24@Read
	mov	edx, DWORD PTR _iTechCount$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T221619[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
$LN24@Read:
	mov	eax, DWORD PTR $T221619[ebp]
	mov	ecx, DWORD PTR _iTechCount$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 66   : 	for(int i = 0; i < iTechCount; ++i)

	mov	DWORD PTR _i$217570[ebp], 0
	jmp	SHORT $LN7@Read
$LN6@Read:
	mov	edx, DWORD PTR _i$217570[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217570[ebp], edx
$LN7@Read:
	mov	eax, DWORD PTR _i$217570[ebp]
	cmp	eax, DWORD PTR _iTechCount$[ebp]
	jge	SHORT $LN5@Read

; 67   : 		m_TechAIWeights.SetWeight(i, 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$217570[ebp]
	mov	DWORD PTR [edx+eax*8+4], 0
	jmp	SHORT $LN6@Read
$LN5@Read:

; 68   : 
; 69   : 	int iCount;
; 70   : 	kStream >> iCount;

	lea	ecx, DWORD PTR _iCount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 71   : 
; 72   : 	for(int i = 0; i < iCount; i++)

	mov	DWORD PTR _i$217575[ebp], 0
	jmp	SHORT $LN4@Read
$LN3@Read:
	mov	edx, DWORD PTR _i$217575[ebp]
	add	edx, 1
	mov	DWORD PTR _i$217575[ebp], edx
$LN4@Read:
	mov	eax, DWORD PTR _i$217575[ebp]
	cmp	eax, DWORD PTR _iCount$[ebp]
	jge	SHORT $LN8@Read

; 73   : 	{
; 74   : 		int iIndex = CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iIndex$217579[ebp], eax

; 75   : 		kStream >> iWeight;

	lea	edx, DWORD PTR _iWeight$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 76   : 		if(iIndex >= 0 && iIndex < iCount)

	cmp	DWORD PTR _iIndex$217579[ebp], 0
	jl	SHORT $LN1@Read
	mov	eax, DWORD PTR _iIndex$217579[ebp]
	cmp	eax, DWORD PTR _iCount$[ebp]
	jge	SHORT $LN1@Read

; 77   : 			m_TechAIWeights.SetWeight(iIndex, iWeight);

	mov	ecx, DWORD PTR _iWeight$[ebp]
	mov	DWORD PTR $T221642[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iIndex$217579[ebp]
	mov	edx, DWORD PTR $T221642[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx
$LN1@Read:
	jmp	SHORT $LN3@Read
$LN8@Read:

; 78   : 	}
; 79   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvTechAI@@QAEXAAVFDataStream@@@Z ENDP		; CvTechAI::Read
_TEXT	ENDS
PUBLIC	?Write@CvTechAI@@QBEXAAVFDataStream@@@Z		; CvTechAI::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvTechAI@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_elem$221660 = -24					; size = 8
$T221645 = -16						; size = 4
_i$217587 = -12						; size = 4
_uiCount$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvTechAI@@QBEXAAVFDataStream@@@Z PROC		; CvTechAI::Write, COMDAT
; _this$ = ecx

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 	// Current version number
; 85   : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 86   : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 87   : 
; 88   : 	CvAssertMsg(m_pCurrentTechs->GetTechs() != NULL, "Tech AI serialization failure: no tech data");
; 89   : 	CvAssertMsg(m_pCurrentTechs->GetTechs()->GetNumTechs() > 0, "Tech AI serialization failure: number of techs not greater than 0");
; 90   : 
; 91   : 	uint uiCount = m_pCurrentTechs->GetTechs()->GetNumTechs();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	mov	DWORD PTR _uiCount$[ebp], eax

; 92   : 	kStream << uiCount;

	lea	edx, DWORD PTR _uiCount$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 93   : 
; 94   : 	// Loop through writing each entry
; 95   : 	for(uint i = 0; i < uiCount; i++)

	mov	DWORD PTR _i$217587[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	eax, DWORD PTR _i$217587[ebp]
	add	eax, 1
	mov	DWORD PTR _i$217587[ebp], eax
$LN3@Write:
	mov	ecx, DWORD PTR _i$217587[ebp]
	cmp	ecx, DWORD PTR _uiCount$[ebp]
	jae	SHORT $LN4@Write

; 96   : 	{
; 97   : 		CvInfosSerializationHelper::WriteHashed(kStream, (TechTypes)i);	// Write out the hash ID first

	mov	edx, DWORD PTR _i$217587[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 98   : 		kStream << m_TechAIWeights.GetWeight(i);

	mov	DWORD PTR _elem$221660[ebp], 0
	mov	DWORD PTR _elem$221660[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$217587[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$221660[ebp], ecx
	mov	DWORD PTR _elem$221660[ebp+4], edx
	mov	eax, DWORD PTR _elem$221660[ebp+4]
	mov	DWORD PTR $T221645[ebp], eax
	lea	ecx, DWORD PTR $T221645[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 99   : 	}

	jmp	SHORT $LN2@Write
$LN4@Write:

; 100  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvTechAI@@QBEXAAVFDataStream@@@Z ENDP		; CvTechAI::Write
_TEXT	ENDS
PUBLIC	?WeightPrereqs@CvTechAI@@AAEXPAHH@Z		; CvTechAI::WeightPrereqs
PUBLIC	__$ArrayPad$
PUBLIC	?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z ; CvTechAI::AddFlavorWeights
EXTRN	?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z:PROC ; CvPlayerTechs::GetLocaleTechPriority
EXTRN	?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z:PROC ; CvPlayerTechs::GetCivTechPriority
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ:PROC ; CvPlayerTechs::GetPlayer
EXTRN	?GetFlavorValue@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetFlavorValue
EXTRN	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z:PROC ; CvTechXMLEntries::GetEntry
EXTRN	__alloca_probe_16:PROC
; Function compile flags: /Odtp
;	COMDAT ?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z
_TEXT	SEGMENT
tv175 = -44						; size = 4
tv71 = -40						; size = 4
_this$ = -36						; size = 4
$T221680 = -32						; size = 4
__$ArrayPad$ = -28					; size = 4
_entry$217614 = -24					; size = 4
_iTech$217610 = -20					; size = 4
_entry$217608 = -16					; size = 4
_eTech$217606 = -12					; size = 4
_iTech$217602 = -8					; size = 4
_paiTempWeights$ = -4					; size = 4
_eFlavor$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z PROC ; CvTechAI::AddFlavorWeights, COMDAT
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 105  : #ifdef AUI_WARNING_FIXES
; 106  : 	FFastVector<int, true> paiTempWeights;
; 107  : 	paiTempWeights.reserve(m_pCurrentTechs->GetTechs()->GetNumTechs());
; 108  : #else
; 109  : 	int* paiTempWeights;
; 110  : 
; 111  : 	// Create a temporary array of weights
; 112  : 	paiTempWeights = (int*)_alloca(sizeof(int) * m_pCurrentTechs->GetTechs()->GetNumTechs());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	shl	eax, 2
	call	__alloca_probe_16
	mov	DWORD PTR tv71[ebp], esp
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _paiTempWeights$[ebp], ecx

; 113  : #endif
; 114  : 
; 115  : 	// Loop through all our techs
; 116  : #ifdef AUI_WARNING_FIXES
; 117  : 	for (uint iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)
; 118  : #else
; 119  : 	for(int iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)

	mov	DWORD PTR _iTech$217602[ebp], 0
	jmp	SHORT $LN8@AddFlavorW
$LN7@AddFlavorW:
	mov	edx, DWORD PTR _iTech$217602[ebp]
	add	edx, 1
	mov	DWORD PTR _iTech$217602[ebp], edx
$LN8@AddFlavorW:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTech$217602[ebp], eax
	jge	$LN6@AddFlavorW

; 120  : #endif
; 121  : 	{
; 122  : 		const TechTypes eTech = static_cast<TechTypes>(iTech);

	mov	ecx, DWORD PTR _iTech$217602[ebp]
	mov	DWORD PTR _eTech$217606[ebp], ecx

; 123  : 		CvTechEntry* entry = m_pCurrentTechs->GetTechs()->GetEntry(iTech);

	mov	edx, DWORD PTR _iTech$217602[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
	mov	DWORD PTR _entry$217608[ebp], eax

; 124  : 		if (entry)

	cmp	DWORD PTR _entry$217608[ebp], 0
	je	SHORT $LN5@AddFlavorW

; 125  : 		{
; 126  : #ifdef AUI_WARNING_FIXES
; 127  : 			// Set its weight by looking at tech's weight for this flavor and using iWeight multiplier passed in
; 128  : 			int iLoopWeight = entry->GetFlavorValue(eFlavor) * iWeight;
; 129  : 
; 130  : 			// Multiply the weight by any special player-specific weighting (i.e. to prioritize civ unique bonuses)
; 131  : 			iLoopWeight *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetCivTechPriority(eTech);
; 132  : 
; 133  : 			// Multiply the weight by any locale-specific weighting (i.e. to prioritize unlocking resources)
; 134  : 			iLoopWeight *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetLocaleTechPriority(eTech);
; 135  : 
; 136  : 			paiTempWeights.push_back(iLoopWeight);
; 137  : 		}
; 138  : 		else
; 139  : 			paiTempWeights.push_back(0);
; 140  : #else
; 141  : 			// Set its weight by looking at tech's weight for this flavor and using iWeight multiplier passed in
; 142  : 			paiTempWeights[iTech] = entry->GetFlavorValue(eFlavor) * iWeight;

	mov	ecx, DWORD PTR _eFlavor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _entry$217608[ebp]
	call	?GetFlavorValue@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetFlavorValue
	imul	eax, DWORD PTR _iWeight$[ebp]
	mov	edx, DWORD PTR _iTech$217602[ebp]
	mov	ecx, DWORD PTR _paiTempWeights$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 143  : 
; 144  : 			// Multiply the weight by any special player-specific weighting (i.e. to prioritize civ unique bonuses)
; 145  : 			paiTempWeights[iTech] *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetCivTechPriority(eTech);

	mov	edx, DWORD PTR _eTech$217606[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetCivTechPriority
	mov	ecx, DWORD PTR _iTech$217602[ebp]
	mov	edx, DWORD PTR _paiTempWeights$[ebp]
	imul	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _iTech$217602[ebp]
	mov	edx, DWORD PTR _paiTempWeights$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 146  : 
; 147  : 			// Multiply the weight by any locale-specific weighting (i.e. to prioritize unlocking resources)
; 148  : 			paiTempWeights[iTech] *= m_pCurrentTechs->GetPlayer()->GetPlayerTechs()->GetLocaleTechPriority(eTech);

	mov	eax, DWORD PTR _eTech$217606[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetLocaleTechPriority
	mov	edx, DWORD PTR _iTech$217602[ebp]
	mov	ecx, DWORD PTR _paiTempWeights$[ebp]
	imul	eax, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _iTech$217602[ebp]
	mov	ecx, DWORD PTR _paiTempWeights$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN5@AddFlavorW:

; 149  : 		}
; 150  : #endif
; 151  : 	}

	jmp	$LN7@AddFlavorW
$LN6@AddFlavorW:

; 152  : 
; 153  : 	// Propagate these values left in the tree so prereqs get bought
; 154  : 	WeightPrereqs(paiTempWeights, iPropagationPercent);

	mov	edx, DWORD PTR _iPropagationPercent$[ebp]
	push	edx
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WeightPrereqs@CvTechAI@@AAEXPAHH@Z	; CvTechAI::WeightPrereqs

; 155  : 
; 156  : 	// Add these weights over previous ones
; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 	for (uint iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)
; 159  : #else
; 160  : 	for(int iTech = 0; iTech < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTech++)

	mov	DWORD PTR _iTech$217610[ebp], 0
	jmp	SHORT $LN4@AddFlavorW
$LN3@AddFlavorW:
	mov	ecx, DWORD PTR _iTech$217610[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTech$217610[ebp], ecx
$LN4@AddFlavorW:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTech$217610[ebp], eax
	jge	SHORT $LN9@AddFlavorW

; 161  : #endif
; 162  : 	{
; 163  : 		CvTechEntry* entry = m_pCurrentTechs->GetTechs()->GetEntry(iTech);

	mov	eax, DWORD PTR _iTech$217610[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
	mov	DWORD PTR _entry$217614[ebp], eax

; 164  : 		if(entry)

	cmp	DWORD PTR _entry$217614[ebp], 0
	je	SHORT $LN1@AddFlavorW

; 165  : 		{
; 166  : 			m_TechAIWeights.IncreaseWeight(iTech, paiTempWeights[iTech]);

	mov	edx, DWORD PTR _iTech$217610[ebp]
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T221680[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iTech$217610[ebp]
	lea	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR tv175[ebp], edx
	mov	eax, DWORD PTR tv175[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR $T221680[ebp]
	mov	edx, DWORD PTR tv175[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@AddFlavorW:

; 167  : 		}

	jmp	SHORT $LN3@AddFlavorW
$LN9@AddFlavorW:

; 168  : 	}
; 169  : }

	lea	esp, DWORD PTR [ebp-44]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z ENDP ; CvTechAI::AddFlavorWeights
_TEXT	ENDS
PUBLIC	?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ; CvTechAI::LogResearchChoice
PUBLIC	?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,80,1>::ChooseFromTopChoices
PUBLIC	??_C@_0BP@CFJNLAOG@Choosing?5tech?5from?5Top?5Choices?$AA@ ; `string'
PUBLIC	?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ ; CvWeightedVector<int,80,1>::GetTotalWeight
PUBLIC	?LogPossibleResearch@CvTechAI@@AAEXXZ		; CvTechAI::LogPossibleResearch
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
PUBLIC	?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z	; CvTechAI::ReweightByCost
PUBLIC	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
PUBLIC	?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ; CvTechAI::ChooseNextTech
EXTRN	?GetTechNumOptions@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::GetTechNumOptions
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z:PROC ; CvPlayerTechs::CanResearchForFree
EXTRN	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::CanResearch
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
;	COMDAT ??_C@_0BP@CFJNLAOG@Choosing?5tech?5from?5Top?5Choices?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0BP@CFJNLAOG@Choosing?5tech?5from?5Top?5Choices?$AA@ DB 'Choosing t'
	DB	'ech from Top Choices', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
CONST	ENDS
;	COMDAT ?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
_this$ = -172						; size = 4
$T221849 = -132						; size = 4
$T221833 = -104						; size = 4
$T221821 = -100						; size = 4
$T221817 = -96						; size = 4
$T221812 = -92						; size = 4
_weightedElem$221808 = -88				; size = 8
$T221802 = -80						; size = 4
_elem$221796 = -76					; size = 8
$T221787 = -68						; size = 4
_weightedElem$221783 = -64				; size = 8
$T221777 = -56						; size = 4
_elem$221771 = -52					; size = 8
$T221762 = -44						; size = 4
_i$221757 = -40						; size = 4
$T221731 = -36						; size = 4
$T221715 = -32						; size = 4
$T221684 = -28						; size = 8
_iNumChoices$217787 = -20				; size = 4
_fcn$ = -16						; size = 8
_rtnValue$ = -8						; size = 4
_iTechLoop$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_bFreeTech$ = 12					; size = 1
?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z PROC ; CvTechAI::ChooseNextTech, COMDAT
; _this$ = ecx

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 	RandomNumberDelegate fcn;

	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0
	mov	DWORD PTR _fcn$[ebp], 0
	mov	DWORD PTR _fcn$[ebp+4], 0

; 176  : 	TechTypes rtnValue = NO_TECH;

	mov	DWORD PTR _rtnValue$[ebp], -1

; 177  : #ifdef AUI_WARNING_FIXES
; 178  : 	uint iTechLoop;
; 179  : #else
; 180  : 	int iTechLoop;
; 181  : #endif
; 182  : 
; 183  : 	// Use the synchronous random number generate
; 184  : 	// Asynchronous one would be:
; 185  : 	//	fcn = MakeDelegate (&GC.getGame(), &CvGame::getAsyncRandNum);
; 186  : 	fcn = MakeDelegate(&GC.getGame(), &CvGame::getJonRandNum);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T221715[ebp], eax
	push	OFFSET ?getJonRandNum@CvGame@@QAEHHPBD@Z ; CvGame::getJonRandNum
	mov	ecx, DWORD PTR $T221715[ebp]
	push	ecx
	lea	edx, DWORD PTR $T221684[ebp]
	push	edx
	call	??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T221731[ebp], eax
	mov	eax, DWORD PTR $T221731[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _fcn$[ebp+4], ecx
	mov	edx, DWORD PTR $T221731[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _fcn$[ebp], eax

; 187  : 
; 188  : 	// Create a new vector holding only techs we can currently research
; 189  : 	m_ResearchableTechs.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	mov	DWORD PTR $T221762[ebp], ecx
	xor	edx, edx
	je	SHORT $LN38@ChooseNext
	mov	DWORD PTR _i$221757[ebp], 0
	jmp	SHORT $LN36@ChooseNext
$LN35@ChooseNext:
	mov	eax, DWORD PTR _i$221757[ebp]
	add	eax, 1
	mov	DWORD PTR _i$221757[ebp], eax
$LN36@ChooseNext:
	mov	ecx, DWORD PTR $T221762[ebp]
	mov	edx, DWORD PTR _i$221757[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN38@ChooseNext
	jmp	SHORT $LN35@ChooseNext
$LN38@ChooseNext:
	mov	eax, DWORD PTR $T221762[ebp]
	mov	DWORD PTR [eax+4], 0

; 190  : 
; 191  : 	// Loop through adding the researchable techs
; 192  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$[ebp], 0
	jmp	SHORT $LN9@ChooseNext
$LN8@ChooseNext:
	mov	ecx, DWORD PTR _iTechLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iTechLoop$[ebp], ecx
$LN9@ChooseNext:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTechLoop$[ebp], eax
	jge	$LN7@ChooseNext

; 193  : 	{
; 194  : 		if(m_pCurrentTechs->CanResearch((TechTypes)iTechLoop))

	push	0
	mov	eax, DWORD PTR _iTechLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	movzx	edx, al
	test	edx, edx
	je	$LN6@ChooseNext

; 195  : 		{
; 196  : 			// For free techs, need an additional check
; 197  : 			if(bFreeTech)

	movzx	eax, BYTE PTR _bFreeTech$[ebp]
	test	eax, eax
	je	SHORT $LN5@ChooseNext

; 198  : 			{
; 199  : 				if(m_pCurrentTechs->CanResearchForFree((TechTypes)iTechLoop))

	mov	ecx, DWORD PTR _iTechLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanResearchForFree
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@ChooseNext

; 200  : 				{
; 201  : 					m_ResearchableTechs.push_back(iTechLoop, m_TechAIWeights.GetWeight(iTechLoop));

	mov	ecx, DWORD PTR _iTechLoop$[ebp]
	mov	DWORD PTR $T221777[ebp], ecx
	mov	DWORD PTR _elem$221771[ebp], 0
	mov	DWORD PTR _elem$221771[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR $T221777[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$221771[ebp], edx
	mov	DWORD PTR _elem$221771[ebp+4], eax
	mov	ecx, DWORD PTR _elem$221771[ebp+4]
	mov	DWORD PTR $T221787[ebp], ecx
	mov	DWORD PTR _weightedElem$221783[ebp], 0
	mov	DWORD PTR _weightedElem$221783[ebp+4], 0
	mov	edx, DWORD PTR _iTechLoop$[ebp]
	mov	DWORD PTR _weightedElem$221783[ebp], edx
	mov	eax, DWORD PTR $T221787[ebp]
	mov	DWORD PTR _weightedElem$221783[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$221783[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back
$LN4@ChooseNext:

; 202  : 				}
; 203  : 			}
; 204  : 			else

	jmp	SHORT $LN6@ChooseNext
$LN5@ChooseNext:

; 205  : 			{
; 206  : 				m_ResearchableTechs.push_back(iTechLoop, m_TechAIWeights.GetWeight(iTechLoop));

	mov	edx, DWORD PTR _iTechLoop$[ebp]
	mov	DWORD PTR $T221802[ebp], edx
	mov	DWORD PTR _elem$221796[ebp], 0
	mov	DWORD PTR _elem$221796[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T221802[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _elem$221796[ebp], eax
	mov	DWORD PTR _elem$221796[ebp+4], ecx
	mov	edx, DWORD PTR _elem$221796[ebp+4]
	mov	DWORD PTR $T221812[ebp], edx
	mov	DWORD PTR _weightedElem$221808[ebp], 0
	mov	DWORD PTR _weightedElem$221808[ebp+4], 0
	mov	eax, DWORD PTR _iTechLoop$[ebp]
	mov	DWORD PTR _weightedElem$221808[ebp], eax
	mov	ecx, DWORD PTR $T221812[ebp]
	mov	DWORD PTR _weightedElem$221808[ebp+4], ecx
	lea	edx, DWORD PTR _weightedElem$221808[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back
$LN6@ChooseNext:

; 207  : 			}
; 208  : 		}
; 209  : 	}

	jmp	$LN8@ChooseNext
$LN7@ChooseNext:

; 210  : 
; 211  : 	// Reweight our possible choices by their cost, but only if cost is actually a factor!
; 212  : 	if(!bFreeTech)

	movzx	eax, BYTE PTR _bFreeTech$[ebp]
	test	eax, eax
	jne	SHORT $LN2@ChooseNext

; 213  : 		ReweightByCost(pPlayer);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z ; CvTechAI::ReweightByCost
$LN2@ChooseNext:

; 214  : 
; 215  : 	m_ResearchableTechs.SortItems();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 660				; 00000294H
	mov	DWORD PTR $T221833[ebp], edx
	mov	eax, DWORD PTR $T221833[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T221833[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T221817[ebp], ecx
	mov	edx, DWORD PTR $T221833[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T221821[ebp], eax
	mov	ecx, DWORD PTR $T221817[ebp]
	sub	ecx, DWORD PTR $T221821[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T221817[ebp]
	push	edx
	mov	eax, DWORD PTR $T221821[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 216  : 	LogPossibleResearch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPossibleResearch@CvTechAI@@AAEXXZ	; CvTechAI::LogPossibleResearch

; 217  : 
; 218  : 	// If total weight is above 0, choose one above a threshold
; 219  : 	if(m_ResearchableTechs.GetTotalWeight() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	call	?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ ; CvWeightedVector<int,80,1>::GetTotalWeight
	test	eax, eax
	jle	SHORT $LN1@ChooseNext

; 220  : 	{
; 221  : 		int iNumChoices =GC.getGame().getHandicapInfo().GetTechNumOptions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T221849[ebp], ecx
	mov	ecx, DWORD PTR $T221849[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	ecx, eax
	call	?GetTechNumOptions@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::GetTechNumOptions
	mov	DWORD PTR _iNumChoices$217787[ebp], eax

; 222  : 		rtnValue = (TechTypes) m_ResearchableTechs.ChooseFromTopChoices(iNumChoices, &fcn, "Choosing tech from Top Choices");

	push	OFFSET ??_C@_0BP@CFJNLAOG@Choosing?5tech?5from?5Top?5Choices?$AA@
	lea	edx, DWORD PTR _fcn$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNumChoices$217787[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	call	?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ; CvWeightedVector<int,80,1>::ChooseFromTopChoices
	mov	DWORD PTR _rtnValue$[ebp], eax

; 223  : 		LogResearchChoice(rtnValue);

	mov	ecx, DWORD PTR _rtnValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ; CvTechAI::LogResearchChoice
$LN1@ChooseNext:

; 224  : 	}
; 225  : 
; 226  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ChooseNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@_N@Z ENDP ; CvTechAI::ChooseNextTech
_TEXT	ENDS
PUBLIC	?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z ; CvTechAI::RecommendNextTech
; Function compile flags: /Odtp
;	COMDAT ?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T221985 = -72						; size = 4
$T221961 = -56						; size = 4
$T221957 = -52						; size = 4
$T221952 = -48						; size = 4
_weightedElem$221948 = -36				; size = 8
$T221930 = -28						; size = 4
_elem$221924 = -24					; size = 8
$T221915 = -16						; size = 4
_i$221910 = -12						; size = 4
_rtnValue$ = -8						; size = 4
_iTechLoop$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_eIgnoreTech$ = 12					; size = 4
?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z PROC ; CvTechAI::RecommendNextTech, COMDAT
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 	TechTypes rtnValue = NO_TECH;

	mov	DWORD PTR _rtnValue$[ebp], -1

; 233  : #ifdef AUI_WARNING_FIXES
; 234  : 	uint iTechLoop;
; 235  : #else
; 236  : 	int iTechLoop;
; 237  : #endif
; 238  : 
; 239  : 	// Create a new vector holding only techs we can currently research
; 240  : 	m_ResearchableTechs.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 660				; 00000294H
	mov	DWORD PTR $T221915[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN16@RecommendN
	mov	DWORD PTR _i$221910[ebp], 0
	jmp	SHORT $LN14@RecommendN
$LN13@RecommendN:
	mov	edx, DWORD PTR _i$221910[ebp]
	add	edx, 1
	mov	DWORD PTR _i$221910[ebp], edx
$LN14@RecommendN:
	mov	eax, DWORD PTR $T221915[ebp]
	mov	ecx, DWORD PTR _i$221910[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN16@RecommendN
	jmp	SHORT $LN13@RecommendN
$LN16@RecommendN:
	mov	edx, DWORD PTR $T221915[ebp]
	mov	DWORD PTR [edx+4], 0

; 241  : 
; 242  : 	// Loop through adding the researchable techs
; 243  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$[ebp], 0
	jmp	SHORT $LN5@RecommendN
$LN4@RecommendN:
	mov	eax, DWORD PTR _iTechLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$[ebp], eax
$LN5@RecommendN:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTechLoop$[ebp], eax
	jge	$LN3@RecommendN

; 244  : 	{
; 245  : 		//if (m_pCurrentTechs->CanResearch((TechTypes) iTechLoop) &&
; 246  : 		//	iTechLoop != eIgnoreTech &&
; 247  : 		//	m_pCurrentTechs->GetTechs()->GetEntry(iTechLoop)->GetAdvisorType() != eIgnoreAdvisor)
; 248  : #ifdef AUI_WARNING_FIXES
; 249  : 		if (m_pCurrentTechs->CanResearch((TechTypes)iTechLoop) && (TechTypes)iTechLoop != eIgnoreTech)
; 250  : #else
; 251  : 		if(m_pCurrentTechs->CanResearch((TechTypes) iTechLoop) && iTechLoop != eIgnoreTech)

	push	0
	mov	edx, DWORD PTR _iTechLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@RecommendN
	mov	edx, DWORD PTR _iTechLoop$[ebp]
	cmp	edx, DWORD PTR _eIgnoreTech$[ebp]
	je	SHORT $LN2@RecommendN

; 252  : #endif
; 253  : 		{
; 254  : 			m_ResearchableTechs.push_back(iTechLoop, m_TechAIWeights.GetWeight(iTechLoop));

	mov	eax, DWORD PTR _iTechLoop$[ebp]
	mov	DWORD PTR $T221930[ebp], eax
	mov	DWORD PTR _elem$221924[ebp], 0
	mov	DWORD PTR _elem$221924[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T221930[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$221924[ebp], ecx
	mov	DWORD PTR _elem$221924[ebp+4], edx
	mov	eax, DWORD PTR _elem$221924[ebp+4]
	mov	DWORD PTR $T221952[ebp], eax
	mov	DWORD PTR _weightedElem$221948[ebp], 0
	mov	DWORD PTR _weightedElem$221948[ebp+4], 0
	mov	ecx, DWORD PTR _iTechLoop$[ebp]
	mov	DWORD PTR _weightedElem$221948[ebp], ecx
	mov	edx, DWORD PTR $T221952[ebp]
	mov	DWORD PTR _weightedElem$221948[ebp+4], edx
	lea	eax, DWORD PTR _weightedElem$221948[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back
$LN2@RecommendN:

; 255  : 		}
; 256  : 	}

	jmp	$LN4@RecommendN
$LN3@RecommendN:

; 257  : 
; 258  : 	ReweightByCost(pPlayer);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z ; CvTechAI::ReweightByCost

; 259  : 	m_ResearchableTechs.SortItems();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 660				; 00000294H
	mov	DWORD PTR $T221985[ebp], edx
	mov	eax, DWORD PTR $T221985[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR $T221985[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T221957[ebp], ecx
	mov	edx, DWORD PTR $T221985[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T221961[ebp], eax
	mov	ecx, DWORD PTR $T221957[ebp]
	sub	ecx, DWORD PTR $T221961[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T221957[ebp]
	push	edx
	mov	eax, DWORD PTR $T221961[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 260  : 	LogPossibleResearch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogPossibleResearch@CvTechAI@@AAEXXZ	; CvTechAI::LogPossibleResearch

; 261  : 
; 262  : 	// If total weight is above 0, choose top choice as recommendation
; 263  : 	if(m_ResearchableTechs.GetTotalWeight() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 660				; 00000294H
	call	?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ ; CvWeightedVector<int,80,1>::GetTotalWeight
	test	eax, eax
	jle	SHORT $LN1@RecommendN

; 264  : 	{
; 265  : 
; 266  : 		rtnValue = (TechTypes) m_ResearchableTechs.GetElement(0);

	xor	ecx, ecx
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+660]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _rtnValue$[ebp], ecx

; 267  : 		LogResearchChoice(rtnValue);

	mov	edx, DWORD PTR _rtnValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ; CvTechAI::LogResearchChoice
$LN1@RecommendN:

; 268  : 	}
; 269  : 
; 270  : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RecommendNextTech@CvTechAI@@QAE?AW4TechTypes@@PAVCvPlayer@@W42@@Z ENDP ; CvTechAI::RecommendNextTech
_TEXT	ENDS
PUBLIC	?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z	; CvTechAI::GetWeight
; Function compile flags: /Odtp
;	COMDAT ?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_elem$222016 = -8					; size = 8
_eTech$ = 8						; size = 4
?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z PROC		; CvTechAI::GetWeight, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 	return m_TechAIWeights.GetWeight(eTech);

	mov	DWORD PTR _elem$222016[ebp], 0
	mov	DWORD PTR _elem$222016[ebp+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _eTech$[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _elem$222016[ebp], eax
	mov	DWORD PTR _elem$222016[ebp+4], ecx
	mov	eax, DWORD PTR _elem$222016[ebp+4]

; 277  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetWeight@CvTechAI@@QAEHW4TechTypes@@@Z ENDP		; CvTechAI::GetWeight
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
PUBLIC	??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
PUBLIC	?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy
PUBLIC	__real@00000000
PUBLIC	??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z ; std::stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
PUBLIC	?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::push_back
PUBLIC	??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
PUBLIC	?GetTechRatio@CvTechAI@@QAEMXZ			; CvTechAI::GetTechRatio
EXTRN	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ:PROC	; CvTeamTechs::GetNumTechsKnown
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	__fltused:DWORD
;	COMDAT __real@00000000
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTechRatio@CvTechAI@@QAEMXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTechRatio@CvTechAI@@QAEMXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTechRatio@CvTechAI@@QAEMXZ$3
__ehfuncinfo$?GetTechRatio@CvTechAI@@QAEMXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetTechRatio@CvTechAI@@QAEMXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?GetTechRatio@CvTechAI@@QAEMXZ
_TEXT	SEGMENT
_this$ = -236						; size = 4
$T222220 = -200						; size = 4
$T222219 = -196						; size = 4
$T222210 = -192						; size = 4
$T222126 = -140						; size = 4
$T222110 = -136						; size = 4
$T222065 = -108						; size = 4
$T222061 = -104						; size = 4
$T222052 = -100						; size = 4
$T222048 = -93						; size = 1
$T222039 = -92						; size = 4
$T222027 = -80						; size = 4
$T222026 = -76						; size = 4
$T222025 = -72						; size = 4
$T222024 = -65						; size = 1
_iDenominator$218308 = -64				; size = 4
_iNumerator$218307 = -60				; size = 4
_ui$218300 = -56					; size = 4
_ePlayer$218138 = -52					; size = 4
_kEvalChunk$218141 = -48				; size = 8
_ui$218134 = -40					; size = 4
_fTechPositionRatio$ = -36				; size = 4
_iPlayerIndexInList$ = -32				; size = 4
_aLeaderWithNumTechs$ = -28				; size = 16
__$EHRec$ = -12						; size = 12
?GetTechRatio@CvTechAI@@QAEMXZ PROC			; CvTechAI::GetTechRatio, COMDAT
; _this$ = ecx

; 294  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetTechRatio@CvTechAI@@QAEMXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	// create list of all civs with the number of techs they control
; 296  : 	std::vector<LeaderWithNumTechs> aLeaderWithNumTechs;

	lea	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp]
	call	??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 297  : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$218134[ebp], 0
	jmp	SHORT $LN9@GetTechRat
$LN8@GetTechRat:
	mov	eax, DWORD PTR _ui$218134[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$218134[ebp], eax
$LN9@GetTechRat:
	cmp	DWORD PTR _ui$218134[ebp], 22		; 00000016H
	jae	$LN7@GetTechRat

; 298  : 	{
; 299  : 		PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	ecx, DWORD PTR _ui$218134[ebp]
	mov	DWORD PTR _ePlayer$218138[ebp], ecx

; 300  : 		if(!GET_PLAYER(ePlayer).isAlive())

	mov	edx, DWORD PTR _ePlayer$218138[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T222039[ebp], edx
	mov	eax, DWORD PTR $T222039[ebp]
	mov	cl, BYTE PTR [eax+2256]
	mov	BYTE PTR $T222048[ebp], cl
	movzx	edx, BYTE PTR $T222048[ebp]
	test	edx, edx
	jne	SHORT $LN6@GetTechRat

; 301  : 		{
; 302  : 			continue;

	jmp	SHORT $LN8@GetTechRat
$LN6@GetTechRat:

; 303  : 		}
; 304  : 
; 305  : 		LeaderWithNumTechs kEvalChunk;
; 306  : 		kEvalChunk.m_iLeader = ui;

	mov	eax, DWORD PTR _ui$218134[ebp]
	mov	DWORD PTR _kEvalChunk$218141[ebp], eax

; 307  : 		kEvalChunk.m_iNumTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	ecx, DWORD PTR _ePlayer$218138[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T222052[ebp], ecx
	mov	edx, DWORD PTR $T222052[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T222061[ebp], eax
	mov	ecx, DWORD PTR $T222061[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T222065[ebp], ecx
	mov	ecx, DWORD PTR $T222065[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	mov	DWORD PTR _kEvalChunk$218141[ebp+4], eax

; 308  : 		aLeaderWithNumTechs.push_back(kEvalChunk);

	lea	edx, DWORD PTR _kEvalChunk$218141[ebp]
	push	edx
	lea	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp]
	call	?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::push_back

; 309  : 	}

	jmp	$LN8@GetTechRat
$LN7@GetTechRat:

; 310  : 
; 311  : 	std::stable_sort(aLeaderWithNumTechs.begin(), aLeaderWithNumTechs.end(), LeaderWithNumTechsEval());

	xor	eax, eax
	mov	BYTE PTR $T222024[ebp], al
	mov	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp+8]
	mov	DWORD PTR $T222110[ebp], ecx
	mov	edx, DWORD PTR $T222110[ebp]
	mov	DWORD PTR $T222025[ebp], edx
	mov	eax, DWORD PTR _aLeaderWithNumTechs$[ebp+4]
	mov	DWORD PTR $T222126[ebp], eax
	mov	ecx, DWORD PTR $T222126[ebp]
	mov	DWORD PTR $T222026[ebp], ecx
	movzx	edx, BYTE PTR $T222024[ebp]
	push	edx
	mov	eax, DWORD PTR $T222025[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222026[ebp]
	push	ecx
	call	??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z ; std::stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
	add	esp, 12					; 0000000cH

; 312  : 
; 313  : 	int iPlayerIndexInList = -1;

	mov	DWORD PTR _iPlayerIndexInList$[ebp], -1

; 314  : 	for(uint ui = 0; ui < aLeaderWithNumTechs.size(); ui++)

	mov	DWORD PTR _ui$218300[ebp], 0
	jmp	SHORT $LN5@GetTechRat
$LN4@GetTechRat:
	mov	edx, DWORD PTR _ui$218300[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$218300[ebp], edx
$LN5@GetTechRat:
	mov	eax, DWORD PTR _aLeaderWithNumTechs$[ebp+8]
	sub	eax, DWORD PTR _aLeaderWithNumTechs$[ebp+4]
	sar	eax, 3
	cmp	DWORD PTR _ui$218300[ebp], eax
	jae	SHORT $LN3@GetTechRat

; 315  : 	{
; 316  : 		if(aLeaderWithNumTechs[ui].m_iLeader == m_pCurrentTechs->GetPlayer()->GetID())

	mov	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp+4]
	mov	edx, DWORD PTR _ui$218300[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T222210[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	DWORD PTR $T222219[ebp], eax
	mov	edx, DWORD PTR $T222219[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T222220[ebp], eax
	mov	ecx, DWORD PTR $T222210[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR $T222220[ebp]
	jne	SHORT $LN2@GetTechRat

; 317  : 		{
; 318  : 			iPlayerIndexInList = ui;

	mov	eax, DWORD PTR _ui$218300[ebp]
	mov	DWORD PTR _iPlayerIndexInList$[ebp], eax

; 319  : 			break;

	jmp	SHORT $LN3@GetTechRat
$LN2@GetTechRat:

; 320  : 		}
; 321  : 	}

	jmp	SHORT $LN4@GetTechRat
$LN3@GetTechRat:

; 322  : 
; 323  : 	CvAssertMsg(iPlayerIndexInList != -1, "Could not find player in list");
; 324  : 	CvAssertMsg(aLeaderWithNumTechs.size() >= 2, "Only one player in the game? Huh?");
; 325  : 	float fTechPositionRatio = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fTechPositionRatio$[ebp], xmm0

; 326  : 	if(aLeaderWithNumTechs.size() >= 2)

	mov	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp+8]
	sub	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp+4]
	sar	ecx, 3
	cmp	ecx, 2
	jb	SHORT $LN1@GetTechRat

; 327  : 	{
; 328  : 		int iNumerator = iPlayerIndexInList;

	mov	edx, DWORD PTR _iPlayerIndexInList$[ebp]
	mov	DWORD PTR _iNumerator$218307[ebp], edx

; 329  : 		int iDenominator = aLeaderWithNumTechs.size() - 1;

	mov	eax, DWORD PTR _aLeaderWithNumTechs$[ebp+8]
	sub	eax, DWORD PTR _aLeaderWithNumTechs$[ebp+4]
	sar	eax, 3
	sub	eax, 1
	mov	DWORD PTR _iDenominator$218308[ebp], eax

; 330  : 		fTechPositionRatio = iNumerator / (float)iDenominator;

	cvtsi2ss xmm0, DWORD PTR _iNumerator$218307[ebp]
	cvtsi2ss xmm1, DWORD PTR _iDenominator$218308[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _fTechPositionRatio$[ebp], xmm0
$LN1@GetTechRat:

; 331  : 	}
; 332  : 
; 333  : 	return fTechPositionRatio;

	movss	xmm0, DWORD PTR _fTechPositionRatio$[ebp]
	movss	DWORD PTR $T222027[ebp], xmm0
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp]
	call	?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	fld	DWORD PTR $T222027[ebp]

; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTechRatio@CvTechAI@@QAEMXZ$0:
	lea	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp]
	jmp	??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
__unwindfunclet$?GetTechRatio@CvTechAI@@QAEMXZ$3:
	lea	ecx, DWORD PTR _aLeaderWithNumTechs$[ebp]
	jmp	??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
__ehhandler$?GetTechRatio@CvTechAI@@QAEMXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetTechRatio@CvTechAI@@QAEMXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetTechRatio@CvTechAI@@QAEMXZ ENDP			; CvTechAI::GetTechRatio
PUBLIC	?PropagateWeights@CvTechAI@@AAEXHHHH@Z		; CvTechAI::PropagateWeights
; Function compile flags: /Odtp
;	COMDAT ?WeightPrereqs@CvTechAI@@AAEXPAHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iTechLoop$ = -4					; size = 4
_paiTempWeights$ = 8					; size = 4
_iPropagationPercent$ = 12				; size = 4
?WeightPrereqs@CvTechAI@@AAEXPAHH@Z PROC		; CvTechAI::WeightPrereqs, COMDAT
; _this$ = ecx

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 	int iTechLoop;
; 348  : #endif
; 349  : 
; 350  : 	// Loop through techs looking for ones that are just getting some new weight
; 351  : 	for(iTechLoop = 0; iTechLoop < m_pCurrentTechs->GetTechs()->GetNumTechs(); iTechLoop++)

	mov	DWORD PTR _iTechLoop$[ebp], 0
	jmp	SHORT $LN4@WeightPrer
$LN3@WeightPrer:
	mov	eax, DWORD PTR _iTechLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iTechLoop$[ebp], eax
$LN4@WeightPrer:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetNumTechs@CvTechXMLEntries@@QAEHXZ	; CvTechXMLEntries::GetNumTechs
	cmp	DWORD PTR _iTechLoop$[ebp], eax
	jge	SHORT $LN5@WeightPrer

; 352  : 	{
; 353  : 		// If found one, call our recursive routine to weight everything to the left in the tree
; 354  : 		if(paiTempWeights[iTechLoop] > 0)

	mov	edx, DWORD PTR _iTechLoop$[ebp]
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jle	SHORT $LN1@WeightPrer

; 355  : 		{
; 356  : 			PropagateWeights(iTechLoop, paiTempWeights[iTechLoop], iPropagationPercent, 0);

	push	0
	mov	ecx, DWORD PTR _iPropagationPercent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iTechLoop$[ebp]
	mov	eax, DWORD PTR _paiTempWeights$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _iTechLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PropagateWeights@CvTechAI@@AAEXHHHH@Z	; CvTechAI::PropagateWeights
$LN1@WeightPrer:

; 357  : 		}

	jmp	SHORT $LN3@WeightPrer
$LN5@WeightPrer:

; 358  : 	}
; 359  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?WeightPrereqs@CvTechAI@@AAEXPAHH@Z ENDP		; CvTechAI::WeightPrereqs
_TEXT	ENDS
EXTRN	?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z:PROC	; CvTechEntry::GetPrereqAndTechs
; Function compile flags: /Odtp
;	COMDAT ?PropagateWeights@CvTechAI@@AAEXHHHH@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv135 = -32						; size = 4
_this$ = -28						; size = 4
$T222332 = -24						; size = 4
$T222328 = -20						; size = 4
_iPrereq$218336 = -16					; size = 4
_iI$218332 = -12					; size = 4
_iPropagatedWeight$218331 = -8				; size = 4
_pkTechInfo$ = -4					; size = 4
_iTech$ = 8						; size = 4
_iWeight$ = 12						; size = 4
_iPropagationPercent$ = 16				; size = 4
_iPropagationLevel$ = 20				; size = 4
?PropagateWeights@CvTechAI@@AAEXHHHH@Z PROC		; CvTechAI::PropagateWeights, COMDAT
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 	CvTechEntry* pkTechInfo = m_pCurrentTechs->GetTechs()->GetEntry(iTech);

	mov	eax, DWORD PTR _iTech$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
	mov	ecx, eax
	call	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
	mov	DWORD PTR _pkTechInfo$[ebp], eax

; 365  : 	if(pkTechInfo)

	cmp	DWORD PTR _pkTechInfo$[ebp], 0
	je	$LN9@PropagateW

; 366  : 	{
; 367  : 		if(iPropagationLevel < GC.getTECH_WEIGHT_PROPAGATION_LEVELS())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1840
	mov	DWORD PTR $T222328[ebp], edx
	mov	eax, DWORD PTR _iPropagationLevel$[ebp]
	cmp	eax, DWORD PTR $T222328[ebp]
	jge	$LN9@PropagateW

; 368  : 		{
; 369  : 			int iPropagatedWeight = iWeight * iPropagationPercent / 100;

	mov	eax, DWORD PTR _iWeight$[ebp]
	imul	eax, DWORD PTR _iPropagationPercent$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iPropagatedWeight$218331[ebp], eax

; 370  : 
; 371  : 			// Loop through all prerequisites
; 372  : 			for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$218332[ebp], 0
	jmp	SHORT $LN6@PropagateW
$LN5@PropagateW:
	mov	edx, DWORD PTR _iI$218332[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$218332[ebp], edx
$LN6@PropagateW:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	mov	DWORD PTR $T222332[ebp], eax
	mov	ecx, DWORD PTR _iI$218332[ebp]
	cmp	ecx, DWORD PTR $T222332[ebp]
	jge	SHORT $LN9@PropagateW

; 373  : 			{
; 374  : 				// Did we find a prereq?
; 375  : 				int iPrereq = pkTechInfo->GetPrereqAndTechs(iI);

	mov	edx, DWORD PTR _iI$218332[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkTechInfo$[ebp]
	call	?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetPrereqAndTechs
	mov	DWORD PTR _iPrereq$218336[ebp], eax

; 376  : 				if(iPrereq != NO_TECH)

	cmp	DWORD PTR _iPrereq$218336[ebp], -1
	je	SHORT $LN3@PropagateW

; 377  : 				{
; 378  : 					// Apply reduced weight here.  Note that we apply these to the master weight array, not
; 379  : 					// the temporary one.  The temporary one is just used to hold the newly weighted techs
; 380  : 					// (from which this weight propagation must originate).
; 381  : 					m_TechAIWeights.IncreaseWeight(iPrereq, iPropagatedWeight);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _iPrereq$218336[ebp]
	lea	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR tv135[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _iPropagatedWeight$218331[ebp]
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR [eax], edx

; 382  : 
; 383  : 					// Recurse to its prereqs (assuming we have any weight left)
; 384  : 					if(iPropagatedWeight > 0)

	cmp	DWORD PTR _iPropagatedWeight$218331[ebp], 0
	jle	SHORT $LN2@PropagateW

; 385  : 					{
; 386  : 						PropagateWeights(iPrereq, iPropagatedWeight, iPropagationPercent, iPropagationLevel++);

	mov	ecx, DWORD PTR _iPropagationLevel$[ebp]
	mov	DWORD PTR tv90[ebp], ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	mov	eax, DWORD PTR _iPropagationPercent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPropagatedWeight$218331[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPrereq$218336[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PropagateWeights@CvTechAI@@AAEXHHHH@Z	; CvTechAI::PropagateWeights
	mov	eax, DWORD PTR _iPropagationLevel$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPropagationLevel$[ebp], eax
$LN2@PropagateW:

; 387  : 					}
; 388  : 				}
; 389  : 				else

	jmp	SHORT $LN1@PropagateW
$LN3@PropagateW:

; 390  : 				{
; 391  : 					break;

	jmp	SHORT $LN9@PropagateW
$LN1@PropagateW:

; 392  : 				}
; 393  : 
; 394  : 			}

	jmp	SHORT $LN5@PropagateW
$LN9@PropagateW:

; 395  : 		}
; 396  : 	}
; 397  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PropagateWeights@CvTechAI@@AAEXHHHH@Z ENDP		; CvTechAI::PropagateWeights
_TEXT	ENDS
EXTRN	?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z:PROC ; CvPlayerTechs::GetResearchTurnsLeft
EXTRN	?GetScienceTimes100@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetScienceTimes100
EXTRN	?getOverflowResearchTimes100@CvPlayer@@QBEHXZ:PROC ; CvPlayer::getOverflowResearchTimes100
EXTRN	___libm_sse2_pow:PROC
; Function compile flags: /Odtp
;	COMDAT ?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
_elem$222395 = -76					; size = 8
_elem$222381 = -68					; size = 8
$T222367 = -60						; size = 4
$T222363 = -56						; size = 4
$T222347 = -52						; size = 4
_fAdditionalTurnCostFactor$218353 = -48			; size = 8
_iTurnsLeft$218351 = -40				; size = 4
_iNewWeight$218356 = -36				; size = 4
_fWeightDivisor$218352 = -32				; size = 8
_fTotalCostFactor$218354 = -24				; size = 8
_iI$218346 = -12					; size = 4
_eTech$ = -8						; size = 4
_bNeedExpensiveTechs$ = -1				; size = 1
_pPlayer$ = 8						; size = 4
?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z PROC	; CvTechAI::ReweightByCost, COMDAT
; _this$ = ecx

; 401  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 402  : 	TechTypes eTech;
; 403  : 
; 404  : 	// April 2014 Balance Patch: if lots of science overflow, want to pick an expensive tech
; 405  : 	bool bNeedExpensiveTechs = pPlayer->getOverflowResearchTimes100() > (pPlayer->GetScienceTimes100() * 2);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getOverflowResearchTimes100@CvPlayer@@QBEHXZ ; CvPlayer::getOverflowResearchTimes100
	mov	esi, eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	shl	eax, 1
	xor	ecx, ecx
	cmp	esi, eax
	setg	cl
	mov	BYTE PTR _bNeedExpensiveTechs$[ebp], cl

; 406  : 
; 407  : 	for(int iI = 0; iI < m_ResearchableTechs.size(); iI++)

	mov	DWORD PTR _iI$218346[ebp], 0
	jmp	SHORT $LN5@ReweightBy
$LN4@ReweightBy:
	mov	edx, DWORD PTR _iI$218346[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$218346[ebp], edx
$LN5@ReweightBy:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+664]
	mov	DWORD PTR $T222347[ebp], ecx
	mov	edx, DWORD PTR _iI$218346[ebp]
	cmp	edx, DWORD PTR $T222347[ebp]
	jge	$LN3@ReweightBy

; 408  : 	{
; 409  : 		eTech = (TechTypes) m_ResearchableTechs.GetElement(iI);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+660]
	mov	edx, DWORD PTR _iI$218346[ebp]
	mov	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _eTech$[ebp], eax

; 410  : 		int iTurnsLeft = 0;

	mov	DWORD PTR _iTurnsLeft$218351[ebp], 0

; 411  : 
; 412  : 		iTurnsLeft = m_pCurrentTechs->GetResearchTurnsLeft(eTech, true);

	push	1
	mov	ecx, DWORD PTR _eTech$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeft
	mov	DWORD PTR _iTurnsLeft$218351[ebp], eax

; 413  : 
; 414  : 		double fWeightDivisor;
; 415  : 
; 416  : 		// 10 turns will add 0.02; 80 turns will add 0.16
; 417  : 		double fAdditionalTurnCostFactor = GC.getAI_RESEARCH_WEIGHT_MOD_PER_TURN_LEFT() * iTurnsLeft;	// 0.015

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8008
	movss	DWORD PTR $T222363[ebp], xmm0
	cvtsi2ss xmm0, DWORD PTR _iTurnsLeft$218351[ebp]
	mulss	xmm0, DWORD PTR $T222363[ebp]
	cvtss2sd xmm0, xmm0
	movsd	QWORD PTR _fAdditionalTurnCostFactor$218353[ebp], xmm0

; 418  : 		double fTotalCostFactor = GC.getAI_RESEARCH_WEIGHT_BASE_MOD() + fAdditionalTurnCostFactor;	// 0.15

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8012
	movss	DWORD PTR $T222367[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T222367[ebp]
	addsd	xmm0, QWORD PTR _fAdditionalTurnCostFactor$218353[ebp]
	movsd	QWORD PTR _fTotalCostFactor$218354[ebp], xmm0

; 419  : 
; 420  : 		fWeightDivisor = pow((double) iTurnsLeft, fTotalCostFactor);

	cvtsi2sd xmm0, DWORD PTR _iTurnsLeft$218351[ebp]
	movsd	xmm1, QWORD PTR _fTotalCostFactor$218354[ebp]
	call	___libm_sse2_pow
	movsd	QWORD PTR _fWeightDivisor$218352[ebp], xmm0

; 421  : 
; 422  : 		int iNewWeight;
; 423  : 		if (bNeedExpensiveTechs)

	movzx	eax, BYTE PTR _bNeedExpensiveTechs$[ebp]
	test	eax, eax
	je	SHORT $LN2@ReweightBy

; 424  : 		{
; 425  : 			iNewWeight = int(double(m_ResearchableTechs.GetWeight(iI)) * fWeightDivisor);

	mov	DWORD PTR _elem$222381[ebp], 0
	mov	DWORD PTR _elem$222381[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	mov	eax, DWORD PTR _iI$218346[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$222381[ebp], ecx
	mov	DWORD PTR _elem$222381[ebp+4], edx
	cvtsi2sd xmm0, DWORD PTR _elem$222381[ebp+4]
	mulsd	xmm0, QWORD PTR _fWeightDivisor$218352[ebp]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iNewWeight$218356[ebp], eax

; 426  : 		}
; 427  : 		else

	jmp	SHORT $LN1@ReweightBy
$LN2@ReweightBy:

; 428  : 		{
; 429  : 			iNewWeight = int(double(m_ResearchableTechs.GetWeight(iI)) / fWeightDivisor);

	mov	DWORD PTR _elem$222395[ebp], 0
	mov	DWORD PTR _elem$222395[ebp+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	mov	eax, DWORD PTR _iI$218346[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$222395[ebp], ecx
	mov	DWORD PTR _elem$222395[ebp+4], edx
	cvtsi2sd xmm0, DWORD PTR _elem$222395[ebp+4]
	divsd	xmm0, QWORD PTR _fWeightDivisor$218352[ebp]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iNewWeight$218356[ebp], eax
$LN1@ReweightBy:

; 430  : 		}
; 431  : 
; 432  : 		// Now actually change the weight
; 433  : 		m_ResearchableTechs.SetWeight(iI, iNewWeight);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	mov	eax, DWORD PTR _iI$218346[ebp]
	mov	ecx, DWORD PTR _iNewWeight$218356[ebp]
	mov	DWORD PTR [edx+eax*8+4], ecx

; 434  : 	}

	jmp	$LN4@ReweightBy
$LN3@ReweightBy:

; 435  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?ReweightByCost@CvTechAI@@AAEXPAVCvPlayer@@@Z ENDP	; CvTechAI::ReweightByCost
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0N@EGCCLJCI@Unknown?5Tech?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ; CvTechAI::GetLogFileName
PUBLIC	__$ArrayPad$
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@ DB '%s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EGCCLJCI@Unknown?5Tech?$AA@
CONST	SEGMENT
??_C@_0N@EGCCLJCI@Unknown?5Tech?$AA@ DB 'Unknown Tech', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogPossibleResearch@CvTechAI@@AAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogPossibleResearch@CvTechAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogPossibleResearch@CvTechAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?LogPossibleResearch@CvTechAI@@AAEXXZ
_TEXT	SEGMENT
tv253 = -328						; size = 4
tv188 = -324						; size = 4
tv223 = -320						; size = 4
tv264 = -316						; size = 4
tv275 = -312						; size = 4
tv95 = -308						; size = 4
_this$ = -304						; size = 4
$T222501 = -300						; size = 4
$T222497 = -296						; size = 4
_elem$222490 = -292					; size = 8
$T222464 = -284						; size = 4
$T222459 = -280						; size = 4
$T222451 = -276						; size = 4
$T222450 = -272						; size = 4
$T222446 = -268						; size = 4
$T222412 = -264						; size = 28
$T222409 = -236						; size = 28
$T222408 = -208						; size = 28
_pTechEntry$218380 = -180				; size = 4
_szTechType$218381 = -176				; size = 4
_iWeight$218379 = -172					; size = 4
_eTech$218377 = -168					; size = 4
_iI$218373 = -164					; size = 4
_strOutBuf$218363 = -160				; size = 28
_playerName$218366 = -132				; size = 28
_strDesc$218367 = -104					; size = 28
_pLog$218368 = -76					; size = 4
_strTemp$218365 = -72					; size = 28
_strBaseString$218364 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogPossibleResearch@CvTechAI@@AAEXXZ PROC		; CvTechAI::LogPossibleResearch, COMDAT
; _this$ = ecx

; 439  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogPossibleResearch@CvTechAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 316				; 0000013cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 440  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN5@LogPossibl
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@LogPossibl

; 441  : 	{
; 442  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$218363[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 443  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$218364[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 444  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218365[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 445  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$218366[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 446  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$218367[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 447  : 
; 448  : 		// Find the name of this civ
; 449  : 		playerName = m_pCurrentTechs->GetPlayer()->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T222446[ebp], eax
	cmp	DWORD PTR $T222446[ebp], 0
	je	SHORT $LN33@LogPossibl
	mov	eax, DWORD PTR $T222446[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$218366[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN34@LogPossibl
$LN33@LogPossibl:
	lea	ecx, DWORD PTR _playerName$218366[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN34@LogPossibl:

; 450  : 
; 451  : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv95[ebp], eax
	lea	ecx, DWORD PTR _playerName$218366[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222408[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ; CvTechAI::GetLogFileName
	mov	DWORD PTR tv275[ebp], eax
	mov	eax, DWORD PTR tv275[ebp]
	mov	DWORD PTR $T222450[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T222450[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T222451[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T222451[ebp]
	push	ecx
	mov	edx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$218368[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T222408[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 452  : 
; 453  : 		// Get the leading info for this line
; 454  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T222459[ebp], eax
	mov	ecx, DWORD PTR $T222459[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$218364[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 455  : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$218366[ebp]
	push	edx
	lea	eax, DWORD PTR $T222409[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv264[ebp], eax
	mov	ecx, DWORD PTR tv264[ebp]
	mov	DWORD PTR tv223[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv223[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$218364[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T222409[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 456  : 
; 457  : 		// Dump out the weight of each Researchable Tech
; 458  : 		for(int iI = 0; iI < m_ResearchableTechs.size(); iI++)

	mov	DWORD PTR _iI$218373[ebp], 0
	jmp	SHORT $LN3@LogPossibl
$LN2@LogPossibl:
	mov	eax, DWORD PTR _iI$218373[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$218373[ebp], eax
$LN3@LogPossibl:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+664]
	mov	DWORD PTR $T222464[ebp], edx
	mov	eax, DWORD PTR _iI$218373[ebp]
	cmp	eax, DWORD PTR $T222464[ebp]
	jge	$LN1@LogPossibl

; 459  : 		{
; 460  : 			TechTypes eTech = (TechTypes) m_ResearchableTechs.GetElement(iI);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+660]
	mov	eax, DWORD PTR _iI$218373[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR _eTech$218377[ebp], ecx

; 461  : 			int iWeight = m_ResearchableTechs.GetWeight(iI);

	mov	DWORD PTR _elem$222490[ebp], 0
	mov	DWORD PTR _elem$222490[ebp+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+660]
	mov	ecx, DWORD PTR _iI$218373[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$222490[ebp], edx
	mov	DWORD PTR _elem$222490[ebp+4], eax
	mov	ecx, DWORD PTR _elem$222490[ebp+4]
	mov	DWORD PTR _iWeight$218379[ebp], ecx

; 462  : 
; 463  : 			CvTechEntry* pTechEntry = GC.getTechInfo(eTech);

	mov	edx, DWORD PTR _eTech$218377[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pTechEntry$218380[ebp], eax

; 464  : 			const char* szTechType = (pTechEntry != NULL)? pTechEntry->GetType() : "Unknown Tech";

	cmp	DWORD PTR _pTechEntry$218380[ebp], 0
	je	SHORT $LN7@LogPossibl
	mov	ecx, DWORD PTR _pTechEntry$218380[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv188[ebp], eax
	jmp	SHORT $LN8@LogPossibl
$LN7@LogPossibl:
	mov	DWORD PTR tv188[ebp], OFFSET ??_C@_0N@EGCCLJCI@Unknown?5Tech?$AA@
$LN8@LogPossibl:
	mov	eax, DWORD PTR tv188[ebp]
	mov	DWORD PTR _szTechType$218381[ebp], eax

; 465  : 
; 466  : 			strTemp.Format("%s, %d", szTechType, iWeight);

	mov	ecx, DWORD PTR _iWeight$218379[ebp]
	push	ecx
	mov	edx, DWORD PTR _szTechType$218381[ebp]
	push	edx
	push	OFFSET ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strTemp$218365[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 467  : 
; 468  : 			strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$218365[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$218364[ebp]
	push	edx
	lea	eax, DWORD PTR $T222412[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv253[ebp], eax
	mov	ecx, DWORD PTR tv253[ebp]
	mov	DWORD PTR $T222497[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T222497[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$218363[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T222412[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 469  : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$218363[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T222501[ebp], eax
	mov	edx, DWORD PTR $T222501[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$218368[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$218368[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 470  : 		}

	jmp	$LN2@LogPossibl
$LN1@LogPossibl:

; 471  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strDesc$218367[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _playerName$218366[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strTemp$218365[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strBaseString$218364[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strOutBuf$218363[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@LogPossibl:

; 472  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$218363[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$218364[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$218365[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR _playerName$218366[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$4:
	lea	ecx, DWORD PTR _strDesc$218367[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$5:
	lea	ecx, DWORD PTR $T222408[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$6:
	lea	ecx, DWORD PTR $T222409[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogPossibleResearch@CvTechAI@@AAEXXZ$7:
	lea	ecx, DWORD PTR $T222412[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogPossibleResearch@CvTechAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-320]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogPossibleResearch@CvTechAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogPossibleResearch@CvTechAI@@AAEXXZ ENDP		; CvTechAI::LogPossibleResearch
PUBLIC	??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@		; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@ DB 'CHOSEN, %s', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$6
	DD	04H
	DD	FLAT:__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
_TEXT	SEGMENT
tv239 = -304						; size = 4
tv175 = -300						; size = 4
tv209 = -296						; size = 4
tv250 = -292						; size = 4
tv261 = -288						; size = 4
tv95 = -284						; size = 4
_this$ = -280						; size = 4
$T222593 = -276						; size = 4
$T222589 = -272						; size = 4
$T222582 = -268						; size = 4
$T222574 = -264						; size = 4
$T222573 = -260						; size = 4
$T222569 = -256						; size = 4
$T222535 = -252						; size = 28
$T222532 = -224						; size = 28
$T222531 = -196						; size = 28
_playerName$218390 = -168				; size = 28
_strOutBuf$218391 = -140				; size = 28
_pTechEntry$218398 = -112				; size = 4
_szTechType$218399 = -108				; size = 4
_strDesc$218394 = -104					; size = 28
_pLog$218395 = -76					; size = 4
_strTemp$218393 = -72					; size = 28
_strBaseString$218392 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTech$ = 8						; size = 4
?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z PROC	; CvTechAI::LogResearchChoice, COMDAT
; _this$ = ecx

; 476  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN2@LogResearc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@LogResearc

; 478  : 	{
; 479  : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$218390[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 480  : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$218391[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 481  : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$218392[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 482  : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$218393[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 483  : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$218394[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 484  : 
; 485  : 		// Find the name of this civ
; 486  : 		playerName = m_pCurrentTechs->GetPlayer()->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ; CvPlayerTechs::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T222569[ebp], eax
	cmp	DWORD PTR $T222569[ebp], 0
	je	SHORT $LN30@LogResearc
	mov	eax, DWORD PTR $T222569[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$218390[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN31@LogResearc
$LN30@LogResearc:
	lea	ecx, DWORD PTR _playerName$218390[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN31@LogResearc:

; 487  : 
; 488  : 		FILogFile* pLog;
; 489  : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(playerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv95[ebp], eax
	lea	ecx, DWORD PTR _playerName$218390[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222531[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ; CvTechAI::GetLogFileName
	mov	DWORD PTR tv261[ebp], eax
	mov	eax, DWORD PTR tv261[ebp]
	mov	DWORD PTR $T222573[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T222573[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T222574[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T222574[ebp]
	push	ecx
	mov	edx, DWORD PTR tv95[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv95[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$218395[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T222531[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 490  : 
; 491  : 		// Get the leading info for this line
; 492  : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T222582[ebp], eax
	mov	ecx, DWORD PTR $T222582[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$218392[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 493  : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$218390[ebp]
	push	edx
	lea	eax, DWORD PTR $T222532[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv250[ebp], eax
	mov	ecx, DWORD PTR tv250[ebp]
	mov	DWORD PTR tv209[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv209[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$218392[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T222532[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 494  : 
; 495  : 		CvTechEntry* pTechEntry = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	DWORD PTR _pTechEntry$218398[ebp], eax

; 496  : 		const char* szTechType = (pTechEntry != NULL)? pTechEntry->GetType() : "Unknown Tech";

	cmp	DWORD PTR _pTechEntry$218398[ebp], 0
	je	SHORT $LN4@LogResearc
	mov	ecx, DWORD PTR _pTechEntry$218398[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN5@LogResearc
$LN4@LogResearc:
	mov	DWORD PTR tv175[ebp], OFFSET ??_C@_0N@EGCCLJCI@Unknown?5Tech?$AA@
$LN5@LogResearc:
	mov	ecx, DWORD PTR tv175[ebp]
	mov	DWORD PTR _szTechType$218399[ebp], ecx

; 497  : 
; 498  : 		strTemp.Format("CHOSEN, %s", szTechType);

	mov	edx, DWORD PTR _szTechType$218399[ebp]
	push	edx
	push	OFFSET ??_C@_0L@DBMLLMJN@CHOSEN?0?5?$CFs?$AA@
	lea	eax, DWORD PTR _strTemp$218393[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 499  : 
; 500  : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$218393[ebp]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$218392[ebp]
	push	edx
	lea	eax, DWORD PTR $T222535[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR $T222589[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR $T222589[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$218391[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T222535[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 501  : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$218391[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T222593[ebp], eax
	mov	edx, DWORD PTR $T222593[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$218395[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$218395[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 502  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _strDesc$218394[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strTemp$218393[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strBaseString$218392[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strOutBuf$218391[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _playerName$218390[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@LogResearc:

; 503  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$0:
	lea	ecx, DWORD PTR _playerName$218390[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$1:
	lea	ecx, DWORD PTR _strOutBuf$218391[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$2:
	lea	ecx, DWORD PTR _strBaseString$218392[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$3:
	lea	ecx, DWORD PTR _strTemp$218393[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$218394[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$5:
	lea	ecx, DWORD PTR $T222531[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$6:
	lea	ecx, DWORD PTR $T222532[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z$7:
	lea	ecx, DWORD PTR $T222535[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-296]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogResearchChoice@CvTechAI@@AAEXW4TechTypes@@@Z ENDP	; CvTechAI::LogResearchChoice
PUBLIC	??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@		; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0L@EJOHMCKE@TechAILog_?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@ DB 'TechAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
CONST	SEGMENT
??_C@_0L@EJOHMCKE@TechAILog_?$AA@ DB 'TechAILog_', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvtechai.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
tv142 = -124						; size = 4
tv129 = -120						; size = 4
tv169 = -116						; size = 4
_this$ = -112						; size = 4
$T222638 = -108						; size = 4
$T222629 = -104						; size = 4
$T222624 = -100						; size = 28
$T222623 = -72						; size = 28
_strLogName$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z PROC	; CvTechAI::GetLogFileName, COMDAT
; _this$ = ecx

; 507  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222629[ebp], 0

; 508  : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 509  : 
; 510  : 	// Open the log file
; 511  : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetLogFile

; 512  : 	{
; 513  : 		strLogName = "TechAILog_" + playerName + ".csv";

	mov	ecx, DWORD PTR _playerName$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
	lea	edx, DWORD PTR $T222623[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv169[ebp], eax
	mov	eax, DWORD PTR tv169[ebp]
	mov	DWORD PTR tv129[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	ecx, DWORD PTR tv129[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222624[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv142[ebp], eax
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T222638[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T222638[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T222624[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T222623[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 514  : 	}
; 515  : 	else

	jmp	SHORT $LN1@GetLogFile
$LN2@GetLogFile:

; 516  : 	{
; 517  : 		strLogName = "TechAILog.csv";

	mov	ecx, OFFSET ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN16@GetLogFile
	push	OFFSET ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@GetLogFile
$LN16@GetLogFile:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@GetLogFile:

; 518  : 	}
; 519  : 
; 520  : 	return strLogName;

	lea	edx, DWORD PTR _strLogName$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T222629[ebp]
	or	eax, 1
	mov	DWORD PTR $T222629[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 521  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$0:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T222623[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T222624[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z$3:
	mov	eax, DWORD PTR $T222629[ebp]
	and	eax, 1
	je	$LN9@GetLogFile
	and	DWORD PTR $T222629[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN9@GetLogFile:
	ret	0
__ehhandler$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvTechAI@@ABE?AVCvString@@AAV2@@Z ENDP	; CvTechAI::GetLogFileName
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ PROC		; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@H$0FA@$00@@QAE@XZ ENDP		; CvWeightedVector<int,80,1>::~CvWeightedVector<int,80,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T222700 = -24						; size = 4
$T222693 = -20						; size = 4
_elem$218437 = -16					; size = 8
_i$218433 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ PROC ; CvWeightedVector<int,80,1>::GetTotalWeight, COMDAT
; _this$ = ecx

; 89   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 		int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 91   : 
; 92   : 		for (unsigned int i = 0; i < m_pItems.size(); i++)

	mov	DWORD PTR _i$218433[ebp], 0
	jmp	SHORT $LN3@GetTotalWe
$LN2@GetTotalWe:
	mov	eax, DWORD PTR _i$218433[ebp]
	add	eax, 1
	mov	DWORD PTR _i$218433[ebp], eax
$LN3@GetTotalWe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T222693[ebp], edx
	mov	eax, DWORD PTR _i$218433[ebp]
	cmp	eax, DWORD PTR $T222693[ebp]
	jae	SHORT $LN1@GetTotalWe

; 93   : 		{
; 94   : 			WeightedElement elem = m_pItems[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$218433[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T222700[ebp], ecx
	mov	edx, DWORD PTR $T222700[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _elem$218437[ebp], eax
	mov	ecx, DWORD PTR $T222700[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _elem$218437[ebp+4], edx

; 95   : 			rtnValue += elem.m_iWeight;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	add	eax, DWORD PTR _elem$218437[ebp+4]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 96   : 		}

	jmp	SHORT $LN2@GetTotalWe
$LN1@GetTotalWe:

; 97   : 
; 98   : 		return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 99   : 	};

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTotalWeight@?$CvWeightedVector@H$0FA@$00@@QAEHXZ ENDP ; CvWeightedVector<int,80,1>::GetTotalWeight
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T222725 = -36						; size = 4
$T222721 = -32						; size = 4
$T222710 = -28						; size = 4
$T222706 = -24						; size = 4
_iTotalTopChoicesWeight$ = -20				; size = 4
_iChoice$ = -16						; size = 4
_i$ = -12						; size = 4
_elem$ = -8						; size = 8
_iNumChoices$ = 8					; size = 4
_rndFcn$ = 12						; size = 4
_szRollName$ = 16					; size = 4
?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z PROC ; CvWeightedVector<int,80,1>::ChooseFromTopChoices, COMDAT
; _this$ = ecx

; 223  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		// Loop through the top choices, or the total vector size, whichever is smaller
; 225  : 		if (iNumChoices > (int) m_pItems.size())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222706[ebp], ecx
	mov	edx, DWORD PTR _iNumChoices$[ebp]
	cmp	edx, DWORD PTR $T222706[ebp]
	jle	SHORT $LN8@ChooseFrom

; 226  : 		{
; 227  : 			iNumChoices = (int) m_pItems.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T222710[ebp], ecx
	mov	edx, DWORD PTR $T222710[ebp]
	mov	DWORD PTR _iNumChoices$[ebp], edx
$LN8@ChooseFrom:

; 228  : 		}
; 229  : 
; 230  : 		WeightedElement elem;

	mov	DWORD PTR _elem$[ebp], 0
	mov	DWORD PTR _elem$[ebp+4], 0

; 231  : 		int i;
; 232  : 		int iChoice;
; 233  : 		int iTotalTopChoicesWeight = 0;

	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], 0

; 234  : 
; 235  : 		// Get the total weight
; 236  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@ChooseFrom
$LN6@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@ChooseFrom:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN5@ChooseFrom

; 237  : 		{
; 238  : 			elem = m_pItems[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[ebp], edx
	mov	DWORD PTR _elem$[ebp+4], eax

; 239  : 			iTotalTopChoicesWeight += elem.m_iWeight;

	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	add	ecx, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iTotalTopChoicesWeight$[ebp], ecx

; 240  : 		}

	jmp	SHORT $LN6@ChooseFrom
$LN5@ChooseFrom:

; 241  : 
; 242  : 		// Random roll up to total weight
; 243  : 		iChoice = (*rndFcn)(iTotalTopChoicesWeight, szRollName);

	mov	edx, DWORD PTR _rndFcn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T222721[ebp], eax
	mov	ecx, DWORD PTR _rndFcn$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T222725[ebp], edx
	mov	eax, DWORD PTR _szRollName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iTotalTopChoicesWeight$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222725[ebp]
	call	DWORD PTR $T222721[ebp]
	mov	DWORD PTR _iChoice$[ebp], eax

; 244  : 
; 245  : 		// Find out which element was chosen
; 246  : 		for (i = 0; i < iNumChoices; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ChooseFrom
$LN3@ChooseFrom:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@ChooseFrom:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _iNumChoices$[ebp]
	jge	SHORT $LN2@ChooseFrom

; 247  : 		{
; 248  : 			elem = m_pItems[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR _elem$[ebp], ecx
	mov	DWORD PTR _elem$[ebp+4], edx

; 249  : 			iChoice -= elem.m_iWeight;

	mov	eax, DWORD PTR _iChoice$[ebp]
	sub	eax, DWORD PTR _elem$[ebp+4]
	mov	DWORD PTR _iChoice$[ebp], eax

; 250  : 			if (iChoice < 0)

	jns	SHORT $LN1@ChooseFrom

; 251  : 			{
; 252  : 				return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
	jmp	SHORT $LN9@ChooseFrom
$LN1@ChooseFrom:

; 253  : 			}
; 254  : 		}

	jmp	SHORT $LN3@ChooseFrom
$LN2@ChooseFrom:

; 255  : 
; 256  : 		// We should have found something, so reaching here is an error
; 257  : 		//    Just return last thing accessed
; 258  : 		CvAssertMsg (false, "Internal error in CvWeightedVector.");
; 259  : 		return elem.m_Element;

	mov	eax, DWORD PTR _elem$[ebp]
$LN9@ChooseFrom:

; 260  : 	};

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ChooseFromTopChoices@?$CvWeightedVector@H$0FA@$00@@QAEHHPAV?$FastDelegate2@HPBDH@fastdelegate@@PBD@Z ENDP ; CvWeightedVector<int,80,1>::ChooseFromTopChoices
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Buy
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T222766 = -30						; size = 1
$T222753 = -29						; size = 1
$T222749 = -28						; size = 4
$T222742 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T222766[ebp]
	mov	DWORD PTR $T222742[ebp], eax
	lea	ecx, DWORD PTR $T222753[ebp]
	mov	DWORD PTR $T222749[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
PUBLIC	?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::insert
PUBLIC	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T222952 = -32						; size = 4
$T222942 = -28						; size = 4
$T222932 = -24						; size = 4
__Cat$222940 = -19					; size = 1
$T222938 = -18						; size = 1
$T222937 = -17						; size = 1
$T222909 = -16						; size = 4
$T222905 = -12						; size = 4
$T222904 = -8						; size = 4
$T222903 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR $T222909[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T222909[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T222942[ebp], eax
	mov	ecx, DWORD PTR $T222942[ebp]
	mov	DWORD PTR $T222932[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T222937[ebp], dl
	mov	al, BYTE PTR __Cat$222940[ebp]
	mov	BYTE PTR $T222938[ebp], al
	movzx	ecx, BYTE PTR $T222937[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T222938[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T222932[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 3
	add	eax, DWORD PTR $T222942[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T222952[ebp], eax
	mov	ecx, DWORD PTR $T222952[ebp]
	mov	DWORD PTR $T222904[ebp], ecx
	mov	edx, DWORD PTR $T222904[ebp]
	mov	DWORD PTR $T222903[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T222903[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222905[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAEXABULeaderWithNumTechs@@@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::~_Vector_val<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T223036 = -20						; size = 4
_pRet$223032 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 80			; 00000050H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223036[ebp], edx
	cmp	DWORD PTR $T223036[ebp], 80		; 00000050H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T223036[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$223032[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T223036[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$223032[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 80			; 00000050H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$223032[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T223067 = -24						; size = 4
$T223066 = -20						; size = 4
_i$223061 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223067[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T223066[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$223061[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$223061[ebp]
	add	eax, 1
	mov	DWORD PTR _i$223061[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$223061[ebp]
	cmp	ecx, DWORD PTR $T223067[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T223066[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T223066[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::~FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T223080 = -8						; size = 4
$T223079 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+652], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T223080[ebp], ecx
	cmp	DWORD PTR $T223080[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR $T223080[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T223080[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T223080[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@2:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T223079[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$223186 = -24					; size = 4
$T223169 = -20						; size = 4
$T223150 = -16						; size = 4
$T223137 = -12						; size = 4
$T223134 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	test	edx, edx
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223150[ebp], ecx
	mov	edx, DWORD PTR $T223150[ebp]
	mov	DWORD PTR $T223134[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T223134[ebp]
	sar	eax, 3
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T223169[ebp], edx
	mov	eax, DWORD PTR $T223169[ebp]
	mov	DWORD PTR $T223137[ebp], eax
	mov	ecx, DWORD PTR $T223137[ebp]
	mov	DWORD PTR __Tmp$223186[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$223186[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$223186[ebp], ecx
	mov	edx, DWORD PTR __Tmp$223186[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@QAE?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@V?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@ABULeaderWithNumTechs@@@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::insert
_TEXT	ENDS
PUBLIC	??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ; std::_Allocate<LeaderWithNumTechs>
PUBLIC	?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$223206 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$223206[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$223206[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$223206[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ; std::_Allocate<LeaderWithNumTechs>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Buy
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T223302 = -32						; size = 4
$T223301 = -28						; size = 4
$T223297 = -24						; size = 4
$T223296 = -20						; size = 4
$T223278 = -16						; size = 4
$T223277 = -12						; size = 4
$T223261 = -8						; size = 4
__Cat$223284 = -2					; size = 1
$T223281 = -1						; size = 1
?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223297[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T223296[ebp], ecx
	mov	edx, DWORD PTR $T223297[ebp]
	mov	DWORD PTR $T223278[ebp], edx
	mov	eax, DWORD PTR $T223296[ebp]
	mov	DWORD PTR $T223277[ebp], eax
	mov	cl, BYTE PTR __Cat$223284[ebp]
	mov	BYTE PTR $T223281[ebp], cl
	mov	edx, DWORD PTR $T223277[ebp]
	mov	DWORD PTR $T223261[ebp], edx
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	eax, DWORD PTR $T223261[ebp]
	add	eax, 8
	mov	DWORD PTR $T223261[ebp], eax
$LN12@Tidy:
	mov	ecx, DWORD PTR $T223261[ebp]
	cmp	ecx, DWORD PTR $T223278[ebp]
	je	SHORT $LN4@Tidy
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	mov	DWORD PTR $T223302[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223301[ebp], eax
	mov	ecx, DWORD PTR $T223301[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXXZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T223345 = -44						; size = 4
$T223344 = -40						; size = 4
_i$223337 = -36						; size = 4
$T223323 = -32						; size = 4
$T223316 = -28						; size = 4
_pRet$223313 = -24					; size = 4
$T223306 = -20						; size = 4
$T223305 = -16						; size = 4
_i$218604 = -12						; size = 4
_uiNewSize$218596 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$218596[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$218596[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize
$LN6@GrowSize:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$218596[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize
$LN7@GrowSize:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T223316[ebp], ecx
	cmp	DWORD PTR $T223316[ebp], 80		; 00000050H
	jbe	SHORT $LN16@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T223316[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$223313[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T223316[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$223313[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 80			; 00000050H
$LN17@GrowSize:
	mov	ecx, DWORD PTR _pRet$223313[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize
$LN5@GrowSize:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$218604[ebp], 0
	jmp	SHORT $LN3@GrowSize
$LN2@GrowSize:
	mov	edx, DWORD PTR _i$218604[ebp]
	add	edx, 1
	mov	DWORD PTR _i$218604[ebp], edx
$LN3@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$218604[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$218604[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T223306[ebp], ecx
	cmp	DWORD PTR $T223306[ebp], 0
	je	SHORT $LN12@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$218604[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T223323[ebp], edx
	mov	eax, DWORD PTR $T223306[ebp]
	mov	ecx, DWORD PTR $T223323[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T223306[ebp]
	mov	ecx, DWORD PTR $T223323[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T223306[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize
$LN12@GrowSize:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T223305[ebp], ecx
	jmp	SHORT $LN2@GrowSize
$LN4@GrowSize:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223345[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T223344[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize
	mov	DWORD PTR _i$223337[ebp], 0
	jmp	SHORT $LN29@GrowSize
$LN28@GrowSize:
	mov	edx, DWORD PTR _i$223337[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223337[ebp], edx
$LN29@GrowSize:
	mov	eax, DWORD PTR _i$223337[ebp]
	cmp	eax, DWORD PTR $T223345[ebp]
	jae	SHORT $LN24@GrowSize
	jmp	SHORT $LN28@GrowSize
$LN24@GrowSize:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T223344[ebp], ecx
	je	SHORT $LN25@GrowSize
	mov	edx, DWORD PTR $T223344[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+652], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$0FA@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<int,80,1>::WeightedElement,80,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@H$0FA@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<int,80,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
PUBLIC	??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$2
__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$0
__unwindtable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv304 = -428						; size = 4
tv290 = -424						; size = 4
tv282 = -420						; size = 4
_this$ = -416						; size = 4
$T224032 = -412						; size = 4
$T224024 = -408						; size = 4
$T224023 = -404						; size = 4
$T224000 = -398						; size = 1
$T223999 = -397						; size = 1
$T223998 = -396						; size = 4
$T223997 = -392						; size = 4
$T223985 = -385						; size = 1
$T223984 = -384						; size = 4
$T223983 = -380						; size = 4
$T223982 = -376						; size = 4
__Cat$224016 = -372					; size = 1
$T224014 = -371						; size = 1
$T224013 = -370						; size = 1
__Cat$224006 = -368					; size = 1
$T224004 = -367						; size = 1
$T224003 = -366						; size = 1
$T224002 = -365						; size = 1
$T223957 = -364						; size = 4
$T223938 = -360						; size = 4
$T223921 = -353						; size = 1
$T223920 = -352						; size = 4
$T223910 = -348						; size = 4
$T223909 = -344						; size = 4
__Cat$223954 = -338					; size = 1
$T223952 = -337						; size = 1
$T223951 = -336						; size = 1
__Cat$223945 = -335					; size = 1
$T223943 = -334						; size = 1
$T223942 = -333						; size = 1
$T223885 = -332						; size = 4
$T223877 = -328						; size = 4
$T223869 = -324						; size = 4
$T223851 = -320						; size = 4
$T223850 = -316						; size = 4
$T223834 = -312						; size = 4
__Cat$223857 = -306					; size = 1
$T223855 = -305						; size = 1
$T223808 = -304						; size = 4
$T223807 = -300						; size = 4
$T223797 = -296						; size = 4
__Cat$223804 = -291					; size = 1
$T223802 = -290						; size = 1
$T223801 = -289						; size = 1
$T223781 = -288						; size = 4
$T223762 = -284						; size = 4
$T223745 = -277						; size = 1
$T223744 = -276						; size = 4
$T223734 = -272						; size = 4
$T223733 = -268						; size = 4
__Cat$223777 = -262					; size = 1
$T223775 = -261						; size = 1
$T223774 = -260						; size = 1
__Cat$223769 = -259					; size = 1
$T223767 = -258						; size = 1
$T223766 = -257						; size = 1
$T223709 = -256						; size = 4
$T223708 = -252						; size = 4
$T223704 = -248						; size = 4
$T223703 = -244						; size = 4
$T223685 = -240						; size = 4
$T223684 = -236						; size = 4
$T223668 = -232						; size = 4
__Cat$223690 = -226					; size = 1
$T223688 = -225						; size = 1
$T223619 = -224						; size = 4
$T223618 = -220						; size = 4
$T223602 = -216						; size = 4
__Cat$223624 = -210					; size = 1
$T223622 = -209						; size = 1
$T223559 = -208						; size = 4
$T223558 = -204						; size = 4
$T223542 = -200						; size = 4
__Cat$223564 = -194					; size = 1
$T223562 = -193						; size = 1
$T223516 = -192						; size = 4
$T223504 = -188						; size = 4
$T223494 = -181						; size = 1
$T223493 = -180						; size = 4
__Cat$223511 = -175					; size = 1
$T223509 = -174						; size = 1
$T223508 = -173						; size = 1
$T223481 = -172						; size = 4
$T223469 = -168						; size = 4
$T223459 = -161						; size = 1
$T223458 = -160						; size = 4
__Cat$223476 = -155					; size = 1
$T223474 = -154						; size = 1
$T223473 = -153						; size = 1
$T223446 = -152						; size = 4
$T223436 = -148						; size = 4
__Cat$223442 = -143					; size = 1
$T223440 = -142						; size = 1
$T223439 = -141						; size = 1
__Count$223408 = -128					; size = 4
__Count$223382 = -56					; size = 4
__Tmp$218689 = -52					; size = 8
__Oldend$218690 = -44					; size = 4
__Tmp$218679 = -40					; size = 8
__Ncopied$218666 = -32					; size = 4
__Newvec$218664 = -28					; size = 4
__Whereoff$218665 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv282[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR tv282[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$223382[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$223382[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$223382[ebp]
	mov	DWORD PTR tv290[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv290[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	eax, DWORD PTR tv290[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$223408[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$223408[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$223408[ebp]
	mov	DWORD PTR tv304[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv304[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv304[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ; std::_Allocate<LeaderWithNumTechs>
	add	esp, 8
	mov	DWORD PTR __Newvec$218664[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 3
	mov	DWORD PTR __Whereoff$218665[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$218666[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$218665[ebp]
	mov	ecx, DWORD PTR __Newvec$218664[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T223446[ebp], edx
	mov	eax, DWORD PTR $T223446[ebp]
	mov	DWORD PTR $T223436[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T223439[ebp], cl
	mov	dl, BYTE PTR __Cat$223442[ebp]
	mov	BYTE PTR $T223440[ebp], dl
	movzx	eax, BYTE PTR $T223439[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T223440[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223436[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$218666[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$218666[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T223481[ebp], edx
	mov	eax, DWORD PTR __Newvec$218664[ebp]
	mov	DWORD PTR $T223469[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T223473[ebp], cl
	mov	dl, BYTE PTR __Cat$223476[ebp]
	mov	BYTE PTR $T223474[ebp], dl
	mov	al, BYTE PTR $T223473[ebp]
	mov	BYTE PTR $T223459[ebp], al
	mov	ecx, DWORD PTR $T223469[ebp]
	mov	DWORD PTR $T223458[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T223458[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223481[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$218666[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$218666[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223516[ebp], edx
	mov	eax, DWORD PTR __Whereoff$218665[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$218664[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T223504[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T223508[ebp], al
	mov	cl, BYTE PTR __Cat$223511[ebp]
	mov	BYTE PTR $T223509[ebp], cl
	mov	dl, BYTE PTR $T223508[ebp]
	mov	BYTE PTR $T223494[ebp], dl
	mov	eax, DWORD PTR $T223504[ebp]
	mov	DWORD PTR $T223493[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223493[ebp]
	push	edx
	mov	eax, DWORD PTR $T223516[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$218666[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$218665[ebp]
	mov	eax, DWORD PTR __Newvec$218664[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T223559[ebp], ecx
	mov	edx, DWORD PTR __Newvec$218664[ebp]
	mov	DWORD PTR $T223558[ebp], edx
	mov	al, BYTE PTR __Cat$223564[ebp]
	mov	BYTE PTR $T223562[ebp], al
	mov	ecx, DWORD PTR $T223558[ebp]
	mov	DWORD PTR $T223542[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T223542[ebp]
	add	edx, 8
	mov	DWORD PTR $T223542[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T223542[ebp]
	cmp	eax, DWORD PTR $T223559[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$218666[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$218665[ebp]
	mov	edx, DWORD PTR __Newvec$218664[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T223619[ebp], edx
	mov	eax, DWORD PTR __Whereoff$218665[ebp]
	mov	ecx, DWORD PTR __Newvec$218664[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T223618[ebp], edx
	mov	al, BYTE PTR __Cat$223624[ebp]
	mov	BYTE PTR $T223622[ebp], al
	mov	ecx, DWORD PTR $T223618[ebp]
	mov	DWORD PTR $T223602[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T223602[ebp]
	add	edx, 8
	mov	DWORD PTR $T223602[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T223602[ebp]
	cmp	eax, DWORD PTR $T223619[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$218664[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T223704[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T223703[ebp], eax
	mov	ecx, DWORD PTR $T223704[ebp]
	mov	DWORD PTR $T223685[ebp], ecx
	mov	edx, DWORD PTR $T223703[ebp]
	mov	DWORD PTR $T223684[ebp], edx
	mov	al, BYTE PTR __Cat$223690[ebp]
	mov	BYTE PTR $T223688[ebp], al
	mov	ecx, DWORD PTR $T223684[ebp]
	mov	DWORD PTR $T223668[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T223668[ebp]
	add	edx, 8
	mov	DWORD PTR $T223668[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T223668[ebp]
	cmp	eax, DWORD PTR $T223685[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 3
	mov	DWORD PTR $T223709[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T223708[ebp], edx
	mov	eax, DWORD PTR $T223708[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$218664[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$218664[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$218664[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$218679[ebp], edx
	mov	DWORD PTR __Tmp$218679[ebp+4], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T223781[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T223762[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T223766[ebp], al
	mov	cl, BYTE PTR __Cat$223769[ebp]
	mov	BYTE PTR $T223767[ebp], cl
	mov	dl, BYTE PTR $T223766[ebp]
	mov	BYTE PTR $T223745[ebp], dl
	mov	eax, DWORD PTR $T223762[ebp]
	mov	DWORD PTR $T223744[ebp], eax
	mov	ecx, DWORD PTR $T223744[ebp]
	mov	DWORD PTR $T223734[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T223733[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T223774[ebp], al
	mov	cl, BYTE PTR __Cat$223777[ebp]
	mov	BYTE PTR $T223775[ebp], cl
	movzx	edx, BYTE PTR $T223774[ebp]
	push	edx
	movzx	eax, BYTE PTR $T223775[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223734[ebp]
	push	edx
	mov	eax, DWORD PTR $T223781[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223733[ebp]
	push	ecx
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T223808[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T223807[ebp], eax
	mov	ecx, DWORD PTR $T223807[ebp]
	mov	DWORD PTR $T223797[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T223801[ebp], dl
	mov	al, BYTE PTR __Cat$223804[ebp]
	mov	BYTE PTR $T223802[ebp], al
	movzx	ecx, BYTE PTR $T223801[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T223802[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$218679[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223808[ebp]
	push	edx
	mov	eax, DWORD PTR $T223797[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T223869[ebp], ecx
	mov	edx, DWORD PTR $T223869[ebp]
	mov	DWORD PTR $T223851[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T223850[ebp], edx
	mov	al, BYTE PTR __Cat$223857[ebp]
	mov	BYTE PTR $T223855[ebp], al
	mov	ecx, DWORD PTR $T223850[ebp]
	mov	DWORD PTR $T223834[ebp], ecx
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	edx, DWORD PTR $T223834[ebp]
	add	edx, 8
	mov	DWORD PTR $T223834[ebp], edx
$LN160@Insert_n:
	mov	eax, DWORD PTR $T223834[ebp]
	cmp	eax, DWORD PTR $T223851[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	DWORD PTR $T223885[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T223877[ebp], eax
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	ecx, DWORD PTR $T223877[ebp]
	add	ecx, 8
	mov	DWORD PTR $T223877[ebp], ecx
$LN171@Insert_n:
	mov	edx, DWORD PTR $T223877[ebp]
	cmp	edx, DWORD PTR $T223885[ebp]
	je	SHORT $LN167@Insert_n
	mov	eax, DWORD PTR __Tmp$218679[ebp]
	mov	ecx, DWORD PTR __Tmp$218679[ebp+4]
	mov	edx, DWORD PTR $T223877[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$218689[ebp], ecx
	mov	DWORD PTR __Tmp$218689[ebp+4], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$218690[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T223957[ebp], eax
	mov	ecx, DWORD PTR $T223957[ebp]
	mov	DWORD PTR $T223938[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T223942[ebp], dl
	mov	al, BYTE PTR __Cat$223945[ebp]
	mov	BYTE PTR $T223943[ebp], al
	mov	cl, BYTE PTR $T223942[ebp]
	mov	BYTE PTR $T223921[ebp], cl
	mov	edx, DWORD PTR $T223938[ebp]
	mov	DWORD PTR $T223920[ebp], edx
	mov	eax, DWORD PTR $T223920[ebp]
	mov	DWORD PTR $T223910[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$218690[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T223909[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T223951[ebp], al
	mov	cl, BYTE PTR __Cat$223954[ebp]
	mov	BYTE PTR $T223952[ebp], cl
	movzx	edx, BYTE PTR $T223951[ebp]
	push	edx
	movzx	eax, BYTE PTR $T223952[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T223910[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$218690[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223909[ebp]
	push	ecx
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$218690[ebp]
	mov	DWORD PTR $T224024[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T224023[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T224002[ebp], dl
	mov	al, BYTE PTR __Cat$224006[ebp]
	mov	BYTE PTR $T224003[ebp], al
	mov	cl, BYTE PTR $T224002[ebp]
	mov	BYTE PTR $T224000[ebp], cl
	mov	dl, BYTE PTR $T224004[ebp]
	mov	BYTE PTR $T223999[ebp], dl
	mov	eax, DWORD PTR $T224024[ebp]
	mov	DWORD PTR $T223998[ebp], eax
	mov	ecx, DWORD PTR $T224023[ebp]
	mov	DWORD PTR $T223997[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T224013[ebp], dl
	mov	al, BYTE PTR __Cat$224016[ebp]
	mov	BYTE PTR $T224014[ebp], al
	mov	cl, BYTE PTR $T224013[ebp]
	mov	BYTE PTR $T223985[ebp], cl
	mov	edx, DWORD PTR $T223998[ebp]
	mov	DWORD PTR $T223984[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$218690[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T223983[ebp], ecx
	mov	edx, DWORD PTR $T223997[ebp]
	mov	DWORD PTR $T223982[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T223982[ebp]
	cmp	eax, DWORD PTR $T223983[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T223983[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T223983[ebp], ecx
	mov	edx, DWORD PTR $T223984[ebp]
	sub	edx, 8
	mov	DWORD PTR $T223984[ebp], edx
	mov	eax, DWORD PTR $T223983[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T223984[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T224032[ebp], ecx
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	edx, DWORD PTR $T224032[ebp]
	add	edx, 8
	mov	DWORD PTR $T224032[ebp], edx
$LN204@Insert_n:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	cmp	DWORD PTR $T224032[ebp], edx
	je	SHORT $LN16@Insert_n
	mov	eax, DWORD PTR __Tmp$218689[ebp]
	mov	ecx, DWORD PTR __Tmp$218689[ebp+4]
	mov	edx, DWORD PTR $T224032[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@IAEXV?$_Vector_const_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@IABULeaderWithNumTechs@@@Z ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T224054 = -80						; size = 28
$T224053 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ PROC ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T224054[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T224053[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T224053[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T224054[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224053[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T224053[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T224053[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T224054[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T224054[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T224053[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@KAXXZ ENDP ; std::vector<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\eventsystem\fastdelegate.h
_TEXT	ENDS
;	COMDAT ??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_x$ = 12						; size = 4
_func$ = 16						; size = 4
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z PROC ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>, COMDAT

; 2030 : FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 

	push	ebp
	mov	ebp, esp

; 2031 : 	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _func$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2032 : }

	pop	ebp
	ret	0
??$MakeDelegate@VCvGame@@V1@HPBDH@fastdelegate@@YA?AV?$FastDelegate2@HPBDH@0@PAVCvGame@@P82@AEHHPBD@Z@Z ENDP ; fastdelegate::MakeDelegate<CvGame,CvGame,int,char const *,int>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z PROC ; std::stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 3570 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3571 : 	_DEBUG_RANGE(_First, _Last);
; 3572 : 	_DEBUG_POINTER(_Pred);
; 3573 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@stable_sor

; 3574 : 		{
; 3575 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 3576 : 			_Dist_type(_First), _Val_type(_First), _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H
$LN2@stable_sor:

; 3577 : 		}
; 3578 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@@Z ENDP ; std::stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z
_TEXT	SEGMENT
$T224319 = -16						; size = 4
$T224315 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z PROC ; std::_Allocate<LeaderWithNumTechs>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T224319[ebp], 0
	lea	eax, DWORD PTR $T224319[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224315[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T224315[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T224315[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@ULeaderWithNumTechs@@@std@@YAPAULeaderWithNumTechs@@IPAU1@@Z ENDP ; std::_Allocate<LeaderWithNumTechs>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
PUBLIC	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z$0
__ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T224484 = -120						; size = 4
__Next$224487 = -116					; size = 4
$T224369 = -56						; size = 4
$T224365 = -52						; size = 4
$T224352 = -48						; size = 4
$T224351 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 3560 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3561 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3562 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T224365[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T224352[ebp], ecx
	mov	edx, DWORD PTR $T224365[ebp]
	mov	DWORD PTR $T224351[ebp], edx
	mov	eax, DWORD PTR $T224352[ebp]
	sub	eax, DWORD PTR $T224351[ebp]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3563 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T224369[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	ecx, DWORD PTR $T224369[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], ecx
	lea	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3564 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H

; 3565 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$224487[ebp], edx
	jmp	SHORT $LN74@Stable_sor
$LN73@Stable_sor:
	mov	eax, DWORD PTR __Next$224487[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$224487[ebp], eax
$LN74@Stable_sor:
	mov	ecx, DWORD PTR __Next$224487[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN72@Stable_sor
	jmp	SHORT $LN73@Stable_sor
$LN72@Stable_sor:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T224484[ebp], edx
	mov	eax, DWORD PTR $T224484[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0PAHPAULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z
_TEXT	SEGMENT
$T224628 = -128						; size = 4
__Mid$219122 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$219122[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$219122[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$219122[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$219122[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$219122[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$219122[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$219122[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T224628[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T224628[ebp]
	sub	eax, 8
	mov	DWORD PTR $T224628[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T224628[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T224628[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T224628[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<int,80,1>::WeightedElement *,int>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T224725 = -28						; size = 4
__Vptr$224723 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$224723[ebp], eax
	mov	ecx, DWORD PTR __Vptr$224723[ebp]
	mov	DWORD PTR $T224725[ebp], ecx
	cmp	DWORD PTR $T224725[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T224725[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T224725[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAULeaderWithNumTechs@@IU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAXPAULeaderWithNumTechs@@IABU1@AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<LeaderWithNumTechs *,unsigned int,LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T224755 = -8						; size = 4
__Next$219261 = -4					; size = 4
??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$219261[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$219261[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$219261[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$219261[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224755[ebp], ecx
	mov	edx, DWORD PTR $T224755[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
PUBLIC	??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
PUBLIC	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
__Count2$219328 = -8					; size = 4
__Mid$219329 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z PROC ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 3529 : 	{	// sort preserving order of equivalents, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH

; 3530 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3531 : 		std::_Insertion_sort(_First, _Last, _Pred);	// small

	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
	add	esp, 16					; 00000010H

; 3532 : 	else

	jmp	$LN5@Stable_sor@2
$LN4@Stable_sor@2:

; 3533 : 		{	// sort halves and merge
; 3534 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$219328[ebp], eax

; 3535 : 		_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$219329[ebp], eax

; 3536 : 		std::advance(_Mid, _Count2);

	mov	ecx, DWORD PTR __Count2$219328[ebp]
	mov	edx, DWORD PTR __Mid$219329[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid$219329[ebp], eax

; 3537 : 
; 3538 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	DWORD PTR __Count2$219328[ebp], eax
	jg	SHORT $LN2@Stable_sor@2

; 3539 : 			{	// temp buffer big enough, sort each half using buffer
; 3540 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$219328[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$219329[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H

; 3541 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
; 3542 : 				_Tempbuf, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$219328[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$219329[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H

; 3543 : 			}
; 3544 : 		else

	jmp	SHORT $LN1@Stable_sor@2
$LN2@Stable_sor@2:

; 3545 : 			{	// temp buffer not big enough, divide and conquer
; 3546 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$219328[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$219329[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H

; 3547 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$219328[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$219329[ebp]
	push	edx
	call	??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 20					; 00000014H
$LN1@Stable_sor@2:

; 3548 : 			}
; 3549 : 
; 3550 : 		_Buffered_merge(_First, _Mid, _Last,
; 3551 : 			_Count2, _Count - _Count2, _Tempbuf, _Pred);	// merge halves

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$219328[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$219328[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$219329[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 28					; 0000001cH
$LN5@Stable_sor@2:

; 3552 : 		}
; 3553 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Stable_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z
_TEXT	SEGMENT
$T225426 = -124						; size = 4
__Tmp$225421 = -120					; size = 8
$T225406 = -112						; size = 4
$T225405 = -108						; size = 4
__Tmp$225400 = -104					; size = 8
$T225385 = -96						; size = 4
__Tmp$225380 = -92					; size = 8
$T225365 = -84						; size = 4
$T225364 = -80						; size = 4
__Tmp$225359 = -76					; size = 8
$T225344 = -68						; size = 4
$T225343 = -64						; size = 4
__Tmp$225338 = -60					; size = 8
$T225320 = -52						; size = 4
$T225319 = -48						; size = 4
__Tmp$225314 = -44					; size = 8
$T225293 = -36						; size = 4
__Tmp$225286 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T225293[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T225293[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T225293[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225286[ebp], edx
	mov	eax, DWORD PTR $T225293[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$225286[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T225293[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$225286[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$225286[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T225320[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225319[ebp], edx
	mov	eax, DWORD PTR $T225319[ebp]
	cmp	eax, DWORD PTR $T225320[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T225319[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225314[ebp], edx
	mov	eax, DWORD PTR $T225319[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$225314[ebp+4], ecx
	mov	edx, DWORD PTR $T225320[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T225319[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T225320[ebp]
	mov	ecx, DWORD PTR __Tmp$225314[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$225314[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T225344[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225343[ebp], eax
	mov	ecx, DWORD PTR $T225343[ebp]
	cmp	ecx, DWORD PTR $T225344[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T225343[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225338[ebp], eax
	mov	ecx, DWORD PTR $T225343[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225338[ebp+4], edx
	mov	eax, DWORD PTR $T225344[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T225343[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T225344[ebp]
	mov	edx, DWORD PTR __Tmp$225338[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$225338[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T225365[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225364[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T225364[ebp]
	cmp	eax, DWORD PTR $T225365[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T225364[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$225359[ebp], edx
	mov	eax, DWORD PTR $T225364[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$225359[ebp+4], ecx
	mov	edx, DWORD PTR $T225365[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T225364[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T225365[ebp]
	mov	ecx, DWORD PTR __Tmp$225359[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$225359[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225385[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T225385[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$225380[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$225380[ebp+4], eax
	mov	ecx, DWORD PTR $T225385[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T225385[ebp]
	mov	eax, DWORD PTR __Tmp$225380[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$225380[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T225406[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T225405[ebp], ecx
	mov	edx, DWORD PTR $T225405[ebp]
	cmp	edx, DWORD PTR $T225406[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T225405[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$225400[ebp], ecx
	mov	edx, DWORD PTR $T225405[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$225400[ebp+4], eax
	mov	ecx, DWORD PTR $T225406[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T225405[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T225406[ebp]
	mov	eax, DWORD PTR __Tmp$225400[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$225400[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T225426[ebp], eax
	mov	ecx, DWORD PTR $T225426[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T225426[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$225421[ebp], eax
	mov	ecx, DWORD PTR $T225426[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225421[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T225426[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$225421[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$225421[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z ; std::get_temporary_buffer<LeaderWithNumTechs>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$219519 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ PROC ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$219519[ebp]
	push	ecx
	call	??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z ; std::get_temporary_buffer<LeaderWithNumTechs>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$219519[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$219519[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$219519[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$219519[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
PUBLIC	??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
tv144 = -216						; size = 4
$T225873 = -61						; size = 1
$T225544 = -60						; size = 4
$T225540 = -56						; size = 4
$T225503 = -32						; size = 4
$T225483 = -28						; size = 4
$T225440 = -20						; size = 4
__Chunk$219594 = -16					; size = 4
__Midn$219592 = -12					; size = 4
__Nleft$219588 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z PROC ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 3502 : 	{	// sort using temp buffer for merges, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H

; 3503 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3504 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$219588[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$219588[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$219588[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$219588[ebp], 32	; 00000020H
	jl	SHORT $LN26@Buffered_m

; 3505 : 		{	// sort chunks
; 3506 : 		_BidIt _Midn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midn$219592[ebp], eax

; 3507 : 		std::advance(_Midn, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	shl	ecx, 3
	add	ecx, DWORD PTR __Midn$219592[ebp]
	mov	DWORD PTR __Midn$219592[ebp], ecx

; 3508 : 
; 3509 : 		std::_Insertion_sort(_Mid, _Midn, _Pred);

	mov	edx, DWORD PTR __Midn$219592[ebp]
	mov	DWORD PTR $T225483[ebp], edx
	push	0
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T225483[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
	add	esp, 16					; 00000010H

; 3510 : 		_Mid = _Midn;

	mov	eax, DWORD PTR __Midn$219592[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3511 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3512 : 	std::_Insertion_sort(_Mid, _Last, _Pred);	// sort partial last chunk

$LN26@Buffered_m:
	push	0
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	call	??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
	add	esp, 16					; 00000010H

; 3513 : 
; 3514 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$219594[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	ecx, DWORD PTR __Chunk$219594[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$219594[ebp], ecx
$LN3@Buffered_m:
	mov	edx, DWORD PTR __Chunk$219594[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3515 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3516 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3517 : 			_Chunk, _Count, _Pred);

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$219594[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T225440[ebp], esp
	mov	DWORD PTR $T225503[ebp], edx
	mov	eax, DWORD PTR $T225503[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T225503[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T225503[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T225503[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T225503[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T225503[ebp]
	mov	DWORD PTR tv144[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
	add	esp, 40					; 00000028H

; 3518 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3519 : 			_Chunk *= 2, _Count, _Pred);

	mov	ecx, DWORD PTR __Chunk$219594[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$219594[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T225540[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T225544[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T225873[ebp], dl
	movzx	eax, BYTE PTR $T225873[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$219594[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T225540[ebp]
	push	edx
	mov	eax, DWORD PTR $T225544[ebp]
	push	eax
	call	??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
	add	esp, 28					; 0000001cH

; 3520 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0HAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Buffered_merge_sort<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
PUBLIC	??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
PUBLIC	??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
PUBLIC	??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
PUBLIC	??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
tv244 = -344						; size = 4
tv243 = -340						; size = 4
tv240 = -336						; size = 4
tv239 = -332						; size = 4
$T226252 = -272						; size = 4
$T226239 = -268						; size = 4
$T226238 = -264						; size = 4
$T226216 = -257						; size = 1
$T226215 = -256						; size = 4
$T226214 = -252						; size = 4
$T226210 = -248						; size = 4
$T226203 = -244						; size = 4
$T226161 = -236						; size = 4
$T226148 = -232						; size = 4
$T226147 = -228						; size = 4
$T226125 = -221						; size = 1
$T226124 = -220						; size = 4
$T226120 = -216						; size = 4
$T226113 = -212						; size = 4
$T226055 = -205						; size = 1
$T226054 = -204						; size = 4
$T226053 = -200						; size = 4
$T226051 = -193						; size = 1
$T226047 = -192						; size = 4
$T226043 = -188						; size = 4
$T226028 = -184						; size = 4
__Next$226031 = -180					; size = 4
$T226020 = -176						; size = 4
$T226007 = -161						; size = 1
$T226006 = -160						; size = 4
$T226005 = -156						; size = 4
$T226004 = -152						; size = 4
$T225999 = -146						; size = 1
$T225998 = -145						; size = 1
$T225989 = -144						; size = 4
$T225985 = -140						; size = 4
$T225970 = -136						; size = 4
__Next$225973 = -132					; size = 4
$T225962 = -128						; size = 4
$T225949 = -116						; size = 4
$T225948 = -112						; size = 4
$T225933 = -108						; size = 4
__Tmp$225945 = -104					; size = 8
$T225919 = -96						; size = 4
$T225906 = -92						; size = 4
$T225897 = -88						; size = 4
$T225884 = -84						; size = 4
$T225883 = -80						; size = 4
$T225882 = -76						; size = 4
$T225881 = -72						; size = 20
$T225880 = -52						; size = 4
$T225879 = -48						; size = 4
$T225878 = -44						; size = 20
$T225877 = -24						; size = 4
__Firstn$219674 = -20					; size = 4
__Count2n$219677 = -16					; size = 4
__Midn$219700 = -12					; size = 4
__Lastn$219675 = -8					; size = 4
__Count1n$219676 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z PROC ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>, COMDAT

; 2889 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H

; 2890 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2891 : 		{	// order two one-element partitions
; 2892 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225897[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T225906[ebp], edx
	mov	eax, DWORD PTR $T225906[ebp]
	mov	ecx, DWORD PTR $T225897[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@Buffered_m@2

; 2893 : 			std::iter_swap(_First, _Mid);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T225949[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T225948[ebp], eax
	mov	ecx, DWORD PTR $T225949[ebp]
	mov	DWORD PTR $T225919[ebp], ecx
	mov	edx, DWORD PTR $T225948[ebp]
	mov	DWORD PTR $T225933[ebp], edx
	mov	eax, DWORD PTR $T225933[ebp]
	cmp	eax, DWORD PTR $T225919[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	ecx, DWORD PTR $T225933[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$225945[ebp], edx
	mov	DWORD PTR __Tmp$225945[ebp+4], eax
	mov	ecx, DWORD PTR $T225919[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T225933[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T225919[ebp]
	mov	eax, DWORD PTR __Tmp$225945[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$225945[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN8@Buffered_m@2:

; 2894 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2895 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	edx, DWORD PTR __Count1$[ebp]
	cmp	edx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2896 : 		{	// buffer left partition, then merge
; 2897 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T225877[ebp], esp
	mov	DWORD PTR $T225962[ebp], edx
	mov	eax, DWORD PTR $T225962[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T225962[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T225962[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T225962[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T225962[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T225962[ebp]
	mov	DWORD PTR tv239[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225878[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv240[ebp], eax
	cmp	DWORD PTR $T225878[ebp], 0
	je	SHORT $LN52@Buffered_m@2
	mov	edx, DWORD PTR $T225878[ebp]
	mov	DWORD PTR __Next$225973[ebp], edx
	jmp	SHORT $LN50@Buffered_m@2
$LN49@Buffered_m@2:
	mov	eax, DWORD PTR __Next$225973[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$225973[ebp], eax
$LN50@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$225973[ebp]
	cmp	ecx, DWORD PTR $T225878[ebp+8]
	je	SHORT $LN48@Buffered_m@2
	jmp	SHORT $LN49@Buffered_m@2
$LN48@Buffered_m@2:
	mov	edx, DWORD PTR $T225878[ebp]
	mov	DWORD PTR $T225970[ebp], edx
	mov	eax, DWORD PTR $T225970[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@Buffered_m@2:

; 2898 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2899 : 			_Mid, _Last, _First, _Pred);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T225985[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T225989[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T226007[ebp], cl
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226006[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T226005[ebp], eax
	mov	ecx, DWORD PTR $T225989[ebp]
	mov	DWORD PTR $T226004[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T225998[ebp], dl
	movzx	eax, BYTE PTR $T225998[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T225999[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T226007[ebp]
	push	edx
	mov	eax, DWORD PTR $T226006[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226005[ebp]
	push	edx
	mov	eax, DWORD PTR $T225985[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226004[ebp]
	push	ecx
	lea	edx, DWORD PTR $T225879[ebp]
	push	edx
	call	??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H

; 2900 : 		}
; 2901 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2902 : 		{	// buffer right partition, then merge
; 2903 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T225880[ebp], esp
	mov	DWORD PTR $T226020[ebp], edx
	mov	eax, DWORD PTR $T226020[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T226020[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T226020[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T226020[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T226020[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T226020[ebp]
	mov	DWORD PTR tv243[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T225881[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv244[ebp], eax
	cmp	DWORD PTR $T225881[ebp], 0
	je	SHORT $LN79@Buffered_m@2
	mov	edx, DWORD PTR $T225881[ebp]
	mov	DWORD PTR __Next$226031[ebp], edx
	jmp	SHORT $LN77@Buffered_m@2
$LN76@Buffered_m@2:
	mov	eax, DWORD PTR __Next$226031[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$226031[ebp], eax
$LN77@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$226031[ebp]
	cmp	ecx, DWORD PTR $T225881[ebp+8]
	je	SHORT $LN75@Buffered_m@2
	jmp	SHORT $LN76@Buffered_m@2
$LN75@Buffered_m@2:
	mov	edx, DWORD PTR $T225881[ebp]
	mov	DWORD PTR $T226028[ebp], edx
	mov	eax, DWORD PTR $T226028[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN79@Buffered_m@2:

; 2904 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid, _Tempbuf._First(), _Tempbuf._Last(),
; 2905 : 			_Last, _Pred);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T226043[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T226047[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T226055[ebp], cl
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T226054[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226053[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226051[ebp], cl
	movzx	edx, BYTE PTR $T226051[ebp]
	push	edx
	movzx	eax, BYTE PTR $T226055[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226043[ebp]
	push	edx
	mov	eax, DWORD PTR $T226047[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226054[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226053[ebp]
	push	edx
	lea	eax, DWORD PTR $T225882[ebp]
	push	eax
	call	??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
	add	esp, 32					; 00000020H

; 2906 : 		}
; 2907 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2908 : 		{	// buffer too small, divide and conquer
; 2909 : 		_BidIt _Firstn, _Lastn;

	mov	DWORD PTR __Firstn$219674[ebp], 0
	mov	DWORD PTR __Lastn$219675[ebp], 0

; 2910 : 		_Diff _Count1n, _Count2n;
; 2911 : 		if (_Count2 < _Count1)

	mov	ecx, DWORD PTR __Count2$[ebp]
	cmp	ecx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@2

; 2912 : 			{	// left larger, cut it in half and partition right to match
; 2913 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$219676[ebp], eax
	mov	DWORD PTR __Count2n$219677[ebp], 0

; 2914 : 			_Firstn = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$219674[ebp], edx

; 2915 : 			std::advance(_Firstn, _Count1n);

	mov	eax, DWORD PTR __Count1n$219676[ebp]
	mov	ecx, DWORD PTR __Firstn$219674[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Firstn$219674[ebp], edx

; 2916 : 			_Lastn = lower_bound(_Mid, _Last, *_Firstn, _Pred);

	mov	eax, DWORD PTR __Firstn$219674[ebp]
	mov	DWORD PTR $T226113[ebp], eax
	mov	cl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T226125[ebp], cl
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T226124[ebp], edx
	push	0
	movzx	eax, BYTE PTR $T226125[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226113[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T226124[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226120[ebp]
	push	ecx
	call	??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T226124[ebp], edx
	mov	eax, DWORD PTR $T226124[ebp]
	mov	DWORD PTR $T225883[ebp], eax
	mov	ecx, DWORD PTR $T225883[ebp]
	mov	DWORD PTR __Lastn$219675[ebp], ecx

; 2917 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T226161[ebp], edx
	mov	eax, DWORD PTR __Lastn$219675[ebp]
	mov	DWORD PTR $T226148[ebp], eax
	mov	ecx, DWORD PTR $T226161[ebp]
	mov	DWORD PTR $T226147[ebp], ecx
	mov	edx, DWORD PTR $T226148[ebp]
	sub	edx, DWORD PTR $T226147[ebp]
	sar	edx, 3
	add	edx, DWORD PTR __Count2n$219677[ebp]
	mov	DWORD PTR __Count2n$219677[ebp], edx

; 2918 : 			}
; 2919 : 		else

	jmp	$LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2920 : 			{	// right larger, cut it in half and partition left to match
; 2921 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$219676[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$219677[ebp], eax

; 2922 : 			_Lastn = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$219675[ebp], eax

; 2923 : 			std::advance(_Lastn, _Count2n);

	mov	ecx, DWORD PTR __Count2n$219677[ebp]
	mov	edx, DWORD PTR __Lastn$219675[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Lastn$219675[ebp], eax

; 2924 : 			_Firstn = upper_bound(_First, _Mid, *_Lastn, _Pred);

	mov	ecx, DWORD PTR __Lastn$219675[ebp]
	mov	DWORD PTR $T226203[ebp], ecx
	mov	dl, BYTE PTR __Pred$[ebp]
	mov	BYTE PTR $T226216[ebp], dl
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T226215[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226214[ebp], ecx
	push	0
	movzx	edx, BYTE PTR $T226216[ebp]
	push	edx
	mov	eax, DWORD PTR $T226203[ebp]
	push	eax
	mov	ecx, DWORD PTR $T226215[ebp]
	push	ecx
	mov	edx, DWORD PTR $T226214[ebp]
	push	edx
	lea	eax, DWORD PTR $T226210[ebp]
	push	eax
	call	??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T226214[ebp], ecx
	mov	edx, DWORD PTR $T226214[ebp]
	mov	DWORD PTR $T225884[ebp], edx
	mov	eax, DWORD PTR $T225884[ebp]
	mov	DWORD PTR __Firstn$219674[ebp], eax

; 2925 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226252[ebp], ecx
	mov	edx, DWORD PTR __Firstn$219674[ebp]
	mov	DWORD PTR $T226239[ebp], edx
	mov	eax, DWORD PTR $T226252[ebp]
	mov	DWORD PTR $T226238[ebp], eax
	mov	ecx, DWORD PTR $T226239[ebp]
	sub	ecx, DWORD PTR $T226238[ebp]
	sar	ecx, 3
	add	ecx, DWORD PTR __Count1n$219676[ebp]
	mov	DWORD PTR __Count1n$219676[ebp], ecx
$LN1@Buffered_m@2:

; 2926 : 			}
; 2927 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2928 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$219677[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$219676[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$219675[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$219674[ebp]
	push	ecx
	lea	edx, DWORD PTR __Midn$219700[ebp]
	push	edx
	call	??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
	add	esp, 28					; 0000001cH

; 2929 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2930 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part

	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2n$219677[ebp]
	push	edx
	mov	eax, DWORD PTR __Count1n$219676[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$219700[ebp]
	push	ecx
	mov	edx, DWORD PTR __Firstn$219674[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 28					; 0000001cH

; 2931 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2932 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$[ebp]
	sub	eax, DWORD PTR __Count2n$219677[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$219676[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$219675[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$219700[ebp]
	push	ecx
	call	??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
	add	esp, 28					; 0000001cH
$LN10@Buffered_m@2:

; 2933 : 		}
; 2934 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@ULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@ULeaderWithNumTechsEval@@@Z ENDP ; std::_Buffered_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
__Step$219716 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$219716[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$219716[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$219716[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$219716[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$219716[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$219716[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$219716[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$219716[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$219716[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<int,80,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z
_TEXT	SEGMENT
$T226576 = -20						; size = 4
$T226575 = -16						; size = 4
__Hole$219734 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$219734[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$219734[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$219734[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$219734[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$219734[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T226576[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T226575[ebp], esp
	mov	edx, DWORD PTR $T226575[ebp]
	mov	eax, DWORD PTR $T226576[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T226575[ebp]
	mov	eax, DWORD PTR $T226576[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$219734[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
$T226646 = -52						; size = 4
$T226645 = -48						; size = 4
$T226629 = -42						; size = 1
$T226628 = -41						; size = 1
$T226627 = -40						; size = 4
$T226626 = -36						; size = 4
$T226625 = -32						; size = 4
__Cat$226637 = -24					; size = 1
$T226634 = -23						; size = 1
$T226633 = -22						; size = 1
$T226632 = -21						; size = 1
__First1$219775 = -20					; size = 4
__Val$219765 = -16					; size = 8
__Next1$219764 = -8					; size = 4
__Next$219760 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$219760[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$219760[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$219760[ebp], edx
	mov	eax, DWORD PTR __Next$219760[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$219760[ebp]
	mov	DWORD PTR __Next1$219764[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$219760[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$219765[ebp], eax
	mov	ecx, DWORD PTR __Next$219760[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$219765[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$219765[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$219764[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$219764[ebp], ecx
	mov	edx, DWORD PTR __Next1$219764[ebp]
	mov	DWORD PTR $T226646[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226645[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T226632[ebp], cl
	mov	dl, BYTE PTR __Cat$226637[ebp]
	mov	BYTE PTR $T226633[ebp], dl
	mov	al, BYTE PTR $T226632[ebp]
	mov	BYTE PTR $T226629[ebp], al
	mov	cl, BYTE PTR $T226634[ebp]
	mov	BYTE PTR $T226628[ebp], cl
	mov	edx, DWORD PTR $T226646[ebp]
	mov	DWORD PTR $T226627[ebp], edx
	mov	eax, DWORD PTR __Next$219760[ebp]
	mov	DWORD PTR $T226626[ebp], eax
	mov	ecx, DWORD PTR $T226645[ebp]
	mov	DWORD PTR $T226625[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T226625[ebp]
	cmp	edx, DWORD PTR $T226626[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T226626[ebp]
	sub	eax, 8
	mov	DWORD PTR $T226626[ebp], eax
	mov	ecx, DWORD PTR $T226627[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T226627[ebp], ecx
	mov	edx, DWORD PTR $T226626[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T226627[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$219765[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$219765[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$219764[ebp]
	mov	DWORD PTR __First1$219775[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$219775[ebp]
	mov	DWORD PTR __Next1$219764[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$219775[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$219775[ebp], edx
	mov	eax, DWORD PTR __First1$219775[ebp]
	mov	ecx, DWORD PTR __Val$219765[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$219775[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$219764[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$219764[ebp]
	mov	eax, DWORD PTR __Val$219765[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$219765[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z
_TEXT	SEGMENT
__Cat$226656 = -3					; size = 1
$T226653 = -2						; size = 1
$T226652 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T226652[ebp], al
	mov	cl, BYTE PTR __Cat$226656[ebp]
	mov	BYTE PTR $T226653[ebp], cl
	movzx	edx, BYTE PTR $T226652[ebp]
	push	edx
	movzx	eax, BYTE PTR $T226653[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@stdext@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
_TEXT	ENDS
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Odtp
;	COMDAT ??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z
_TEXT	SEGMENT
$T226664 = -20						; size = 4
$T226660 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z PROC ; std::get_temporary_buffer<LeaderWithNumTechs>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T226664[ebp], 0
	lea	eax, DWORD PTR $T226664[ebp]
	push	eax
	lea	ecx, DWORD PTR $T226660[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T226660[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T226660[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 3
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@ULeaderWithNumTechs@@@std@@YA?AU?$pair@PAULeaderWithNumTechs@@H@0@H@Z ENDP ; std::get_temporary_buffer<LeaderWithNumTechs>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
$T226880 = -76						; size = 4
$T226868 = -72						; size = 4
$T226843 = -68						; size = 4
$T226842 = -64						; size = 4
$T226841 = -60						; size = 4
$T226805 = -54						; size = 1
$T226804 = -53						; size = 1
$T226803 = -52						; size = 4
$T226802 = -48						; size = 4
$T226801 = -44						; size = 4
$T226760 = -40						; size = 4
__Cat$226813 = -32					; size = 1
$T226810 = -31						; size = 1
$T226809 = -30						; size = 1
$T226808 = -29						; size = 1
$T226711 = -28						; size = 4
$T226670 = -24						; size = 4
__First1$219867 = -20					; size = 4
__Val$219856 = -16					; size = 8
__Next1$219855 = -8					; size = 4
__Next$219851 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
___formal$ = 20						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>, COMDAT

; 3123 : 	{	// insertion sort [_First, _Last), using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 3124 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@2

; 3125 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$219851[ebp], ecx
$LN7@Insertion_@2:
	mov	edx, DWORD PTR __Next$219851[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$219851[ebp], edx
	mov	eax, DWORD PTR __Next$219851[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN9@Insertion_@2

; 3126 : 			{	// order next element
; 3127 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$219851[ebp]
	mov	DWORD PTR __Next1$219855[ebp], ecx

; 3128 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$219851[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$219856[ebp], eax
	mov	DWORD PTR __Val$219856[ebp+4], ecx

; 3129 : 
; 3130 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226711[ebp], edx
	mov	eax, DWORD PTR $T226711[ebp]
	mov	ecx, DWORD PTR __Val$219856[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN5@Insertion_@2

; 3131 : 				{	// found new earliest element, move to front
; 3132 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$219855[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$219855[ebp], ecx
	mov	edx, DWORD PTR __Next1$219855[ebp]
	mov	DWORD PTR $T226843[ebp], edx
	mov	eax, DWORD PTR __Next$219851[ebp]
	mov	DWORD PTR $T226842[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T226841[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T226808[ebp], dl
	mov	al, BYTE PTR __Cat$226813[ebp]
	mov	BYTE PTR $T226809[ebp], al
	mov	cl, BYTE PTR $T226808[ebp]
	mov	BYTE PTR $T226805[ebp], cl
	mov	dl, BYTE PTR $T226810[ebp]
	mov	BYTE PTR $T226804[ebp], dl
	mov	eax, DWORD PTR $T226843[ebp]
	mov	DWORD PTR $T226803[ebp], eax
	mov	ecx, DWORD PTR $T226842[ebp]
	mov	DWORD PTR $T226802[ebp], ecx
	mov	edx, DWORD PTR $T226841[ebp]
	mov	DWORD PTR $T226801[ebp], edx
$LN47@Insertion_@2:
	mov	eax, DWORD PTR $T226801[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T226802[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN43@Insertion_@2
	mov	ecx, DWORD PTR $T226802[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T226802[ebp], ecx
	mov	edx, DWORD PTR $T226802[ebp]
	mov	DWORD PTR $T226760[ebp], edx
	mov	eax, DWORD PTR $T226803[ebp]
	sub	eax, 8
	mov	DWORD PTR $T226803[ebp], eax
	mov	ecx, DWORD PTR $T226760[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T226803[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN47@Insertion_@2
$LN43@Insertion_@2:
	mov	edx, DWORD PTR $T226803[ebp]
	mov	DWORD PTR $T226670[ebp], edx

; 3133 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$219856[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$219856[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 3134 : 				}
; 3135 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 3136 : 				{	// look for insertion point after first
; 3137 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$219855[ebp]
	mov	DWORD PTR __First1$219867[ebp], eax

; 3138 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3139 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@2
$LN2@Insertion_@2:
	mov	ecx, DWORD PTR __First1$219867[ebp]
	mov	DWORD PTR __Next1$219855[ebp], ecx
$LN3@Insertion_@2:
	mov	edx, DWORD PTR __First1$219867[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$219867[ebp], edx
	mov	eax, DWORD PTR __First1$219867[ebp]
	mov	DWORD PTR $T226868[ebp], eax
	mov	ecx, DWORD PTR $T226868[ebp]
	mov	edx, DWORD PTR __Val$219856[ebp+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN89@Insertion_@2

; 3140 : 					*_Next1 = *_First1;	// move hole down

	mov	edx, DWORD PTR __First1$219867[ebp]
	mov	DWORD PTR $T226880[ebp], edx
	mov	eax, DWORD PTR $T226880[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Next1$219855[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Insertion_@2

; 3141 : 				*_Next1 = _Val;	// insert element in hole

$LN89@Insertion_@2:
	mov	ecx, DWORD PTR __Next1$219855[ebp]
	mov	edx, DWORD PTR __Val$219856[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$219856[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN4@Insertion_@2:

; 3142 : 				}
; 3143 : 			}

	jmp	$LN7@Insertion_@2
$LN9@Insertion_@2:

; 3144 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@ULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0ULeaderWithNumTechsEval@@PAULeaderWithNumTechs@@@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,LeaderWithNumTechs>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
tv94 = -160						; size = 4
$T227092 = -156						; size = 4
__Next$227095 = -152					; size = 4
$T226911 = -24						; size = 4
$T226900 = -20						; size = 4
$T226899 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z PROC ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>, COMDAT

; 5285 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5286 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _Pred, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T226899[ebp], al
	movzx	ecx, BYTE PTR $T226899[ebp]
	push	ecx
	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Chunk$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T226900[ebp], esp
	mov	DWORD PTR $T226911[ebp], edx
	mov	eax, DWORD PTR $T226911[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T226911[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T226911[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T226911[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T226911[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T226911[ebp]
	mov	DWORD PTR tv94[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
	add	esp, 44					; 0000002cH

; 5287 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$227095[ebp], eax
	jmp	SHORT $LN85@Unchecked_
$LN84@Unchecked_:
	mov	ecx, DWORD PTR __Next$227095[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$227095[ebp], ecx
$LN85@Unchecked_:
	mov	edx, DWORD PTR __Next$227095[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN83@Unchecked_
	jmp	SHORT $LN84@Unchecked_
$LN83@Unchecked_:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227092[ebp], eax
	mov	ecx, DWORD PTR $T227092[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@stdext@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@0V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HHULeaderWithNumTechsEval@@@Z ENDP ; stdext::_Unchecked_chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T227145 = -40						; size = 4
__Next$227148 = -36					; size = 4
$T227137 = -32						; size = 4
__Cat$227123 = -25					; size = 1
$T227119 = -24						; size = 4
$T227115 = -20						; size = 4
$T227114 = -15						; size = 1
$T227113 = -14						; size = 1
$T227112 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z PROC ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T227119[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T227112[ebp], al
	mov	cl, BYTE PTR __Cat$227123[ebp]
	mov	BYTE PTR $T227113[ebp], cl
	movzx	edx, BYTE PTR $T227112[ebp]
	push	edx
	movzx	eax, BYTE PTR $T227113[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T227114[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T227115[ebp], esp
	mov	DWORD PTR $T227137[ebp], edx
	mov	eax, DWORD PTR $T227137[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T227137[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T227137[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T227137[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T227137[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T227137[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T227119[ebp]
	or	ecx, 1
	mov	DWORD PTR $T227119[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$227148[ebp], edx
	jmp	SHORT $LN17@unchecked_
$LN16@unchecked_:
	mov	eax, DWORD PTR __Next$227148[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$227148[ebp], eax
$LN17@unchecked_:
	mov	ecx, DWORD PTR __Next$227148[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_
	jmp	SHORT $LN16@unchecked_
$LN15@unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227145[ebp], edx
	mov	eax, DWORD PTR $T227145[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ENDP ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
PUBLIC	??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z
_TEXT	SEGMENT
tv180 = -256						; size = 4
tv179 = -252						; size = 4
tv176 = -248						; size = 4
tv175 = -244						; size = 4
$T227510 = -236						; size = 4
$T227509 = -232						; size = 4
$T227508 = -228						; size = 4
$T227486 = -221						; size = 1
$T227485 = -220						; size = 4
$T227484 = -216						; size = 4
$T227483 = -212						; size = 4
$T227488 = -205						; size = 1
$T227447 = -204						; size = 4
$T227446 = -200						; size = 4
$T227421 = -194						; size = 1
$T227420 = -193						; size = 1
$T227419 = -192						; size = 4
$T227418 = -188						; size = 4
__Cat$227428 = -180					; size = 1
$T227425 = -179						; size = 1
$T227424 = -178						; size = 1
$T227423 = -177						; size = 1
$T227375 = -176						; size = 4
$T227371 = -172						; size = 4
$T227367 = -168						; size = 4
$T227366 = -164						; size = 4
__Cat$227361 = -156					; size = 1
$T227358 = -155						; size = 1
$T227357 = -154						; size = 1
$T227356 = -153						; size = 1
$T227331 = -152						; size = 4
__Next$227336 = -148					; size = 4
$T227323 = -144						; size = 4
$T227310 = -132						; size = 4
$T227309 = -128						; size = 4
$T227285 = -122						; size = 1
$T227284 = -121						; size = 1
$T227283 = -120						; size = 4
$T227282 = -116						; size = 4
$T227281 = -112						; size = 4
__Cat$227292 = -104					; size = 1
$T227290 = -103						; size = 1
$T227289 = -102						; size = 1
$T227288 = -101						; size = 1
$T227239 = -100						; size = 4
$T227235 = -96						; size = 4
$T227231 = -92						; size = 4
$T227230 = -88						; size = 4
__Cat$227225 = -80					; size = 1
$T227223 = -79						; size = 1
$T227222 = -78						; size = 1
$T227221 = -77						; size = 1
$T227195 = -76						; size = 4
__Next$227198 = -72					; size = 4
$T227187 = -68						; size = 4
$T227170 = -56						; size = 4
$T227169 = -52						; size = 20
$T227168 = -32						; size = 4
$T227167 = -28						; size = 4
$T227166 = -24						; size = 20
$T227165 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Mid$ = 16						; size = 4
__Last$ = 20						; size = 4
__Count1$ = 24						; size = 4
__Count2$ = 28						; size = 4
__Tempbuf$ = 32						; size = 4
??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z PROC ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T227165[ebp], esp
	mov	DWORD PTR $T227187[ebp], eax
	mov	ecx, DWORD PTR $T227187[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T227187[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T227187[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T227187[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T227187[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T227187[ebp]
	mov	DWORD PTR tv175[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227166[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv176[ebp], eax
	cmp	DWORD PTR $T227166[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T227166[ebp]
	mov	DWORD PTR __Next$227198[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$227198[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$227198[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$227198[ebp]
	cmp	edx, DWORD PTR $T227166[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T227166[ebp]
	mov	DWORD PTR $T227195[ebp], eax
	mov	ecx, DWORD PTR $T227195[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227231[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T227230[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227221[ebp], cl
	mov	dl, BYTE PTR __Cat$227225[ebp]
	mov	BYTE PTR $T227222[ebp], dl
	movzx	eax, BYTE PTR $T227221[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T227222[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T227223[ebp]
	push	edx
	mov	eax, DWORD PTR $T227231[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227230[ebp]
	push	edx
	lea	eax, DWORD PTR $T227167[ebp]
	push	eax
	call	??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227235[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227239[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T227310[ebp], ecx
	mov	edx, DWORD PTR $T227239[ebp]
	mov	DWORD PTR $T227309[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T227288[ebp], al
	mov	cl, BYTE PTR __Cat$227292[ebp]
	mov	BYTE PTR $T227289[ebp], cl
	mov	dl, BYTE PTR $T227288[ebp]
	mov	BYTE PTR $T227285[ebp], dl
	mov	al, BYTE PTR $T227290[ebp]
	mov	BYTE PTR $T227284[ebp], al
	mov	ecx, DWORD PTR $T227310[ebp]
	mov	DWORD PTR $T227283[ebp], ecx
	mov	edx, DWORD PTR $T227235[ebp]
	mov	DWORD PTR $T227282[ebp], edx
	mov	eax, DWORD PTR $T227309[ebp]
	mov	DWORD PTR $T227281[ebp], eax
$LN47@Buffered_r:
	mov	ecx, DWORD PTR $T227281[ebp]
	cmp	ecx, DWORD PTR $T227282[ebp]
	je	SHORT $LN46@Buffered_r
	mov	edx, DWORD PTR $T227282[ebp]
	sub	edx, 8
	mov	DWORD PTR $T227282[ebp], edx
	mov	eax, DWORD PTR $T227283[ebp]
	sub	eax, 8
	mov	DWORD PTR $T227283[ebp], eax
	mov	ecx, DWORD PTR $T227282[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T227283[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN47@Buffered_r
$LN46@Buffered_r:
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T227283[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEHXZ ; std::_Temp_iterator<LeaderWithNumTechs>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T227168[ebp], esp
	mov	DWORD PTR $T227323[ebp], eax
	mov	ecx, DWORD PTR $T227323[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T227323[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T227323[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T227323[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T227323[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T227323[ebp]
	mov	DWORD PTR tv179[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227169[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv180[ebp], eax
	cmp	DWORD PTR $T227169[ebp], 0
	je	SHORT $LN71@Buffered_r
	mov	eax, DWORD PTR $T227169[ebp]
	mov	DWORD PTR __Next$227336[ebp], eax
	jmp	SHORT $LN69@Buffered_r
$LN68@Buffered_r:
	mov	ecx, DWORD PTR __Next$227336[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$227336[ebp], ecx
$LN69@Buffered_r:
	mov	edx, DWORD PTR __Next$227336[ebp]
	cmp	edx, DWORD PTR $T227169[ebp+8]
	je	SHORT $LN67@Buffered_r
	jmp	SHORT $LN68@Buffered_r
$LN67@Buffered_r:
	mov	eax, DWORD PTR $T227169[ebp]
	mov	DWORD PTR $T227331[ebp], eax
	mov	ecx, DWORD PTR $T227331[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN71@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T227367[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227366[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T227356[ebp], cl
	mov	dl, BYTE PTR __Cat$227361[ebp]
	mov	BYTE PTR $T227357[ebp], dl
	movzx	eax, BYTE PTR $T227356[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T227357[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T227358[ebp]
	push	edx
	mov	eax, DWORD PTR $T227367[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227366[ebp]
	push	edx
	lea	eax, DWORD PTR $T227170[ebp]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T227371[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T227375[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227447[ebp], ecx
	mov	edx, DWORD PTR $T227375[ebp]
	mov	DWORD PTR $T227446[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T227423[ebp], al
	mov	cl, BYTE PTR __Cat$227428[ebp]
	mov	BYTE PTR $T227424[ebp], cl
	mov	dl, BYTE PTR $T227423[ebp]
	mov	BYTE PTR $T227421[ebp], dl
	mov	al, BYTE PTR $T227425[ebp]
	mov	BYTE PTR $T227420[ebp], al
	mov	ecx, DWORD PTR $T227447[ebp]
	mov	DWORD PTR $T227419[ebp], ecx
	mov	edx, DWORD PTR $T227446[ebp]
	mov	DWORD PTR $T227418[ebp], edx
	jmp	SHORT $LN95@Buffered_r
$LN94@Buffered_r:
	mov	eax, DWORD PTR $T227419[ebp]
	add	eax, 8
	mov	DWORD PTR $T227419[ebp], eax
	mov	ecx, DWORD PTR $T227418[ebp]
	add	ecx, 8
	mov	DWORD PTR $T227418[ebp], ecx
$LN95@Buffered_r:
	mov	edx, DWORD PTR $T227418[ebp]
	cmp	edx, DWORD PTR $T227371[ebp]
	je	SHORT $LN93@Buffered_r
	mov	eax, DWORD PTR $T227418[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T227419[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN94@Buffered_r
$LN93@Buffered_r:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T227419[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	$LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T227510[ebp], eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T227509[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T227508[ebp], edx
	mov	eax, DWORD PTR $T227508[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR $T227509[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN127@Buffered_r
	mov	ecx, DWORD PTR $T227509[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T227510[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN127@Buffered_r
	mov	dl, BYTE PTR $T227488[ebp]
	mov	BYTE PTR $T227486[ebp], dl
	mov	eax, DWORD PTR $T227510[ebp]
	mov	DWORD PTR $T227485[ebp], eax
	mov	ecx, DWORD PTR $T227509[ebp]
	mov	DWORD PTR $T227484[ebp], ecx
	mov	edx, DWORD PTR $T227508[ebp]
	mov	DWORD PTR $T227483[ebp], edx
	push	0
	push	0
	mov	eax, DWORD PTR $T227485[ebp]
	push	eax
	mov	ecx, DWORD PTR $T227484[ebp]
	push	ecx
	mov	edx, DWORD PTR $T227483[ebp]
	push	edx
	call	??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN127@Buffered_r:
	mov	eax, DWORD PTR __Count2$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __First$[ebp], edx

; 2701 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00HHAAV?$_Temp_iterator@ULeaderWithNumTechs@@@0@@Z ENDP ; std::_Buffered_rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
__Tmp$227607 = -24					; size = 8
__Tmp$227585 = -16					; size = 8
__Tmp$227563 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$227563[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$227563[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$227563[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$227563[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$227585[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$227585[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$227585[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$227585[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227607[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$227607[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$227607[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$227607[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<int,80,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z
_TEXT	SEGMENT
$T227635 = -32						; size = 4
$T227634 = -28						; size = 8
__Idx$227630 = -20					; size = 4
$T227621 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T227634[ebp]
	mov	DWORD PTR $T227621[ebp], edx
	mov	eax, DWORD PTR $T227621[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T227621[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T227635[ebp], ecx
	mov	eax, DWORD PTR $T227635[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$227630[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T227635[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$227630[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T227635[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$227630[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T227634[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$227630[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T227635[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$227630[ebp]
	mov	DWORD PTR $T227635[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T227635[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T227634[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T227634[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
$T227661 = -28						; size = 4
__Vptr$227667 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$227667[ebp], ecx
	mov	edx, DWORD PTR __Vptr$227667[ebp]
	mov	DWORD PTR $T227661[ebp], edx
	cmp	DWORD PTR $T227661[ebp], 0
	je	SHORT $LN18@Uninit_cop
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T227661[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T227661[ebp]
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN14@Uninit_cop
$LN18@Uninit_cop:
	mov	DWORD PTR tv84[ebp], 0
$LN14@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAULeaderWithNumTechs@@PAU1@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@YAPAULeaderWithNumTechs@@PAU1@00AAV?$allocator@ULeaderWithNumTechs@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<LeaderWithNumTechs *,LeaderWithNumTechs *,std::allocator<LeaderWithNumTechs> >
PUBLIC	??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv187 = -180						; size = 4
tv186 = -176						; size = 4
tv182 = -172						; size = 4
tv181 = -168						; size = 4
tv177 = -164						; size = 4
tv176 = -160						; size = 4
$T227894 = -156						; size = 4
__Next$227897 = -152					; size = 4
$T227875 = -148						; size = 4
__Next$227878 = -144					; size = 4
$T227867 = -140						; size = 4
$T227814 = -132						; size = 4
__Next$227817 = -128					; size = 4
$T227806 = -124						; size = 4
$T227786 = -120						; size = 4
__Next$227789 = -116					; size = 4
$T227778 = -112						; size = 4
$T227774 = -108						; size = 4
$T227692 = -100						; size = 20
$T227691 = -80						; size = 4
$T227690 = -76						; size = 20
$T227689 = -56						; size = 4
$T227688 = -52						; size = 20
$T227687 = -32						; size = 4
__Mid1$220410 = -28					; size = 4
__Mid2$220391 = -24					; size = 4
__Mid1$220390 = -20					; size = 4
__Chunk2$220386 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
__Pred$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$220386[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$220386[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$220386[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$220390[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$220390[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$220390[ebp], eax

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$220390[ebp]
	mov	DWORD PTR __Mid2$220391[ebp], ecx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$220391[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$220391[ebp], ecx

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T227687[ebp], esp
	mov	DWORD PTR $T227774[ebp], eax
	mov	ecx, DWORD PTR $T227774[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T227774[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T227774[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T227774[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T227774[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T227774[ebp]
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR __Mid2$220391[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$220390[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$220390[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T227688[ebp]
	push	eax
	call	??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv177[ebp], eax
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR $T227778[ebp], ecx
	mov	edx, DWORD PTR $T227778[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Dest$[ebp+16], eax
	cmp	DWORD PTR $T227688[ebp], 0
	je	SHORT $LN45@Chunked_me
	mov	ecx, DWORD PTR $T227688[ebp]
	mov	DWORD PTR __Next$227789[ebp], ecx
	jmp	SHORT $LN43@Chunked_me
$LN42@Chunked_me:
	mov	edx, DWORD PTR __Next$227789[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$227789[ebp], edx
$LN43@Chunked_me:
	mov	eax, DWORD PTR __Next$227789[ebp]
	cmp	eax, DWORD PTR $T227688[ebp+8]
	je	SHORT $LN41@Chunked_me
	jmp	SHORT $LN42@Chunked_me
$LN41@Chunked_me:
	mov	ecx, DWORD PTR $T227688[ebp]
	mov	DWORD PTR $T227786[ebp], ecx
	mov	edx, DWORD PTR $T227786[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Chunked_me:

; 3443 : 		_First = _Mid2;

	mov	eax, DWORD PTR __Mid2$220391[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 3444 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T227689[ebp], esp
	mov	DWORD PTR $T227806[ebp], edx
	mov	eax, DWORD PTR $T227806[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T227806[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T227806[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T227806[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T227806[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T227806[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T227690[ebp]
	push	eax
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv182[ebp], eax
	cmp	DWORD PTR $T227690[ebp], 0
	je	SHORT $LN59@Chunked_me
	mov	ecx, DWORD PTR $T227690[ebp]
	mov	DWORD PTR __Next$227817[ebp], ecx
	jmp	SHORT $LN57@Chunked_me
$LN56@Chunked_me:
	mov	edx, DWORD PTR __Next$227817[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$227817[ebp], edx
$LN57@Chunked_me:
	mov	eax, DWORD PTR __Next$227817[ebp]
	cmp	eax, DWORD PTR $T227690[ebp+8]
	je	SHORT $LN55@Chunked_me
	jmp	SHORT $LN56@Chunked_me
$LN55@Chunked_me:
	mov	ecx, DWORD PTR $T227690[ebp]
	mov	DWORD PTR $T227814[ebp], ecx
	mov	edx, DWORD PTR $T227814[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN59@Chunked_me:

; 3448 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$220410[ebp], eax

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$220410[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$220410[ebp], eax

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	movzx	ecx, BYTE PTR __Pred$[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T227691[ebp], esp
	mov	DWORD PTR $T227867[ebp], edx
	mov	eax, DWORD PTR $T227867[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T227867[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T227867[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T227867[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T227867[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T227867[ebp]
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$220410[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$220410[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227692[ebp]
	push	edx
	call	??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv187[ebp], eax
	cmp	DWORD PTR $T227692[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	eax, DWORD PTR $T227692[ebp]
	mov	DWORD PTR __Next$227878[ebp], eax
	jmp	SHORT $LN81@Chunked_me
$LN80@Chunked_me:
	mov	ecx, DWORD PTR __Next$227878[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$227878[ebp], ecx
$LN81@Chunked_me:
	mov	edx, DWORD PTR __Next$227878[ebp]
	cmp	edx, DWORD PTR $T227692[ebp+8]
	je	SHORT $LN79@Chunked_me
	jmp	SHORT $LN80@Chunked_me
$LN79@Chunked_me:
	mov	eax, DWORD PTR $T227692[ebp]
	mov	DWORD PTR $T227875[ebp], eax
	mov	ecx, DWORD PTR $T227875[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3454 : 		}
; 3455 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$227897[ebp], edx
	jmp	SHORT $LN91@Chunked_me
$LN90@Chunked_me:
	mov	eax, DWORD PTR __Next$227897[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$227897[ebp], eax
$LN91@Chunked_me:
	mov	ecx, DWORD PTR __Next$227897[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN89@Chunked_me
	jmp	SHORT $LN90@Chunked_me
$LN89@Chunked_me:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T227894[ebp], edx
	mov	eax, DWORD PTR $T227894[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@HULeaderWithNumTechsEval@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V?$_Temp_iterator@ULeaderWithNumTechs@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,int,LeaderWithNumTechsEval>
PUBLIC	??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
PUBLIC	??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T228330 = -180						; size = 4
$T228329 = -176						; size = 4
$T228328 = -172						; size = 4
$T228327 = -168						; size = 4
$T228323 = -100						; size = 1
$T228322 = -99						; size = 1
$T228122 = -96						; size = 4
$T228121 = -92						; size = 4
$T228096 = -86						; size = 1
$T228095 = -85						; size = 1
$T228094 = -84						; size = 4
$T228093 = -80						; size = 4
__Cat$228103 = -75					; size = 1
$T228101 = -74						; size = 1
$T228100 = -73						; size = 1
$T228099 = -72						; size = 1
$T227916 = -28						; size = 4
$T227915 = -24						; size = 4
$T227914 = -20						; size = 4
__Mid1$220442 = -16					; size = 4
__Mid2$220425 = -12					; size = 4
__Mid1$220418 = -8					; size = 4
__Chunk2$220414 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
__Pred$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>, COMDAT

; 3434 : 	{	// copy merging chunks, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H

; 3435 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$220414[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$220414[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$220414[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3436 : 		{	// copy merging pairs of adjacent chunks
; 3437 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$220418[ebp], eax

; 3438 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	mov	edx, DWORD PTR __Mid1$220418[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Mid1$220418[ebp], eax

; 3439 : 		_BidIt _Mid2 = _Mid1;

	mov	ecx, DWORD PTR __Mid1$220418[ebp]
	mov	DWORD PTR __Mid2$220425[ebp], ecx

; 3440 : 		std::advance(_Mid2, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid2$220425[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid2$220425[ebp], ecx

; 3441 : 
; 3442 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);

	movzx	edx, BYTE PTR __Pred$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid2$220425[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$220418[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$220418[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T227914[ebp]
	push	edx
	call	??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z ; stdext::unchecked_merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
	add	esp, 28					; 0000001cH
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Dest$[ebp], eax

; 3443 : 		_First = _Mid2;

	mov	ecx, DWORD PTR __Mid2$220425[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 3444 : 		}

	jmp	SHORT $LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3445 : 
; 3446 : 	if (_Count <= _Chunk)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	edx, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3447 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228122[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228121[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T228099[ebp], dl
	mov	al, BYTE PTR __Cat$228103[ebp]
	mov	BYTE PTR $T228100[ebp], al
	mov	cl, BYTE PTR $T228099[ebp]
	mov	BYTE PTR $T228096[ebp], cl
	mov	dl, BYTE PTR $T228101[ebp]
	mov	BYTE PTR $T228095[ebp], dl
	mov	eax, DWORD PTR $T228122[ebp]
	mov	DWORD PTR $T228094[ebp], eax
	mov	ecx, DWORD PTR $T228121[ebp]
	mov	DWORD PTR $T228093[ebp], ecx
	jmp	SHORT $LN59@Chunked_me@2
$LN58@Chunked_me@2:
	mov	edx, DWORD PTR $T228094[ebp]
	add	edx, 8
	mov	DWORD PTR $T228094[ebp], edx
	mov	eax, DWORD PTR $T228093[ebp]
	add	eax, 8
	mov	DWORD PTR $T228093[ebp], eax
$LN59@Chunked_me@2:
	mov	ecx, DWORD PTR $T228093[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN57@Chunked_me@2
	mov	edx, DWORD PTR $T228093[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T228094[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN58@Chunked_me@2
$LN57@Chunked_me@2:
	mov	eax, DWORD PTR $T228094[ebp]
	mov	DWORD PTR $T227915[ebp], eax

; 3448 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3449 : 		{	// copy merging whole and partial last chunk
; 3450 : 		_BidIt _Mid1 = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$220442[ebp], ecx

; 3451 : 		std::advance(_Mid1, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	mov	eax, DWORD PTR __Mid1$220442[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid1$220442[ebp], ecx

; 3452 : 
; 3453 : 		_STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228330[ebp], edx
	mov	eax, DWORD PTR __Mid1$220442[ebp]
	mov	DWORD PTR $T228329[ebp], eax
	mov	ecx, DWORD PTR __Mid1$220442[ebp]
	mov	DWORD PTR $T228328[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228327[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T228322[ebp], al
	movzx	ecx, BYTE PTR $T228322[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T228323[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228330[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T228329[ebp]
	push	eax
	mov	ecx, DWORD PTR $T228328[ebp]
	push	ecx
	mov	edx, DWORD PTR $T228327[ebp]
	push	edx
	lea	eax, DWORD PTR $T227916[ebp]
	push	eax
	call	??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
$LN6@Chunked_me@2:

; 3454 : 		}
; 3455 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechsEval@@@std@@YAXPAULeaderWithNumTechs@@0V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@HHULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechsEval>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T228399 = -40						; size = 4
__Next$228407 = -36					; size = 4
$T228364 = -20						; size = 4
$T228335 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T228335[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN15@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN15@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228364[ebp], edx
	mov	eax, DWORD PTR $T228364[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T228335[ebp]
	or	ecx, 1
	mov	DWORD PTR $T228335[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN43@Copy_opt
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$228407[ebp], edx
	jmp	SHORT $LN41@Copy_opt
$LN40@Copy_opt:
	mov	eax, DWORD PTR __Next$228407[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$228407[ebp], eax
$LN41@Copy_opt:
	mov	ecx, DWORD PTR __Next$228407[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN39@Copy_opt
	jmp	SHORT $LN40@Copy_opt
$LN39@Copy_opt:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228399[ebp], edx
	mov	eax, DWORD PTR $T228399[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN43@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T228675 = -80						; size = 4
$T228674 = -76						; size = 4
$T228673 = -72						; size = 4
$T228636 = -66						; size = 1
$T228635 = -65						; size = 1
$T228634 = -64						; size = 4
$T228633 = -60						; size = 4
$T228632 = -56						; size = 4
$T228598 = -52						; size = 4
__Cat$228643 = -44					; size = 1
$T228640 = -43						; size = 1
$T228639 = -42						; size = 1
$T228638 = -41						; size = 1
$T228552 = -40						; size = 4
$T228551 = -36						; size = 4
$T228526 = -30						; size = 1
$T228525 = -29						; size = 1
$T228524 = -28						; size = 4
$T228523 = -24						; size = 4
__Cat$228533 = -16					; size = 1
$T228530 = -15						; size = 1
$T228529 = -14						; size = 1
$T228528 = -13						; size = 1
$T228456 = -12						; size = 4
$T228444 = -8						; size = 4
$T228419 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last2$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN3@Merge

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T228444[ebp], eax
	mov	ecx, DWORD PTR $T228444[ebp]
	mov	edx, DWORD PTR __First1$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN34@Merge

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T228456[ebp], eax
	mov	ecx, DWORD PTR $T228456[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 8
	mov	DWORD PTR __First2$[ebp], edx

; 2600 : 		else

	jmp	SHORT $LN1@Merge

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN34@Merge:
	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge:
	jmp	$LN4@Merge
$LN3@Merge:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228552[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T228551[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T228528[ebp], cl
	mov	dl, BYTE PTR __Cat$228533[ebp]
	mov	BYTE PTR $T228529[ebp], dl
	mov	al, BYTE PTR $T228528[ebp]
	mov	BYTE PTR $T228526[ebp], al
	mov	cl, BYTE PTR $T228530[ebp]
	mov	BYTE PTR $T228525[ebp], cl
	mov	edx, DWORD PTR $T228552[ebp]
	mov	DWORD PTR $T228524[ebp], edx
	mov	eax, DWORD PTR $T228551[ebp]
	mov	DWORD PTR $T228523[ebp], eax
	jmp	SHORT $LN46@Merge
$LN45@Merge:
	mov	ecx, DWORD PTR $T228524[ebp]
	add	ecx, 8
	mov	DWORD PTR $T228524[ebp], ecx
	mov	edx, DWORD PTR $T228523[ebp]
	add	edx, 8
	mov	DWORD PTR $T228523[ebp], edx
$LN46@Merge:
	mov	eax, DWORD PTR $T228523[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN44@Merge
	mov	ecx, DWORD PTR $T228523[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T228524[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN45@Merge
$LN44@Merge:
	mov	edx, DWORD PTR $T228524[ebp]
	mov	DWORD PTR $T228419[ebp], edx
	mov	eax, DWORD PTR $T228419[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228675[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T228674[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T228673[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T228638[ebp], cl
	mov	dl, BYTE PTR __Cat$228643[ebp]
	mov	BYTE PTR $T228639[ebp], dl
	mov	al, BYTE PTR $T228638[ebp]
	mov	BYTE PTR $T228636[ebp], al
	mov	cl, BYTE PTR $T228640[ebp]
	mov	BYTE PTR $T228635[ebp], cl
	mov	edx, DWORD PTR $T228675[ebp]
	mov	DWORD PTR $T228634[ebp], edx
	mov	eax, DWORD PTR $T228674[ebp]
	mov	DWORD PTR $T228633[ebp], eax
	mov	ecx, DWORD PTR $T228673[ebp]
	mov	DWORD PTR $T228632[ebp], ecx
	jmp	SHORT $LN76@Merge
$LN64@Merge:
	mov	edx, DWORD PTR $T228634[ebp]
	add	edx, 8
	mov	DWORD PTR $T228634[ebp], edx
	mov	eax, DWORD PTR $T228632[ebp]
	add	eax, 8
	mov	DWORD PTR $T228632[ebp], eax
$LN76@Merge:
	mov	ecx, DWORD PTR $T228632[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T228633[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN63@Merge
	mov	edx, DWORD PTR $T228632[ebp]
	mov	DWORD PTR $T228598[ebp], edx
	mov	eax, DWORD PTR $T228598[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T228634[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN64@Merge
$LN63@Merge:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T228634[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAULeaderWithNumTechs@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V23@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@0V10@11ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T228901 = -80						; size = 4
$T228889 = -76						; size = 4
$T228872 = -72						; size = 4
$T228871 = -68						; size = 4
$T228870 = -64						; size = 4
$T228834 = -58						; size = 1
$T228833 = -57						; size = 1
$T228832 = -56						; size = 4
$T228831 = -52						; size = 4
$T228830 = -48						; size = 4
$T228789 = -44						; size = 4
__Cat$228842 = -36					; size = 1
$T228839 = -35						; size = 1
$T228838 = -34						; size = 1
$T228837 = -33						; size = 1
$T228751 = -32						; size = 4
$T228750 = -28						; size = 4
$T228726 = -22						; size = 1
$T228725 = -21						; size = 1
$T228724 = -20						; size = 4
$T228723 = -16						; size = 4
$T228722 = -12						; size = 4
__Cat$228733 = -4					; size = 1
$T228730 = -3						; size = 1
$T228729 = -2						; size = 1
$T228728 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 2839 : 	{	// merge backwards to _Dest, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 2840 : 	for (; ; )
; 2841 : 		if (_First1 == _Last1)

$LN11@Merge_back:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN6@Merge_back

; 2842 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228751[ebp], eax
	mov	ecx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T228750[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T228728[ebp], dl
	mov	al, BYTE PTR __Cat$228733[ebp]
	mov	BYTE PTR $T228729[ebp], al
	mov	cl, BYTE PTR $T228728[ebp]
	mov	BYTE PTR $T228726[ebp], cl
	mov	dl, BYTE PTR $T228730[ebp]
	mov	BYTE PTR $T228725[ebp], dl
	mov	eax, DWORD PTR $T228751[ebp]
	mov	DWORD PTR $T228724[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T228723[ebp], ecx
	mov	edx, DWORD PTR $T228750[ebp]
	mov	DWORD PTR $T228722[ebp], edx
$LN20@Merge_back:
	mov	eax, DWORD PTR $T228722[ebp]
	cmp	eax, DWORD PTR $T228723[ebp]
	je	SHORT $LN19@Merge_back
	mov	ecx, DWORD PTR $T228723[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T228723[ebp], ecx
	mov	edx, DWORD PTR $T228724[ebp]
	sub	edx, 8
	mov	DWORD PTR $T228724[ebp], edx
	mov	eax, DWORD PTR $T228723[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T228724[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN20@Merge_back
$LN19@Merge_back:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T228724[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2843 : 		else if (_First2 == _Last2)

	mov	eax, DWORD PTR __First2$[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	jne	$LN4@Merge_back

; 2844 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T228872[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T228871[ebp], edx
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T228870[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T228837[ebp], cl
	mov	dl, BYTE PTR __Cat$228842[ebp]
	mov	BYTE PTR $T228838[ebp], dl
	mov	al, BYTE PTR $T228837[ebp]
	mov	BYTE PTR $T228834[ebp], al
	mov	cl, BYTE PTR $T228839[ebp]
	mov	BYTE PTR $T228833[ebp], cl
	mov	edx, DWORD PTR $T228872[ebp]
	mov	DWORD PTR $T228832[ebp], edx
	mov	eax, DWORD PTR $T228871[ebp]
	mov	DWORD PTR $T228831[ebp], eax
	mov	ecx, DWORD PTR $T228870[ebp]
	mov	DWORD PTR $T228830[ebp], ecx
$LN41@Merge_back:
	mov	edx, DWORD PTR $T228830[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T228831[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN37@Merge_back
	mov	eax, DWORD PTR $T228831[ebp]
	sub	eax, 8
	mov	DWORD PTR $T228831[ebp], eax
	mov	ecx, DWORD PTR $T228831[ebp]
	mov	DWORD PTR $T228789[ebp], ecx
	mov	edx, DWORD PTR $T228832[ebp]
	sub	edx, 8
	mov	DWORD PTR $T228832[ebp], edx
	mov	eax, DWORD PTR $T228789[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T228832[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN41@Merge_back
$LN37@Merge_back:
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR $T228832[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN9@Merge_back
	jmp	SHORT $LN5@Merge_back
$LN4@Merge_back:

; 2845 : 		else if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))

	mov	eax, DWORD PTR __Last2$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Last2$[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T228889[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR $T228889[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge_back

; 2846 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T228901[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR $T228901[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Last2$[ebp]
	add	edx, 8
	mov	DWORD PTR __Last2$[ebp], edx

; 2847 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2848 : 			*--_Dest = *_Last2, ++_Last1;

	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Last1$[ebp]
	add	edx, 8
	mov	DWORD PTR __Last1$[ebp], edx
$LN5@Merge_back:
	jmp	$LN11@Merge_back
$LN9@Merge_back:

; 2849 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@V12@ULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0PAULeaderWithNumTechs@@10ULeaderWithNumTechsEval@@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z
_TEXT	SEGMENT
$T229021 = -36						; size = 4
$T228979 = -28						; size = 4
$T228966 = -24						; size = 4
$T228965 = -20						; size = 4
__Count2$220500 = -12					; size = 4
__Mid$220501 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z PROC ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>, COMDAT

; 2288 : 	{	// find first element not before _Val, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2289 : 	_DEBUG_POINTER(_Pred);
; 2290 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2291 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2292 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T228979[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T228966[ebp], ecx
	mov	edx, DWORD PTR $T228979[ebp]
	mov	DWORD PTR $T228965[ebp], edx
	mov	eax, DWORD PTR $T228966[ebp]
	sub	eax, DWORD PTR $T228965[ebp]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Lower_boun:

; 2293 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2294 : 		{	// divide and conquer, find half that contains answer
; 2295 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$220500[ebp], eax

; 2296 : 		_FwdIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$220501[ebp], ecx

; 2297 : 		std::advance(_Mid, _Count2);

	mov	edx, DWORD PTR __Count2$220500[ebp]
	mov	eax, DWORD PTR __Mid$220501[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid$220501[ebp], ecx

; 2298 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2299 : 
; 2300 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))

	mov	edx, DWORD PTR __Mid$220501[ebp]
	mov	DWORD PTR $T229021[ebp], edx
	mov	eax, DWORD PTR $T229021[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Lower_boun

; 2301 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$220501[ebp]
	add	edx, 8
	mov	DWORD PTR __Mid$220501[ebp], edx
	mov	eax, DWORD PTR __Mid$220501[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$220500[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2302 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2303 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$220500[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Lower_boun:

; 2304 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2305 : 	return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2306 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ENDP ; std::_Lower_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z
_TEXT	SEGMENT
$T229112 = -36						; size = 4
$T229070 = -28						; size = 4
$T229057 = -24						; size = 4
$T229056 = -20						; size = 4
__Count2$220510 = -12					; size = 4
__Mid$220511 = -8					; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 4
??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z PROC ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>, COMDAT

; 2359 : 	{	// find first element that _Val is before, using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2360 : 	_DEBUG_POINTER(_Pred);
; 2361 : 	_DEBUG_ORDER_SINGLE_PRED(_First, _Last, _Pred, true);
; 2362 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2363 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229070[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T229057[ebp], ecx
	mov	edx, DWORD PTR $T229070[ebp]
	mov	DWORD PTR $T229056[ebp], edx
	mov	eax, DWORD PTR $T229057[ebp]
	sub	eax, DWORD PTR $T229056[ebp]
	sar	eax, 3
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Upper_boun:

; 2364 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2365 : 		{	// divide and conquer, find half that contains answer
; 2366 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$220510[ebp], eax

; 2367 : 		_FwdIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$220511[ebp], ecx

; 2368 : 		std::advance(_Mid, _Count2);

	mov	edx, DWORD PTR __Count2$220510[ebp]
	mov	eax, DWORD PTR __Mid$220511[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Mid$220511[ebp], ecx

; 2369 : 		_DEBUG_ORDER_SINGLE_PRED(_Mid, _Last, _Pred, false);
; 2370 : 
; 2371 : 		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))

	mov	edx, DWORD PTR __Mid$220511[ebp]
	mov	DWORD PTR $T229112[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR $T229112[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@Upper_boun

; 2372 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	edx, DWORD PTR __Mid$220511[ebp]
	add	edx, 8
	mov	DWORD PTR __Mid$220511[ebp], edx
	mov	eax, DWORD PTR __Mid$220511[ebp]
	mov	DWORD PTR __First$[ebp], eax
	mov	ecx, DWORD PTR __Count2$220510[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Count$[ebp], edx

; 2373 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2374 : 			_Count = _Count2;

	mov	eax, DWORD PTR __Count2$220510[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN1@Upper_boun:

; 2375 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2376 : 	return (_First);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2377 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechs@@HULeaderWithNumTechsEval@@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@0ABULeaderWithNumTechs@@ULeaderWithNumTechsEval@@PAH@Z ENDP ; std::_Upper_bound<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechs,int,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z
_TEXT	SEGMENT
$T229169 = -60						; size = 8
$T229140 = -20						; size = 4
$T229134 = -12						; size = 4
$T229133 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T229134[ebp], eax
	lea	ecx, DWORD PTR $T229169[ebp]
	mov	DWORD PTR $T229133[ebp], ecx
	mov	edx, DWORD PTR $T229133[ebp]
	mov	eax, DWORD PTR $T229134[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T229133[ebp]
	mov	eax, DWORD PTR $T229134[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T229140[ebp], esp
	mov	eax, DWORD PTR $T229140[ebp]
	mov	ecx, DWORD PTR $T229169[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T229140[ebp]
	mov	eax, DWORD PTR $T229169[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<int,80,1>::WeightedElement *,int,CvWeightedVector<int,80,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@H$0FA@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<int,80,1>::WeightedElement *,CvWeightedVector<int,80,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T229182 = -12						; size = 4
__Vptr$229180 = -8					; size = 4
__Ptr$220705 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z PROC ; std::_Temp_iterator<LeaderWithNumTechs>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+16]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	SHORT $LN1@operator
$LN2@operator:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$220705[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$220705[ebp]
	mov	DWORD PTR __Vptr$229180[ebp], edx
	mov	eax, DWORD PTR __Vptr$229180[ebp]
	mov	DWORD PTR $T229182[ebp], eax
	cmp	DWORD PTR $T229182[ebp], 0
	je	SHORT $LN7@operator
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T229182[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T229182[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator
$LN7@operator:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z ENDP ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229213 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

$LN5@Copy_backw:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T229213[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR $T229213[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN5@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z$0
__ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T229260 = -40						; size = 4
__Next$229263 = -36					; size = 4
$T229252 = -32						; size = 4
$T229238 = -24						; size = 4
$T229234 = -20						; size = 4
$T229233 = -14						; size = 1
$T229232 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z PROC ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T229238[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T229232[ebp], al
	movzx	ecx, BYTE PTR $T229232[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229233[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T229234[ebp], esp
	mov	DWORD PTR $T229252[ebp], ecx
	mov	edx, DWORD PTR $T229252[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T229252[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T229252[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T229252[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T229252[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T229252[ebp]
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>
	add	esp, 52					; 00000034H
	mov	DWORD PTR tv135[ebp], eax
	mov	edx, DWORD PTR $T229238[ebp]
	or	edx, 1
	mov	DWORD PTR $T229238[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@2
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$229263[ebp], eax
	jmp	SHORT $LN15@unchecked_@2
$LN14@unchecked_@2:
	mov	ecx, DWORD PTR __Next$229263[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next$229263[ebp], ecx
$LN15@unchecked_@2:
	mov	edx, DWORD PTR __Next$229263[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@2
	jmp	SHORT $LN14@unchecked_@2
$LN13@unchecked_@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229260[ebp], eax
	mov	ecx, DWORD PTR $T229260[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5160 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@000V12@ULeaderWithNumTechsEval@@@Z ENDP ; stdext::unchecked_merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z
_TEXT	SEGMENT
$T229281 = -2						; size = 1
$T229280 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z PROC ; stdext::unchecked_merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>, COMDAT

; 5157 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 5158 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest, _Pred,
; 5159 : 			_STD _Iter_random(_First1, _First2,_Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T229280[ebp], al
	movzx	ecx, BYTE PTR $T229280[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T229281[ebp]
	push	edx
	movzx	eax, BYTE PTR __Pred$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
	add	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5160 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@@stdext@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@PAULeaderWithNumTechs@@000V12@ULeaderWithNumTechsEval@@@Z ENDP ; stdext::unchecked_merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229493 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN14@Copy_opt@2
$LN2@Copy_opt@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN14@Copy_opt@2:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T229493[ebp], eax
	mov	ecx, DWORD PTR $T229493[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::random_access_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv197 = -128						; size = 4
tv196 = -124						; size = 4
tv192 = -120						; size = 4
tv191 = -116						; size = 4
$T229674 = -112						; size = 4
__Next$229677 = -108					; size = 4
$T229666 = -104						; size = 4
$T229646 = -100						; size = 4
__Next$229649 = -96					; size = 4
$T229638 = -92						; size = 4
$T229634 = -88						; size = 4
$T229598 = -72						; size = 4
$T229562 = -56						; size = 4
$T229550 = -52						; size = 4
$T229541 = -48						; size = 4
$T229512 = -44						; size = 4
$T229506 = -40						; size = 4
$T229505 = -36						; size = 20
$T229504 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
__Pred$ = 48						; size = 1
___formal$ = 52						; size = 1
___formal$ = 56						; size = 1
??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T229512[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

$LN16@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last1$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Last2$[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Merge@2

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T229541[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T229550[ebp], eax
	mov	ecx, DWORD PTR $T229550[ebp]
	mov	edx, DWORD PTR $T229541[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN56@Merge@2

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T229562[ebp], eax
	mov	ecx, DWORD PTR $T229562[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 8
	mov	DWORD PTR __First2$[ebp], edx

; 2600 : 		else

	jmp	SHORT $LN1@Merge@2

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN56@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T229598[ebp], eax
	mov	ecx, DWORD PTR $T229598[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAEAAV01@ABULeaderWithNumTechs@@@Z ; std::_Temp_iterator<LeaderWithNumTechs>::operator=
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 8
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@2:
	jmp	$LN16@Merge@2
$LN3@Merge@2:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T229504[ebp], esp
	mov	DWORD PTR $T229634[ebp], eax
	mov	ecx, DWORD PTR $T229634[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T229634[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T229634[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T229634[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T229634[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T229634[ebp]
	mov	DWORD PTR tv191[ebp], ecx
	mov	edx, DWORD PTR __Last1$[ebp]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T229505[ebp]
	push	ecx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv192[ebp], eax
	mov	edx, DWORD PTR tv192[ebp]
	mov	DWORD PTR $T229638[ebp], edx
	mov	eax, DWORD PTR $T229638[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T229505[ebp], 0
	je	SHORT $LN84@Merge@2
	mov	edx, DWORD PTR $T229505[ebp]
	mov	DWORD PTR __Next$229649[ebp], edx
	jmp	SHORT $LN82@Merge@2
$LN81@Merge@2:
	mov	eax, DWORD PTR __Next$229649[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$229649[ebp], eax
$LN82@Merge@2:
	mov	ecx, DWORD PTR __Next$229649[ebp]
	cmp	ecx, DWORD PTR $T229505[ebp+8]
	je	SHORT $LN80@Merge@2
	jmp	SHORT $LN81@Merge@2
$LN80@Merge@2:
	mov	edx, DWORD PTR $T229505[ebp]
	mov	DWORD PTR $T229646[ebp], edx
	mov	eax, DWORD PTR $T229646[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN84@Merge@2:

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T229506[ebp], esp
	mov	DWORD PTR $T229666[ebp], ecx
	mov	edx, DWORD PTR $T229666[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T229666[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T229666[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T229666[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T229666[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T229666[ebp]
	mov	DWORD PTR tv196[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$unchecked_copy@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@@stdext@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@std@@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@2@0V12@@Z ; stdext::unchecked_copy<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv197[ebp], eax
	mov	eax, DWORD PTR $T229512[ebp]
	or	eax, 1
	mov	DWORD PTR $T229512[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN98@Merge@2
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$229677[ebp], ecx
	jmp	SHORT $LN96@Merge@2
$LN95@Merge@2:
	mov	edx, DWORD PTR __Next$229677[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$229677[ebp], edx
$LN96@Merge@2:
	mov	eax, DWORD PTR __Next$229677[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN94@Merge@2
	jmp	SHORT $LN95@Merge@2
$LN94@Merge@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229674[ebp], ecx
	mov	edx, DWORD PTR $T229674[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN98@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@ULeaderWithNumTechs@@@std@@QAE@XZ ; std::_Temp_iterator<LeaderWithNumTechs>::~_Temp_iterator<LeaderWithNumTechs>
__ehhandler$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@V12@V?$_Temp_iterator@ULeaderWithNumTechs@@@2@ULeaderWithNumTechsEval@@Uforward_iterator_tag@2@@std@@YA?AV?$_Temp_iterator@ULeaderWithNumTechs@@@0@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@000V10@ULeaderWithNumTechsEval@@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,std::_Temp_iterator<LeaderWithNumTechs>,LeaderWithNumTechsEval,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229865 = -60						; size = 4
$T229864 = -56						; size = 4
$T229839 = -50						; size = 1
$T229838 = -49						; size = 1
$T229837 = -48						; size = 4
$T229836 = -44						; size = 4
__Cat$229846 = -36					; size = 1
$T229843 = -35						; size = 1
$T229842 = -34						; size = 1
$T229841 = -33						; size = 1
$T229793 = -32						; size = 4
$T229792 = -28						; size = 4
$T229767 = -22						; size = 1
$T229766 = -21						; size = 1
$T229765 = -20						; size = 4
$T229764 = -16						; size = 4
__Cat$229774 = -8					; size = 1
$T229771 = -7						; size = 1
$T229770 = -6						; size = 1
$T229769 = -5						; size = 1
$T229694 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 4
__Pred$ = 32						; size = 1
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>, COMDAT

; 2593 : 	{	//  copy merging ranges, both using _Pred

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2594 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2595 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2596 : 	_DEBUG_POINTER(_Dest);
; 2597 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge@3
$LN4@Merge@3:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge@3:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@3
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@3

; 2598 : 		if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN18@Merge@3

; 2599 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 8
	mov	DWORD PTR __First2$[ebp], eax

; 2600 : 		else

	jmp	SHORT $LN1@Merge@3

; 2601 : 			*_Dest = *_First1, ++_First1;

$LN18@Merge@3:
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 8
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge@3:
	jmp	SHORT $LN4@Merge@3
$LN3@Merge@3:

; 2602 : 
; 2603 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229793[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T229792[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T229769[ebp], dl
	mov	al, BYTE PTR __Cat$229774[ebp]
	mov	BYTE PTR $T229770[ebp], al
	mov	cl, BYTE PTR $T229769[ebp]
	mov	BYTE PTR $T229767[ebp], cl
	mov	dl, BYTE PTR $T229771[ebp]
	mov	BYTE PTR $T229766[ebp], dl
	mov	eax, DWORD PTR $T229793[ebp]
	mov	DWORD PTR $T229765[ebp], eax
	mov	ecx, DWORD PTR $T229792[ebp]
	mov	DWORD PTR $T229764[ebp], ecx
	jmp	SHORT $LN30@Merge@3
$LN29@Merge@3:
	mov	edx, DWORD PTR $T229765[ebp]
	add	edx, 8
	mov	DWORD PTR $T229765[ebp], edx
	mov	eax, DWORD PTR $T229764[ebp]
	add	eax, 8
	mov	DWORD PTR $T229764[ebp], eax
$LN30@Merge@3:
	mov	ecx, DWORD PTR $T229764[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN28@Merge@3
	mov	edx, DWORD PTR $T229764[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T229765[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN29@Merge@3
$LN28@Merge@3:
	mov	eax, DWORD PTR $T229765[ebp]
	mov	DWORD PTR $T229694[ebp], eax
	mov	ecx, DWORD PTR $T229694[ebp]
	mov	DWORD PTR __Dest$[ebp], ecx

; 2604 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T229865[ebp], edx
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T229864[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T229841[ebp], cl
	mov	dl, BYTE PTR __Cat$229846[ebp]
	mov	BYTE PTR $T229842[ebp], dl
	mov	al, BYTE PTR $T229841[ebp]
	mov	BYTE PTR $T229839[ebp], al
	mov	cl, BYTE PTR $T229843[ebp]
	mov	BYTE PTR $T229838[ebp], cl
	mov	edx, DWORD PTR $T229865[ebp]
	mov	DWORD PTR $T229837[ebp], edx
	mov	eax, DWORD PTR $T229864[ebp]
	mov	DWORD PTR $T229836[ebp], eax
	jmp	SHORT $LN49@Merge@3
$LN48@Merge@3:
	mov	ecx, DWORD PTR $T229837[ebp]
	add	ecx, 8
	mov	DWORD PTR $T229837[ebp], ecx
	mov	edx, DWORD PTR $T229836[ebp]
	add	edx, 8
	mov	DWORD PTR $T229836[ebp], edx
$LN49@Merge@3:
	mov	eax, DWORD PTR $T229836[ebp]
	cmp	eax, DWORD PTR __Last2$[ebp]
	je	SHORT $LN47@Merge@3
	mov	ecx, DWORD PTR $T229836[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T229837[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN48@Merge@3
$LN47@Merge@3:
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR $T229837[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2605 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAULeaderWithNumTechs@@PAU1@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@3@@std@@YA?AV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@PAULeaderWithNumTechs@@000V10@ULeaderWithNumTechsEval@@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<LeaderWithNumTechs *,LeaderWithNumTechs *,std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,LeaderWithNumTechsEval,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z
_TEXT	SEGMENT
tv193 = -96						; size = 4
tv149 = -92						; size = 4
__Tmp$230029 = -88					; size = 4
$T230018 = -84						; size = 4
__Tmp$230004 = -80					; size = 4
$T229977 = -76						; size = 4
__Tmp$229960 = -72					; size = 4
__Tmp$229941 = -68					; size = 4
__Tmp$229917 = -64					; size = 4
$T229875 = -60						; size = 4
$T229874 = -56						; size = 4
$T229873 = -52						; size = 4
$T229870 = -48						; size = 4
$T229869 = -44						; size = 4
$T229868 = -40						; size = 4
__Hole$220935 = -36					; size = 4
__Holeval$220938 = -32					; size = 8
__Next1$220939 = -24					; size = 4
__Next$220937 = -20					; size = 4
__Tmp$220930 = -16					; size = 4
__Factor$220926 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z PROC ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	DWORD PTR __Count$[ebp], ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$220926[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$220926[ebp], 0
	je	SHORT $LN23@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$220926[ebp]
	mov	DWORD PTR __Tmp$220930[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$220926[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$220930[ebp]
	mov	DWORD PTR __Factor$220926[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

$LN23@Rotate:
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	DWORD PTR __Count$[ebp], edx
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$229917[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Tmp$229917[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$229917[ebp], ecx
	mov	edx, DWORD PTR __Tmp$229917[ebp]
	mov	DWORD PTR __Hole$220935[ebp], edx

; 1695 : 			_RanIt _Next = _Hole;

	mov	eax, DWORD PTR __Hole$220935[ebp]
	mov	DWORD PTR __Next$220937[ebp], eax

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR __Hole$220935[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Holeval$220938[ebp], edx
	mov	DWORD PTR __Holeval$220938[ebp+4], eax

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	ecx, DWORD PTR __Next$220937[ebp]
	mov	DWORD PTR __Tmp$229941[ebp], ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Tmp$229941[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$229941[ebp], ecx
	mov	edx, DWORD PTR __Tmp$229941[ebp]
	mov	DWORD PTR $T229869[ebp], edx
	mov	eax, DWORD PTR $T229869[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN11@Rotate
	lea	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	ecx, DWORD PTR __Next$220937[ebp]
	mov	DWORD PTR __Tmp$229960[ebp], ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	mov	eax, DWORD PTR __Tmp$229960[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$229960[ebp], ecx
	mov	edx, DWORD PTR __Tmp$229960[ebp]
	mov	DWORD PTR $T229870[ebp], edx
	lea	eax, DWORD PTR $T229870[ebp]
	mov	DWORD PTR tv149[ebp], eax
$LN12@Rotate:
	mov	ecx, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T229868[ebp], ecx
	mov	edx, DWORD PTR $T229868[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Next1$220939[ebp], eax

; 1698 : 			while (_Next1 != _Hole)

$LN51@Rotate:
	mov	ecx, DWORD PTR __Next1$220939[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR __Hole$220935[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	$LN83@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$220939[ebp]
	mov	DWORD PTR $T229977[ebp], edx
	mov	eax, DWORD PTR $T229977[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Next$220937[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 1701 : 				_Next = _Next1;

	mov	ecx, DWORD PTR __Next1$220939[ebp]
	mov	DWORD PTR __Next$220937[ebp], ecx

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Next1$220939[ebp]
	sar	edx, 3
	cmp	DWORD PTR __Shift$[ebp], edx
	jge	SHORT $LN75@Rotate
	mov	eax, DWORD PTR __Next1$220939[ebp]
	mov	DWORD PTR __Tmp$230004[ebp], eax
	mov	ecx, DWORD PTR __Shift$[ebp]
	mov	edx, DWORD PTR __Tmp$230004[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR __Tmp$230004[ebp], eax
	mov	ecx, DWORD PTR __Tmp$230004[ebp]
	mov	DWORD PTR $T229874[ebp], ecx
	lea	edx, DWORD PTR $T229874[ebp]
	mov	DWORD PTR tv193[ebp], edx
	jmp	SHORT $LN14@Rotate
$LN75@Rotate:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$220939[ebp]
	sar	eax, 3
	mov	DWORD PTR $T230018[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$230029[ebp], ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	sub	edx, DWORD PTR $T230018[ebp]
	mov	eax, DWORD PTR __Tmp$230029[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR __Tmp$230029[ebp], ecx
	mov	edx, DWORD PTR __Tmp$230029[ebp]
	mov	DWORD PTR $T229875[ebp], edx
	lea	eax, DWORD PTR $T229875[ebp]
	mov	DWORD PTR tv193[ebp], eax
$LN14@Rotate:
	mov	ecx, DWORD PTR tv193[ebp]
	mov	DWORD PTR $T229873[ebp], ecx
	mov	edx, DWORD PTR $T229873[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Next1$220939[ebp], eax

; 1704 : 				}

	jmp	$LN51@Rotate

; 1705 : 			*_Next = _Holeval;

$LN83@Rotate:
	mov	ecx, DWORD PTR __Next$220937[ebp]
	mov	edx, DWORD PTR __Holeval$220938[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Holeval$220938[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@V?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@std@@HULeaderWithNumTechs@@@std@@YAXV?$_Vector_iterator@ULeaderWithNumTechs@@V?$allocator@ULeaderWithNumTechs@@@std@@@0@00PAHPAULeaderWithNumTechs@@@Z ENDP ; std::_Rotate<std::_Vector_iterator<LeaderWithNumTechs,std::allocator<LeaderWithNumTechs> >,int,LeaderWithNumTechs>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T230083 = -2092					; size = 4
$T230082 = -2088					; size = 4
$T230081 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T230081[ebp], eax
	mov	ecx, DWORD PTR $T230081[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T230082[ebp], eax
	mov	eax, DWORD PTR $T230082[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T230083[ebp], eax
	mov	ecx, DWORD PTR $T230083[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
