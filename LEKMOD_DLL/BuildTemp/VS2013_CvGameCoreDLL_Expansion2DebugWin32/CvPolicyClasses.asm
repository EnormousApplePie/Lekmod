; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPolicyClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@IGNANIEL@b103d2e0?93aab?940d7?9a2f3?9375d2eab@ ; `string'
PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
_CIV5_XP1_SCENARIO3_MODID DD FLAT:??_C@_0CF@IGNANIEL@b103d2e0?93aab?940d7?9a2f3?9375d2eab@
CONST	ENDS
;	COMDAT ??_C@_0CF@IGNANIEL@b103d2e0?93aab?940d7?9a2f3?9375d2eab@
CONST	SEGMENT
??_C@_0CF@IGNANIEL@b103d2e0?93aab?940d7?9a2f3?9375d2eab@ DB 'b103d2e0-3aa'
	DB	'b-40d7-a2f3-375d2eabfcaf', 00H		; `string'
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	??_7CvPolicyEntry@@6B@				; CvPolicyEntry::`vftable'
PUBLIC	??0CvPolicyEntry@@QAE@XZ			; CvPolicyEntry::CvPolicyEntry
PUBLIC	?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPolicyEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_7CvPolicyEntry@@6B@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_7CvPolicyEntry@@6B@ DD FLAT:?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPolicyEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvPolicyEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$2
__ehfuncinfo$??0CvPolicyEntry@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvPolicyEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPolicyEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T230506 = -20						; size = 4
$T230501 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPolicyEntry@@QAE@XZ PROC				; CvPolicyEntry::CvPolicyEntry, COMDAT
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPolicyEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPolicyEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+304], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+308], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+312], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+316], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+328], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+336], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+340], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+348], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+352], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+356], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+360], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+364], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+368], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+372], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+376], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+380], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+384], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+392], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+400], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+404], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+408], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+412], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+424], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+428], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+432], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+436], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+440], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+444], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+448], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+452], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+456], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+460], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+472], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+476], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+480], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+484], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+496], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+500], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+504], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+508], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+512], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+516], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+520], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+524], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+528], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+532], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+536], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+540], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+544], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+548], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+552], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+556], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+560], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+564], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+568], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+572], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+576], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+580], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+584], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+588], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+592], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+596], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+600], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+604], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+608], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+612], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+616], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+620], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+624], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+628], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+632], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+636], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+640], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+644], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+648], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+652], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+656], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+660], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+664], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+668], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+672], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+676], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+680], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+684], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+688], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+692], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+696], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+700], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+704], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+708], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+712], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+716], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+720], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+724], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+728], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+732], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+736], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+740], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+744], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+748], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+752], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+756], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+760], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+764], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+768], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+772], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+776], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+777], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+778], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+780], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+784], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+788], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+792], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+796], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+800], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+804], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+808], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+812], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+816], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+820], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+824], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+828], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+832], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+836], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+840], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+844], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+848], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+852], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+856], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+860], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+864], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+868], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+872], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+873], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+874], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+875], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+876], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+877], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+878], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+879], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+880], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+881], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+882], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+883], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+884], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+885], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+886], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+887], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+888], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+889], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+890], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+891], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 892				; 0000037cH
	mov	DWORD PTR $T230501[ebp], edx
	mov	ecx, DWORD PTR $T230501[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 920				; 00000398H
	mov	DWORD PTR $T230506[ebp], eax
	mov	ecx, DWORD PTR $T230506[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+948], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	call	??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+968], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+972], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+976], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+980], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+984], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+988], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+992], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+996], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1000], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1004], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1012], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1016], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1020], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1024], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1028], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1032], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1036], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1040], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1044], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1048], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1052], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1056], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1060], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1064], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1068], 0

; 293  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvPolicyEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvPolicyEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPolicyEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPolicyEntry@@QAE@XZ ENDP				; CvPolicyEntry::CvPolicyEntry
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T230765 = -48						; size = 4
$T230760 = -44						; size = 4
$T230755 = -40						; size = 4
$T230750 = -36						; size = 4
$T230745 = -32						; size = 4
$T230740 = -28						; size = 4
$T230735 = -24						; size = 4
$T230730 = -20						; size = 4
$T230725 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T230725[ebp], eax
	mov	ecx, DWORD PTR $T230725[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T230730[ebp], ecx
	mov	ecx, DWORD PTR $T230730[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T230735[ebp], edx
	mov	ecx, DWORD PTR $T230735[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T230740[ebp], eax
	mov	ecx, DWORD PTR $T230740[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T230745[ebp], ecx
	mov	ecx, DWORD PTR $T230745[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T230750[ebp], edx
	mov	ecx, DWORD PTR $T230750[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T230755[ebp], eax
	mov	ecx, DWORD PTR $T230755[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T230760[ebp], ecx
	mov	ecx, DWORD PTR $T230760[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T230765[ebp], edx
	mov	ecx, DWORD PTR $T230765[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
PUBLIC	??1CvPolicyEntry@@QAE@XZ			; CvPolicyEntry::~CvPolicyEntry
EXTRN	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z:PROC ; CvDatabaseUtility::SafeDelete2DArray
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvPolicyEntry@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??1CvPolicyEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvPolicyEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPolicyEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -280						; size = 4
$T231078 = -240						; size = 4
$T231073 = -236						; size = 4
$T231068 = -232						; size = 4
$T230909 = -188						; size = 4
$T230908 = -184						; size = 4
$T230903 = -180						; size = 4
$T230902 = -176						; size = 4
$T230897 = -172						; size = 4
$T230896 = -168						; size = 4
$T230891 = -164						; size = 4
$T230890 = -160						; size = 4
$T230885 = -156						; size = 4
$T230884 = -152						; size = 4
$T230879 = -148						; size = 4
$T230878 = -144						; size = 4
$T230873 = -140						; size = 4
$T230872 = -136						; size = 4
$T230867 = -132						; size = 4
$T230866 = -128						; size = 4
$T230861 = -124						; size = 4
$T230860 = -120						; size = 4
$T230855 = -116						; size = 4
$T230854 = -112						; size = 4
$T230849 = -108						; size = 4
$T230848 = -104						; size = 4
$T230843 = -100						; size = 4
$T230842 = -96						; size = 4
$T230837 = -92						; size = 4
$T230836 = -88						; size = 4
$T230831 = -84						; size = 4
$T230830 = -80						; size = 4
$T230825 = -76						; size = 4
$T230824 = -72						; size = 4
$T230819 = -68						; size = 4
$T230818 = -64						; size = 4
$T230813 = -60						; size = 4
$T230812 = -56						; size = 4
$T230807 = -52						; size = 4
$T230806 = -48						; size = 4
$T230801 = -44						; size = 4
$T230800 = -40						; size = 4
$T230795 = -36						; size = 4
$T230794 = -32						; size = 4
$T230789 = -28						; size = 4
$T230788 = -24						; size = 4
$T230783 = -20						; size = 4
$T230782 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPolicyEntry@@QAE@XZ PROC				; CvPolicyEntry::~CvPolicyEntry, COMDAT
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPolicyEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPolicyEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 298  : 	SAFE_DELETE_ARRAY(m_piPrereqOrPolicies);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	mov	DWORD PTR $T230783[ebp], ecx
	mov	edx, DWORD PTR $T230783[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230782[ebp], eax
	mov	ecx, DWORD PTR $T230782[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230783[ebp]
	mov	DWORD PTR [edx], 0

; 299  : 	SAFE_DELETE_ARRAY(m_piPrereqAndPolicies);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 968				; 000003c8H
	mov	DWORD PTR $T230789[ebp], eax
	mov	ecx, DWORD PTR $T230789[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230788[ebp], edx
	mov	eax, DWORD PTR $T230788[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230789[ebp]
	mov	DWORD PTR [ecx], 0

; 300  : 	SAFE_DELETE_ARRAY(m_piPolicyDisables);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 972				; 000003ccH
	mov	DWORD PTR $T230795[ebp], edx
	mov	eax, DWORD PTR $T230795[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230794[ebp], ecx
	mov	edx, DWORD PTR $T230794[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230795[ebp]
	mov	DWORD PTR [eax], 0

; 301  : 	SAFE_DELETE_ARRAY(m_piYieldModifier);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 976				; 000003d0H
	mov	DWORD PTR $T230801[ebp], ecx
	mov	edx, DWORD PTR $T230801[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230800[ebp], eax
	mov	ecx, DWORD PTR $T230800[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230801[ebp]
	mov	DWORD PTR [edx], 0

; 302  : 	SAFE_DELETE_ARRAY(m_piCityYieldChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 980				; 000003d4H
	mov	DWORD PTR $T230807[ebp], eax
	mov	ecx, DWORD PTR $T230807[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230806[ebp], edx
	mov	eax, DWORD PTR $T230806[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230807[ebp]
	mov	DWORD PTR [ecx], 0

; 303  : 	SAFE_DELETE_ARRAY(m_piCoastalCityYieldChange);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 984				; 000003d8H
	mov	DWORD PTR $T230813[ebp], edx
	mov	eax, DWORD PTR $T230813[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230812[ebp], ecx
	mov	edx, DWORD PTR $T230812[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230813[ebp]
	mov	DWORD PTR [eax], 0

; 304  : 	SAFE_DELETE_ARRAY(m_piCapitalYieldChange);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 988				; 000003dcH
	mov	DWORD PTR $T230819[ebp], ecx
	mov	edx, DWORD PTR $T230819[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230818[ebp], eax
	mov	ecx, DWORD PTR $T230818[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230819[ebp]
	mov	DWORD PTR [edx], 0

; 305  : 	SAFE_DELETE_ARRAY(m_piCapitalYieldPerPopChange);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 992				; 000003e0H
	mov	DWORD PTR $T230825[ebp], eax
	mov	ecx, DWORD PTR $T230825[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230824[ebp], edx
	mov	eax, DWORD PTR $T230824[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230825[ebp]
	mov	DWORD PTR [ecx], 0

; 306  : 	SAFE_DELETE_ARRAY(m_piCapitalYieldModifier);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 996				; 000003e4H
	mov	DWORD PTR $T230831[ebp], edx
	mov	eax, DWORD PTR $T230831[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230830[ebp], ecx
	mov	edx, DWORD PTR $T230830[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230831[ebp]
	mov	DWORD PTR [eax], 0

; 307  : 	SAFE_DELETE_ARRAY(m_piGreatWorkYieldChange);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1000				; 000003e8H
	mov	DWORD PTR $T230837[ebp], ecx
	mov	edx, DWORD PTR $T230837[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230836[ebp], eax
	mov	ecx, DWORD PTR $T230836[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230837[ebp]
	mov	DWORD PTR [edx], 0

; 308  : 	SAFE_DELETE_ARRAY(m_piSpecialistExtraYield);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1004				; 000003ecH
	mov	DWORD PTR $T230843[ebp], eax
	mov	ecx, DWORD PTR $T230843[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230842[ebp], edx
	mov	eax, DWORD PTR $T230842[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230843[ebp]
	mov	DWORD PTR [ecx], 0

; 309  : 	SAFE_DELETE_ARRAY(m_pabFreePromotion);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1012				; 000003f4H
	mov	DWORD PTR $T230849[ebp], edx
	mov	eax, DWORD PTR $T230849[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230848[ebp], ecx
	mov	edx, DWORD PTR $T230848[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230849[ebp]
	mov	DWORD PTR [eax], 0

; 310  : 	SAFE_DELETE_ARRAY(m_paiUnitCombatProductionModifiers);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1016				; 000003f8H
	mov	DWORD PTR $T230855[ebp], ecx
	mov	edx, DWORD PTR $T230855[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230854[ebp], eax
	mov	ecx, DWORD PTR $T230854[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230855[ebp]
	mov	DWORD PTR [edx], 0

; 311  : 	SAFE_DELETE_ARRAY(m_paiUnitCombatFreeExperiences);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1020				; 000003fcH
	mov	DWORD PTR $T230861[ebp], eax
	mov	ecx, DWORD PTR $T230861[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230860[ebp], edx
	mov	eax, DWORD PTR $T230860[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230861[ebp]
	mov	DWORD PTR [ecx], 0

; 312  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassCultureChanges);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1028				; 00000404H
	mov	DWORD PTR $T230867[ebp], edx
	mov	eax, DWORD PTR $T230867[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230866[ebp], ecx
	mov	edx, DWORD PTR $T230866[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230867[ebp]
	mov	DWORD PTR [eax], 0

; 313  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassProductionModifiers);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1032				; 00000408H
	mov	DWORD PTR $T230873[ebp], ecx
	mov	edx, DWORD PTR $T230873[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230872[ebp], eax
	mov	ecx, DWORD PTR $T230872[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230873[ebp]
	mov	DWORD PTR [edx], 0

; 314  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassTourismModifiers);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1036				; 0000040cH
	mov	DWORD PTR $T230879[ebp], eax
	mov	ecx, DWORD PTR $T230879[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230878[ebp], edx
	mov	eax, DWORD PTR $T230878[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230879[ebp]
	mov	DWORD PTR [ecx], 0

; 315  : 	SAFE_DELETE_ARRAY(m_paiBuildingClassHappiness);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1040				; 00000410H
	mov	DWORD PTR $T230885[ebp], edx
	mov	eax, DWORD PTR $T230885[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230884[ebp], ecx
	mov	edx, DWORD PTR $T230884[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230885[ebp]
	mov	DWORD PTR [eax], 0

; 316  : 	SAFE_DELETE_ARRAY(m_paiFreeUnitClasses);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1044				; 00000414H
	mov	DWORD PTR $T230891[ebp], ecx
	mov	edx, DWORD PTR $T230891[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230890[ebp], eax
	mov	ecx, DWORD PTR $T230890[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230891[ebp]
	mov	DWORD PTR [edx], 0

; 317  : 	SAFE_DELETE_ARRAY(m_paiTourismOnUnitCreation);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1048				; 00000418H
	mov	DWORD PTR $T230897[ebp], eax
	mov	ecx, DWORD PTR $T230897[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230896[ebp], edx
	mov	eax, DWORD PTR $T230896[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230897[ebp]
	mov	DWORD PTR [ecx], 0

; 318  : 
; 319  : //	SAFE_DELETE_ARRAY(m_pabHurry);
; 320  : 	SAFE_DELETE_ARRAY(m_paiHurryModifier);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1024				; 00000400H
	mov	DWORD PTR $T230903[ebp], edx
	mov	eax, DWORD PTR $T230903[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230902[ebp], ecx
	mov	edx, DWORD PTR $T230902[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230903[ebp]
	mov	DWORD PTR [eax], 0

; 321  : 	SAFE_DELETE_ARRAY(m_pabSpecialistValid);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1052				; 0000041cH
	mov	DWORD PTR $T230909[ebp], ecx
	mov	edx, DWORD PTR $T230909[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230908[ebp], eax
	mov	ecx, DWORD PTR $T230908[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230909[ebp]
	mov	DWORD PTR [edx], 0

; 322  : 
; 323  : #ifdef AUI_WARNING_FIXES
; 324  : 	SAFE_DELETE_ARRAY(m_piFlavorValue);
; 325  : 	SAFE_DELETE_ARRAY(m_piImprovementCultureChange);
; 326  : #endif
; 327  : 
; 328  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 329  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges.first, m_ppiImprovementYieldChanges.second);
; 330  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldModifiers.first, m_ppiBuildingClassYieldModifiers.second);
; 331  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges.first, m_ppiBuildingClassYieldChanges.second);
; 332  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 333  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassFlavorChanges.first, m_ppiBuildingClassFlavorChanges.second);
; 334  : #endif
; 335  : #else
; 336  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiImprovementYieldChanges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1056				; 00000420H
	push	eax
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 337  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldModifiers);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1060				; 00000424H
	push	ecx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 338  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassYieldChanges);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1064				; 00000428H
	push	edx
	call	?SafeDelete2DArray@CvDatabaseUtility@@SAXAAPAPAH@Z ; CvDatabaseUtility::SafeDelete2DArray
	add	esp, 4

; 339  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 340  : 	CvDatabaseUtility::SafeDelete2DArray(m_ppiBuildingClassFlavorChanges);
; 341  : #endif
; 342  : #endif
; 343  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 952				; 000003b8H
	mov	DWORD PTR $T231068[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T231068[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	mov	DWORD PTR $T231073[ebp], ecx
	mov	ecx, DWORD PTR $T231073[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 892				; 0000037cH
	mov	DWORD PTR $T231078[ebp], edx
	mov	ecx, DWORD PTR $T231078[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??1CvPolicyEntry@@QAE@XZ$5:
	mov	ecx, DWORD PTR $T231068[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1CvPolicyEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPolicyEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPolicyEntry@@QAE@XZ ENDP				; CvPolicyEntry::~CvPolicyEntry
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1
__ehfuncinfo$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::~multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
PUBLIC	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
PUBLIC	??_C@_0NH@JGCEKKAB@select?5UnitPromotions?4ID?0?5UnitCo@ ; `string'
PUBLIC	??_C@_0BM@DNOOJGJD@m_FreePromotionsUnitCombats?$AA@ ; `string'
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
PUBLIC	??_C@_0HC@FGKHHPOB@select?5Policies?4ID?5from?5Policy_D@ ; `string'
PUBLIC	??_C@_0BD@KHHJPNKJ@m_piPolicyDisables?$AA@	; `string'
PUBLIC	??_C@_0HH@MGLLOFBN@select?5Policies?4ID?5from?5Policy_P@ ; `string'
PUBLIC	??_C@_0BG@HDAGFADH@m_piPrereqAndPolicies?$AA@	; `string'
PUBLIC	??_C@_0HJ@CCDHNOKM@select?5Policies?4ID?5from?5Policy_P@ ; `string'
PUBLIC	??_C@_0BF@CDEDBDG@m_piPrereqOrPolicies?$AA@	; `string'
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
PUBLIC	??_C@_08NDDAPGNJ@Policies?$AA@			; `string'
PUBLIC	??_C@_0CB@JPJEMFOO@Policy_ImprovementCultureChanges@ ; `string'
PUBLIC	??_C@_0BA@PMOLGEPK@ImprovementType?$AA@		; `string'
PUBLIC	??_C@_0OK@OMDAFMLP@select?5Improvements?4ID?5as?5Improv@ ; `string'
PUBLIC	??_C@_0BP@DBAIIMOC@Policy_ImprovementYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0N@CJDAHDJO@Improvements?$AA@		; `string'
PUBLIC	??_C@_0PP@PBCKHIDL@select?5BuildingClasses?4ID?5as?5Bui@ ; `string'
PUBLIC	??_C@_0CB@GDAPPICJ@Policy_BuildingClassYieldChanges@ ; `string'
PUBLIC	??_C@_0PO@NAMOGGP@select?5BuildingClasses?4ID?5as?5Bui@ ; `string'
PUBLIC	??_C@_0CD@CIHGELLG@Policy_BuildingClassYieldModifie@ ; `string'
PUBLIC	??_C@_06JAMLCLDI@Yields?$AA@			; `string'
PUBLIC	??_C@_0BN@HDOPCCMH@Policy_TourismOnUnitCreation?$AA@ ; `string'
PUBLIC	??_C@_07COHILFBB@Tourism?$AA@			; `string'
PUBLIC	??_C@_0M@HLHJNCC@UnitClasses?$AA@		; `string'
PUBLIC	??_C@_0BH@KKBIBCHK@Policy_FreeUnitClasses?$AA@	; `string'
PUBLIC	??_C@_0O@JGILCIIO@UnitClassType?$AA@		; `string'
PUBLIC	??_C@_05IJGIMMHE@Count?$AA@			; `string'
PUBLIC	??_C@_0BO@BNAMIIKH@Policy_BuildingClassHappiness?$AA@ ; `string'
PUBLIC	??_C@_09MNJMGIDC@Happiness?$AA@			; `string'
PUBLIC	??_C@_0CF@CMGLKFDI@Policy_BuildingClassTourismModif@ ; `string'
PUBLIC	??_C@_0BA@COIBAHID@TourismModifier?$AA@		; `string'
PUBLIC	??_C@_0CI@MCHMEPOE@Policy_BuildingClassProductionMo@ ; `string'
PUBLIC	??_C@_0BA@GLDILOEP@BuildingClasses?$AA@		; `string'
PUBLIC	??_C@_0CD@OAPCCMEJ@Policy_BuildingClassCultureChang@ ; `string'
PUBLIC	??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@	; `string'
PUBLIC	??_C@_0O@DKCHOOHE@CultureChange?$AA@		; `string'
PUBLIC	??_C@_0CF@JAEDOHPB@Policy_UnitCombatProductionModif@ ; `string'
PUBLIC	??_C@_0BD@JMJICLDJ@ProductionModifier?$AA@	; `string'
PUBLIC	??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@		; `string'
PUBLIC	??_C@_0CB@ILPCOPJK@Policy_UnitCombatFreeExperiences@ ; `string'
PUBLIC	??_C@_0P@GFHIODK@UnitCombatType?$AA@		; `string'
PUBLIC	??_C@_0P@GCBJCIAG@UnitPromotions?$AA@		; `string'
PUBLIC	??_C@_0BG@ECDIGOEK@Policy_FreePromotions?$AA@	; `string'
PUBLIC	??_C@_0O@IILJPJBB@PromotionType?$AA@		; `string'
PUBLIC	??_C@_0M@EENMFCNN@Specialists?$AA@		; `string'
PUBLIC	??_C@_0BI@BPBDIBOC@Policy_ValidSpecialists?$AA@	; `string'
PUBLIC	??_C@_0P@KLBEOMLO@SpecialistType?$AA@		; `string'
PUBLIC	??_C@_0L@PGMCIMFM@HurryInfos?$AA@		; `string'
PUBLIC	??_C@_0BG@FHFLCHBI@Policy_HurryModifiers?$AA@	; `string'
PUBLIC	??_C@_09FFMCMAO@HurryType?$AA@			; `string'
PUBLIC	??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@	; `string'
PUBLIC	??_C@_0P@BFDDJDDA@Policy_Flavors?$AA@		; `string'
PUBLIC	??_C@_0BN@JKGJDLCA@Policy_SpecialistExtraYields?$AA@ ; `string'
PUBLIC	??_C@_0BN@MFJLJONG@Policy_GreatWorkYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0BN@MENJPEMM@Policy_CapitalYieldModifiers?$AA@ ; `string'
PUBLIC	??_C@_0CB@JNJCBEJA@Policy_CapitalYieldPerPopChanges@ ; `string'
PUBLIC	??_C@_0BL@CCCEKMJN@Policy_CapitalYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0BP@NJFEBBPC@Policy_CoastalCityYieldChanges?$AA@ ; `string'
PUBLIC	??_C@_0BI@KKDHIEEK@Policy_CityYieldChanges?$AA@	; `string'
PUBLIC	??_C@_0BG@KPLKNJFC@Policy_YieldModifiers?$AA@	; `string'
PUBLIC	??_C@_0L@LIHFHODE@PolicyType?$AA@		; `string'
PUBLIC	??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@	; `string'
PUBLIC	??_C@_0BB@MAJHKHNK@NumExtraBranches?$AA@	; `string'
PUBLIC	??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@	; `string'
PUBLIC	??_C@_0L@IANCLNMF@TechPrereq?$AA@		; `string'
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
PUBLIC	??_C@_0O@FEEMIMFP@WeLoveTheKing?$AA@		; `string'
PUBLIC	??_C@_0BJ@HFFJCDOB@IncludesOneShotFreeUnits?$AA@ ; `string'
PUBLIC	??_C@_07GACJADJO@OneShot?$AA@			; `string'
PUBLIC	??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@	; `string'
PUBLIC	??_C@_0BG@JJPEJKJK@EnablesSSPartPurchase?$AA@	; `string'
PUBLIC	??_C@_0BG@BGMJCDCP@AllowPuppetPurchasing?$AA@	; `string'
PUBLIC	??_C@_0BE@PCLBMPHC@NoMinorDOWIfFriends?$AA@	; `string'
PUBLIC	??_C@_09FCFHIKFI@IsWarHero?$AA@			; `string'
PUBLIC	??_C@_0CB@GIDMBFM@IsDoubleTrainedMilitaryLandUnits@ ; `string'
PUBLIC	??_C@_0BH@FDMMCIJH@DisablesResistanceTime?$AA@	; `string'
PUBLIC	??_C@_0BD@PONKBHPA@EnablesSSPartHurry?$AA@	; `string'
PUBLIC	??_C@_0BF@GEHLOEOL@AddReformationBelief?$AA@	; `string'
PUBLIC	??_C@_0BH@KEAINGJC@SecondReligionPantheon?$AA@	; `string'
PUBLIC	??_C@_0BO@FKDEDCGL@GoldenAgeCultureBonusDisabled?$AA@ ; `string'
PUBLIC	??_C@_0BH@BHOFEKLH@ProductionFromGarrison?$AA@	; `string'
PUBLIC	??_C@_0CE@FEKIMMKI@IdeologyPressureUnhappinessModif@ ; `string'
PUBLIC	??_C@_0P@DMNLMCNC@TourismPerCity?$AA@		; `string'
PUBLIC	??_C@_0BB@FIJKHBME@TourismPerWonder?$AA@	; `string'
PUBLIC	??_C@_0BJ@PPFAPLBM@ExtraTourismPerGreatWork?$AA@ ; `string'
PUBLIC	??_C@_0BE@GFLBEIAH@ExtraTerritoryClaim?$AA@	; `string'
PUBLIC	??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@	; `string'
PUBLIC	??_C@_0CB@INOPFAOD@MinorMilitaryNumExtraUnitsToGift@ ; `string'
PUBLIC	??_C@_0BD@LDBBMJHF@MinorResourceBonus?$AA@	; `string'
PUBLIC	??_C@_0BD@OIOEBHLN@MinorScienceAllies?$AA@	; `string'
PUBLIC	??_C@_0BH@NDGBALIP@MinorGreatPeopleAllies?$AA@	; `string'
PUBLIC	??_C@_0BF@MKBOLOFE@CityStateTradeChange?$AA@	; `string'
PUBLIC	??_C@_0BL@BBIFLCLM@OpenBordersTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BK@LGCJBFHM@TradeRouteTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BO@GLBABIPM@SharedReligionTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BD@GIMAOKOM@CoupChanceModifier?$AA@	; `string'
PUBLIC	??_C@_0CE@DKCEDOAL@MinorFriendshipGainBullyGoldSucc@ ; `string'
PUBLIC	??_C@_0BP@GOECOIG@HappinessFromGreatImprovements?$AA@ ; `string'
PUBLIC	??_C@_0BJ@EMLAAIA@TourismFromTradeMissions?$AA@	; `string'
PUBLIC	??_C@_0CB@IIFBEMOI@InfluenceBoostPerGreatPersonBorn@ ; `string'
PUBLIC	??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@ ; `string'
PUBLIC	??_C@_0BO@JKAGNMLN@TradeMissionInfluenceModifier?$AA@ ; `string'
PUBLIC	??_C@_0CD@PLONLNAF@ProductionToGreatMusiciansModifi@ ; `string'
PUBLIC	??_C@_0BI@NMJFENFF@CombatBonusVsSmallerCiv?$AA@	; `string'
PUBLIC	??_C@_0CB@EAENMJPL@RailConnectionProductionModifier@ ; `string'
PUBLIC	??_C@_0CI@PIJMLMPB@InternalTradeRouteProductionYiel@ ; `string'
PUBLIC	??_C@_0CA@KBPBNEF@InternalTradeRouteYieldModifier?$AA@ ; `string'
PUBLIC	??_C@_0BH@NCANENCP@ThemingBonusMultiplier?$AA@	; `string'
PUBLIC	??_C@_0BI@DFKMMHDF@MinorBullyScoreModifier?$AA@	; `string'
PUBLIC	??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@ ; `string'
PUBLIC	??_C@_0BP@ODMELIBJ@ProtectedMinorPerTurnInfluence?$AA@ ; `string'
PUBLIC	??_C@_0BP@DHAEOHLB@MilitaryUnitGiftExtraInfluence?$AA@ ; `string'
PUBLIC	??_C@_0BI@EDFKCKKD@RiggingElectionModifier?$AA@	; `string'
PUBLIC	??_C@_0BO@LIPLOMJF@SharedIdeologyTradeGoldChange?$AA@ ; `string'
PUBLIC	??_C@_0BN@PBNBAHDF@InternalTradeRouteGoldChange?$AA@ ; `string'
PUBLIC	??_C@_0BI@JMHDBAJE@SeaTradeRouteGoldChange?$AA@	; `string'
PUBLIC	??_C@_0BJ@NPLFFGBN@LandTradeRouteGoldChange?$AA@ ; `string'
PUBLIC	??_C@_0BO@NCHBIENE@SharedIdeologyTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PKHFPDIL@LessHappyTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BJ@ONGDHBAE@CommonFoeTourismModifier?$AA@ ; `string'
PUBLIC	??_C@_0BP@BOJEJAGP@CityStateUnitFrequencyModifier?$AA@ ; `string'
PUBLIC	??_C@_0CE@OKMBJAKL@OtherPlayersMinorFriendshipDecay@ ; `string'
PUBLIC	??_C@_0BI@EBPAAEPN@MinorFriendshipDecayMod?$AA@	; `string'
PUBLIC	??_C@_0BH@CNJFAHMI@MinorFriendshipMinimum?$AA@	; `string'
PUBLIC	??_C@_0BH@PGJKGPKO@MinorGoldFriendshipMod?$AA@	; `string'
PUBLIC	??_C@_0BI@HIEEGHEA@MinorQuestFriendshipMod?$AA@	; `string'
PUBLIC	??_C@_0BE@JMMGOOCJ@ExpInBorderModifier?$AA@	; `string'
PUBLIC	??_C@_0M@OLBPIHKG@ExpModifier?$AA@		; `string'
PUBLIC	??_C@_0P@ONAKJGND@FreeSpecialist?$AA@		; `string'
PUBLIC	??_C@_0BI@FBAEOHNO@GarrisonFreeMaintenance?$AA@	; `string'
PUBLIC	??_C@_0BC@DOIJCEHM@RevealAllCapitals?$AA@	; `string'
PUBLIC	??_C@_0BD@MDAIKGML@AlwaysSeeBarbCamps?$AA@	; `string'
PUBLIC	??_C@_0BF@HFMOGHPJ@BarbarianCombatBonus?$AA@	; `string'
PUBLIC	??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@	; `string'
PUBLIC	??_C@_0BF@HBALDEPJ@WoundedUnitDamageMod?$AA@	; `string'
PUBLIC	??_C@_0N@EHHEPDOA@MaxConscript?$AA@		; `string'
PUBLIC	??_C@_0BH@PINGGCAG@MilitaryFoodProduction?$AA@	; `string'
PUBLIC	??_C@_0BD@HOBGLLL@HalfSpecialistFood?$AA@	; `string'
PUBLIC	??_C@_0BO@JCLIINCC@HalfMoreSpecialistUnhappiness?$AA@ ; `string'
PUBLIC	??_C@_0BK@MNPNKBOH@HalfSpecialistUnhappiness?$AA@ ; `string'
PUBLIC	??_C@_0BK@KFJBPGNL@NumCitiesFreeFoodBuilding?$AA@ ; `string'
PUBLIC	??_C@_0BN@FIEHLJMJ@NumCitiesFreeCultureBuilding?$AA@ ; `string'
PUBLIC	??_C@_0BD@KDKHHJEK@NumCitiesFreeWalls?$AA@	; `string'
PUBLIC	??_C@_0BK@JOIILMDO@NumCitiesFreePietyGardens?$AA@ ; `string'
PUBLIC	??_C@_0BP@ELCFNBD@NumCitiesFreeAestheticsSchools?$AA@ ; `string'
PUBLIC	??_C@_0O@ELPPBGEP@GoldToScience?$AA@		; `string'
PUBLIC	??_C@_0BD@CDMOEEGG@HappinessToScience?$AA@	; `string'
PUBLIC	??_C@_0BD@MMMKOKOB@HappinessToCulture?$AA@	; `string'
PUBLIC	??_C@_0BF@NKCDCBLE@HappyPerMilitaryUnit?$AA@	; `string'
PUBLIC	??_C@_0O@IKEGJHGF@UnitSupplyMod?$AA@		; `string'
PUBLIC	??_C@_0BH@GPCCGJFH@UnitGoldMaintenanceMod?$AA@	; `string'
PUBLIC	??_C@_0BL@GOKAHANB@BuildingGoldMaintenanceMod?$AA@ ; `string'
PUBLIC	??_C@_0BI@JPCPBJHC@RouteGoldMaintenanceMod?$AA@	; `string'
PUBLIC	??_C@_0M@EOGMLPFM@FreeFoodBox?$AA@		; `string'
PUBLIC	??_C@_0BH@PDNAFCEG@NewCityExtraPopulation?$AA@	; `string'
PUBLIC	??_C@_0CB@MIGPIJHP@CapitalSettlerProductionModifier@ ; `string'
PUBLIC	??_C@_0BK@KEMFJDHB@SettlerProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BB@IIOEMOFG@CapitalGrowthMod?$AA@	; `string'
PUBLIC	??_C@_0O@KIHLCIGE@CityGrowthMod?$AA@		; `string'
PUBLIC	??_C@_0BA@JGKPMHDI@CityStrengthMod?$AA@		; `string'
PUBLIC	??_C@_0BE@LMFGEEFC@GoldPerMilitaryUnit?$AA@	; `string'
PUBLIC	??_C@_0M@CELEIBNP@GoldPerUnit?$AA@		; `string'
PUBLIC	??_C@_0BD@FEHHPDEP@CatchSpiesModifier?$AA@	; `string'
PUBLIC	??_C@_0BI@PDPCGKIO@StealTechFasterModifier?$AA@	; `string'
PUBLIC	??_C@_0BI@GKMOPGMA@StealTechSlowerModifier?$AA@	; `string'
PUBLIC	??_C@_0BK@FGEFNEAF@CulturalPlunderMultiplier?$AA@ ; `string'
PUBLIC	??_C@_0BC@LIHGJKGH@FaithCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BJ@OGAAKMBL@TradeMissionGoldModifier?$AA@ ; `string'
PUBLIC	??_C@_0CF@CKGIHFME@CityConnectionTradeRouteGoldModi@ ; `string'
PUBLIC	??_C@_0BN@MDJBNLIP@BuildingPurchaseCostModifier?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MKCDENAA@UnitPurchaseCostModifier?$AA@ ; `string'
PUBLIC	??_C@_0CC@ELHNOAEL@GarrisonedCityRangeStrikeModifie@ ; `string'
PUBLIC	??_C@_0BO@MEMOKKJL@NumCitiesResearchCostDiscount?$AA@ ; `string'
PUBLIC	??_C@_0BM@COIEECHE@NumCitiesPolicyCostDiscount?$AA@ ; `string'
PUBLIC	??_C@_0BM@FKOPEKNC@PlotCultureExponentModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BA@EBDNNHOP@PlotGoldCostMod?$AA@		; `string'
PUBLIC	??_C@_0BB@ONFGPAJH@NumExtraBuilders?$AA@	; `string'
PUBLIC	??_C@_0BI@IMKGJEKK@UnhappinessFromUnitsMod?$AA@	; `string'
PUBLIC	??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@	; `string'
PUBLIC	??_C@_0BI@EKOONHKP@HappinessPerXPopulation?$AA@	; `string'
PUBLIC	??_C@_0BL@NOANKODL@HappinessPerRailConnection?$AA@ ; `string'
PUBLIC	??_C@_0BH@FKMKPMOM@HappinessPerTradeRoute?$AA@	; `string'
PUBLIC	??_C@_0BJ@JGKBABME@CulturePerGarrisonedUnit?$AA@ ; `string'
PUBLIC	??_C@_0BL@JJAGICMO@HappinessPerGarrisonedUnit?$AA@ ; `string'
PUBLIC	??_C@_0CD@HCLGJPMG@FreeMilitaryUnitsPopulationPerce@ ; `string'
PUBLIC	??_C@_0BL@OICFPJHJ@FreeUnitsPopulationPercent?$AA@ ; `string'
PUBLIC	??_C@_0BG@HNNABIFD@BaseFreeMilitaryUnits?$AA@	; `string'
PUBLIC	??_C@_0O@EIFAIMLA@BaseFreeUnits?$AA@		; `string'
PUBLIC	??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BK@CFFAKCBM@SpecialistUpgradeModifier?$AA@ ; `string'
PUBLIC	??_C@_0BN@BCNFIGMF@SpecialistProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BP@HAEEHIKP@ImprovementUpgradeRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@OOJHBKNI@ImprovementCostModifier?$AA@	; `string'
PUBLIC	??_C@_0BF@BBFBLGII@AllFeatureProduction?$AA@	; `string'
PUBLIC	??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@	; `string'
PUBLIC	??_C@_0P@MOBEEGOH@FreeExperience?$AA@		; `string'
PUBLIC	??_C@_0BG@GLEFCJIP@CapitalUnhappinessMod?$AA@	; `string'
PUBLIC	??_C@_0CB@MDKPLGNJ@OccupiedPopulationUnhappinessMod@ ; `string'
PUBLIC	??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@	; `string'
PUBLIC	??_C@_0P@MJJHCDCN@UnhappinessMod?$AA@		; `string'
PUBLIC	??_C@_0BG@BNECOPBF@ExtraHappinessPerCity?$AA@	; `string'
PUBLIC	??_C@_0P@PKOJCLKH@ExtraHappiness?$AA@		; `string'
PUBLIC	??_C@_0CB@PIKCEEAD@DomesticGreatGeneralRateModifier@ ; `string'
PUBLIC	??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BK@EFBINBKL@GreatMerchantRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BK@EGCNJBGG@GreatMusicianRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@EDMONEDH@GreatArtistRateModifier?$AA@	; `string'
PUBLIC	??_C@_0BI@LJIIKCIN@GreatWriterRateModifier?$AA@	; `string'
PUBLIC	??_C@_0BJ@OJPABOPK@GreatAdmiralRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@ ; `string'
PUBLIC	??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@	; `string'
PUBLIC	??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@ ; `string'
PUBLIC	??_C@_0BF@OHPDEMNG@StrategicResourceMod?$AA@	; `string'
PUBLIC	??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@	; `string'
PUBLIC	??_C@_0O@OGNCLEHN@NumExtraSpies?$AA@		; `string'
PUBLIC	??_C@_0BD@JMFDFLLL@NumFreeGreatPeople?$AA@	; `string'
PUBLIC	??_C@_0BA@BKNGJGHF@NumFreePolicies?$AA@		; `string'
PUBLIC	??_C@_0N@DBLFACAI@NumFreeTechs?$AA@		; `string'
PUBLIC	??_C@_0BF@MHEADKKO@GoldenAgeDurationMod?$AA@	; `string'
PUBLIC	??_C@_0BC@GGDDOBLH@GoldenAgeMeterMod?$AA@	; `string'
PUBLIC	??_C@_0P@BJCGNFDJ@GoldenAgeTurns?$AA@		; `string'
PUBLIC	??_C@_0BB@LCLFIBJM@AttackBonusTurns?$AA@	; `string'
PUBLIC	??_C@_0BD@KHNGHMJB@EmbarkedExtraMoves?$AA@	; `string'
PUBLIC	??_C@_0BB@OCLFMNEB@ScienceFromKills?$AA@	; `string'
PUBLIC	??_C@_0O@IFCPKMIO@GoldFromKills?$AA@		; `string'
PUBLIC	??_C@_0BK@DICAPLG@CultureFromBarbarianKills?$AA@ ; `string'
PUBLIC	??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBDGMPP@CultureImprovementChange?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KNLKNLF@CulturePerTechResearched?$AA@	; `string'
PUBLIC	??_C@_0BI@DGDBMDFC@CultureWonderMultiplier?$AA@	; `string'
PUBLIC	??_C@_0BB@LIMEGBNN@CulturePerWonder?$AA@	; `string'
PUBLIC	??_C@_0P@HLGECCII@CulturePerCity?$AA@		; `string'
PUBLIC	??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@	; `string'
PUBLIC	??_C@_05KOHFLOFG@Level?$AA@			; `string'
PUBLIC	??_C@_05LNPLOKEP@GridY?$AA@			; `string'
PUBLIC	??_C@_05KEOANLAO@GridX?$AA@			; `string'
PUBLIC	??_C@_0M@IMLKLLCO@CultureCost?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBD_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z:PROC ; CvDatabaseUtility::Initialize2DArray
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z:PROC ; CvDatabaseUtility::SetYields
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
EXTRN	__CxxThrowException@8:PROC
;	COMDAT ??_C@_0NH@JGCEKKAB@select?5UnitPromotions?4ID?0?5UnitCo@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
CONST	SEGMENT
??_C@_0NH@JGCEKKAB@select?5UnitPromotions?4ID?0?5UnitCo@ DB 'select UnitP'
	DB	'romotions.ID, UnitCombatInfos.ID  from Policy_FreePromotionUn'
	DB	'itCombats, UnitPromotions, UnitCombatInfos where PolicyType ='
	DB	' ? and PromotionType = UnitPromotions.ID and UnitCombatType ='
	DB	' UnitCombatInfos.ID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DNOOJGJD@m_FreePromotionsUnitCombats?$AA@
CONST	SEGMENT
??_C@_0BM@DNOOJGJD@m_FreePromotionsUnitCombats?$AA@ DB 'm_FreePromotionsU'
	DB	'nitCombats', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0HC@FGKHHPOB@select?5Policies?4ID?5from?5Policy_D@
CONST	SEGMENT
??_C@_0HC@FGKHHPOB@select?5Policies?4ID?5from?5Policy_D@ DB 'select Polic'
	DB	'ies.ID from Policy_Disables inner join Policies on Policies.T'
	DB	'ype = PolicyDisable where PolicyType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KHHJPNKJ@m_piPolicyDisables?$AA@
CONST	SEGMENT
??_C@_0BD@KHHJPNKJ@m_piPolicyDisables?$AA@ DB 'm_piPolicyDisables', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@MGLLOFBN@select?5Policies?4ID?5from?5Policy_P@
CONST	SEGMENT
??_C@_0HH@MGLLOFBN@select?5Policies?4ID?5from?5Policy_P@ DB 'select Polic'
	DB	'ies.ID from Policy_PrereqPolicies inner join Policies on Poli'
	DB	'cies.Type = PrereqPolicy where PolicyType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HDAGFADH@m_piPrereqAndPolicies?$AA@
CONST	SEGMENT
??_C@_0BG@HDAGFADH@m_piPrereqAndPolicies?$AA@ DB 'm_piPrereqAndPolicies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HJ@CCDHNOKM@select?5Policies?4ID?5from?5Policy_P@
CONST	SEGMENT
??_C@_0HJ@CCDHNOKM@select?5Policies?4ID?5from?5Policy_P@ DB 'select Polic'
	DB	'ies.ID from Policy_PrereqORPolicies inner join Policies on Po'
	DB	'licies.Type = PrereqPolicy where PolicyType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CDEDBDG@m_piPrereqOrPolicies?$AA@
CONST	SEGMENT
??_C@_0BF@CDEDBDG@m_piPrereqOrPolicies?$AA@ DB 'm_piPrereqOrPolicies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NDDAPGNJ@Policies?$AA@
CONST	SEGMENT
??_C@_08NDDAPGNJ@Policies?$AA@ DB 'Policies', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JPJEMFOO@Policy_ImprovementCultureChanges@
CONST	SEGMENT
??_C@_0CB@JPJEMFOO@Policy_ImprovementCultureChanges@ DB 'Policy_Improveme'
	DB	'ntCultureChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
CONST	SEGMENT
??_C@_0BA@PMOLGEPK@ImprovementType?$AA@ DB 'ImprovementType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0OK@OMDAFMLP@select?5Improvements?4ID?5as?5Improv@
CONST	SEGMENT
??_C@_0OK@OMDAFMLP@select?5Improvements?4ID?5as?5Improv@ DB 'select Impro'
	DB	'vements.ID as ImprovementID, Yields.ID as YieldID, Yield from'
	DB	' Policy_ImprovementYieldChanges inner join Improvements on Im'
	DB	'provements.Type = ImprovementType inner join Yields on Yields'
	DB	'.Type = YieldType where PolicyType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DBAIIMOC@Policy_ImprovementYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BP@DBAIIMOC@Policy_ImprovementYieldChanges?$AA@ DB 'Policy_Improve'
	DB	'mentYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CJDAHDJO@Improvements?$AA@
CONST	SEGMENT
??_C@_0N@CJDAHDJO@Improvements?$AA@ DB 'Improvements', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0PP@PBCKHIDL@select?5BuildingClasses?4ID?5as?5Bui@
CONST	SEGMENT
??_C@_0PP@PBCKHIDL@select?5BuildingClasses?4ID?5as?5Bui@ DB 'select Build'
	DB	'ingClasses.ID as BuildingClassID, Yields.ID as YieldID, Yield'
	DB	'Change from Policy_BuildingClassYieldChanges inner join Build'
	DB	'ingClasses on BuildingClasses.Type = BuildingClassType inner '
	DB	'join Yields on Yields.Type = YieldType where PolicyType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GDAPPICJ@Policy_BuildingClassYieldChanges@
CONST	SEGMENT
??_C@_0CB@GDAPPICJ@Policy_BuildingClassYieldChanges@ DB 'Policy_BuildingC'
	DB	'lassYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0PO@NAMOGGP@select?5BuildingClasses?4ID?5as?5Bui@
CONST	SEGMENT
??_C@_0PO@NAMOGGP@select?5BuildingClasses?4ID?5as?5Bui@ DB 'select Buildi'
	DB	'ngClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldM'
	DB	'od from Policy_BuildingClassYieldModifiers inner join Buildin'
	DB	'gClasses on BuildingClasses.Type = BuildingClassType inner jo'
	DB	'in Yields on Yields.Type = YieldType where PolicyType = ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CIHGELLG@Policy_BuildingClassYieldModifie@
CONST	SEGMENT
??_C@_0CD@CIHGELLG@Policy_BuildingClassYieldModifie@ DB 'Policy_BuildingC'
	DB	'lassYieldModifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06JAMLCLDI@Yields?$AA@
CONST	SEGMENT
??_C@_06JAMLCLDI@Yields?$AA@ DB 'Yields', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HDOPCCMH@Policy_TourismOnUnitCreation?$AA@
CONST	SEGMENT
??_C@_0BN@HDOPCCMH@Policy_TourismOnUnitCreation?$AA@ DB 'Policy_TourismOn'
	DB	'UnitCreation', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07COHILFBB@Tourism?$AA@
CONST	SEGMENT
??_C@_07COHILFBB@Tourism?$AA@ DB 'Tourism', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HLHJNCC@UnitClasses?$AA@
CONST	SEGMENT
??_C@_0M@HLHJNCC@UnitClasses?$AA@ DB 'UnitClasses', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KKBIBCHK@Policy_FreeUnitClasses?$AA@
CONST	SEGMENT
??_C@_0BH@KKBIBCHK@Policy_FreeUnitClasses?$AA@ DB 'Policy_FreeUnitClasses'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JGILCIIO@UnitClassType?$AA@
CONST	SEGMENT
??_C@_0O@JGILCIIO@UnitClassType?$AA@ DB 'UnitClassType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IJGIMMHE@Count?$AA@
CONST	SEGMENT
??_C@_05IJGIMMHE@Count?$AA@ DB 'Count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BNAMIIKH@Policy_BuildingClassHappiness?$AA@
CONST	SEGMENT
??_C@_0BO@BNAMIIKH@Policy_BuildingClassHappiness?$AA@ DB 'Policy_Building'
	DB	'ClassHappiness', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNJMGIDC@Happiness?$AA@
CONST	SEGMENT
??_C@_09MNJMGIDC@Happiness?$AA@ DB 'Happiness', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CMGLKFDI@Policy_BuildingClassTourismModif@
CONST	SEGMENT
??_C@_0CF@CMGLKFDI@Policy_BuildingClassTourismModif@ DB 'Policy_BuildingC'
	DB	'lassTourismModifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@COIBAHID@TourismModifier?$AA@
CONST	SEGMENT
??_C@_0BA@COIBAHID@TourismModifier?$AA@ DB 'TourismModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MCHMEPOE@Policy_BuildingClassProductionMo@
CONST	SEGMENT
??_C@_0CI@MCHMEPOE@Policy_BuildingClassProductionMo@ DB 'Policy_BuildingC'
	DB	'lassProductionModifiers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
CONST	SEGMENT
??_C@_0BA@GLDILOEP@BuildingClasses?$AA@ DB 'BuildingClasses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OAPCCMEJ@Policy_BuildingClassCultureChang@
CONST	SEGMENT
??_C@_0CD@OAPCCMEJ@Policy_BuildingClassCultureChang@ DB 'Policy_BuildingC'
	DB	'lassCultureChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
CONST	SEGMENT
??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@ DB 'BuildingClassType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DKCHOOHE@CultureChange?$AA@
CONST	SEGMENT
??_C@_0O@DKCHOOHE@CultureChange?$AA@ DB 'CultureChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JAEDOHPB@Policy_UnitCombatProductionModif@
CONST	SEGMENT
??_C@_0CF@JAEDOHPB@Policy_UnitCombatProductionModif@ DB 'Policy_UnitComba'
	DB	'tProductionModifiers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMJICLDJ@ProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BD@JMJICLDJ@ProductionModifier?$AA@ DB 'ProductionModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
CONST	SEGMENT
??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@ DB 'UnitCombatInfos', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ILPCOPJK@Policy_UnitCombatFreeExperiences@
CONST	SEGMENT
??_C@_0CB@ILPCOPJK@Policy_UnitCombatFreeExperiences@ DB 'Policy_UnitComba'
	DB	'tFreeExperiences', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GFHIODK@UnitCombatType?$AA@
CONST	SEGMENT
??_C@_0P@GFHIODK@UnitCombatType?$AA@ DB 'UnitCombatType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GCBJCIAG@UnitPromotions?$AA@
CONST	SEGMENT
??_C@_0P@GCBJCIAG@UnitPromotions?$AA@ DB 'UnitPromotions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ECDIGOEK@Policy_FreePromotions?$AA@
CONST	SEGMENT
??_C@_0BG@ECDIGOEK@Policy_FreePromotions?$AA@ DB 'Policy_FreePromotions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IILJPJBB@PromotionType?$AA@
CONST	SEGMENT
??_C@_0O@IILJPJBB@PromotionType?$AA@ DB 'PromotionType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EENMFCNN@Specialists?$AA@
CONST	SEGMENT
??_C@_0M@EENMFCNN@Specialists?$AA@ DB 'Specialists', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BPBDIBOC@Policy_ValidSpecialists?$AA@
CONST	SEGMENT
??_C@_0BI@BPBDIBOC@Policy_ValidSpecialists?$AA@ DB 'Policy_ValidSpecialis'
	DB	'ts', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KLBEOMLO@SpecialistType?$AA@
CONST	SEGMENT
??_C@_0P@KLBEOMLO@SpecialistType?$AA@ DB 'SpecialistType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGMCIMFM@HurryInfos?$AA@
CONST	SEGMENT
??_C@_0L@PGMCIMFM@HurryInfos?$AA@ DB 'HurryInfos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FHFLCHBI@Policy_HurryModifiers?$AA@
CONST	SEGMENT
??_C@_0BG@FHFLCHBI@Policy_HurryModifiers?$AA@ DB 'Policy_HurryModifiers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FFMCMAO@HurryType?$AA@
CONST	SEGMENT
??_C@_09FFMCMAO@HurryType?$AA@ DB 'HurryType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@
CONST	SEGMENT
??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@ DB 'HurryCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BFDDJDDA@Policy_Flavors?$AA@
CONST	SEGMENT
??_C@_0P@BFDDJDDA@Policy_Flavors?$AA@ DB 'Policy_Flavors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JKGJDLCA@Policy_SpecialistExtraYields?$AA@
CONST	SEGMENT
??_C@_0BN@JKGJDLCA@Policy_SpecialistExtraYields?$AA@ DB 'Policy_Specialis'
	DB	'tExtraYields', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MFJLJONG@Policy_GreatWorkYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BN@MFJLJONG@Policy_GreatWorkYieldChanges?$AA@ DB 'Policy_GreatWork'
	DB	'YieldChanges', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MENJPEMM@Policy_CapitalYieldModifiers?$AA@
CONST	SEGMENT
??_C@_0BN@MENJPEMM@Policy_CapitalYieldModifiers?$AA@ DB 'Policy_CapitalYi'
	DB	'eldModifiers', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JNJCBEJA@Policy_CapitalYieldPerPopChanges@
CONST	SEGMENT
??_C@_0CB@JNJCBEJA@Policy_CapitalYieldPerPopChanges@ DB 'Policy_CapitalYi'
	DB	'eldPerPopChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CCCEKMJN@Policy_CapitalYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BL@CCCEKMJN@Policy_CapitalYieldChanges?$AA@ DB 'Policy_CapitalYiel'
	DB	'dChanges', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NJFEBBPC@Policy_CoastalCityYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BP@NJFEBBPC@Policy_CoastalCityYieldChanges?$AA@ DB 'Policy_Coastal'
	DB	'CityYieldChanges', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KKDHIEEK@Policy_CityYieldChanges?$AA@
CONST	SEGMENT
??_C@_0BI@KKDHIEEK@Policy_CityYieldChanges?$AA@ DB 'Policy_CityYieldChang'
	DB	'es', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KPLKNJFC@Policy_YieldModifiers?$AA@
CONST	SEGMENT
??_C@_0BG@KPLKNJFC@Policy_YieldModifiers?$AA@ DB 'Policy_YieldModifiers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIHFHODE@PolicyType?$AA@
CONST	SEGMENT
??_C@_0L@LIHFHODE@PolicyType?$AA@ DB 'PolicyType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@
CONST	SEGMENT
??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@ DB 'FreeBuildingOnConquest'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MAJHKHNK@NumExtraBranches?$AA@
CONST	SEGMENT
??_C@_0BB@MAJHKHNK@NumExtraBranches?$AA@ DB 'NumExtraBranches', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@
CONST	SEGMENT
??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@ DB 'PolicyBranchType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IANCLNMF@TechPrereq?$AA@
CONST	SEGMENT
??_C@_0L@IANCLNMF@TechPrereq?$AA@ DB 'TechPrereq', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FEEMIMFP@WeLoveTheKing?$AA@
CONST	SEGMENT
??_C@_0O@FEEMIMFP@WeLoveTheKing?$AA@ DB 'WeLoveTheKing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HFFJCDOB@IncludesOneShotFreeUnits?$AA@
CONST	SEGMENT
??_C@_0BJ@HFFJCDOB@IncludesOneShotFreeUnits?$AA@ DB 'IncludesOneShotFreeU'
	DB	'nits', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07GACJADJO@OneShot?$AA@
CONST	SEGMENT
??_C@_07GACJADJO@OneShot?$AA@ DB 'OneShot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@
CONST	SEGMENT
??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@ DB 'AbleToAnnexCityStates', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JJPEJKJK@EnablesSSPartPurchase?$AA@
CONST	SEGMENT
??_C@_0BG@JJPEJKJK@EnablesSSPartPurchase?$AA@ DB 'EnablesSSPartPurchase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BGMJCDCP@AllowPuppetPurchasing?$AA@
CONST	SEGMENT
??_C@_0BG@BGMJCDCP@AllowPuppetPurchasing?$AA@ DB 'AllowPuppetPurchasing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PCLBMPHC@NoMinorDOWIfFriends?$AA@
CONST	SEGMENT
??_C@_0BE@PCLBMPHC@NoMinorDOWIfFriends?$AA@ DB 'NoMinorDOWIfFriends', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCFHIKFI@IsWarHero?$AA@
CONST	SEGMENT
??_C@_09FCFHIKFI@IsWarHero?$AA@ DB 'IsWarHero', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GIDMBFM@IsDoubleTrainedMilitaryLandUnits@
CONST	SEGMENT
??_C@_0CB@GIDMBFM@IsDoubleTrainedMilitaryLandUnits@ DB 'IsDoubleTrainedMi'
	DB	'litaryLandUnits', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FDMMCIJH@DisablesResistanceTime?$AA@
CONST	SEGMENT
??_C@_0BH@FDMMCIJH@DisablesResistanceTime?$AA@ DB 'DisablesResistanceTime'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PONKBHPA@EnablesSSPartHurry?$AA@
CONST	SEGMENT
??_C@_0BD@PONKBHPA@EnablesSSPartHurry?$AA@ DB 'EnablesSSPartHurry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GEHLOEOL@AddReformationBelief?$AA@
CONST	SEGMENT
??_C@_0BF@GEHLOEOL@AddReformationBelief?$AA@ DB 'AddReformationBelief', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KEAINGJC@SecondReligionPantheon?$AA@
CONST	SEGMENT
??_C@_0BH@KEAINGJC@SecondReligionPantheon?$AA@ DB 'SecondReligionPantheon'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FKDEDCGL@GoldenAgeCultureBonusDisabled?$AA@
CONST	SEGMENT
??_C@_0BO@FKDEDCGL@GoldenAgeCultureBonusDisabled?$AA@ DB 'GoldenAgeCultur'
	DB	'eBonusDisabled', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BHOFEKLH@ProductionFromGarrison?$AA@
CONST	SEGMENT
??_C@_0BH@BHOFEKLH@ProductionFromGarrison?$AA@ DB 'ProductionFromGarrison'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FEKIMMKI@IdeologyPressureUnhappinessModif@
CONST	SEGMENT
??_C@_0CE@FEKIMMKI@IdeologyPressureUnhappinessModif@ DB 'IdeologyPressure'
	DB	'UnhappinessModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DMNLMCNC@TourismPerCity?$AA@
CONST	SEGMENT
??_C@_0P@DMNLMCNC@TourismPerCity?$AA@ DB 'TourismPerCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FIJKHBME@TourismPerWonder?$AA@
CONST	SEGMENT
??_C@_0BB@FIJKHBME@TourismPerWonder?$AA@ DB 'TourismPerWonder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PPFAPLBM@ExtraTourismPerGreatWork?$AA@
CONST	SEGMENT
??_C@_0BJ@PPFAPLBM@ExtraTourismPerGreatWork?$AA@ DB 'ExtraTourismPerGreat'
	DB	'Work', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GFLBEIAH@ExtraTerritoryClaim?$AA@
CONST	SEGMENT
??_C@_0BE@GFLBEIAH@ExtraTerritoryClaim?$AA@ DB 'ExtraTerritoryClaim', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@
CONST	SEGMENT
??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@ DB 'CityStateBonusModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@INOPFAOD@MinorMilitaryNumExtraUnitsToGift@
CONST	SEGMENT
??_C@_0CB@INOPFAOD@MinorMilitaryNumExtraUnitsToGift@ DB 'MinorMilitaryNum'
	DB	'ExtraUnitsToGift', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LDBBMJHF@MinorResourceBonus?$AA@
CONST	SEGMENT
??_C@_0BD@LDBBMJHF@MinorResourceBonus?$AA@ DB 'MinorResourceBonus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OIOEBHLN@MinorScienceAllies?$AA@
CONST	SEGMENT
??_C@_0BD@OIOEBHLN@MinorScienceAllies?$AA@ DB 'MinorScienceAllies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NDGBALIP@MinorGreatPeopleAllies?$AA@
CONST	SEGMENT
??_C@_0BH@NDGBALIP@MinorGreatPeopleAllies?$AA@ DB 'MinorGreatPeopleAllies'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MKBOLOFE@CityStateTradeChange?$AA@
CONST	SEGMENT
??_C@_0BF@MKBOLOFE@CityStateTradeChange?$AA@ DB 'CityStateTradeChange', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BBIFLCLM@OpenBordersTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BL@BBIFLCLM@OpenBordersTourismModifier?$AA@ DB 'OpenBordersTourism'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LGCJBFHM@TradeRouteTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BK@LGCJBFHM@TradeRouteTourismModifier?$AA@ DB 'TradeRouteTourismMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GLBABIPM@SharedReligionTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BO@GLBABIPM@SharedReligionTourismModifier?$AA@ DB 'SharedReligionT'
	DB	'ourismModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIMAOKOM@CoupChanceModifier?$AA@
CONST	SEGMENT
??_C@_0BD@GIMAOKOM@CoupChanceModifier?$AA@ DB 'CoupChanceModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DKCEDOAL@MinorFriendshipGainBullyGoldSucc@
CONST	SEGMENT
??_C@_0CE@DKCEDOAL@MinorFriendshipGainBullyGoldSucc@ DB 'MinorFriendshipG'
	DB	'ainBullyGoldSuccess', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GOECOIG@HappinessFromGreatImprovements?$AA@
CONST	SEGMENT
??_C@_0BP@GOECOIG@HappinessFromGreatImprovements?$AA@ DB 'HappinessFromGr'
	DB	'eatImprovements', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EMLAAIA@TourismFromTradeMissions?$AA@
CONST	SEGMENT
??_C@_0BJ@EMLAAIA@TourismFromTradeMissions?$AA@ DB 'TourismFromTradeMissi'
	DB	'ons', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IIFBEMOI@InfluenceBoostPerGreatPersonBorn@
CONST	SEGMENT
??_C@_0CB@IIFBEMOI@InfluenceBoostPerGreatPersonBorn@ DB 'InfluenceBoostPe'
	DB	'rGreatPersonBorn', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@
CONST	SEGMENT
??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@ DB 'SciencePerGreatPerso'
	DB	'nBorn', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JKAGNMLN@TradeMissionInfluenceModifier?$AA@
CONST	SEGMENT
??_C@_0BO@JKAGNMLN@TradeMissionInfluenceModifier?$AA@ DB 'TradeMissionInf'
	DB	'luenceModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PLONLNAF@ProductionToGreatMusiciansModifi@
CONST	SEGMENT
??_C@_0CD@PLONLNAF@ProductionToGreatMusiciansModifi@ DB 'ProductionToGrea'
	DB	'tMusiciansModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NMJFENFF@CombatBonusVsSmallerCiv?$AA@
CONST	SEGMENT
??_C@_0BI@NMJFENFF@CombatBonusVsSmallerCiv?$AA@ DB 'CombatBonusVsSmallerC'
	DB	'iv', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EAENMJPL@RailConnectionProductionModifier@
CONST	SEGMENT
??_C@_0CB@EAENMJPL@RailConnectionProductionModifier@ DB 'RailConnectionPr'
	DB	'oductionModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PIJMLMPB@InternalTradeRouteProductionYiel@
CONST	SEGMENT
??_C@_0CI@PIJMLMPB@InternalTradeRouteProductionYiel@ DB 'InternalTradeRou'
	DB	'teProductionYieldChange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KBPBNEF@InternalTradeRouteYieldModifier?$AA@
CONST	SEGMENT
??_C@_0CA@KBPBNEF@InternalTradeRouteYieldModifier?$AA@ DB 'InternalTradeR'
	DB	'outeYieldModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NCANENCP@ThemingBonusMultiplier?$AA@
CONST	SEGMENT
??_C@_0BH@NCANENCP@ThemingBonusMultiplier?$AA@ DB 'ThemingBonusMultiplier'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFKMMHDF@MinorBullyScoreModifier?$AA@
CONST	SEGMENT
??_C@_0BI@DFKMMHDF@MinorBullyScoreModifier?$AA@ DB 'MinorBullyScoreModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@
CONST	SEGMENT
??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@ DB 'AfraidMinorPerTur'
	DB	'nInfluence', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ODMELIBJ@ProtectedMinorPerTurnInfluence?$AA@
CONST	SEGMENT
??_C@_0BP@ODMELIBJ@ProtectedMinorPerTurnInfluence?$AA@ DB 'ProtectedMinor'
	DB	'PerTurnInfluence', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DHAEOHLB@MilitaryUnitGiftExtraInfluence?$AA@
CONST	SEGMENT
??_C@_0BP@DHAEOHLB@MilitaryUnitGiftExtraInfluence?$AA@ DB 'MilitaryUnitGi'
	DB	'ftExtraInfluence', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EDFKCKKD@RiggingElectionModifier?$AA@
CONST	SEGMENT
??_C@_0BI@EDFKCKKD@RiggingElectionModifier?$AA@ DB 'RiggingElectionModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LIPLOMJF@SharedIdeologyTradeGoldChange?$AA@
CONST	SEGMENT
??_C@_0BO@LIPLOMJF@SharedIdeologyTradeGoldChange?$AA@ DB 'SharedIdeologyT'
	DB	'radeGoldChange', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PBNBAHDF@InternalTradeRouteGoldChange?$AA@
CONST	SEGMENT
??_C@_0BN@PBNBAHDF@InternalTradeRouteGoldChange?$AA@ DB 'InternalTradeRou'
	DB	'teGoldChange', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JMHDBAJE@SeaTradeRouteGoldChange?$AA@
CONST	SEGMENT
??_C@_0BI@JMHDBAJE@SeaTradeRouteGoldChange?$AA@ DB 'SeaTradeRouteGoldChan'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NPLFFGBN@LandTradeRouteGoldChange?$AA@
CONST	SEGMENT
??_C@_0BJ@NPLFFGBN@LandTradeRouteGoldChange?$AA@ DB 'LandTradeRouteGoldCh'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NCHBIENE@SharedIdeologyTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BO@NCHBIENE@SharedIdeologyTourismModifier?$AA@ DB 'SharedIdeologyT'
	DB	'ourismModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PKHFPDIL@LessHappyTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@PKHFPDIL@LessHappyTourismModifier?$AA@ DB 'LessHappyTourismModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@ONGDHBAE@CommonFoeTourismModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@ONGDHBAE@CommonFoeTourismModifier?$AA@ DB 'CommonFoeTourismModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BOJEJAGP@CityStateUnitFrequencyModifier?$AA@
CONST	SEGMENT
??_C@_0BP@BOJEJAGP@CityStateUnitFrequencyModifier?$AA@ DB 'CityStateUnitF'
	DB	'requencyModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OKMBJAKL@OtherPlayersMinorFriendshipDecay@
CONST	SEGMENT
??_C@_0CE@OKMBJAKL@OtherPlayersMinorFriendshipDecay@ DB 'OtherPlayersMino'
	DB	'rFriendshipDecayMod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EBPAAEPN@MinorFriendshipDecayMod?$AA@
CONST	SEGMENT
??_C@_0BI@EBPAAEPN@MinorFriendshipDecayMod?$AA@ DB 'MinorFriendshipDecayM'
	DB	'od', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNJFAHMI@MinorFriendshipMinimum?$AA@
CONST	SEGMENT
??_C@_0BH@CNJFAHMI@MinorFriendshipMinimum?$AA@ DB 'MinorFriendshipMinimum'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PGJKGPKO@MinorGoldFriendshipMod?$AA@
CONST	SEGMENT
??_C@_0BH@PGJKGPKO@MinorGoldFriendshipMod?$AA@ DB 'MinorGoldFriendshipMod'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HIEEGHEA@MinorQuestFriendshipMod?$AA@
CONST	SEGMENT
??_C@_0BI@HIEEGHEA@MinorQuestFriendshipMod?$AA@ DB 'MinorQuestFriendshipM'
	DB	'od', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JMMGOOCJ@ExpInBorderModifier?$AA@
CONST	SEGMENT
??_C@_0BE@JMMGOOCJ@ExpInBorderModifier?$AA@ DB 'ExpInBorderModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OLBPIHKG@ExpModifier?$AA@
CONST	SEGMENT
??_C@_0M@OLBPIHKG@ExpModifier?$AA@ DB 'ExpModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONAKJGND@FreeSpecialist?$AA@
CONST	SEGMENT
??_C@_0P@ONAKJGND@FreeSpecialist?$AA@ DB 'FreeSpecialist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FBAEOHNO@GarrisonFreeMaintenance?$AA@
CONST	SEGMENT
??_C@_0BI@FBAEOHNO@GarrisonFreeMaintenance?$AA@ DB 'GarrisonFreeMaintenan'
	DB	'ce', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DOIJCEHM@RevealAllCapitals?$AA@
CONST	SEGMENT
??_C@_0BC@DOIJCEHM@RevealAllCapitals?$AA@ DB 'RevealAllCapitals', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MDAIKGML@AlwaysSeeBarbCamps?$AA@
CONST	SEGMENT
??_C@_0BD@MDAIKGML@AlwaysSeeBarbCamps?$AA@ DB 'AlwaysSeeBarbCamps', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HFMOGHPJ@BarbarianCombatBonus?$AA@
CONST	SEGMENT
??_C@_0BF@HFMOGHPJ@BarbarianCombatBonus?$AA@ DB 'BarbarianCombatBonus', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@
CONST	SEGMENT
??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@ DB 'UnitUpgradeCostMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HBALDEPJ@WoundedUnitDamageMod?$AA@
CONST	SEGMENT
??_C@_0BF@HBALDEPJ@WoundedUnitDamageMod?$AA@ DB 'WoundedUnitDamageMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHHEPDOA@MaxConscript?$AA@
CONST	SEGMENT
??_C@_0N@EHHEPDOA@MaxConscript?$AA@ DB 'MaxConscript', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PINGGCAG@MilitaryFoodProduction?$AA@
CONST	SEGMENT
??_C@_0BH@PINGGCAG@MilitaryFoodProduction?$AA@ DB 'MilitaryFoodProduction'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HOBGLLL@HalfSpecialistFood?$AA@
CONST	SEGMENT
??_C@_0BD@HOBGLLL@HalfSpecialistFood?$AA@ DB 'HalfSpecialistFood', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JCLIINCC@HalfMoreSpecialistUnhappiness?$AA@
CONST	SEGMENT
??_C@_0BO@JCLIINCC@HalfMoreSpecialistUnhappiness?$AA@ DB 'HalfMoreSpecial'
	DB	'istUnhappiness', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MNPNKBOH@HalfSpecialistUnhappiness?$AA@
CONST	SEGMENT
??_C@_0BK@MNPNKBOH@HalfSpecialistUnhappiness?$AA@ DB 'HalfSpecialistUnhap'
	DB	'piness', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFJBPGNL@NumCitiesFreeFoodBuilding?$AA@
CONST	SEGMENT
??_C@_0BK@KFJBPGNL@NumCitiesFreeFoodBuilding?$AA@ DB 'NumCitiesFreeFoodBu'
	DB	'ilding', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FIEHLJMJ@NumCitiesFreeCultureBuilding?$AA@
CONST	SEGMENT
??_C@_0BN@FIEHLJMJ@NumCitiesFreeCultureBuilding?$AA@ DB 'NumCitiesFreeCul'
	DB	'tureBuilding', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KDKHHJEK@NumCitiesFreeWalls?$AA@
CONST	SEGMENT
??_C@_0BD@KDKHHJEK@NumCitiesFreeWalls?$AA@ DB 'NumCitiesFreeWalls', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JOIILMDO@NumCitiesFreePietyGardens?$AA@
CONST	SEGMENT
??_C@_0BK@JOIILMDO@NumCitiesFreePietyGardens?$AA@ DB 'NumCitiesFreePietyG'
	DB	'ardens', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ELCFNBD@NumCitiesFreeAestheticsSchools?$AA@
CONST	SEGMENT
??_C@_0BP@ELCFNBD@NumCitiesFreeAestheticsSchools?$AA@ DB 'NumCitiesFreeAe'
	DB	'stheticsSchools', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ELPPBGEP@GoldToScience?$AA@
CONST	SEGMENT
??_C@_0O@ELPPBGEP@GoldToScience?$AA@ DB 'GoldToScience', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CDMOEEGG@HappinessToScience?$AA@
CONST	SEGMENT
??_C@_0BD@CDMOEEGG@HappinessToScience?$AA@ DB 'HappinessToScience', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MMMKOKOB@HappinessToCulture?$AA@
CONST	SEGMENT
??_C@_0BD@MMMKOKOB@HappinessToCulture?$AA@ DB 'HappinessToCulture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NKCDCBLE@HappyPerMilitaryUnit?$AA@
CONST	SEGMENT
??_C@_0BF@NKCDCBLE@HappyPerMilitaryUnit?$AA@ DB 'HappyPerMilitaryUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IKEGJHGF@UnitSupplyMod?$AA@
CONST	SEGMENT
??_C@_0O@IKEGJHGF@UnitSupplyMod?$AA@ DB 'UnitSupplyMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GPCCGJFH@UnitGoldMaintenanceMod?$AA@
CONST	SEGMENT
??_C@_0BH@GPCCGJFH@UnitGoldMaintenanceMod?$AA@ DB 'UnitGoldMaintenanceMod'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GOKAHANB@BuildingGoldMaintenanceMod?$AA@
CONST	SEGMENT
??_C@_0BL@GOKAHANB@BuildingGoldMaintenanceMod?$AA@ DB 'BuildingGoldMainte'
	DB	'nanceMod', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPCPBJHC@RouteGoldMaintenanceMod?$AA@
CONST	SEGMENT
??_C@_0BI@JPCPBJHC@RouteGoldMaintenanceMod?$AA@ DB 'RouteGoldMaintenanceM'
	DB	'od', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EOGMLPFM@FreeFoodBox?$AA@
CONST	SEGMENT
??_C@_0M@EOGMLPFM@FreeFoodBox?$AA@ DB 'FreeFoodBox', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PDNAFCEG@NewCityExtraPopulation?$AA@
CONST	SEGMENT
??_C@_0BH@PDNAFCEG@NewCityExtraPopulation?$AA@ DB 'NewCityExtraPopulation'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MIGPIJHP@CapitalSettlerProductionModifier@
CONST	SEGMENT
??_C@_0CB@MIGPIJHP@CapitalSettlerProductionModifier@ DB 'CapitalSettlerPr'
	DB	'oductionModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KEMFJDHB@SettlerProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BK@KEMFJDHB@SettlerProductionModifier?$AA@ DB 'SettlerProductionMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IIOEMOFG@CapitalGrowthMod?$AA@
CONST	SEGMENT
??_C@_0BB@IIOEMOFG@CapitalGrowthMod?$AA@ DB 'CapitalGrowthMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KIHLCIGE@CityGrowthMod?$AA@
CONST	SEGMENT
??_C@_0O@KIHLCIGE@CityGrowthMod?$AA@ DB 'CityGrowthMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGKPMHDI@CityStrengthMod?$AA@
CONST	SEGMENT
??_C@_0BA@JGKPMHDI@CityStrengthMod?$AA@ DB 'CityStrengthMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMFGEEFC@GoldPerMilitaryUnit?$AA@
CONST	SEGMENT
??_C@_0BE@LMFGEEFC@GoldPerMilitaryUnit?$AA@ DB 'GoldPerMilitaryUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CELEIBNP@GoldPerUnit?$AA@
CONST	SEGMENT
??_C@_0M@CELEIBNP@GoldPerUnit?$AA@ DB 'GoldPerUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEHHPDEP@CatchSpiesModifier?$AA@
CONST	SEGMENT
??_C@_0BD@FEHHPDEP@CatchSpiesModifier?$AA@ DB 'CatchSpiesModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PDPCGKIO@StealTechFasterModifier?$AA@
CONST	SEGMENT
??_C@_0BI@PDPCGKIO@StealTechFasterModifier?$AA@ DB 'StealTechFasterModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GKMOPGMA@StealTechSlowerModifier?$AA@
CONST	SEGMENT
??_C@_0BI@GKMOPGMA@StealTechSlowerModifier?$AA@ DB 'StealTechSlowerModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FGEFNEAF@CulturalPlunderMultiplier?$AA@
CONST	SEGMENT
??_C@_0BK@FGEFNEAF@CulturalPlunderMultiplier?$AA@ DB 'CulturalPlunderMult'
	DB	'iplier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LIHGJKGH@FaithCostModifier?$AA@
CONST	SEGMENT
??_C@_0BC@LIHGJKGH@FaithCostModifier?$AA@ DB 'FaithCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OGAAKMBL@TradeMissionGoldModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@OGAAKMBL@TradeMissionGoldModifier?$AA@ DB 'TradeMissionGoldModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CKGIHFME@CityConnectionTradeRouteGoldModi@
CONST	SEGMENT
??_C@_0CF@CKGIHFME@CityConnectionTradeRouteGoldModi@ DB 'CityConnectionTr'
	DB	'adeRouteGoldModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDJBNLIP@BuildingPurchaseCostModifier?$AA@
CONST	SEGMENT
??_C@_0BN@MDJBNLIP@BuildingPurchaseCostModifier?$AA@ DB 'BuildingPurchase'
	DB	'CostModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MKCDENAA@UnitPurchaseCostModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@MKCDENAA@UnitPurchaseCostModifier?$AA@ DB 'UnitPurchaseCostModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ELHNOAEL@GarrisonedCityRangeStrikeModifie@
CONST	SEGMENT
??_C@_0CC@ELHNOAEL@GarrisonedCityRangeStrikeModifie@ DB 'GarrisonedCityRa'
	DB	'ngeStrikeModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MEMOKKJL@NumCitiesResearchCostDiscount?$AA@
CONST	SEGMENT
??_C@_0BO@MEMOKKJL@NumCitiesResearchCostDiscount?$AA@ DB 'NumCitiesResear'
	DB	'chCostDiscount', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@COIEECHE@NumCitiesPolicyCostDiscount?$AA@
CONST	SEGMENT
??_C@_0BM@COIEECHE@NumCitiesPolicyCostDiscount?$AA@ DB 'NumCitiesPolicyCo'
	DB	'stDiscount', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FKOPEKNC@PlotCultureExponentModifier?$AA@
CONST	SEGMENT
??_C@_0BM@FKOPEKNC@PlotCultureExponentModifier?$AA@ DB 'PlotCultureExpone'
	DB	'ntModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@
CONST	SEGMENT
??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@ DB 'PlotCultureCostModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EBDNNHOP@PlotGoldCostMod?$AA@
CONST	SEGMENT
??_C@_0BA@EBDNNHOP@PlotGoldCostMod?$AA@ DB 'PlotGoldCostMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ONFGPAJH@NumExtraBuilders?$AA@
CONST	SEGMENT
??_C@_0BB@ONFGPAJH@NumExtraBuilders?$AA@ DB 'NumExtraBuilders', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IMKGJEKK@UnhappinessFromUnitsMod?$AA@
CONST	SEGMENT
??_C@_0BI@IMKGJEKK@UnhappinessFromUnitsMod?$AA@ DB 'UnhappinessFromUnitsM'
	DB	'od', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@
CONST	SEGMENT
??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@ DB 'ExtraHappinessPerLuxu'
	DB	'ry', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EKOONHKP@HappinessPerXPopulation?$AA@
CONST	SEGMENT
??_C@_0BI@EKOONHKP@HappinessPerXPopulation?$AA@ DB 'HappinessPerXPopulati'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NOANKODL@HappinessPerRailConnection?$AA@
CONST	SEGMENT
??_C@_0BL@NOANKODL@HappinessPerRailConnection?$AA@ DB 'HappinessPerRailCo'
	DB	'nnection', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FKMKPMOM@HappinessPerTradeRoute?$AA@
CONST	SEGMENT
??_C@_0BH@FKMKPMOM@HappinessPerTradeRoute?$AA@ DB 'HappinessPerTradeRoute'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JGKBABME@CulturePerGarrisonedUnit?$AA@
CONST	SEGMENT
??_C@_0BJ@JGKBABME@CulturePerGarrisonedUnit?$AA@ DB 'CulturePerGarrisoned'
	DB	'Unit', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JJAGICMO@HappinessPerGarrisonedUnit?$AA@
CONST	SEGMENT
??_C@_0BL@JJAGICMO@HappinessPerGarrisonedUnit?$AA@ DB 'HappinessPerGarris'
	DB	'onedUnit', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HCLGJPMG@FreeMilitaryUnitsPopulationPerce@
CONST	SEGMENT
??_C@_0CD@HCLGJPMG@FreeMilitaryUnitsPopulationPerce@ DB 'FreeMilitaryUnit'
	DB	'sPopulationPercent', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OICFPJHJ@FreeUnitsPopulationPercent?$AA@
CONST	SEGMENT
??_C@_0BL@OICFPJHJ@FreeUnitsPopulationPercent?$AA@ DB 'FreeUnitsPopulatio'
	DB	'nPercent', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HNNABIFD@BaseFreeMilitaryUnits?$AA@
CONST	SEGMENT
??_C@_0BG@HNNABIFD@BaseFreeMilitaryUnits?$AA@ DB 'BaseFreeMilitaryUnits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EIFAIMLA@BaseFreeUnits?$AA@
CONST	SEGMENT
??_C@_0O@EIFAIMLA@BaseFreeUnits?$AA@ DB 'BaseFreeUnits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@ DB 'MilitaryProduction'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CFFAKCBM@SpecialistUpgradeModifier?$AA@
CONST	SEGMENT
??_C@_0BK@CFFAKCBM@SpecialistUpgradeModifier?$AA@ DB 'SpecialistUpgradeMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BCNFIGMF@SpecialistProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BN@BCNFIGMF@SpecialistProductionModifier?$AA@ DB 'SpecialistProduc'
	DB	'tionModifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HAEEHIKP@ImprovementUpgradeRateModifier?$AA@
CONST	SEGMENT
??_C@_0BP@HAEEHIKP@ImprovementUpgradeRateModifier?$AA@ DB 'ImprovementUpg'
	DB	'radeRateModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@OOJHBKNI@ImprovementCostModifier?$AA@
CONST	SEGMENT
??_C@_0BI@OOJHBKNI@ImprovementCostModifier?$AA@ DB 'ImprovementCostModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BBFBLGII@AllFeatureProduction?$AA@
CONST	SEGMENT
??_C@_0BF@BBFBLGII@AllFeatureProduction?$AA@ DB 'AllFeatureProduction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
CONST	SEGMENT
??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@ DB 'WorkerSpeedModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOBEEGOH@FreeExperience?$AA@
CONST	SEGMENT
??_C@_0P@MOBEEGOH@FreeExperience?$AA@ DB 'FreeExperience', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GLEFCJIP@CapitalUnhappinessMod?$AA@
CONST	SEGMENT
??_C@_0BG@GLEFCJIP@CapitalUnhappinessMod?$AA@ DB 'CapitalUnhappinessMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MDKPLGNJ@OccupiedPopulationUnhappinessMod@
CONST	SEGMENT
??_C@_0CB@MDKPLGNJ@OccupiedPopulationUnhappinessMod@ DB 'OccupiedPopulati'
	DB	'onUnhappinessMod', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@
CONST	SEGMENT
??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@ DB 'CityCountUnhappinessM'
	DB	'od', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MJJHCDCN@UnhappinessMod?$AA@
CONST	SEGMENT
??_C@_0P@MJJHCDCN@UnhappinessMod?$AA@ DB 'UnhappinessMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BNECOPBF@ExtraHappinessPerCity?$AA@
CONST	SEGMENT
??_C@_0BG@BNECOPBF@ExtraHappinessPerCity?$AA@ DB 'ExtraHappinessPerCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PKOJCLKH@ExtraHappiness?$AA@
CONST	SEGMENT
??_C@_0P@PKOJCLKH@ExtraHappiness?$AA@ DB 'ExtraHappiness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PIKCEEAD@DomesticGreatGeneralRateModifier@
CONST	SEGMENT
??_C@_0CB@PIKCEEAD@DomesticGreatGeneralRateModifier@ DB 'DomesticGreatGen'
	DB	'eralRateModifier', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@
CONST	SEGMENT
??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@ DB 'GreatScientistRate'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EFBINBKL@GreatMerchantRateModifier?$AA@
CONST	SEGMENT
??_C@_0BK@EFBINBKL@GreatMerchantRateModifier?$AA@ DB 'GreatMerchantRateMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EGCNJBGG@GreatMusicianRateModifier?$AA@
CONST	SEGMENT
??_C@_0BK@EGCNJBGG@GreatMusicianRateModifier?$AA@ DB 'GreatMusicianRateMo'
	DB	'difier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EDMONEDH@GreatArtistRateModifier?$AA@
CONST	SEGMENT
??_C@_0BI@EDMONEDH@GreatArtistRateModifier?$AA@ DB 'GreatArtistRateModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LJIIKCIN@GreatWriterRateModifier?$AA@
CONST	SEGMENT
??_C@_0BI@LJIIKCIN@GreatWriterRateModifier?$AA@ DB 'GreatWriterRateModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OJPABOPK@GreatAdmiralRateModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@OJPABOPK@GreatAdmiralRateModifier?$AA@ DB 'GreatAdmiralRateModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@ DB 'GreatGeneralRateModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@
CONST	SEGMENT
??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@ DB 'GreatPeopleRateModifi'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@ DB 'BuildingProduction'
	DB	'Modifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@
CONST	SEGMENT
??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@ DB 'WonderProductionModi'
	DB	'fier', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OHPDEMNG@StrategicResourceMod?$AA@
CONST	SEGMENT
??_C@_0BF@OHPDEMNG@StrategicResourceMod?$AA@ DB 'StrategicResourceMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@
CONST	SEGMENT
??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@ DB 'MedianTechPercentChan'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OGNCLEHN@NumExtraSpies?$AA@
CONST	SEGMENT
??_C@_0O@OGNCLEHN@NumExtraSpies?$AA@ DB 'NumExtraSpies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMFDFLLL@NumFreeGreatPeople?$AA@
CONST	SEGMENT
??_C@_0BD@JMFDFLLL@NumFreeGreatPeople?$AA@ DB 'NumFreeGreatPeople', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BKNGJGHF@NumFreePolicies?$AA@
CONST	SEGMENT
??_C@_0BA@BKNGJGHF@NumFreePolicies?$AA@ DB 'NumFreePolicies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DBLFACAI@NumFreeTechs?$AA@
CONST	SEGMENT
??_C@_0N@DBLFACAI@NumFreeTechs?$AA@ DB 'NumFreeTechs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MHEADKKO@GoldenAgeDurationMod?$AA@
CONST	SEGMENT
??_C@_0BF@MHEADKKO@GoldenAgeDurationMod?$AA@ DB 'GoldenAgeDurationMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GGDDOBLH@GoldenAgeMeterMod?$AA@
CONST	SEGMENT
??_C@_0BC@GGDDOBLH@GoldenAgeMeterMod?$AA@ DB 'GoldenAgeMeterMod', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BJCGNFDJ@GoldenAgeTurns?$AA@
CONST	SEGMENT
??_C@_0P@BJCGNFDJ@GoldenAgeTurns?$AA@ DB 'GoldenAgeTurns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCLFIBJM@AttackBonusTurns?$AA@
CONST	SEGMENT
??_C@_0BB@LCLFIBJM@AttackBonusTurns?$AA@ DB 'AttackBonusTurns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KHNGHMJB@EmbarkedExtraMoves?$AA@
CONST	SEGMENT
??_C@_0BD@KHNGHMJB@EmbarkedExtraMoves?$AA@ DB 'EmbarkedExtraMoves', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCLFMNEB@ScienceFromKills?$AA@
CONST	SEGMENT
??_C@_0BB@OCLFMNEB@ScienceFromKills?$AA@ DB 'ScienceFromKills', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFCPKMIO@GoldFromKills?$AA@
CONST	SEGMENT
??_C@_0O@IFCPKMIO@GoldFromKills?$AA@ DB 'GoldFromKills', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DICAPLG@CultureFromBarbarianKills?$AA@
CONST	SEGMENT
??_C@_0BK@DICAPLG@CultureFromBarbarianKills?$AA@ DB 'CultureFromBarbarian'
	DB	'Kills', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@
CONST	SEGMENT
??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@ DB 'CultureFromKills', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBDGMPP@CultureImprovementChange?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBDGMPP@CultureImprovementChange?$AA@ DB 'CultureImprovementCh'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KNLKNLF@CulturePerTechResearched?$AA@
CONST	SEGMENT
??_C@_0BJ@KNLKNLF@CulturePerTechResearched?$AA@ DB 'CulturePerTechResearc'
	DB	'hed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DGDBMDFC@CultureWonderMultiplier?$AA@
CONST	SEGMENT
??_C@_0BI@DGDBMDFC@CultureWonderMultiplier?$AA@ DB 'CultureWonderMultipli'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIMEGBNN@CulturePerWonder?$AA@
CONST	SEGMENT
??_C@_0BB@LIMEGBNN@CulturePerWonder?$AA@ DB 'CulturePerWonder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLGECCII@CulturePerCity?$AA@
CONST	SEGMENT
??_C@_0P@HLGECCII@CulturePerCity?$AA@ DB 'CulturePerCity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@
CONST	SEGMENT
??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@ DB 'PolicyCostModifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KOHFLOFG@Level?$AA@
CONST	SEGMENT
??_C@_05KOHFLOFG@Level?$AA@ DB 'Level', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LNPLOKEP@GridY?$AA@
CONST	SEGMENT
??_C@_05LNPLOKEP@GridY?$AA@ DB 'GridY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KEOANLAO@GridX?$AA@
CONST	SEGMENT
??_C@_05KEOANLAO@GridX?$AA@ DB 'GridX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMLKLLCO@CultureCost?$AA@
CONST	SEGMENT
??_C@_0M@IMLKLLCO@CultureCost?$AA@ DB 'CultureCost', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$19
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv1572 = -1076						; size = 4
tv1765 = -1072						; size = 4
_this$ = -1068						; size = 4
$T231673 = -460						; size = 8
_count$231469 = -436					; size = 4
_count$231462 = -424					; size = 4
_count$231455 = -412					; size = 4
$T231442 = -408						; size = 4
$T231441 = -404						; size = 4
$T231437 = -400						; size = 4
$T231433 = -396						; size = 4
$T231432 = -392						; size = 4
$T231417 = -388						; size = 12
$T231416 = -376						; size = 4
$T231415 = -372						; size = 8
$T231414 = -364						; size = 8
$T231413 = -356						; size = 28
_UnitPromotionID$223420 = -328				; size = 4
_UnitCombatInfoID$223421 = -324				; size = 4
_szSQL$223415 = -320					; size = 4
_pResults$223413 = -316					; size = 4
_sqlKey$223411 = -312					; size = 28
_szSQL$223405 = -284					; size = 4
_pResults$223403 = -280					; size = 4
_sqlKey$223401 = -276					; size = 28
_i$223407 = -248					; size = 4
_szSQL$223394 = -244					; size = 4
_pResults$223392 = -240					; size = 4
_sqlKey$223390 = -236					; size = 28
_i$223396 = -208					; size = 4
_szSQL$223383 = -204					; size = 4
_pResults$223381 = -200					; size = 4
_sqlKey$223379 = -196					; size = 28
_i$223385 = -168					; size = 4
_yield$223369 = -164					; size = 4
_ImprovementID$223367 = -160				; size = 4
_YieldID$223368 = -156					; size = 4
_pResults$223361 = -152					; size = 4
_strKey$223359 = -148					; size = 28
_iYieldChange$223357 = -120				; size = 4
_BuildingClassID$223355 = -116				; size = 4
_iYieldID$223356 = -112					; size = 4
_pResults$223349 = -108					; size = 4
_strKey$223347 = -104					; size = 28
_iYieldMod$223346 = -76					; size = 4
_BuildingClassID$223344 = -72				; size = 4
_iYieldID$223345 = -68					; size = 4
_pResults$223338 = -64					; size = 4
_strKey$223336 = -60					; size = 28
__$ArrayPad$ = -32					; size = 4
_szTechPrereq$ = -28					; size = 4
_szPolicyType$ = -24					; size = 4
_szPolicyBranchType$ = -20				; size = 4
_szFreeBuilding$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvPolicyEntry::CacheResults, COMDAT
; _this$ = ecx

; 347  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1064				; 00000428H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 348  : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN23@CacheResul

; 349  : 		return false;

	xor	al, al
	jmp	$LN24@CacheResul
$LN23@CacheResul:

; 350  : 
; 351  : 	//Basic Properties
; 352  : 	m_iCultureCost = kResults.GetInt("CultureCost");

	push	OFFSET ??_C@_0M@IMLKLLCO@CultureCost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 353  : 	m_iGridX = kResults.GetInt("GridX");

	push	OFFSET ??_C@_05KEOANLAO@GridX?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+268], eax

; 354  : 	m_iGridY = kResults.GetInt("GridY");

	push	OFFSET ??_C@_05LNPLOKEP@GridY?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 355  : 	m_iLevel = kResults.GetInt("Level");

	push	OFFSET ??_C@_05KOHFLOFG@Level?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], eax

; 356  : 	m_iPolicyCostModifier = kResults.GetInt("PolicyCostModifier");

	push	OFFSET ??_C@_0BD@MIAKAFOH@PolicyCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], eax

; 357  : 	m_iCulturePerCity = kResults.GetInt("CulturePerCity");

	push	OFFSET ??_C@_0P@HLGECCII@CulturePerCity?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], eax

; 358  : #ifdef FRUITY_TRADITION_ARISTOCRACY
; 359  : 	m_iCapitalCulturePerUniqueLuxury = kResults.GetInt("CapitalCulturePerUniqueLuxury");
; 360  : #endif
; 361  : 	m_iCulturePerWonder = kResults.GetInt("CulturePerWonder");

	push	OFFSET ??_C@_0BB@LIMEGBNN@CulturePerWonder?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax

; 362  : 	m_iCultureWonderMultiplier = kResults.GetInt("CultureWonderMultiplier");

	push	OFFSET ??_C@_0BI@DGDBMDFC@CultureWonderMultiplier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], eax

; 363  : 	m_iCulturePerTechResearched = kResults.GetInt("CulturePerTechResearched");

	push	OFFSET ??_C@_0BJ@KNLKNLF@CulturePerTechResearched?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 364  : 	m_iCultureImprovementChange = kResults.GetInt("CultureImprovementChange");

	push	OFFSET ??_C@_0BJ@BLBDGMPP@CultureImprovementChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], eax

; 365  : 	m_iCultureFromKills = kResults.GetInt("CultureFromKills");

	push	OFFSET ??_C@_0BB@EMBLNIDN@CultureFromKills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+304], eax

; 366  : 	m_iCultureFromBarbarianKills = kResults.GetInt("CultureFromBarbarianKills");

	push	OFFSET ??_C@_0BK@DICAPLG@CultureFromBarbarianKills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+308], eax

; 367  : 	m_iGoldFromKills = kResults.GetInt("GoldFromKills");

	push	OFFSET ??_C@_0O@IFCPKMIO@GoldFromKills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+312], eax

; 368  : 	m_iScienceFromKills = kResults.GetInt("ScienceFromKills"); // NQMP GJS - Honor Finisher

	push	OFFSET ??_C@_0BB@OCLFMNEB@ScienceFromKills?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+316], eax

; 369  : 	m_iEmbarkedExtraMoves = kResults.GetInt("EmbarkedExtraMoves");

	push	OFFSET ??_C@_0BD@KHNGHMJB@EmbarkedExtraMoves?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], eax

; 370  : 	m_iAttackBonusTurns = kResults.GetInt("AttackBonusTurns");

	push	OFFSET ??_C@_0BB@LCLFIBJM@AttackBonusTurns?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+324], eax

; 371  : 	m_iGoldenAgeTurns = kResults.GetInt("GoldenAgeTurns");

	push	OFFSET ??_C@_0P@BJCGNFDJ@GoldenAgeTurns?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+328], eax

; 372  : 	m_iGoldenAgeMeterMod = kResults.GetInt("GoldenAgeMeterMod");

	push	OFFSET ??_C@_0BC@GGDDOBLH@GoldenAgeMeterMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+332], eax

; 373  : 	m_iGoldenAgeDurationMod = kResults.GetInt("GoldenAgeDurationMod");

	push	OFFSET ??_C@_0BF@MHEADKKO@GoldenAgeDurationMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+336], eax

; 374  : 	m_iNumFreeTechs = kResults.GetInt("NumFreeTechs");

	push	OFFSET ??_C@_0N@DBLFACAI@NumFreeTechs?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+340], eax

; 375  : 	m_iNumFreePolicies = kResults.GetInt("NumFreePolicies");

	push	OFFSET ??_C@_0BA@BKNGJGHF@NumFreePolicies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+344], eax

; 376  : 	m_iNumFreeGreatPeople = kResults.GetInt("NumFreeGreatPeople");

	push	OFFSET ??_C@_0BD@JMFDFLLL@NumFreeGreatPeople?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+348], eax

; 377  : #ifdef NQ_EXTRA_SPIES_FROM_POLICIES
; 378  : 	m_iNumExtraSpies = kResults.GetInt("NumExtraSpies");

	push	OFFSET ??_C@_0O@OGNCLEHN@NumExtraSpies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+352], eax

; 379  : #endif
; 380  : 	m_iMedianTechPercentChange = kResults.GetInt("MedianTechPercentChange");

	push	OFFSET ??_C@_0BI@COMEBICJ@MedianTechPercentChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+356], eax

; 381  : 	m_iStrategicResourceMod = kResults.GetInt("StrategicResourceMod");

	push	OFFSET ??_C@_0BF@OHPDEMNG@StrategicResourceMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+360], eax

; 382  : 	m_iWonderProductionModifier = kResults.GetInt("WonderProductionModifier");

	push	OFFSET ??_C@_0BJ@KGAAGHKI@WonderProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+364], eax

; 383  : 	m_iBuildingProductionModifier = kResults.GetInt("BuildingProductionModifier");

	push	OFFSET ??_C@_0BL@HLGIJEIL@BuildingProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+368], eax

; 384  : 	m_iGreatPeopleRateModifier = kResults.GetInt("GreatPeopleRateModifier");

	push	OFFSET ??_C@_0BI@DKDDAFPG@GreatPeopleRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+372], eax

; 385  : 	m_iGreatGeneralRateModifier = kResults.GetInt("GreatGeneralRateModifier");

	push	OFFSET ??_C@_0BJ@MFKPLGEE@GreatGeneralRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+376], eax

; 386  : 	m_iGreatAdmiralRateModifier = kResults.GetInt("GreatAdmiralRateModifier");

	push	OFFSET ??_C@_0BJ@OJPABOPK@GreatAdmiralRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+380], eax

; 387  : 	m_iGreatWriterRateModifier = kResults.GetInt("GreatWriterRateModifier");

	push	OFFSET ??_C@_0BI@LJIIKCIN@GreatWriterRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+384], eax

; 388  : 	m_iGreatArtistRateModifier = kResults.GetInt("GreatArtistRateModifier");

	push	OFFSET ??_C@_0BI@EDMONEDH@GreatArtistRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+388], eax

; 389  : 	m_iGreatMusicianRateModifier = kResults.GetInt("GreatMusicianRateModifier");

	push	OFFSET ??_C@_0BK@EGCNJBGG@GreatMusicianRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+392], eax

; 390  : 	m_iGreatMerchantRateModifier = kResults.GetInt("GreatMerchantRateModifier");

	push	OFFSET ??_C@_0BK@EFBINBKL@GreatMerchantRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+396], eax

; 391  : 	m_iGreatScientistRateModifier = kResults.GetInt("GreatScientistRateModifier");

	push	OFFSET ??_C@_0BL@JEHMMHCB@GreatScientistRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+400], eax

; 392  : 	m_iDomesticGreatGeneralRateModifier = kResults.GetInt("DomesticGreatGeneralRateModifier");

	push	OFFSET ??_C@_0CB@PIKCEEAD@DomesticGreatGeneralRateModifier@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+404], eax

; 393  : 	m_iExtraHappiness = kResults.GetInt("ExtraHappiness");

	push	OFFSET ??_C@_0P@PKOJCLKH@ExtraHappiness?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+408], eax

; 394  : 	m_iExtraHappinessPerCity = kResults.GetInt("ExtraHappinessPerCity");

	push	OFFSET ??_C@_0BG@BNECOPBF@ExtraHappinessPerCity?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+412], eax

; 395  : 	m_iUnhappinessMod = kResults.GetInt("UnhappinessMod");

	push	OFFSET ??_C@_0P@MJJHCDCN@UnhappinessMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+416], eax

; 396  : 	m_iCityCountUnhappinessMod = kResults.GetInt("CityCountUnhappinessMod");

	push	OFFSET ??_C@_0BI@NMIGNJMC@CityCountUnhappinessMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+420], eax

; 397  : 	m_iOccupiedPopulationUnhappinessMod = kResults.GetInt("OccupiedPopulationUnhappinessMod");

	push	OFFSET ??_C@_0CB@MDKPLGNJ@OccupiedPopulationUnhappinessMod@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+424], eax

; 398  : 	m_iCapitalUnhappinessMod = kResults.GetInt("CapitalUnhappinessMod");

	push	OFFSET ??_C@_0BG@GLEFCJIP@CapitalUnhappinessMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+428], eax

; 399  : 	m_iFreeExperience = kResults.GetInt("FreeExperience");

	push	OFFSET ??_C@_0P@MOBEEGOH@FreeExperience?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+432], eax

; 400  : 	m_iWorkerSpeedModifier = kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET ??_C@_0BE@NGOPBNAB@WorkerSpeedModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+436], eax

; 401  : 	m_iAllFeatureProduction = kResults.GetInt("AllFeatureProduction");

	push	OFFSET ??_C@_0BF@BBFBLGII@AllFeatureProduction?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+440], eax

; 402  : 	m_iImprovementCostModifier = kResults.GetInt("ImprovementCostModifier");

	push	OFFSET ??_C@_0BI@OOJHBKNI@ImprovementCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+444], eax

; 403  : 	m_iImprovementUpgradeRateModifier = kResults.GetInt("ImprovementUpgradeRateModifier");

	push	OFFSET ??_C@_0BP@HAEEHIKP@ImprovementUpgradeRateModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+448], eax

; 404  : 	m_iSpecialistProductionModifier = kResults.GetInt("SpecialistProductionModifier");

	push	OFFSET ??_C@_0BN@BCNFIGMF@SpecialistProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+452], eax

; 405  : 	m_iSpecialistUpgradeModifier = kResults.GetInt("SpecialistUpgradeModifier");

	push	OFFSET ??_C@_0BK@CFFAKCBM@SpecialistUpgradeModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+456], eax

; 406  : 	m_iMilitaryProductionModifier = kResults.GetInt("MilitaryProductionModifier");

	push	OFFSET ??_C@_0BL@DFCFJKDP@MilitaryProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+460], eax

; 407  : 	m_iBaseFreeUnits = kResults.GetInt("BaseFreeUnits");

	push	OFFSET ??_C@_0O@EIFAIMLA@BaseFreeUnits?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], eax

; 408  : 	m_iBaseFreeMilitaryUnits = kResults.GetInt("BaseFreeMilitaryUnits");

	push	OFFSET ??_C@_0BG@HNNABIFD@BaseFreeMilitaryUnits?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+468], eax

; 409  : 	m_iFreeUnitsPopulationPercent = kResults.GetInt("FreeUnitsPopulationPercent");

	push	OFFSET ??_C@_0BL@OICFPJHJ@FreeUnitsPopulationPercent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+472], eax

; 410  : 	m_iFreeMilitaryUnitsPopulationPercent = kResults.GetInt("FreeMilitaryUnitsPopulationPercent");

	push	OFFSET ??_C@_0CD@HCLGJPMG@FreeMilitaryUnitsPopulationPerce@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+476], eax

; 411  : 	m_iHappinessPerGarrisonedUnit = kResults.GetInt("HappinessPerGarrisonedUnit");

	push	OFFSET ??_C@_0BL@JJAGICMO@HappinessPerGarrisonedUnit?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+480], eax

; 412  : 	m_iCulturePerGarrisonedUnit = kResults.GetInt("CulturePerGarrisonedUnit");

	push	OFFSET ??_C@_0BJ@JGKBABME@CulturePerGarrisonedUnit?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+484], eax

; 413  : 	m_iHappinessPerTradeRoute = kResults.GetInt("HappinessPerTradeRoute");

	push	OFFSET ??_C@_0BH@FKMKPMOM@HappinessPerTradeRoute?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+488], eax

; 414  : #ifdef NQ_RAIL_CONNECTION_HAPPINESS_FROM_POLICIES
; 415  : 	m_iHappinessPerRailConnection = kResults.GetInt("HappinessPerRailConnection");

	push	OFFSET ??_C@_0BL@NOANKODL@HappinessPerRailConnection?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], eax

; 416  : #endif
; 417  : 	m_iHappinessPerXPopulation = kResults.GetInt("HappinessPerXPopulation");

	push	OFFSET ??_C@_0BI@EKOONHKP@HappinessPerXPopulation?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+496], eax

; 418  : 	m_iExtraHappinessPerLuxury = kResults.GetInt("ExtraHappinessPerLuxury");

	push	OFFSET ??_C@_0BI@KDPCJKIO@ExtraHappinessPerLuxury?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+500], eax

; 419  : 	m_iUnhappinessFromUnitsMod = kResults.GetInt("UnhappinessFromUnitsMod");

	push	OFFSET ??_C@_0BI@IMKGJEKK@UnhappinessFromUnitsMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+504], eax

; 420  : 	m_iNumExtraBuilders = kResults.GetInt("NumExtraBuilders");

	push	OFFSET ??_C@_0BB@ONFGPAJH@NumExtraBuilders?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+508], eax

; 421  : 	m_iPlotGoldCostMod = kResults.GetInt("PlotGoldCostMod");

	push	OFFSET ??_C@_0BA@EBDNNHOP@PlotGoldCostMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+512], eax

; 422  : 	m_iPlotCultureCostModifier = kResults.GetInt("PlotCultureCostModifier");

	push	OFFSET ??_C@_0BI@CCICLKEE@PlotCultureCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+516], eax

; 423  : 	m_iPlotCultureExponentModifier = kResults.GetInt("PlotCultureExponentModifier");

	push	OFFSET ??_C@_0BM@FKOPEKNC@PlotCultureExponentModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+520], eax

; 424  : 	m_iNumCitiesPolicyCostDiscount = kResults.GetInt("NumCitiesPolicyCostDiscount");

	push	OFFSET ??_C@_0BM@COIEECHE@NumCitiesPolicyCostDiscount?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+524], eax

; 425  : 	m_iNumCitiesResearchCostDiscount = kResults.GetInt("NumCitiesResearchCostDiscount"); // NQMP GJS - new Dictatorship of the Proletariat i.e. Communism

	push	OFFSET ??_C@_0BO@MEMOKKJL@NumCitiesResearchCostDiscount?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+528], eax

; 426  : 	m_iGarrisonedCityRangeStrikeModifier = kResults.GetInt("GarrisonedCityRangeStrikeModifier");

	push	OFFSET ??_C@_0CC@ELHNOAEL@GarrisonedCityRangeStrikeModifie@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+532], eax

; 427  : 	m_iUnitPurchaseCostModifier = kResults.GetInt("UnitPurchaseCostModifier");

	push	OFFSET ??_C@_0BJ@MKCDENAA@UnitPurchaseCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+536], eax

; 428  : 	m_iBuildingPurchaseCostModifier = kResults.GetInt("BuildingPurchaseCostModifier");

	push	OFFSET ??_C@_0BN@MDJBNLIP@BuildingPurchaseCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+540], eax

; 429  : 	m_iCityConnectionTradeRouteGoldModifier = kResults.GetInt("CityConnectionTradeRouteGoldModifier");

	push	OFFSET ??_C@_0CF@CKGIHFME@CityConnectionTradeRouteGoldModi@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+544], eax

; 430  : 	m_iTradeMissionGoldModifier = kResults.GetInt("TradeMissionGoldModifier");

	push	OFFSET ??_C@_0BJ@OGAAKMBL@TradeMissionGoldModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+548], eax

; 431  : 	m_iFaithCostModifier = kResults.GetInt("FaithCostModifier");

	push	OFFSET ??_C@_0BC@LIHGJKGH@FaithCostModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+552], eax

; 432  : 	m_iCulturalPlunderMultiplier = kResults.GetInt("CulturalPlunderMultiplier");

	push	OFFSET ??_C@_0BK@FGEFNEAF@CulturalPlunderMultiplier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+556], eax

; 433  : 	m_iStealTechSlowerModifier = kResults.GetInt("StealTechSlowerModifier");

	push	OFFSET ??_C@_0BI@GKMOPGMA@StealTechSlowerModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+560], eax

; 434  : 	m_iStealTechFasterModifier = kResults.GetInt("StealTechFasterModifier");

	push	OFFSET ??_C@_0BI@PDPCGKIO@StealTechFasterModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+564], eax

; 435  : 	m_iCatchSpiesModifier = kResults.GetInt("CatchSpiesModifier");

	push	OFFSET ??_C@_0BD@FEHHPDEP@CatchSpiesModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+568], eax

; 436  : 	m_iGoldPerUnit = kResults.GetInt("GoldPerUnit");

	push	OFFSET ??_C@_0M@CELEIBNP@GoldPerUnit?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+572], eax

; 437  : 	m_iGoldPerMilitaryUnit = kResults.GetInt("GoldPerMilitaryUnit");

	push	OFFSET ??_C@_0BE@LMFGEEFC@GoldPerMilitaryUnit?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+576], eax

; 438  : 	m_iCityStrengthMod = kResults.GetInt("CityStrengthMod");

	push	OFFSET ??_C@_0BA@JGKPMHDI@CityStrengthMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+580], eax

; 439  : 	m_iCityGrowthMod = kResults.GetInt("CityGrowthMod");

	push	OFFSET ??_C@_0O@KIHLCIGE@CityGrowthMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+584], eax

; 440  : 	m_iCapitalGrowthMod = kResults.GetInt("CapitalGrowthMod");

	push	OFFSET ??_C@_0BB@IIOEMOFG@CapitalGrowthMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+588], eax

; 441  : 	m_iSettlerProductionModifier = kResults.GetInt("SettlerProductionModifier");

	push	OFFSET ??_C@_0BK@KEMFJDHB@SettlerProductionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+592], eax

; 442  : 	m_iCapitalSettlerProductionModifier = kResults.GetInt("CapitalSettlerProductionModifier");

	push	OFFSET ??_C@_0CB@MIGPIJHP@CapitalSettlerProductionModifier@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+596], eax

; 443  : 	m_iNewCityExtraPopulation = kResults.GetInt("NewCityExtraPopulation");

	push	OFFSET ??_C@_0BH@PDNAFCEG@NewCityExtraPopulation?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+600], eax

; 444  : 	m_iFreeFoodBox = kResults.GetInt("FreeFoodBox");

	push	OFFSET ??_C@_0M@EOGMLPFM@FreeFoodBox?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+604], eax

; 445  : 	m_iRouteGoldMaintenanceMod = kResults.GetInt("RouteGoldMaintenanceMod");

	push	OFFSET ??_C@_0BI@JPCPBJHC@RouteGoldMaintenanceMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+608], eax

; 446  : 	m_iBuildingGoldMaintenanceMod = kResults.GetInt("BuildingGoldMaintenanceMod");

	push	OFFSET ??_C@_0BL@GOKAHANB@BuildingGoldMaintenanceMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+612], eax

; 447  : 	m_iUnitGoldMaintenanceMod = kResults.GetInt("UnitGoldMaintenanceMod");

	push	OFFSET ??_C@_0BH@GPCCGJFH@UnitGoldMaintenanceMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+616], eax

; 448  : 	m_iUnitSupplyMod = kResults.GetInt("UnitSupplyMod");

	push	OFFSET ??_C@_0O@IKEGJHGF@UnitSupplyMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+620], eax

; 449  : 	m_iHappyPerMilitaryUnit = kResults.GetInt("HappyPerMilitaryUnit");

	push	OFFSET ??_C@_0BF@NKCDCBLE@HappyPerMilitaryUnit?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+624], eax

; 450  : 	m_iHappinessToCulture = kResults.GetInt("HappinessToCulture");

	push	OFFSET ??_C@_0BD@MMMKOKOB@HappinessToCulture?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+840], eax

; 451  : 	m_iHappinessToScience = kResults.GetInt("HappinessToScience");

	push	OFFSET ??_C@_0BD@CDMOEEGG@HappinessToScience?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+844], eax

; 452  : #ifdef NQ_GOLD_TO_SCIENCE_FROM_POLICIES
; 453  : 	m_iGoldToScience = kResults.GetInt("GoldToScience");

	push	OFFSET ??_C@_0O@ELPPBGEP@GoldToScience?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+848], eax

; 454  : #endif
; 455  : 	m_iNumCitiesFreeAestheticsSchools = kResults.GetInt("NumCitiesFreeAestheticsSchools"); // NQMP GJS - add support for NumCitiesFreeAestheticsSchools

	push	OFFSET ??_C@_0BP@ELCFNBD@NumCitiesFreeAestheticsSchools?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+852], eax

; 456  : 	m_iNumCitiesFreePietyGardens = kResults.GetInt("NumCitiesFreePietyGardens");

	push	OFFSET ??_C@_0BK@JOIILMDO@NumCitiesFreePietyGardens?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+856], eax

; 457  : 	m_iNumCitiesFreeWalls = kResults.GetInt("NumCitiesFreeWalls"); // NQMP GJS - New Oligarchy add support for NumCitiesFreeWalls

	push	OFFSET ??_C@_0BD@KDKHHJEK@NumCitiesFreeWalls?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+860], eax

; 458  : 	m_iNumCitiesFreeCultureBuilding = kResults.GetInt("NumCitiesFreeCultureBuilding");

	push	OFFSET ??_C@_0BN@FIEHLJMJ@NumCitiesFreeCultureBuilding?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+864], eax

; 459  : 	m_iNumCitiesFreeFoodBuilding = kResults.GetInt("NumCitiesFreeFoodBuilding");

	push	OFFSET ??_C@_0BK@KFJBPGNL@NumCitiesFreeFoodBuilding?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+868], eax

; 460  : 	m_bHalfSpecialistUnhappiness = kResults.GetBool("HalfSpecialistUnhappiness");

	push	OFFSET ??_C@_0BK@MNPNKBOH@HalfSpecialistUnhappiness?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+872], al

; 461  : 	m_bHalfMoreSpecialistUnhappiness = kResults.GetBool("HalfMoreSpecialistUnhappiness");

	push	OFFSET ??_C@_0BO@JCLIINCC@HalfMoreSpecialistUnhappiness?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+873], al

; 462  : 	m_bHalfSpecialistFood = kResults.GetBool("HalfSpecialistFood");

	push	OFFSET ??_C@_0BD@HOBGLLL@HalfSpecialistFood?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+874], al

; 463  : 	m_bMilitaryFoodProduction = kResults.GetBool("MilitaryFoodProduction");

	push	OFFSET ??_C@_0BH@PINGGCAG@MilitaryFoodProduction?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+875], al

; 464  : 	m_iMaxConscript = kResults.GetInt("MaxConscript");

	push	OFFSET ??_C@_0N@EHHEPDOA@MaxConscript?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+816], eax

; 465  : 	m_iWoundedUnitDamageMod = kResults.GetInt("WoundedUnitDamageMod");

	push	OFFSET ??_C@_0BF@HBALDEPJ@WoundedUnitDamageMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+828], eax

; 466  : 	m_iUnitUpgradeCostMod = kResults.GetInt("UnitUpgradeCostMod");

	push	OFFSET ??_C@_0BD@GBJLPLCI@UnitUpgradeCostMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+832], eax

; 467  : 	m_iBarbarianCombatBonus = kResults.GetInt("BarbarianCombatBonus");

	push	OFFSET ??_C@_0BF@HFMOGHPJ@BarbarianCombatBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+836], eax

; 468  : 	m_bAlwaysSeeBarbCamps = kResults.GetBool("AlwaysSeeBarbCamps");

	push	OFFSET ??_C@_0BD@MDAIKGML@AlwaysSeeBarbCamps?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+876], al

; 469  : 	m_bRevealAllCapitals = kResults.GetBool("RevealAllCapitals");

	push	OFFSET ??_C@_0BC@DOIJCEHM@RevealAllCapitals?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+877], al

; 470  : 	m_bGarrisonFreeMaintenance = kResults.GetBool("GarrisonFreeMaintenance");

	push	OFFSET ??_C@_0BI@FBAEOHNO@GarrisonFreeMaintenance?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+878], al

; 471  : 	m_iFreeSpecialist = kResults.GetInt("FreeSpecialist");

	push	OFFSET ??_C@_0P@ONAKJGND@FreeSpecialist?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+812], eax

; 472  : 	m_iExpModifier = kResults.GetInt("ExpModifier");

	push	OFFSET ??_C@_0M@OLBPIHKG@ExpModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+628], eax

; 473  : 	m_iExpInBorderModifier = kResults.GetInt("ExpInBorderModifier");

	push	OFFSET ??_C@_0BE@JMMGOOCJ@ExpInBorderModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+632], eax

; 474  : 	m_iMinorQuestFriendshipMod = kResults.GetInt("MinorQuestFriendshipMod");

	push	OFFSET ??_C@_0BI@HIEEGHEA@MinorQuestFriendshipMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+636], eax

; 475  : 	m_iMinorGoldFriendshipMod = kResults.GetInt("MinorGoldFriendshipMod");

	push	OFFSET ??_C@_0BH@PGJKGPKO@MinorGoldFriendshipMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+640], eax

; 476  : 	m_iMinorFriendshipMinimum = kResults.GetInt("MinorFriendshipMinimum");

	push	OFFSET ??_C@_0BH@CNJFAHMI@MinorFriendshipMinimum?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+644], eax

; 477  : 	m_iMinorFriendshipDecayMod = kResults.GetInt("MinorFriendshipDecayMod");

	push	OFFSET ??_C@_0BI@EBPAAEPN@MinorFriendshipDecayMod?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+648], eax

; 478  : 	m_iOtherPlayersMinorFriendshipDecayMod = kResults.GetInt("OtherPlayersMinorFriendshipDecayMod");

	push	OFFSET ??_C@_0CE@OKMBJAKL@OtherPlayersMinorFriendshipDecay@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+652], eax

; 479  : 	m_iCityStateUnitFrequencyModifier = kResults.GetInt("CityStateUnitFrequencyModifier");

	push	OFFSET ??_C@_0BP@BOJEJAGP@CityStateUnitFrequencyModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 480  : 	m_iCommonFoeTourismModifier = kResults.GetInt("CommonFoeTourismModifier");

	push	OFFSET ??_C@_0BJ@ONGDHBAE@CommonFoeTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+660], eax

; 481  : 	m_iLessHappyTourismModifier = kResults.GetInt("LessHappyTourismModifier");

	push	OFFSET ??_C@_0BJ@PKHFPDIL@LessHappyTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+664], eax

; 482  : 	m_iSharedIdeologyTourismModifier = kResults.GetInt("SharedIdeologyTourismModifier");

	push	OFFSET ??_C@_0BO@NCHBIENE@SharedIdeologyTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+668], eax

; 483  : 	m_iLandTradeRouteGoldChange = kResults.GetInt("LandTradeRouteGoldChange");

	push	OFFSET ??_C@_0BJ@NPLFFGBN@LandTradeRouteGoldChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+672], eax

; 484  : 	m_iSeaTradeRouteGoldChange = kResults.GetInt("SeaTradeRouteGoldChange");

	push	OFFSET ??_C@_0BI@JMHDBAJE@SeaTradeRouteGoldChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+676], eax

; 485  : 	m_iInternalTradeRouteGoldChange = kResults.GetInt("InternalTradeRouteGoldChange"); // NQMP GJS - Silk Road

	push	OFFSET ??_C@_0BN@PBNBAHDF@InternalTradeRouteGoldChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+680], eax

; 486  : 	m_iSharedIdeologyTradeGoldChange = kResults.GetInt("SharedIdeologyTradeGoldChange");

	push	OFFSET ??_C@_0BO@LIPLOMJF@SharedIdeologyTradeGoldChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+684], eax

; 487  : 
; 488  : 	m_iRiggingElectionModifier = kResults.GetInt("RiggingElectionModifier");

	push	OFFSET ??_C@_0BI@EDFKCKKD@RiggingElectionModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+688], eax

; 489  : 	m_iMilitaryUnitGiftExtraInfluence = kResults.GetInt("MilitaryUnitGiftExtraInfluence");

	push	OFFSET ??_C@_0BP@DHAEOHLB@MilitaryUnitGiftExtraInfluence?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+692], eax

; 490  : 	m_iProtectedMinorPerTurnInfluence = kResults.GetInt("ProtectedMinorPerTurnInfluence");

	push	OFFSET ??_C@_0BP@ODMELIBJ@ProtectedMinorPerTurnInfluence?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+696], eax

; 491  : 	m_iAfraidMinorPerTurnInfluence = kResults.GetInt("AfraidMinorPerTurnInfluence");

	push	OFFSET ??_C@_0BM@IPHHLIAB@AfraidMinorPerTurnInfluence?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+700], eax

; 492  : 	m_iMinorBullyScoreModifier = kResults.GetInt("MinorBullyScoreModifier");

	push	OFFSET ??_C@_0BI@DFKMMHDF@MinorBullyScoreModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+704], eax

; 493  : 	m_iThemingBonusMultiplier = kResults.GetInt("ThemingBonusMultiplier");

	push	OFFSET ??_C@_0BH@NCANENCP@ThemingBonusMultiplier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+708], eax

; 494  : 	m_iInternalTradeRouteYieldModifier = kResults.GetInt("InternalTradeRouteYieldModifier");

	push	OFFSET ??_C@_0CA@KBPBNEF@InternalTradeRouteYieldModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+712], eax

; 495  : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 496  : 	m_iInternalTradeRouteFoodYieldChange = kResults.GetInt("InternalTradeRouteFoodYieldChange");
; 497  : #endif
; 498  : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 499  : 	m_iInternalTradeRouteProductionYieldChange = kResults.GetInt("InternalTradeRouteProductionYieldChange");

	push	OFFSET ??_C@_0CI@PIJMLMPB@InternalTradeRouteProductionYiel@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+716], eax

; 500  : #endif
; 501  : #ifdef NQ_RAIL_CONNECTION_PRODUCTION_MODIFIER_FROM_POLICIES
; 502  : 	m_iRailConnectionProductionModifier = kResults.GetInt("RailConnectionProductionModifier");

	push	OFFSET ??_C@_0CB@EAENMJPL@RailConnectionProductionModifier@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+720], eax

; 503  : #endif
; 504  : #ifdef NQ_COMBAT_BONUS_VS_SMALLER_CIV_FROM_POLICIES
; 505  : 	m_iCombatBonusVsSmallerCiv = kResults.GetInt("CombatBonusVsSmallerCiv");

	push	OFFSET ??_C@_0BI@NMJFENFF@CombatBonusVsSmallerCiv?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+724], eax

; 506  : #endif
; 507  : #ifdef NQ_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER_FROM_POLICIES
; 508  : 	m_iProductionToGreatMusiciansModifier = kResults.GetInt("ProductionToGreatMusiciansModifier");

	push	OFFSET ??_C@_0CD@PLONLNAF@ProductionToGreatMusiciansModifi@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+728], eax

; 509  : #endif
; 510  : #ifdef NQ_TRADE_MISSION_INFLUENCE_MODIFIER_FROM_POLICIES
; 511  : 	m_iTradeMissionInfluenceModifier = kResults.GetInt("TradeMissionInfluenceModifier");

	push	OFFSET ??_C@_0BO@JKAGNMLN@TradeMissionInfluenceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+732], eax

; 512  : #endif
; 513  : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 514  : 	m_iSciencePerGreatPersonBorn = kResults.GetInt("SciencePerGreatPersonBorn");

	push	OFFSET ??_C@_0BK@NKEMBBH@SciencePerGreatPersonBorn?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+736], eax

; 515  : #endif
; 516  : #ifdef NQ_INFLUENCE_BOOST_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 517  : 	m_iInfluenceBoostPerGreatPersonBorn = kResults.GetInt("InfluenceBoostPerGreatPersonBorn");

	push	OFFSET ??_C@_0CB@IIFBEMOI@InfluenceBoostPerGreatPersonBorn@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+740], eax

; 518  : #endif
; 519  : #ifdef NQ_TOURISM_FROM_TRADE_MISSIONS_FROM_POLICIES
; 520  : 	m_iTourismFromTradeMissions = kResults.GetInt("TourismFromTradeMissions");

	push	OFFSET ??_C@_0BJ@EMLAAIA@TourismFromTradeMissions?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+744], eax

; 521  : #endif
; 522  : #ifdef NQ_HAPPINESS_FROM_GREAT_IMPROVEMENTS_FROM_POLICIES
; 523  : 	m_iHappinessFromGreatImprovements = kResults.GetInt("HappinessFromGreatImprovements");

	push	OFFSET ??_C@_0BP@GOECOIG@HappinessFromGreatImprovements?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+748], eax

; 524  : #endif
; 525  : #ifdef NQ_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS_FROM_POLICIES
; 526  : 	m_iMinorFriendshipGainBullyGoldSuccess = kResults.GetInt("MinorFriendshipGainBullyGoldSuccess");

	push	OFFSET ??_C@_0CE@DKCEDOAL@MinorFriendshipGainBullyGoldSucc@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+752], eax

; 527  : #endif
; 528  : #ifdef NQ_COUP_CHANCE_MODIFIER_FROM_POLICIES
; 529  : 	m_iCoupChanceModifier = kResults.GetInt("CoupChanceModifier");

	push	OFFSET ??_C@_0BD@GIMAOKOM@CoupChanceModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+756], eax

; 530  : #endif
; 531  : 	m_iSharedReligionTourismModifier = kResults.GetInt("SharedReligionTourismModifier");

	push	OFFSET ??_C@_0BO@GLBABIPM@SharedReligionTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+760], eax

; 532  : 	m_iTradeRouteTourismModifier = kResults.GetInt("TradeRouteTourismModifier");

	push	OFFSET ??_C@_0BK@LGCJBFHM@TradeRouteTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+764], eax

; 533  : 	m_iOpenBordersTourismModifier = kResults.GetInt("OpenBordersTourismModifier");

	push	OFFSET ??_C@_0BL@BBIFLCLM@OpenBordersTourismModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+768], eax

; 534  : 	m_iCityStateTradeChange = kResults.GetInt("CityStateTradeChange");

	push	OFFSET ??_C@_0BF@MKBOLOFE@CityStateTradeChange?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+772], eax

; 535  : 	m_bMinorGreatPeopleAllies = kResults.GetBool("MinorGreatPeopleAllies");

	push	OFFSET ??_C@_0BH@NDGBALIP@MinorGreatPeopleAllies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+776], al

; 536  : 	m_bMinorScienceAllies = kResults.GetBool("MinorScienceAllies");

	push	OFFSET ??_C@_0BD@OIOEBHLN@MinorScienceAllies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+777], al

; 537  : 	m_bMinorResourceBonus = kResults.GetBool("MinorResourceBonus");

	push	OFFSET ??_C@_0BD@LDBBMJHF@MinorResourceBonus?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+778], al

; 538  : 	m_iMinorMilitaryNumExtraUnitsToGift = kResults.GetInt("MinorMilitaryNumExtraUnitsToGift"); // NQMP GJS - Patronage Finisher

	push	OFFSET ??_C@_0CB@INOPFAOD@MinorMilitaryNumExtraUnitsToGift@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+780], eax

; 539  : 	m_iCityStateBonusModifier = kResults.GetInt("CityStateBonusModifier"); // NQMP GJS - Patronage Finisher

	push	OFFSET ??_C@_0BH@BJAEBEN@CityStateBonusModifier?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+784], eax

; 540  : 	m_iExtraTerritoryClaim = kResults.GetInt("ExtraTerritoryClaim"); // NQMP GJS - Colonialism

	push	OFFSET ??_C@_0BE@GFLBEIAH@ExtraTerritoryClaim?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+788], eax

; 541  : 	m_iExtraTourismPerGreatWork = kResults.GetInt("ExtraTourismPerGreatWork"); // NQMP GJS - Cultural Exchange

	push	OFFSET ??_C@_0BJ@PPFAPLBM@ExtraTourismPerGreatWork?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+792], eax

; 542  : 	m_iTourismPerWonder = kResults.GetInt("TourismPerWonder"); // NQMP GJS - Flourishing of the Arts

	push	OFFSET ??_C@_0BB@FIJKHBME@TourismPerWonder?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+796], eax

; 543  : #ifdef NQ_TOURISM_PER_CITY
; 544  : 	m_iTourismPerCity = kResults.GetInt("TourismPerCity");

	push	OFFSET ??_C@_0P@DMNLMCNC@TourismPerCity?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+800], eax

; 545  : #endif
; 546  : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 547  : 	m_iIdeologyPressureUnhappinessModifier = kResults.GetInt("IdeologyPressureUnhappinessModifier");

	push	OFFSET ??_C@_0CE@FEKIMMKI@IdeologyPressureUnhappinessModif@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+804], eax

; 548  : #endif
; 549  : 
; 550  : 	m_iProductionFromGarrison = kResults.GetInt("ProductionFromGarrison"); // NQMP GJS - Military Caste

	push	OFFSET ??_C@_0BH@BHOFEKLH@ProductionFromGarrison?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+808], eax

; 551  : 	m_bGoldenAgeCultureBonusDisabled = kResults.GetBool("GoldenAgeCultureBonusDisabled");

	push	OFFSET ??_C@_0BO@FKDEDCGL@GoldenAgeCultureBonusDisabled?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+879], al

; 552  : 	m_bSecondReligionPantheon = kResults.GetBool("SecondReligionPantheon");

	push	OFFSET ??_C@_0BH@KEAINGJC@SecondReligionPantheon?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+880], al

; 553  : 	m_bAddReformationBelief = kResults.GetBool("AddReformationBelief");

	push	OFFSET ??_C@_0BF@GEHLOEOL@AddReformationBelief?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+881], al

; 554  : 	m_bEnablesSSPartHurry = kResults.GetBool("EnablesSSPartHurry");

	push	OFFSET ??_C@_0BD@PONKBHPA@EnablesSSPartHurry?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+882], al

; 555  : #ifdef NQ_DIABLE_RESISTANCE_TIME_VIA_POLICIES
; 556  : 	m_bDisablesResistanceTime = kResults.GetBool("DisablesResistanceTime");

	push	OFFSET ??_C@_0BH@FDMMCIJH@DisablesResistanceTime?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+883], al

; 557  : #endif
; 558  : #ifdef NQ_PATRIOTIC_WAR
; 559  : 	m_bDoubleTrainedMilitaryLandUnit = kResults.GetBool("IsDoubleTrainedMilitaryLandUnits");

	push	OFFSET ??_C@_0CB@GIDMBFM@IsDoubleTrainedMilitaryLandUnits@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+884], al

; 560  : #endif
; 561  : #ifdef NQ_WAR_HERO
; 562  : 	m_bWarHero = kResults.GetBool("IsWarHero");

	push	OFFSET ??_C@_09FCFHIKFI@IsWarHero?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+885], al

; 563  : #endif
; 564  : #ifdef NQ_IGNORE_PUPPETS_FOR_RESEARCH_COSTS_FROM_POLICIES
; 565  : 	m_bIgnorePuppetsForResearchCosts = kResults.GetBool("IgnorePuppetsForResearchCosts");
; 566  : #endif
; 567  : #ifdef NQ_POLICY_TOGGLE_NO_MINOR_DOW_IF_FRIENDS
; 568  : 	m_bNoMinorDOWIfFriends = kResults.GetBool("NoMinorDOWIfFriends");

	push	OFFSET ??_C@_0BE@PCLBMPHC@NoMinorDOWIfFriends?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+886], al

; 569  : #endif
; 570  : #ifdef NQ_ALLOW_PUPPET_PURCHASING_FROM_POLICIES
; 571  : 	m_bAllowPuppetPurchasing = kResults.GetBool("AllowPuppetPurchasing");

	push	OFFSET ??_C@_0BG@BGMJCDCP@AllowPuppetPurchasing?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+887], al

; 572  : #endif
; 573  : 
; 574  : 	m_bEnablesSSPartPurchase = kResults.GetBool("EnablesSSPartPurchase");

	push	OFFSET ??_C@_0BG@JJPEJKJK@EnablesSSPartPurchase?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+888], al

; 575  : 	m_bAbleToAnnexCityStates = kResults.GetBool("AbleToAnnexCityStates");

	push	OFFSET ??_C@_0BG@CDIIOFIJ@AbleToAnnexCityStates?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+889], al

; 576  : 	m_bOneShot = kResults.GetBool("OneShot");

	push	OFFSET ??_C@_07GACJADJO@OneShot?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+890], al

; 577  : 	m_bIncludesOneShotFreeUnits = kResults.GetBool("IncludesOneShotFreeUnits");

	push	OFFSET ??_C@_0BJ@HFFJCDOB@IncludesOneShotFreeUnits?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+891], al

; 578  : 
; 579  : 	m_strWeLoveTheKingKey = kResults.GetText("WeLoveTheKing");

	push	OFFSET ??_C@_0O@FEEMIMFP@WeLoveTheKing?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR $T231433[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 892				; 0000037cH
	mov	DWORD PTR $T231432[ebp], eax
	cmp	DWORD PTR $T231433[ebp], 0
	je	SHORT $LN36@CacheResul
	mov	ecx, DWORD PTR $T231433[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231432[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN37@CacheResul
$LN36@CacheResul:
	mov	ecx, DWORD PTR $T231432[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN37@CacheResul:

; 580  : 	m_wstrWeLoveTheKing = GetLocalizedText(m_strWeLoveTheKingKey);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 892				; 0000037cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T231437[ebp], eax
	mov	edx, DWORD PTR $T231437[ebp]
	push	edx
	lea	eax, DWORD PTR $T231413[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv1765[ebp], eax
	mov	ecx, DWORD PTR tv1765[ebp]
	mov	DWORD PTR $T231442[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 920				; 00000398H
	mov	DWORD PTR $T231441[ebp], edx
	mov	eax, DWORD PTR $T231442[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231441[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T231413[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 581  : 
; 582  : 	//References
; 583  : 	const char* szTechPrereq = kResults.GetText("TechPrereq");

	push	OFFSET ??_C@_0L@IANCLNMF@TechPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTechPrereq$[ebp], eax

; 584  : 	m_iTechPrereq = GC.getInfoTypeForString(szTechPrereq, true);

	push	1
	mov	ecx, DWORD PTR _szTechPrereq$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+260], eax

; 585  : 
; 586  : 	const char* szPolicyBranchType = kResults.GetText("PolicyBranchType");

	push	OFFSET ??_C@_0BB@NPPBPBOI@PolicyBranchType?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szPolicyBranchType$[ebp], eax

; 587  : 	m_iPolicyBranchType = GC.getInfoTypeForString(szPolicyBranchType, true);

	push	1
	mov	eax, DWORD PTR _szPolicyBranchType$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+820], eax

; 588  : 
; 589  : 	m_iNumExtraBranches = kResults.GetInt("NumExtraBranches");

	push	OFFSET ??_C@_0BB@MAJHKHNK@NumExtraBranches?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+824], eax

; 590  : 
; 591  : 	const char* szFreeBuilding = kResults.GetText("FreeBuildingOnConquest");

	push	OFFSET ??_C@_0BH@MPDGGDMG@FreeBuildingOnConquest?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szFreeBuilding$[ebp], eax

; 592  : 	if(szFreeBuilding)

	cmp	DWORD PTR _szFreeBuilding$[ebp], 0
	je	SHORT $LN46@CacheResul

; 593  : 	{
; 594  : 		m_eFreeBuildingOnConquest = (BuildingTypes)GC.getInfoTypeForString(szFreeBuilding, true);

	push	1
	mov	eax, DWORD PTR _szFreeBuilding$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+948], eax

; 595  : 	}
; 596  : 
; 597  : 	//Arrays
; 598  : 	const char* szPolicyType = GetType();

$LN46@CacheResul:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szPolicyType$[ebp], eax

; 599  : 	kUtility.SetYields(m_piYieldModifier, "Policy_YieldModifiers", "PolicyType", szPolicyType);

	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BG@KPLKNJFC@Policy_YieldModifiers?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 976				; 000003d0H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 600  : 	kUtility.SetYields(m_piCityYieldChange, "Policy_CityYieldChanges", "PolicyType", szPolicyType);

	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BI@KKDHIEEK@Policy_CityYieldChanges?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 980				; 000003d4H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 601  : 	kUtility.SetYields(m_piCoastalCityYieldChange, "Policy_CoastalCityYieldChanges", "PolicyType", szPolicyType);

	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BP@NJFEBBPC@Policy_CoastalCityYieldChanges?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 984				; 000003d8H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 602  : 	kUtility.SetYields(m_piCapitalYieldChange, "Policy_CapitalYieldChanges", "PolicyType", szPolicyType);

	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BL@CCCEKMJN@Policy_CapitalYieldChanges?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 988				; 000003dcH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 603  : 	kUtility.SetYields(m_piCapitalYieldPerPopChange, "Policy_CapitalYieldPerPopChanges", "PolicyType", szPolicyType);

	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0CB@JNJCBEJA@Policy_CapitalYieldPerPopChanges@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 992				; 000003e0H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 604  : 	kUtility.SetYields(m_piCapitalYieldModifier, "Policy_CapitalYieldModifiers", "PolicyType", szPolicyType);

	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BN@MENJPEMM@Policy_CapitalYieldModifiers?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 996				; 000003e4H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 605  : 	kUtility.SetYields(m_piGreatWorkYieldChange, "Policy_GreatWorkYieldChanges", "PolicyType", szPolicyType);

	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BN@MFJLJONG@Policy_GreatWorkYieldChanges?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1000				; 000003e8H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 606  : 	kUtility.SetYields(m_piSpecialistExtraYield, "Policy_SpecialistExtraYields", "PolicyType", szPolicyType);

	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BN@JKGJDLCA@Policy_SpecialistExtraYields?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1004				; 000003ecH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetYields@CvDatabaseUtility@@QAE_NAAPAHPBD11@Z ; CvDatabaseUtility::SetYields

; 607  : 
; 608  : 	kUtility.SetFlavors(m_piFlavorValue, "Policy_Flavors", "PolicyType", szPolicyType);

	push	0
	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0P@BFDDJDDA@Policy_Flavors?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1068				; 0000042cH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 609  : 
; 610  : 	kUtility.PopulateArrayByValue(m_paiHurryModifier, "HurryInfos", "Policy_HurryModifiers", "HurryType", "PolicyType", szPolicyType, "HurryCostModifier");

	push	0
	push	0
	push	OFFSET ??_C@_0BC@KALJCKJH@HurryCostModifier?$AA@
	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_09FFMCMAO@HurryType?$AA@
	push	OFFSET ??_C@_0BG@FHFLCHBI@Policy_HurryModifiers?$AA@
	push	OFFSET ??_C@_0L@PGMCIMFM@HurryInfos?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1024				; 00000400H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 611  : 
; 612  : 	kUtility.PopulateArrayByExistence(m_pabSpecialistValid, "Specialists", "Policy_ValidSpecialists", "SpecialistType", "PolicyType", szPolicyType);

	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0P@KLBEOMLO@SpecialistType?$AA@
	push	OFFSET ??_C@_0BI@BPBDIBOC@Policy_ValidSpecialists?$AA@
	push	OFFSET ??_C@_0M@EENMFCNN@Specialists?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1052				; 0000041cH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 613  : 
; 614  : 	kUtility.PopulateArrayByExistence(m_pabFreePromotion, "UnitPromotions", "Policy_FreePromotions", "PromotionType", "PolicyType", szPolicyType);

	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0O@IILJPJBB@PromotionType?$AA@
	push	OFFSET ??_C@_0BG@ECDIGOEK@Policy_FreePromotions?$AA@
	push	OFFSET ??_C@_0P@GCBJCIAG@UnitPromotions?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1012				; 000003f4H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 615  : 	kUtility.PopulateArrayByValue(m_paiUnitCombatFreeExperiences, "UnitCombatInfos", "Policy_UnitCombatFreeExperiences", "UnitCombatType", "PolicyType", szPolicyType, "FreeExperience");

	push	0
	push	0
	push	OFFSET ??_C@_0P@MOBEEGOH@FreeExperience?$AA@
	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0P@GFHIODK@UnitCombatType?$AA@
	push	OFFSET ??_C@_0CB@ILPCOPJK@Policy_UnitCombatFreeExperiences@
	push	OFFSET ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1020				; 000003fcH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 616  : 	kUtility.PopulateArrayByValue(m_paiUnitCombatProductionModifiers, "UnitCombatInfos", "Policy_UnitCombatProductionModifiers", "UnitCombatType", "PolicyType", szPolicyType, "ProductionModifier");

	push	0
	push	0
	push	OFFSET ??_C@_0BD@JMJICLDJ@ProductionModifier?$AA@
	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0P@GFHIODK@UnitCombatType?$AA@
	push	OFFSET ??_C@_0CF@JAEDOHPB@Policy_UnitCombatProductionModif@
	push	OFFSET ??_C@_0BA@NHHFHDEL@UnitCombatInfos?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1016				; 000003f8H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 617  : 
; 618  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassCultureChanges, "BuildingClasses", "Policy_BuildingClassCultureChanges", "BuildingClassType", "PolicyType", szPolicyType, "CultureChange");

	push	0
	push	0
	push	OFFSET ??_C@_0O@DKCHOOHE@CultureChange?$AA@
	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0CD@OAPCCMEJ@Policy_BuildingClassCultureChang@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1028				; 00000404H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 619  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassProductionModifiers, "BuildingClasses", "Policy_BuildingClassProductionModifiers", "BuildingClassType", "PolicyType", szPolicyType, "ProductionModifier");

	push	0
	push	0
	push	OFFSET ??_C@_0BD@JMJICLDJ@ProductionModifier?$AA@
	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0CI@MCHMEPOE@Policy_BuildingClassProductionMo@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1032				; 00000408H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 620  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassTourismModifiers, "BuildingClasses", "Policy_BuildingClassTourismModifiers", "BuildingClassType", "PolicyType", szPolicyType, "TourismModifier");

	push	0
	push	0
	push	OFFSET ??_C@_0BA@COIBAHID@TourismModifier?$AA@
	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0CF@CMGLKFDI@Policy_BuildingClassTourismModif@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1036				; 0000040cH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 621  : 	kUtility.PopulateArrayByValue(m_paiBuildingClassHappiness, "BuildingClasses", "Policy_BuildingClassHappiness", "BuildingClassType", "PolicyType", szPolicyType, "Happiness");

	push	0
	push	0
	push	OFFSET ??_C@_09MNJMGIDC@Happiness?$AA@
	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BC@OELPCAJJ@BuildingClassType?$AA@
	push	OFFSET ??_C@_0BO@BNAMIIKH@Policy_BuildingClassHappiness?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1040				; 00000410H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 622  : 
; 623  : 	kUtility.PopulateArrayByValue(m_paiFreeUnitClasses, "UnitClasses", "Policy_FreeUnitClasses", "UnitClassType", "PolicyType", szPolicyType, "Count");

	push	0
	push	0
	push	OFFSET ??_C@_05IJGIMMHE@Count?$AA@
	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0O@JGILCIIO@UnitClassType?$AA@
	push	OFFSET ??_C@_0BH@KKBIBCHK@Policy_FreeUnitClasses?$AA@
	push	OFFSET ??_C@_0M@HLHJNCC@UnitClasses?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1044				; 00000414H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 624  : 	kUtility.PopulateArrayByValue(m_paiTourismOnUnitCreation, "UnitClasses", "Policy_TourismOnUnitCreation", "UnitClassType", "PolicyType", szPolicyType, "Tourism");

	push	0
	push	0
	push	OFFSET ??_C@_07COHILFBB@Tourism?$AA@
	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0O@JGILCIIO@UnitClassType?$AA@
	push	OFFSET ??_C@_0BN@HDOPCCMH@Policy_TourismOnUnitCreation?$AA@
	push	OFFSET ??_C@_0M@HLHJNCC@UnitClasses?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1048				; 00000418H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 625  : 
; 626  : 	//BuildingYieldModifiers
; 627  : 	{
; 628  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 629  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldModifiers.first, "BuildingClasses", "Yields");
; 630  : 		m_ppiBuildingClassYieldModifiers.second = kUtility.MaxRows("BuildingClasses");
; 631  : #else
; 632  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldModifiers, "BuildingClasses", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1060				; 00000424H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 633  : #endif
; 634  : 
; 635  : 		std::string strKey("Policy_BuildingClassYieldModifiers");

	push	OFFSET ??_C@_0CD@CIHGELLG@Policy_BuildingClassYieldModifie@
	lea	ecx, DWORD PTR _strKey$223336[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 636  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	ecx, DWORD PTR _strKey$223336[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$223338[ebp], eax

; 637  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$223338[ebp], 0
	jne	SHORT $LN21@CacheResul

; 638  : 		{
; 639  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldMod from Policy_BuildingClassYieldModifiers inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Yields on Yields.Type = YieldType where PolicyType = ?");

	push	OFFSET ??_C@_0PO@NAMOGGP@select?5BuildingClasses?4ID?5as?5Bui@
	lea	edx, DWORD PTR _strKey$223336[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$223338[ebp], eax
$LN21@CacheResul:

; 640  : 		}
; 641  : 
; 642  : 		pResults->Bind(1, szPolicyType);

	push	1
	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$223338[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN20@CacheResul:

; 643  : 
; 644  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$223338[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@CacheResul

; 645  : 		{
; 646  : 			const int BuildingClassID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$223338[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _BuildingClassID$223344[ebp], eax

; 647  : 			const int iYieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$223338[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYieldID$223345[ebp], eax

; 648  : 			const int iYieldMod = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$223338[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYieldMod$223346[ebp], eax

; 649  : 
; 650  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 651  : 			m_ppiBuildingClassYieldModifiers.first[BuildingClassID][iYieldID] = iYieldMod;
; 652  : #else
; 653  : 			m_ppiBuildingClassYieldModifiers[BuildingClassID][iYieldID] = iYieldMod;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1060]
	mov	ecx, DWORD PTR _BuildingClassID$223344[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _iYieldID$223345[ebp]
	mov	ecx, DWORD PTR _iYieldMod$223346[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 654  : #endif
; 655  : 		}

	jmp	SHORT $LN20@CacheResul
$LN19@CacheResul:

; 656  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$223336[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 657  : 
; 658  : 	//BuildingYieldChanges
; 659  : 	{
; 660  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 661  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges.first, "BuildingClasses", "Yields");
; 662  : 		m_ppiBuildingClassYieldChanges.second = kUtility.MaxRows("BuildingClasses");
; 663  : #else
; 664  : 		kUtility.Initialize2DArray(m_ppiBuildingClassYieldChanges, "BuildingClasses", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0BA@GLDILOEP@BuildingClasses?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1064				; 00000428H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 665  : #endif
; 666  : 
; 667  : 		std::string strKey("Policy_BuildingClassYieldChanges");

	push	OFFSET ??_C@_0CB@GDAPPICJ@Policy_BuildingClassYieldChanges@
	lea	ecx, DWORD PTR _strKey$223347[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 668  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	eax, DWORD PTR _strKey$223347[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$223349[ebp], eax

; 669  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$223349[ebp], 0
	jne	SHORT $LN18@CacheResul

; 670  : 		{
; 671  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Yields.ID as YieldID, YieldChange from Policy_BuildingClassYieldChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Yields on Yields.Type = YieldType where PolicyType = ?");

	push	OFFSET ??_C@_0PP@PBCKHIDL@select?5BuildingClasses?4ID?5as?5Bui@
	lea	ecx, DWORD PTR _strKey$223347[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$223349[ebp], eax
$LN18@CacheResul:

; 672  : 		}
; 673  : 
; 674  : 		pResults->Bind(1, szPolicyType);

	push	1
	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$223349[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN17@CacheResul:

; 675  : 
; 676  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$223349[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@CacheResul

; 677  : 		{
; 678  : 			const int BuildingClassID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$223349[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _BuildingClassID$223355[ebp], eax

; 679  : 			const int iYieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$223349[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYieldID$223356[ebp], eax

; 680  : 			const int iYieldChange = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$223349[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iYieldChange$223357[ebp], eax

; 681  : 
; 682  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 683  : 			m_ppiBuildingClassYieldChanges.first[BuildingClassID][iYieldID] = iYieldChange;
; 684  : #else
; 685  : 			m_ppiBuildingClassYieldChanges[BuildingClassID][iYieldID] = iYieldChange;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1064]
	mov	eax, DWORD PTR _BuildingClassID$223355[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _iYieldID$223356[ebp]
	mov	eax, DWORD PTR _iYieldChange$223357[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 686  : #endif
; 687  : 		}

	jmp	SHORT $LN17@CacheResul
$LN16@CacheResul:

; 688  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$223347[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 689  : 
; 690  : #ifdef AUI_POLICY_BUILDING_CLASS_FLAVOR_MODIFIERS
; 691  : 	//BuildingClassFlavorChanges
; 692  : 	{
; 693  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 694  : 		kUtility.Initialize2DArray(m_ppiBuildingClassFlavorChanges.first, "BuildingClasses", "Flavors");
; 695  : 		m_ppiBuildingClassFlavorChanges.second = kUtility.MaxRows("BuildingClasses");
; 696  : #else
; 697  : 		kUtility.Initialize2DArray(m_ppiBuildingClassFlavorChanges, "BuildingClasses", "Flavors");
; 698  : #endif
; 699  : 
; 700  : 		std::string strKey("Policy_BuildingClassFlavorChanges");
; 701  : 		Database::Results* pResults = kUtility.GetResults(strKey);
; 702  : 		if (pResults == NULL)
; 703  : 		{
; 704  : 			pResults = kUtility.PrepareResults(strKey, "select BuildingClasses.ID as BuildingClassID, Flavors.ID as FlavorID, FlavorChange from Policy_BuildingClassFlavorChanges inner join BuildingClasses on BuildingClasses.Type = BuildingClassType inner join Flavors on Flavors.Type = FlavorType where PolicyType = ?");
; 705  : 		}
; 706  : 
; 707  : 		pResults->Bind(1, szPolicyType);
; 708  : 
; 709  : 		while (pResults->Step())
; 710  : 		{
; 711  : 			const int BuildingClassID = pResults->GetInt(0);
; 712  : 			const int iFlavorID = pResults->GetInt(1);
; 713  : 			const int iFlavorChange = pResults->GetInt(2);
; 714  : 
; 715  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 716  : 			m_ppiBuildingClassFlavorChanges.first[BuildingClassID][iFlavorID] = iFlavorChange;
; 717  : #else
; 718  : 			m_ppiBuildingClassFlavorChanges[BuildingClassID][iFlavorID] = iFlavorChange;
; 719  : #endif
; 720  : 		}
; 721  : 	}
; 722  : #endif
; 723  : 
; 724  : 	//ImprovementYieldChanges
; 725  : 	{
; 726  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 727  : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges.first, "Improvements", "Yields");
; 728  : 		m_ppiImprovementYieldChanges.second = kUtility.MaxRows("Improvements");
; 729  : #else
; 730  : 		kUtility.Initialize2DArray(m_ppiImprovementYieldChanges, "Improvements", "Yields");

	push	0
	push	OFFSET ??_C@_06JAMLCLDI@Yields?$AA@
	push	OFFSET ??_C@_0N@CJDAHDJO@Improvements?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1056				; 00000420H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?Initialize2DArray@CvDatabaseUtility@@QAE_NAAPAPAHPBD1H@Z ; CvDatabaseUtility::Initialize2DArray

; 731  : #endif
; 732  : 
; 733  : 		std::string strKey("Policy_ImprovementYieldChanges");

	push	OFFSET ??_C@_0BP@DBAIIMOC@Policy_ImprovementYieldChanges?$AA@
	lea	ecx, DWORD PTR _strKey$223359[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 734  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	lea	edx, DWORD PTR _strKey$223359[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$223361[ebp], eax

; 735  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$223361[ebp], 0
	jne	SHORT $LN15@CacheResul

; 736  : 		{
; 737  : 			pResults = kUtility.PrepareResults(strKey, "select Improvements.ID as ImprovementID, Yields.ID as YieldID, Yield from Policy_ImprovementYieldChanges inner join Improvements on Improvements.Type = ImprovementType inner join Yields on Yields.Type = YieldType where PolicyType = ?");

	push	OFFSET ??_C@_0OK@OMDAFMLP@select?5Improvements?4ID?5as?5Improv@
	lea	eax, DWORD PTR _strKey$223359[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$223361[ebp], eax
$LN15@CacheResul:

; 738  : 		}
; 739  : 
; 740  : 		pResults->Bind(1, szPolicyType);

	push	1
	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$223361[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN14@CacheResul:

; 741  : 
; 742  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$223361[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN13@CacheResul

; 743  : 		{
; 744  : 			const int ImprovementID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$223361[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _ImprovementID$223367[ebp], eax

; 745  : 			const int YieldID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$223361[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _YieldID$223368[ebp], eax

; 746  : 			const int yield = pResults->GetInt(2);

	push	2
	mov	ecx, DWORD PTR _pResults$223361[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _yield$223369[ebp], eax

; 747  : 
; 748  : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 749  : 			m_ppiImprovementYieldChanges.first[ImprovementID][YieldID] = yield;
; 750  : #else
; 751  : 			m_ppiImprovementYieldChanges[ImprovementID][YieldID] = yield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1056]
	mov	edx, DWORD PTR _ImprovementID$223367[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _YieldID$223368[ebp]
	mov	edx, DWORD PTR _yield$223369[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 752  : #endif
; 753  : 		}

	jmp	SHORT $LN14@CacheResul
$LN13@CacheResul:

; 754  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strKey$223359[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 755  : 
; 756  : 	//ImprovementCultureChanges
; 757  : 	kUtility.PopulateArrayByValue(m_piImprovementCultureChange, "Improvements", "Policy_ImprovementCultureChanges", "ImprovementType", "PolicyType", szPolicyType, "CultureChange");

	push	0
	push	0
	push	OFFSET ??_C@_0O@DKCHOOHE@CultureChange?$AA@
	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	OFFSET ??_C@_0L@LIHFHODE@PolicyType?$AA@
	push	OFFSET ??_C@_0BA@PMOLGEPK@ImprovementType?$AA@
	push	OFFSET ??_C@_0CB@JPJEMFOO@Policy_ImprovementCultureChanges@
	push	OFFSET ??_C@_0N@CJDAHDJO@Improvements?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1008				; 000003f0H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 758  : 
; 759  : 	//OrPreReqs
; 760  : 	{
; 761  : 		kUtility.InitializeArray(m_piPrereqOrPolicies, "Policies", (int)NO_POLICY);

	push	OFFSET ??_C@_08NDDAPGNJ@Policies?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _count$231455[ebp], eax
	cmp	DWORD PTR _count$231455[ebp], 0
	jne	SHORT $LN48@CacheResul
	mov	DWORD PTR _count$231455[ebp], 1
$LN48@CacheResul:
	push	-1
	mov	edx, DWORD PTR _count$231455[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 964				; 000003c4H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 762  : 
; 763  : 		std::string sqlKey = "m_piPrereqOrPolicies";

	push	OFFSET ??_C@_0BF@CDEDBDG@m_piPrereqOrPolicies?$AA@
	lea	ecx, DWORD PTR _sqlKey$223379[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 764  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	ecx, DWORD PTR _sqlKey$223379[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$223381[ebp], eax

; 765  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$223381[ebp], 0
	jne	SHORT $LN12@CacheResul

; 766  : 		{
; 767  : 			const char* szSQL = "select Policies.ID from Policy_PrereqORPolicies inner join Policies on Policies.Type = PrereqPolicy where PolicyType = ?";

	mov	DWORD PTR _szSQL$223383[ebp], OFFSET ??_C@_0HJ@CCDHNOKM@select?5Policies?4ID?5from?5Policy_P@

; 768  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	edx, DWORD PTR _szSQL$223383[ebp]
	push	edx
	lea	eax, DWORD PTR _sqlKey$223379[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$223381[ebp], eax
$LN12@CacheResul:

; 769  : 		}
; 770  : 
; 771  : 		pResults->Bind(1, szPolicyType, false);

	push	0
	mov	ecx, DWORD PTR _szPolicyType$[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _pResults$223381[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 772  : 
; 773  : 		int i = 0;

	mov	DWORD PTR _i$223385[ebp], 0
$LN11@CacheResul:

; 774  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$223381[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@CacheResul

; 775  : 		{
; 776  : 			m_piPrereqOrPolicies[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$223381[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+964]
	mov	ecx, DWORD PTR _i$223385[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edx, DWORD PTR _i$223385[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223385[ebp], edx

; 777  : 		}

	jmp	SHORT $LN11@CacheResul
$LN10@CacheResul:

; 778  : 
; 779  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$223381[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 780  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$223379[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 781  : 
; 782  : 	//AndPreReqs
; 783  : 	{
; 784  : 		kUtility.InitializeArray(m_piPrereqAndPolicies, "Policies", (int)NO_POLICY);

	push	OFFSET ??_C@_08NDDAPGNJ@Policies?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _count$231462[ebp], eax
	cmp	DWORD PTR _count$231462[ebp], 0
	jne	SHORT $LN58@CacheResul
	mov	DWORD PTR _count$231462[ebp], 1
$LN58@CacheResul:
	push	-1
	mov	eax, DWORD PTR _count$231462[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 785  : 		std::string sqlKey = "m_piPrereqAndPolicies";

	push	OFFSET ??_C@_0BG@HDAGFADH@m_piPrereqAndPolicies?$AA@
	lea	ecx, DWORD PTR _sqlKey$223390[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 786  : 
; 787  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$223390[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$223392[ebp], eax

; 788  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$223392[ebp], 0
	jne	SHORT $LN9@CacheResul

; 789  : 		{
; 790  : 			const char* szSQL = "select Policies.ID from Policy_PrereqPolicies inner join Policies on Policies.Type = PrereqPolicy where PolicyType = ?";

	mov	DWORD PTR _szSQL$223394[ebp], OFFSET ??_C@_0HH@MGLLOFBN@select?5Policies?4ID?5from?5Policy_P@

; 791  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	eax, DWORD PTR _szSQL$223394[ebp]
	push	eax
	lea	ecx, DWORD PTR _sqlKey$223390[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$223392[ebp], eax
$LN9@CacheResul:

; 792  : 		}
; 793  : 
; 794  : 		pResults->Bind(1, szPolicyType, false);

	push	0
	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$223392[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 795  : 
; 796  : 		int i = 0;

	mov	DWORD PTR _i$223396[ebp], 0
$LN8@CacheResul:

; 797  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$223392[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@CacheResul

; 798  : 		{
; 799  : 			m_piPrereqAndPolicies[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$223392[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+968]
	mov	ecx, DWORD PTR _i$223396[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edx, DWORD PTR _i$223396[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223396[ebp], edx

; 800  : 		}

	jmp	SHORT $LN8@CacheResul
$LN7@CacheResul:

; 801  : 
; 802  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$223392[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 803  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$223390[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 804  : 
; 805  : 	//Policy_Disables
; 806  : 	{
; 807  : 		kUtility.InitializeArray(m_piPolicyDisables, "Policies", (int)NO_POLICY);

	push	OFFSET ??_C@_08NDDAPGNJ@Policies?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _count$231469[ebp], eax
	cmp	DWORD PTR _count$231469[ebp], 0
	jne	SHORT $LN68@CacheResul
	mov	DWORD PTR _count$231469[ebp], 1
$LN68@CacheResul:
	push	-1
	mov	eax, DWORD PTR _count$231469[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 972				; 000003ccH
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 808  : 
; 809  : 		std::string sqlKey = "m_piPolicyDisables";

	push	OFFSET ??_C@_0BD@KHHJPNKJ@m_piPolicyDisables?$AA@
	lea	ecx, DWORD PTR _sqlKey$223401[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 810  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$223401[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$223403[ebp], eax

; 811  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$223403[ebp], 0
	jne	SHORT $LN6@CacheResul

; 812  : 		{
; 813  : 			const char* szSQL = "select Policies.ID from Policy_Disables inner join Policies on Policies.Type = PolicyDisable where PolicyType = ?";

	mov	DWORD PTR _szSQL$223405[ebp], OFFSET ??_C@_0HC@FGKHHPOB@select?5Policies?4ID?5from?5Policy_D@

; 814  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	eax, DWORD PTR _szSQL$223405[ebp]
	push	eax
	lea	ecx, DWORD PTR _sqlKey$223401[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$223403[ebp], eax
$LN6@CacheResul:

; 815  : 		}
; 816  : 
; 817  : 		pResults->Bind(1, szPolicyType, false);

	push	0
	mov	edx, DWORD PTR _szPolicyType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$223403[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z

; 818  : 
; 819  : 		int i = 0;

	mov	DWORD PTR _i$223407[ebp], 0
$LN5@CacheResul:

; 820  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$223403[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@CacheResul

; 821  : 		{
; 822  : 			m_piPolicyDisables[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$223403[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+972]
	mov	ecx, DWORD PTR _i$223407[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edx, DWORD PTR _i$223407[ebp]
	add	edx, 1
	mov	DWORD PTR _i$223407[ebp], edx

; 823  : 		}

	jmp	SHORT $LN5@CacheResul
$LN4@CacheResul:

; 824  : 
; 825  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$223403[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 826  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$223401[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 827  : 
; 828  : 	//UnitCombatFreePromotions
; 829  : 	{
; 830  : 		m_FreePromotionUnitCombats.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	call	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear

; 831  : 		std::string sqlKey = "m_FreePromotionsUnitCombats";

	push	OFFSET ??_C@_0BM@DNOOJGJD@m_FreePromotionsUnitCombats?$AA@
	lea	ecx, DWORD PTR _sqlKey$223411[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 832  : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	eax, DWORD PTR _sqlKey$223411[ebp]
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$223413[ebp], eax

; 833  : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$223413[ebp], 0
	jne	SHORT $LN3@CacheResul

; 834  : 		{
; 835  : 			const char* szSQL = "select UnitPromotions.ID, UnitCombatInfos.ID  from Policy_FreePromotionUnitCombats, UnitPromotions, UnitCombatInfos where PolicyType = ? and PromotionType = UnitPromotions.ID and UnitCombatType = UnitCombatInfos.ID";

	mov	DWORD PTR _szSQL$223415[ebp], OFFSET ??_C@_0NH@JGCEKKAB@select?5UnitPromotions?4ID?0?5UnitCo@

; 836  : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	ecx, DWORD PTR _szSQL$223415[ebp]
	push	ecx
	lea	edx, DWORD PTR _sqlKey$223411[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$223413[ebp], eax
$LN3@CacheResul:

; 837  : 		}
; 838  : 
; 839  : 		pResults->Bind(1, szPolicyType, false);

	push	0
	mov	eax, DWORD PTR _szPolicyType$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pResults$223413[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN2@CacheResul:

; 840  : 
; 841  : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$223413[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	$LN1@CacheResul

; 842  : 		{
; 843  : 			const int UnitPromotionID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$223413[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _UnitPromotionID$223420[ebp], eax

; 844  : 			const int UnitCombatInfoID = pResults->GetInt(1);

	push	1
	mov	ecx, DWORD PTR _pResults$223413[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _UnitCombatInfoID$223421[ebp], eax

; 845  : 
; 846  : 			m_FreePromotionUnitCombats.insert(std::pair<int, int>(UnitPromotionID, UnitCombatInfoID));

	mov	edx, DWORD PTR _UnitPromotionID$223420[ebp]
	mov	DWORD PTR $T231415[ebp], edx
	mov	eax, DWORD PTR _UnitCombatInfoID$223421[ebp]
	mov	DWORD PTR $T231415[ebp+4], eax
	mov	ecx, DWORD PTR $T231415[ebp]
	mov	DWORD PTR $T231414[ebp], ecx
	mov	edx, DWORD PTR $T231415[ebp+4]
	mov	DWORD PTR $T231414[ebp+4], edx
	lea	eax, DWORD PTR $T231414[ebp]
	push	eax
	lea	ecx, DWORD PTR $T231673[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	call	?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T231416[ebp], edx

; 847  : 		}

	jmp	$LN2@CacheResul
$LN1@CacheResul:

; 848  : 
; 849  : 		//Trim capacity
; 850  : 		std::multimap<int, int>(m_FreePromotionUnitCombats).swap(m_FreePromotionUnitCombats);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 952				; 000003b8H
	push	eax
	lea	ecx, DWORD PTR $T231417[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	lea	ecx, DWORD PTR $T231417[ebp]
	mov	DWORD PTR tv1572[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 952				; 000003b8H
	push	edx
	mov	ecx, DWORD PTR tv1572[ebp]
	call	?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T231417[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 851  : 
; 852  : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$223413[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 853  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$223411[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 854  : 
; 855  : 	return true;

	mov	al, 1
$LN24@CacheResul:

; 856  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR $T231413[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$223336[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$2:
	lea	ecx, DWORD PTR _strKey$223347[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$3:
	lea	ecx, DWORD PTR _strKey$223359[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$4:
	lea	ecx, DWORD PTR _sqlKey$223379[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$5:
	lea	ecx, DWORD PTR _sqlKey$223390[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$6:
	lea	ecx, DWORD PTR _sqlKey$223401[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$7:
	lea	ecx, DWORD PTR _sqlKey$223411[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$8:
	lea	ecx, DWORD PTR $T231417[ebp]
	jmp	??1?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$19:
	lea	ecx, DWORD PTR $T231417[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1068]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvPolicyEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvPolicyEntry::CacheResults
PUBLIC	__$ArrayPad$
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
$T233018 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T233018[ebp], 0

; 490  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 491  : 
; 492  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 493  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 494  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 495  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 496  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T233018[ebp]
	or	eax, 1
	mov	DWORD PTR $T233018[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 497  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$2:
	mov	eax, DWORD PTR $T233018[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz
	and	DWORD PTR $T233018[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	?GetCultureCost@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetCultureCost
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
;	COMDAT ?GetCultureCost@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureCost@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCultureCost, COMDAT
; _this$ = ecx

; 860  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 861  : 	return m_iCultureCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+264]

; 862  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureCost@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCultureCost
_TEXT	ENDS
PUBLIC	?GetGridX@CvPolicyEntry@@QBEHXZ			; CvPolicyEntry::GetGridX
; Function compile flags: /Odtp
;	COMDAT ?GetGridX@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGridX@CvPolicyEntry@@QBEHXZ PROC			; CvPolicyEntry::GetGridX, COMDAT
; _this$ = ecx

; 866  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 867  : 	return m_iGridX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 868  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGridX@CvPolicyEntry@@QBEHXZ ENDP			; CvPolicyEntry::GetGridX
_TEXT	ENDS
PUBLIC	?GetGridY@CvPolicyEntry@@QBEHXZ			; CvPolicyEntry::GetGridY
; Function compile flags: /Odtp
;	COMDAT ?GetGridY@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGridY@CvPolicyEntry@@QBEHXZ PROC			; CvPolicyEntry::GetGridY, COMDAT
; _this$ = ecx

; 872  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 873  : 	return m_iGridY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 874  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGridY@CvPolicyEntry@@QBEHXZ ENDP			; CvPolicyEntry::GetGridY
_TEXT	ENDS
PUBLIC	?GetLevel@CvPolicyEntry@@QBEHXZ			; CvPolicyEntry::GetLevel
; Function compile flags: /Odtp
;	COMDAT ?GetLevel@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLevel@CvPolicyEntry@@QBEHXZ PROC			; CvPolicyEntry::GetLevel, COMDAT
; _this$ = ecx

; 878  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 879  : 	return m_iLevel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 880  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLevel@CvPolicyEntry@@QBEHXZ ENDP			; CvPolicyEntry::GetLevel
_TEXT	ENDS
PUBLIC	?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetPolicyCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetPolicyCostModifier, COMDAT
; _this$ = ecx

; 884  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 885  : 	return m_iPolicyCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 886  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetPolicyCostModifier
_TEXT	ENDS
PUBLIC	?GetCulturePerCity@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCulturePerCity
; Function compile flags: /Odtp
;	COMDAT ?GetCulturePerCity@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCulturePerCity@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCulturePerCity, COMDAT
; _this$ = ecx

; 890  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 891  : 	return m_iCulturePerCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 892  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCulturePerCity@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCulturePerCity
_TEXT	ENDS
PUBLIC	?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCulturePerWonder
; Function compile flags: /Odtp
;	COMDAT ?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCulturePerWonder, COMDAT
; _this$ = ecx

; 905  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 906  : 	return m_iCulturePerWonder;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 907  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCulturePerWonder@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCulturePerWonder
_TEXT	ENDS
PUBLIC	?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureWonderMultiplier
; Function compile flags: /Odtp
;	COMDAT ?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCultureWonderMultiplier, COMDAT
; _this$ = ecx

; 911  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 912  : 	return m_iCultureWonderMultiplier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 913  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureWonderMultiplier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCultureWonderMultiplier
_TEXT	ENDS
PUBLIC	?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturePerTechResearched
; Function compile flags: /Odtp
;	COMDAT ?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCulturePerTechResearched, COMDAT
; _this$ = ecx

; 917  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 918  : 	return m_iCulturePerTechResearched;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 919  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCulturePerTechResearched@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCulturePerTechResearched
_TEXT	ENDS
PUBLIC	?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureImprovementChange
; Function compile flags: /Odtp
;	COMDAT ?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCultureImprovementChange, COMDAT
; _this$ = ecx

; 923  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 924  : 	return m_iCultureImprovementChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 925  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCultureImprovementChange
_TEXT	ENDS
PUBLIC	?GetCultureFromKills@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCultureFromKills
; Function compile flags: /Odtp
;	COMDAT ?GetCultureFromKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureFromKills@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCultureFromKills, COMDAT
; _this$ = ecx

; 929  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 	return m_iCultureFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+304]

; 931  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureFromKills@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCultureFromKills
_TEXT	ENDS
PUBLIC	?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureFromBarbarianKills
; Function compile flags: /Odtp
;	COMDAT ?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCultureFromBarbarianKills, COMDAT
; _this$ = ecx

; 935  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 936  : 	return m_iCultureFromBarbarianKills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+308]

; 937  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCultureFromBarbarianKills
_TEXT	ENDS
PUBLIC	?GetGoldFromKills@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetGoldFromKills
; Function compile flags: /Odtp
;	COMDAT ?GetGoldFromKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldFromKills@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldFromKills, COMDAT
; _this$ = ecx

; 941  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 942  : 	return m_iGoldFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+312]

; 943  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldFromKills@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldFromKills
_TEXT	ENDS
PUBLIC	?GetScienceFromKills@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetScienceFromKills
; Function compile flags: /Odtp
;	COMDAT ?GetScienceFromKills@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetScienceFromKills@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetScienceFromKills, COMDAT
; _this$ = ecx

; 948  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 949  : 	return m_iScienceFromKills;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+316]

; 950  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetScienceFromKills@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetScienceFromKills
_TEXT	ENDS
PUBLIC	?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetEmbarkedExtraMoves
; Function compile flags: /Odtp
;	COMDAT ?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetEmbarkedExtraMoves, COMDAT
; _this$ = ecx

; 955  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 956  : 	return m_iEmbarkedExtraMoves;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+320]

; 957  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetEmbarkedExtraMoves
_TEXT	ENDS
PUBLIC	?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetAttackBonusTurns
; Function compile flags: /Odtp
;	COMDAT ?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetAttackBonusTurns, COMDAT
; _this$ = ecx

; 961  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 962  : 	return m_iAttackBonusTurns;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+324]

; 963  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAttackBonusTurns@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetAttackBonusTurns
_TEXT	ENDS
PUBLIC	?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldenAgeTurns
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldenAgeTurns, COMDAT
; _this$ = ecx

; 967  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 968  : 	return m_iGoldenAgeTurns;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+328]

; 969  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeTurns@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldenAgeTurns
_TEXT	ENDS
PUBLIC	?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldenAgeMeterMod
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGoldenAgeMeterMod, COMDAT
; _this$ = ecx

; 973  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 974  : 	return m_iGoldenAgeMeterMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]

; 975  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeMeterMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGoldenAgeMeterMod
_TEXT	ENDS
PUBLIC	?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldenAgeDurationMod
; Function compile flags: /Odtp
;	COMDAT ?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGoldenAgeDurationMod, COMDAT
; _this$ = ecx

; 979  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 	return m_iGoldenAgeDurationMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+336]

; 981  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldenAgeDurationMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGoldenAgeDurationMod
_TEXT	ENDS
PUBLIC	?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetNumFreeTechs
; Function compile flags: /Odtp
;	COMDAT ?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumFreeTechs, COMDAT
; _this$ = ecx

; 985  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 986  : 	return m_iNumFreeTechs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+340]

; 987  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumFreeTechs@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumFreeTechs
_TEXT	ENDS
PUBLIC	?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumFreePolicies
; Function compile flags: /Odtp
;	COMDAT ?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumFreePolicies, COMDAT
; _this$ = ecx

; 991  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 992  : 	return m_iNumFreePolicies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+344]

; 993  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumFreePolicies@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumFreePolicies
_TEXT	ENDS
PUBLIC	?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumFreeGreatPeople
; Function compile flags: /Odtp
;	COMDAT ?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetNumFreeGreatPeople, COMDAT
; _this$ = ecx

; 997  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 998  : 	return m_iNumFreeGreatPeople;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+348]

; 999  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumFreeGreatPeople@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetNumFreeGreatPeople
_TEXT	ENDS
PUBLIC	?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetNumExtraSpies
; Function compile flags: /Odtp
;	COMDAT ?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumExtraSpies, COMDAT
; _this$ = ecx

; 1004 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1005 : 	return m_iNumExtraSpies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+352]

; 1006 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumExtraSpies@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumExtraSpies
_TEXT	ENDS
PUBLIC	?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMedianTechPercentChange
; Function compile flags: /Odtp
;	COMDAT ?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMedianTechPercentChange, COMDAT
; _this$ = ecx

; 1011 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1012 : 	return m_iMedianTechPercentChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+356]

; 1013 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMedianTechPercentChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMedianTechPercentChange
_TEXT	ENDS
PUBLIC	?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetStrategicResourceMod
; Function compile flags: /Odtp
;	COMDAT ?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetStrategicResourceMod, COMDAT
; _this$ = ecx

; 1017 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 	return m_iStrategicResourceMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+360]

; 1019 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetStrategicResourceMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetStrategicResourceMod
_TEXT	ENDS
PUBLIC	?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetWonderProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetWonderProductionModifier, COMDAT
; _this$ = ecx

; 1023 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1024 : 	return m_iWonderProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+364]

; 1025 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetWonderProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetBuildingProductionModifier, COMDAT
; _this$ = ecx

; 1029 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1030 : 	return m_iBuildingProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+368]

; 1031 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetBuildingProductionModifier
_TEXT	ENDS
PUBLIC	?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatPeopleRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatPeopleRateModifier, COMDAT
; _this$ = ecx

; 1035 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1036 : 	return m_iGreatPeopleRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+372]

; 1037 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatPeopleRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatGeneralRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 1041 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1042 : 	return m_iGreatGeneralRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+376]

; 1043 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatAdmiralRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatAdmiralRateModifier, COMDAT
; _this$ = ecx

; 1047 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1048 : 	return m_iGreatAdmiralRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+380]

; 1049 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatAdmiralRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatWriterRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatWriterRateModifier, COMDAT
; _this$ = ecx

; 1053 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1054 : 	return m_iGreatWriterRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+384]

; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatWriterRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatArtistRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGreatArtistRateModifier, COMDAT
; _this$ = ecx

; 1059 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 	return m_iGreatArtistRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+388]

; 1061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGreatArtistRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatMusicianRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGreatMusicianRateModifier, COMDAT
; _this$ = ecx

; 1065 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1066 : 	return m_iGreatMusicianRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+392]

; 1067 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGreatMusicianRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatMerchantRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGreatMerchantRateModifier, COMDAT
; _this$ = ecx

; 1071 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1072 : 	return m_iGreatMerchantRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+396]

; 1073 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGreatMerchantRateModifier
_TEXT	ENDS
PUBLIC	?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatScientistRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGreatScientistRateModifier, COMDAT
; _this$ = ecx

; 1077 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1078 : 	return m_iGreatScientistRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+400]

; 1079 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGreatScientistRateModifier
_TEXT	ENDS
PUBLIC	?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetDomesticGreatGeneralRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetDomesticGreatGeneralRateModifier, COMDAT
; _this$ = ecx

; 1083 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1084 : 	return m_iDomesticGreatGeneralRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+404]

; 1085 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetDomesticGreatGeneralRateModifier
_TEXT	ENDS
PUBLIC	?GetExtraHappiness@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExtraHappiness
; Function compile flags: /Odtp
;	COMDAT ?GetExtraHappiness@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraHappiness@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetExtraHappiness, COMDAT
; _this$ = ecx

; 1089 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1090 : 	return m_iExtraHappiness;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+408]

; 1091 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraHappiness@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetExtraHappiness
_TEXT	ENDS
PUBLIC	?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExtraHappinessPerCity
; Function compile flags: /Odtp
;	COMDAT ?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraHappinessPerCity, COMDAT
; _this$ = ecx

; 1095 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1096 : 	return m_iExtraHappinessPerCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+412]

; 1097 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraHappinessPerCity
_TEXT	ENDS
PUBLIC	?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetUnhappinessMod
; Function compile flags: /Odtp
;	COMDAT ?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetUnhappinessMod, COMDAT
; _this$ = ecx

; 1101 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1102 : 	return m_iUnhappinessMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+416]

; 1103 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityCountUnhappinessMod
; Function compile flags: /Odtp
;	COMDAT ?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCityCountUnhappinessMod, COMDAT
; _this$ = ecx

; 1107 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1108 : 	return m_iCityCountUnhappinessMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+420]

; 1109 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityCountUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCityCountUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetOccupiedPopulationUnhappinessMod
; Function compile flags: /Odtp
;	COMDAT ?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetOccupiedPopulationUnhappinessMod, COMDAT
; _this$ = ecx

; 1113 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 	return m_iOccupiedPopulationUnhappinessMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+424]

; 1115 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOccupiedPopulationUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetOccupiedPopulationUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCapitalUnhappinessMod
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCapitalUnhappinessMod, COMDAT
; _this$ = ecx

; 1119 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1120 : 	return m_iCapitalUnhappinessMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+428]

; 1121 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalUnhappinessMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCapitalUnhappinessMod
_TEXT	ENDS
PUBLIC	?GetFreeExperience@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetFreeExperience
; Function compile flags: /Odtp
;	COMDAT ?GetFreeExperience@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeExperience@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetFreeExperience, COMDAT
; _this$ = ecx

; 1125 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1126 : 	return m_iFreeExperience;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+432]

; 1127 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeExperience@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetFreeExperience
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetWorkerSpeedModifier
; Function compile flags: /Odtp
;	COMDAT ?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 1131 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1132 : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+436]

; 1133 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorkerSpeedModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetAllFeatureProduction
; Function compile flags: /Odtp
;	COMDAT ?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetAllFeatureProduction, COMDAT
; _this$ = ecx

; 1137 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1138 : 	return m_iAllFeatureProduction;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+440]

; 1139 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAllFeatureProduction@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetAllFeatureProduction
_TEXT	ENDS
PUBLIC	?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetImprovementCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetImprovementCostModifier, COMDAT
; _this$ = ecx

; 1143 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1144 : 	return m_iImprovementCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+444]

; 1145 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetImprovementCostModifier
_TEXT	ENDS
PUBLIC	?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetImprovementUpgradeRateModifier
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetImprovementUpgradeRateModifier, COMDAT
; _this$ = ecx

; 1149 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1150 : 	return m_iImprovementUpgradeRateModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+448]

; 1151 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovementUpgradeRateModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetImprovementUpgradeRateModifier
_TEXT	ENDS
PUBLIC	?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSpecialistProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSpecialistProductionModifier, COMDAT
; _this$ = ecx

; 1155 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1156 : 	return m_iSpecialistProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+452]

; 1157 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpecialistProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSpecialistProductionModifier
_TEXT	ENDS
PUBLIC	?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSpecialistUpgradeModifier
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSpecialistUpgradeModifier, COMDAT
; _this$ = ecx

; 1161 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1162 : 	return m_iSpecialistUpgradeModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+456]

; 1163 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpecialistUpgradeModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSpecialistUpgradeModifier
_TEXT	ENDS
PUBLIC	?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMilitaryProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMilitaryProductionModifier, COMDAT
; _this$ = ecx

; 1167 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 	return m_iMilitaryProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+460]

; 1169 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMilitaryProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMilitaryProductionModifier
_TEXT	ENDS
PUBLIC	?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetBaseFreeUnits
; Function compile flags: /Odtp
;	COMDAT ?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetBaseFreeUnits, COMDAT
; _this$ = ecx

; 1173 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1174 : 	return m_iBaseFreeUnits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+464]

; 1175 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseFreeUnits@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetBaseFreeUnits
_TEXT	ENDS
PUBLIC	?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetBaseFreeMilitaryUnits
; Function compile flags: /Odtp
;	COMDAT ?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetBaseFreeMilitaryUnits, COMDAT
; _this$ = ecx

; 1179 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1180 : 	return m_iBaseFreeMilitaryUnits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+468]

; 1181 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseFreeMilitaryUnits@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetBaseFreeMilitaryUnits
_TEXT	ENDS
PUBLIC	?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetFreeUnitsPopulationPercent
; Function compile flags: /Odtp
;	COMDAT ?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetFreeUnitsPopulationPercent, COMDAT
; _this$ = ecx

; 1185 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1186 : 	return m_iFreeUnitsPopulationPercent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+472]

; 1187 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetFreeUnitsPopulationPercent
_TEXT	ENDS
PUBLIC	?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetFreeMilitaryUnitsPopulationPercent
; Function compile flags: /Odtp
;	COMDAT ?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetFreeMilitaryUnitsPopulationPercent, COMDAT
; _this$ = ecx

; 1191 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1192 : 	return m_iFreeMilitaryUnitsPopulationPercent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+476]

; 1193 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeMilitaryUnitsPopulationPercent@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetFreeMilitaryUnitsPopulationPercent
_TEXT	ENDS
PUBLIC	?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerGarrisonedUnit
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetHappinessPerGarrisonedUnit, COMDAT
; _this$ = ecx

; 1197 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1198 : 	return m_iHappinessPerGarrisonedUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+480]

; 1199 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetHappinessPerGarrisonedUnit
_TEXT	ENDS
PUBLIC	?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturePerGarrisonedUnit
; Function compile flags: /Odtp
;	COMDAT ?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCulturePerGarrisonedUnit, COMDAT
; _this$ = ecx

; 1203 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1204 : 	return m_iCulturePerGarrisonedUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+484]

; 1205 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCulturePerGarrisonedUnit
_TEXT	ENDS
PUBLIC	?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerTradeRoute
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessPerTradeRoute, COMDAT
; _this$ = ecx

; 1209 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1210 : 	return m_iHappinessPerTradeRoute;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+488]

; 1211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessPerTradeRoute@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessPerTradeRoute
_TEXT	ENDS
PUBLIC	?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerRailConnection
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetHappinessPerRailConnection, COMDAT
; _this$ = ecx

; 1216 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1217 : 	return m_iHappinessPerRailConnection;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+492]

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessPerRailConnection@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetHappinessPerRailConnection
_TEXT	ENDS
PUBLIC	?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerXPopulation
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessPerXPopulation, COMDAT
; _this$ = ecx

; 1223 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1224 : 	return m_iHappinessPerXPopulation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+496]

; 1225 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessPerXPopulation@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessPerXPopulation
_TEXT	ENDS
PUBLIC	?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraHappinessPerLuxury
; Function compile flags: /Odtp
;	COMDAT ?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraHappinessPerLuxury, COMDAT
; _this$ = ecx

; 1229 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1230 : 	return m_iExtraHappinessPerLuxury;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+500]

; 1231 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraHappinessPerLuxury@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraHappinessPerLuxury
_TEXT	ENDS
PUBLIC	?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetUnhappinessFromUnitsMod
; Function compile flags: /Odtp
;	COMDAT ?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnhappinessFromUnitsMod, COMDAT
; _this$ = ecx

; 1235 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1236 : 	return m_iUnhappinessFromUnitsMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+504]

; 1237 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnhappinessFromUnitsMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnhappinessFromUnitsMod
_TEXT	ENDS
PUBLIC	?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumExtraBuilders
; Function compile flags: /Odtp
;	COMDAT ?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumExtraBuilders, COMDAT
; _this$ = ecx

; 1241 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1242 : 	return m_iNumExtraBuilders;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+508]

; 1243 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumExtraBuilders@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumExtraBuilders
_TEXT	ENDS
PUBLIC	?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetPlotGoldCostMod
; Function compile flags: /Odtp
;	COMDAT ?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetPlotGoldCostMod, COMDAT
; _this$ = ecx

; 1247 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1248 : 	return m_iPlotGoldCostMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+512]

; 1249 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotGoldCostMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetPlotGoldCostMod
_TEXT	ENDS
PUBLIC	?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPlotCultureCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetPlotCultureCostModifier, COMDAT
; _this$ = ecx

; 1253 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 	return m_iPlotCultureCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+516]

; 1255 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotCultureCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetPlotCultureCostModifier
_TEXT	ENDS
PUBLIC	?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPlotCultureExponentModifier
; Function compile flags: /Odtp
;	COMDAT ?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetPlotCultureExponentModifier, COMDAT
; _this$ = ecx

; 1259 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1260 : 	return m_iPlotCultureExponentModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+520]

; 1261 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlotCultureExponentModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetPlotCultureExponentModifier
_TEXT	ENDS
PUBLIC	?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesPolicyCostDiscount
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesPolicyCostDiscount, COMDAT
; _this$ = ecx

; 1265 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1266 : 	return m_iNumCitiesPolicyCostDiscount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+524]

; 1267 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesPolicyCostDiscount@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesPolicyCostDiscount
_TEXT	ENDS
PUBLIC	?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesResearchCostDiscount
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesResearchCostDiscount, COMDAT
; _this$ = ecx

; 1272 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1273 : 	return m_iNumCitiesResearchCostDiscount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+528]

; 1274 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesResearchCostDiscount@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesResearchCostDiscount
_TEXT	ENDS
PUBLIC	?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGarrisonedCityRangeStrikeModifier
; Function compile flags: /Odtp
;	COMDAT ?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetGarrisonedCityRangeStrikeModifier, COMDAT
; _this$ = ecx

; 1279 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1280 : 	return m_iGarrisonedCityRangeStrikeModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+532]

; 1281 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetGarrisonedCityRangeStrikeModifier
_TEXT	ENDS
PUBLIC	?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetUnitPurchaseCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnitPurchaseCostModifier, COMDAT
; _this$ = ecx

; 1285 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 	return m_iUnitPurchaseCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+536]

; 1287 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnitPurchaseCostModifier
_TEXT	ENDS
PUBLIC	?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingPurchaseCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetBuildingPurchaseCostModifier, COMDAT
; _this$ = ecx

; 1291 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1292 : 	return m_iBuildingPurchaseCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+540]

; 1293 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetBuildingPurchaseCostModifier
_TEXT	ENDS
PUBLIC	?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityConnectionTradeRouteGoldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCityConnectionTradeRouteGoldModifier, COMDAT
; _this$ = ecx

; 1297 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1298 : 	return m_iCityConnectionTradeRouteGoldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+544]

; 1299 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityConnectionTradeRouteGoldModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCityConnectionTradeRouteGoldModifier
_TEXT	ENDS
PUBLIC	?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeMissionGoldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetTradeMissionGoldModifier, COMDAT
; _this$ = ecx

; 1303 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1304 : 	return m_iTradeMissionGoldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+548]

; 1305 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetTradeMissionGoldModifier
_TEXT	ENDS
PUBLIC	?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetFaithCostModifier
; Function compile flags: /Odtp
;	COMDAT ?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetFaithCostModifier, COMDAT
; _this$ = ecx

; 1309 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1310 : 	return m_iFaithCostModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+552]

; 1311 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetFaithCostModifier
_TEXT	ENDS
PUBLIC	?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturalPlunderMultiplier
; Function compile flags: /Odtp
;	COMDAT ?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCulturalPlunderMultiplier, COMDAT
; _this$ = ecx

; 1315 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1316 : 	return m_iCulturalPlunderMultiplier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+556]

; 1317 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCulturalPlunderMultiplier
_TEXT	ENDS
PUBLIC	?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetStealTechSlowerModifier
; Function compile flags: /Odtp
;	COMDAT ?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetStealTechSlowerModifier, COMDAT
; _this$ = ecx

; 1321 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1322 : 	return m_iStealTechSlowerModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+560]

; 1323 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetStealTechSlowerModifier
_TEXT	ENDS
PUBLIC	?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetStealTechFasterModifier
; Function compile flags: /Odtp
;	COMDAT ?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetStealTechFasterModifier, COMDAT
; _this$ = ecx

; 1326 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1327 : 	return m_iStealTechFasterModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+564]

; 1328 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetStealTechFasterModifier
_TEXT	ENDS
PUBLIC	?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCatchSpiesModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCatchSpiesModifier, COMDAT
; _this$ = ecx

; 1332 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1333 : 	return m_iCatchSpiesModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+568]

; 1334 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCatchSpiesModifier
_TEXT	ENDS
PUBLIC	?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetGoldPerUnit
; Function compile flags: /Odtp
;	COMDAT ?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldPerUnit, COMDAT
; _this$ = ecx

; 1338 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1339 : 	return m_iGoldPerUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+572]

; 1340 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldPerUnit@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldPerUnit
_TEXT	ENDS
PUBLIC	?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldPerMilitaryUnit
; Function compile flags: /Odtp
;	COMDAT ?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetGoldPerMilitaryUnit, COMDAT
; _this$ = ecx

; 1344 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1345 : 	return m_iGoldPerMilitaryUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+576]

; 1346 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldPerMilitaryUnit@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetGoldPerMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCityStrengthMod
; Function compile flags: /Odtp
;	COMDAT ?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCityStrengthMod, COMDAT
; _this$ = ecx

; 1350 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1351 : 	return m_iCityStrengthMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+580]

; 1352 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStrengthMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCityStrengthMod
_TEXT	ENDS
PUBLIC	?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetCityGrowthMod
; Function compile flags: /Odtp
;	COMDAT ?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCityGrowthMod, COMDAT
; _this$ = ecx

; 1356 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1357 : 	return m_iCityGrowthMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+584]

; 1358 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityGrowthMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCityGrowthMod
_TEXT	ENDS
PUBLIC	?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCapitalGrowthMod
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetCapitalGrowthMod, COMDAT
; _this$ = ecx

; 1362 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1363 : 	return m_iCapitalGrowthMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+588]

; 1364 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalGrowthMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetCapitalGrowthMod
_TEXT	ENDS
PUBLIC	?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSettlerProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSettlerProductionModifier, COMDAT
; _this$ = ecx

; 1368 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1369 : 	return m_iSettlerProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+592]

; 1370 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSettlerProductionModifier
_TEXT	ENDS
PUBLIC	?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCapitalSettlerProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCapitalSettlerProductionModifier, COMDAT
; _this$ = ecx

; 1374 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1375 : 	return m_iCapitalSettlerProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+596]

; 1376 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalSettlerProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCapitalSettlerProductionModifier
_TEXT	ENDS
PUBLIC	?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNewCityExtraPopulation
; Function compile flags: /Odtp
;	COMDAT ?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetNewCityExtraPopulation, COMDAT
; _this$ = ecx

; 1380 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1381 : 	return m_iNewCityExtraPopulation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+600]

; 1382 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNewCityExtraPopulation@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetNewCityExtraPopulation
_TEXT	ENDS
PUBLIC	?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetFreeFoodBox
; Function compile flags: /Odtp
;	COMDAT ?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetFreeFoodBox, COMDAT
; _this$ = ecx

; 1386 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1387 : 	return m_iFreeFoodBox;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+604]

; 1388 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeFoodBox@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetFreeFoodBox
_TEXT	ENDS
PUBLIC	?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRouteGoldMaintenanceMod
; Function compile flags: /Odtp
;	COMDAT ?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetRouteGoldMaintenanceMod, COMDAT
; _this$ = ecx

; 1392 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1393 : 	return m_iRouteGoldMaintenanceMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+608]

; 1394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRouteGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetRouteGoldMaintenanceMod
_TEXT	ENDS
PUBLIC	?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingGoldMaintenanceMod
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetBuildingGoldMaintenanceMod, COMDAT
; _this$ = ecx

; 1398 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1399 : 	return m_iBuildingGoldMaintenanceMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+612]

; 1400 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBuildingGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetBuildingGoldMaintenanceMod
_TEXT	ENDS
PUBLIC	?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetUnitGoldMaintenanceMod
; Function compile flags: /Odtp
;	COMDAT ?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnitGoldMaintenanceMod, COMDAT
; _this$ = ecx

; 1404 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1405 : 	return m_iUnitGoldMaintenanceMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+616]

; 1406 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitGoldMaintenanceMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnitGoldMaintenanceMod
_TEXT	ENDS
PUBLIC	?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetUnitSupplyMod
; Function compile flags: /Odtp
;	COMDAT ?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetUnitSupplyMod, COMDAT
; _this$ = ecx

; 1410 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1411 : 	return m_iUnitSupplyMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+620]

; 1412 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitSupplyMod@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetUnitSupplyMod
_TEXT	ENDS
PUBLIC	?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetHappyPerMilitaryUnit
; Function compile flags: /Odtp
;	COMDAT ?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappyPerMilitaryUnit, COMDAT
; _this$ = ecx

; 1416 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1417 : 	return m_iHappyPerMilitaryUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+624]

; 1418 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappyPerMilitaryUnit@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappyPerMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetFreeSpecialist
; Function compile flags: /Odtp
;	COMDAT ?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetFreeSpecialist, COMDAT
; _this$ = ecx

; 1422 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1423 : 	return m_iFreeSpecialist;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+812]

; 1424 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeSpecialist@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetFreeSpecialist
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetTechPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetTechPrereq@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechPrereq@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 1428 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1429 : 	return m_iTechPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+260]

; 1430 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechPrereq@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetMaxConscript@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetMaxConscript
; Function compile flags: /Odtp
;	COMDAT ?GetMaxConscript@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxConscript@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetMaxConscript, COMDAT
; _this$ = ecx

; 1434 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1435 : 	return m_iMaxConscript;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+816]

; 1436 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxConscript@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetMaxConscript
_TEXT	ENDS
PUBLIC	?GetExpModifier@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetExpModifier
; Function compile flags: /Odtp
;	COMDAT ?GetExpModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExpModifier@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetExpModifier, COMDAT
; _this$ = ecx

; 1440 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1441 : 	return m_iExpModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+628]

; 1442 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExpModifier@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetExpModifier
_TEXT	ENDS
PUBLIC	?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExpInBorderModifier
; Function compile flags: /Odtp
;	COMDAT ?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExpInBorderModifier, COMDAT
; _this$ = ecx

; 1446 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 	return m_iExpInBorderModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+632]

; 1448 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExpInBorderModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExpInBorderModifier
_TEXT	ENDS
PUBLIC	?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorQuestFriendshipMod
; Function compile flags: /Odtp
;	COMDAT ?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorQuestFriendshipMod, COMDAT
; _this$ = ecx

; 1452 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1453 : 	return m_iMinorQuestFriendshipMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+636]

; 1454 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorQuestFriendshipMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorQuestFriendshipMod
_TEXT	ENDS
PUBLIC	?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorGoldFriendshipMod
; Function compile flags: /Odtp
;	COMDAT ?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorGoldFriendshipMod, COMDAT
; _this$ = ecx

; 1458 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1459 : 	return m_iMinorGoldFriendshipMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+640]

; 1460 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorGoldFriendshipMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorGoldFriendshipMod
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorFriendshipMinimum
; Function compile flags: /Odtp
;	COMDAT ?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorFriendshipMinimum, COMDAT
; _this$ = ecx

; 1464 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1465 : 	return m_iMinorFriendshipMinimum;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+644]

; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorFriendshipMinimum@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorFriendshipMinimum
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorFriendshipDecayMod
; Function compile flags: /Odtp
;	COMDAT ?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorFriendshipDecayMod, COMDAT
; _this$ = ecx

; 1470 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1471 : 	return m_iMinorFriendshipDecayMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+648]

; 1472 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorFriendshipDecayMod
_TEXT	ENDS
PUBLIC	?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetOtherPlayersMinorFriendshipDecayMod
; Function compile flags: /Odtp
;	COMDAT ?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetOtherPlayersMinorFriendshipDecayMod, COMDAT
; _this$ = ecx

; 1476 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1477 : 	return m_iOtherPlayersMinorFriendshipDecayMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+652]

; 1478 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOtherPlayersMinorFriendshipDecayMod@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetOtherPlayersMinorFriendshipDecayMod
_TEXT	ENDS
PUBLIC	?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityStateUnitFrequencyModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetCityStateUnitFrequencyModifier, COMDAT
; _this$ = ecx

; 1482 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1483 : 	return m_iCityStateUnitFrequencyModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+656]

; 1484 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetCityStateUnitFrequencyModifier
_TEXT	ENDS
PUBLIC	?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCommonFoeTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCommonFoeTourismModifier, COMDAT
; _this$ = ecx

; 1488 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1489 : 	return m_iCommonFoeTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+660]

; 1490 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCommonFoeTourismModifier
_TEXT	ENDS
PUBLIC	?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetLessHappyTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetLessHappyTourismModifier, COMDAT
; _this$ = ecx

; 1494 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : 	return m_iLessHappyTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+664]

; 1496 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetLessHappyTourismModifier
_TEXT	ENDS
PUBLIC	?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedIdeologyTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSharedIdeologyTourismModifier, COMDAT
; _this$ = ecx

; 1500 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1501 : 	return m_iSharedIdeologyTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+668]

; 1502 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSharedIdeologyTourismModifier
_TEXT	ENDS
PUBLIC	?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetLandTradeRouteGoldChange
; Function compile flags: /Odtp
;	COMDAT ?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetLandTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 1506 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1507 : 	return m_iLandTradeRouteGoldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+672]

; 1508 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetLandTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSeaTradeRouteGoldChange
; Function compile flags: /Odtp
;	COMDAT ?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetSeaTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 1512 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1513 : 	return m_iSeaTradeRouteGoldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+676]

; 1514 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetSeaTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteGoldChange
; Function compile flags: /Odtp
;	COMDAT ?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInternalTradeRouteGoldChange, COMDAT
; _this$ = ecx

; 1519 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1520 : 	return m_iInternalTradeRouteGoldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+680]

; 1521 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInternalTradeRouteGoldChange
_TEXT	ENDS
PUBLIC	?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedIdeologyTradeGoldChange
; Function compile flags: /Odtp
;	COMDAT ?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSharedIdeologyTradeGoldChange, COMDAT
; _this$ = ecx

; 1525 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1526 : 	return m_iSharedIdeologyTradeGoldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+684]

; 1527 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSharedIdeologyTradeGoldChange
_TEXT	ENDS
PUBLIC	?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRiggingElectionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetRiggingElectionModifier, COMDAT
; _this$ = ecx

; 1531 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 	return m_iRiggingElectionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+688]

; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetRiggingElectionModifier
_TEXT	ENDS
PUBLIC	?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMilitaryUnitGiftExtraInfluence
; Function compile flags: /Odtp
;	COMDAT ?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMilitaryUnitGiftExtraInfluence, COMDAT
; _this$ = ecx

; 1537 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1538 : 	return m_iMilitaryUnitGiftExtraInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+692]

; 1539 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMilitaryUnitGiftExtraInfluence
_TEXT	ENDS
PUBLIC	?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProtectedMinorPerTurnInfluence
; Function compile flags: /Odtp
;	COMDAT ?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetProtectedMinorPerTurnInfluence, COMDAT
; _this$ = ecx

; 1543 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1544 : 	return m_iProtectedMinorPerTurnInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+696]

; 1545 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetProtectedMinorPerTurnInfluence
_TEXT	ENDS
PUBLIC	?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetAfraidMinorPerTurnInfluence
; Function compile flags: /Odtp
;	COMDAT ?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetAfraidMinorPerTurnInfluence, COMDAT
; _this$ = ecx

; 1549 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1550 : 	return m_iAfraidMinorPerTurnInfluence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+700]

; 1551 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetAfraidMinorPerTurnInfluence
_TEXT	ENDS
PUBLIC	?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorBullyScoreModifier
; Function compile flags: /Odtp
;	COMDAT ?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetMinorBullyScoreModifier, COMDAT
; _this$ = ecx

; 1555 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1556 : 	return m_iMinorBullyScoreModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+704]

; 1557 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetMinorBullyScoreModifier
_TEXT	ENDS
PUBLIC	?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetThemingBonusMultiplier
; Function compile flags: /Odtp
;	COMDAT ?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetThemingBonusMultiplier, COMDAT
; _this$ = ecx

; 1561 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1562 : 	return m_iThemingBonusMultiplier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+708]

; 1563 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetThemingBonusMultiplier
_TEXT	ENDS
PUBLIC	?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInternalTradeRouteYieldModifier, COMDAT
; _this$ = ecx

; 1567 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1568 : 	return m_iInternalTradeRouteYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+712]

; 1569 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInternalTradeRouteYieldModifier
_TEXT	ENDS
PUBLIC	?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteProductionYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInternalTradeRouteProductionYieldChange, COMDAT
; _this$ = ecx

; 1582 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1583 : 	return m_iInternalTradeRouteProductionYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+716]

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInternalTradeRouteProductionYieldChange
_TEXT	ENDS
PUBLIC	?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRailConnectionProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetRailConnectionProductionModifier, COMDAT
; _this$ = ecx

; 1590 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1591 : 	return m_iRailConnectionProductionModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+720]

; 1592 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetRailConnectionProductionModifier
_TEXT	ENDS
PUBLIC	?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCombatBonusVsSmallerCiv
; Function compile flags: /Odtp
;	COMDAT ?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCombatBonusVsSmallerCiv, COMDAT
; _this$ = ecx

; 1598 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1599 : 	return m_iCombatBonusVsSmallerCiv;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+724]

; 1600 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCombatBonusVsSmallerCiv
_TEXT	ENDS
PUBLIC	?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProductionToGreatMusiciansModifier
; Function compile flags: /Odtp
;	COMDAT ?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetProductionToGreatMusiciansModifier, COMDAT
; _this$ = ecx

; 1606 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1607 : 	return m_iProductionToGreatMusiciansModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+728]

; 1608 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetProductionToGreatMusiciansModifier
_TEXT	ENDS
PUBLIC	?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeMissionInfluenceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetTradeMissionInfluenceModifier, COMDAT
; _this$ = ecx

; 1615 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1616 : 	return m_iTradeMissionInfluenceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+732]

; 1617 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetTradeMissionInfluenceModifier
_TEXT	ENDS
PUBLIC	?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSciencePerGreatPersonBorn
; Function compile flags: /Odtp
;	COMDAT ?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSciencePerGreatPersonBorn, COMDAT
; _this$ = ecx

; 1623 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1624 : 	return m_iSciencePerGreatPersonBorn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+736]

; 1625 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSciencePerGreatPersonBorn
_TEXT	ENDS
PUBLIC	?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInfluenceBoostPerGreatPersonBorn
; Function compile flags: /Odtp
;	COMDAT ?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetInfluenceBoostPerGreatPersonBorn, COMDAT
; _this$ = ecx

; 1631 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1632 : 	return m_iInfluenceBoostPerGreatPersonBorn;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+740]

; 1633 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetInfluenceBoostPerGreatPersonBorn
_TEXT	ENDS
PUBLIC	?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTourismFromTradeMissions
; Function compile flags: /Odtp
;	COMDAT ?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetTourismFromTradeMissions, COMDAT
; _this$ = ecx

; 1639 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1640 : 	return m_iTourismFromTradeMissions;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+744]

; 1641 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetTourismFromTradeMissions
_TEXT	ENDS
PUBLIC	?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessFromGreatImprovements
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetHappinessFromGreatImprovements, COMDAT
; _this$ = ecx

; 1647 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1648 : 	return m_iHappinessFromGreatImprovements;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+748]

; 1649 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetHappinessFromGreatImprovements
_TEXT	ENDS
PUBLIC	?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorFriendshipGainBullyGoldSuccess
; Function compile flags: /Odtp
;	COMDAT ?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMinorFriendshipGainBullyGoldSuccess, COMDAT
; _this$ = ecx

; 1655 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1656 : 	return m_iMinorFriendshipGainBullyGoldSuccess;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+752]

; 1657 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMinorFriendshipGainBullyGoldSuccess
_TEXT	ENDS
PUBLIC	?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCoupChanceModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCoupChanceModifier, COMDAT
; _this$ = ecx

; 1663 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1664 : 	return m_iCoupChanceModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+756]

; 1665 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCoupChanceModifier
_TEXT	ENDS
PUBLIC	?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedReligionTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetSharedReligionTourismModifier, COMDAT
; _this$ = ecx

; 1670 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1671 : 	return m_iSharedReligionTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+760]

; 1672 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetSharedReligionTourismModifier
_TEXT	ENDS
PUBLIC	?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeRouteTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetTradeRouteTourismModifier, COMDAT
; _this$ = ecx

; 1676 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1677 : 	return m_iTradeRouteTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+764]

; 1678 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetTradeRouteTourismModifier
_TEXT	ENDS
PUBLIC	?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetOpenBordersTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetOpenBordersTourismModifier, COMDAT
; _this$ = ecx

; 1682 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1683 : 	return m_iOpenBordersTourismModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+768]

; 1684 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetOpenBordersTourismModifier
_TEXT	ENDS
PUBLIC	?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetCityStateTradeChange
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCityStateTradeChange, COMDAT
; _this$ = ecx

; 1688 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1689 : 	return m_iCityStateTradeChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+772]

; 1690 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCityStateTradeChange
_TEXT	ENDS
PUBLIC	?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsMinorGreatPeopleAllies
; Function compile flags: /Odtp
;	COMDAT ?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMinorGreatPeopleAllies, COMDAT
; _this$ = ecx

; 1694 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1695 : 	return m_bMinorGreatPeopleAllies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+776]

; 1696 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMinorGreatPeopleAllies@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMinorGreatPeopleAllies
_TEXT	ENDS
PUBLIC	?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsMinorScienceAllies
; Function compile flags: /Odtp
;	COMDAT ?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMinorScienceAllies, COMDAT
; _this$ = ecx

; 1700 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1701 : 	return m_bMinorScienceAllies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+777]

; 1702 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMinorScienceAllies@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMinorScienceAllies
_TEXT	ENDS
PUBLIC	?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsMinorResourceBonus
; Function compile flags: /Odtp
;	COMDAT ?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMinorResourceBonus, COMDAT
; _this$ = ecx

; 1706 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1707 : 	return m_bMinorResourceBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+778]

; 1708 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMinorResourceBonus@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMinorResourceBonus
_TEXT	ENDS
PUBLIC	?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorMilitaryNumExtraUnitsToGift
; Function compile flags: /Odtp
;	COMDAT ?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetMinorMilitaryNumExtraUnitsToGift, COMDAT
; _this$ = ecx

; 1713 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1714 : 	return m_iMinorMilitaryNumExtraUnitsToGift;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+780]

; 1715 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetMinorMilitaryNumExtraUnitsToGift
_TEXT	ENDS
PUBLIC	?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityStateBonusModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetCityStateBonusModifier, COMDAT
; _this$ = ecx

; 1719 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1720 : 	return m_iCityStateBonusModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+784]

; 1721 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetCityStateBonusModifier
_TEXT	ENDS
PUBLIC	?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetExtraTerritoryClaim
; Function compile flags: /Odtp
;	COMDAT ?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraTerritoryClaim, COMDAT
; _this$ = ecx

; 1727 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1728 : 	return m_iExtraTerritoryClaim;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+788]

; 1729 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraTerritoryClaim
_TEXT	ENDS
PUBLIC	?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraTourismPerGreatWork
; Function compile flags: /Odtp
;	COMDAT ?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetExtraTourismPerGreatWork, COMDAT
; _this$ = ecx

; 1734 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1735 : 	return m_iExtraTourismPerGreatWork;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+792]

; 1736 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetExtraTourismPerGreatWork
_TEXT	ENDS
PUBLIC	?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetTourismPerWonder
; Function compile flags: /Odtp
;	COMDAT ?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetTourismPerWonder, COMDAT
; _this$ = ecx

; 1741 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1742 : 	return m_iTourismPerWonder;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+796]

; 1743 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetTourismPerWonder
_TEXT	ENDS
PUBLIC	?GetTourismPerCity@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetTourismPerCity
; Function compile flags: /Odtp
;	COMDAT ?GetTourismPerCity@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTourismPerCity@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetTourismPerCity, COMDAT
; _this$ = ecx

; 1748 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1749 : 	return m_iTourismPerCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+800]

; 1750 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTourismPerCity@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetTourismPerCity
_TEXT	ENDS
PUBLIC	?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetIdeologyPressureUnhappinessModifier
; Function compile flags: /Odtp
;	COMDAT ?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetIdeologyPressureUnhappinessModifier, COMDAT
; _this$ = ecx

; 1756 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1757 : 	return m_iIdeologyPressureUnhappinessModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+804]

; 1758 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetIdeologyPressureUnhappinessModifier
_TEXT	ENDS
PUBLIC	?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProductionFromGarrison
; Function compile flags: /Odtp
;	COMDAT ?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetProductionFromGarrison, COMDAT
; _this$ = ecx

; 1764 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1765 : 	return m_iProductionFromGarrison;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+808]

; 1766 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetProductionFromGarrison
_TEXT	ENDS
PUBLIC	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetPolicyBranchType
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetPolicyBranchType, COMDAT
; _this$ = ecx

; 1770 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1771 : 	return m_iPolicyBranchType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+820]

; 1772 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetPolicyBranchType
_TEXT	ENDS
PUBLIC	?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumExtraBranches
; Function compile flags: /Odtp
;	COMDAT ?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetNumExtraBranches, COMDAT
; _this$ = ecx

; 1776 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1777 : 	return m_iNumExtraBranches;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+824]

; 1778 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumExtraBranches@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetNumExtraBranches
_TEXT	ENDS
PUBLIC	?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetHappinessToCulture
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessToCulture, COMDAT
; _this$ = ecx

; 1782 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1783 : 	return m_iHappinessToCulture;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+840]

; 1784 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessToCulture@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessToCulture
_TEXT	ENDS
PUBLIC	?GetHappinessToScience@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetHappinessToScience
; Function compile flags: /Odtp
;	COMDAT ?GetHappinessToScience@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHappinessToScience@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetHappinessToScience, COMDAT
; _this$ = ecx

; 1788 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1789 : 	return m_iHappinessToScience;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+844]

; 1790 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHappinessToScience@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetHappinessToScience
_TEXT	ENDS
PUBLIC	?GetGoldToScience@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetGoldToScience
; Function compile flags: /Odtp
;	COMDAT ?GetGoldToScience@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoldToScience@CvPolicyEntry@@QBEHXZ PROC		; CvPolicyEntry::GetGoldToScience, COMDAT
; _this$ = ecx

; 1795 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1796 : 	return m_iGoldToScience;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+848]

; 1797 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoldToScience@CvPolicyEntry@@QBEHXZ ENDP		; CvPolicyEntry::GetGoldToScience
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreeAestheticsSchools
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreeAestheticsSchools, COMDAT
; _this$ = ecx

; 1803 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1804 : 	return m_iNumCitiesFreeAestheticsSchools;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+852]

; 1805 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesFreeAestheticsSchools@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreeAestheticsSchools
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreePietyGardens
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreePietyGardens, COMDAT
; _this$ = ecx

; 1809 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1810 : 	return m_iNumCitiesFreePietyGardens;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+856]

; 1811 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesFreePietyGardens@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreePietyGardens
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetNumCitiesFreeWalls
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetNumCitiesFreeWalls, COMDAT
; _this$ = ecx

; 1816 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1817 : 	return m_iNumCitiesFreeWalls;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+860]

; 1818 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesFreeWalls@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetNumCitiesFreeWalls
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreeCultureBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreeCultureBuilding, COMDAT
; _this$ = ecx

; 1822 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1823 : 	return m_iNumCitiesFreeCultureBuilding;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+864]

; 1824 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesFreeCultureBuilding@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreeCultureBuilding
_TEXT	ENDS
PUBLIC	?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetNumCitiesFreeFoodBuilding
; Function compile flags: /Odtp
;	COMDAT ?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ PROC ; CvPolicyEntry::GetNumCitiesFreeFoodBuilding, COMDAT
; _this$ = ecx

; 1828 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1829 : 	return m_iNumCitiesFreeFoodBuilding;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+868]

; 1830 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumCitiesFreeFoodBuilding@CvPolicyEntry@@QBEHXZ ENDP ; CvPolicyEntry::GetNumCitiesFreeFoodBuilding
_TEXT	ENDS
PUBLIC	?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsHalfSpecialistUnhappiness
; Function compile flags: /Odtp
;	COMDAT ?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsHalfSpecialistUnhappiness, COMDAT
; _this$ = ecx

; 1834 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1835 : 	return m_bHalfSpecialistUnhappiness;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+872]

; 1836 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHalfSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsHalfSpecialistUnhappiness
_TEXT	ENDS
PUBLIC	?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsHalfMoreSpecialistUnhappiness
; Function compile flags: /Odtp
;	COMDAT ?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsHalfMoreSpecialistUnhappiness, COMDAT
; _this$ = ecx

; 1839 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1840 : 	return m_bHalfMoreSpecialistUnhappiness;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+873]

; 1841 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHalfMoreSpecialistUnhappiness@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsHalfMoreSpecialistUnhappiness
_TEXT	ENDS
PUBLIC	?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsHalfSpecialistFood
; Function compile flags: /Odtp
;	COMDAT ?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsHalfSpecialistFood, COMDAT
; _this$ = ecx

; 1844 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1845 : 	return m_bHalfSpecialistFood;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+874]

; 1846 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsHalfSpecialistFood@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsHalfSpecialistFood
_TEXT	ENDS
PUBLIC	?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsMilitaryFoodProduction
; Function compile flags: /Odtp
;	COMDAT ?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsMilitaryFoodProduction, COMDAT
; _this$ = ecx

; 1850 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1851 : 	return m_bMilitaryFoodProduction;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+875]

; 1852 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMilitaryFoodProduction@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsMilitaryFoodProduction
_TEXT	ENDS
PUBLIC	?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetWoundedUnitDamageMod
; Function compile flags: /Odtp
;	COMDAT ?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetWoundedUnitDamageMod, COMDAT
; _this$ = ecx

; 1856 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1857 : 	return m_iWoundedUnitDamageMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+828]

; 1858 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWoundedUnitDamageMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetWoundedUnitDamageMod
_TEXT	ENDS
PUBLIC	?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetUnitUpgradeCostMod
; Function compile flags: /Odtp
;	COMDAT ?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetUnitUpgradeCostMod, COMDAT
; _this$ = ecx

; 1862 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1863 : 	return m_iUnitUpgradeCostMod;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+832]

; 1864 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetUnitUpgradeCostMod@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetUnitUpgradeCostMod
_TEXT	ENDS
PUBLIC	?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetBarbarianCombatBonus
; Function compile flags: /Odtp
;	COMDAT ?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ PROC	; CvPolicyEntry::GetBarbarianCombatBonus, COMDAT
; _this$ = ecx

; 1868 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1869 : 	return m_iBarbarianCombatBonus;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+836]

; 1870 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBarbarianCombatBonus@CvPolicyEntry@@QBEHXZ ENDP	; CvPolicyEntry::GetBarbarianCombatBonus
_TEXT	ENDS
PUBLIC	?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAlwaysSeeBarbCamps
; Function compile flags: /Odtp
;	COMDAT ?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAlwaysSeeBarbCamps, COMDAT
; _this$ = ecx

; 1874 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1875 : 	return m_bAlwaysSeeBarbCamps;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+876]

; 1876 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlwaysSeeBarbCamps@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAlwaysSeeBarbCamps
_TEXT	ENDS
PUBLIC	?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsRevealAllCapitals
; Function compile flags: /Odtp
;	COMDAT ?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsRevealAllCapitals, COMDAT
; _this$ = ecx

; 1880 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1881 : 	return m_bRevealAllCapitals;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+877]

; 1882 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRevealAllCapitals@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsRevealAllCapitals
_TEXT	ENDS
PUBLIC	?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsGarrisonFreeMaintenance
; Function compile flags: /Odtp
;	COMDAT ?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsGarrisonFreeMaintenance, COMDAT
; _this$ = ecx

; 1886 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1887 : 	return m_bGarrisonFreeMaintenance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+878]

; 1888 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsGarrisonFreeMaintenance
_TEXT	ENDS
PUBLIC	?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsGoldenAgeCultureBonusDisabled
; Function compile flags: /Odtp
;	COMDAT ?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsGoldenAgeCultureBonusDisabled, COMDAT
; _this$ = ecx

; 1891 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1892 : 	return m_bGoldenAgeCultureBonusDisabled;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+879]

; 1893 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsGoldenAgeCultureBonusDisabled@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsGoldenAgeCultureBonusDisabled
_TEXT	ENDS
PUBLIC	?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsSecondReligionPantheon
; Function compile flags: /Odtp
;	COMDAT ?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsSecondReligionPantheon, COMDAT
; _this$ = ecx

; 1896 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1897 : 	return m_bSecondReligionPantheon;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+880]

; 1898 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSecondReligionPantheon@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsSecondReligionPantheon
_TEXT	ENDS
PUBLIC	?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAddReformationBelief
; Function compile flags: /Odtp
;	COMDAT ?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAddReformationBelief, COMDAT
; _this$ = ecx

; 1901 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1902 : 	return m_bAddReformationBelief;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+881]

; 1903 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAddReformationBelief
_TEXT	ENDS
PUBLIC	?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsEnablesSSPartHurry
; Function compile flags: /Odtp
;	COMDAT ?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsEnablesSSPartHurry, COMDAT
; _this$ = ecx

; 1906 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1907 : 	return m_bEnablesSSPartHurry;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+882]

; 1908 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEnablesSSPartHurry@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsEnablesSSPartHurry
_TEXT	ENDS
PUBLIC	?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsDisablesResistanceTime
; Function compile flags: /Odtp
;	COMDAT ?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsDisablesResistanceTime, COMDAT
; _this$ = ecx

; 1912 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1913 : 	return m_bDisablesResistanceTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+883]

; 1914 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDisablesResistanceTime@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsDisablesResistanceTime
_TEXT	ENDS
PUBLIC	?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsDoubleTrainedMilitaryLandUnit
; Function compile flags: /Odtp
;	COMDAT ?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ PROC ; CvPolicyEntry::IsDoubleTrainedMilitaryLandUnit, COMDAT
; _this$ = ecx

; 1919 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1920 : 	return m_bDoubleTrainedMilitaryLandUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+884]

; 1921 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDoubleTrainedMilitaryLandUnit@CvPolicyEntry@@QBE_NXZ ENDP ; CvPolicyEntry::IsDoubleTrainedMilitaryLandUnit
_TEXT	ENDS
PUBLIC	?IsWarHero@CvPolicyEntry@@QBE_NXZ		; CvPolicyEntry::IsWarHero
; Function compile flags: /Odtp
;	COMDAT ?IsWarHero@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWarHero@CvPolicyEntry@@QBE_NXZ PROC			; CvPolicyEntry::IsWarHero, COMDAT
; _this$ = ecx

; 1926 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1927 : 	return m_bWarHero;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+885]

; 1928 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsWarHero@CvPolicyEntry@@QBE_NXZ ENDP			; CvPolicyEntry::IsWarHero
_TEXT	ENDS
PUBLIC	?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsNoMinorDOWIfFriends
; Function compile flags: /Odtp
;	COMDAT ?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsNoMinorDOWIfFriends, COMDAT
; _this$ = ecx

; 1940 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1941 : 	return m_bNoMinorDOWIfFriends;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+886]

; 1942 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoMinorDOWIfFriends@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsNoMinorDOWIfFriends
_TEXT	ENDS
PUBLIC	?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAllowPuppetPurchasing
; Function compile flags: /Odtp
;	COMDAT ?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAllowPuppetPurchasing, COMDAT
; _this$ = ecx

; 1947 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1948 : 	return m_bAllowPuppetPurchasing;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+887]

; 1949 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowPuppetPurchasing@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAllowPuppetPurchasing
_TEXT	ENDS
PUBLIC	?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsEnablesSSPartPurchase
; Function compile flags: /Odtp
;	COMDAT ?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsEnablesSSPartPurchase, COMDAT
; _this$ = ecx

; 1953 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1954 : 	return m_bEnablesSSPartPurchase;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+888]

; 1955 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsEnablesSSPartPurchase@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsEnablesSSPartPurchase
_TEXT	ENDS
PUBLIC	?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ	; CvPolicyEntry::IsAbleToAnnexCityStates
; Function compile flags: /Odtp
;	COMDAT ?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IsAbleToAnnexCityStates, COMDAT
; _this$ = ecx

; 1959 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1960 : 	return m_bAbleToAnnexCityStates;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+889]

; 1961 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAbleToAnnexCityStates@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IsAbleToAnnexCityStates
_TEXT	ENDS
PUBLIC	?IsOneShot@CvPolicyEntry@@QBE_NXZ		; CvPolicyEntry::IsOneShot
; Function compile flags: /Odtp
;	COMDAT ?IsOneShot@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsOneShot@CvPolicyEntry@@QBE_NXZ PROC			; CvPolicyEntry::IsOneShot, COMDAT
; _this$ = ecx

; 1965 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1966 : 	return m_bOneShot;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+890]

; 1967 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsOneShot@CvPolicyEntry@@QBE_NXZ ENDP			; CvPolicyEntry::IsOneShot
_TEXT	ENDS
PUBLIC	?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IncludesOneShotFreeUnits
; Function compile flags: /Odtp
;	COMDAT ?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ PROC	; CvPolicyEntry::IncludesOneShotFreeUnits, COMDAT
; _this$ = ecx

; 1971 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1972 : 	return m_bIncludesOneShotFreeUnits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+891]

; 1973 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IncludesOneShotFreeUnits@CvPolicyEntry@@QBE_NXZ ENDP	; CvPolicyEntry::IncludesOneShotFreeUnits
_TEXT	ENDS
PUBLIC	?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ	; CvPolicyEntry::GetWeLoveTheKing
; Function compile flags: /Odtp
;	COMDAT ?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ PROC		; CvPolicyEntry::GetWeLoveTheKing, COMDAT
; _this$ = ecx

; 1977 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1978 : 	return m_wstrWeLoveTheKing.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 920				; 00000398H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 1979 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ ENDP		; CvPolicyEntry::GetWeLoveTheKing
_TEXT	ENDS
PUBLIC	?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z	; CvPolicyEntry::SetWeLoveTheKingKey
; Function compile flags: /Odtp
;	COMDAT ?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T233397 = -4						; size = 4
_szVal$ = 8						; size = 4
?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z PROC	; CvPolicyEntry::SetWeLoveTheKingKey, COMDAT
; _this$ = ecx

; 1983 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1984 : 	m_strWeLoveTheKingKey = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 892				; 0000037cH
	mov	DWORD PTR $T233397[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN4@SetWeLoveT
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233397[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@SetWeLoveT
$LN4@SetWeLoveT:
	mov	ecx, DWORD PTR $T233397[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@SetWeLoveT:

; 1985 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetWeLoveTheKingKey@CvPolicyEntry@@QAEXPBD@Z ENDP	; CvPolicyEntry::SetWeLoveTheKingKey
_TEXT	ENDS
PUBLIC	?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetPrereqOrPolicies
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetPrereqOrPolicies, COMDAT
; _this$ = ecx

; 1991 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1992 : 	return m_piPrereqOrPolicies ? m_piPrereqOrPolicies[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+964], 0
	je	SHORT $LN3@GetPrereqO
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+964]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPrereqO
$LN3@GetPrereqO:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPrereqO:
	mov	eax, DWORD PTR tv69[ebp]

; 1993 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetPrereqOrPolicies
_TEXT	ENDS
PUBLIC	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetPrereqAndPolicies
; Function compile flags: /Odtp
;	COMDAT ?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetPrereqAndPolicies, COMDAT
; _this$ = ecx

; 1997 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1998 : 	return m_piPrereqAndPolicies ? m_piPrereqAndPolicies[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+968], 0
	je	SHORT $LN3@GetPrereqA
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+968]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPrereqA
$LN3@GetPrereqA:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPrereqA:
	mov	eax, DWORD PTR tv69[ebp]

; 1999 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetPrereqAndPolicies
_TEXT	ENDS
PUBLIC	?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetPolicyDisables
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetPolicyDisables, COMDAT
; _this$ = ecx

; 2003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2004 : 	return m_piPolicyDisables ? m_piPolicyDisables[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+972], 0
	je	SHORT $LN3@GetPolicyD
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+972]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPolicyD
$LN3@GetPolicyD:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPolicyD:
	mov	eax, DWORD PTR tv69[ebp]

; 2005 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetPolicyDisables
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetYieldModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetYieldModifier@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetYieldModifier, COMDAT
; _this$ = ecx

; 2009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2010 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2011 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2012 : 	return m_piYieldModifier ? m_piYieldModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+976], 0
	je	SHORT $LN3@GetYieldMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+976]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetYieldMo
$LN3@GetYieldMo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetYieldMo:
	mov	eax, DWORD PTR tv69[ebp]

; 2013 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldModifier@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetYieldModifier
_TEXT	ENDS
PUBLIC	?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ	; CvPolicyEntry::GetYieldModifierArray
; Function compile flags: /Odtp
;	COMDAT ?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ PROC	; CvPolicyEntry::GetYieldModifierArray, COMDAT
; _this$ = ecx

; 2017 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2018 : 	return m_piYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+976]

; 2019 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetYieldModifierArray@CvPolicyEntry@@QBEPAHXZ ENDP	; CvPolicyEntry::GetYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetCityYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetCityYieldChange, COMDAT
; _this$ = ecx

; 2023 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2024 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2025 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2026 : 	return m_piCityYieldChange ? m_piCityYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+980], 0
	je	SHORT $LN3@GetCityYie
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+980]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCityYie
$LN3@GetCityYie:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetCityYie:
	mov	eax, DWORD PTR tv69[ebp]

; 2027 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCityYieldChange@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetCityYieldChange
_TEXT	ENDS
PUBLIC	?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCityYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC	; CvPolicyEntry::GetCityYieldChangeArray, COMDAT
; _this$ = ecx

; 2031 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2032 : 	return m_piCityYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+980]

; 2033 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP	; CvPolicyEntry::GetCityYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetCoastalCityYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetCoastalCityYieldChange, COMDAT
; _this$ = ecx

; 2037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2038 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2039 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2040 : 	return m_piCoastalCityYieldChange ? m_piCoastalCityYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+984], 0
	je	SHORT $LN3@GetCoastal
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+984]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCoastal
$LN3@GetCoastal:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetCoastal:
	mov	eax, DWORD PTR tv69[ebp]

; 2041 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCoastalCityYieldChange@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetCoastalCityYieldChange
_TEXT	ENDS
PUBLIC	?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCoastalCityYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCoastalCityYieldChangeArray, COMDAT
; _this$ = ecx

; 2045 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2046 : 	return m_piCoastalCityYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+984]

; 2047 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCoastalCityYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCoastalCityYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetCapitalYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetCapitalYieldChange, COMDAT
; _this$ = ecx

; 2051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2052 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2053 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2054 : 	return m_piCapitalYieldChange ? m_piCapitalYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+988], 0
	je	SHORT $LN3@GetCapital
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+988]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCapital
$LN3@GetCapital:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetCapital:
	mov	eax, DWORD PTR tv69[ebp]

; 2055 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCapitalYieldChange@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetCapitalYieldChange
_TEXT	ENDS
PUBLIC	?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCapitalYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCapitalYieldChangeArray, COMDAT
; _this$ = ecx

; 2059 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2060 : 	return m_piCapitalYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+988]

; 2061 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCapitalYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetCapitalYieldPerPopChange
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetCapitalYieldPerPopChange, COMDAT
; _this$ = ecx

; 2065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2066 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2067 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2068 : 	return m_piCapitalYieldPerPopChange ? m_piCapitalYieldPerPopChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+992], 0
	je	SHORT $LN3@GetCapital@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+992]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCapital@2
$LN3@GetCapital@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetCapital@2:
	mov	eax, DWORD PTR tv69[ebp]

; 2069 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCapitalYieldPerPopChange@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetCapitalYieldPerPopChange
_TEXT	ENDS
PUBLIC	?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCapitalYieldPerPopChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCapitalYieldPerPopChangeArray, COMDAT
; _this$ = ecx

; 2073 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2074 : 	return m_piCapitalYieldPerPopChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+992]

; 2075 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalYieldPerPopChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCapitalYieldPerPopChangeArray
_TEXT	ENDS
PUBLIC	?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetCapitalYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetCapitalYieldModifier, COMDAT
; _this$ = ecx

; 2079 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2080 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2081 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2082 : 	return m_piCapitalYieldModifier ? m_piCapitalYieldModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+996], 0
	je	SHORT $LN3@GetCapital@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+996]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCapital@3
$LN3@GetCapital@3:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetCapital@3:
	mov	eax, DWORD PTR tv69[ebp]

; 2083 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCapitalYieldModifier@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetCapitalYieldModifier
_TEXT	ENDS
PUBLIC	?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetCapitalYieldModifierArray
; Function compile flags: /Odtp
;	COMDAT ?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetCapitalYieldModifierArray, COMDAT
; _this$ = ecx

; 2087 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2088 : 	return m_piCapitalYieldModifier;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+996]

; 2089 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCapitalYieldModifierArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetCapitalYieldModifierArray
_TEXT	ENDS
PUBLIC	?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetGreatWorkYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetGreatWorkYieldChange, COMDAT
; _this$ = ecx

; 2093 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2094 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2095 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2096 : 	return m_piGreatWorkYieldChange ? m_piGreatWorkYieldChange[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1000], 0
	je	SHORT $LN3@GetGreatWo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1000]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetGreatWo
$LN3@GetGreatWo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetGreatWo:
	mov	eax, DWORD PTR tv69[ebp]

; 2097 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetGreatWorkYieldChange@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetGreatWorkYieldChange
_TEXT	ENDS
PUBLIC	?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetGreatWorkYieldChangeArray
; Function compile flags: /Odtp
;	COMDAT ?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetGreatWorkYieldChangeArray, COMDAT
; _this$ = ecx

; 2101 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2102 : 	return m_piGreatWorkYieldChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1000]

; 2103 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGreatWorkYieldChangeArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetGreatWorkYieldChangeArray
_TEXT	ENDS
PUBLIC	?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetSpecialistExtraYield
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetSpecialistExtraYield, COMDAT
; _this$ = ecx

; 2107 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2108 : 	CvAssertMsg(i < NUM_YIELD_TYPES, "Index out of bounds");
; 2109 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2110 : 	return m_piSpecialistExtraYield ? m_piSpecialistExtraYield[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1004], 0
	je	SHORT $LN3@GetSpecial
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1004]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetSpecial
$LN3@GetSpecial:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetSpecial:
	mov	eax, DWORD PTR tv69[ebp]

; 2111 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetSpecialistExtraYield@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetSpecialistExtraYield
_TEXT	ENDS
PUBLIC	?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ ; CvPolicyEntry::GetSpecialistExtraYieldArray
; Function compile flags: /Odtp
;	COMDAT ?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ PROC ; CvPolicyEntry::GetSpecialistExtraYieldArray, COMDAT
; _this$ = ecx

; 2115 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2116 : 	return m_piSpecialistExtraYield;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1004]

; 2117 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpecialistExtraYieldArray@CvPolicyEntry@@QBEPAHXZ ENDP ; CvPolicyEntry::GetSpecialistExtraYieldArray
_TEXT	ENDS
PUBLIC	?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetUnitCombatProductionModifiers
; Function compile flags: /Odtp
;	COMDAT ?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetUnitCombatProductionModifiers, COMDAT
; _this$ = ecx

; 2121 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2122 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 2123 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2124 : 	return m_paiUnitCombatProductionModifiers ? m_paiUnitCombatProductionModifiers[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1016], 0
	je	SHORT $LN3@GetUnitCom
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1016]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetUnitCom
$LN3@GetUnitCom:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetUnitCom:
	mov	eax, DWORD PTR tv69[ebp]

; 2125 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitCombatProductionModifiers@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetUnitCombatProductionModifiers
_TEXT	ENDS
PUBLIC	?IsFreePromotion@CvPolicyEntry@@QBEHH@Z		; CvPolicyEntry::IsFreePromotion
; Function compile flags: /Odtp
;	COMDAT ?IsFreePromotion@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?IsFreePromotion@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::IsFreePromotion, COMDAT
; _this$ = ecx

; 2128 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2129 : 	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1012], 0
	je	SHORT $LN3@IsFreeProm
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1012]
	mov	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [edx+eax]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@IsFreeProm
$LN3@IsFreeProm:
	mov	DWORD PTR tv69[ebp], -1
$LN4@IsFreeProm:
	mov	eax, DWORD PTR tv69[ebp]

; 2130 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsFreePromotion@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::IsFreePromotion
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
PUBLIC	?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z ; CvPolicyEntry::IsFreePromotionUnitCombat
; Function compile flags: /Odtp
;	COMDAT ?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T233580 = -60						; size = 4
$T233529 = -48						; size = 4
$T233468 = -12						; size = 4
_lastElement$224240 = -8				; size = 4
_it$ = -4						; size = 4
_promotionID$ = 8					; size = 4
_unitCombatID$ = 12					; size = 4
?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z PROC ; CvPolicyEntry::IsFreePromotionUnitCombat, COMDAT
; _this$ = ecx

; 2134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 2135 : 	std::multimap<int, int>::const_iterator it = m_FreePromotionUnitCombats.find(promotionID);

	lea	eax, DWORD PTR _promotionID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	call	?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find

; 2136 : 	if(it != m_FreePromotionUnitCombats.end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+956]
	mov	DWORD PTR $T233529[ebp], eax
	mov	ecx, DWORD PTR $T233529[ebp]
	mov	DWORD PTR $T233468[ebp], ecx
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T233468[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@IsFreeProm@2

; 2137 : 	{
; 2138 : 		// get an iterator to the element that is one past the last element associated with key
; 2139 : 		std::multimap<int, int>::const_iterator lastElement = m_FreePromotionUnitCombats.upper_bound(promotionID);

	lea	eax, DWORD PTR _promotionID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	call	?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
	mov	DWORD PTR $T233580[ebp], eax
	mov	ecx, DWORD PTR $T233580[ebp]
	mov	DWORD PTR _lastElement$224240[ebp], ecx

; 2140 : 
; 2141 : 		// for each element in the sequence [itr, lastElement)
; 2142 : 		for(; it != lastElement; ++it)

	jmp	SHORT $LN106@IsFreeProm@2
$LN3@IsFreeProm@2:
	lea	ecx, DWORD PTR _it$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
$LN106@IsFreeProm@2:
	mov	edx, DWORD PTR _it$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR _lastElement$224240[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@IsFreeProm@2

; 2143 : 		{
; 2144 : 			if(it->second == unitCombatID)

	mov	eax, DWORD PTR _it$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _unitCombatID$[ebp]
	jne	SHORT $LN1@IsFreeProm@2

; 2145 : 			{
; 2146 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@IsFreeProm@2
$LN1@IsFreeProm@2:

; 2147 : 			}
; 2148 : 		}

	jmp	SHORT $LN3@IsFreeProm@2
$LN5@IsFreeProm@2:

; 2149 : 	}
; 2150 : 
; 2151 : 	return false;

	xor	al, al
$LN6@IsFreeProm@2:

; 2152 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IsFreePromotionUnitCombat@CvPolicyEntry@@QBE_NHH@Z ENDP ; CvPolicyEntry::IsFreePromotionUnitCombat
_TEXT	ENDS
PUBLIC	?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetUnitCombatFreeExperiences
; Function compile flags: /Odtp
;	COMDAT ?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetUnitCombatFreeExperiences, COMDAT
; _this$ = ecx

; 2156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2157 : 	CvAssertMsg(i < GC.getNumUnitCombatClassInfos(), "Index out of bounds");
; 2158 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2159 : 	return m_paiUnitCombatFreeExperiences ? m_paiUnitCombatFreeExperiences[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1020], 0
	je	SHORT $LN3@GetUnitCom@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1020]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetUnitCom@2
$LN3@GetUnitCom@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetUnitCom@2:
	mov	eax, DWORD PTR tv69[ebp]

; 2160 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetUnitCombatFreeExperiences@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetUnitCombatFreeExperiences
_TEXT	ENDS
PUBLIC	?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassCultureChange
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetBuildingClassCultureChange, COMDAT
; _this$ = ecx

; 2164 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2165 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2166 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2167 : 	return m_paiBuildingClassCultureChanges ? m_paiBuildingClassCultureChanges[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1028], 0
	je	SHORT $LN3@GetBuildin
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1028]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetBuildin
$LN3@GetBuildin:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetBuildin:
	mov	eax, DWORD PTR tv69[ebp]

; 2168 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingClassCultureChange@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetBuildingClassCultureChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassHappiness
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetBuildingClassHappiness, COMDAT
; _this$ = ecx

; 2172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2173 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2174 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2175 : 	return m_paiBuildingClassHappiness ? m_paiBuildingClassHappiness[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1040], 0
	je	SHORT $LN3@GetBuildin@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1040]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetBuildin@2
$LN3@GetBuildin@2:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetBuildin@2:
	mov	eax, DWORD PTR tv69[ebp]

; 2176 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingClassHappiness@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetBuildingClassHappiness
_TEXT	ENDS
PUBLIC	?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetNumFreeUnitsByClass
; Function compile flags: /Odtp
;	COMDAT ?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z PROC	; CvPolicyEntry::GetNumFreeUnitsByClass, COMDAT
; _this$ = ecx

; 2180 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2181 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2182 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2183 : 	return m_paiFreeUnitClasses ? m_paiFreeUnitClasses[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1044], 0
	je	SHORT $LN3@GetNumFree
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1044]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetNumFree
$LN3@GetNumFree:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetNumFree:
	mov	eax, DWORD PTR tv69[ebp]

; 2184 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumFreeUnitsByClass@CvPolicyEntry@@QBEHH@Z ENDP	; CvPolicyEntry::GetNumFreeUnitsByClass
_TEXT	ENDS
PUBLIC	?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetTourismByUnitClassCreated
; Function compile flags: /Odtp
;	COMDAT ?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetTourismByUnitClassCreated, COMDAT
; _this$ = ecx

; 2188 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2189 : 	CvAssertMsg(i < GC.getNumUnitClassInfos(), "Index out of bounds");
; 2190 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2191 : 	return m_paiTourismOnUnitCreation ? m_paiTourismOnUnitCreation[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1048], 0
	je	SHORT $LN3@GetTourism
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1048]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetTourism
$LN3@GetTourism:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetTourism:
	mov	eax, DWORD PTR tv69[ebp]

; 2192 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetTourismByUnitClassCreated
_TEXT	ENDS
PUBLIC	?GetHurryModifier@CvPolicyEntry@@QBEHH@Z	; CvPolicyEntry::GetHurryModifier
; Function compile flags: /Odtp
;	COMDAT ?GetHurryModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetHurryModifier@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetHurryModifier, COMDAT
; _this$ = ecx

; 2204 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2205 : 	CvAssertMsg(i < GC.getNumHurryInfos(), "Index out of bounds");
; 2206 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2207 : 	return m_paiHurryModifier ? m_paiHurryModifier[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1024], 0
	je	SHORT $LN3@GetHurryMo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1024]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetHurryMo
$LN3@GetHurryMo:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetHurryMo:
	mov	eax, DWORD PTR tv69[ebp]

; 2208 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetHurryModifier@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetHurryModifier
_TEXT	ENDS
PUBLIC	?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z	; CvPolicyEntry::IsSpecialistValid
; Function compile flags: /Odtp
;	COMDAT ?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z
_TEXT	SEGMENT
tv68 = -5						; size = 1
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z PROC		; CvPolicyEntry::IsSpecialistValid, COMDAT
; _this$ = ecx

; 2212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2213 : 	CvAssertMsg(i < GC.getNumSpecialistInfos(), "Index out of bounds");
; 2214 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2215 : 	return m_pabSpecialistValid ? m_pabSpecialistValid[i] : false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1052], 0
	je	SHORT $LN3@IsSpeciali
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1052]
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [edx+eax]
	mov	BYTE PTR tv68[ebp], cl
	jmp	SHORT $LN4@IsSpeciali
$LN3@IsSpeciali:
	mov	BYTE PTR tv68[ebp], 0
$LN4@IsSpeciali:
	mov	al, BYTE PTR tv68[ebp]

; 2216 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsSpecialistValid@CvPolicyEntry@@QBE_NH@Z ENDP		; CvPolicyEntry::IsSpecialistValid
_TEXT	ENDS
PUBLIC	?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetImprovementYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z PROC ; CvPolicyEntry::GetImprovementYieldChanges, COMDAT
; _this$ = ecx

; 2220 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2221 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2222 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2223 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2224 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2225 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2226 : 	return m_ppiImprovementYieldChanges.first ? m_ppiImprovementYieldChanges.first[i][j] : 0;
; 2227 : #else
; 2228 : 	return m_ppiImprovementYieldChanges[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1056]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2229 : #endif
; 2230 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetImprovementYieldChanges@CvPolicyEntry@@QBEHHH@Z ENDP ; CvPolicyEntry::GetImprovementYieldChanges
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetBuildingClassYieldModifiers
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z PROC ; CvPolicyEntry::GetBuildingClassYieldModifiers, COMDAT
; _this$ = ecx

; 2234 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2235 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2236 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2237 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2238 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2239 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2240 : 	return m_ppiBuildingClassYieldModifiers.first ? m_ppiBuildingClassYieldModifiers.first[i][j] : 0;
; 2241 : #else
; 2242 : 	return m_ppiBuildingClassYieldModifiers[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1060]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2243 : #endif
; 2244 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z ENDP ; CvPolicyEntry::GetBuildingClassYieldModifiers
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetBuildingClassYieldChanges
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z PROC ; CvPolicyEntry::GetBuildingClassYieldChanges, COMDAT
; _this$ = ecx

; 2248 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2249 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2250 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2251 : 	CvAssertMsg(j < NUM_YIELD_TYPES, "Index out of bounds");
; 2252 : 	CvAssertMsg(j > -1, "Index out of bounds");
; 2253 : #ifdef AUI_DATABASE_UTILITY_PROPER_2D_ALLOCATION_AND_DESTRUCTION
; 2254 : 	return m_ppiBuildingClassYieldChanges.first ? m_ppiBuildingClassYieldChanges.first[i][j] : 0;
; 2255 : #else
; 2256 : 	return m_ppiBuildingClassYieldChanges[i][j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1064]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2257 : #endif
; 2258 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z ENDP ; CvPolicyEntry::GetBuildingClassYieldChanges
_TEXT	ENDS
PUBLIC	?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetBuildingClassProductionModifier, COMDAT
; _this$ = ecx

; 2273 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2274 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2275 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2276 : 	return m_paiBuildingClassProductionModifiers[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1032]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2277 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetBuildingClassProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetBuildingClassTourismModifier, COMDAT
; _this$ = ecx

; 2281 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2282 : 	CvAssertMsg(i < GC.getNumBuildingClassInfos(), "Index out of bounds");
; 2283 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2284 : 	return m_paiBuildingClassTourismModifiers[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1036]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2285 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetBuildingClassTourismModifier
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvPolicyEntry@@QBEHH@Z		; CvPolicyEntry::GetFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetFlavorValue@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetFlavorValue@CvPolicyEntry@@QBEHH@Z PROC		; CvPolicyEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 2289 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2290 : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 2291 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2292 : 	return m_piFlavorValue ? m_piFlavorValue[i] : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1068], 0
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1068]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetFlavorV
$LN3@GetFlavorV:
	mov	DWORD PTR tv69[ebp], 0
$LN4@GetFlavorV:
	mov	eax, DWORD PTR tv69[ebp]

; 2293 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFlavorValue@CvPolicyEntry@@QBEHH@Z ENDP		; CvPolicyEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetImprovementCultureChanges
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z PROC ; CvPolicyEntry::GetImprovementCultureChanges, COMDAT
; _this$ = ecx

; 2297 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2298 : 	CvAssertMsg(i < GC.getNumImprovementInfos(), "Index out of bounds");
; 2299 : 	CvAssertMsg(i > -1, "Index out of bounds");
; 2300 : 	return m_piImprovementCultureChange[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1008]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2301 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z ENDP ; CvPolicyEntry::GetImprovementCultureChanges
_TEXT	ENDS
PUBLIC	?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ ; CvPolicyEntry::GetFreeBuildingOnConquest
; Function compile flags: /Odtp
;	COMDAT ?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ PROC ; CvPolicyEntry::GetFreeBuildingOnConquest, COMDAT
; _this$ = ecx

; 2305 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2306 : 	return m_eFreeBuildingOnConquest;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+948]

; 2307 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ ENDP ; CvPolicyEntry::GetFreeBuildingOnConquest
_TEXT	ENDS
PUBLIC	??_7CvPolicyBranchEntry@@6B@			; CvPolicyBranchEntry::`vftable'
PUBLIC	??0CvPolicyBranchEntry@@QAE@XZ			; CvPolicyBranchEntry::CvPolicyBranchEntry
PUBLIC	?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPolicyBranchEntry::CacheResults
;	COMDAT ??_7CvPolicyBranchEntry@@6B@
CONST	SEGMENT
??_7CvPolicyBranchEntry@@6B@ DD FLAT:?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvPolicyBranchEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvPolicyBranchEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvPolicyBranchEntry@@QAE@XZ PROC			; CvPolicyBranchEntry::CvPolicyBranchEntry, COMDAT
; _this$ = ecx

; 2321 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPolicyBranchEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+288], 0

; 2322 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvPolicyBranchEntry@@QAE@XZ ENDP			; CvPolicyBranchEntry::CvPolicyBranchEntry
_TEXT	ENDS
PUBLIC	??1CvPolicyBranchEntry@@QAE@XZ			; CvPolicyBranchEntry::~CvPolicyBranchEntry
; Function compile flags: /Odtp
;	COMDAT ??1CvPolicyBranchEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T233713 = -8						; size = 4
$T233711 = -4						; size = 4
??1CvPolicyBranchEntry@@QAE@XZ PROC			; CvPolicyBranchEntry::~CvPolicyBranchEntry, COMDAT
; _this$ = ecx

; 2326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPolicyBranchEntry@@6B@

; 2327 : 	SAFE_DELETE_ARRAY(m_piPolicyBranchDisables);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	mov	DWORD PTR $T233713[ebp], ecx
	mov	edx, DWORD PTR $T233713[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T233711[ebp], eax
	mov	ecx, DWORD PTR $T233711[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T233713[ebp]
	mov	DWORD PTR [edx], 0

; 2328 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvPolicyBranchEntry@@QAE@XZ ENDP			; CvPolicyBranchEntry::~CvPolicyBranchEntry
_TEXT	ENDS
PUBLIC	??_C@_0JP@ENEFJOMD@select?5PolicyBranchTypes?4ID?5from@ ; `string'
PUBLIC	??_C@_0BJ@JPLILCDC@m_piPolicyBranchDisables?$AA@ ; `string'
PUBLIC	??_C@_0BC@KKBMLBIO@PolicyBranchTypes?$AA@	; `string'
PUBLIC	??_C@_0BB@GAEIJPAA@AIDelayNoScience?$AA@	; `string'
PUBLIC	??_C@_0BE@MNCFMOBD@AIDelayNoCityStates?$AA@	; `string'
PUBLIC	??_C@_0BB@IPEMDBIH@AIDelayNoCulture?$AA@	; `string'
PUBLIC	??_C@_0BC@GAMKPLGN@AIDelayNoReligion?$AA@	; `string'
PUBLIC	??_C@_0BE@DDDNNBBL@AIMutuallyExclusive?$AA@	; `string'
PUBLIC	??_C@_0BG@OLAJEDHI@LockedWithoutReligion?$AA@	; `string'
PUBLIC	??_C@_0BA@BAHAMAIN@PurchaseByLevel?$AA@		; `string'
PUBLIC	??_C@_0BK@EPHHDJGP@SecondAdopterFreePolicies?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JBEDFHAP@FirstAdopterFreePolicies?$AA@ ; `string'
PUBLIC	??_C@_0BE@OADLBCKC@FreeFinishingPolicy?$AA@	; `string'
PUBLIC	??_C@_0L@KCDBGDBF@FreePolicy?$AA@		; `string'
PUBLIC	??_C@_09CLBBIEDA@EraPrereq?$AA@			; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0JP@ENEFJOMD@select?5PolicyBranchTypes?4ID?5from@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
CONST	SEGMENT
??_C@_0JP@ENEFJOMD@select?5PolicyBranchTypes?4ID?5from@ DB 'select Policy'
	DB	'BranchTypes.ID from PolicyBranch_Disables inner join PolicyBr'
	DB	'anchTypes on PolicyBranchTypes.Type = PolicyBranchDisable whe'
	DB	're PolicyBranchType = ?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JPLILCDC@m_piPolicyBranchDisables?$AA@
CONST	SEGMENT
??_C@_0BJ@JPLILCDC@m_piPolicyBranchDisables?$AA@ DB 'm_piPolicyBranchDisa'
	DB	'bles', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KKBMLBIO@PolicyBranchTypes?$AA@
CONST	SEGMENT
??_C@_0BC@KKBMLBIO@PolicyBranchTypes?$AA@ DB 'PolicyBranchTypes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GAEIJPAA@AIDelayNoScience?$AA@
CONST	SEGMENT
??_C@_0BB@GAEIJPAA@AIDelayNoScience?$AA@ DB 'AIDelayNoScience', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNCFMOBD@AIDelayNoCityStates?$AA@
CONST	SEGMENT
??_C@_0BE@MNCFMOBD@AIDelayNoCityStates?$AA@ DB 'AIDelayNoCityStates', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPEMDBIH@AIDelayNoCulture?$AA@
CONST	SEGMENT
??_C@_0BB@IPEMDBIH@AIDelayNoCulture?$AA@ DB 'AIDelayNoCulture', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GAMKPLGN@AIDelayNoReligion?$AA@
CONST	SEGMENT
??_C@_0BC@GAMKPLGN@AIDelayNoReligion?$AA@ DB 'AIDelayNoReligion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DDDNNBBL@AIMutuallyExclusive?$AA@
CONST	SEGMENT
??_C@_0BE@DDDNNBBL@AIMutuallyExclusive?$AA@ DB 'AIMutuallyExclusive', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OLAJEDHI@LockedWithoutReligion?$AA@
CONST	SEGMENT
??_C@_0BG@OLAJEDHI@LockedWithoutReligion?$AA@ DB 'LockedWithoutReligion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BAHAMAIN@PurchaseByLevel?$AA@
CONST	SEGMENT
??_C@_0BA@BAHAMAIN@PurchaseByLevel?$AA@ DB 'PurchaseByLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EPHHDJGP@SecondAdopterFreePolicies?$AA@
CONST	SEGMENT
??_C@_0BK@EPHHDJGP@SecondAdopterFreePolicies?$AA@ DB 'SecondAdopterFreePo'
	DB	'licies', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JBEDFHAP@FirstAdopterFreePolicies?$AA@
CONST	SEGMENT
??_C@_0BJ@JBEDFHAP@FirstAdopterFreePolicies?$AA@ DB 'FirstAdopterFreePoli'
	DB	'cies', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OADLBCKC@FreeFinishingPolicy?$AA@
CONST	SEGMENT
??_C@_0BE@OADLBCKC@FreeFinishingPolicy?$AA@ DB 'FreeFinishingPolicy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KCDBGDBF@FreePolicy?$AA@
CONST	SEGMENT
??_C@_0L@KCDBGDBF@FreePolicy?$AA@ DB 'FreePolicy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CLBBIEDA@EraPrereq?$AA@
CONST	SEGMENT
??_C@_09CLBBIEDA@EraPrereq?$AA@ DB 'EraPrereq', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
_count$233781 = -76					; size = 4
_szSQL$224344 = -72					; size = 4
_pResults$224342 = -68					; size = 4
_sqlKey$224340 = -64					; size = 28
__$ArrayPad$ = -36					; size = 4
_iID$224346 = -32					; size = 4
_szFreePolicy$ = -28					; size = 4
_szEraPrereq$ = -24					; size = 4
_szPolicyBranchType$ = -20				; size = 4
_szFreeFinishingPolicy$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvPolicyBranchEntry::CacheResults, COMDAT
; _this$ = ecx

; 2332 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2333 : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@CacheResul@2

; 2334 : 		return false;

	xor	al, al
	jmp	$LN5@CacheResul@2
$LN4@CacheResul@2:

; 2335 : 
; 2336 : 	//References
; 2337 : 	const char* szEraPrereq = kResults.GetText("EraPrereq");

	push	OFFSET ??_C@_09CLBBIEDA@EraPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szEraPrereq$[ebp], eax

; 2338 : 	m_iEraPrereq = GC.getInfoTypeForString(szEraPrereq, true);

	push	1
	mov	eax, DWORD PTR _szEraPrereq$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], eax

; 2339 : 
; 2340 : 	const char* szFreePolicy = kResults.GetText("FreePolicy");

	push	OFFSET ??_C@_0L@KCDBGDBF@FreePolicy?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szFreePolicy$[ebp], eax

; 2341 : 	m_iFreePolicy = GC.getInfoTypeForString(szFreePolicy, true);

	push	1
	mov	edx, DWORD PTR _szFreePolicy$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 2342 : 
; 2343 : 	const char* szFreeFinishingPolicy = kResults.GetText("FreeFinishingPolicy");

	push	OFFSET ??_C@_0BE@OADLBCKC@FreeFinishingPolicy?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szFreeFinishingPolicy$[ebp], eax

; 2344 : 	m_iFreeFinishingPolicy = GC.getInfoTypeForString(szFreeFinishingPolicy, true);

	push	1
	mov	edx, DWORD PTR _szFreeFinishingPolicy$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 2345 : 
; 2346 : 	m_iFirstAdopterFreePolicies = kResults.GetInt("FirstAdopterFreePolicies");

	push	OFFSET ??_C@_0BJ@JBEDFHAP@FirstAdopterFreePolicies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 2347 : 	m_iSecondAdopterFreePolicies = kResults.GetInt("SecondAdopterFreePolicies");

	push	OFFSET ??_C@_0BK@EPHHDJGP@SecondAdopterFreePolicies?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+276], eax

; 2348 : 
; 2349 : 	const char* szPolicyBranchType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szPolicyBranchType$[ebp], eax

; 2350 : 
; 2351 : 	m_bPurchaseByLevel = kResults.GetBool("PurchaseByLevel");

	push	OFFSET ??_C@_0BA@BAHAMAIN@PurchaseByLevel?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+280], al

; 2352 : 	m_bLockedWithoutReligion = kResults.GetBool("LockedWithoutReligion");

	push	OFFSET ??_C@_0BG@OLAJEDHI@LockedWithoutReligion?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+281], al

; 2353 : 	m_bMutuallyExclusive = kResults.GetBool("AIMutuallyExclusive");

	push	OFFSET ??_C@_0BE@DDDNNBBL@AIMutuallyExclusive?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+282], al

; 2354 : 
; 2355 : 	m_bDelayWhenNoReligion = kResults.GetBool("AIDelayNoReligion");

	push	OFFSET ??_C@_0BC@GAMKPLGN@AIDelayNoReligion?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+283], al

; 2356 : 	m_bDelayWhenNoCulture = kResults.GetBool("AIDelayNoCulture");

	push	OFFSET ??_C@_0BB@IPEMDBIH@AIDelayNoCulture?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+284], al

; 2357 : 	m_bDelayWhenNoCityStates = kResults.GetBool("AIDelayNoCityStates");

	push	OFFSET ??_C@_0BE@MNCFMOBD@AIDelayNoCityStates?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+285], al

; 2358 : 	m_bDelayWhenNoScience = kResults.GetBool("AIDelayNoScience");

	push	OFFSET ??_C@_0BB@GAEIJPAA@AIDelayNoScience?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+286], al

; 2359 : 
; 2360 : 	//PolicyBranch_Disables
; 2361 : 	{
; 2362 : 		kUtility.InitializeArray(m_piPolicyBranchDisables, "PolicyBranchTypes", (int)NO_POLICY_BRANCH_TYPE);

	push	OFFSET ??_C@_0BC@KKBMLBIO@PolicyBranchTypes?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _count$233781[ebp], eax
	cmp	DWORD PTR _count$233781[ebp], 0
	jne	SHORT $LN10@CacheResul@2
	mov	DWORD PTR _count$233781[ebp], 1
$LN10@CacheResul@2:
	push	-1
	mov	eax, DWORD PTR _count$233781[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 2363 : 
; 2364 : 		std::string sqlKey = "m_piPolicyBranchDisables";

	push	OFFSET ??_C@_0BJ@JPLILCDC@m_piPolicyBranchDisables?$AA@
	lea	ecx, DWORD PTR _sqlKey$224340[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2365 : 		Database::Results* pResults = kUtility.GetResults(sqlKey);

	lea	edx, DWORD PTR _sqlKey$224340[ebp]
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	DWORD PTR _pResults$224342[ebp], eax

; 2366 : 		if(pResults == NULL)

	cmp	DWORD PTR _pResults$224342[ebp], 0
	jne	SHORT $LN3@CacheResul@2

; 2367 : 		{
; 2368 : 			const char* szSQL = "select PolicyBranchTypes.ID from PolicyBranch_Disables inner join PolicyBranchTypes on PolicyBranchTypes.Type = PolicyBranchDisable where PolicyBranchType = ?";

	mov	DWORD PTR _szSQL$224344[ebp], OFFSET ??_C@_0JP@ENEFJOMD@select?5PolicyBranchTypes?4ID?5from@

; 2369 : 			pResults = kUtility.PrepareResults(sqlKey, szSQL);

	mov	eax, DWORD PTR _szSQL$224344[ebp]
	push	eax
	lea	ecx, DWORD PTR _sqlKey$224340[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	DWORD PTR _pResults$224342[ebp], eax
$LN3@CacheResul@2:

; 2370 : 		}
; 2371 : 
; 2372 : 		pResults->Bind(1, szPolicyBranchType, false);

	push	0
	mov	edx, DWORD PTR _szPolicyBranchType$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _pResults$224342[ebp]
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBD_N@Z
$LN2@CacheResul@2:

; 2373 : 
; 2374 : 		int iID;
; 2375 : 		while(pResults->Step())

	mov	ecx, DWORD PTR _pResults$224342[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@CacheResul@2

; 2376 : 		{
; 2377 : 			iID = pResults->GetInt(0);

	push	0
	mov	ecx, DWORD PTR _pResults$224342[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	DWORD PTR _iID$224346[ebp], eax

; 2378 : 			m_piPolicyBranchDisables[iID] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	eax, DWORD PTR _iID$224346[ebp]
	mov	DWORD PTR [edx+eax*4], 1

; 2379 : 		}

	jmp	SHORT $LN2@CacheResul@2
$LN1@CacheResul@2:

; 2380 : 
; 2381 : 		pResults->Reset();

	mov	ecx, DWORD PTR _pResults$224342[ebp]
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 2382 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sqlKey$224340[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2383 : 
; 2384 : 	return true;

	mov	al, 1
$LN5@CacheResul@2:

; 2385 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _sqlKey$224340[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvPolicyBranchEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvPolicyBranchEntry::CacheResults
PUBLIC	?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ	; CvPolicyBranchEntry::GetEraPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ PROC		; CvPolicyBranchEntry::GetEraPrereq, COMDAT
; _this$ = ecx

; 2389 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2390 : 	return m_iEraPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+260]

; 2391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ ENDP		; CvPolicyBranchEntry::GetEraPrereq
_TEXT	ENDS
PUBLIC	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ	; CvPolicyBranchEntry::GetFreePolicy
; Function compile flags: /Odtp
;	COMDAT ?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ PROC		; CvPolicyBranchEntry::GetFreePolicy, COMDAT
; _this$ = ecx

; 2395 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2396 : 	return m_iFreePolicy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+264]

; 2397 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ENDP		; CvPolicyBranchEntry::GetFreePolicy
_TEXT	ENDS
PUBLIC	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreeFinishingPolicy
; Function compile flags: /Odtp
;	COMDAT ?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ PROC ; CvPolicyBranchEntry::GetFreeFinishingPolicy, COMDAT
; _this$ = ecx

; 2401 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2402 : 	return m_iFreeFinishingPolicy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 2403 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ENDP ; CvPolicyBranchEntry::GetFreeFinishingPolicy
_TEXT	ENDS
PUBLIC	?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFirstAdopterFreePolicies
; Function compile flags: /Odtp
;	COMDAT ?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ PROC ; CvPolicyBranchEntry::GetFirstAdopterFreePolicies, COMDAT
; _this$ = ecx

; 2407 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2408 : 	return m_iFirstAdopterFreePolicies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 2409 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ENDP ; CvPolicyBranchEntry::GetFirstAdopterFreePolicies
_TEXT	ENDS
PUBLIC	?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetSecondAdopterFreePolicies
; Function compile flags: /Odtp
;	COMDAT ?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ PROC ; CvPolicyBranchEntry::GetSecondAdopterFreePolicies, COMDAT
; _this$ = ecx

; 2413 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2414 : 	return m_iSecondAdopterFreePolicies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 2415 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ENDP ; CvPolicyBranchEntry::GetSecondAdopterFreePolicies
_TEXT	ENDS
PUBLIC	?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z ; CvPolicyBranchEntry::GetPolicyBranchDisables
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z PROC ; CvPolicyBranchEntry::GetPolicyBranchDisables, COMDAT
; _this$ = ecx

; 2419 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2420 : 	return m_piPolicyBranchDisables ? m_piPolicyBranchDisables[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+288], 0
	je	SHORT $LN3@GetPolicyB
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+288]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPolicyB
$LN3@GetPolicyB:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPolicyB:
	mov	eax, DWORD PTR tv69[ebp]

; 2421 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z ENDP ; CvPolicyBranchEntry::GetPolicyBranchDisables
_TEXT	ENDS
PUBLIC	?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ	; CvPolicyBranchEntry::IsPurchaseByLevel
; Function compile flags: /Odtp
;	COMDAT ?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsPurchaseByLevel, COMDAT
; _this$ = ecx

; 2425 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2426 : 	return m_bPurchaseByLevel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+280]

; 2427 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsPurchaseByLevel
_TEXT	ENDS
PUBLIC	?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsLockedWithoutReligion
; Function compile flags: /Odtp
;	COMDAT ?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ PROC ; CvPolicyBranchEntry::IsLockedWithoutReligion, COMDAT
; _this$ = ecx

; 2431 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2432 : 	return m_bLockedWithoutReligion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+281]

; 2433 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ ENDP ; CvPolicyBranchEntry::IsLockedWithoutReligion
_TEXT	ENDS
PUBLIC	?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsMutuallyExclusive
; Function compile flags: /Odtp
;	COMDAT ?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsMutuallyExclusive, COMDAT
; _this$ = ecx

; 2437 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2438 : 	return m_bMutuallyExclusive;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+282]

; 2439 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMutuallyExclusive@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsMutuallyExclusive
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoReligion
; Function compile flags: /Odtp
;	COMDAT ?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ PROC ; CvPolicyBranchEntry::IsDelayWhenNoReligion, COMDAT
; _this$ = ecx

; 2443 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2444 : 	return m_bDelayWhenNoReligion;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+283]

; 2445 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDelayWhenNoReligion@CvPolicyBranchEntry@@QBE_NXZ ENDP ; CvPolicyBranchEntry::IsDelayWhenNoReligion
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCulture
; Function compile flags: /Odtp
;	COMDAT ?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsDelayWhenNoCulture, COMDAT
; _this$ = ecx

; 2449 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2450 : 	return m_bDelayWhenNoCulture;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+284]

; 2451 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDelayWhenNoCulture@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsDelayWhenNoCulture
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
; Function compile flags: /Odtp
;	COMDAT ?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ PROC ; CvPolicyBranchEntry::IsDelayWhenNoCityStates, COMDAT
; _this$ = ecx

; 2455 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2456 : 	return m_bDelayWhenNoCityStates;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+285]

; 2457 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDelayWhenNoCityStates@CvPolicyBranchEntry@@QBE_NXZ ENDP ; CvPolicyBranchEntry::IsDelayWhenNoCityStates
_TEXT	ENDS
PUBLIC	?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsDelayWhenNoScience
; Function compile flags: /Odtp
;	COMDAT ?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ PROC	; CvPolicyBranchEntry::IsDelayWhenNoScience, COMDAT
; _this$ = ecx

; 2461 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2462 : 	return m_bDelayWhenNoScience;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+286]

; 2463 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsDelayWhenNoScience@CvPolicyBranchEntry@@QBE_NXZ ENDP	; CvPolicyBranchEntry::IsDelayWhenNoScience
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
PUBLIC	??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
PUBLIC	??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Buy
PUBLIC	?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Buy
PUBLIC	??0CvPolicyXMLEntries@@QAE@XZ			; CvPolicyXMLEntries::CvPolicyXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvPolicyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$6
__ehfuncinfo$??0CvPolicyXMLEntries@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CvPolicyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvPolicyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv184 = -252						; size = 4
tv240 = -248						; size = 4
tv131 = -244						; size = 4
tv156 = -240						; size = 4
_this$ = -236						; size = 4
$T233979 = -232						; size = 4
$T233930 = -138						; size = 1
$T233917 = -137						; size = 1
$T233913 = -136						; size = 4
$T233906 = -128						; size = 4
$T233851 = -30						; size = 1
$T233838 = -29						; size = 1
$T233834 = -28						; size = 4
$T233827 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPolicyXMLEntries@@QAE@XZ PROC			; CvPolicyXMLEntries::CvPolicyXMLEntries, COMDAT
; _this$ = ecx

; 2470 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvPolicyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T233851[ebp]
	mov	DWORD PTR $T233827[ebp], eax
	lea	ecx, DWORD PTR $T233838[ebp]
	mov	DWORD PTR $T233834[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv156[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv131[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T233979[ebp], ecx
	lea	edx, DWORD PTR $T233930[ebp]
	mov	DWORD PTR $T233906[ebp], edx
	lea	eax, DWORD PTR $T233917[ebp]
	mov	DWORD PTR $T233913[ebp], eax
	mov	ecx, DWORD PTR $T233979[ebp]
	mov	DWORD PTR tv240[ebp], ecx
	mov	edx, DWORD PTR $T233979[ebp]
	mov	DWORD PTR tv184[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	0
	mov	ecx, DWORD PTR $T233979[ebp]
	call	?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2471 : 
; 2472 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
__unwindfunclet$??0CvPolicyXMLEntries@@QAE@XZ$6:
	mov	ecx, DWORD PTR $T233979[ebp]
	jmp	??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvPolicyXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-244]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvPolicyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPolicyXMLEntries@@QAE@XZ ENDP			; CvPolicyXMLEntries::CvPolicyXMLEntries
PUBLIC	??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy
PUBLIC	?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy
PUBLIC	?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ ; CvPolicyXMLEntries::DeletePolicyBranchesArray
PUBLIC	?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ	; CvPolicyXMLEntries::DeletePoliciesArray
PUBLIC	??1CvPolicyXMLEntries@@QAE@XZ			; CvPolicyXMLEntries::~CvPolicyXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvPolicyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$4
__ehfuncinfo$??1CvPolicyXMLEntries@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvPolicyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvPolicyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T234045 = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPolicyXMLEntries@@QAE@XZ PROC			; CvPolicyXMLEntries::~CvPolicyXMLEntries, COMDAT
; _this$ = ecx

; 2476 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvPolicyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2477 : 	DeletePoliciesArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ ; CvPolicyXMLEntries::DeletePoliciesArray

; 2478 : 	DeletePolicyBranchesArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ ; CvPolicyXMLEntries::DeletePolicyBranchesArray

; 2479 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T234045[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T234045[ebp]
	call	?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$2:
	mov	ecx, DWORD PTR $T234045[ebp]
	jmp	??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
__unwindfunclet$??1CvPolicyXMLEntries@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvPolicyXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvPolicyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPolicyXMLEntries@@QAE@XZ ENDP			; CvPolicyXMLEntries::~CvPolicyXMLEntries
PUBLIC	?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyEntries
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ PROC ; CvPolicyXMLEntries::GetPolicyEntries, COMDAT
; _this$ = ecx

; 2483 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2484 : 	return m_paPolicyEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 2485 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicyEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@XZ ENDP ; CvPolicyXMLEntries::GetPolicyEntries
_TEXT	ENDS
PUBLIC	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ	; CvPolicyXMLEntries::GetNumPolicies
; Function compile flags: /Odtp
;	COMDAT ?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ PROC		; CvPolicyXMLEntries::GetNumPolicies, COMDAT
; _this$ = ecx

; 2493 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2494 : 	return m_paPolicyEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 2495 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ENDP		; CvPolicyXMLEntries::GetNumPolicies
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::erase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv143 = -116						; size = 4
_this$ = -112						; size = 4
$T234223 = -56						; size = 4
$T234207 = -52						; size = 4
$T234328 = -48						; size = 4
$T234327 = -44						; size = 4
$T234326 = -40						; size = 4
$T234325 = -36						; size = 4
$T234324 = -32						; size = 4
$T234191 = -28						; size = 4
$T234185 = -24						; size = 4
$T234184 = -20						; size = 4
$T234150 = -16						; size = 4
$T234126 = -12						; size = 4
$T234116 = -8						; size = 4
_it$224562 = -4						; size = 4
?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ PROC	; CvPolicyXMLEntries::DeletePoliciesArray, COMDAT
; _this$ = ecx

; 2499 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 2500 : 	for(std::vector<CvPolicyEntry*>::iterator it = m_paPolicyEntries.begin(); it != m_paPolicyEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234126[ebp], ecx
	mov	edx, DWORD PTR $T234126[ebp]
	mov	DWORD PTR _it$224562[ebp], edx
	jmp	SHORT $LN3@DeletePoli
$LN2@DeletePoli:
	mov	eax, DWORD PTR _it$224562[ebp]
	add	eax, 4
	mov	DWORD PTR _it$224562[ebp], eax
$LN3@DeletePoli:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T234150[ebp], edx
	mov	eax, DWORD PTR $T234150[ebp]
	mov	DWORD PTR $T234116[ebp], eax
	mov	ecx, DWORD PTR _it$224562[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T234116[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeletePoli

; 2501 : 	{
; 2502 : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$224562[ebp]
	mov	DWORD PTR $T234191[ebp], edx
	mov	eax, DWORD PTR $T234191[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234185[ebp], ecx
	mov	edx, DWORD PTR $T234185[ebp]
	mov	DWORD PTR $T234184[ebp], edx
	cmp	DWORD PTR $T234184[ebp], 0
	je	SHORT $LN32@DeletePoli
	mov	ecx, DWORD PTR $T234184[ebp]
	call	??1CvPolicyEntry@@QAE@XZ		; CvPolicyEntry::~CvPolicyEntry
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN35@DeletePoli
	mov	ecx, DWORD PTR $T234184[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@DeletePoli:
	mov	edx, DWORD PTR $T234184[ebp]
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN33@DeletePoli
$LN32@DeletePoli:
	mov	DWORD PTR tv143[ebp], 0
$LN33@DeletePoli:
	mov	eax, DWORD PTR $T234191[ebp]
	mov	DWORD PTR [eax], 0

; 2503 : 	}

	jmp	$LN2@DeletePoli
$LN1@DeletePoli:

; 2504 : 
; 2505 : 	m_paPolicyEntries.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T234207[ebp], edx
	mov	eax, DWORD PTR $T234207[ebp]
	mov	DWORD PTR $T234325[ebp], eax
	mov	ecx, DWORD PTR $T234325[ebp]
	mov	DWORD PTR $T234324[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T234223[ebp], eax
	mov	ecx, DWORD PTR $T234223[ebp]
	mov	DWORD PTR $T234327[ebp], ecx
	mov	edx, DWORD PTR $T234327[ebp]
	mov	DWORD PTR $T234326[ebp], edx
	mov	eax, DWORD PTR $T234324[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234326[ebp]
	push	ecx
	lea	edx, DWORD PTR $T234328[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::erase

; 2506 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeletePoliciesArray@CvPolicyXMLEntries@@QAEXXZ ENDP	; CvPolicyXMLEntries::DeletePoliciesArray
_TEXT	ENDS
PUBLIC	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z PROC ; CvPolicyXMLEntries::GetPolicyEntry, COMDAT
; _this$ = ecx

; 2514 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2515 : 	return m_paPolicyEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2516 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ENDP ; CvPolicyXMLEntries::GetPolicyEntry
_TEXT	ENDS
PUBLIC	?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ; CvPolicyXMLEntries::GetPolicyBranchEntries
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ PROC ; CvPolicyXMLEntries::GetPolicyBranchEntries, COMDAT
; _this$ = ecx

; 2520 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2521 : 	return m_paPolicyBranchEntries;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H

; 2522 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicyBranchEntries@CvPolicyXMLEntries@@QAEAAV?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@XZ ENDP ; CvPolicyXMLEntries::GetPolicyBranchEntries
_TEXT	ENDS
PUBLIC	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
; Function compile flags: /Odtp
;	COMDAT ?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T234353 = -4						; size = 4
?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ PROC	; CvPolicyXMLEntries::GetNumPolicyBranches, COMDAT
; _this$ = ecx

; 2530 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2531 : 	return m_paPolicyBranchEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR $T234353[ebp], eax
	mov	ecx, DWORD PTR $T234353[ebp]
	mov	edx, DWORD PTR $T234353[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2

; 2532 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ENDP	; CvPolicyXMLEntries::GetNumPolicyBranches
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv146 = -120						; size = 4
_this$ = -116						; size = 4
$T234581 = -112						; size = 4
$T234463 = -56						; size = 4
$T234447 = -52						; size = 4
$T234568 = -48						; size = 4
$T234567 = -44						; size = 4
$T234566 = -40						; size = 4
$T234565 = -36						; size = 4
$T234564 = -32						; size = 4
$T234431 = -28						; size = 4
$T234425 = -24						; size = 4
$T234424 = -20						; size = 4
$T234390 = -16						; size = 4
$T234366 = -12						; size = 4
$T234356 = -8						; size = 4
_it$224740 = -4						; size = 4
?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ PROC ; CvPolicyXMLEntries::DeletePolicyBranchesArray, COMDAT
; _this$ = ecx

; 2536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 2537 : 	for(std::vector<CvPolicyBranchEntry*>::iterator it = m_paPolicyBranchEntries.begin(); it != m_paPolicyBranchEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T234366[ebp], ecx
	mov	edx, DWORD PTR $T234366[ebp]
	mov	DWORD PTR _it$224740[ebp], edx
	jmp	SHORT $LN3@DeletePoli@2
$LN2@DeletePoli@2:
	mov	eax, DWORD PTR _it$224740[ebp]
	add	eax, 4
	mov	DWORD PTR _it$224740[ebp], eax
$LN3@DeletePoli@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR $T234390[ebp], edx
	mov	eax, DWORD PTR $T234390[ebp]
	mov	DWORD PTR $T234356[ebp], eax
	mov	ecx, DWORD PTR _it$224740[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T234356[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeletePoli@2

; 2538 : 	{
; 2539 : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$224740[ebp]
	mov	DWORD PTR $T234431[ebp], edx
	mov	eax, DWORD PTR $T234431[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234425[ebp], ecx
	mov	edx, DWORD PTR $T234425[ebp]
	mov	DWORD PTR $T234424[ebp], edx
	cmp	DWORD PTR $T234424[ebp], 0
	je	SHORT $LN32@DeletePoli@2
	mov	ecx, DWORD PTR $T234424[ebp]
	call	??1CvPolicyBranchEntry@@QAE@XZ		; CvPolicyBranchEntry::~CvPolicyBranchEntry
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN35@DeletePoli@2
	mov	ecx, DWORD PTR $T234424[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@DeletePoli@2:
	mov	edx, DWORD PTR $T234424[ebp]
	mov	DWORD PTR tv146[ebp], edx
	jmp	SHORT $LN33@DeletePoli@2
$LN32@DeletePoli@2:
	mov	DWORD PTR tv146[ebp], 0
$LN33@DeletePoli@2:
	mov	eax, DWORD PTR $T234431[ebp]
	mov	DWORD PTR [eax], 0

; 2540 : 	}

	jmp	$LN2@DeletePoli@2
$LN1@DeletePoli@2:

; 2541 : 
; 2542 : 	m_paPolicyBranchEntries.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR $T234581[ebp], ecx
	mov	edx, DWORD PTR $T234581[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T234447[ebp], eax
	mov	ecx, DWORD PTR $T234447[ebp]
	mov	DWORD PTR $T234565[ebp], ecx
	mov	edx, DWORD PTR $T234565[ebp]
	mov	DWORD PTR $T234564[ebp], edx
	mov	eax, DWORD PTR $T234581[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T234463[ebp], ecx
	mov	edx, DWORD PTR $T234463[ebp]
	mov	DWORD PTR $T234567[ebp], edx
	mov	eax, DWORD PTR $T234567[ebp]
	mov	DWORD PTR $T234566[ebp], eax
	mov	ecx, DWORD PTR $T234564[ebp]
	push	ecx
	mov	edx, DWORD PTR $T234566[ebp]
	push	edx
	lea	eax, DWORD PTR $T234568[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234581[ebp]
	call	?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::erase

; 2543 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeletePolicyBranchesArray@CvPolicyXMLEntries@@QAEXXZ ENDP ; CvPolicyXMLEntries::DeletePolicyBranchesArray
_TEXT	ENDS
PUBLIC	?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyBranchEntry
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z PROC ; CvPolicyXMLEntries::GetPolicyBranchEntry, COMDAT
; _this$ = ecx

; 2551 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2552 : 	return m_paPolicyBranchEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 2553 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z ENDP ; CvPolicyXMLEntries::GetPolicyBranchEntry
_TEXT	ENDS
PUBLIC	??_7CvPlayerPolicies@@6B@			; CvPlayerPolicies::`vftable'
PUBLIC	??0CvPlayerPolicies@@QAE@XZ			; CvPlayerPolicies::CvPlayerPolicies
PUBLIC	?Uninit@CvPlayerPolicies@@UAEXXZ		; CvPlayerPolicies::Uninit
PUBLIC	?FlavorUpdate@CvPlayerPolicies@@UAEXXZ		; CvPlayerPolicies::FlavorUpdate
PUBLIC	?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z ; CvPlayerPolicies::LogFlavors
EXTRN	??0CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::CvFlavorRecipient
EXTRN	?Init@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Init
;	COMDAT ??_7CvPlayerPolicies@@6B@
CONST	SEGMENT
??_7CvPlayerPolicies@@6B@ DD FLAT:?Init@CvFlavorRecipient@@UAEXXZ ; CvPlayerPolicies::`vftable'
	DD	FLAT:?Uninit@CvPlayerPolicies@@UAEXXZ
	DD	FLAT:?FlavorUpdate@CvPlayerPolicies@@UAEXXZ
	DD	FLAT:?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvPlayerPolicies@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvPlayerPolicies@@QAE@XZ PROC			; CvPlayerPolicies::CvPlayerPolicies, COMDAT
; _this$ = ecx

; 2579 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::CvFlavorRecipient
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPlayerPolicies@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 0

; 2580 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvPlayerPolicies@@QAE@XZ ENDP			; CvPlayerPolicies::CvPlayerPolicies
_TEXT	ENDS
PUBLIC	??1CvPlayerPolicies@@QAE@XZ			; CvPlayerPolicies::~CvPlayerPolicies
EXTRN	??1CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::~CvFlavorRecipient
; Function compile flags: /Odtp
;	COMDAT ??1CvPlayerPolicies@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvPlayerPolicies@@QAE@XZ PROC			; CvPlayerPolicies::~CvPlayerPolicies, COMDAT
; _this$ = ecx

; 2584 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvPlayerPolicies@@6B@

; 2585 : }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvPlayerPolicies@@QAE@XZ ENDP			; CvPlayerPolicies::~CvPlayerPolicies
_TEXT	ENDS
PUBLIC	?Reset@CvPlayerPolicies@@QAEXXZ			; CvPlayerPolicies::Reset
PUBLIC	?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z ; CvPlayerPolicies::Init
EXTRN	??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z:PROC	; CvPolicyAI::CvPolicyAI
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z$0
__ehfuncinfo$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
tv175 = -60						; size = 4
_this$ = -56						; size = 4
$T234604 = -52						; size = 4
$T234603 = -48						; size = 4
$T234602 = -44						; size = 4
$T234601 = -40						; size = 4
$T234600 = -36						; size = 4
$T234599 = -32						; size = 4
$T234598 = -28						; size = 4
$T234597 = -24						; size = 4
$T234596 = -20						; size = 4
$T234595 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pPolicies$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
_bIsCity$ = 16						; size = 1
?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z PROC ; CvPlayerPolicies::Init, COMDAT
; _this$ = ecx

; 2589 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2590 : 	// Init base class
; 2591 : 	CvFlavorRecipient::Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@CvFlavorRecipient@@UAEXXZ		; CvFlavorRecipient::Init

; 2592 : 
; 2593 : 	// Store off the pointer to the policies active for this game
; 2594 : 	m_bIsCity = bIsCity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bIsCity$[ebp]
	mov	BYTE PTR [eax+4], cl

; 2595 : 	m_pPolicies = pPolicies;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPolicies$[ebp]
	mov	DWORD PTR [edx+52], eax

; 2596 : 	m_pPlayer = pPlayer;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [ecx+60], edx

; 2597 : 
; 2598 : 	// Initialize policy status array
; 2599 : 	CvAssertMsg(m_pabHasPolicy==NULL, "about to leak memory, CvPlayerPolicies::m_pabHasPolicy");
; 2600 : 	m_pabHasPolicy = FNEW(bool[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234595[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234595[ebp]
	mov	DWORD PTR [ecx+12], edx

; 2601 : 	CvAssertMsg(m_pabHasOneShotPolicyFired==NULL, "about to leak memory, CvPlayerPolicies::m_pabHasOneShotPolicyFired");
; 2602 : 	m_pabHasOneShotPolicyFired = FNEW(bool[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234596[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234596[ebp]
	mov	DWORD PTR [ecx+16], edx

; 2603 : 	CvAssertMsg(m_pabHaveOneShotFreeUnitsFired==NULL, "about to leak memory, CvPlayerPolicies::m_pabHaveOneShotFreeUnitsFired");
; 2604 : 	m_pabHaveOneShotFreeUnitsFired = FNEW(bool[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234597[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234597[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2605 : 
; 2606 : 	// Policy Branches Chosen
; 2607 : 	CvAssertMsg(m_pabPolicyBranchUnlocked==NULL, "about to leak memory, CvPlayerPolicies::m_pabPolicyBranchUnlocked");
; 2608 : 	m_pabPolicyBranchUnlocked = FNEW(bool[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234598[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234598[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2609 : 
; 2610 : 	// Policy Branches Blocked by choices
; 2611 : 	CvAssertMsg(m_pabPolicyBranchBlocked==NULL, "about to leak memory, CvPlayerPolicies::m_pabPolicyBranchBlocked");
; 2612 : 	m_pabPolicyBranchBlocked = FNEW(bool[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234599[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234599[ebp]
	mov	DWORD PTR [ecx+28], edx

; 2613 : 
; 2614 : 	// Policy Branches finished
; 2615 : 	CvAssertMsg(m_pabPolicyBranchFinished==NULL, "about to leak memory, CvPlayerPolicies::m_pabPolicyBranchFinished");
; 2616 : 	m_pabPolicyBranchFinished = FNEW(bool[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234600[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234600[ebp]
	mov	DWORD PTR [ecx+32], edx

; 2617 : 
; 2618 : 	CvAssertMsg(m_paePolicyBranchesChosen==NULL, "about to leak memory, CvPlayerPolicies::m_paePolicyBranchesChosen");
; 2619 : 	m_paePolicyBranchesChosen = FNEW(PolicyBranchTypes[m_pPolicies->GetNumPolicyBranches()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234601[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T234601[ebp]
	mov	DWORD PTR [eax+44], ecx

; 2620 : 
; 2621 : 	CvAssertMsg(m_paePolicyBlockedBranchCheck==NULL, "about to leak memory, CvPlayerPolicies::m_paePolicyBlockedBranchCheck");
; 2622 : 	m_paePolicyBlockedBranchCheck = FNEW(PolicyBranchTypes[m_pPolicies->GetNumPolicies()], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T234602[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T234602[ebp]
	mov	DWORD PTR [eax+48], ecx

; 2623 : 	
; 2624 : 	// Create AI object
; 2625 : 	m_pPolicyAI = FNEW(CvPolicyAI(this), c_eCiv5GameplayDLL, 0);

	push	1068					; 0000042cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T234604[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T234604[ebp], 0
	je	SHORT $LN3@Init
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234604[ebp]
	call	??0CvPolicyAI@@QAE@PAVCvPlayerPolicies@@@Z ; CvPolicyAI::CvPolicyAI
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN4@Init
$LN3@Init:
	mov	DWORD PTR tv175[ebp], 0
$LN4@Init:
	mov	eax, DWORD PTR tv175[ebp]
	mov	DWORD PTR $T234603[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T234603[ebp]
	mov	DWORD PTR [ecx+56], edx

; 2626 : 
; 2627 : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvPlayerPolicies@@QAEXXZ		; CvPlayerPolicies::Reset

; 2628 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z$0:
	mov	eax, DWORD PTR $T234604[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvPlayerPolicies@@QAEXPAVCvPolicyXMLEntries@@PAVCvPlayer@@_N@Z ENDP ; CvPlayerPolicies::Init
EXTRN	??1CvPolicyAI@@QAE@XZ:PROC			; CvPolicyAI::~CvPolicyAI
EXTRN	?Uninit@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Uninit
; Function compile flags: /Odtp
;	COMDAT ?Uninit@CvPlayerPolicies@@UAEXXZ
_TEXT	SEGMENT
tv91 = -84						; size = 4
_this$ = -80						; size = 4
$T234682 = -76						; size = 4
$T234680 = -72						; size = 4
$T234676 = -68						; size = 4
$T234669 = -64						; size = 4
$T234668 = -60						; size = 4
$T234657 = -56						; size = 4
$T234655 = -52						; size = 4
$T234651 = -48						; size = 4
$T234649 = -44						; size = 4
$T234645 = -40						; size = 4
$T234643 = -36						; size = 4
$T234639 = -32						; size = 4
$T234637 = -28						; size = 4
$T234633 = -24						; size = 4
$T234631 = -20						; size = 4
$T234627 = -16						; size = 4
$T234625 = -12						; size = 4
$T234621 = -8						; size = 4
$T234619 = -4						; size = 4
?Uninit@CvPlayerPolicies@@UAEXXZ PROC			; CvPlayerPolicies::Uninit, COMDAT
; _this$ = ecx

; 2632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 2633 : 	// Uninit base class
; 2634 : 	CvFlavorRecipient::Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvFlavorRecipient@@UAEXXZ	; CvFlavorRecipient::Uninit

; 2635 : 
; 2636 : 	SAFE_DELETE_ARRAY(m_pabHasPolicy);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T234621[ebp], eax
	mov	ecx, DWORD PTR $T234621[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T234619[ebp], edx
	mov	eax, DWORD PTR $T234619[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T234621[ebp]
	mov	DWORD PTR [ecx], 0

; 2637 : 	SAFE_DELETE_ARRAY(m_pabHasOneShotPolicyFired);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T234627[ebp], edx
	mov	eax, DWORD PTR $T234627[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234625[ebp], ecx
	mov	edx, DWORD PTR $T234625[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T234627[ebp]
	mov	DWORD PTR [eax], 0

; 2638 : 	SAFE_DELETE_ARRAY(m_pabHaveOneShotFreeUnitsFired);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T234633[ebp], ecx
	mov	edx, DWORD PTR $T234633[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234631[ebp], eax
	mov	ecx, DWORD PTR $T234631[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T234633[ebp]
	mov	DWORD PTR [edx], 0

; 2639 : 	SAFE_DELETE_ARRAY(m_pabPolicyBranchUnlocked);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR $T234639[ebp], eax
	mov	ecx, DWORD PTR $T234639[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T234637[ebp], edx
	mov	eax, DWORD PTR $T234637[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T234639[ebp]
	mov	DWORD PTR [ecx], 0

; 2640 : 	SAFE_DELETE_ARRAY(m_pabPolicyBranchBlocked);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR $T234645[ebp], edx
	mov	eax, DWORD PTR $T234645[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234643[ebp], ecx
	mov	edx, DWORD PTR $T234643[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T234645[ebp]
	mov	DWORD PTR [eax], 0

; 2641 : 	SAFE_DELETE_ARRAY(m_pabPolicyBranchFinished);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR $T234651[ebp], ecx
	mov	edx, DWORD PTR $T234651[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234649[ebp], eax
	mov	ecx, DWORD PTR $T234649[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T234651[ebp]
	mov	DWORD PTR [edx], 0

; 2642 : 	SAFE_DELETE_ARRAY(m_paePolicyBranchesChosen);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR $T234657[ebp], eax
	mov	ecx, DWORD PTR $T234657[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T234655[ebp], edx
	mov	eax, DWORD PTR $T234655[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T234657[ebp]
	mov	DWORD PTR [ecx], 0

; 2643 : 	SAFE_DELETE(m_pPolicyAI);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR $T234676[ebp], edx
	mov	eax, DWORD PTR $T234676[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234669[ebp], ecx
	mov	edx, DWORD PTR $T234669[ebp]
	mov	DWORD PTR $T234668[ebp], edx
	cmp	DWORD PTR $T234668[ebp], 0
	je	SHORT $LN19@Uninit
	mov	ecx, DWORD PTR $T234668[ebp]
	call	??1CvPolicyAI@@QAE@XZ			; CvPolicyAI::~CvPolicyAI
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN22@Uninit
	mov	ecx, DWORD PTR $T234668[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN22@Uninit:
	mov	edx, DWORD PTR $T234668[ebp]
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $LN20@Uninit
$LN19@Uninit:
	mov	DWORD PTR tv91[ebp], 0
$LN20@Uninit:
	mov	eax, DWORD PTR $T234676[ebp]
	mov	DWORD PTR [eax], 0

; 2644 : 	SAFE_DELETE_ARRAY(m_paePolicyBlockedBranchCheck);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR $T234682[ebp], ecx
	mov	edx, DWORD PTR $T234682[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T234680[ebp], eax
	mov	ecx, DWORD PTR $T234680[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T234682[ebp]
	mov	DWORD PTR [edx], 0

; 2645 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvPlayerPolicies@@UAEXXZ ENDP			; CvPlayerPolicies::Uninit
_TEXT	ENDS
EXTRN	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z:PROC ; CvGlobals::getPolicyBranchInfo
EXTRN	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z:PROC ; CvGlobals::getPolicyInfo
EXTRN	?Reset@CvPolicyAI@@QAEXXZ:PROC			; CvPolicyAI::Reset
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvPlayerPolicies@@QAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
_pkLoopPolicyBranch$224827 = -32			; size = 4
_eLoopBranch$224825 = -28				; size = 4
_iBranchLoop$224821 = -24				; size = 4
_iNumPolicyBranches$224820 = -20			; size = 4
_eBranch$224817 = -16					; size = 4
_pkPolicyInfo$224814 = -12				; size = 4
_eType$224812 = -8					; size = 4
_iI$ = -4						; size = 4
?Reset@CvPlayerPolicies@@QAEXXZ PROC			; CvPlayerPolicies::Reset, COMDAT
; _this$ = ecx

; 2649 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 2650 : #ifdef AUI_WARNING_FIXES
; 2651 : 	uint iI;
; 2652 : #else
; 2653 : 	int iI;
; 2654 : #endif
; 2655 : 
; 2656 : 	for(iI = 0; iI < m_pPolicies->GetNumPolicies(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN17@Reset
$LN16@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN17@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN15@Reset

; 2657 : 	{
; 2658 : 		m_pabHasPolicy[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 2659 : 		m_pabHasOneShotPolicyFired[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 2660 : 		m_pabHaveOneShotFreeUnitsFired[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 2661 : 		m_paePolicyBlockedBranchCheck[iI] = (PolicyBranchTypes)-2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -2		; fffffffeH

; 2662 : 	}

	jmp	SHORT $LN16@Reset
$LN15@Reset:

; 2663 : 
; 2664 : 	for(iI = 0; iI < m_pPolicies->GetNumPolicyBranches(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN14@Reset
$LN13@Reset:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN14@Reset:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN12@Reset

; 2665 : 	{
; 2666 : 		m_pabPolicyBranchUnlocked[iI] = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [edx+eax], 0

; 2667 : 		m_pabPolicyBranchBlocked[iI] = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [edx+eax], 0

; 2668 : 		m_pabPolicyBranchFinished[iI] = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [edx+eax], 0

; 2669 : 		m_paePolicyBranchesChosen[iI] = NO_POLICY_BRANCH_TYPE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx+eax*4], -1

; 2670 : 	}

	jmp	SHORT $LN13@Reset
$LN12@Reset:

; 2671 : 
; 2672 : 	m_iNumExtraBranches = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 2673 : 
; 2674 : 	m_eBranchPicked1 = NO_POLICY_BRANCH_TYPE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], -1

; 2675 : 	m_eBranchPicked2 = NO_POLICY_BRANCH_TYPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], -1

; 2676 : 	m_eBranchPicked3 = NO_POLICY_BRANCH_TYPE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], -1

; 2677 : 
; 2678 : 	// Reset AI too
; 2679 : 	m_pPolicyAI->Reset();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?Reset@CvPolicyAI@@QAEXXZ		; CvPolicyAI::Reset

; 2680 : 
; 2681 : 
; 2682 : 	CvAssert( m_pPolicies->GetNumPolicies() == m_pPolicies->GetNumPolicies());
; 2683 : 	//  Pre-calculate a policy to branch table so we don't do this over and over again.
; 2684 : 	for (iI = 0; iI < m_pPolicies->GetNumPolicies(); ++iI)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN11@Reset
$LN10@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN11@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN18@Reset

; 2685 : 	{
; 2686 : 		PolicyTypes eType = (PolicyTypes) iI;

	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _eType$224812[ebp], edx

; 2687 : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(eType);

	mov	eax, DWORD PTR _eType$224812[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$224814[ebp], eax

; 2688 : 		if(pkPolicyInfo == NULL)

	cmp	DWORD PTR _pkPolicyInfo$224814[ebp], 0
	jne	SHORT $LN8@Reset

; 2689 : 		{
; 2690 : 			m_paePolicyBlockedBranchCheck[eType] = NO_POLICY_BRANCH_TYPE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _eType$224812[ebp]
	mov	DWORD PTR [edx+eax*4], -1

; 2691 : 		}
; 2692 : 		else

	jmp	SHORT $LN7@Reset
$LN8@Reset:

; 2693 : 		{
; 2694 : 			// What is our branch?
; 2695 : 			PolicyBranchTypes eBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkPolicyInfo$224814[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eBranch$224817[ebp], eax

; 2696 : 
; 2697 : 			// Are we a free branch policy?
; 2698 : 			if(eBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eBranch$224817[ebp], -1
	jne	SHORT $LN6@Reset

; 2699 : 			{
; 2700 : 				int iNumPolicyBranches = m_pPolicies->GetNumPolicyBranches();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	mov	DWORD PTR _iNumPolicyBranches$224820[ebp], eax

; 2701 : 				for(int iBranchLoop = 0; iBranchLoop < iNumPolicyBranches; iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$224821[ebp], 0
	jmp	SHORT $LN5@Reset
$LN4@Reset:
	mov	edx, DWORD PTR _iBranchLoop$224821[ebp]
	add	edx, 1
	mov	DWORD PTR _iBranchLoop$224821[ebp], edx
$LN5@Reset:
	mov	eax, DWORD PTR _iBranchLoop$224821[ebp]
	cmp	eax, DWORD PTR _iNumPolicyBranches$224820[ebp]
	jge	SHORT $LN6@Reset

; 2702 : 				{
; 2703 : 					const PolicyBranchTypes eLoopBranch = static_cast<PolicyBranchTypes>(iBranchLoop);

	mov	ecx, DWORD PTR _iBranchLoop$224821[ebp]
	mov	DWORD PTR _eLoopBranch$224825[ebp], ecx

; 2704 : 					CvPolicyBranchEntry* pkLoopPolicyBranch = GC.getPolicyBranchInfo(eLoopBranch);

	mov	edx, DWORD PTR _eLoopBranch$224825[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkLoopPolicyBranch$224827[ebp], eax

; 2705 : 					if(pkLoopPolicyBranch)

	cmp	DWORD PTR _pkLoopPolicyBranch$224827[ebp], 0
	je	SHORT $LN2@Reset

; 2706 : 					{
; 2707 : 						// Yes, it's a freebie
; 2708 : 						if(pkLoopPolicyBranch->GetFreePolicy() == eType)

	mov	ecx, DWORD PTR _pkLoopPolicyBranch$224827[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	cmp	eax, DWORD PTR _eType$224812[ebp]
	jne	SHORT $LN2@Reset

; 2709 : 						{
; 2710 : 							eBranch = eLoopBranch;

	mov	eax, DWORD PTR _eLoopBranch$224825[ebp]
	mov	DWORD PTR _eBranch$224817[ebp], eax

; 2711 : 							break;

	jmp	SHORT $LN6@Reset
$LN2@Reset:

; 2712 : 						}
; 2713 : 					}
; 2714 : 				}

	jmp	SHORT $LN4@Reset
$LN6@Reset:

; 2715 : 			}
; 2716 : 
; 2717 : 			m_paePolicyBlockedBranchCheck[eType] = eBranch;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _eType$224812[ebp]
	mov	ecx, DWORD PTR _eBranch$224817[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN7@Reset:

; 2718 : 		}

	jmp	$LN10@Reset
$LN18@Reset:

; 2719 : 	}
; 2720 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvPlayerPolicies@@QAEXXZ ENDP			; CvPlayerPolicies::Reset
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
PUBLIC	??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
PUBLIC	?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z	; CvPlayerPolicies::Read
EXTRN	?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z:PROC	; CvPolicyAI::Read
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T234703 = -36						; size = 4
$T234702 = -32						; size = 4
_temp$224854 = -28					; size = 4
_wrapm_piLatestFlavorValues$ = -24			; size = 8
_uiVersion$ = -16					; size = 4
_uiPolicyCount$ = -12					; size = 4
_uiPolicyBranchCount$ = -8				; size = 4
_iNumFlavors$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerPolicies::Read, COMDAT
; _this$ = ecx

; 2724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2725 : 	// Version number to maintain backwards compatibility
; 2726 : 	uint uiVersion;
; 2727 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2728 : 
; 2729 : 	CvAssertMsg(m_pPolicies != NULL && m_pPolicies->GetNumPolicies() > 0, "Number of policies to serialize is expected to greater than 0");
; 2730 : 
; 2731 : 	uint uiPolicyCount = 0;

	mov	DWORD PTR _uiPolicyCount$[ebp], 0

; 2732 : 	uint uiPolicyBranchCount = 0;

	mov	DWORD PTR _uiPolicyBranchCount$[ebp], 0

; 2733 : 	if(m_pPolicies)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN2@Read

; 2734 : 	{
; 2735 : 		uiPolicyCount = m_pPolicies->GetNumPolicies();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _uiPolicyCount$[ebp], eax

; 2736 : 		uiPolicyBranchCount = m_pPolicies->GetNumPolicyBranches();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	mov	DWORD PTR _uiPolicyBranchCount$[ebp], eax
$LN2@Read:

; 2737 : 	}
; 2738 : 
; 2739 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabHasPolicy, uiPolicyCount);

	mov	ecx, DWORD PTR _uiPolicyCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 2740 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabHasOneShotPolicyFired, uiPolicyCount);

	mov	edx, DWORD PTR _uiPolicyCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 2741 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabHaveOneShotFreeUnitsFired, uiPolicyCount);

	mov	eax, DWORD PTR _uiPolicyCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 2742 : 
; 2743 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabPolicyBranchUnlocked, uiPolicyBranchCount);

	mov	ecx, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 2744 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabPolicyBranchBlocked, uiPolicyBranchCount);

	mov	edx, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 2745 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabPolicyBranchFinished, uiPolicyBranchCount);

	mov	eax, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
	add	esp, 12					; 0000000cH

; 2746 : 	CvInfosSerializationHelper::ReadHashedTypeArray(kStream, m_paePolicyBranchesChosen, uiPolicyBranchCount);

	mov	ecx, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>
	add	esp, 12					; 0000000cH

; 2747 : 
; 2748 : 	kStream >> m_iNumExtraBranches;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2749 : 
; 2750 : 	m_eBranchPicked1 = (PolicyBranchTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], eax

; 2751 : 	m_eBranchPicked2 = (PolicyBranchTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], eax

; 2752 : 	m_eBranchPicked3 = (PolicyBranchTypes)CvInfosSerializationHelper::ReadHashed(kStream);

	push	0
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 2753 : 
; 2754 : 	if (uiVersion < 2)

	cmp	DWORD PTR _uiVersion$[ebp], 2
	jae	SHORT $LN1@Read

; 2755 : 	{
; 2756 : 		int temp;
; 2757 : 		kStream >> temp;  // m_iMaxEffectiveCities moved to player class

	lea	edx, DWORD PTR _temp$224854[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN1@Read:

; 2758 : 	}
; 2759 : 
; 2760 : 	// Now for AI
; 2761 : 	m_pPolicyAI->Read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Read@CvPolicyAI@@QAEXAAVFDataStream@@@Z ; CvPolicyAI::Read

; 2762 : 
; 2763 : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 2764 : 
; 2765 : 	int iNumFlavors;
; 2766 : 	kStream >> iNumFlavors;

	lea	edx, DWORD PTR _iNumFlavors$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2767 : 
; 2768 : 	ArrayWrapper<int> wrapm_piLatestFlavorValues(iNumFlavors, m_piLatestFlavorValues);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234703[ebp], ecx
	mov	edx, DWORD PTR _iNumFlavors$[ebp]
	mov	DWORD PTR $T234702[ebp], edx
	mov	eax, DWORD PTR $T234703[ebp]
	mov	DWORD PTR _wrapm_piLatestFlavorValues$[ebp], eax
	mov	ecx, DWORD PTR $T234702[ebp]
	mov	DWORD PTR _wrapm_piLatestFlavorValues$[ebp+4], ecx

; 2769 : 	kStream >> wrapm_piLatestFlavorValues;

	lea	edx, DWORD PTR _wrapm_piLatestFlavorValues$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 2770 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvPlayerPolicies@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerPolicies::Read
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
PUBLIC	??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>
PUBLIC	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>
PUBLIC	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>
PUBLIC	?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z	; CvPlayerPolicies::Write
EXTRN	?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z:PROC	; CvPolicyAI::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T234728 = -36						; size = 4
$T234724 = -32						; size = 4
$T234717 = -28						; size = 4
$T234707 = -24						; size = 8
$T234706 = -16						; size = 4
_uiVersion$ = -12					; size = 4
_uiPolicyCount$ = -8					; size = 4
_uiPolicyBranchCount$ = -4				; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z PROC	; CvPlayerPolicies::Write, COMDAT
; _this$ = ecx

; 2774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2775 : 	// Current version number
; 2776 : 	uint uiVersion = 2;

	mov	DWORD PTR _uiVersion$[ebp], 2

; 2777 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2778 : 
; 2779 : 	CvAssertMsg(m_pPolicies != NULL && GC.getNumPolicyInfos() > 0, "Number of policies to serialize is expected to greater than 0");
; 2780 : 
; 2781 : 	uint uiPolicyCount = 0;

	mov	DWORD PTR _uiPolicyCount$[ebp], 0

; 2782 : 	uint uiPolicyBranchCount = 0;

	mov	DWORD PTR _uiPolicyBranchCount$[ebp], 0

; 2783 : 	if(m_pPolicies)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN1@Write

; 2784 : 	{
; 2785 : 		uiPolicyCount = m_pPolicies->GetNumPolicies();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _uiPolicyCount$[ebp], eax

; 2786 : 		uiPolicyBranchCount = m_pPolicies->GetNumPolicyBranches();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	mov	DWORD PTR _uiPolicyBranchCount$[ebp], eax
$LN1@Write:

; 2787 : 	}
; 2788 : 
; 2789 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyTypes>(kStream, m_pabHasPolicy, uiPolicyCount);

	mov	ecx, DWORD PTR _uiPolicyCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>
	add	esp, 12					; 0000000cH

; 2790 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyTypes>(kStream, m_pabHasOneShotPolicyFired, uiPolicyCount);

	mov	edx, DWORD PTR _uiPolicyCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>
	add	esp, 12					; 0000000cH

; 2791 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyTypes>(kStream, m_pabHaveOneShotFreeUnitsFired, uiPolicyCount);

	mov	eax, DWORD PTR _uiPolicyCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>
	add	esp, 12					; 0000000cH

; 2792 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyBranchTypes>(kStream, m_pabPolicyBranchUnlocked, uiPolicyBranchCount);

	mov	ecx, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>
	add	esp, 12					; 0000000cH

; 2793 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyBranchTypes>(kStream, m_pabPolicyBranchBlocked, uiPolicyBranchCount);

	mov	edx, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>
	add	esp, 12					; 0000000cH

; 2794 : 	CvInfosSerializationHelper::WriteHashedDataArray<PolicyBranchTypes>(kStream, m_pabPolicyBranchFinished, uiPolicyBranchCount);

	mov	eax, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>
	add	esp, 12					; 0000000cH

; 2795 : 	CvInfosSerializationHelper::WriteHashedTypeArray<PolicyBranchTypes>(kStream, m_paePolicyBranchesChosen, uiPolicyBranchCount);

	mov	ecx, DWORD PTR _uiPolicyBranchCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>
	add	esp, 12					; 0000000cH

; 2796 : 
; 2797 : 	kStream << m_iNumExtraBranches;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2798 : 
; 2799 : 	CvInfosSerializationHelper::WriteHashed(kStream, m_eBranchPicked1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 2800 : 	CvInfosSerializationHelper::WriteHashed(kStream, m_eBranchPicked2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 2801 : 	CvInfosSerializationHelper::WriteHashed(kStream, m_eBranchPicked3);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 2802 : 
; 2803 : 	// Now for AI
; 2804 : 	m_pPolicyAI->Write(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?Write@CvPolicyAI@@QAEXAAVFDataStream@@@Z ; CvPolicyAI::Write

; 2805 : 
; 2806 : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 2807 : 	kStream << GC.getNumFlavorTypes();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T234717[ebp], edx
	mov	eax, DWORD PTR $T234717[ebp]
	mov	DWORD PTR $T234706[ebp], eax
	lea	ecx, DWORD PTR $T234706[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2808 : 	kStream << ArrayWrapper<int>(GC.getNumFlavorTypes(), m_piLatestFlavorValues);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T234724[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T234728[ebp], ecx
	mov	edx, DWORD PTR $T234728[ebp]
	mov	DWORD PTR $T234707[ebp], edx
	mov	eax, DWORD PTR $T234724[ebp]
	mov	DWORD PTR $T234707[ebp+4], eax
	lea	ecx, DWORD PTR $T234707[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 2809 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvPlayerPolicies@@QBEXAAVFDataStream@@@Z ENDP	; CvPlayerPolicies::Write
_TEXT	ENDS
PUBLIC	?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z ; CvPlayerPolicies::AddFlavorAsStrategies
; Function compile flags: /Odtp
;	COMDAT ?FlavorUpdate@CvPlayerPolicies@@UAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T234734 = -4						; size = 4
?FlavorUpdate@CvPlayerPolicies@@UAEXXZ PROC		; CvPlayerPolicies::FlavorUpdate, COMDAT
; _this$ = ecx

; 2813 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2814 : 	AddFlavorAsStrategies(GC.getPOLICY_WEIGHT_PROPAGATION_PERCENT());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1824
	mov	DWORD PTR $T234734[ebp], eax
	mov	ecx, DWORD PTR $T234734[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z ; CvPlayerPolicies::AddFlavorAsStrategies

; 2815 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FlavorUpdate@CvPlayerPolicies@@UAEXXZ ENDP		; CvPlayerPolicies::FlavorUpdate
_TEXT	ENDS
PUBLIC	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ	; CvPlayerPolicies::GetPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ PROC	; CvPlayerPolicies::GetPlayer, COMDAT
; _this$ = ecx

; 2819 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2820 : 	return m_pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]

; 2821 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ENDP	; CvPlayerPolicies::GetPlayer
_TEXT	ENDS
PUBLIC	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
; Function compile flags: /Odtp
;	COMDAT ?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::HasPolicy, COMDAT
; _this$ = ecx

; 2825 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2826 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2827 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2828 : 	return m_pabHasPolicy[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 2829 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::HasPolicy
_TEXT	ENDS
PUBLIC	?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchFinished
PUBLIC	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
PUBLIC	?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z ; CvPlayerPolicies::DoNewPolicyPickedForHistory
PUBLIC	?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ; CvPlayerPolicies::SetPolicy
EXTRN	?ChangeNumFreePoliciesEver@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::ChangeNumFreePoliciesEver
EXTRN	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z:PROC ; CvPlayer::setHasPolicy
EXTRN	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ:PROC ; CvGame::getActivePlayer
EXTRN	?ChangeNumPolicies@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumPolicies
; Function compile flags: /Odtp
;	COMDAT ?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
tv134 = -56						; size = 4
_this$ = -52						; size = 4
$T234757 = -48						; size = 4
$T234753 = -44						; size = 4
$T234749 = -40						; size = 4
_eFinisher$224982 = -36					; size = 4
_pkPolicyBranchInfo$224980 = -32			; size = 4
_eLoopPolicy$224973 = -28				; size = 4
_pkLoopPolicyInfo$224975 = -24				; size = 4
_iPolicyLoop$224969 = -20				; size = 4
_bBranchFinished$224966 = -13				; size = 1
_iChange$224960 = -12					; size = 4
_eThisBranch$224963 = -8				; size = 4
_pkPolicyInfo$ = -4					; size = 4
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::SetPolicy, COMDAT
; _this$ = ecx

; 2833 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 2834 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2835 : 	CvAssertMsg(eIndex < m_pPolicies->GetNumPolicies(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2836 : 
; 2837 : 	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$[ebp], eax

; 2838 : 	if(pkPolicyInfo == NULL)

	cmp	DWORD PTR _pkPolicyInfo$[ebp], 0
	jne	SHORT $LN16@SetPolicy

; 2839 : 		return;

	jmp	$LN17@SetPolicy
$LN16@SetPolicy:

; 2840 : 
; 2841 : 	if(HasPolicy(eIndex) != bNewValue)

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	edx, al
	movzx	eax, BYTE PTR _bNewValue$[ebp]
	cmp	edx, eax
	je	$LN17@SetPolicy

; 2842 : 	{
; 2843 : 		m_pabHasPolicy[eIndex] = bNewValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _eIndex$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 2844 : 
; 2845 : 		int iChange = bNewValue ? 1 : -1;

	movzx	edx, BYTE PTR _bNewValue$[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, 2
	add	edx, -1
	mov	DWORD PTR _iChange$224960[ebp], edx

; 2846 : 		GetPlayer()->ChangeNumPolicies(iChange);

	mov	eax, DWORD PTR _iChange$224960[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?ChangeNumPolicies@CvPlayer@@QAEXH@Z	; CvPlayer::ChangeNumPolicies

; 2847 : 
; 2848 : 		if(bNewValue)

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@SetPolicy

; 2849 : 		{
; 2850 : 			DoNewPolicyPickedForHistory(eIndex);

	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z ; CvPlayerPolicies::DoNewPolicyPickedForHistory

; 2851 : 
; 2852 : 			if(m_pPlayer->GetID() == GC.getGame().getActivePlayer())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T234749[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234753[ebp], eax
	mov	ecx, DWORD PTR $T234753[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T234749[ebp], eax
	jne	SHORT $LN14@SetPolicy

; 2853 : 				GC.GetEngineUserInterface()->SetPolicyNotificationSeen(false);

	mov	ecx, DWORD PTR $T234757[ebp]
	mov	DWORD PTR tv134[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv134[ebp], edx
	push	0
	mov	eax, DWORD PTR tv134[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx+512]
	call	eax
$LN14@SetPolicy:

; 2854 : 		}
; 2855 : 
; 2856 : 		PolicyBranchTypes eThisBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkPolicyInfo$[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eThisBranch$224963[ebp], eax

; 2857 : 
; 2858 : 		if(eThisBranch != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eThisBranch$224963[ebp], -1
	je	$LN17@SetPolicy

; 2859 : 		{
; 2860 : 			bool bBranchFinished;
; 2861 : 
; 2862 : 			// We don't have this Policy, so this branch is definitely not finished
; 2863 : 			if(!bNewValue)

	movzx	ecx, BYTE PTR _bNewValue$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@SetPolicy

; 2864 : 			{
; 2865 : 				bBranchFinished = false;

	mov	BYTE PTR _bBranchFinished$224966[ebp], 0

; 2866 : 			}
; 2867 : 			// We now have this Policy, so we MAY have this branch finished
; 2868 : 			else

	jmp	SHORT $LN10@SetPolicy
$LN11@SetPolicy:

; 2869 : 			{
; 2870 : 				bBranchFinished = true;

	mov	BYTE PTR _bBranchFinished$224966[ebp], 1

; 2871 : 
; 2872 : 				// Is the branch this policy is in finished?
; 2873 : #ifdef AUI_WARNING_FIXES
; 2874 : 				for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 2875 : #else
; 2876 : 				for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$224969[ebp], 0
	jmp	SHORT $LN9@SetPolicy
$LN8@SetPolicy:
	mov	edx, DWORD PTR _iPolicyLoop$224969[ebp]
	add	edx, 1
	mov	DWORD PTR _iPolicyLoop$224969[ebp], edx
$LN9@SetPolicy:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$224969[ebp], eax
	jge	SHORT $LN10@SetPolicy

; 2877 : #endif
; 2878 : 				{
; 2879 : 					const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);

	mov	eax, DWORD PTR _iPolicyLoop$224969[ebp]
	mov	DWORD PTR _eLoopPolicy$224973[ebp], eax

; 2880 : 
; 2881 : 					CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	mov	ecx, DWORD PTR _eLoopPolicy$224973[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkLoopPolicyInfo$224975[ebp], eax

; 2882 : 					if(pkLoopPolicyInfo)

	cmp	DWORD PTR _pkLoopPolicyInfo$224975[ebp], 0
	je	SHORT $LN6@SetPolicy

; 2883 : 					{
; 2884 : 						// This policy belongs to our branch
; 2885 : 						if(pkLoopPolicyInfo->GetPolicyBranchType() == eThisBranch)

	mov	ecx, DWORD PTR _pkLoopPolicyInfo$224975[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eThisBranch$224963[ebp]
	jne	SHORT $LN6@SetPolicy

; 2886 : 						{
; 2887 : 							// We don't have this policy!
; 2888 : 							if(!HasPolicy(eLoopPolicy))

	mov	edx, DWORD PTR _eLoopPolicy$224973[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@SetPolicy

; 2889 : 							{
; 2890 : 								bBranchFinished = false;

	mov	BYTE PTR _bBranchFinished$224966[ebp], 0

; 2891 : 
; 2892 : 								// No need to continue, we already know we don't have the branch
; 2893 : 								break;

	jmp	SHORT $LN10@SetPolicy
$LN6@SetPolicy:

; 2894 : 							}
; 2895 : 						}
; 2896 : 					}
; 2897 : 				}

	jmp	SHORT $LN8@SetPolicy
$LN10@SetPolicy:

; 2898 : 			}
; 2899 : 
; 2900 : 			SetPolicyBranchFinished(eThisBranch, bBranchFinished);

	movzx	ecx, BYTE PTR _bBranchFinished$224966[ebp]
	push	ecx
	mov	edx, DWORD PTR _eThisBranch$224963[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchFinished

; 2901 : 
; 2902 : 			if(bBranchFinished)

	movzx	eax, BYTE PTR _bBranchFinished$224966[ebp]
	test	eax, eax
	je	SHORT $LN17@SetPolicy

; 2903 : 			{
; 2904 : 				CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eThisBranch);

	mov	ecx, DWORD PTR _eThisBranch$224963[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$224980[ebp], eax

; 2905 : 				if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$224980[ebp], 0
	je	SHORT $LN17@SetPolicy

; 2906 : 				{
; 2907 : 					PolicyTypes eFinisher = (PolicyTypes)pkPolicyBranchInfo->GetFreeFinishingPolicy();

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$224980[ebp]
	call	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreeFinishingPolicy
	mov	DWORD PTR _eFinisher$224982[ebp], eax

; 2908 : 					if(eFinisher != NO_POLICY)

	cmp	DWORD PTR _eFinisher$224982[ebp], -1
	je	SHORT $LN17@SetPolicy

; 2909 : 					{
; 2910 : 						GetPlayer()->setHasPolicy(eFinisher, true);

	push	1
	mov	edx, DWORD PTR _eFinisher$224982[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy

; 2911 : 						GetPlayer()->ChangeNumFreePoliciesEver(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?ChangeNumFreePoliciesEver@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePoliciesEver
$LN17@SetPolicy:

; 2912 : 					}
; 2913 : 				}
; 2914 : 			}
; 2915 : 		}
; 2916 : 	}
; 2917 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetPolicy@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::SetPolicy
_TEXT	ENDS
PUBLIC	?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasOneShotPolicyFired
; Function compile flags: /Odtp
;	COMDAT ?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::HasOneShotPolicyFired, COMDAT
; _this$ = ecx

; 2921 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2922 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2923 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2924 : 	return m_pabHasOneShotPolicyFired[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 2925 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HasOneShotPolicyFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::HasOneShotPolicyFired
_TEXT	ENDS
PUBLIC	?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ; CvPlayerPolicies::SetOneShotPolicyFired
; Function compile flags: /Odtp
;	COMDAT ?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_bFired$ = 12						; size = 1
?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::SetOneShotPolicyFired, COMDAT
; _this$ = ecx

; 2929 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2930 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2931 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2932 : 	m_pabHasOneShotPolicyFired[eIndex] = bFired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR _bFired$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2933 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetOneShotPolicyFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::SetOneShotPolicyFired
_TEXT	ENDS
PUBLIC	?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HaveOneShotFreeUnitsFired
; Function compile flags: /Odtp
;	COMDAT ?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::HaveOneShotFreeUnitsFired, COMDAT
; _this$ = ecx

; 2936 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2937 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2938 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2939 : 	return m_pabHaveOneShotFreeUnitsFired[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 2940 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?HaveOneShotFreeUnitsFired@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::HaveOneShotFreeUnitsFired
_TEXT	ENDS
PUBLIC	?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ; CvPlayerPolicies::SetOneShotFreeUnitsFired
; Function compile flags: /Odtp
;	COMDAT ?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_bFired$ = 12						; size = 1
?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::SetOneShotFreeUnitsFired, COMDAT
; _this$ = ecx

; 2944 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2945 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2946 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2947 : 	m_pabHaveOneShotFreeUnitsFired[eIndex] = bFired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	al, BYTE PTR _bFired$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 2948 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetOneShotFreeUnitsFired@CvPlayerPolicies@@QAEXW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::SetOneShotFreeUnitsFired
_TEXT	ENDS
PUBLIC	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ	; CvPlayerPolicies::GetNumPoliciesOwned
; Function compile flags: /Odtp
;	COMDAT ?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225007 = -8						; size = 4
_rtnValue$ = -4						; size = 4
?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ PROC	; CvPlayerPolicies::GetNumPoliciesOwned, COMDAT
; _this$ = ecx

; 2952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2953 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 2954 : 
; 2955 : #ifdef AUI_WARNING_FIXES
; 2956 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 2957 : #else
; 2958 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225007[ebp], 0
	jmp	SHORT $LN4@GetNumPoli
$LN3@GetNumPoli:
	mov	eax, DWORD PTR _i$225007[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225007[ebp], eax
$LN4@GetNumPoli:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225007[ebp], eax
	jge	SHORT $LN2@GetNumPoli

; 2959 : #endif
; 2960 : 	{
; 2961 : 		// Do we have this policy?
; 2962 : 		if(m_pabHasPolicy[i])

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225007[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetNumPoli

; 2963 : 		{
; 2964 : 			rtnValue++;

	mov	eax, DWORD PTR _rtnValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetNumPoli:

; 2965 : 		}
; 2966 : 	}

	jmp	SHORT $LN3@GetNumPoli
$LN2@GetNumPoli:

; 2967 : 
; 2968 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 2969 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ ENDP	; CvPlayerPolicies::GetNumPoliciesOwned
_TEXT	ENDS
PUBLIC	?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch
; Function compile flags: /Odtp
;	COMDAT ?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225017 = -8						; size = 4
_rtnValue$ = -4						; size = 4
_eBranch$ = 8						; size = 4
?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch, COMDAT
; _this$ = ecx

; 2973 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2974 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 2975 : 
; 2976 : #ifdef AUI_WARNING_FIXES
; 2977 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 2978 : #else
; 2979 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225017[ebp], 0
	jmp	SHORT $LN4@GetNumPoli@2
$LN3@GetNumPoli@2:
	mov	eax, DWORD PTR _i$225017[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225017[ebp], eax
$LN4@GetNumPoli@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225017[ebp], eax
	jge	SHORT $LN2@GetNumPoli@2

; 2980 : #endif
; 2981 : 	{
; 2982 : 		// Do we have this policy?
; 2983 : 		if (m_pabHasPolicy[i] && m_pPolicies->GetPolicyEntry(i)->GetPolicyBranchType() == eBranch)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225017[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetNumPoli@2
	mov	eax, DWORD PTR _i$225017[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[ebp]
	jne	SHORT $LN1@GetNumPoli@2

; 2984 : 		{
; 2985 : 			rtnValue++;

	mov	edx, DWORD PTR _rtnValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _rtnValue$[ebp], edx
$LN1@GetNumPoli@2:

; 2986 : 		}
; 2987 : 	}

	jmp	SHORT $LN3@GetNumPoli@2
$LN2@GetNumPoli@2:

; 2988 : 
; 2989 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 2990 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ PROC ; CvPlayerPolicies::GetPolicies, COMDAT
; _this$ = ecx

; 2994 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2995 : 	return m_pPolicies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]

; 2996 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ENDP ; CvPlayerPolicies::GetPolicies
_TEXT	ENDS
PUBLIC	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
PUBLIC	?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ; CvPlayerPolicies::GetNumericModifier
; Function compile flags: /Odtp
;	COMDAT ?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z
_TEXT	SEGMENT
tv78 = -20						; size = 4
_this$ = -16						; size = 4
_i$225031 = -12						; size = 4
_iNumPolicies$ = -8					; size = 4
_rtnValue$ = -4						; size = 4
_eType$ = 8						; size = 4
?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z PROC ; CvPlayerPolicies::GetNumericModifier, COMDAT
; _this$ = ecx

; 3000 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 3001 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 3002 : 
; 3003 : 	int iNumPolicies = m_pPolicies->GetNumPolicies();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _iNumPolicies$[ebp], eax

; 3004 : 	for(int i = 0; i < iNumPolicies; i++)

	mov	DWORD PTR _i$225031[ebp], 0
	jmp	SHORT $LN73@GetNumeric
$LN72@GetNumeric:
	mov	ecx, DWORD PTR _i$225031[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$225031[ebp], ecx
$LN73@GetNumeric:
	mov	edx, DWORD PTR _i$225031[ebp]
	cmp	edx, DWORD PTR _iNumPolicies$[ebp]
	jge	$LN71@GetNumeric

; 3005 : 	{
; 3006 : 		// Do we have this policy?
; 3007 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _i$225031[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	$LN70@GetNumeric
	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	edx, al
	test	edx, edx
	jne	$LN70@GetNumeric

; 3008 : 		{
; 3009 : 			// Yes, so add it to our counts
; 3010 : 			switch(eType)

	mov	eax, DWORD PTR _eType$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	cmp	DWORD PTR tv78[ebp], 67			; 00000043H
	ja	$LN70@GetNumeric
	mov	ecx, DWORD PTR tv78[ebp]
	jmp	DWORD PTR $LN76@GetNumeric[ecx*4]
$LN67@GetNumeric:

; 3011 : 			{
; 3012 : 			case POLICYMOD_EXTRA_HAPPINESS:
; 3013 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraHappiness();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetExtraHappiness@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraHappiness
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3014 : 				break;

	jmp	$LN70@GetNumeric
$LN66@GetNumeric:

; 3015 : 			case POLICYMOD_EXTRA_HAPPINESS_PER_CITY:
; 3016 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraHappinessPerCity();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetExtraHappinessPerCity@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraHappinessPerCity
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3017 : 				break;

	jmp	$LN70@GetNumeric
$LN65@GetNumeric:

; 3018 : 			case POLICYMOD_GREAT_PERSON_RATE:
; 3019 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatPeopleRateModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatPeopleRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatPeopleRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3020 : 				break;

	jmp	$LN70@GetNumeric
$LN64@GetNumeric:

; 3021 : 			case POLICYMOD_GREAT_GENERAL_RATE:
; 3022 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatGeneralRateModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatGeneralRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3023 : 				break;

	jmp	$LN70@GetNumeric
$LN63@GetNumeric:

; 3024 : 			case POLICYMOD_GREAT_ADMIRAL_RATE:
; 3025 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatAdmiralRateModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatAdmiralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatAdmiralRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3026 : 				break;

	jmp	$LN70@GetNumeric
$LN62@GetNumeric:

; 3027 : 			case POLICYMOD_GREAT_WRITER_RATE:
; 3028 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatWriterRateModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatWriterRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatWriterRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3029 : 				break;

	jmp	$LN70@GetNumeric
$LN61@GetNumeric:

; 3030 : 			case POLICYMOD_GREAT_ARTIST_RATE:
; 3031 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatArtistRateModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatArtistRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatArtistRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3032 : 				break;

	jmp	$LN70@GetNumeric
$LN60@GetNumeric:

; 3033 : 			case POLICYMOD_GREAT_MUSICIAN_RATE:
; 3034 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatMusicianRateModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatMusicianRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatMusicianRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3035 : 				break;

	jmp	$LN70@GetNumeric
$LN59@GetNumeric:

; 3036 : 			case POLICYMOD_GREAT_MERCHANT_RATE:
; 3037 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatMerchantRateModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatMerchantRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatMerchantRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3038 : 				break;

	jmp	$LN70@GetNumeric
$LN58@GetNumeric:

; 3039 : 			case POLICYMOD_GREAT_SCIENTIST_RATE:
; 3040 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGreatScientistRateModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGreatScientistRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGreatScientistRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3041 : 				break;

	jmp	$LN70@GetNumeric
$LN57@GetNumeric:

; 3042 : 			case POLICYMOD_DOMESTIC_GREAT_GENERAL_RATE:
; 3043 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetDomesticGreatGeneralRateModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetDomesticGreatGeneralRateModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetDomesticGreatGeneralRateModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3044 : 				break;

	jmp	$LN70@GetNumeric
$LN56@GetNumeric:

; 3045 : 			case POLICYMOD_POLICY_COST_MODIFIER:
; 3046 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetPolicyCostModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetPolicyCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyCostModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3047 : 				break;

	jmp	$LN70@GetNumeric
$LN55@GetNumeric:

; 3048 : 			case POLICYMOD_WONDER_PRODUCTION_MODIFIER:
; 3049 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetWonderProductionModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetWonderProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetWonderProductionModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3050 : 				break;

	jmp	$LN70@GetNumeric
$LN54@GetNumeric:

; 3051 : 			case POLICYMOD_BUILDING_PRODUCTION_MODIFIER:
; 3052 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingProductionModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetBuildingProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingProductionModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3053 : 				break;

	jmp	$LN70@GetNumeric
$LN53@GetNumeric:

; 3054 : 			case POLICYMOD_FREE_EXPERIENCE:
; 3055 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetFreeExperience();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetFreeExperience@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetFreeExperience
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3056 : 				break;

	jmp	$LN70@GetNumeric
$LN52@GetNumeric:

; 3057 : 			case POLICYMOD_EXTRA_CULTURE_FROM_IMPROVEMENTS:
; 3058 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCultureImprovementChange();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCultureImprovementChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureImprovementChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3059 : 				break;

	jmp	$LN70@GetNumeric
$LN51@GetNumeric:

; 3060 : 			case POLICYMOD_CULTURE_FROM_KILLS:
; 3061 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCultureFromKills();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCultureFromKills@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureFromKills
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3062 : 				break;

	jmp	$LN70@GetNumeric
$LN50@GetNumeric:

; 3063 : 			case POLICYMOD_EMBARKED_EXTRA_MOVES:
; 3064 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetEmbarkedExtraMoves();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetEmbarkedExtraMoves@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetEmbarkedExtraMoves
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3065 : 				break;

	jmp	$LN70@GetNumeric
$LN49@GetNumeric:

; 3066 : 			case POLICYMOD_CULTURE_FROM_BARBARIAN_KILLS:
; 3067 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCultureFromBarbarianKills();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCultureFromBarbarianKills@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCultureFromBarbarianKills
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3068 : 				break;

	jmp	$LN70@GetNumeric
$LN48@GetNumeric:

; 3069 : 			case POLICYMOD_GOLD_FROM_KILLS:
; 3070 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetGoldFromKills();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetGoldFromKills@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetGoldFromKills
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3071 : 				break;

	jmp	$LN70@GetNumeric
$LN47@GetNumeric:

; 3072 : 			// NQMP GJS - Honor Finisher
; 3073 : 			case POLICYMOD_SCIENCE_FROM_KILLS:
; 3074 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetScienceFromKills();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetScienceFromKills@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetScienceFromKills
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3075 : 				break;

	jmp	$LN70@GetNumeric
$LN46@GetNumeric:

; 3076 : 			// NQMP GJS - Honor Finisher end
; 3077 : 			case POLICYMOD_CULTURE_FROM_GARRISON:
; 3078 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCulturePerGarrisonedUnit();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturePerGarrisonedUnit
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3079 : 				break;

	jmp	$LN70@GetNumeric
$LN45@GetNumeric:

; 3080 : 			case POLICYMOD_UNIT_FREQUENCY_MODIFIER:
; 3081 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCityStateUnitFrequencyModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCityStateUnitFrequencyModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityStateUnitFrequencyModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3082 : 				break;

	jmp	$LN70@GetNumeric
$LN44@GetNumeric:

; 3083 : 			// NQMP GJS - Patronage Finisher begin
; 3084 : 			case POLICYMOD_MINOR_MILITARY_NUM_EXTRA_UNITS_TO_GIFT:
; 3085 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMinorMilitaryNumExtraUnitsToGift();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetMinorMilitaryNumExtraUnitsToGift@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorMilitaryNumExtraUnitsToGift
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3086 : 				break;

	jmp	$LN70@GetNumeric
$LN43@GetNumeric:

; 3087 : 			case POLICYMOD_CITY_STATE_BONUS_MODIFIER:
; 3088 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCityStateBonusModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCityStateBonusModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityStateBonusModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3089 : 				break;

	jmp	$LN70@GetNumeric
$LN42@GetNumeric:

; 3090 : 			// NQMP GJS - Patronage Finisher end
; 3091 : 			// NQMP GJS - Colonialism begin
; 3092 : 			case POLICYMOD_EXTRA_TERRITORY_CLAIM:
; 3093 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraTerritoryClaim();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetExtraTerritoryClaim@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraTerritoryClaim
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3094 : 				break;

	jmp	$LN70@GetNumeric
$LN41@GetNumeric:

; 3095 : 			// NQMP GJS - Colonialism end
; 3096 : 			// NQMP GJS - Cultural Exchange begin
; 3097 : 			case POLICYMOD_EXTRA_TOURISM_PER_GREAT_WORK:
; 3098 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetExtraTourismPerGreatWork();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetExtraTourismPerGreatWork@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetExtraTourismPerGreatWork
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3099 : 				break;

	jmp	$LN70@GetNumeric
$LN40@GetNumeric:

; 3100 : 			// NQMP GJS - Cultural Exchange end
; 3101 : 			// NQMP GJS - Flourishing of the Arts begin
; 3102 : 			case POLICYMOD_TOURISM_PER_WONDER:
; 3103 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTourismPerWonder();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetTourismPerWonder@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTourismPerWonder
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3104 : 				break;

	jmp	$LN70@GetNumeric
$LN39@GetNumeric:

; 3105 : 			// NQMP GJS - Flourishing of the Arts end
; 3106 : #ifdef NQ_TOURISM_PER_CITY
; 3107 : 			case POLICYMOD_TOURISM_PER_CITY:
; 3108 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTourismPerCity();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetTourismPerCity@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTourismPerCity
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3109 : 				break;

	jmp	$LN70@GetNumeric
$LN38@GetNumeric:

; 3110 : #endif
; 3111 : #ifdef NQ_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER_FROM_POLICIES
; 3112 : 			case POLICYMOD_IDEOLOGY_PRESSURE_UNHAPPINESS_MODIFIER:
; 3113 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetIdeologyPressureUnhappinessModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetIdeologyPressureUnhappinessModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetIdeologyPressureUnhappinessModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3114 : 				break;

	jmp	$LN70@GetNumeric
$LN37@GetNumeric:

; 3115 : #endif
; 3116 : 			// NQMP GJS - Military Caste begin
; 3117 : 			case POLICYMOD_PRODUCTION_FROM_GARRISON:
; 3118 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetProductionFromGarrison();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetProductionFromGarrison@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProductionFromGarrison
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3119 : 				break;

	jmp	$LN70@GetNumeric
$LN36@GetNumeric:

; 3120 : 			// NQMP GJS - Military Caste end
; 3121 : 			case POLICYMOD_TOURISM_MOD_COMMON_FOE:
; 3122 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCommonFoeTourismModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCommonFoeTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCommonFoeTourismModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3123 : 				break;

	jmp	$LN70@GetNumeric
$LN35@GetNumeric:

; 3124 : 			case POLICYMOD_TOURISM_MOD_LESS_HAPPY:
; 3125 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetLessHappyTourismModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetLessHappyTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetLessHappyTourismModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3126 : 				break;

	jmp	$LN70@GetNumeric
$LN34@GetNumeric:

; 3127 : 			case POLICYMOD_TOURISM_MOD_SHARED_IDEOLOGY:
; 3128 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSharedIdeologyTourismModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetSharedIdeologyTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedIdeologyTourismModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3129 : 				break;

	jmp	$LN70@GetNumeric
$LN33@GetNumeric:

; 3130 : 			case POLICYMOD_TRADE_MISSION_GOLD_MODIFIER:
; 3131 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTradeMissionGoldModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetTradeMissionGoldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeMissionGoldModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3132 : 				break;

	jmp	$LN70@GetNumeric
$LN32@GetNumeric:

; 3133 : 			case POLICYMOD_FAITH_COST_MODIFIER:
; 3134 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetFaithCostModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetFaithCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetFaithCostModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3135 : 				break;

	jmp	$LN70@GetNumeric
$LN31@GetNumeric:

; 3136 : 			case POLICYMOD_CULTURAL_PLUNDER_MULTIPLIER:
; 3137 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCulturalPlunderMultiplier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCulturalPlunderMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturalPlunderMultiplier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3138 : 				break;

	jmp	$LN70@GetNumeric
$LN30@GetNumeric:

; 3139 : 			case POLICYMOD_STEAL_TECH_SLOWER_MODIFIER:
; 3140 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetStealTechSlowerModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetStealTechSlowerModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetStealTechSlowerModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3141 : 				break;

	jmp	$LN70@GetNumeric
$LN29@GetNumeric:

; 3142 : 			case POLICYMOD_STEAL_TECH_FASTER_MODIFIER:
; 3143 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetStealTechFasterModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetStealTechFasterModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetStealTechFasterModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3144 : 				break;

	jmp	$LN70@GetNumeric
$LN28@GetNumeric:

; 3145 : 			case POLICYMOD_CATCH_SPIES_MODIFIER:
; 3146 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCatchSpiesModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCatchSpiesModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCatchSpiesModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3147 : 				break;

	jmp	$LN70@GetNumeric
$LN27@GetNumeric:

; 3148 : 			case POLICYMOD_BUILDING_PURCHASE_COST_MODIFIER:
; 3149 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingPurchaseCostModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetBuildingPurchaseCostModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetBuildingPurchaseCostModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3150 : 				break;

	jmp	$LN70@GetNumeric
$LN26@GetNumeric:

; 3151 : 			case POLICYMOD_LAND_TRADE_GOLD_CHANGE:
; 3152 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetLandTradeRouteGoldChange();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetLandTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetLandTradeRouteGoldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3153 : 				break;

	jmp	$LN70@GetNumeric
$LN25@GetNumeric:

; 3154 : 			case POLICYMOD_SEA_TRADE_GOLD_CHANGE:
; 3155 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSeaTradeRouteGoldChange();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetSeaTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSeaTradeRouteGoldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3156 : 				break;

	jmp	$LN70@GetNumeric
$LN24@GetNumeric:

; 3157 : 			// NQMP GJS - Silk Road begin
; 3158 : 			case POLICYMOD_INTERNAL_TRADE_GOLD_CHANGE:
; 3159 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteGoldChange();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetInternalTradeRouteGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteGoldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3160 : 				break;

	jmp	$LN70@GetNumeric
$LN23@GetNumeric:

; 3161 : 			// NQMP GJS - Silk Road end
; 3162 : 			case POLICYMOD_SHARED_IDEOLOGY_TRADE_CHANGE:
; 3163 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSharedIdeologyTradeGoldChange();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetSharedIdeologyTradeGoldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedIdeologyTradeGoldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3164 : 				break;

	jmp	$LN70@GetNumeric
$LN22@GetNumeric:

; 3165 : 			case POLICYMOD_RIGGING_ELECTION_MODIFIER:
; 3166 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetRiggingElectionModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetRiggingElectionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRiggingElectionModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3167 : 				break;

	jmp	$LN70@GetNumeric
$LN21@GetNumeric:

; 3168 : 			case POLICYMOD_MILITARY_UNIT_GIFT_INFLUENCE:
; 3169 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMilitaryUnitGiftExtraInfluence();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetMilitaryUnitGiftExtraInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMilitaryUnitGiftExtraInfluence
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3170 : 				break;

	jmp	$LN70@GetNumeric
$LN20@GetNumeric:

; 3171 : 			case POLICYMOD_PROTECTED_MINOR_INFLUENCE:
; 3172 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetProtectedMinorPerTurnInfluence();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetProtectedMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProtectedMinorPerTurnInfluence
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3173 : 				break;

	jmp	$LN70@GetNumeric
$LN19@GetNumeric:

; 3174 : 			case POLICYMOD_AFRAID_INFLUENCE:
; 3175 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetAfraidMinorPerTurnInfluence();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetAfraidMinorPerTurnInfluence@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetAfraidMinorPerTurnInfluence
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3176 : 				break;

	jmp	$LN70@GetNumeric
$LN18@GetNumeric:

; 3177 : 			case POLICYMOD_MINOR_BULLY_SCORE_MODIFIER:
; 3178 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMinorBullyScoreModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetMinorBullyScoreModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorBullyScoreModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3179 : 				break;

	jmp	$LN70@GetNumeric
$LN17@GetNumeric:

; 3180 : 			case POLICYMOD_THEMING_BONUS:
; 3181 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetThemingBonusMultiplier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetThemingBonusMultiplier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetThemingBonusMultiplier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3182 : 				break;

	jmp	$LN70@GetNumeric
$LN16@GetNumeric:

; 3183 : 			case POLICYMOD_CITY_STATE_TRADE_CHANGE:
; 3184 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCityStateTradeChange();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCityStateTradeChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCityStateTradeChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3185 : 				break;

	jmp	$LN70@GetNumeric
$LN15@GetNumeric:

; 3186 : 			case POLICYMOD_INTERNAL_TRADE_MODIFIER:
; 3187 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteYieldModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetInternalTradeRouteYieldModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteYieldModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3188 : 				break;

	jmp	$LN70@GetNumeric
$LN14@GetNumeric:

; 3189 : #ifdef FRUITY_TRADITION_LANDED_ELITE
; 3190 : 			case POLICYMOD_INTERNAL_TRADE_FOOD_YIELD_CHANGE:
; 3191 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteFoodYieldChange();
; 3192 : 				break;
; 3193 : #endif
; 3194 : #ifdef NQ_INTERNAL_TRADE_ROUTE_PRODUCTION_YIELD_CHANGE_FROM_POLICIES
; 3195 : 			case POLICYMOD_INTERNAL_TRADE_PRODUCTION_YIELD_CHANGE:
; 3196 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInternalTradeRouteProductionYieldChange();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetInternalTradeRouteProductionYieldChange@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInternalTradeRouteProductionYieldChange
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3197 : 				break;

	jmp	$LN70@GetNumeric
$LN13@GetNumeric:

; 3198 : #endif
; 3199 : #ifdef NQ_RAIL_CONNECTION_PRODUCTION_MODIFIER_FROM_POLICIES
; 3200 : 			case POLICYMOD_RAIL_CONNECTION_PRODUCTION_MODIFIER:
; 3201 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetRailConnectionProductionModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetRailConnectionProductionModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetRailConnectionProductionModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3202 : 				break;

	jmp	$LN70@GetNumeric
$LN12@GetNumeric:

; 3203 : #endif
; 3204 : #ifdef NQ_COMBAT_BONUS_VS_SMALLER_CIV_FROM_POLICIES
; 3205 : 			case POLICYMOD_COMBAT_BONUS_VS_SMALLER_CIV:
; 3206 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCombatBonusVsSmallerCiv();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCombatBonusVsSmallerCiv@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCombatBonusVsSmallerCiv
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3207 : 				break;

	jmp	$LN70@GetNumeric
$LN11@GetNumeric:

; 3208 : #endif
; 3209 : #ifdef NQ_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER_FROM_POLICIES
; 3210 : 			case POLICYMOD_PRODUCTION_TO_GREAT_MUSICIANS_MODIFIER:
; 3211 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetProductionToGreatMusiciansModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetProductionToGreatMusiciansModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetProductionToGreatMusiciansModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3212 : 				break;

	jmp	$LN70@GetNumeric
$LN10@GetNumeric:

; 3213 : #endif
; 3214 : #ifdef NQ_TRADE_MISSION_INFLUENCE_MODIFIER_FROM_POLICIES
; 3215 : 			case POLICYMOD_TRADE_MISSION_INFLUENCE_MODIFIER:
; 3216 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTradeMissionInfluenceModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetTradeMissionInfluenceModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeMissionInfluenceModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3217 : 				break;

	jmp	$LN70@GetNumeric
$LN9@GetNumeric:

; 3218 : #endif
; 3219 : #ifdef NQ_SCIENCE_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 3220 : 			case POLICYMOD_SCIENCE_PER_GREAT_PERSON_BORN:
; 3221 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSciencePerGreatPersonBorn();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetSciencePerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSciencePerGreatPersonBorn
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3222 : 				break;

	jmp	$LN70@GetNumeric
$LN8@GetNumeric:

; 3223 : #endif
; 3224 : #ifdef NQ_INFLUENCE_BOOST_PER_GREAT_PERSON_BORN_FROM_POLICIES
; 3225 : 			case POLICYMOD_INFLUENCE_BOOST_PER_GREAT_PERSON_BORN:
; 3226 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetInfluenceBoostPerGreatPersonBorn();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetInfluenceBoostPerGreatPersonBorn@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetInfluenceBoostPerGreatPersonBorn
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3227 : 				break;

	jmp	$LN70@GetNumeric
$LN7@GetNumeric:

; 3228 : #endif
; 3229 : #ifdef NQ_TOURISM_FROM_TRADE_MISSIONS_FROM_POLICIES
; 3230 : 			case POLICYMOD_TOURISM_FROM_TRADE_MISSIONS:
; 3231 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTourismFromTradeMissions();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetTourismFromTradeMissions@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTourismFromTradeMissions
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3232 : 				break;

	jmp	$LN70@GetNumeric
$LN6@GetNumeric:

; 3233 : #endif
; 3234 : #ifdef NQ_HAPPINESS_FROM_GREAT_IMPROVEMENTS_FROM_POLICIES
; 3235 : 			case POLICYMOD_HAPPINESS_FROM_GREAT_IMPROVEMENTS:
; 3236 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetHappinessFromGreatImprovements();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetHappinessFromGreatImprovements@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessFromGreatImprovements
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3237 : 				break;

	jmp	$LN70@GetNumeric
$LN5@GetNumeric:

; 3238 : #endif
; 3239 : #ifdef NQ_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS_FROM_POLICIES
; 3240 : 			case POLICYMOD_MINOR_FRIENDSHIP_GAIN_BULLY_GOLD_SUCCESS:
; 3241 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetMinorFriendshipGainBullyGoldSuccess();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetMinorFriendshipGainBullyGoldSuccess@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetMinorFriendshipGainBullyGoldSuccess
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3242 : 				break;

	jmp	SHORT $LN70@GetNumeric
$LN4@GetNumeric:

; 3243 : #endif
; 3244 : #ifdef NQ_COUP_CHANCE_MODIFIER_FROM_POLICIES
; 3245 : 			case POLICYMOD_COUP_CHANCE_MODIFIER:
; 3246 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetCoupChanceModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetCoupChanceModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCoupChanceModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3247 : 				break;

	jmp	SHORT $LN70@GetNumeric
$LN3@GetNumeric:

; 3248 : #endif
; 3249 : 			case POLICYMOD_SHARED_RELIGION_TOURISM_MODIFIER:
; 3250 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetSharedReligionTourismModifier();

	mov	ecx, DWORD PTR _i$225031[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetSharedReligionTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetSharedReligionTourismModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3251 : 				break;

	jmp	SHORT $LN70@GetNumeric
$LN2@GetNumeric:

; 3252 : 			case POLICYMOD_TRADE_ROUTE_TOURISM_MODIFIER:
; 3253 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetTradeRouteTourismModifier();

	mov	eax, DWORD PTR _i$225031[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetTradeRouteTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetTradeRouteTourismModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax

; 3254 : 				break;

	jmp	SHORT $LN70@GetNumeric
$LN1@GetNumeric:

; 3255 : 			case POLICYMOD_OPEN_BORDERS_TOURISM_MODIFIER:
; 3256 : 				rtnValue += m_pPolicies->GetPolicyEntry(i)->GetOpenBordersTourismModifier();

	mov	edx, DWORD PTR _i$225031[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetOpenBordersTourismModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetOpenBordersTourismModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN70@GetNumeric:

; 3257 : 				break;
; 3258 : 			}
; 3259 : 		}
; 3260 : 	}

	jmp	$LN72@GetNumeric
$LN71@GetNumeric:

; 3261 : 
; 3262 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 3263 : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN76@GetNumeric:
	DD	$LN67@GetNumeric
	DD	$LN66@GetNumeric
	DD	$LN65@GetNumeric
	DD	$LN64@GetNumeric
	DD	$LN57@GetNumeric
	DD	$LN56@GetNumeric
	DD	$LN70@GetNumeric
	DD	$LN55@GetNumeric
	DD	$LN54@GetNumeric
	DD	$LN53@GetNumeric
	DD	$LN52@GetNumeric
	DD	$LN51@GetNumeric
	DD	$LN50@GetNumeric
	DD	$LN49@GetNumeric
	DD	$LN48@GetNumeric
	DD	$LN46@GetNumeric
	DD	$LN45@GetNumeric
	DD	$LN33@GetNumeric
	DD	$LN32@GetNumeric
	DD	$LN31@GetNumeric
	DD	$LN30@GetNumeric
	DD	$LN28@GetNumeric
	DD	$LN63@GetNumeric
	DD	$LN62@GetNumeric
	DD	$LN61@GetNumeric
	DD	$LN60@GetNumeric
	DD	$LN59@GetNumeric
	DD	$LN58@GetNumeric
	DD	$LN36@GetNumeric
	DD	$LN35@GetNumeric
	DD	$LN34@GetNumeric
	DD	$LN27@GetNumeric
	DD	$LN26@GetNumeric
	DD	$LN25@GetNumeric
	DD	$LN23@GetNumeric
	DD	$LN22@GetNumeric
	DD	$LN21@GetNumeric
	DD	$LN20@GetNumeric
	DD	$LN19@GetNumeric
	DD	$LN18@GetNumeric
	DD	$LN29@GetNumeric
	DD	$LN17@GetNumeric
	DD	$LN16@GetNumeric
	DD	$LN15@GetNumeric
	DD	$LN14@GetNumeric
	DD	$LN13@GetNumeric
	DD	$LN12@GetNumeric
	DD	$LN11@GetNumeric
	DD	$LN10@GetNumeric
	DD	$LN9@GetNumeric
	DD	$LN8@GetNumeric
	DD	$LN7@GetNumeric
	DD	$LN6@GetNumeric
	DD	$LN5@GetNumeric
	DD	$LN4@GetNumeric
	DD	$LN3@GetNumeric
	DD	$LN2@GetNumeric
	DD	$LN1@GetNumeric
	DD	$LN47@GetNumeric
	DD	$LN44@GetNumeric
	DD	$LN43@GetNumeric
	DD	$LN42@GetNumeric
	DD	$LN37@GetNumeric
	DD	$LN41@GetNumeric
	DD	$LN40@GetNumeric
	DD	$LN39@GetNumeric
	DD	$LN38@GetNumeric
	DD	$LN24@GetNumeric
?GetNumericModifier@CvPlayerPolicies@@QAEHW4PolicyModifierType@@@Z ENDP ; CvPlayerPolicies::GetNumericModifier
_TEXT	ENDS
PUBLIC	?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z ; CvPlayerPolicies::GetYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225113 = -8						; size = 4
_rtnValue$ = -4						; size = 4
_eYieldType$ = 8					; size = 4
?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z PROC ; CvPlayerPolicies::GetYieldModifier, COMDAT
; _this$ = ecx

; 3267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3268 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 3269 : 
; 3270 : #ifdef AUI_WARNING_FIXES
; 3271 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3272 : #else
; 3273 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225113[ebp], 0
	jmp	SHORT $LN4@GetYieldMo@2
$LN3@GetYieldMo@2:
	mov	eax, DWORD PTR _i$225113[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225113[ebp], eax
$LN4@GetYieldMo@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225113[ebp], eax
	jge	SHORT $LN2@GetYieldMo@2

; 3274 : #endif
; 3275 : 	{
; 3276 : 		// Do we have this policy?
; 3277 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225113[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetYieldMo@2
	mov	eax, DWORD PTR _i$225113[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetYieldMo@2

; 3278 : 		{
; 3279 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetYieldModifier(eYieldType);

	mov	edx, DWORD PTR _eYieldType$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$225113[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetYieldModifier@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetYieldModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetYieldMo@2:

; 3280 : 		}
; 3281 : 	}

	jmp	SHORT $LN3@GetYieldMo@2
$LN2@GetYieldMo@2:

; 3282 : 
; 3283 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 3284 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetYieldModifier@CvPlayerPolicies@@QAEHW4YieldTypes@@@Z ENDP ; CvPlayerPolicies::GetYieldModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ; CvPlayerPolicies::GetBuildingClassYieldModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225125 = -8						; size = 4
_rtnValue$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_eYieldType$ = 12					; size = 4
?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassYieldModifier, COMDAT
; _this$ = ecx

; 3288 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3289 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 3290 : 
; 3291 : #ifdef AUI_WARNING_FIXES
; 3292 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3293 : #else
; 3294 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225125[ebp], 0
	jmp	SHORT $LN4@GetBuildin@3
$LN3@GetBuildin@3:
	mov	eax, DWORD PTR _i$225125[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225125[ebp], eax
$LN4@GetBuildin@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225125[ebp], eax
	jge	SHORT $LN2@GetBuildin@3

; 3295 : #endif
; 3296 : 	{
; 3297 : 		// Do we have this policy?
; 3298 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225125[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetBuildin@3
	mov	eax, DWORD PTR _i$225125[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetBuildin@3

; 3299 : 		{
; 3300 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassYieldModifiers(eBuildingClass, eYieldType);

	mov	edx, DWORD PTR _eYieldType$[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$225125[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetBuildingClassYieldModifiers@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetBuildingClassYieldModifiers
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetBuildin@3:

; 3301 : 		}
; 3302 : 	}

	jmp	SHORT $LN3@GetBuildin@3
$LN2@GetBuildin@3:

; 3303 : 
; 3304 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 3305 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBuildingClassYieldModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassYieldModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ; CvPlayerPolicies::GetBuildingClassYieldChange
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225137 = -8						; size = 4
_rtnValue$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
_eYieldType$ = 12					; size = 4
?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassYieldChange, COMDAT
; _this$ = ecx

; 3309 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3310 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 3311 : 
; 3312 : #ifdef AUI_WARNING_FIXES
; 3313 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3314 : #else
; 3315 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225137[ebp], 0
	jmp	SHORT $LN4@GetBuildin@4
$LN3@GetBuildin@4:
	mov	eax, DWORD PTR _i$225137[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225137[ebp], eax
$LN4@GetBuildin@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225137[ebp], eax
	jge	SHORT $LN2@GetBuildin@4

; 3316 : #endif
; 3317 : 	{
; 3318 : 		// Do we have this policy?
; 3319 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225137[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetBuildin@4
	mov	eax, DWORD PTR _i$225137[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetBuildin@4

; 3320 : 		{
; 3321 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassYieldChanges(eBuildingClass, eYieldType);

	mov	edx, DWORD PTR _eYieldType$[ebp]
	push	edx
	mov	eax, DWORD PTR _eBuildingClass$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$225137[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetBuildingClassYieldChanges@CvPolicyEntry@@QBEHHH@Z ; CvPolicyEntry::GetBuildingClassYieldChanges
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetBuildin@4:

; 3322 : 		}
; 3323 : 	}

	jmp	SHORT $LN3@GetBuildin@4
$LN2@GetBuildin@4:

; 3324 : 
; 3325 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 3326 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBuildingClassYieldChange@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@W4YieldTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassYieldChange
_TEXT	ENDS
PUBLIC	?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ; CvPlayerPolicies::GetImprovementCultureChange
; Function compile flags: /Odtp
;	COMDAT ?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225148 = -8						; size = 4
_rtnValue$ = -4						; size = 4
_eImprovement$ = 8					; size = 4
?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z PROC ; CvPlayerPolicies::GetImprovementCultureChange, COMDAT
; _this$ = ecx

; 3330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3331 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 3332 : 
; 3333 : #ifdef AUI_WARNING_FIXES
; 3334 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3335 : #else
; 3336 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225148[ebp], 0
	jmp	SHORT $LN4@GetImprove
$LN3@GetImprove:
	mov	eax, DWORD PTR _i$225148[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225148[ebp], eax
$LN4@GetImprove:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225148[ebp], eax
	jge	SHORT $LN2@GetImprove

; 3337 : #endif
; 3338 : 	{
; 3339 : 		// Do we have this policy?
; 3340 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225148[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetImprove
	mov	eax, DWORD PTR _i$225148[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetImprove

; 3341 : 		{
; 3342 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetImprovementCultureChanges(eImprovement);

	mov	edx, DWORD PTR _eImprovement$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$225148[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetImprovementCultureChanges@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetImprovementCultureChanges
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetImprove:

; 3343 : 		}
; 3344 : 	}

	jmp	SHORT $LN3@GetImprove
$LN2@GetImprove:

; 3345 : 
; 3346 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 3347 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetImprovementCultureChange@CvPlayerPolicies@@QAEHW4ImprovementTypes@@@Z ENDP ; CvPlayerPolicies::GetImprovementCultureChange
_TEXT	ENDS
PUBLIC	?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassProductionModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225159 = -8						; size = 4
_rtnValue$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassProductionModifier, COMDAT
; _this$ = ecx

; 3351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3352 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 3353 : 
; 3354 : #ifdef AUI_WARNING_FIXES
; 3355 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3356 : #else
; 3357 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225159[ebp], 0
	jmp	SHORT $LN4@GetBuildin@5
$LN3@GetBuildin@5:
	mov	eax, DWORD PTR _i$225159[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225159[ebp], eax
$LN4@GetBuildin@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225159[ebp], eax
	jge	SHORT $LN2@GetBuildin@5

; 3358 : #endif
; 3359 : 	{
; 3360 : 		// Do we have this policy?
; 3361 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225159[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetBuildin@5
	mov	eax, DWORD PTR _i$225159[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetBuildin@5

; 3362 : 		{
; 3363 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassProductionModifier(eBuildingClass);

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$225159[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetBuildingClassProductionModifier@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassProductionModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetBuildin@5:

; 3364 : 		}
; 3365 : 	}

	jmp	SHORT $LN3@GetBuildin@5
$LN2@GetBuildin@5:

; 3366 : 
; 3367 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 3368 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingClassProductionModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassProductionModifier
_TEXT	ENDS
PUBLIC	?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ; CvPlayerPolicies::GetBuildingClassTourismModifier
; Function compile flags: /Odtp
;	COMDAT ?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$225170 = -8						; size = 4
_rtnValue$ = -4						; size = 4
_eBuildingClass$ = 8					; size = 4
?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z PROC ; CvPlayerPolicies::GetBuildingClassTourismModifier, COMDAT
; _this$ = ecx

; 3372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3373 : 	int rtnValue = 0;

	mov	DWORD PTR _rtnValue$[ebp], 0

; 3374 : 
; 3375 : #ifdef AUI_WARNING_FIXES
; 3376 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3377 : #else
; 3378 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225170[ebp], 0
	jmp	SHORT $LN4@GetBuildin@6
$LN3@GetBuildin@6:
	mov	eax, DWORD PTR _i$225170[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225170[ebp], eax
$LN4@GetBuildin@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225170[ebp], eax
	jge	SHORT $LN2@GetBuildin@6

; 3379 : #endif
; 3380 : 	{
; 3381 : 		// Do we have this policy?
; 3382 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225170[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN1@GetBuildin@6
	mov	eax, DWORD PTR _i$225170[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetBuildin@6

; 3383 : 		{
; 3384 : 			rtnValue += m_pPolicies->GetPolicyEntry(i)->GetBuildingClassTourismModifier(eBuildingClass);

	mov	edx, DWORD PTR _eBuildingClass$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$225170[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetBuildingClassTourismModifier@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetBuildingClassTourismModifier
	add	eax, DWORD PTR _rtnValue$[ebp]
	mov	DWORD PTR _rtnValue$[ebp], eax
$LN1@GetBuildin@6:

; 3385 : 		}
; 3386 : 	}

	jmp	SHORT $LN3@GetBuildin@6
$LN2@GetBuildin@6:

; 3387 : 
; 3388 : 	return rtnValue;

	mov	eax, DWORD PTR _rtnValue$[ebp]

; 3389 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuildingClassTourismModifier@CvPlayerPolicies@@QAEHW4BuildingClassTypes@@@Z ENDP ; CvPlayerPolicies::GetBuildingClassTourismModifier
_TEXT	ENDS
PUBLIC	?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
; Function compile flags: /Odtp
;	COMDAT ?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pPolicy$225185 = -8					; size = 4
_i$225179 = -4						; size = 4
?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ PROC ; CvPlayerPolicies::HasPolicyEncouragingGarrisons, COMDAT
; _this$ = ecx

; 3393 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3394 : #ifdef AUI_WARNING_FIXES
; 3395 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3396 : #else
; 3397 : 	for(int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225179[ebp], 0
	jmp	SHORT $LN11@HasPolicyE
$LN10@HasPolicyE:
	mov	eax, DWORD PTR _i$225179[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225179[ebp], eax
$LN11@HasPolicyE:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225179[ebp], eax
	jge	$LN9@HasPolicyE

; 3398 : #endif
; 3399 : 	{
; 3400 : 		// Do we have this policy?
; 3401 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225179[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN8@HasPolicyE
	mov	eax, DWORD PTR _i$225179[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN8@HasPolicyE

; 3402 : 		{
; 3403 : 			CvPolicyEntry* pPolicy = m_pPolicies->GetPolicyEntry(i);

	mov	edx, DWORD PTR _i$225179[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pPolicy$225185[ebp], eax

; 3404 : 			if(pPolicy->GetGarrisonedCityRangeStrikeModifier() > 0)

	mov	ecx, DWORD PTR _pPolicy$225185[ebp]
	call	?GetGarrisonedCityRangeStrikeModifier@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetGarrisonedCityRangeStrikeModifier
	test	eax, eax
	jle	SHORT $LN7@HasPolicyE

; 3405 : 			{
; 3406 : 				return true;

	mov	al, 1
	jmp	SHORT $LN12@HasPolicyE
	jmp	SHORT $LN8@HasPolicyE
$LN7@HasPolicyE:

; 3407 : 			}
; 3408 : 			else if(pPolicy->GetCulturePerGarrisonedUnit() > 0)

	mov	ecx, DWORD PTR _pPolicy$225185[ebp]
	call	?GetCulturePerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetCulturePerGarrisonedUnit
	test	eax, eax
	jle	SHORT $LN5@HasPolicyE

; 3409 : 			{
; 3410 : 				return true;

	mov	al, 1
	jmp	SHORT $LN12@HasPolicyE
	jmp	SHORT $LN8@HasPolicyE
$LN5@HasPolicyE:

; 3411 : 			}
; 3412 : 			else if(pPolicy->GetHappinessPerGarrisonedUnit() > 0)

	mov	ecx, DWORD PTR _pPolicy$225185[ebp]
	call	?GetHappinessPerGarrisonedUnit@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetHappinessPerGarrisonedUnit
	test	eax, eax
	jle	SHORT $LN3@HasPolicyE

; 3413 : 			{
; 3414 : 				return true;

	mov	al, 1
	jmp	SHORT $LN12@HasPolicyE
	jmp	SHORT $LN8@HasPolicyE
$LN3@HasPolicyE:

; 3415 : 			}
; 3416 : 			else if(pPolicy->IsGarrisonFreeMaintenance())

	mov	ecx, DWORD PTR _pPolicy$225185[ebp]
	call	?IsGarrisonFreeMaintenance@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsGarrisonFreeMaintenance
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@HasPolicyE

; 3417 : 			{
; 3418 : 				return true;

	mov	al, 1
	jmp	SHORT $LN12@HasPolicyE
$LN8@HasPolicyE:

; 3419 : 			}
; 3420 : 		}
; 3421 : 	}

	jmp	$LN10@HasPolicyE
$LN9@HasPolicyE:

; 3422 : 
; 3423 : 	return false;

	xor	al, al
$LN12@HasPolicyE:

; 3424 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasPolicyEncouragingGarrisons@CvPlayerPolicies@@QBE_NXZ ENDP ; CvPlayerPolicies::HasPolicyEncouragingGarrisons
_TEXT	ENDS
PUBLIC	?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::HasPolicyGrantingReformationBelief
; Function compile flags: /Odtp
;	COMDAT ?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pPolicy$225202 = -8					; size = 4
_i$225196 = -4						; size = 4
?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ PROC ; CvPlayerPolicies::HasPolicyGrantingReformationBelief, COMDAT
; _this$ = ecx

; 3428 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3429 : #ifdef AUI_WARNING_FIXES
; 3430 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3431 : #else
; 3432 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225196[ebp], 0
	jmp	SHORT $LN5@HasPolicyG
$LN4@HasPolicyG:
	mov	eax, DWORD PTR _i$225196[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225196[ebp], eax
$LN5@HasPolicyG:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225196[ebp], eax
	jge	SHORT $LN3@HasPolicyG

; 3433 : #endif
; 3434 : 	{
; 3435 : 		// Do we have this policy?
; 3436 : 		if (m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225196[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN2@HasPolicyG
	mov	eax, DWORD PTR _i$225196[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@HasPolicyG

; 3437 : 		{
; 3438 : 			CvPolicyEntry *pPolicy = m_pPolicies->GetPolicyEntry(i);

	mov	edx, DWORD PTR _i$225196[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pPolicy$225202[ebp], eax

; 3439 : 			if (pPolicy->IsAddReformationBelief())

	mov	ecx, DWORD PTR _pPolicy$225202[ebp]
	call	?IsAddReformationBelief@CvPolicyEntry@@QBE_NXZ ; CvPolicyEntry::IsAddReformationBelief
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@HasPolicyG

; 3440 : 			{
; 3441 : 				return true;

	mov	al, 1
	jmp	SHORT $LN6@HasPolicyG
$LN2@HasPolicyG:

; 3442 : 			}
; 3443 : 		}
; 3444 : 	}

	jmp	SHORT $LN4@HasPolicyG
$LN3@HasPolicyG:

; 3445 : 
; 3446 : 	return false;

	xor	al, al
$LN6@HasPolicyG:

; 3447 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasPolicyGrantingReformationBelief@CvPlayerPolicies@@QBE_NXZ ENDP ; CvPlayerPolicies::HasPolicyGrantingReformationBelief
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ ; CvPlayerPolicies::GetWeLoveTheKingString
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$2
	DD	00H
	DD	FLAT:__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$1
__ehfuncinfo$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
_TEXT	SEGMENT
tv163 = -92						; size = 4
_this$ = -88						; size = 4
$T234811 = -84						; size = 4
$T234797 = -80						; size = 4
_str$225215 = -76					; size = 28
_i$225209 = -48						; size = 4
_rtnValue$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ PROC ; CvPlayerPolicies::GetWeLoveTheKingString, COMDAT
; _this$ = ecx

; 3451 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T234797[ebp], 0

; 3452 : 	CvString rtnValue;

	lea	ecx, DWORD PTR _rtnValue$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3453 : 
; 3454 : 	// Policies are arranged from least to most advanced in XML
; 3455 : 	//   So loop from back to front until we find a string
; 3456 : #ifdef AUI_WARNING_FIXES
; 3457 : 	for (uint i = m_pPolicies->GetNumPolicies(); i > 0; i--)
; 3458 : 	{
; 3459 : 		// Do we have this policy?
; 3460 : 		if (m_pabHasPolicy[i - 1] && !IsPolicyBlocked((PolicyTypes)(i - 1)))
; 3461 : 		{
; 3462 : 			// Does it have a string for us?
; 3463 : 			CvString str = m_pPolicies->GetPolicyEntry(i - 1)->GetWeLoveTheKing();
; 3464 : #else
; 3465 : 	for(int i = m_pPolicies->GetNumPolicies() - 1; i >= 0; i--)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	sub	eax, 1
	mov	DWORD PTR _i$225209[ebp], eax
	jmp	SHORT $LN5@GetWeLoveT
$LN4@GetWeLoveT:
	mov	ecx, DWORD PTR _i$225209[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$225209[ebp], ecx
$LN5@GetWeLoveT:
	cmp	DWORD PTR _i$225209[ebp], 0
	jl	$LN3@GetWeLoveT

; 3466 : 	{
; 3467 : 		// Do we have this policy?
; 3468 : 		if(m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225209[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	$LN2@GetWeLoveT
	mov	eax, DWORD PTR _i$225209[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@GetWeLoveT

; 3469 : 		{
; 3470 : 			// Does it have a string for us?
; 3471 : 			CvString str = m_pPolicies->GetPolicyEntry(i)->GetWeLoveTheKing();

	mov	edx, DWORD PTR _i$225209[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetWeLoveTheKing@CvPolicyEntry@@QAEPBDXZ ; CvPolicyEntry::GetWeLoveTheKing
	mov	DWORD PTR $T234811[ebp], eax
	cmp	DWORD PTR $T234811[ebp], 0
	je	SHORT $LN17@GetWeLoveT
	mov	ecx, DWORD PTR $T234811[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	jmp	SHORT $LN18@GetWeLoveT
$LN17@GetWeLoveT:
	mov	DWORD PTR tv163[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN18@GetWeLoveT:
	mov	edx, DWORD PTR tv163[ebp]
	push	edx
	lea	ecx, DWORD PTR _str$225215[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3472 : #endif
; 3473 : 			if(str.length() > 0)

	lea	ecx, DWORD PTR _str$225215[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	test	eax, eax
	jbe	SHORT $LN1@GetWeLoveT

; 3474 : 			{
; 3475 : 				rtnValue = str;

	lea	eax, DWORD PTR _str$225215[ebp]
	push	eax
	lea	ecx, DWORD PTR _rtnValue$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 3476 : 				break;  // All done when find the first one

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$225215[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN3@GetWeLoveT
$LN1@GetWeLoveT:

; 3477 : 			}
; 3478 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$225215[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@GetWeLoveT:

; 3479 : 	}

	jmp	$LN4@GetWeLoveT
$LN3@GetWeLoveT:

; 3480 : 
; 3481 : 	return rtnValue;

	lea	ecx, DWORD PTR _rtnValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T234797[ebp]
	or	edx, 1
	mov	DWORD PTR $T234797[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rtnValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3482 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$0:
	lea	ecx, DWORD PTR _rtnValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$1:
	lea	ecx, DWORD PTR _str$225215[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ$2:
	mov	eax, DWORD PTR $T234797[ebp]
	and	eax, 1
	je	$LN11@GetWeLoveT
	and	DWORD PTR $T234797[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN11@GetWeLoveT:
	ret	0
__ehhandler$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetWeLoveTheKingString@CvPlayerPolicies@@QAE?AVCvString@@XZ ENDP ; CvPlayerPolicies::GetWeLoveTheKingString
PUBLIC	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
PUBLIC	??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back
PUBLIC	?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve
PUBLIC	??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ ; CvPlayerPolicies::GetFreeBuildingsOnConquest
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$5
__ehfuncinfo$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -228						; size = 4
$T234841 = -44						; size = 4
_pPolicy$225236 = -40					; size = 4
_eFreeBuilding$225237 = -36				; size = 4
_i$225230 = -32						; size = 4
_freeBuildings$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ PROC ; CvPlayerPolicies::GetFreeBuildingsOnConquest, COMDAT
; _this$ = ecx

; 3486 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T234841[ebp], 0

; 3487 : 	std::vector<BuildingTypes> freeBuildings;

	lea	ecx, DWORD PTR _freeBuildings$[ebp]
	call	??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3488 : 	freeBuildings.reserve(m_pPolicies->GetNumPolicies());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	push	eax
	lea	ecx, DWORD PTR _freeBuildings$[ebp]
	call	?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve

; 3489 : 
; 3490 : #ifdef AUI_WARNING_FIXES
; 3491 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3492 : #else
; 3493 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225230[ebp], 0
	jmp	SHORT $LN5@GetFreeBui
$LN4@GetFreeBui:
	mov	ecx, DWORD PTR _i$225230[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$225230[ebp], ecx
$LN5@GetFreeBui:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225230[ebp], eax
	jge	SHORT $LN3@GetFreeBui

; 3494 : #endif
; 3495 : 	{
; 3496 : 		// Do we have this policy?
; 3497 : 		if (m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _i$225230[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	test	eax, eax
	je	SHORT $LN2@GetFreeBui
	mov	ecx, DWORD PTR _i$225230[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@GetFreeBui

; 3498 : 		{
; 3499 : 			CvPolicyEntry *pPolicy = m_pPolicies->GetPolicyEntry(i);

	mov	eax, DWORD PTR _i$225230[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pPolicy$225236[ebp], eax

; 3500 : 			BuildingTypes eFreeBuilding = pPolicy->GetFreeBuildingOnConquest();

	mov	ecx, DWORD PTR _pPolicy$225236[ebp]
	call	?GetFreeBuildingOnConquest@CvPolicyEntry@@QBE?AW4BuildingTypes@@XZ ; CvPolicyEntry::GetFreeBuildingOnConquest
	mov	DWORD PTR _eFreeBuilding$225237[ebp], eax

; 3501 : 			if (eFreeBuilding)

	cmp	DWORD PTR _eFreeBuilding$225237[ebp], 0
	je	SHORT $LN2@GetFreeBui

; 3502 : 			{
; 3503 : 				freeBuildings.push_back(eFreeBuilding);

	lea	edx, DWORD PTR _eFreeBuilding$225237[ebp]
	push	edx
	lea	ecx, DWORD PTR _freeBuildings$[ebp]
	call	?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back
$LN2@GetFreeBui:

; 3504 : 			}
; 3505 : 		}
; 3506 : 	}

	jmp	SHORT $LN4@GetFreeBui
$LN3@GetFreeBui:

; 3507 : 	return freeBuildings;

	lea	eax, DWORD PTR _freeBuildings$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
	mov	ecx, DWORD PTR $T234841[ebp]
	or	ecx, 1
	mov	DWORD PTR $T234841[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _freeBuildings$[ebp]
	call	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3508 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$0:
	lea	ecx, DWORD PTR _freeBuildings$[ebp]
	jmp	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$1:
	mov	eax, DWORD PTR $T234841[ebp]
	and	eax, 1
	je	$LN10@GetFreeBui
	and	DWORD PTR $T234841[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
$LN10@GetFreeBui:
	ret	0
__unwindfunclet$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ$5:
	lea	ecx, DWORD PTR _freeBuildings$[ebp]
	jmp	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
__ehhandler$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFreeBuildingsOnConquest@CvPlayerPolicies@@QAE?AV?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@XZ ENDP ; CvPlayerPolicies::GetFreeBuildingsOnConquest
PUBLIC	?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z ; CvPlayerPolicies::GetTourismFromUnitCreation
; Function compile flags: /Odtp
;	COMDAT ?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pPolicy$225250 = -12					; size = 4
_i$225244 = -8						; size = 4
_iTourism$ = -4						; size = 4
_eUnitClass$ = 8					; size = 4
?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z PROC ; CvPlayerPolicies::GetTourismFromUnitCreation, COMDAT
; _this$ = ecx

; 3512 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 3513 : 	int iTourism = 0;

	mov	DWORD PTR _iTourism$[ebp], 0

; 3514 : 
; 3515 : #ifdef AUI_WARNING_FIXES
; 3516 : 	for (uint i = 0; i < m_pPolicies->GetNumPolicies(); i++)
; 3517 : #else
; 3518 : 	for (int i = 0; i < m_pPolicies->GetNumPolicies(); i++)

	mov	DWORD PTR _i$225244[ebp], 0
	jmp	SHORT $LN5@GetTourism@2
$LN4@GetTourism@2:
	mov	eax, DWORD PTR _i$225244[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225244[ebp], eax
$LN5@GetTourism@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _i$225244[ebp], eax
	jge	SHORT $LN3@GetTourism@2

; 3519 : #endif
; 3520 : 	{
; 3521 : 		// Do we have this policy?
; 3522 : 		if (m_pabHasPolicy[i] && !IsPolicyBlocked((PolicyTypes)i))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$225244[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	test	edx, edx
	je	SHORT $LN2@GetTourism@2
	mov	eax, DWORD PTR _i$225244[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::IsPolicyBlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@GetTourism@2

; 3523 : 		{
; 3524 : 			CvPolicyEntry *pPolicy = m_pPolicies->GetPolicyEntry(i);

	mov	edx, DWORD PTR _i$225244[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pPolicy$225250[ebp], eax

; 3525 : 			if (pPolicy->GetTourismByUnitClassCreated(eUnitClass) > 0)

	mov	ecx, DWORD PTR _eUnitClass$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPolicy$225250[ebp]
	call	?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetTourismByUnitClassCreated
	test	eax, eax
	jle	SHORT $LN2@GetTourism@2

; 3526 : 			{
; 3527 : 				iTourism += pPolicy->GetTourismByUnitClassCreated(eUnitClass);

	mov	edx, DWORD PTR _eUnitClass$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPolicy$225250[ebp]
	call	?GetTourismByUnitClassCreated@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetTourismByUnitClassCreated
	add	eax, DWORD PTR _iTourism$[ebp]
	mov	DWORD PTR _iTourism$[ebp], eax
$LN2@GetTourism@2:

; 3528 : 			}
; 3529 : 		}
; 3530 : 	}

	jmp	SHORT $LN4@GetTourism@2
$LN3@GetTourism@2:

; 3531 : 
; 3532 : 	return iTourism;

	mov	eax, DWORD PTR _iTourism$[ebp]

; 3533 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTourismFromUnitCreation@CvPlayerPolicies@@QBEHW4UnitClassTypes@@@Z ENDP ; CvPlayerPolicies::GetTourismFromUnitCreation
_TEXT	ENDS
PUBLIC	?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ	; CvPlayerPolicies::GetNextPolicyCost
EXTRN	?getPolicyPercent@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getPolicyPercent
EXTRN	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvPlayer::getHandicapInfo
EXTRN	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ:PROC	; CvGameSpeedInfo::getCulturePercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getPolicyCostModifier@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getPolicyCostModifier
EXTRN	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z:PROC	; CvPlayer::GetMaxEffectiveCities
EXTRN	?GetNumCitiesPolicyCostDiscount@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetNumCitiesPolicyCostDiscount
EXTRN	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ:PROC ; CvWorldInfo::GetNumCitiesPolicyCostMod
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?GetNumFreeTenets@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetNumFreeTenets
EXTRN	?GetNumFreePolicies@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumFreePolicies
EXTRN	?GetNumFreePoliciesEver@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumFreePoliciesEver
EXTRN	__fltused:DWORD
EXTRN	___libm_sse2_pow:PROC
; Function compile flags: /Odtp
;	COMDAT ?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T235128 = -44						; size = 4
$T235124 = -40						; size = 4
$T235120 = -36						; size = 4
$T235116 = -32						; size = 4
$T235112 = -28						; size = 4
_iNumPolicies$ = -24					; size = 4
_iDivisor$ = -20					; size = 4
_iNumCities$ = -16					; size = 4
_iPolicyModDiscount$ = -12				; size = 4
_iMod$ = -8						; size = 4
_iCost$ = -4						; size = 4
?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ PROC	; CvPlayerPolicies::GetNextPolicyCost, COMDAT
; _this$ = ecx

; 3537 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 3538 : 	int iNumPolicies = GetNumPoliciesOwned();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPoliciesOwned
	mov	DWORD PTR _iNumPolicies$[ebp], eax

; 3539 : 
; 3540 : 	// Reduce count by however many free Policies we've had in this game
; 3541 : 	iNumPolicies -= (m_pPlayer->GetNumFreePoliciesEver() - m_pPlayer->GetNumFreePolicies() - m_pPlayer->GetNumFreeTenets());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetNumFreePoliciesEver@CvPlayer@@QBEHXZ ; CvPlayer::GetNumFreePoliciesEver
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	sub	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets
	sub	esi, eax
	mov	eax, DWORD PTR _iNumPolicies$[ebp]
	sub	eax, esi
	mov	DWORD PTR _iNumPolicies$[ebp], eax

; 3542 : 
; 3543 : 	// Each branch we unlock (after the first) costs us a buy, so add that in; JON: not any more
; 3544 : 	//if (GetNumPolicyBranchesUnlocked() > 0)
; 3545 : 	//{
; 3546 : 	//	iNumPolicies += (GetNumPolicyBranchesUnlocked() - 1);
; 3547 : 	//}
; 3548 : 
; 3549 : 	int iCost = 0;

	mov	DWORD PTR _iCost$[ebp], 0

; 3550 : 	iCost += (iNumPolicies* /*7*/ GC.getPOLICY_COST_INCREASE_TO_BE_EXPONENTED());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6968
	mov	DWORD PTR $T235112[ebp], ecx
	mov	edx, DWORD PTR _iNumPolicies$[ebp]
	imul	edx, DWORD PTR $T235112[ebp]
	add	edx, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], edx

; 3551 : 
; 3552 : 	// Exponential cost scaling
; 3553 : 	iCost = (int) pow((double) iCost, (double) /*1.70*/ GC.getPOLICY_COST_EXPONENT());

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8136
	movss	DWORD PTR $T235116[ebp], xmm0
	cvtsi2sd xmm0, DWORD PTR _iCost$[ebp]
	cvtss2sd xmm1, DWORD PTR $T235116[ebp]
	call	___libm_sse2_pow
	cvttsd2si eax, xmm0
	mov	DWORD PTR _iCost$[ebp], eax

; 3554 : 
; 3555 : 	// Base cost that doesn't get exponent-ed
; 3556 : 	iCost += /*25*/ GC.getBASE_POLICY_COST();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6964
	mov	DWORD PTR $T235120[ebp], ecx
	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, DWORD PTR $T235120[ebp]
	mov	DWORD PTR _iCost$[ebp], edx

; 3557 : 
; 3558 : 	// Mod for City Count
; 3559 : 	int iMod = GC.getMap().getWorldInfo().GetNumCitiesPolicyCostMod();	// Default is 40, gets smaller on larger maps

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235124[ebp], eax
	mov	ecx, DWORD PTR $T235124[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ ; CvWorldInfo::GetNumCitiesPolicyCostMod
	mov	DWORD PTR _iMod$[ebp], eax

; 3560 : 	int iPolicyModDiscount = m_pPlayer->GetNumCitiesPolicyCostDiscount();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetNumCitiesPolicyCostDiscount@CvPlayer@@QBEHXZ ; CvPlayer::GetNumCitiesPolicyCostDiscount
	mov	DWORD PTR _iPolicyModDiscount$[ebp], eax

; 3561 : 	if(iPolicyModDiscount != 0)

	cmp	DWORD PTR _iPolicyModDiscount$[ebp], 0
	je	SHORT $LN1@GetNextPol

; 3562 : 	{
; 3563 : 		iMod = iMod * (100 + iPolicyModDiscount);

	mov	edx, DWORD PTR _iPolicyModDiscount$[ebp]
	add	edx, 100				; 00000064H
	imul	edx, DWORD PTR _iMod$[ebp]
	mov	DWORD PTR _iMod$[ebp], edx

; 3564 : 		iMod /= 100;

	mov	eax, DWORD PTR _iMod$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMod$[ebp], eax
$LN1@GetNextPol:

; 3565 : 	}
; 3566 : 
; 3567 : 	int iNumCities = m_pPlayer->GetMaxEffectiveCities();

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z ; CvPlayer::GetMaxEffectiveCities
	mov	DWORD PTR _iNumCities$[ebp], eax

; 3568 : 
; 3569 : 	iMod = (iCost * (iNumCities - 1) * iMod);

	mov	eax, DWORD PTR _iNumCities$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _iCost$[ebp]
	imul	eax, DWORD PTR _iMod$[ebp]
	mov	DWORD PTR _iMod$[ebp], eax

; 3570 : 	iMod /= 100;

	mov	eax, DWORD PTR _iMod$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iMod$[ebp], eax

; 3571 : 	iCost += iMod;

	mov	edx, DWORD PTR _iCost$[ebp]
	add	edx, DWORD PTR _iMod$[ebp]
	mov	DWORD PTR _iCost$[ebp], edx

; 3572 : 
; 3573 : 	// Policy Cost Mod
; 3574 : 	iCost *= (100 + m_pPlayer->getPolicyCostModifier());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?getPolicyCostModifier@CvPlayer@@QBEHXZ	; CvPlayer::getPolicyCostModifier
	add	eax, 100				; 00000064H
	imul	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 3575 : 	iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax

; 3576 : 
; 3577 : 	// Game Speed Mod
; 3578 : 	iCost *= GC.getGame().getGameSpeedInfo().getCulturePercent();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235128[ebp], edx
	mov	ecx, DWORD PTR $T235128[ebp]
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getCulturePercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getCulturePercent
	imul	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 3579 : 	iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax

; 3580 : 
; 3581 : 	// Handicap Mod
; 3582 : 	iCost *= m_pPlayer->getHandicapInfo().getPolicyPercent();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?getHandicapInfo@CvPlayer@@QBEAAVCvHandicapInfo@@XZ ; CvPlayer::getHandicapInfo
	mov	ecx, eax
	call	?getPolicyPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getPolicyPercent
	imul	eax, DWORD PTR _iCost$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 3583 : 	iCost /= 100;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iCost$[ebp], eax

; 3584 : 
; 3585 : 	// Make the number nice and even
; 3586 : 	int iDivisor = /*5*/ GC.getPOLICY_COST_VISIBLE_DIVISOR();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6972
	mov	DWORD PTR _iDivisor$[ebp], edx

; 3587 : 	iCost /= iDivisor;

	mov	eax, DWORD PTR _iCost$[ebp]
	cdq
	idiv	DWORD PTR _iDivisor$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 3588 : 	iCost *= iDivisor;

	mov	eax, DWORD PTR _iCost$[ebp]
	imul	eax, DWORD PTR _iDivisor$[ebp]
	mov	DWORD PTR _iCost$[ebp], eax

; 3589 : 
; 3590 : 	return iCost;

	mov	eax, DWORD PTR _iCost$[ebp]

; 3591 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextPolicyCost@CvPlayerPolicies@@QAEHXZ ENDP	; CvPlayerPolicies::GetNextPolicyCost
_TEXT	ENDS
PUBLIC	??_C@_0BF@FGGMGGEP@PlayerCanAdoptPolicy?$AA@	; `string'
PUBLIC	?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetNumTenetsOfLevel
PUBLIC	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
PUBLIC	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ; CvPlayerPolicies::CanAdoptPolicy
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?getJONSCulture@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getJONSCulture
EXTRN	?getNextPolicyCost@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getNextPolicyCost
;	COMDAT ??_C@_0BF@FGGMGGEP@PlayerCanAdoptPolicy?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0BF@FGGMGGEP@PlayerCanAdoptPolicy?$AA@ DB 'PlayerCanAdoptPolicy', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z$0
__ehfuncinfo$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
_TEXT	SEGMENT
tv265 = -148						; size = 4
tv255 = -144						; size = 4
tv244 = -140						; size = 4
_this$ = -136						; size = 4
$T235186 = -132						; size = 4
$T235179 = -128						; size = 4
$T235167 = -124						; size = 4
$T235163 = -120						; size = 4
$T235159 = -116						; size = 4
$T235158 = -112						; size = 4
$T235149 = -108						; size = 4
$T235145 = -104						; size = 4
$T235141 = -100						; size = 4
$T235136 = -94						; size = 1
_bResult$225333 = -93					; size = 1
_args$225332 = -92					; size = 4
_iI$225322 = -88					; size = 4
_eDisablePolicy$225317 = -84				; size = 4
_pkDisablePolicyInfo$225319 = -80			; size = 4
_iPolicyLoop$225313 = -76				; size = 4
_pkPrereqPolicyInfo$225310 = -72			; size = 4
_ePrereq$225307 = -68					; size = 4
_iI$225303 = -64					; size = 4
_ePrereq$225298 = -60					; size = 4
_iI$225294 = -56					; size = 4
_iPoliciesOfThisLevel$225289 = -52			; size = 4
_iPoliciesOfPreviousLevel$225290 = -48			; size = 4
_iLevel$225287 = -44					; size = 4
_bTenet$225275 = -37					; size = 1
_eBranch$ = -36						; size = 4
_pkPolicyBranchInfo$ = -32				; size = 4
_bFoundValid$ = -25					; size = 1
_pkPolicyEntry$ = -24					; size = 4
_bFoundPossible$ = -17					; size = 1
_pkScriptSystem$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bIgnoreCost$ = 12					; size = 1
?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z PROC ; CvPlayerPolicies::CanAdoptPolicy, COMDAT
; _this$ = ecx

; 3595 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3596 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3597 : 	CvAssertMsg(eIndex < GC.getNumPolicyInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 3598 : 
; 3599 : 	CvPolicyEntry* pkPolicyEntry = GC.getPolicyInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyEntry$[ebp], eax

; 3600 : 	if(pkPolicyEntry == NULL)

	cmp	DWORD PTR _pkPolicyEntry$[ebp], 0
	jne	SHORT $LN40@CanAdoptPo

; 3601 : 		return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN40@CanAdoptPo:

; 3602 : 
; 3603 : 	// Already has Policy?
; 3604 : 	if(HasPolicy(eIndex))

	mov	ecx, DWORD PTR _eIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN39@CanAdoptPo

; 3605 : 	{
; 3606 : 		return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN39@CanAdoptPo:

; 3607 : 	}
; 3608 : 
; 3609 : 	// Has enough culture to spend?
; 3610 : 	if((!bIgnoreCost) && m_pPlayer->getNextPolicyCost() > 0)

	movzx	eax, BYTE PTR _bIgnoreCost$[ebp]
	test	eax, eax
	jne	SHORT $LN38@CanAdoptPo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	test	eax, eax
	jle	SHORT $LN38@CanAdoptPo

; 3611 : 	{
; 3612 : 		if(m_pPlayer->getJONSCulture() < m_pPlayer->getNextPolicyCost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?getJONSCulture@CvPlayer@@QBEHXZ	; CvPlayer::getJONSCulture
	mov	esi, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	cmp	esi, eax
	jge	SHORT $LN38@CanAdoptPo

; 3613 : 		{
; 3614 : 			bool bTenet = pkPolicyEntry->GetLevel() > 0;

	mov	ecx, DWORD PTR _pkPolicyEntry$[ebp]
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	xor	ecx, ecx
	test	eax, eax
	setg	cl
	mov	BYTE PTR _bTenet$225275[ebp], cl

; 3615 : 			if (m_pPlayer->GetNumFreePolicies() == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jne	SHORT $LN38@CanAdoptPo

; 3616 : 			{
; 3617 : 				if (!bTenet || m_pPlayer->GetNumFreeTenets() == 0)

	movzx	eax, BYTE PTR _bTenet$225275[ebp]
	test	eax, eax
	je	SHORT $LN34@CanAdoptPo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets
	test	eax, eax
	jne	SHORT $LN38@CanAdoptPo
$LN34@CanAdoptPo:

; 3618 : 				{
; 3619 : 					return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN38@CanAdoptPo:

; 3620 : 				}
; 3621 : 			}
; 3622 : 		}
; 3623 : 	}
; 3624 : 
; 3625 : 	PolicyBranchTypes eBranch = (PolicyBranchTypes) pkPolicyEntry->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkPolicyEntry$[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eBranch$[ebp], eax

; 3626 : 
; 3627 : 	// If it doesn't have a branch, it's a freebie that comes WITH the branch, so we can't pick it manually
; 3628 : 	if(eBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eBranch$[ebp], -1
	jne	SHORT $LN33@CanAdoptPo

; 3629 : 	{
; 3630 : 		return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN33@CanAdoptPo:

; 3631 : 	}
; 3632 : 
; 3633 : 	if(!IsPolicyBranchUnlocked(eBranch))

	mov	edx, DWORD PTR _eBranch$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN32@CanAdoptPo

; 3634 : 	{
; 3635 : 		return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN32@CanAdoptPo:

; 3636 : 	}
; 3637 : 
; 3638 : 	// Is it from a branch with Levels?
; 3639 : 	CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranch);

	mov	ecx, DWORD PTR _eBranch$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$[ebp], eax

; 3640 : 	if(pkPolicyBranchInfo == NULL)

	cmp	DWORD PTR _pkPolicyBranchInfo$[ebp], 0
	jne	SHORT $LN31@CanAdoptPo

; 3641 : 	{
; 3642 : 		return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo

; 3643 : 	}
; 3644 : 	else

	jmp	SHORT $LN30@CanAdoptPo
$LN31@CanAdoptPo:

; 3645 : 	{
; 3646 : 		if (pkPolicyBranchInfo->IsPurchaseByLevel())

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$[ebp]
	call	?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsPurchaseByLevel
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN30@CanAdoptPo

; 3647 : 		{
; 3648 : 			// If below level 1, can't have as many of this level as of the previous one
; 3649 : 			int iLevel = pkPolicyEntry->GetLevel();

	mov	ecx, DWORD PTR _pkPolicyEntry$[ebp]
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	mov	DWORD PTR _iLevel$225287[ebp], eax

; 3650 : 			if (iLevel > 1)

	cmp	DWORD PTR _iLevel$225287[ebp], 1
	jle	SHORT $LN30@CanAdoptPo

; 3651 : 			{
; 3652 : 				int iPoliciesOfThisLevel = GetNumTenetsOfLevel(eBranch, iLevel) + 1 /* For the policy we're adding here */;

	mov	eax, DWORD PTR _iLevel$225287[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBranch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetNumTenetsOfLevel
	add	eax, 1
	mov	DWORD PTR _iPoliciesOfThisLevel$225289[ebp], eax

; 3653 : 				int iPoliciesOfPreviousLevel = GetNumTenetsOfLevel(eBranch, iLevel - 1);

	mov	edx, DWORD PTR _iLevel$225287[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _eBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetNumTenetsOfLevel
	mov	DWORD PTR _iPoliciesOfPreviousLevel$225290[ebp], eax

; 3654 : 				if (iPoliciesOfThisLevel >= iPoliciesOfPreviousLevel)

	mov	ecx, DWORD PTR _iPoliciesOfThisLevel$225289[ebp]
	cmp	ecx, DWORD PTR _iPoliciesOfPreviousLevel$225290[ebp]
	jl	SHORT $LN30@CanAdoptPo

; 3655 : 				{
; 3656 : 					return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN30@CanAdoptPo:

; 3657 : 				}
; 3658 : 			}
; 3659 : 		}
; 3660 : 	}
; 3661 : 
; 3662 : 	// Other Policies as Prereqs
; 3663 : 
; 3664 : 	bool bFoundPossible = false;

	mov	BYTE PTR _bFoundPossible$[ebp], 0

; 3665 : 	bool bFoundValid = false;

	mov	BYTE PTR _bFoundValid$[ebp], 0

; 3666 : 
; 3667 : 	for(int iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$225294[ebp], 0
	jmp	SHORT $LN26@CanAdoptPo
$LN25@CanAdoptPo:
	mov	edx, DWORD PTR _iI$225294[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225294[ebp], edx
$LN26@CanAdoptPo:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	mov	DWORD PTR $T235141[ebp], eax
	mov	ecx, DWORD PTR _iI$225294[ebp]
	cmp	ecx, DWORD PTR $T235141[ebp]
	jge	SHORT $LN24@CanAdoptPo

; 3668 : 	{
; 3669 : 		PolicyTypes ePrereq = (PolicyTypes)pkPolicyEntry->GetPrereqOrPolicies(iI);

	mov	edx, DWORD PTR _iI$225294[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPolicyEntry$[ebp]
	call	?GetPrereqOrPolicies@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetPrereqOrPolicies
	mov	DWORD PTR _ePrereq$225298[ebp], eax

; 3670 : 		if(ePrereq != NO_POLICY)

	cmp	DWORD PTR _ePrereq$225298[ebp], -1
	je	SHORT $LN23@CanAdoptPo

; 3671 : 		{
; 3672 : 			bFoundPossible = true;

	mov	BYTE PTR _bFoundPossible$[ebp], 1

; 3673 : 
; 3674 : 			if(HasPolicy(ePrereq))

	mov	eax, DWORD PTR _ePrereq$225298[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@CanAdoptPo

; 3675 : 			{
; 3676 : 				bFoundValid = true;

	mov	BYTE PTR _bFoundValid$[ebp], 1

; 3677 : 				break;

	jmp	SHORT $LN24@CanAdoptPo
$LN23@CanAdoptPo:

; 3678 : 			}
; 3679 : 		}
; 3680 : 	}

	jmp	SHORT $LN25@CanAdoptPo
$LN24@CanAdoptPo:

; 3681 : 
; 3682 : 	if(bFoundPossible && !bFoundValid)

	movzx	edx, BYTE PTR _bFoundPossible$[ebp]
	test	edx, edx
	je	SHORT $LN21@CanAdoptPo
	movzx	eax, BYTE PTR _bFoundValid$[ebp]
	test	eax, eax
	jne	SHORT $LN21@CanAdoptPo

; 3683 : 	{
; 3684 : 		return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN21@CanAdoptPo:

; 3685 : 	}
; 3686 : 
; 3687 : 	for(int iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$225303[ebp], 0
	jmp	SHORT $LN20@CanAdoptPo
$LN19@CanAdoptPo:
	mov	ecx, DWORD PTR _iI$225303[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225303[ebp], ecx
$LN20@CanAdoptPo:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272
	mov	DWORD PTR $T235145[ebp], edx
	mov	eax, DWORD PTR _iI$225303[ebp]
	cmp	eax, DWORD PTR $T235145[ebp]
	jge	SHORT $LN18@CanAdoptPo

; 3688 : 	{
; 3689 : 		const PolicyTypes ePrereq = static_cast<PolicyTypes>(pkPolicyEntry->GetPrereqAndPolicies(iI));

	mov	ecx, DWORD PTR _iI$225303[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPolicyEntry$[ebp]
	call	?GetPrereqAndPolicies@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetPrereqAndPolicies
	mov	DWORD PTR _ePrereq$225307[ebp], eax

; 3690 : 
; 3691 : 		if(ePrereq == NO_POLICY)

	cmp	DWORD PTR _ePrereq$225307[ebp], -1
	jne	SHORT $LN17@CanAdoptPo

; 3692 : 			continue;

	jmp	SHORT $LN19@CanAdoptPo
$LN17@CanAdoptPo:

; 3693 : 
; 3694 : 		CvPolicyEntry* pkPrereqPolicyInfo = GC.getPolicyInfo(ePrereq);

	mov	edx, DWORD PTR _ePrereq$225307[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPrereqPolicyInfo$225310[ebp], eax

; 3695 : 		if(pkPrereqPolicyInfo)

	cmp	DWORD PTR _pkPrereqPolicyInfo$225310[ebp], 0
	je	SHORT $LN16@CanAdoptPo

; 3696 : 		{
; 3697 : 			if(!HasPolicy(ePrereq))

	mov	eax, DWORD PTR _ePrereq$225307[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN16@CanAdoptPo

; 3698 : 			{
; 3699 : 				return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN16@CanAdoptPo:

; 3700 : 			}
; 3701 : 		}
; 3702 : 	}

	jmp	SHORT $LN19@CanAdoptPo
$LN18@CanAdoptPo:

; 3703 : 
; 3704 : 	// Disabled by another Policy?
; 3705 : #ifdef AUI_WARNING_FIXES
; 3706 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 3707 : #else
; 3708 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$225313[ebp], 0
	jmp	SHORT $LN14@CanAdoptPo
$LN13@CanAdoptPo:
	mov	edx, DWORD PTR _iPolicyLoop$225313[ebp]
	add	edx, 1
	mov	DWORD PTR _iPolicyLoop$225313[ebp], edx
$LN14@CanAdoptPo:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$225313[ebp], eax
	jge	SHORT $LN12@CanAdoptPo

; 3709 : #endif
; 3710 : 	{
; 3711 : 		const PolicyTypes eDisablePolicy =static_cast<PolicyTypes>(iPolicyLoop);

	mov	eax, DWORD PTR _iPolicyLoop$225313[ebp]
	mov	DWORD PTR _eDisablePolicy$225317[ebp], eax

; 3712 : 
; 3713 : 		CvPolicyEntry* pkDisablePolicyInfo = GC.getPolicyInfo(eDisablePolicy);

	mov	ecx, DWORD PTR _eDisablePolicy$225317[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkDisablePolicyInfo$225319[ebp], eax

; 3714 : 		if(pkDisablePolicyInfo)

	cmp	DWORD PTR _pkDisablePolicyInfo$225319[ebp], 0
	je	SHORT $LN11@CanAdoptPo

; 3715 : 		{
; 3716 : 			if(HasPolicy(eDisablePolicy))

	mov	edx, DWORD PTR _eDisablePolicy$225317[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@CanAdoptPo

; 3717 : 			{
; 3718 : 				for(int iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	mov	DWORD PTR _iI$225322[ebp], 0
	jmp	SHORT $LN9@CanAdoptPo
$LN8@CanAdoptPo:
	mov	ecx, DWORD PTR _iI$225322[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$225322[ebp], ecx
$LN9@CanAdoptPo:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272
	mov	DWORD PTR $T235149[ebp], edx
	mov	eax, DWORD PTR _iI$225322[ebp]
	cmp	eax, DWORD PTR $T235149[ebp]
	jge	SHORT $LN11@CanAdoptPo

; 3719 : 				{
; 3720 : 					if(pkDisablePolicyInfo->GetPolicyDisables(iI) == eIndex)

	mov	ecx, DWORD PTR _iI$225322[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkDisablePolicyInfo$225319[ebp]
	call	?GetPolicyDisables@CvPolicyEntry@@QBEHH@Z ; CvPolicyEntry::GetPolicyDisables
	cmp	eax, DWORD PTR _eIndex$[ebp]
	jne	SHORT $LN6@CanAdoptPo

; 3721 : 					{
; 3722 : 						return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN6@CanAdoptPo:

; 3723 : 					}
; 3724 : 				}

	jmp	SHORT $LN8@CanAdoptPo
$LN11@CanAdoptPo:

; 3725 : 			}
; 3726 : 		}
; 3727 : 	}

	jmp	$LN13@CanAdoptPo
$LN12@CanAdoptPo:

; 3728 : 
; 3729 : 	// Has tech prereq? (no policies have one by default)
; 3730 : 	if(pkPolicyEntry->GetTechPrereq() != NO_TECH)

	mov	ecx, DWORD PTR _pkPolicyEntry$[ebp]
	call	?GetTechPrereq@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetTechPrereq
	cmp	eax, -1
	je	SHORT $LN5@CanAdoptPo

; 3731 : 	{
; 3732 : 		if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes) pkPolicyEntry->GetTechPrereq()))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR $T235158[ebp], eax
	mov	ecx, DWORD PTR $T235158[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235159[ebp], eax
	mov	eax, DWORD PTR $T235159[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235163[ebp], eax
	mov	ecx, DWORD PTR _pkPolicyEntry$[ebp]
	call	?GetTechPrereq@CvPolicyEntry@@QBEHXZ	; CvPolicyEntry::GetTechPrereq
	push	eax
	mov	ecx, DWORD PTR $T235163[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@CanAdoptPo

; 3733 : 		{
; 3734 : 			return false;

	xor	al, al
	jmp	$LN41@CanAdoptPo
$LN5@CanAdoptPo:

; 3735 : 		}
; 3736 : 	}
; 3737 : 
; 3738 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T235167[ebp]
	mov	DWORD PTR tv244[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv244[ebp], eax
	mov	ecx, DWORD PTR tv244[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv244[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 3739 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN3@CanAdoptPo

; 3740 : 	{
; 3741 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225332[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3742 : 		args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _args$225332[ebp]
	mov	DWORD PTR tv255[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T235179[ebp], ecx
	mov	edx, DWORD PTR $T235179[ebp]
	push	edx
	mov	eax, DWORD PTR tv255[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv255[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 3743 : 		args->Push(eIndex);

	mov	ecx, DWORD PTR _args$225332[ebp]
	mov	DWORD PTR tv265[ebp], ecx
	mov	edx, DWORD PTR _eIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR tv265[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv265[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 3744 : 
; 3745 : 		// Attempt to execute the game events.
; 3746 : 		// Will return false if there are no registered listeners.
; 3747 : 		bool bResult = false;

	mov	BYTE PTR _bResult$225333[ebp], 0

; 3748 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanAdoptPolicy", args.get(), bResult))

	mov	ecx, DWORD PTR _args$225332[ebp]
	mov	DWORD PTR $T235186[ebp], ecx
	lea	edx, DWORD PTR _bResult$225333[ebp]
	push	edx
	mov	eax, DWORD PTR $T235186[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@FGGMGGEP@PlayerCanAdoptPolicy?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$[ebp]
	push	ecx
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@CanAdoptPo

; 3749 : 		{
; 3750 : 			// Check the result.
; 3751 : 			if(bResult == false)

	movzx	eax, BYTE PTR _bResult$225333[ebp]
	test	eax, eax
	jne	SHORT $LN2@CanAdoptPo

; 3752 : 			{
; 3753 : 				return false;

	mov	BYTE PTR $T235136[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$225332[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	al, BYTE PTR $T235136[ebp]
	jmp	SHORT $LN41@CanAdoptPo
$LN2@CanAdoptPo:

; 3754 : 			}
; 3755 : 		}
; 3756 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$225332[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanAdoptPo:

; 3757 : 
; 3758 : 	return true;

	mov	al, 1
$LN41@CanAdoptPo:

; 3759 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$225332[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ENDP ; CvPlayerPolicies::CanAdoptPolicy
PUBLIC	??_C@_0BI@CFEMAFHP@PlayerAdoptPolicyBranch?$AA@	; `string'
PUBLIC	?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchToPolicyBranch
PUBLIC	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked
PUBLIC	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
PUBLIC	?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoUnlockPolicyBranch
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ:PROC	; CvPlayer::DoUpdateNextPolicyCost
EXTRN	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeNumFreePolicies
EXTRN	?changeJONSCulture@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeJONSCulture
;	COMDAT ??_C@_0BI@CFEMAFHP@PlayerAdoptPolicyBranch?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0BI@CFEMAFHP@PlayerAdoptPolicyBranch?$AA@ DB 'PlayerAdoptPolicyBran'
	DB	'ch', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z$0
__ehfuncinfo$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
tv201 = -84						; size = 4
tv191 = -80						; size = 4
tv180 = -76						; size = 4
tv168 = -72						; size = 4
tv147 = -68						; size = 4
_this$ = -64						; size = 4
$T235233 = -60						; size = 4
$T235221 = -56						; size = 4
$T235217 = -52						; size = 4
$T235213 = -48						; size = 4
$T235212 = -44						; size = 4
$T235203 = -40						; size = 4
$T235199 = -36						; size = 4
_bResult$225354 = -29					; size = 1
_args$225353 = -28					; size = 4
_pkPolicyBranchInfo$ = -24				; size = 4
_pkScriptSystem$ = -20					; size = 4
_eFreePolicy$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eBranchType$ = 8					; size = 4
?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::DoUnlockPolicyBranch, COMDAT
; _this$ = ecx

; 3763 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3764 : 	CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$[ebp], eax

; 3765 : 	if(pkPolicyBranchInfo == NULL)

	cmp	DWORD PTR _pkPolicyBranchInfo$[ebp], 0
	jne	SHORT $LN7@DoUnlockPo

; 3766 : 	{
; 3767 : 		return;

	jmp	$LN8@DoUnlockPo
$LN7@DoUnlockPo:

; 3768 : 	}
; 3769 : 
; 3770 : 	// Can we actually do this?
; 3771 : 	if(!CanUnlockPolicyBranch(eBranchType))

	mov	ecx, DWORD PTR _eBranchType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN6@DoUnlockPo

; 3772 : 	{
; 3773 : 		return;

	jmp	$LN8@DoUnlockPo
$LN6@DoUnlockPo:

; 3774 : 	}
; 3775 : 
; 3776 : 	// Set that we now have it
; 3777 : 	SetPolicyBranchUnlocked(eBranchType, true, false);

	push	0
	push	1
	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 3778 : 
; 3779 : 	// Are we blocked? If so, unblock us
; 3780 : 	DoSwitchToPolicyBranch(eBranchType);

	mov	ecx, DWORD PTR _eBranchType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchToPolicyBranch

; 3781 : 
; 3782 : 	// Free Policy with this Branch?
; 3783 : 	PolicyTypes eFreePolicy = (PolicyTypes) pkPolicyBranchInfo->GetFreePolicy();

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	mov	DWORD PTR _eFreePolicy$[ebp], eax

; 3784 : 	if(eFreePolicy != NO_POLICY)

	cmp	DWORD PTR _eFreePolicy$[ebp], -1
	je	SHORT $LN5@DoUnlockPo

; 3785 : 	{
; 3786 : 		GetPlayer()->setHasPolicy(eFreePolicy, true);

	push	1
	mov	edx, DWORD PTR _eFreePolicy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
$LN5@DoUnlockPo:

; 3787 : 	}
; 3788 : 
; 3789 : 	// Pay Culture cost - if applicable
; 3790 : 	if(GetPlayer()->GetNumFreePolicies() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jne	SHORT $LN4@DoUnlockPo

; 3791 : 	{
; 3792 : 		GetPlayer()->changeJONSCulture(-GetPlayer()->getNextPolicyCost());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?changeJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::changeJONSCulture

; 3793 : 	}
; 3794 : 	else

	jmp	SHORT $LN3@DoUnlockPo
$LN4@DoUnlockPo:

; 3795 : 	{
; 3796 : 		GetPlayer()->ChangeNumFreePolicies(-1);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePolicies
$LN3@DoUnlockPo:

; 3797 : 	}
; 3798 : 
; 3799 : 	// Update cost if trying to buy another policy this turn
; 3800 : 	GetPlayer()->DoUpdateNextPolicyCost();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?DoUpdateNextPolicyCost@CvPlayer@@QAEXXZ ; CvPlayer::DoUpdateNextPolicyCost

; 3801 : 
; 3802 : 	GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T235199[ebp]
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv147[ebp], ecx
	push	1
	push	11					; 0000000bH
	mov	edx, DWORD PTR tv147[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv147[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx

; 3803 : 
; 3804 : 	// This Dirty bit must only be set when changing something for the active player
; 3805 : 	if(GC.getGame().getActivePlayer() == GetPlayer()->GetID())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235203[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	DWORD PTR $T235212[ebp], eax
	mov	ecx, DWORD PTR $T235212[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T235213[ebp], edx
	mov	ecx, DWORD PTR $T235203[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR $T235213[ebp]
	jne	SHORT $LN2@DoUnlockPo

; 3806 : 	{
; 3807 : 		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T235217[ebp]
	mov	DWORD PTR tv168[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv168[ebp], ecx
	push	1
	push	32					; 00000020H
	mov	edx, DWORD PTR tv168[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv168[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx
$LN2@DoUnlockPo:

; 3808 : 	}
; 3809 : 
; 3810 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T235221[ebp]
	mov	DWORD PTR tv180[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv180[ebp], ecx
	mov	edx, DWORD PTR tv180[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv180[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 3811 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	SHORT $LN8@DoUnlockPo

; 3812 : 	{
; 3813 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225353[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3814 : 		args->Push(m_pPlayer->GetID());

	mov	eax, DWORD PTR _args$225353[ebp]
	mov	DWORD PTR tv191[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235233[ebp], eax
	mov	ecx, DWORD PTR $T235233[ebp]
	push	ecx
	mov	edx, DWORD PTR tv191[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv191[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3815 : 		args->Push(eBranchType);

	mov	eax, DWORD PTR _args$225353[ebp]
	mov	DWORD PTR tv201[ebp], eax
	mov	ecx, DWORD PTR _eBranchType$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv201[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv201[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3816 : 
; 3817 : 		// Attempt to execute the game events.
; 3818 : 		// Will return false if there are no registered listeners.
; 3819 : 		bool bResult = false;

	mov	BYTE PTR _bResult$225354[ebp], 0

; 3820 : 		LuaSupport::CallHook(pkScriptSystem, "PlayerAdoptPolicyBranch", args.get(), bResult);

	lea	eax, DWORD PTR _bResult$225354[ebp]
	push	eax
	mov	ecx, DWORD PTR _args$225353[ebp]
	push	ecx
	push	OFFSET ??_C@_0BI@CFEMAFHP@PlayerAdoptPolicyBranch?$AA@
	mov	edx, DWORD PTR _pkScriptSystem$[ebp]
	push	edx
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 3821 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$225353[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN8@DoUnlockPo:

; 3822 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$225353[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::DoUnlockPolicyBranch
PUBLIC	??_C@_0BL@PMNNKCGM@PlayerCanAdoptPolicyBranch?$AA@ ; `string'
EXTRN	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ:PROC	; CvTeam::GetCurrentEra
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
;	COMDAT ??_C@_0BL@PMNNKCGM@PlayerCanAdoptPolicyBranch?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
CONST	SEGMENT
??_C@_0BL@PMNNKCGM@PlayerCanAdoptPolicyBranch?$AA@ DB 'PlayerCanAdoptPoli'
	DB	'cyBranch', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z$0
__ehfuncinfo$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
tv170 = -76						; size = 4
tv160 = -72						; size = 4
tv149 = -68						; size = 4
_this$ = -64						; size = 4
$T235290 = -60						; size = 4
$T235283 = -56						; size = 4
$T235271 = -52						; size = 4
$T235267 = -48						; size = 4
$T235263 = -44						; size = 4
$T235262 = -40						; size = 4
$T235253 = -36						; size = 4
$T235248 = -30						; size = 1
_bResult$225374 = -29					; size = 1
_args$225373 = -28					; size = 4
_ePrereqEra$225367 = -24				; size = 4
_pkScriptSystem$ = -20					; size = 4
_pkBranchEntry$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eBranchType$ = 8					; size = 4
?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::CanUnlockPolicyBranch, COMDAT
; _this$ = ecx

; 3826 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3827 : 	// Must have enough culture to spend a buy opening a new branch
; 3828 : 	if(GetPlayer()->getJONSCulture() < GetPlayer()->getNextPolicyCost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getJONSCulture@CvPlayer@@QBEHXZ	; CvPlayer::getJONSCulture
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	cmp	esi, eax
	jge	SHORT $LN11@CanUnlockP

; 3829 : 	{
; 3830 : 		if(GetPlayer()->GetNumFreePolicies() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jne	SHORT $LN11@CanUnlockP

; 3831 : 			return false;

	xor	al, al
	jmp	$LN12@CanUnlockP
$LN11@CanUnlockP:

; 3832 : 	}
; 3833 : 
; 3834 : 	CvPolicyBranchEntry* pkBranchEntry = m_pPolicies->GetPolicyBranchEntry(eBranchType);

	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyBranchEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyBranchEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyBranchEntry
	mov	DWORD PTR _pkBranchEntry$[ebp], eax

; 3835 : 	if(pkBranchEntry)

	cmp	DWORD PTR _pkBranchEntry$[ebp], 0
	je	$LN9@CanUnlockP

; 3836 : 	{
; 3837 : 		// Ideology branches unlocked through a direct call to SetPolicyBranchUnlocked()
; 3838 : 		if (pkBranchEntry->IsPurchaseByLevel())

	mov	ecx, DWORD PTR _pkBranchEntry$[ebp]
	call	?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsPurchaseByLevel
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@CanUnlockP

; 3839 : 		{
; 3840 : 			return false;

	xor	al, al
	jmp	$LN12@CanUnlockP
$LN8@CanUnlockP:

; 3841 : 		}
; 3842 : 
; 3843 : 		if (pkBranchEntry->IsLockedWithoutReligion())

	mov	ecx, DWORD PTR _pkBranchEntry$[ebp]
	call	?IsLockedWithoutReligion@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsLockedWithoutReligion
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@CanUnlockP

; 3844 : 		{
; 3845 : 			if (GC.getGame().isOption(GAMEOPTION_NO_RELIGION))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235253[ebp], ecx
	push	21					; 00000015H
	mov	ecx, DWORD PTR $T235253[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@CanUnlockP

; 3846 : 			{
; 3847 : 				return false;

	xor	al, al
	jmp	$LN12@CanUnlockP
$LN7@CanUnlockP:

; 3848 : 			}
; 3849 : 		}
; 3850 : 
; 3851 : 		EraTypes ePrereqEra = (EraTypes) pkBranchEntry->GetEraPrereq();

	mov	ecx, DWORD PTR _pkBranchEntry$[ebp]
	call	?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetEraPrereq
	mov	DWORD PTR _ePrereqEra$225367[ebp], eax

; 3852 : 
; 3853 : 		// Must be in the proper Era
; 3854 : 		if(ePrereqEra != NO_ERA)

	cmp	DWORD PTR _ePrereqEra$225367[ebp], -1
	je	SHORT $LN9@CanUnlockP

; 3855 : 		{
; 3856 : 			if(GET_TEAM(GetPlayer()->getTeam()).GetCurrentEra() < ePrereqEra)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	DWORD PTR $T235262[ebp], eax
	mov	eax, DWORD PTR $T235262[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235263[ebp], eax
	mov	edx, DWORD PTR $T235263[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235267[ebp], edx
	mov	ecx, DWORD PTR $T235267[ebp]
	call	?GetCurrentEra@CvTeam@@QBE?AW4EraTypes@@XZ ; CvTeam::GetCurrentEra
	cmp	eax, DWORD PTR _ePrereqEra$225367[ebp]
	jge	SHORT $LN9@CanUnlockP

; 3857 : 			{
; 3858 : 				return false;

	xor	al, al
	jmp	$LN12@CanUnlockP
$LN9@CanUnlockP:

; 3859 : 			}
; 3860 : 		}
; 3861 : 	}
; 3862 : 
; 3863 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	eax, DWORD PTR $T235271[ebp]
	mov	DWORD PTR tv149[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv149[ebp], ecx
	mov	edx, DWORD PTR tv149[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pkScriptSystem$[ebp], eax

; 3864 : 	if(pkScriptSystem)

	cmp	DWORD PTR _pkScriptSystem$[ebp], 0
	je	$LN3@CanUnlockP

; 3865 : 	{
; 3866 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225373[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3867 : 		args->Push(m_pPlayer->GetID());

	mov	eax, DWORD PTR _args$225373[ebp]
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235283[ebp], eax
	mov	ecx, DWORD PTR $T235283[ebp]
	push	ecx
	mov	edx, DWORD PTR tv160[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv160[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3868 : 		args->Push(eBranchType);

	mov	eax, DWORD PTR _args$225373[ebp]
	mov	DWORD PTR tv170[ebp], eax
	mov	ecx, DWORD PTR _eBranchType$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv170[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv170[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 3869 : 
; 3870 : 		// Attempt to execute the game events.
; 3871 : 		// Will return false if there are no registered listeners.
; 3872 : 		bool bResult = false;

	mov	BYTE PTR _bResult$225374[ebp], 0

; 3873 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanAdoptPolicyBranch", args.get(), bResult))

	mov	eax, DWORD PTR _args$225373[ebp]
	mov	DWORD PTR $T235290[ebp], eax
	lea	ecx, DWORD PTR _bResult$225374[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235290[ebp]
	push	edx
	push	OFFSET ??_C@_0BL@PMNNKCGM@PlayerCanAdoptPolicyBranch?$AA@
	mov	eax, DWORD PTR _pkScriptSystem$[ebp]
	push	eax
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@CanUnlockP

; 3874 : 		{
; 3875 : 			// Check the result.
; 3876 : 			if(bResult == false)

	movzx	edx, BYTE PTR _bResult$225374[ebp]
	test	edx, edx
	jne	SHORT $LN2@CanUnlockP

; 3877 : 			{
; 3878 : 				return false;

	mov	BYTE PTR $T235248[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$225373[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	mov	al, BYTE PTR $T235248[ebp]
	jmp	SHORT $LN12@CanUnlockP
$LN2@CanUnlockP:

; 3879 : 			}
; 3880 : 		}
; 3881 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _args$225373[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanUnlockP:

; 3882 : 
; 3883 : 	return true;

	mov	al, 1
$LN12@CanUnlockP:

; 3884 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$225373[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::CanUnlockPolicyBranch
; Function compile flags: /Odtp
;	COMDAT ?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBranchType$ = 8					; size = 4
?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked, COMDAT
; _this$ = ecx

; 3888 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3889 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3890 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 3891 : 	return m_pabPolicyBranchUnlocked[eBranchType];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _eBranchType$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 3892 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBranchUnlocked
_TEXT	ENDS
PUBLIC	??_C@_0CN@HDBGCGID@TXT_KEY_NOTIFICATION_SUMMARY_IDE@ ; `string'
PUBLIC	??_C@_0CN@IOCFBKAF@TXT_KEY_NOTIFICATION_SUMMARY_IDE@ ; `string'
PUBLIC	??_C@_0CL@PDGBLPGB@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ ; `string'
PUBLIC	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z	; GetLocalizedText<char const *>
PUBLIC	??_C@_0CL@NLKKOP@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ ; `string'
PUBLIC	??_C@_0CF@GLPKJODE@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ ; `string'
PUBLIC	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
PUBLIC	??_C@_0CF@JGMJKCLC@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ ; `string'
PUBLIC	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
PUBLIC	__$ArrayPad$
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescriptionKey
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isHasMet
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?ChangeNumFreeTenets@CvPlayer@@QAEXH_N@Z:PROC	; CvPlayer::ChangeNumFreeTenets
;	COMDAT ??_C@_0CN@HDBGCGID@TXT_KEY_NOTIFICATION_SUMMARY_IDE@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CN@HDBGCGID@TXT_KEY_NOTIFICATION_SUMMARY_IDE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_IDEOLOGY_CHOSEN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IOCFBKAF@TXT_KEY_NOTIFICATION_SUMMARY_IDE@
CONST	SEGMENT
??_C@_0CN@IOCFBKAF@TXT_KEY_NOTIFICATION_SUMMARY_IDE@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_SUMMARY_IDEOLOGY_CHANGE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PDGBLPGB@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
CONST	SEGMENT
??_C@_0CL@PDGBLPGB@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_IDEOLOGY_CHOSEN_UNMET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NLKKOP@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
CONST	SEGMENT
??_C@_0CL@NLKKOP@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ DB 'TXT_KEY_NOTIFICATI'
	DB	'ON_IDEOLOGY_CHANGE_UNMET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GLPKJODE@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
CONST	SEGMENT
??_C@_0CF@GLPKJODE@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_IDEOLOGY_CHOSEN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JGMJKCLC@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
CONST	SEGMENT
??_C@_0CF@JGMJKCLC@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@ DB 'TXT_KEY_NOTIFICA'
	DB	'TION_IDEOLOGY_CHANGE', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$7
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
_TEXT	SEGMENT
tv469 = -372						; size = 4
tv468 = -368						; size = 4
tv467 = -364						; size = 4
tv152 = -360						; size = 4
tv293 = -356						; size = 4
tv412 = -352						; size = 4
_this$ = -348						; size = 4
$T235436 = -344						; size = 4
$T235432 = -340						; size = 4
$T235419 = -336						; size = 4
$T235411 = -332						; size = 4
$T235399 = -328						; size = 4
$T235395 = -324						; size = 4
$T235387 = -320						; size = 4
$T235383 = -316						; size = 4
$T235375 = -312						; size = 4
$T235364 = -308						; size = 4
$T235353 = -304						; size = 4
$T235352 = -300						; size = 4
$T235340 = -296						; size = 4
$T235331 = -292						; size = 4
$T235311 = -288						; size = 28
$T235310 = -260						; size = 28
$T235309 = -232						; size = 28
$T235308 = -204						; size = 28
$T235307 = -176						; size = 28
$T235306 = -148						; size = 4
$T235305 = -144						; size = 4
$T235304 = -140						; size = 28
$T235303 = -112						; size = 4
$T235302 = -108						; size = 4
_strBuffer$225407 = -104				; size = 28
_strSummary$225438 = -76				; size = 28
__$ArrayPad$ = -48					; size = 4
_pNotifications$225405 = -44				; size = 4
_kNotifyTeam$225403 = -40				; size = 4
_bHasMet$225404 = -33					; size = 1
_eNotifyPlayer$225399 = -32				; size = 4
_kCurNotifyPlayer$225401 = -28				; size = 4
_iNotifyLoop$225395 = -24				; size = 4
_pkPolicyBranchInfo$225392 = -20			; size = 4
_iFreePolicies$225391 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_eBranchType$ = 8					; size = 4
_bNewValue$ = 12					; size = 1
_bRevolution$ = 16					; size = 1
?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z PROC ; CvPlayerPolicies::SetPolicyBranchUnlocked, COMDAT
; _this$ = ecx

; 3896 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 3897 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 3898 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 3899 : 
; 3900 : 	if(IsPolicyBranchUnlocked(eBranchType) != bNewValue)

	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	cmp	ecx, edx
	je	$LN19@SetPolicyB

; 3901 : 	{
; 3902 : 		// Unlocked?
; 3903 : 		if (bNewValue)

	movzx	eax, BYTE PTR _bNewValue$[ebp]
	test	eax, eax
	je	$LN17@SetPolicyB

; 3904 : 		{
; 3905 : 			int iFreePolicies = PolicyHelpers::GetNumFreePolicies(eBranchType);

	mov	ecx, DWORD PTR _eBranchType$[ebp]
	push	ecx
	call	?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumFreePolicies
	add	esp, 4
	mov	DWORD PTR _iFreePolicies$225391[ebp], eax

; 3906 : 
; 3907 : 			// Late-game tree so want to issue notification?
; 3908 : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	mov	edx, DWORD PTR _eBranchType$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$225392[ebp], eax

; 3909 : 			if(pkPolicyBranchInfo != NULL)

	cmp	DWORD PTR _pkPolicyBranchInfo$225392[ebp], 0
	je	$LN17@SetPolicyB

; 3910 : 			{
; 3911 : 				if (pkPolicyBranchInfo->IsPurchaseByLevel())

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225392[ebp]
	call	?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsPurchaseByLevel
	movzx	eax, al
	test	eax, eax
	je	$LN15@SetPolicyB

; 3912 : 				{
; 3913 : 					m_pPlayer->ChangeNumFreeTenets(iFreePolicies, !bRevolution);

	movzx	ecx, BYTE PTR _bRevolution$[ebp]
	test	ecx, ecx
	sete	dl
	movzx	eax, dl
	push	eax
	mov	ecx, DWORD PTR _iFreePolicies$225391[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?ChangeNumFreeTenets@CvPlayer@@QAEXH_N@Z ; CvPlayer::ChangeNumFreeTenets

; 3914 : 
; 3915 : 					for(int iNotifyLoop = 0; iNotifyLoop < MAX_MAJOR_CIVS; ++iNotifyLoop){

	mov	DWORD PTR _iNotifyLoop$225395[ebp], 0
	jmp	SHORT $LN14@SetPolicyB
$LN13@SetPolicyB:
	mov	eax, DWORD PTR _iNotifyLoop$225395[ebp]
	add	eax, 1
	mov	DWORD PTR _iNotifyLoop$225395[ebp], eax
$LN14@SetPolicyB:
	cmp	DWORD PTR _iNotifyLoop$225395[ebp], 22	; 00000016H
	jge	$LN12@SetPolicyB

; 3916 : 						PlayerTypes eNotifyPlayer = (PlayerTypes) iNotifyLoop;

	mov	ecx, DWORD PTR _iNotifyLoop$225395[ebp]
	mov	DWORD PTR _eNotifyPlayer$225399[ebp], ecx

; 3917 : 						CvPlayerAI& kCurNotifyPlayer = GET_PLAYER(eNotifyPlayer);

	mov	edx, DWORD PTR _eNotifyPlayer$225399[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kCurNotifyPlayer$225401[ebp], edx

; 3918 : 
; 3919 : 						// Issue notification if OTHER than target player
; 3920 : 						if (m_pPlayer->GetID() != eNotifyPlayer)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T235331[ebp], edx
	mov	eax, DWORD PTR $T235331[ebp]
	cmp	eax, DWORD PTR _eNotifyPlayer$225399[ebp]
	je	$LN11@SetPolicyB

; 3921 : 						{
; 3922 : 							CvTeam& kNotifyTeam = GET_TEAM(kCurNotifyPlayer.getTeam());

	mov	ecx, DWORD PTR _kCurNotifyPlayer$225401[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235340[ebp], eax
	mov	eax, DWORD PTR $T235340[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kNotifyTeam$225403[ebp], eax

; 3923 : 							const bool bHasMet = kNotifyTeam.isHasMet(m_pPlayer->getTeam());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR $T235352[ebp], edx
	mov	eax, DWORD PTR $T235352[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235353[ebp], eax
	mov	edx, DWORD PTR $T235353[ebp]
	push	edx
	mov	ecx, DWORD PTR _kNotifyTeam$225403[ebp]
	call	?isHasMet@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isHasMet
	mov	BYTE PTR _bHasMet$225404[ebp], al

; 3924 : 
; 3925 : 							CvNotifications* pNotifications = kCurNotifyPlayer.GetNotifications();

	mov	ecx, DWORD PTR _kCurNotifyPlayer$225401[ebp]
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	DWORD PTR _pNotifications$225405[ebp], eax

; 3926 : 							if(pNotifications)

	cmp	DWORD PTR _pNotifications$225405[ebp], 0
	je	$LN11@SetPolicyB

; 3927 : 							{
; 3928 : 								CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3929 : 								if(bHasMet)

	movzx	eax, BYTE PTR _bHasMet$225404[ebp]
	test	eax, eax
	je	$LN9@SetPolicyB

; 3930 : 								{
; 3931 : 									if (bRevolution)

	movzx	ecx, BYTE PTR _bRevolution$[ebp]
	test	ecx, ecx
	je	SHORT $LN55@SetPolicyB

; 3932 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHANGE", m_pPlayer->getCivilizationShortDescriptionKey(), pkPolicyBranchInfo->GetDescriptionKey());

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225392[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235302[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR $T235303[ebp], eax
	lea	eax, DWORD PTR $T235302[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235303[ebp]
	push	ecx
	push	OFFSET ??_C@_0CF@JGMJKCLC@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
	lea	edx, DWORD PTR $T235304[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv412[ebp], eax
	mov	eax, DWORD PTR tv412[ebp]
	mov	DWORD PTR $T235364[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR $T235364[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T235304[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3933 : 									else

	jmp	SHORT $LN7@SetPolicyB

; 3934 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHOSEN", m_pPlayer->getCivilizationShortDescriptionKey(), pkPolicyBranchInfo->GetDescriptionKey());

$LN55@SetPolicyB:
	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225392[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235305[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?getCivilizationShortDescriptionKey@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescriptionKey
	mov	DWORD PTR $T235306[ebp], eax
	lea	eax, DWORD PTR $T235305[ebp]
	push	eax
	lea	ecx, DWORD PTR $T235306[ebp]
	push	ecx
	push	OFFSET ??_C@_0CF@GLPKJODE@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
	lea	edx, DWORD PTR $T235307[ebp]
	push	edx
	call	??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ; GetLocalizedText<char const *,char const *>
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv293[ebp], eax
	mov	eax, DWORD PTR tv293[ebp]
	mov	DWORD PTR $T235375[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T235375[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T235307[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@SetPolicyB:

; 3935 : 								}
; 3936 : 								else

	jmp	$LN6@SetPolicyB
$LN9@SetPolicyB:

; 3937 : 								{
; 3938 : 									if (bRevolution)

	movzx	edx, BYTE PTR _bRevolution$[ebp]
	test	edx, edx
	je	SHORT $LN5@SetPolicyB

; 3939 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHANGE_UNMET", pkPolicyBranchInfo->GetDescriptionKey());

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225392[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235383[ebp], eax
	mov	eax, DWORD PTR $T235383[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@NLKKOP@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
	lea	ecx, DWORD PTR $T235308[ebp]
	push	ecx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv152[ebp], eax
	mov	edx, DWORD PTR tv152[ebp]
	mov	DWORD PTR $T235387[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR $T235387[ebp]
	push	eax
	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T235308[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3940 : 									else

	jmp	SHORT $LN6@SetPolicyB
$LN5@SetPolicyB:

; 3941 : 										strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_IDEOLOGY_CHOSEN_UNMET", pkPolicyBranchInfo->GetDescriptionKey());

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225392[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235395[ebp], eax
	mov	ecx, DWORD PTR $T235395[ebp]
	push	ecx
	push	OFFSET ??_C@_0CL@PDGBLPGB@TXT_KEY_NOTIFICATION_IDEOLOGY_CH@
	lea	edx, DWORD PTR $T235309[ebp]
	push	edx
	call	??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ; GetLocalizedText<char const *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv467[ebp], eax
	mov	eax, DWORD PTR tv467[ebp]
	mov	DWORD PTR $T235399[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T235399[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T235309[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@SetPolicyB:

; 3942 : 								}
; 3943 : 
; 3944 : 								CvString strSummary;

	lea	ecx, DWORD PTR _strSummary$225438[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3945 : 								if (bRevolution)

	movzx	edx, BYTE PTR _bRevolution$[ebp]
	test	edx, edx
	je	SHORT $LN3@SetPolicyB

; 3946 : 									strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_IDEOLOGY_CHANGE");

	push	OFFSET ??_C@_0CN@IOCFBKAF@TXT_KEY_NOTIFICATION_SUMMARY_IDE@
	lea	eax, DWORD PTR $T235310[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv468[ebp], eax
	mov	ecx, DWORD PTR tv468[ebp]
	mov	DWORD PTR $T235411[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR $T235411[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$225438[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235310[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3947 : 								else

	jmp	SHORT $LN91@SetPolicyB
$LN3@SetPolicyB:

; 3948 : 									strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_IDEOLOGY_CHOSEN");

	push	OFFSET ??_C@_0CN@HDBGCGID@TXT_KEY_NOTIFICATION_SUMMARY_IDE@
	lea	eax, DWORD PTR $T235311[ebp]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	mov	DWORD PTR tv469[ebp], eax
	mov	ecx, DWORD PTR tv469[ebp]
	mov	DWORD PTR $T235419[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR $T235419[ebp]
	push	edx
	lea	ecx, DWORD PTR _strSummary$225438[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T235311[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3949 : 
; 3950 : 								pNotifications->Add(NOTIFICATION_IDEOLOGY_CHOSEN, strBuffer, strSummary, -1, -1, m_pPlayer->GetID());

$LN91@SetPolicyB:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T235432[ebp], edx
	lea	ecx, DWORD PTR _strSummary$225438[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235436[ebp], eax
	push	-1
	mov	eax, DWORD PTR $T235432[ebp]
	push	eax
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T235436[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	-1871397394				; 9074bdeeH
	mov	ecx, DWORD PTR _pNotifications$225405[ebp]
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 3951 : 							}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strSummary$225438[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN11@SetPolicyB:

; 3952 : 						}
; 3953 : 					}

	jmp	$LN13@SetPolicyB
$LN12@SetPolicyB:

; 3954 : 				}
; 3955 : 				else

	jmp	SHORT $LN17@SetPolicyB
$LN15@SetPolicyB:

; 3956 : 				{
; 3957 : 					m_pPlayer->ChangeNumFreePolicies(iFreePolicies);

	mov	edx, DWORD PTR _iFreePolicies$225391[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?ChangeNumFreePolicies@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeNumFreePolicies
$LN17@SetPolicyB:

; 3958 : 				}
; 3959 : 			}
; 3960 : 		}
; 3961 : 
; 3962 : 		m_pabPolicyBranchUnlocked[eBranchType] = bNewValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _eBranchType$[ebp]
	mov	cl, BYTE PTR _bNewValue$[ebp]
	mov	BYTE PTR [edx+eax], cl
$LN19@SetPolicyB:

; 3963 : 	}
; 3964 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$0:
	lea	ecx, DWORD PTR _strBuffer$225407[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$1:
	lea	ecx, DWORD PTR $T235304[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$2:
	lea	ecx, DWORD PTR $T235307[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$3:
	lea	ecx, DWORD PTR $T235308[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$4:
	lea	ecx, DWORD PTR $T235309[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$5:
	lea	ecx, DWORD PTR _strSummary$225438[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$6:
	lea	ecx, DWORD PTR $T235310[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z$7:
	lea	ecx, DWORD PTR $T235311[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-364]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ENDP ; CvPlayerPolicies::SetPolicyBranchUnlocked
PUBLIC	?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesUnlocked
; Function compile flags: /Odtp
;	COMDAT ?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iBranchLoop$225450 = -8				; size = 4
_iCount$ = -4						; size = 4
?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ PROC ; CvPlayerPolicies::GetNumPolicyBranchesUnlocked, COMDAT
; _this$ = ecx

; 3968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 3969 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 3970 : 
; 3971 : #ifdef AUI_WARNING_FIXES
; 3972 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 3973 : #else
; 3974 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$225450[ebp], 0
	jmp	SHORT $LN4@GetNumPoli@3
$LN3@GetNumPoli@3:
	mov	eax, DWORD PTR _iBranchLoop$225450[ebp]
	add	eax, 1
	mov	DWORD PTR _iBranchLoop$225450[ebp], eax
$LN4@GetNumPoli@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$225450[ebp], eax
	jge	SHORT $LN2@GetNumPoli@3

; 3975 : #endif
; 3976 : 	{
; 3977 : 		if(IsPolicyBranchUnlocked((PolicyBranchTypes) iBranchLoop))

	mov	edx, DWORD PTR _iBranchLoop$225450[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@GetNumPoli@3

; 3978 : 		{
; 3979 : 			iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx
$LN1@GetNumPoli@3:

; 3980 : 		}
; 3981 : 	}

	jmp	SHORT $LN3@GetNumPoli@3
$LN2@GetNumPoli@3:

; 3982 : 
; 3983 : 	return iCount;

	mov	eax, DWORD PTR _iCount$[ebp]

; 3984 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPolicyBranchesUnlocked@CvPlayerPolicies@@QBEHXZ ENDP ; CvPlayerPolicies::GetNumPolicyBranchesUnlocked
_TEXT	ENDS
PUBLIC	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
PUBLIC	?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchBlocked
EXTRN	?ChangeAnarchyNumTurns@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::ChangeAnarchyNumTurns
; Function compile flags: /Odtp
;	COMDAT ?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
tv201 = -64						; size = 4
_this$ = -60						; size = 4
$T235478 = -56						; size = 4
$T235474 = -52						; size = 4
$T235473 = -48						; size = 4
$T235464 = -44						; size = 4
_eOtherBranch$225486 = -40				; size = 4
_pkOtherPolicyBranchInfo$225488 = -36			; size = 4
_iOtherBranchLoop$225482 = -32				; size = 4
_eActivateBranch$225476 = -28				; size = 4
_pkActivateBranchInfo$225478 = -24			; size = 4
_pkDisablePolicyBranchInfo$225469 = -20			; size = 4
_eDisableBranch$225467 = -16				; size = 4
_iNumTurnsAnarchy$225462 = -12				; size = 4
_bUnlockBranch$ = -5					; size = 1
_iBranchLoop$ = -4					; size = 4
_eBranchType$ = 8					; size = 4
?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::DoSwitchToPolicyBranch, COMDAT
; _this$ = ecx

; 3988 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 3989 : 	// Must be unlocked
; 3990 : 	if(!IsPolicyBranchUnlocked(eBranchType))

	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@DoSwitchTo

; 3991 : 	{
; 3992 : 		return;

	jmp	$LN26@DoSwitchTo
$LN25@DoSwitchTo:

; 3993 : 	}
; 3994 : 
; 3995 : 	// Is this branch blocked?
; 3996 : 	if(IsPolicyBranchBlocked(eBranchType))

	mov	edx, DWORD PTR _eBranchType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchBlocked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@DoSwitchTo

; 3997 : 	{
; 3998 : 		// Anarchy time!
; 3999 : 		int iNumTurnsAnarchy = /*1*/ GC.getSWITCH_POLICY_BRANCHES_ANARCHY_TURNS();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6976
	mov	DWORD PTR _iNumTurnsAnarchy$225462[ebp], ecx

; 4000 : 		GetPlayer()->ChangeAnarchyNumTurns(iNumTurnsAnarchy);

	mov	edx, DWORD PTR _iNumTurnsAnarchy$225462[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?ChangeAnarchyNumTurns@CvPlayer@@QAEXH@Z ; CvPlayer::ChangeAnarchyNumTurns

; 4001 : 
; 4002 : 		// Turn off blocking
; 4003 : 		SetPolicyBranchBlocked(eBranchType, false);

	push	0
	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
$LN24@DoSwitchTo:

; 4004 : 	}
; 4005 : 
; 4006 : 	// Does THIS Branch block any other branch?
; 4007 : #ifdef AUI_WARNING_FIXES
; 4008 : 	uint iBranchLoop;
; 4009 : #else
; 4010 : 	int iBranchLoop;
; 4011 : #endif
; 4012 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$[ebp], 0
	jmp	SHORT $LN23@DoSwitchTo
$LN22@DoSwitchTo:
	mov	ecx, DWORD PTR _iBranchLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBranchLoop$[ebp], ecx
$LN23@DoSwitchTo:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$[ebp], eax
	jge	SHORT $LN21@DoSwitchTo

; 4013 : 	{
; 4014 : 		const PolicyBranchTypes eDisableBranch = static_cast<PolicyBranchTypes>(iBranchLoop);

	mov	eax, DWORD PTR _iBranchLoop$[ebp]
	mov	DWORD PTR _eDisableBranch$225467[ebp], eax

; 4015 : 		CvPolicyBranchEntry* pkDisablePolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	mov	ecx, DWORD PTR _eBranchType$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkDisablePolicyBranchInfo$225469[ebp], eax

; 4016 : 		if(pkDisablePolicyBranchInfo)

	cmp	DWORD PTR _pkDisablePolicyBranchInfo$225469[ebp], 0
	je	SHORT $LN20@DoSwitchTo

; 4017 : 		{
; 4018 : 			if(pkDisablePolicyBranchInfo->GetPolicyBranchDisables(eDisableBranch) > 0)

	mov	edx, DWORD PTR _eDisableBranch$225467[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkDisablePolicyBranchInfo$225469[ebp]
	call	?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z ; CvPolicyBranchEntry::GetPolicyBranchDisables
	test	eax, eax
	jle	SHORT $LN20@DoSwitchTo

; 4019 : 			{
; 4020 : 				SetPolicyBranchBlocked(eDisableBranch, true);

	push	1
	mov	eax, DWORD PTR _eDisableBranch$225467[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
$LN20@DoSwitchTo:

; 4021 : 			}
; 4022 : 		}
; 4023 : 
; 4024 : 	}

	jmp	SHORT $LN22@DoSwitchTo
$LN21@DoSwitchTo:

; 4025 : 
; 4026 : //	std::vector<PolicyBranchTypes> veOtherPoliciesToUnblock;
; 4027 : 	bool bUnlockBranch;
; 4028 : 
; 4029 : 	// Do a pass over the Policies to see if there are any we can safely unblock
; 4030 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$[ebp], 0
	jmp	SHORT $LN18@DoSwitchTo
$LN17@DoSwitchTo:
	mov	ecx, DWORD PTR _iBranchLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBranchLoop$[ebp], ecx
$LN18@DoSwitchTo:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$[ebp], eax
	jge	$LN16@DoSwitchTo

; 4031 : 	{
; 4032 : 		const PolicyBranchTypes eActivateBranch = static_cast<PolicyBranchTypes>(iBranchLoop);

	mov	eax, DWORD PTR _iBranchLoop$[ebp]
	mov	DWORD PTR _eActivateBranch$225476[ebp], eax

; 4033 : 		CvPolicyBranchEntry* pkActivateBranchInfo = GC.getPolicyBranchInfo(eActivateBranch);

	mov	ecx, DWORD PTR _eActivateBranch$225476[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkActivateBranchInfo$225478[ebp], eax

; 4034 : 		if(pkActivateBranchInfo)

	cmp	DWORD PTR _pkActivateBranchInfo$225478[ebp], 0
	je	$LN15@DoSwitchTo

; 4035 : 		{
; 4036 : 			// Must be activatable
; 4037 : 			if(!IsPolicyBranchUnlocked(eActivateBranch))

	mov	edx, DWORD PTR _eActivateBranch$225476[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@DoSwitchTo

; 4038 : 			{
; 4039 : 				continue;

	jmp	SHORT $LN17@DoSwitchTo
$LN14@DoSwitchTo:

; 4040 : 			}
; 4041 : 
; 4042 : 			// Must be blocked now
; 4043 : 			if(!IsPolicyBranchBlocked(eActivateBranch))

	mov	ecx, DWORD PTR _eActivateBranch$225476[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchBlocked
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@DoSwitchTo

; 4044 : 			{
; 4045 : 				continue;

	jmp	SHORT $LN17@DoSwitchTo
$LN13@DoSwitchTo:

; 4046 : 			}
; 4047 : 
; 4048 : 			// Let's try to unblock this
; 4049 : 			bUnlockBranch = true;

	mov	BYTE PTR _bUnlockBranch$[ebp], 1

; 4050 : 
; 4051 : 			// Loop through all Policies we have and make sure they don't interfere with us
; 4052 : #ifdef AUI_WARNING_FIXES
; 4053 : 			for (uint iOtherBranchLoop = 0; iOtherBranchLoop < m_pPolicies->GetNumPolicyBranches(); iOtherBranchLoop++)
; 4054 : #else
; 4055 : 			for(int iOtherBranchLoop = 0; iOtherBranchLoop < m_pPolicies->GetNumPolicyBranches(); iOtherBranchLoop++)

	mov	DWORD PTR _iOtherBranchLoop$225482[ebp], 0
	jmp	SHORT $LN12@DoSwitchTo
$LN11@DoSwitchTo:
	mov	eax, DWORD PTR _iOtherBranchLoop$225482[ebp]
	add	eax, 1
	mov	DWORD PTR _iOtherBranchLoop$225482[ebp], eax
$LN12@DoSwitchTo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iOtherBranchLoop$225482[ebp], eax
	jge	$LN10@DoSwitchTo

; 4056 : #endif
; 4057 : 			{
; 4058 : 				const PolicyBranchTypes eOtherBranch = static_cast<PolicyBranchTypes>(iOtherBranchLoop);

	mov	edx, DWORD PTR _iOtherBranchLoop$225482[ebp]
	mov	DWORD PTR _eOtherBranch$225486[ebp], edx

; 4059 : 				CvPolicyBranchEntry* pkOtherPolicyBranchInfo = GC.getPolicyBranchInfo(eOtherBranch);

	mov	eax, DWORD PTR _eOtherBranch$225486[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkOtherPolicyBranchInfo$225488[ebp], eax

; 4060 : 				if(pkOtherPolicyBranchInfo)

	cmp	DWORD PTR _pkOtherPolicyBranchInfo$225488[ebp], 0
	je	SHORT $LN9@DoSwitchTo

; 4061 : 				{
; 4062 : 					// Don't test branch against itself
; 4063 : 					if(eActivateBranch != eOtherBranch)

	mov	ecx, DWORD PTR _eActivateBranch$225476[ebp]
	cmp	ecx, DWORD PTR _eOtherBranch$225486[ebp]
	je	SHORT $LN9@DoSwitchTo

; 4064 : 					{
; 4065 : 						// Is this other branch unlocked and unblocked?
; 4066 : 						if(IsPolicyBranchUnlocked(eOtherBranch))

	mov	edx, DWORD PTR _eOtherBranch$225486[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@DoSwitchTo

; 4067 : 						{
; 4068 : 							if(!IsPolicyBranchBlocked(eOtherBranch))

	mov	ecx, DWORD PTR _eOtherBranch$225486[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchBlocked
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@DoSwitchTo

; 4069 : 							{
; 4070 : 								// Do we block them?
; 4071 : 								if(pkActivateBranchInfo->GetPolicyBranchDisables(eOtherBranch) > 0)

	mov	eax, DWORD PTR _eOtherBranch$225486[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkActivateBranchInfo$225478[ebp]
	call	?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z ; CvPolicyBranchEntry::GetPolicyBranchDisables
	test	eax, eax
	jle	SHORT $LN5@DoSwitchTo

; 4072 : 								{
; 4073 : 									bUnlockBranch = false;

	mov	BYTE PTR _bUnlockBranch$[ebp], 0
$LN5@DoSwitchTo:

; 4074 : 								}
; 4075 : 								// Do they block us?
; 4076 : 								if(pkOtherPolicyBranchInfo->GetPolicyBranchDisables(eActivateBranch) > 0)

	mov	ecx, DWORD PTR _eActivateBranch$225476[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkOtherPolicyBranchInfo$225488[ebp]
	call	?GetPolicyBranchDisables@CvPolicyBranchEntry@@QBEHH@Z ; CvPolicyBranchEntry::GetPolicyBranchDisables
	test	eax, eax
	jle	SHORT $LN7@DoSwitchTo

; 4077 : 								{
; 4078 : 									bUnlockBranch = false;

	mov	BYTE PTR _bUnlockBranch$[ebp], 0
$LN7@DoSwitchTo:

; 4079 : 								}
; 4080 : 							}
; 4081 : 						}
; 4082 : 
; 4083 : 						// We've identified that eActivateBranch conflicts with something, so leave it be
; 4084 : 						if(!bUnlockBranch)

	movzx	edx, BYTE PTR _bUnlockBranch$[ebp]
	test	edx, edx
	jne	SHORT $LN9@DoSwitchTo

; 4085 : 						{
; 4086 : 							break;

	jmp	SHORT $LN10@DoSwitchTo
$LN9@DoSwitchTo:

; 4087 : 						}
; 4088 : 					}
; 4089 : 				}
; 4090 : 			}

	jmp	$LN11@DoSwitchTo
$LN10@DoSwitchTo:

; 4091 : 
; 4092 : 			// We know that eActivateBranch doesn't affect anything, so unblock it!
; 4093 : 			if(bUnlockBranch)

	movzx	eax, BYTE PTR _bUnlockBranch$[ebp]
	test	eax, eax
	je	SHORT $LN15@DoSwitchTo

; 4094 : 			{
; 4095 : 				SetPolicyBranchBlocked(eActivateBranch, false);

	push	0
	mov	ecx, DWORD PTR _eActivateBranch$225476[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ; CvPlayerPolicies::SetPolicyBranchBlocked
$LN15@DoSwitchTo:

; 4096 : 			}
; 4097 : 		}
; 4098 : 	}

	jmp	$LN17@DoSwitchTo
$LN16@DoSwitchTo:

; 4099 : 
; 4100 : 	// This Dirty bit must only be set when changing something for the active player
; 4101 : 	if(GC.getGame().getActivePlayer() == GetPlayer()->GetID())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235464[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	DWORD PTR $T235473[ebp], eax
	mov	eax, DWORD PTR $T235473[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T235474[ebp], ecx
	mov	ecx, DWORD PTR $T235464[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR $T235474[ebp]
	jne	SHORT $LN26@DoSwitchTo

; 4102 : 	{
; 4103 : 		GC.GetEngineUserInterface()->setDirty(Policies_DIRTY_BIT, true);

	mov	edx, DWORD PTR $T235478[ebp]
	mov	DWORD PTR tv201[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv201[ebp], eax
	push	1
	push	32					; 00000020H
	mov	ecx, DWORD PTR tv201[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv201[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax
$LN26@DoSwitchTo:

; 4104 : 	}
; 4105 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoSwitchToPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::DoSwitchToPolicyBranch
_TEXT	ENDS
EXTRN	?processPolicies@CvPlayer@@IAEXW4PolicyTypes@@H@Z:PROC ; CvPlayer::processPolicies
; Function compile flags: /Odtp
;	COMDAT ?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_pkPolicyInfo$225514 = -20				; size = 4
_ePolicy$225512 = -16					; size = 4
_iPolicyLoop$225508 = -12				; size = 4
_iPolicyEffectChange$225506 = -8			; size = 4
_pkPolicyBranchEntry$ = -4				; size = 4
_eBranchType$ = 8					; size = 4
_bValue$ = 12						; size = 1
?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z PROC ; CvPlayerPolicies::SetPolicyBranchBlocked, COMDAT
; _this$ = ecx

; 4109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4110 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4111 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4112 : 
; 4113 : 	CvPolicyBranchEntry* pkPolicyBranchEntry = GC.getPolicyBranchInfo(eBranchType);

	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchEntry$[ebp], eax

; 4114 : 	if(pkPolicyBranchEntry)

	cmp	DWORD PTR _pkPolicyBranchEntry$[ebp], 0
	je	$LN11@SetPolicyB@2

; 4115 : 	{
; 4116 : 		if(bValue != IsPolicyBranchBlocked(eBranchType))

	movzx	esi, BYTE PTR _bValue$[ebp]
	mov	ecx, DWORD PTR _eBranchType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchBlocked
	movzx	edx, al
	cmp	esi, edx
	je	$LN11@SetPolicyB@2

; 4117 : 		{
; 4118 : 			m_pabPolicyBranchBlocked[eBranchType] = bValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _eBranchType$[ebp]
	mov	al, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 4119 : 
; 4120 : 			int iPolicyEffectChange = bValue ? -1 : 1;

	movzx	ecx, BYTE PTR _bValue$[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 1
	mov	DWORD PTR _iPolicyEffectChange$225506[ebp], ecx

; 4121 : 
; 4122 : 			if(iPolicyEffectChange != 0)

	je	$LN11@SetPolicyB@2

; 4123 : 			{
; 4124 : 				// Set Policies in this branch as blocked
; 4125 : #ifdef AUI_WARNING_FIXES
; 4126 : 				for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4127 : #else
; 4128 : 				for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$225508[ebp], 0
	jmp	SHORT $LN7@SetPolicyB@2
$LN6@SetPolicyB@2:
	mov	edx, DWORD PTR _iPolicyLoop$225508[ebp]
	add	edx, 1
	mov	DWORD PTR _iPolicyLoop$225508[ebp], edx
$LN7@SetPolicyB@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$225508[ebp], eax
	jge	SHORT $LN11@SetPolicyB@2

; 4129 : #endif
; 4130 : 				{
; 4131 : 					const PolicyTypes ePolicy = static_cast<PolicyTypes>(iPolicyLoop);

	mov	eax, DWORD PTR _iPolicyLoop$225508[ebp]
	mov	DWORD PTR _ePolicy$225512[ebp], eax

; 4132 : 					CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	mov	ecx, DWORD PTR _ePolicy$225512[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$225514[ebp], eax

; 4133 : 					if(pkPolicyInfo)

	cmp	DWORD PTR _pkPolicyInfo$225514[ebp], 0
	je	SHORT $LN4@SetPolicyB@2

; 4134 : 					{
; 4135 : 						if(eBranchType == (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType() ||	// Branch type matches
; 4136 : 						        pkPolicyBranchEntry->GetFreePolicy() == ePolicy ||		// Free Policy with this branch
; 4137 : 						        pkPolicyBranchEntry->GetFreeFinishingPolicy() == ePolicy)

	mov	ecx, DWORD PTR _pkPolicyInfo$225514[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	DWORD PTR _eBranchType$[ebp], eax
	je	SHORT $LN2@SetPolicyB@2
	mov	ecx, DWORD PTR _pkPolicyBranchEntry$[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	cmp	eax, DWORD PTR _ePolicy$225512[ebp]
	je	SHORT $LN2@SetPolicyB@2
	mov	ecx, DWORD PTR _pkPolicyBranchEntry$[ebp]
	call	?GetFreeFinishingPolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreeFinishingPolicy
	cmp	eax, DWORD PTR _ePolicy$225512[ebp]
	jne	SHORT $LN4@SetPolicyB@2
$LN2@SetPolicyB@2:

; 4138 : 						{
; 4139 : 							//ChangePolicyBlockedCount(ePolicy, iPolicyEffectChange);
; 4140 : 
; 4141 : 							// Activate/Deactivate Policies
; 4142 : 							if(HasPolicy(ePolicy))

	mov	edx, DWORD PTR _ePolicy$225512[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@SetPolicyB@2

; 4143 : 							{
; 4144 : 								GetPlayer()->processPolicies(ePolicy, iPolicyEffectChange);

	mov	ecx, DWORD PTR _iPolicyEffectChange$225506[ebp]
	push	ecx
	mov	edx, DWORD PTR _ePolicy$225512[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvPlayerPolicies@@QAEPAVCvPlayer@@XZ ; CvPlayerPolicies::GetPlayer
	mov	ecx, eax
	call	?processPolicies@CvPlayer@@IAEXW4PolicyTypes@@H@Z ; CvPlayer::processPolicies
$LN4@SetPolicyB@2:

; 4145 : 							}
; 4146 : 						}
; 4147 : 					}
; 4148 : 				}

	jmp	$LN6@SetPolicyB@2
$LN11@SetPolicyB@2:

; 4149 : 			}
; 4150 : 		}
; 4151 : 	}
; 4152 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?SetPolicyBranchBlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ENDP ; CvPlayerPolicies::SetPolicyBranchBlocked
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBranchType$ = 8					; size = 4
?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBranchBlocked, COMDAT
; _this$ = ecx

; 4156 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4157 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4158 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4159 : 	return m_pabPolicyBranchBlocked[eBranchType];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _eBranchType$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 4160 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBranchBlocked
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_eBranch$ = -4						; size = 4
_eType$ = 8						; size = 4
?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBlocked, COMDAT
; _this$ = ecx

; 4164 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4165 : 	CvAssertMsg(eType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4166 : 	CvAssertMsg(eType < m_pPolicies->GetNumPolicies(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4167 : 
; 4168 : 	// Get the policy branch we have to check.
; 4169 : 	PolicyBranchTypes eBranch = m_paePolicyBlockedBranchCheck[eType];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR _eType$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _eBranch$[ebp], eax

; 4170 : 	if (eBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eBranch$[ebp], -1
	jne	SHORT $LN1@IsPolicyBl

; 4171 : 		return false;	// Policy has no branch

	xor	al, al
	jmp	SHORT $LN2@IsPolicyBl
$LN1@IsPolicyBl:

; 4172 : 
; 4173 : 	return IsPolicyBranchBlocked(eBranch);

	mov	ecx, DWORD PTR _eBranch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchBlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchBlocked
$LN2@IsPolicyBl:

; 4174 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsPolicyBlocked@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBlocked
_TEXT	ENDS
PUBLIC	?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::ClearPolicyBranch
PUBLIC	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
PUBLIC	?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoSwitchIdeologies
EXTRN	?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z:PROC ; CvPlayerCulture::SetTurnIdeologySwitch
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?DoPublicOpinion@CvPlayerCulture@@QAEXXZ:PROC	; CvPlayerCulture::DoPublicOpinion
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
; Function compile flags: /Odtp
;	COMDAT ?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
tv149 = -56						; size = 4
tv155 = -52						; size = 4
_this$ = -48						; size = 4
$T235522 = -44						; size = 4
$T235518 = -40						; size = 4
$T235509 = -36						; size = 4
$T235505 = -32						; size = 4
$T235499 = -28						; size = 4
$T235492 = -24						; size = 4
$T235488 = -20						; size = 4
$T235487 = -16						; size = 4
_iOldBranchTenets$ = -12				; size = 4
_eOldBranchType$ = -8					; size = 4
_iNewBranchTenets$ = -4					; size = 4
_eNewBranchType$ = 8					; size = 4
?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::DoSwitchIdeologies, COMDAT
; _this$ = ecx

; 4178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 4179 : 	PolicyBranchTypes eOldBranchType = GetLateGamePolicyTree();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eOldBranchType$[ebp], eax

; 4180 : 	CvAssertMsg (eOldBranchType != eNewBranchType && eNewBranchType != NO_POLICY_BRANCH_TYPE && eOldBranchType != NO_POLICY_BRANCH_TYPE, "Illegal time for Ideology change");
; 4181 : 
; 4182 : 	int iOldBranchTenets = GetNumPoliciesOwnedInBranch(eOldBranchType);

	mov	eax, DWORD PTR _eOldBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumPoliciesOwnedInBranch@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::GetNumPoliciesOwnedInBranch
	mov	DWORD PTR _iOldBranchTenets$[ebp], eax

; 4183 : 	int iNewBranchTenets = max(0, iOldBranchTenets - GC.getSWITCH_POLICY_BRANCHES_TENETS_LOST());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6980
	mov	DWORD PTR $T235492[ebp], ecx
	mov	edx, DWORD PTR _iOldBranchTenets$[ebp]
	sub	edx, DWORD PTR $T235492[ebp]
	mov	DWORD PTR $T235487[ebp], edx
	mov	DWORD PTR $T235488[ebp], 0
	mov	eax, DWORD PTR $T235488[ebp]
	cmp	eax, DWORD PTR $T235487[ebp]
	jge	SHORT $LN8@DoSwitchId
	lea	ecx, DWORD PTR $T235487[ebp]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN9@DoSwitchId
$LN8@DoSwitchId:
	lea	edx, DWORD PTR $T235488[ebp]
	mov	DWORD PTR tv155[ebp], edx
$LN9@DoSwitchId:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T235499[ebp], eax
	mov	ecx, DWORD PTR $T235499[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iNewBranchTenets$[ebp], edx

; 4184 : 
; 4185 : 	ClearPolicyBranch(eOldBranchType);

	mov	eax, DWORD PTR _eOldBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::ClearPolicyBranch

; 4186 : 	SetPolicyBranchUnlocked(eOldBranchType, false, false);

	push	0
	push	0
	mov	ecx, DWORD PTR _eOldBranchType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 4187 : 
; 4188 : 	SetPolicyBranchUnlocked(eNewBranchType, true, true /*bRevolution*/);

	push	1
	push	1
	mov	edx, DWORD PTR _eNewBranchType$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetPolicyBranchUnlocked@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N1@Z ; CvPlayerPolicies::SetPolicyBranchUnlocked

; 4189 : 	m_pPlayer->GetCulture()->DoPublicOpinion();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?DoPublicOpinion@CvPlayerCulture@@QAEXXZ ; CvPlayerCulture::DoPublicOpinion

; 4190 : 	m_pPlayer->GetCulture()->SetTurnIdeologySwitch(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235505[ebp], ecx
	mov	ecx, DWORD PTR $T235505[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?SetTurnIdeologySwitch@CvPlayerCulture@@QAEXH@Z ; CvPlayerCulture::SetTurnIdeologySwitch

; 4191 : 	//m_pPlayer->setJONSCulture(0); - No culture reset ~EAP
; 4192 : 	m_pPlayer->ChangeNumFreeTenets(iNewBranchTenets, false /*bCountAsFreePolicies*/);

	push	0
	mov	eax, DWORD PTR _iNewBranchTenets$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?ChangeNumFreeTenets@CvPlayer@@QAEXH_N@Z ; CvPlayer::ChangeNumFreeTenets

; 4193 : 
; 4194 : 	if (GC.getGame().getActivePlayer() == m_pPlayer->GetID())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235509[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T235518[ebp], edx
	mov	ecx, DWORD PTR $T235509[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	eax, DWORD PTR $T235518[ebp]
	jne	SHORT $LN2@DoSwitchId

; 4195 : 	{
; 4196 : 		DLLUI->setDirty(Policies_DIRTY_BIT, true);

	mov	eax, DWORD PTR $T235522[ebp]
	mov	DWORD PTR tv149[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv149[ebp], ecx
	push	1
	push	32					; 00000020H
	mov	edx, DWORD PTR tv149[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv149[ebp]
	mov	edx, DWORD PTR [eax+260]
	call	edx
$LN2@DoSwitchId:

; 4197 : 	}
; 4198 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoSwitchIdeologies@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::DoSwitchIdeologies
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_eLoopBranch$225552 = -16				; size = 4
_eLoopPolicy$225548 = -12				; size = 4
_pkLoopPolicyInfo$225550 = -8				; size = 4
_iPolicyLoop$225544 = -4				; size = 4
_eBranchType$ = 8					; size = 4
?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::ClearPolicyBranch, COMDAT
; _this$ = ecx

; 4202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4203 : 	// count the policies within the branch
; 4204 : #ifdef AUI_WARNING_FIXES
; 4205 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4206 : #else
; 4207 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$225544[ebp], 0
	jmp	SHORT $LN5@ClearPolic
$LN4@ClearPolic:
	mov	eax, DWORD PTR _iPolicyLoop$225544[ebp]
	add	eax, 1
	mov	DWORD PTR _iPolicyLoop$225544[ebp], eax
$LN5@ClearPolic:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$225544[ebp], eax
	jge	SHORT $LN6@ClearPolic

; 4208 : #endif
; 4209 : 	{
; 4210 : 		const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);

	mov	ecx, DWORD PTR _iPolicyLoop$225544[ebp]
	mov	DWORD PTR _eLoopPolicy$225548[ebp], ecx

; 4211 : 		CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	mov	edx, DWORD PTR _eLoopPolicy$225548[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkLoopPolicyInfo$225550[ebp], eax

; 4212 : 		if(pkLoopPolicyInfo)

	cmp	DWORD PTR _pkLoopPolicyInfo$225550[ebp], 0
	je	SHORT $LN2@ClearPolic

; 4213 : 		{
; 4214 : 			PolicyBranchTypes eLoopBranch = (PolicyBranchTypes)pkLoopPolicyInfo->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkLoopPolicyInfo$225550[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eLoopBranch$225552[ebp], eax

; 4215 : 			if (eLoopBranch == eBranchType)

	mov	eax, DWORD PTR _eLoopBranch$225552[ebp]
	cmp	eax, DWORD PTR _eBranchType$[ebp]
	jne	SHORT $LN2@ClearPolic

; 4216 : 			{
; 4217 : 				m_pPlayer->setHasPolicy(eLoopPolicy, false);

	push	0
	mov	ecx, DWORD PTR _eLoopPolicy$225548[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?setHasPolicy@CvPlayer@@QAEXW4PolicyTypes@@_N@Z ; CvPlayer::setHasPolicy
$LN2@ClearPolic:

; 4218 : 			}
; 4219 : 		}

	jmp	SHORT $LN4@ClearPolic
$LN6@ClearPolic:

; 4220 : 	}
; 4221 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::ClearPolicyBranch
_TEXT	ENDS
PUBLIC	?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchFinished
PUBLIC	?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesFinished
; Function compile flags: /Odtp
;	COMDAT ?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_iBranchLoop$225560 = -12				; size = 4
_iNumBranchesFinished$ = -8				; size = 4
_eLoopBranch$ = -4					; size = 4
?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ PROC ; CvPlayerPolicies::GetNumPolicyBranchesFinished, COMDAT
; _this$ = ecx

; 4225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 4226 : 	int iNumBranchesFinished = 0;

	mov	DWORD PTR _iNumBranchesFinished$[ebp], 0

; 4227 : 
; 4228 : 	PolicyBranchTypes eLoopBranch;
; 4229 : #ifdef AUI_WARNING_FIXES
; 4230 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4231 : #else
; 4232 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$225560[ebp], 0
	jmp	SHORT $LN4@GetNumPoli@4
$LN3@GetNumPoli@4:
	mov	eax, DWORD PTR _iBranchLoop$225560[ebp]
	add	eax, 1
	mov	DWORD PTR _iBranchLoop$225560[ebp], eax
$LN4@GetNumPoli@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$225560[ebp], eax
	jge	SHORT $LN2@GetNumPoli@4

; 4233 : #endif
; 4234 : 	{
; 4235 : 		eLoopBranch = (PolicyBranchTypes) iBranchLoop;

	mov	edx, DWORD PTR _iBranchLoop$225560[ebp]
	mov	DWORD PTR _eLoopBranch$[ebp], edx

; 4236 : 
; 4237 : 		if(IsPolicyBranchFinished(eLoopBranch))

	mov	eax, DWORD PTR _eLoopBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchFinished
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@GetNumPoli@4

; 4238 : 		{
; 4239 : 			iNumBranchesFinished++;

	mov	edx, DWORD PTR _iNumBranchesFinished$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumBranchesFinished$[ebp], edx
$LN1@GetNumPoli@4:

; 4240 : 		}
; 4241 : 	}

	jmp	SHORT $LN3@GetNumPoli@4
$LN2@GetNumPoli@4:

; 4242 : 
; 4243 : 	return iNumBranchesFinished;

	mov	eax, DWORD PTR _iNumBranchesFinished$[ebp]

; 4244 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPolicyBranchesFinished@CvPlayerPolicies@@QBEHXZ ENDP ; CvPlayerPolicies::GetNumPolicyBranchesFinished
_TEXT	ENDS
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
; Function compile flags: /Odtp
;	COMDAT ?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z
_TEXT	SEGMENT
tv394 = -204						; size = 4
tv380 = -200						; size = 4
tv366 = -196						; size = 4
tv352 = -192						; size = 4
tv338 = -188						; size = 4
tv324 = -184						; size = 4
tv310 = -180						; size = 4
tv296 = -176						; size = 4
tv282 = -172						; size = 4
tv268 = -168						; size = 4
tv254 = -164						; size = 4
tv242 = -160						; size = 4
tv231 = -156						; size = 4
tv220 = -152						; size = 4
tv209 = -148						; size = 4
tv198 = -144						; size = 4
tv187 = -140						; size = 4
tv176 = -136						; size = 4
tv165 = -132						; size = 4
tv154 = -128						; size = 4
tv146 = -124						; size = 4
tv79 = -120						; size = 4
_this$ = -116						; size = 4
$T235638 = -112						; size = 4
$T235634 = -108						; size = 4
$T235630 = -104						; size = 4
$T235626 = -100						; size = 4
$T235622 = -96						; size = 4
$T235618 = -92						; size = 4
$T235614 = -88						; size = 4
$T235610 = -84						; size = 4
$T235606 = -80						; size = 4
$T235602 = -76						; size = 4
$T235598 = -72						; size = 4
$T235594 = -68						; size = 4
$T235590 = -64						; size = 4
$T235586 = -60						; size = 4
$T235582 = -56						; size = 4
$T235578 = -52						; size = 4
$T235574 = -48						; size = 4
$T235570 = -44						; size = 4
$T235566 = -40						; size = 4
$T235562 = -36						; size = 4
$T235558 = -32						; size = 4
$T235554 = -28						; size = 4
$T235545 = -24						; size = 4
$T235544 = -20						; size = 4
$T235540 = -16						; size = 4
$T235536 = -12						; size = 4
$T235532 = -8						; size = 4
_bUsingXP1Scenario3$225572 = -1				; size = 1
_eBranchType$ = 8					; size = 4
_bValue$ = 12						; size = 1
?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z PROC ; CvPlayerPolicies::SetPolicyBranchFinished, COMDAT
; _this$ = ecx

; 4248 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4249 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4250 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4251 : 
; 4252 : 	if(bValue != IsPolicyBranchFinished(eBranchType))

	movzx	esi, BYTE PTR _bValue$[ebp]
	mov	eax, DWORD PTR _eBranchType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchFinished
	movzx	ecx, al
	cmp	esi, ecx
	je	$LN16@SetPolicyB@3

; 4253 : 	{
; 4254 : 		m_pabPolicyBranchFinished[eBranchType] = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _eBranchType$[ebp]
	mov	dl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 4255 : 
; 4256 : 
; 4257 : 		bool bUsingXP1Scenario3 = gDLL->IsModActivated(CIV5_XP1_SCENARIO3_MODID);

	mov	eax, DWORD PTR $T235532[ebp]
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv79[ebp], ecx
	mov	edx, DWORD PTR _CIV5_XP1_SCENARIO3_MODID
	push	edx
	mov	eax, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	mov	BYTE PTR _bUsingXP1Scenario3$225572[ebp], al

; 4258 : 
; 4259 : 		//Achievements for fulfilling branches
; 4260 : 		if(!GC.getGame().isGameMultiPlayer() && GET_PLAYER(GC.getGame().getActivePlayer()).isHuman())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235536[ebp], ecx
	mov	ecx, DWORD PTR $T235536[ebp]
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	movzx	edx, al
	test	edx, edx
	jne	$LN16@SetPolicyB@3
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235540[ebp], eax
	mov	ecx, DWORD PTR $T235540[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	mov	DWORD PTR $T235544[ebp], eax
	mov	ecx, DWORD PTR $T235544[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T235545[ebp], ecx
	mov	ecx, DWORD PTR $T235545[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	$LN16@SetPolicyB@3

; 4261 : 		{
; 4262 : 			//Must not be playing smokey skies scenario.
; 4263 : 			if(m_pPlayer->GetID() == GC.getGame().getActivePlayer() && !bUsingXP1Scenario3)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T235554[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235558[ebp], eax
	mov	ecx, DWORD PTR $T235558[ebp]
	call	?getActivePlayer@CvGame@@QBE?AW4PlayerTypes@@XZ ; CvGame::getActivePlayer
	cmp	DWORD PTR $T235554[ebp], eax
	jne	$LN13@SetPolicyB@3
	movzx	ecx, BYTE PTR _bUsingXP1Scenario3$225572[ebp]
	test	ecx, ecx
	jne	$LN13@SetPolicyB@3

; 4264 : 			{
; 4265 : #ifdef AUI_WARNING_FIXES
; 4266 : 				switch (static_cast<int>(eBranchType))
; 4267 : #else
; 4268 : 				switch(eBranchType)

	mov	edx, DWORD PTR _eBranchType$[ebp]
	mov	DWORD PTR tv146[ebp], edx
	cmp	DWORD PTR tv146[ebp], 8
	ja	$LN13@SetPolicyB@3
	mov	eax, DWORD PTR tv146[ebp]
	jmp	DWORD PTR $LN72@SetPolicyB@3[eax*4]
$LN10@SetPolicyB@3:

; 4269 : #endif
; 4270 : 				{
; 4271 : 				case 0:
; 4272 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_TRADITION);

	mov	ecx, DWORD PTR $T235562[ebp]
	mov	DWORD PTR tv154[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv154[ebp], edx
	push	82					; 00000052H
	mov	eax, DWORD PTR tv154[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4273 : 					break;

	jmp	$LN13@SetPolicyB@3
$LN9@SetPolicyB@3:

; 4274 : 				case 1:
; 4275 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_LIBERTY);

	mov	ecx, DWORD PTR $T235566[ebp]
	mov	DWORD PTR tv165[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv165[ebp], edx
	push	78					; 0000004eH
	mov	eax, DWORD PTR tv165[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv165[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4276 : 					break;

	jmp	$LN13@SetPolicyB@3
$LN8@SetPolicyB@3:

; 4277 : 				case 2:
; 4278 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_HONOR);

	mov	ecx, DWORD PTR $T235570[ebp]
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv176[ebp], edx
	push	83					; 00000053H
	mov	eax, DWORD PTR tv176[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv176[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4279 : 					break;

	jmp	$LN13@SetPolicyB@3
$LN7@SetPolicyB@3:

; 4280 : 				case 3:
; 4281 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_PIETY);

	mov	ecx, DWORD PTR $T235574[ebp]
	mov	DWORD PTR tv187[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv187[ebp], edx
	push	79					; 0000004fH
	mov	eax, DWORD PTR tv187[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv187[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4282 : 					break;

	jmp	$LN13@SetPolicyB@3
$LN6@SetPolicyB@3:

; 4283 : 				case 4:
; 4284 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_PATRONAGE);

	mov	ecx, DWORD PTR $T235578[ebp]
	mov	DWORD PTR tv198[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv198[ebp], edx
	push	84					; 00000054H
	mov	eax, DWORD PTR tv198[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv198[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4285 : 					break;

	jmp	$LN13@SetPolicyB@3
$LN5@SetPolicyB@3:

; 4286 : 				
; 4287 : 				case 5:	//Aesthetics
; 4288 : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_48);

	mov	ecx, DWORD PTR $T235582[ebp]
	mov	DWORD PTR tv209[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv209[ebp], edx
	push	290					; 00000122H
	mov	eax, DWORD PTR tv209[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv209[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4289 : 					break;

	jmp	$LN13@SetPolicyB@3
$LN4@SetPolicyB@3:

; 4290 : 				case 6:
; 4291 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_COMMERCE);

	mov	ecx, DWORD PTR $T235586[ebp]
	mov	DWORD PTR tv220[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv220[ebp], edx
	push	85					; 00000055H
	mov	eax, DWORD PTR tv220[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv220[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4292 : 					break;

	jmp	SHORT $LN13@SetPolicyB@3
$LN3@SetPolicyB@3:

; 4293 : 				case 7: //Exploration
; 4294 : 					gDLL->UnlockAchievement(ACHIEVEMENT_XP2_47);

	mov	ecx, DWORD PTR $T235590[ebp]
	mov	DWORD PTR tv231[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv231[ebp], edx
	push	289					; 00000121H
	mov	eax, DWORD PTR tv231[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv231[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax

; 4295 : 					break;

	jmp	SHORT $LN13@SetPolicyB@3
$LN2@SetPolicyB@3:

; 4296 : 				case 8:
; 4297 : 					gDLL->UnlockAchievement(ACHIEVEMENT_POLICY_RATIONALISM);

	mov	ecx, DWORD PTR $T235594[ebp]
	mov	DWORD PTR tv242[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv242[ebp], edx
	push	86					; 00000056H
	mov	eax, DWORD PTR tv242[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv242[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN13@SetPolicyB@3:

; 4298 : 					break;
; 4299 : 				}
; 4300 : 			}
; 4301 : 			if(gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_TRADITION) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_HONOR) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_LIBERTY) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_PIETY) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_PATRONAGE) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_ORDER) && gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_AUTOCRACY)&& gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_FREEDOM)&& gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_COMMERCE)&& gDLL->IsAchievementUnlocked(ACHIEVEMENT_POLICY_RATIONALISM))

	mov	ecx, DWORD PTR $T235598[ebp]
	mov	DWORD PTR tv254[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv254[ebp], edx
	push	82					; 00000052H
	mov	eax, DWORD PTR tv254[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv254[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235602[ebp]
	mov	DWORD PTR tv268[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv268[ebp], eax
	push	83					; 00000053H
	mov	ecx, DWORD PTR tv268[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv268[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235606[ebp]
	mov	DWORD PTR tv282[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv282[ebp], eax
	push	78					; 0000004eH
	mov	ecx, DWORD PTR tv282[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv282[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235610[ebp]
	mov	DWORD PTR tv296[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv296[ebp], eax
	push	79					; 0000004fH
	mov	ecx, DWORD PTR tv296[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv296[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235614[ebp]
	mov	DWORD PTR tv310[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv310[ebp], eax
	push	84					; 00000054H
	mov	ecx, DWORD PTR tv310[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv310[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235618[ebp]
	mov	DWORD PTR tv324[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv324[ebp], eax
	push	81					; 00000051H
	mov	ecx, DWORD PTR tv324[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv324[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235622[ebp]
	mov	DWORD PTR tv338[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv338[ebp], eax
	push	80					; 00000050H
	mov	ecx, DWORD PTR tv338[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv338[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235626[ebp]
	mov	DWORD PTR tv352[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv352[ebp], eax
	push	87					; 00000057H
	mov	ecx, DWORD PTR tv352[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv352[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	$LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235630[ebp]
	mov	DWORD PTR tv366[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv366[ebp], eax
	push	85					; 00000055H
	mov	ecx, DWORD PTR tv366[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv366[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@SetPolicyB@3
	mov	edx, DWORD PTR $T235634[ebp]
	mov	DWORD PTR tv380[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv380[ebp], eax
	push	86					; 00000056H
	mov	ecx, DWORD PTR tv380[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv380[ebp]
	mov	eax, DWORD PTR [edx+832]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN16@SetPolicyB@3

; 4302 : 			{
; 4303 : 				gDLL->UnlockAchievement(ACHIEVEMENT_ALL_SOCIAL_POLICIES);

	mov	edx, DWORD PTR $T235638[ebp]
	mov	DWORD PTR tv394[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv394[ebp], eax
	push	53					; 00000035H
	mov	ecx, DWORD PTR tv394[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv394[ebp]
	mov	eax, DWORD PTR [edx+828]
	call	eax
$LN16@SetPolicyB@3:

; 4304 : 			}
; 4305 : 		}
; 4306 : 
; 4307 : 	}
; 4308 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN72@SetPolicyB@3:
	DD	$LN10@SetPolicyB@3
	DD	$LN9@SetPolicyB@3
	DD	$LN8@SetPolicyB@3
	DD	$LN7@SetPolicyB@3
	DD	$LN6@SetPolicyB@3
	DD	$LN5@SetPolicyB@3
	DD	$LN4@SetPolicyB@3
	DD	$LN3@SetPolicyB@3
	DD	$LN2@SetPolicyB@3
?SetPolicyBranchFinished@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@_N@Z ENDP ; CvPlayerPolicies::SetPolicyBranchFinished
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBranchType$ = 8					; size = 4
?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::IsPolicyBranchFinished, COMDAT
; _this$ = ecx

; 4312 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4313 : 	CvAssertMsg(eBranchType >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 4314 : 	CvAssertMsg(eBranchType < m_pPolicies->GetNumPolicyBranches(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 4315 : 	return m_pabPolicyBranchFinished[eBranchType];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _eBranchType$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 4316 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsPolicyBranchFinished@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::IsPolicyBranchFinished
_TEXT	ENDS
PUBLIC	?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::WillFinishBranchIfAdopted
; Function compile flags: /Odtp
;	COMDAT ?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_eLoopPolicy$225604 = -16				; size = 4
_pkLoopPolicyInfo$225606 = -12				; size = 4
_iPolicyLoop$225600 = -8				; size = 4
_eBranchType$ = -4					; size = 4
_eType$ = 8						; size = 4
?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::WillFinishBranchIfAdopted, COMDAT
; _this$ = ecx

; 4320 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4321 : 	PolicyBranchTypes eBranchType = (PolicyBranchTypes)m_pPolicies->GetPolicyEntry(eType)->GetPolicyBranchType();

	mov	eax, DWORD PTR _eType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	ecx, eax
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eBranchType$[ebp], eax

; 4322 : 
; 4323 : 	if(eBranchType != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eBranchType$[ebp], -1
	je	SHORT $LN8@WillFinish

; 4324 : 	{
; 4325 : 		// Is the branch this policy is in finished?
; 4326 : #ifdef AUI_WARNING_FIXES
; 4327 : 		for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4328 : #else
; 4329 : 		for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$225600[ebp], 0
	jmp	SHORT $LN7@WillFinish
$LN6@WillFinish:
	mov	edx, DWORD PTR _iPolicyLoop$225600[ebp]
	add	edx, 1
	mov	DWORD PTR _iPolicyLoop$225600[ebp], edx
$LN7@WillFinish:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$225600[ebp], eax
	jge	SHORT $LN5@WillFinish

; 4330 : #endif
; 4331 : 		{
; 4332 : 			const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);

	mov	eax, DWORD PTR _iPolicyLoop$225600[ebp]
	mov	DWORD PTR _eLoopPolicy$225604[ebp], eax

; 4333 : 
; 4334 : 			CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	mov	ecx, DWORD PTR _eLoopPolicy$225604[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkLoopPolicyInfo$225606[ebp], eax

; 4335 : 			if(pkLoopPolicyInfo)

	cmp	DWORD PTR _pkLoopPolicyInfo$225606[ebp], 0
	je	SHORT $LN4@WillFinish

; 4336 : 			{
; 4337 : 				// This policy belongs to our branch
; 4338 : 				if(pkLoopPolicyInfo->GetPolicyBranchType() == eBranchType)

	mov	ecx, DWORD PTR _pkLoopPolicyInfo$225606[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranchType$[ebp]
	jne	SHORT $LN4@WillFinish

; 4339 : 				{
; 4340 : 					// We don't have this policy!
; 4341 : 					if(!HasPolicy(eLoopPolicy))

	mov	edx, DWORD PTR _eLoopPolicy$225604[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@WillFinish

; 4342 : 					{
; 4343 : 						// Is it this policy passed in?
; 4344 : 						if(eLoopPolicy != eType)

	mov	ecx, DWORD PTR _eLoopPolicy$225604[ebp]
	cmp	ecx, DWORD PTR _eType$[ebp]
	je	SHORT $LN4@WillFinish

; 4345 : 						{
; 4346 : 							// No, so this one won't finish branch
; 4347 : 							return false;

	xor	al, al
	jmp	SHORT $LN9@WillFinish
$LN4@WillFinish:

; 4348 : 						}
; 4349 : 					}
; 4350 : 				}
; 4351 : 			}
; 4352 : 		}

	jmp	SHORT $LN6@WillFinish
$LN5@WillFinish:

; 4353 : 
; 4354 : 		// Didn't find any policy in this branch that we didn't have covered.  This will finish it
; 4355 : 		return true;

	mov	al, 1
	jmp	SHORT $LN9@WillFinish
$LN8@WillFinish:

; 4356 : 	}
; 4357 : 
; 4358 : 	return false;

	xor	al, al
$LN9@WillFinish:

; 4359 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?WillFinishBranchIfAdopted@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::WillFinishBranchIfAdopted
_TEXT	ENDS
PUBLIC	?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesAllowed
PUBLIC	?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetPolicyBranchChosen
; Function compile flags: /Odtp
;	COMDAT ?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z PROC ; CvPlayerPolicies::GetPolicyBranchChosen, COMDAT
; _this$ = ecx

; 4363 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4364 : 	if(iID < GetNumPolicyBranchesAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesAllowed
	cmp	DWORD PTR _iID$[ebp], eax
	jge	SHORT $LN1@GetPolicyB@2

; 4365 : 	{
; 4366 : 		return m_paePolicyBranchesChosen[iID];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iID$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@GetPolicyB@2
$LN1@GetPolicyB@2:

; 4367 : 	}
; 4368 : 
; 4369 : 	FAssert(false);
; 4370 : 
; 4371 : 	return NO_POLICY_BRANCH_TYPE;

	or	eax, -1
$LN2@GetPolicyB@2:

; 4372 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPolicyBranchChosen@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@H@Z ENDP ; CvPlayerPolicies::GetPolicyBranchChosen
_TEXT	ENDS
PUBLIC	?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetPolicyBranchChosen
; Function compile flags: /Odtp
;	COMDAT ?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
_eBranchType$ = 12					; size = 4
?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetPolicyBranchChosen, COMDAT
; _this$ = ecx

; 4376 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4377 : 	FAssert(eBranchType > -1);
; 4378 : 	FAssert(eBranchType < m_pPolicies->GetNumPolicyBranches());
; 4379 : 
; 4380 : 	if(iID < GetNumPolicyBranchesAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPolicyBranchesAllowed
	cmp	DWORD PTR _iID$[ebp], eax
	jge	SHORT $LN3@SetPolicyB@4

; 4381 : 	{
; 4382 : 		m_paePolicyBranchesChosen[iID] = eBranchType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _iID$[ebp]
	mov	eax, DWORD PTR _eBranchType$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax
$LN3@SetPolicyB@4:

; 4383 : 	}
; 4384 : 	else
; 4385 : 	{
; 4386 : 		FAssert(false);
; 4387 : 	}
; 4388 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetPolicyBranchChosen@CvPlayerPolicies@@QAEXHW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetPolicyBranchChosen
_TEXT	ENDS
PUBLIC	?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ	; CvPlayerPolicies::GetNumExtraBranches
; Function compile flags: /Odtp
;	COMDAT ?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T235653 = -4						; size = 4
?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ PROC ; CvPlayerPolicies::GetNumPolicyBranchesAllowed, COMDAT
; _this$ = ecx

; 4392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 4393 : 	return /*2*/ GC.getNUM_POLICY_BRANCHES_ALLOWED() + GetNumExtraBranches();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6256
	mov	DWORD PTR $T235653[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumExtraBranches
	add	eax, DWORD PTR $T235653[ebp]

; 4394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPolicyBranchesAllowed@CvPlayerPolicies@@QBEHXZ ENDP ; CvPlayerPolicies::GetNumPolicyBranchesAllowed
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ PROC	; CvPlayerPolicies::GetNumExtraBranches, COMDAT
; _this$ = ecx

; 4398 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4399 : 	return m_iNumExtraBranches;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 4400 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumExtraBranches@CvPlayerPolicies@@QBEHXZ ENDP	; CvPlayerPolicies::GetNumExtraBranches
_TEXT	ENDS
PUBLIC	?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z ; CvPlayerPolicies::ChangeNumExtraBranches
; Function compile flags: /Odtp
;	COMDAT ?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z PROC	; CvPlayerPolicies::ChangeNumExtraBranches, COMDAT
; _this$ = ecx

; 4404 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4405 : 	m_iNumExtraBranches += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 4406 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeNumExtraBranches@CvPlayerPolicies@@QAEXH@Z ENDP	; CvPlayerPolicies::ChangeNumExtraBranches
_TEXT	ENDS
PUBLIC	?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted
; Function compile flags: /Odtp
;	COMDAT ?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
_eBranchType$225656 = -32				; size = 4
_eLoopPolicy$225652 = -28				; size = 4
_pkLoopPolicyInfo$225654 = -24				; size = 4
_iPolicyLoop$225648 = -20				; size = 4
_pkPolicyBranchInfo$225645 = -16			; size = 4
_eBranchType$225641 = -12				; size = 4
_iBranchLoop$225637 = -8				; size = 4
_iNumPoliciesToAcquire$ = -4				; size = 4
?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ PROC ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted, COMDAT
; _this$ = ecx

; 4410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 4411 : 	int iNumPoliciesToAcquire = 0;

	mov	DWORD PTR _iNumPoliciesToAcquire$[ebp], 0

; 4412 : 
; 4413 : 	// count the branch openers
; 4414 : #ifdef AUI_WARNING_FIXES
; 4415 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4416 : #else
; 4417 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$225637[ebp], 0
	jmp	SHORT $LN14@GetNumPoli@5
$LN13@GetNumPoli@5:
	mov	eax, DWORD PTR _iBranchLoop$225637[ebp]
	add	eax, 1
	mov	DWORD PTR _iBranchLoop$225637[ebp], eax
$LN14@GetNumPoli@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$225637[ebp], eax
	jge	SHORT $LN12@GetNumPoli@5

; 4418 : #endif
; 4419 : 	{
; 4420 : 		PolicyBranchTypes eBranchType = (PolicyBranchTypes)iBranchLoop;

	mov	edx, DWORD PTR _iBranchLoop$225637[ebp]
	mov	DWORD PTR _eBranchType$225641[ebp], edx

; 4421 : 		if (IsPolicyBranchUnlocked(eBranchType) || CanUnlockPolicyBranch(eBranchType))

	mov	eax, DWORD PTR _eBranchType$225641[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN10@GetNumPoli@5
	mov	edx, DWORD PTR _eBranchType$225641[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@GetNumPoli@5
$LN10@GetNumPoli@5:

; 4422 : 		{
; 4423 : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eBranchType);

	mov	ecx, DWORD PTR _eBranchType$225641[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$225645[ebp], eax

; 4424 : 			if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$225645[ebp], 0
	je	SHORT $LN11@GetNumPoli@5

; 4425 : 			{
; 4426 : 				// Yes, it's a freebie
; 4427 : 				if(pkPolicyBranchInfo->GetFreePolicy() != NO_POLICY)

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225645[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	cmp	eax, -1
	je	SHORT $LN11@GetNumPoli@5

; 4428 : 				{
; 4429 : 					iNumPoliciesToAcquire++;

	mov	edx, DWORD PTR _iNumPoliciesToAcquire$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumPoliciesToAcquire$[ebp], edx
$LN11@GetNumPoli@5:

; 4430 : 				}
; 4431 : 			}
; 4432 : 		}
; 4433 : 	}

	jmp	SHORT $LN13@GetNumPoli@5
$LN12@GetNumPoli@5:

; 4434 : 
; 4435 : 	// count the policies within the branch
; 4436 : #ifdef AUI_WARNING_FIXES
; 4437 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)
; 4438 : #else
; 4439 : 	for(int iPolicyLoop = 0; iPolicyLoop < GetPolicies()->GetNumPolicies(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$225648[ebp], 0
	jmp	SHORT $LN7@GetNumPoli@5
$LN6@GetNumPoli@5:
	mov	eax, DWORD PTR _iPolicyLoop$225648[ebp]
	add	eax, 1
	mov	DWORD PTR _iPolicyLoop$225648[ebp], eax
$LN7@GetNumPoli@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPolicies@CvPlayerPolicies@@QBEPAVCvPolicyXMLEntries@@XZ ; CvPlayerPolicies::GetPolicies
	mov	ecx, eax
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	cmp	DWORD PTR _iPolicyLoop$225648[ebp], eax
	jge	SHORT $LN5@GetNumPoli@5

; 4440 : #endif
; 4441 : 	{
; 4442 : 		const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);

	mov	ecx, DWORD PTR _iPolicyLoop$225648[ebp]
	mov	DWORD PTR _eLoopPolicy$225652[ebp], ecx

; 4443 : 		CvPolicyEntry* pkLoopPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	mov	edx, DWORD PTR _eLoopPolicy$225652[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkLoopPolicyInfo$225654[ebp], eax

; 4444 : 		if(pkLoopPolicyInfo)

	cmp	DWORD PTR _pkLoopPolicyInfo$225654[ebp], 0
	je	SHORT $LN4@GetNumPoli@5

; 4445 : 		{
; 4446 : 			PolicyBranchTypes eBranchType = (PolicyBranchTypes)pkLoopPolicyInfo->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkLoopPolicyInfo$225654[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eBranchType$225656[ebp], eax

; 4447 : 			if (eBranchType != -1)

	cmp	DWORD PTR _eBranchType$225656[ebp], -1
	je	SHORT $LN4@GetNumPoli@5

; 4448 : 			{
; 4449 : 				if (IsPolicyBranchUnlocked(eBranchType) || CanUnlockPolicyBranch(eBranchType))

	mov	eax, DWORD PTR _eBranchType$225656[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@GetNumPoli@5
	mov	edx, DWORD PTR _eBranchType$225656[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanUnlockPolicyBranch@CvPlayerPolicies@@QAE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::CanUnlockPolicyBranch
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@GetNumPoli@5
$LN1@GetNumPoli@5:

; 4450 : 				{
; 4451 : 					iNumPoliciesToAcquire++;

	mov	ecx, DWORD PTR _iNumPoliciesToAcquire$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumPoliciesToAcquire$[ebp], ecx
$LN4@GetNumPoli@5:

; 4452 : 				}
; 4453 : 			}
; 4454 : 		}
; 4455 : 	}

	jmp	SHORT $LN6@GetNumPoli@5
$LN5@GetNumPoli@5:

; 4456 : 
; 4457 : 	return iNumPoliciesToAcquire - GetNumPoliciesOwned();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPoliciesOwned
	mov	edx, DWORD PTR _iNumPoliciesToAcquire$[ebp]
	sub	edx, eax
	mov	eax, edx

; 4458 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ ENDP ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted
_TEXT	ENDS
PUBLIC	?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked3
PUBLIC	?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked3
PUBLIC	?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked2
PUBLIC	?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked2
PUBLIC	?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked1
PUBLIC	?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked1
; Function compile flags: /Odtp
;	COMDAT ?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_pkPolicyBranchInfo$225676 = -20			; size = 4
_eLoopBranch$225674 = -16				; size = 4
_iBranchLoop$225670 = -12				; size = 4
_eNewBranch$ = -8					; size = 4
_pkPolicyInfo$ = -4					; size = 4
_ePolicy$ = 8						; size = 4
?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z PROC ; CvPlayerPolicies::DoNewPolicyPickedForHistory, COMDAT
; _this$ = ecx

; 4462 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4463 : 	CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(ePolicy);

	mov	eax, DWORD PTR _ePolicy$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$[ebp], eax

; 4464 : 	if(pkPolicyInfo == NULL)

	cmp	DWORD PTR _pkPolicyInfo$[ebp], 0
	jne	SHORT $LN13@DoNewPolic

; 4465 : 		return;

	jmp	$LN14@DoNewPolic
$LN13@DoNewPolic:

; 4466 : 
; 4467 : 	PolicyBranchTypes eNewBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkPolicyInfo$[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eNewBranch$[ebp], eax

; 4468 : 
; 4469 : 	// Are we a free branch policy?
; 4470 : 	if(eNewBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eNewBranch$[ebp], -1
	jne	SHORT $LN12@DoNewPolic

; 4471 : 	{
; 4472 : #ifdef AUI_WARNING_FIXES
; 4473 : 		for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4474 : #else
; 4475 : 		for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$225670[ebp], 0
	jmp	SHORT $LN11@DoNewPolic
$LN10@DoNewPolic:
	mov	ecx, DWORD PTR _iBranchLoop$225670[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBranchLoop$225670[ebp], ecx
$LN11@DoNewPolic:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$225670[ebp], eax
	jge	SHORT $LN12@DoNewPolic

; 4476 : #endif
; 4477 : 		{
; 4478 : 			const PolicyBranchTypes eLoopBranch = static_cast<PolicyBranchTypes>(iBranchLoop);

	mov	eax, DWORD PTR _iBranchLoop$225670[ebp]
	mov	DWORD PTR _eLoopBranch$225674[ebp], eax

; 4479 : 			CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eLoopBranch);

	mov	ecx, DWORD PTR _eLoopBranch$225674[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$225676[ebp], eax

; 4480 : 			if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$225676[ebp], 0
	je	SHORT $LN8@DoNewPolic

; 4481 : 			{
; 4482 : 				// Yes, it's a freebie
; 4483 : 				if(pkPolicyBranchInfo->GetFreePolicy() == ePolicy)

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225676[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	cmp	eax, DWORD PTR _ePolicy$[ebp]
	jne	SHORT $LN8@DoNewPolic

; 4484 : 				{
; 4485 : 					eNewBranch = eLoopBranch;

	mov	edx, DWORD PTR _eLoopBranch$225674[ebp]
	mov	DWORD PTR _eNewBranch$[ebp], edx

; 4486 : 					break;

	jmp	SHORT $LN12@DoNewPolic
$LN8@DoNewPolic:

; 4487 : 				}
; 4488 : 			}
; 4489 : 		}

	jmp	SHORT $LN10@DoNewPolic
$LN12@DoNewPolic:

; 4490 : 	}
; 4491 : 
; 4492 : 	// Have we filled up the slots yet?
; 4493 : 	if(GetBranchPicked1() == NO_POLICY_BRANCH_TYPE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked1
	cmp	eax, -1
	jne	SHORT $LN6@DoNewPolic

; 4494 : 	{
; 4495 : 		SetBranchPicked1(eNewBranch);

	mov	eax, DWORD PTR _eNewBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked1
	jmp	SHORT $LN14@DoNewPolic
$LN6@DoNewPolic:

; 4496 : 	}
; 4497 : 	else if(GetBranchPicked2() == NO_POLICY_BRANCH_TYPE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked2
	cmp	eax, -1
	jne	SHORT $LN4@DoNewPolic

; 4498 : 	{
; 4499 : 		SetBranchPicked2(eNewBranch);

	mov	ecx, DWORD PTR _eNewBranch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked2
	jmp	SHORT $LN14@DoNewPolic
$LN4@DoNewPolic:

; 4500 : 	}
; 4501 : 	else if(GetBranchPicked3() == NO_POLICY_BRANCH_TYPE)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked3
	cmp	eax, -1
	jne	SHORT $LN2@DoNewPolic

; 4502 : 	{
; 4503 : 		SetBranchPicked3(eNewBranch);

	mov	edx, DWORD PTR _eNewBranch$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked3

; 4504 : 	}
; 4505 : 
; 4506 : 	// if we've gotten here it means that all the slots are filled already, so we gotta bump some stuff
; 4507 : 	else

	jmp	SHORT $LN14@DoNewPolic
$LN2@DoNewPolic:

; 4508 : 	{
; 4509 : 		SetBranchPicked3(GetBranchPicked2());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked3

; 4510 : 		SetBranchPicked2(GetBranchPicked1());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked2

; 4511 : 		SetBranchPicked1(eNewBranch);

	mov	eax, DWORD PTR _eNewBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::SetBranchPicked1
$LN14@DoNewPolic:

; 4512 : 	}
; 4513 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DoNewPolicyPickedForHistory@CvPlayerPolicies@@QAEXW4PolicyTypes@@@Z ENDP ; CvPlayerPolicies::DoNewPolicyPickedForHistory
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetDominantPolicyBranchForTitle
EXTRN	?getNumPolicyInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPolicyInfos
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ$3
__ehfuncinfo$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
tv155 = -176						; size = 4
_this$ = -172						; size = 4
$T235665 = -72						; size = 4
$T235664 = -68						; size = 4
_pkPolicyBranchInfo$225716 = -64			; size = 4
_eLoopBranch$225714 = -60				; size = 4
_eLoopPolicy$225704 = -56				; size = 4
_pkPolicyInfo$225706 = -52				; size = 4
_iPolicyLoop$225700 = -48				; size = 4
_viPolicyBranchCounts$ = -44				; size = 16
_iBestValue$ = -28					; size = 4
_eTempBranch$ = -24					; size = 4
_eBestBranch$ = -20					; size = 4
_iBranchLoop$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetDominantPolicyBranchForTitle, COMDAT
; _this$ = ecx

; 4517 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4518 : 	// Everything we've picked recently matches
; 4519 : 	if(GetBranchPicked1() == GetBranchPicked2() &&
; 4520 : 	        GetBranchPicked1() == GetBranchPicked3() &&
; 4521 : 	        GetBranchPicked2() == GetBranchPicked3())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked1
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked2
	cmp	esi, eax
	jne	SHORT $LN20@GetDominan
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked1
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked3
	cmp	esi, eax
	jne	SHORT $LN20@GetDominan
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked2
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked3
	cmp	esi, eax
	jne	SHORT $LN20@GetDominan

; 4522 : 	{
; 4523 : 		return GetBranchPicked1();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetBranchPicked1
	jmp	$LN21@GetDominan
$LN20@GetDominan:

; 4524 : 	}
; 4525 : 
; 4526 : 	// Haven't picked stuff from a branch three times in a row, so we have to see which branch we have the most of
; 4527 : 
; 4528 : 	PolicyBranchTypes eTempBranch;
; 4529 : 
; 4530 : 	std::vector<int> viPolicyBranchCounts;

	lea	ecx, DWORD PTR _viPolicyBranchCounts$[ebp]
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4531 : 
; 4532 : 	// Init vector
; 4533 : #ifdef AUI_WARNING_FIXES
; 4534 : 	uint iBranchLoop;
; 4535 : #else
; 4536 : 	int iBranchLoop;
; 4537 : #endif
; 4538 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$[ebp], 0
	jmp	SHORT $LN19@GetDominan
$LN18@GetDominan:
	mov	eax, DWORD PTR _iBranchLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iBranchLoop$[ebp], eax
$LN19@GetDominan:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$[ebp], eax
	jge	SHORT $LN17@GetDominan

; 4539 : 	{
; 4540 : 		viPolicyBranchCounts.push_back(0);

	mov	DWORD PTR $T235664[ebp], 0
	lea	edx, DWORD PTR $T235664[ebp]
	push	edx
	lea	ecx, DWORD PTR _viPolicyBranchCounts$[ebp]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4541 : 	}

	jmp	SHORT $LN18@GetDominan
$LN17@GetDominan:

; 4542 : 
; 4543 : 	// Get count of each branch
; 4544 : #ifdef AUI_WARNING_FIXES
; 4545 : 	for (uint iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)
; 4546 : #else
; 4547 : 	for(int iPolicyLoop = 0; iPolicyLoop < GC.getNumPolicyInfos(); iPolicyLoop++)

	mov	DWORD PTR _iPolicyLoop$225700[ebp], 0
	jmp	SHORT $LN16@GetDominan
$LN15@GetDominan:
	mov	eax, DWORD PTR _iPolicyLoop$225700[ebp]
	add	eax, 1
	mov	DWORD PTR _iPolicyLoop$225700[ebp], eax
$LN16@GetDominan:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	DWORD PTR _iPolicyLoop$225700[ebp], eax
	jge	$LN14@GetDominan

; 4548 : #endif
; 4549 : 	{
; 4550 : 		const PolicyTypes eLoopPolicy = static_cast<PolicyTypes>(iPolicyLoop);

	mov	ecx, DWORD PTR _iPolicyLoop$225700[ebp]
	mov	DWORD PTR _eLoopPolicy$225704[ebp], ecx

; 4551 : 		CvPolicyEntry* pkPolicyInfo = GC.getPolicyInfo(eLoopPolicy);

	mov	edx, DWORD PTR _eLoopPolicy$225704[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyInfo@CvGlobals@@QAEPAVCvPolicyEntry@@W4PolicyTypes@@@Z ; CvGlobals::getPolicyInfo
	mov	DWORD PTR _pkPolicyInfo$225706[ebp], eax

; 4552 : 		if(pkPolicyInfo)

	cmp	DWORD PTR _pkPolicyInfo$225706[ebp], 0
	je	$LN13@GetDominan

; 4553 : 		{
; 4554 : 			if(HasPolicy(eLoopPolicy))

	mov	eax, DWORD PTR _eLoopPolicy$225704[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN13@GetDominan

; 4555 : 			{
; 4556 : 				eTempBranch = (PolicyBranchTypes) pkPolicyInfo->GetPolicyBranchType();

	mov	ecx, DWORD PTR _pkPolicyInfo$225706[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	mov	DWORD PTR _eTempBranch$[ebp], eax

; 4557 : 
; 4558 : 				// Are we a free branch policy?
; 4559 : 				if(eTempBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eTempBranch$[ebp], -1
	jne	SHORT $LN11@GetDominan

; 4560 : 				{
; 4561 : 					for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$[ebp], 0
	jmp	SHORT $LN10@GetDominan
$LN9@GetDominan:
	mov	edx, DWORD PTR _iBranchLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iBranchLoop$[ebp], edx
$LN10@GetDominan:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$[ebp], eax
	jge	SHORT $LN11@GetDominan

; 4562 : 					{
; 4563 : 						const PolicyBranchTypes eLoopBranch = static_cast<PolicyBranchTypes>(iBranchLoop);

	mov	ecx, DWORD PTR _iBranchLoop$[ebp]
	mov	DWORD PTR _eLoopBranch$225714[ebp], ecx

; 4564 : 						CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eLoopBranch);

	mov	edx, DWORD PTR _eLoopBranch$225714[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$225716[ebp], eax

; 4565 : 						if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$225716[ebp], 0
	je	SHORT $LN7@GetDominan

; 4566 : 						{
; 4567 : 							// Yes, it's a freebie
; 4568 : 							if(pkPolicyBranchInfo->GetFreePolicy() == eLoopPolicy)

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225716[ebp]
	call	?GetFreePolicy@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFreePolicy
	cmp	eax, DWORD PTR _eLoopPolicy$225704[ebp]
	jne	SHORT $LN7@GetDominan

; 4569 : 							{
; 4570 : 								eTempBranch = eLoopBranch;

	mov	eax, DWORD PTR _eLoopBranch$225714[ebp]
	mov	DWORD PTR _eTempBranch$[ebp], eax

; 4571 : 								break;

	jmp	SHORT $LN11@GetDominan
$LN7@GetDominan:

; 4572 : 							}
; 4573 : 						}
; 4574 : 					}

	jmp	SHORT $LN9@GetDominan
$LN11@GetDominan:

; 4575 : 				}
; 4576 : 
; 4577 : 				if(eTempBranch != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eTempBranch$[ebp], -1
	je	SHORT $LN13@GetDominan

; 4578 : 				{
; 4579 : 					viPolicyBranchCounts[eTempBranch]++;

	mov	ecx, DWORD PTR _viPolicyBranchCounts$[ebp+4]
	mov	edx, DWORD PTR _eTempBranch$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR tv155[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR [eax], edx
$LN13@GetDominan:

; 4580 : 				}
; 4581 : 			}
; 4582 : 		}
; 4583 : 	}

	jmp	$LN15@GetDominan
$LN14@GetDominan:

; 4584 : 
; 4585 : 	// Now that we have our vector, see which has the most
; 4586 : 	PolicyBranchTypes eBestBranch = NO_POLICY_BRANCH_TYPE;

	mov	DWORD PTR _eBestBranch$[ebp], -1

; 4587 : 	int iBestValue = 0;

	mov	DWORD PTR _iBestValue$[ebp], 0

; 4588 : 
; 4589 : 	for(iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$[ebp], 0
	jmp	SHORT $LN4@GetDominan
$LN3@GetDominan:
	mov	ecx, DWORD PTR _iBranchLoop$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iBranchLoop$[ebp], ecx
$LN4@GetDominan:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$[ebp], eax
	jge	SHORT $LN2@GetDominan

; 4590 : 	{
; 4591 : 		if(viPolicyBranchCounts[iBranchLoop] > iBestValue)

	mov	eax, DWORD PTR _viPolicyBranchCounts$[ebp+4]
	mov	ecx, DWORD PTR _iBranchLoop$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	edx, DWORD PTR _iBestValue$[ebp]
	jle	SHORT $LN1@GetDominan

; 4592 : 		{
; 4593 : 			eBestBranch = (PolicyBranchTypes) iBranchLoop;

	mov	eax, DWORD PTR _iBranchLoop$[ebp]
	mov	DWORD PTR _eBestBranch$[ebp], eax

; 4594 : 			iBestValue = viPolicyBranchCounts[iBranchLoop];

	mov	ecx, DWORD PTR _viPolicyBranchCounts$[ebp+4]
	mov	edx, DWORD PTR _iBranchLoop$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _iBestValue$[ebp], eax
$LN1@GetDominan:

; 4595 : 		}
; 4596 : 	}

	jmp	SHORT $LN3@GetDominan
$LN2@GetDominan:

; 4597 : 
; 4598 : 	return eBestBranch;

	mov	ecx, DWORD PTR _eBestBranch$[ebp]
	mov	DWORD PTR $T235665[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _viPolicyBranchCounts$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T235665[ebp]
$LN21@GetDominan:

; 4599 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ$0:
	lea	ecx, DWORD PTR _viPolicyBranchCounts$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ$3:
	lea	ecx, DWORD PTR _viPolicyBranchCounts$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetDominantPolicyBranchForTitle@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetDominantPolicyBranchForTitle
; Function compile flags: /Odtp
;	COMDAT ?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetBranchPicked1, COMDAT
; _this$ = ecx

; 4603 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4604 : 	return m_eBranchPicked1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+68]

; 4605 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchPicked1@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetBranchPicked1
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBranch$ = 8						; size = 4
?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetBranchPicked1, COMDAT
; _this$ = ecx

; 4609 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4610 : 	m_eBranchPicked1 = eBranch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eBranch$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 4611 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBranchPicked1@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetBranchPicked1
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetBranchPicked2, COMDAT
; _this$ = ecx

; 4615 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4616 : 	return m_eBranchPicked2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+72]

; 4617 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchPicked2@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetBranchPicked2
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBranch$ = 8						; size = 4
?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetBranchPicked2, COMDAT
; _this$ = ecx

; 4621 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4622 : 	m_eBranchPicked2 = eBranch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eBranch$[ebp]
	mov	DWORD PTR [eax+72], ecx

; 4623 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBranchPicked2@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetBranchPicked2
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetBranchPicked3, COMDAT
; _this$ = ecx

; 4627 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4628 : 	return m_eBranchPicked3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+76]

; 4629 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetBranchPicked3@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetBranchPicked3
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eBranch$ = 8						; size = 4
?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z PROC ; CvPlayerPolicies::SetBranchPicked3, COMDAT
; _this$ = ecx

; 4633 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4634 : 	m_eBranchPicked3 = eBranch;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _eBranch$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 4635 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBranchPicked3@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ENDP ; CvPlayerPolicies::SetBranchPicked3
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_pkPolicyBranchInfo$225759 = -16			; size = 4
_iBranchLoop$225754 = -12				; size = 4
_eOurChoice$ = -8					; size = 4
_eLoopBranch$ = -4					; size = 4
?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ PROC ; CvPlayerPolicies::GetLateGamePolicyTree, COMDAT
; _this$ = ecx

; 4641 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 4642 : 	PolicyBranchTypes eOurChoice = NO_POLICY_BRANCH_TYPE;

	mov	DWORD PTR _eOurChoice$[ebp], -1

; 4643 : 
; 4644 : 	PolicyBranchTypes eLoopBranch;
; 4645 : #ifdef AUI_WARNING_FIXES
; 4646 : 	for (uint iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)
; 4647 : #else
; 4648 : 	for(int iBranchLoop = 0; iBranchLoop < m_pPolicies->GetNumPolicyBranches(); iBranchLoop++)

	mov	DWORD PTR _iBranchLoop$225754[ebp], 0
	jmp	SHORT $LN5@GetLateGam
$LN4@GetLateGam:
	mov	eax, DWORD PTR _iBranchLoop$225754[ebp]
	add	eax, 1
	mov	DWORD PTR _iBranchLoop$225754[ebp], eax
$LN5@GetLateGam:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iBranchLoop$225754[ebp], eax
	jge	SHORT $LN3@GetLateGam

; 4649 : #endif
; 4650 : 	{
; 4651 : 		eLoopBranch = (PolicyBranchTypes) iBranchLoop;

	mov	edx, DWORD PTR _iBranchLoop$225754[ebp]
	mov	DWORD PTR _eLoopBranch$[ebp], edx

; 4652 : 
; 4653 : 		CvPolicyBranchEntry* pkPolicyBranchInfo = GC.getPolicyBranchInfo(eLoopBranch);

	mov	eax, DWORD PTR _eLoopBranch$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkPolicyBranchInfo$225759[ebp], eax

; 4654 : 		if(pkPolicyBranchInfo)

	cmp	DWORD PTR _pkPolicyBranchInfo$225759[ebp], 0
	je	SHORT $LN2@GetLateGam

; 4655 : 		{
; 4656 : 			if (pkPolicyBranchInfo->IsPurchaseByLevel() && IsPolicyBranchUnlocked(eLoopBranch))

	mov	ecx, DWORD PTR _pkPolicyBranchInfo$225759[ebp]
	call	?IsPurchaseByLevel@CvPolicyBranchEntry@@QBE_NXZ ; CvPolicyBranchEntry::IsPurchaseByLevel
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@GetLateGam
	mov	edx, DWORD PTR _eLoopBranch$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@GetLateGam

; 4657 : 			{
; 4658 : 				eOurChoice = eLoopBranch;

	mov	ecx, DWORD PTR _eLoopBranch$[ebp]
	mov	DWORD PTR _eOurChoice$[ebp], ecx

; 4659 : 				break;

	jmp	SHORT $LN3@GetLateGam
$LN2@GetLateGam:

; 4660 : 			}
; 4661 : 		}
; 4662 : 	}

	jmp	SHORT $LN4@GetLateGam
$LN3@GetLateGam:

; 4663 : 
; 4664 : 	return eOurChoice;

	mov	eax, DWORD PTR _eOurChoice$[ebp]

; 4665 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ENDP ; CvPlayerPolicies::GetLateGamePolicyTree
_TEXT	ENDS
PUBLIC	??_C@_0P@IGHGNBHE@ERA_INDUSTRIAL?$AA@		; `string'
PUBLIC	??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@	; `string'
PUBLIC	?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ ; CvPlayerPolicies::IsTimeToChooseIdeology
EXTRN	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z:PROC ; CvPlayer::getBuildingClassCount
EXTRN	?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ:PROC ; CvPlayer::GetCurrentEra
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
;	COMDAT ??_C@_0P@IGHGNBHE@ERA_INDUSTRIAL?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0P@IGHGNBHE@ERA_INDUSTRIAL?$AA@ DB 'ERA_INDUSTRIAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
CONST	SEGMENT
??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@ DB 'GAMEOPTION_AI_TWEAKS', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
CONST	ENDS
;	COMDAT ?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T235890 = -40						; size = 4
_iIdeologyTriggerCount$225790 = -36			; size = 4
_eBuilding$225785 = -32					; size = 4
_pkBuildingInfo$225787 = -28				; size = 4
_iI$225781 = -24					; size = 4
_pkInfo$225779 = -20					; size = 4
_pkGameBuildings$225778 = -16				; size = 4
_eFreedomBranch$ = -12					; size = 4
_eOrderBranch$ = -8					; size = 4
_eAutocracyBranch$ = -4					; size = 4
?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ PROC	; CvPlayerPolicies::IsTimeToChooseIdeology, COMDAT
; _this$ = ecx

; 4669 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4670 : 	PolicyBranchTypes eFreedomBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_FREEDOM();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8376
	mov	DWORD PTR _eFreedomBranch$[ebp], eax

; 4671 : 	PolicyBranchTypes eAutocracyBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_AUTOCRACY();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8380
	mov	DWORD PTR _eAutocracyBranch$[ebp], ecx

; 4672 : 	PolicyBranchTypes eOrderBranch = (PolicyBranchTypes)GC.getPOLICY_BRANCH_ORDER();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8384
	mov	DWORD PTR _eOrderBranch$[ebp], edx

; 4673 : #ifdef AI_CANT_ADOPT_IDEOLOGY
; 4674 : 	if (!m_pPlayer->isHuman() && GC.getGame().isOption("GAMEOPTION_AI_TWEAKS"))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN13@IsTimeToCh
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235890[ebp], edx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T235890[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@IsTimeToCh

; 4675 : 	{
; 4676 : 		return false;

	xor	al, al
	jmp	$LN14@IsTimeToCh
$LN13@IsTimeToCh:

; 4677 : 	}
; 4678 : #endif
; 4679 : 	if (eFreedomBranch == NO_POLICY_BRANCH_TYPE || eAutocracyBranch == NO_POLICY_BRANCH_TYPE || eOrderBranch == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eFreedomBranch$[ebp], -1
	je	SHORT $LN11@IsTimeToCh
	cmp	DWORD PTR _eAutocracyBranch$[ebp], -1
	je	SHORT $LN11@IsTimeToCh
	cmp	DWORD PTR _eOrderBranch$[ebp], -1
	jne	SHORT $LN12@IsTimeToCh
$LN11@IsTimeToCh:

; 4680 : 	{
; 4681 : 		return false;

	xor	al, al
	jmp	$LN14@IsTimeToCh
$LN12@IsTimeToCh:

; 4682 : 	}
; 4683 : 
; 4684 : 	if (m_pPlayer->GetCurrentEra() > GC.getInfoTypeForString("ERA_INDUSTRIAL"))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetCurrentEra@CvPlayer@@QBE?AW4EraTypes@@XZ ; CvPlayer::GetCurrentEra
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_0P@IGHGNBHE@ERA_INDUSTRIAL?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	esi, eax
	jle	SHORT $LN10@IsTimeToCh

; 4685 : 	{
; 4686 : 		return true;

	mov	al, 1
	jmp	$LN14@IsTimeToCh

; 4687 : 	}
; 4688 : 
; 4689 : 	// Check for the right number of buildings of a certain type (3 factories)
; 4690 : 	else

	jmp	$LN9@IsTimeToCh
$LN10@IsTimeToCh:

; 4691 : 	{
; 4692 : 		CvBuildingXMLEntries* pkGameBuildings = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	DWORD PTR _pkGameBuildings$225778[ebp], eax

; 4693 : 		CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(m_pPlayer->getCivilizationType());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkInfo$225779[ebp], eax

; 4694 : 		if(pkInfo)

	cmp	DWORD PTR _pkInfo$225779[ebp], 0
	je	SHORT $LN9@IsTimeToCh

; 4695 : 		{
; 4696 : 			// Find a building that triggers an ideology
; 4697 : 			// Loop through all building classes
; 4698 : #ifdef AUI_WARNING_FIXES
; 4699 : 			for (uint iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)
; 4700 : #else
; 4701 : 			for(int iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	DWORD PTR _iI$225781[ebp], 0
	jmp	SHORT $LN7@IsTimeToCh
$LN6@IsTimeToCh:
	mov	eax, DWORD PTR _iI$225781[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$225781[ebp], eax
$LN7@IsTimeToCh:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	DWORD PTR _iI$225781[ebp], eax
	jge	SHORT $LN9@IsTimeToCh

; 4702 : #endif
; 4703 : 			{
; 4704 : 				const BuildingTypes eBuilding = static_cast<BuildingTypes>(pkInfo->getCivilizationBuildings(iI));

	mov	ecx, DWORD PTR _iI$225781[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkInfo$225779[ebp]
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	DWORD PTR _eBuilding$225785[ebp], eax

; 4705 : 				CvBuildingEntry* pkBuildingInfo = NULL;

	mov	DWORD PTR _pkBuildingInfo$225787[ebp], 0

; 4706 : 				if(eBuilding != -1)

	cmp	DWORD PTR _eBuilding$225785[ebp], -1
	je	SHORT $LN4@IsTimeToCh

; 4707 : 				{
; 4708 : 					pkBuildingInfo = pkGameBuildings->GetEntry(eBuilding);

	mov	edx, DWORD PTR _eBuilding$225785[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkGameBuildings$225778[ebp]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkBuildingInfo$225787[ebp], eax

; 4709 : 					if (pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$225787[ebp], 0
	je	SHORT $LN4@IsTimeToCh

; 4710 : 					{
; 4711 : 						int iIdeologyTriggerCount = pkBuildingInfo->GetXBuiltTriggersIdeologyChoice();

	mov	ecx, DWORD PTR _pkBuildingInfo$225787[ebp]
	call	?GetXBuiltTriggersIdeologyChoice@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetXBuiltTriggersIdeologyChoice
	mov	DWORD PTR _iIdeologyTriggerCount$225790[ebp], eax

; 4712 : 						if (iIdeologyTriggerCount > 0)

	cmp	DWORD PTR _iIdeologyTriggerCount$225790[ebp], 0
	jle	SHORT $LN4@IsTimeToCh

; 4713 : 						{
; 4714 : 							if (m_pPlayer->getBuildingClassCount((BuildingClassTypes)iI) >= iIdeologyTriggerCount)

	mov	eax, DWORD PTR _iI$225781[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?getBuildingClassCount@CvPlayer@@QBEHW4BuildingClassTypes@@@Z ; CvPlayer::getBuildingClassCount
	cmp	eax, DWORD PTR _iIdeologyTriggerCount$225790[ebp]
	jl	SHORT $LN4@IsTimeToCh

; 4715 : 							{
; 4716 : 								return true;

	mov	al, 1
	jmp	SHORT $LN14@IsTimeToCh
$LN4@IsTimeToCh:

; 4717 : 							}
; 4718 : 						}
; 4719 : 					}
; 4720 : 				}
; 4721 : 			}

	jmp	SHORT $LN6@IsTimeToCh
$LN9@IsTimeToCh:

; 4722 : 		}
; 4723 : 	}
; 4724 : 
; 4725 : 	return false;

	xor	al, al
$LN14@IsTimeToCh:

; 4726 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTimeToChooseIdeology@CvPlayerPolicies@@QBE_NXZ ENDP	; CvPlayerPolicies::IsTimeToChooseIdeology
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >
PUBLIC	??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
PUBLIC	?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy
PUBLIC	??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
PUBLIC	?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back
PUBLIC	?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve
PUBLIC	??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
PUBLIC	?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z ; CvPlayerPolicies::GetAvailableTenets
EXTRN	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ:PROC ; CvGlobals::GetGamePolicies
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$5
__ehfuncinfo$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
_TEXT	SEGMENT
_this$ = -236						; size = 4
$T235895 = -52						; size = 4
_eTenet$226111 = -48					; size = 4
_pEntry$226112 = -44					; size = 4
_iI$226106 = -40					; size = 4
_iNumPolicies$ = -36					; size = 4
_availableTenets$ = -32					; size = 16
_pkPolicies$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_eBranch$ = 12						; size = 4
_iLevel$ = 16						; size = 4
?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z PROC ; CvPlayerPolicies::GetAvailableTenets, COMDAT
; _this$ = ecx

; 4730 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T235895[ebp], 0

; 4731 : 	std::vector<PolicyTypes> availableTenets;

	lea	ecx, DWORD PTR _availableTenets$[ebp]
	call	??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 4732 : 
; 4733 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies
	mov	DWORD PTR _pkPolicies$[ebp], eax

; 4734 : #ifdef AUI_WARNING_FIXES
; 4735 : 	const uint iNumPolicies = pkPolicies->GetNumPolicies();
; 4736 : 
; 4737 : 	availableTenets.reserve(iNumPolicies);
; 4738 : 	for (uint iI = 0; iI < iNumPolicies; iI++)
; 4739 : #else
; 4740 : 	const int iNumPolicies = pkPolicies->GetNumPolicies();

	mov	ecx, DWORD PTR _pkPolicies$[ebp]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _iNumPolicies$[ebp], eax

; 4741 : 
; 4742 : 	availableTenets.reserve(iNumPolicies);

	mov	eax, DWORD PTR _iNumPolicies$[ebp]
	push	eax
	lea	ecx, DWORD PTR _availableTenets$[ebp]
	call	?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve

; 4743 : 	for(int iI = 0; iI < iNumPolicies; iI++)

	mov	DWORD PTR _iI$226106[ebp], 0
	jmp	SHORT $LN4@GetAvailab
$LN3@GetAvailab:
	mov	ecx, DWORD PTR _iI$226106[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$226106[ebp], ecx
$LN4@GetAvailab:
	mov	edx, DWORD PTR _iI$226106[ebp]
	cmp	edx, DWORD PTR _iNumPolicies$[ebp]
	jge	SHORT $LN2@GetAvailab

; 4744 : #endif
; 4745 : 	{
; 4746 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));

	mov	eax, DWORD PTR _iI$226106[ebp]
	mov	DWORD PTR _eTenet$226111[ebp], eax

; 4747 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	ecx, DWORD PTR _eTenet$226111[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkPolicies$[ebp]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pEntry$226112[ebp], eax

; 4748 : 		if (pEntry && pEntry->GetPolicyBranchType() == eBranch && pEntry->GetLevel() == iLevel && !HasPolicy(eTenet))

	cmp	DWORD PTR _pEntry$226112[ebp], 0
	je	SHORT $LN1@GetAvailab
	mov	ecx, DWORD PTR _pEntry$226112[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[ebp]
	jne	SHORT $LN1@GetAvailab
	mov	ecx, DWORD PTR _pEntry$226112[ebp]
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	cmp	eax, DWORD PTR _iLevel$[ebp]
	jne	SHORT $LN1@GetAvailab
	mov	edx, DWORD PTR _eTenet$226111[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@GetAvailab

; 4749 : 		{
; 4750 : 			availableTenets.push_back(eTenet);

	lea	ecx, DWORD PTR _eTenet$226111[ebp]
	push	ecx
	lea	ecx, DWORD PTR _availableTenets$[ebp]
	call	?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back
$LN1@GetAvailab:

; 4751 : 		}
; 4752 : 	}

	jmp	SHORT $LN3@GetAvailab
$LN2@GetAvailab:

; 4753 : 
; 4754 : 	return availableTenets;

	lea	edx, DWORD PTR _availableTenets$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
	mov	eax, DWORD PTR $T235895[ebp]
	or	eax, 1
	mov	DWORD PTR $T235895[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _availableTenets$[ebp]
	call	?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4755 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$0:
	lea	ecx, DWORD PTR _availableTenets$[ebp]
	jmp	??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$1:
	mov	eax, DWORD PTR $T235895[ebp]
	and	eax, 1
	je	$LN9@GetAvailab
	and	DWORD PTR $T235895[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
$LN9@GetAvailab:
	ret	0
__unwindfunclet$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z$5:
	lea	ecx, DWORD PTR _availableTenets$[ebp]
	jmp	??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
__ehhandler$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetAvailableTenets@CvPlayerPolicies@@QAE?AV?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@W4PolicyBranchTypes@@H@Z ENDP ; CvPlayerPolicies::GetAvailableTenets
PUBLIC	?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z ; CvPlayerPolicies::GetTenet
; Function compile flags: /Odtp
;	COMDAT ?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_eTenet$226128 = -24					; size = 4
_pEntry$226129 = -20					; size = 4
_iI$226123 = -16					; size = 4
_iNumPolicies$ = -12					; size = 4
_iNumFound$ = -8					; size = 4
_pkPolicies$ = -4					; size = 4
_eBranch$ = 8						; size = 4
_iLevel$ = 12						; size = 4
_iIndex$ = 16						; size = 4
?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z PROC ; CvPlayerPolicies::GetTenet, COMDAT
; _this$ = ecx

; 4759 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4760 : 	int iNumFound = 0;

	mov	DWORD PTR _iNumFound$[ebp], 0

; 4761 : 
; 4762 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies
	mov	DWORD PTR _pkPolicies$[ebp], eax

; 4763 : #ifdef AUI_WARNING_FIXES
; 4764 : 	for (uint iI = 0; iI < pkPolicies->GetNumPolicies(); iI++)
; 4765 : #else
; 4766 : 	const int iNumPolicies = pkPolicies->GetNumPolicies();

	mov	ecx, DWORD PTR _pkPolicies$[ebp]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _iNumPolicies$[ebp], eax

; 4767 : 
; 4768 : 	for(int iI = 0; iI < iNumPolicies; iI++)

	mov	DWORD PTR _iI$226123[ebp], 0
	jmp	SHORT $LN5@GetTenet
$LN4@GetTenet:
	mov	eax, DWORD PTR _iI$226123[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226123[ebp], eax
$LN5@GetTenet:
	mov	ecx, DWORD PTR _iI$226123[ebp]
	cmp	ecx, DWORD PTR _iNumPolicies$[ebp]
	jge	SHORT $LN3@GetTenet

; 4769 : #endif
; 4770 : 	{
; 4771 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));

	mov	edx, DWORD PTR _iI$226123[ebp]
	mov	DWORD PTR _eTenet$226128[ebp], edx

; 4772 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	eax, DWORD PTR _eTenet$226128[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPolicies$[ebp]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pEntry$226129[ebp], eax

; 4773 : 		if (pEntry && pEntry->GetPolicyBranchType() == eBranch && pEntry->GetLevel() == iLevel && HasPolicy(eTenet))

	cmp	DWORD PTR _pEntry$226129[ebp], 0
	je	SHORT $LN2@GetTenet
	mov	ecx, DWORD PTR _pEntry$226129[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[ebp]
	jne	SHORT $LN2@GetTenet
	mov	ecx, DWORD PTR _pEntry$226129[ebp]
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	cmp	eax, DWORD PTR _iLevel$[ebp]
	jne	SHORT $LN2@GetTenet
	mov	ecx, DWORD PTR _eTenet$226128[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetTenet

; 4774 : 		{
; 4775 : 			iNumFound++;

	mov	eax, DWORD PTR _iNumFound$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumFound$[ebp], eax

; 4776 : 			if (iNumFound == iIndex)

	mov	ecx, DWORD PTR _iNumFound$[ebp]
	cmp	ecx, DWORD PTR _iIndex$[ebp]
	jne	SHORT $LN2@GetTenet

; 4777 : 			{
; 4778 : 				return eTenet;

	mov	eax, DWORD PTR _eTenet$226128[ebp]
	jmp	SHORT $LN6@GetTenet
$LN2@GetTenet:

; 4779 : 			}
; 4780 : 		}
; 4781 : 	}

	jmp	SHORT $LN4@GetTenet
$LN3@GetTenet:

; 4782 : 
; 4783 : 	return NO_POLICY;

	or	eax, -1
$LN6@GetTenet:

; 4784 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTenet@CvPlayerPolicies@@QAE?AW4PolicyTypes@@W4PolicyBranchTypes@@HH@Z ENDP ; CvPlayerPolicies::GetTenet
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_eTenet$226145 = -24					; size = 4
_pEntry$226146 = -20					; size = 4
_iI$226140 = -16					; size = 4
_iNumPolicies$ = -12					; size = 4
_iNumFound$ = -8					; size = 4
_pkPolicies$ = -4					; size = 4
_eBranch$ = 8						; size = 4
_iLevel$ = 12						; size = 4
?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z PROC ; CvPlayerPolicies::GetNumTenetsOfLevel, COMDAT
; _this$ = ecx

; 4788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 4789 : 	int iNumFound = 0;

	mov	DWORD PTR _iNumFound$[ebp], 0

; 4790 : 
; 4791 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies
	mov	DWORD PTR _pkPolicies$[ebp], eax

; 4792 : #ifdef AUI_WARNING_FIXES
; 4793 : 	for (uint iI = 0; iI < pkPolicies->GetNumPolicies(); iI++)
; 4794 : #else
; 4795 : 	const int iNumPolicies = pkPolicies->GetNumPolicies();

	mov	ecx, DWORD PTR _pkPolicies$[ebp]
	call	?GetNumPolicies@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicies
	mov	DWORD PTR _iNumPolicies$[ebp], eax

; 4796 : 
; 4797 : 	for(int iI = 0; iI < iNumPolicies; iI++)

	mov	DWORD PTR _iI$226140[ebp], 0
	jmp	SHORT $LN4@GetNumTene
$LN3@GetNumTene:
	mov	eax, DWORD PTR _iI$226140[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226140[ebp], eax
$LN4@GetNumTene:
	mov	ecx, DWORD PTR _iI$226140[ebp]
	cmp	ecx, DWORD PTR _iNumPolicies$[ebp]
	jge	SHORT $LN2@GetNumTene

; 4798 : #endif
; 4799 : 	{
; 4800 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));

	mov	edx, DWORD PTR _iI$226140[ebp]
	mov	DWORD PTR _eTenet$226145[ebp], edx

; 4801 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	eax, DWORD PTR _eTenet$226145[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkPolicies$[ebp]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pEntry$226146[ebp], eax

; 4802 : 		if (pEntry && pEntry->GetPolicyBranchType() == eBranch && pEntry->GetLevel() == iLevel && HasPolicy(eTenet))

	cmp	DWORD PTR _pEntry$226146[ebp], 0
	je	SHORT $LN1@GetNumTene
	mov	ecx, DWORD PTR _pEntry$226146[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eBranch$[ebp]
	jne	SHORT $LN1@GetNumTene
	mov	ecx, DWORD PTR _pEntry$226146[ebp]
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	cmp	eax, DWORD PTR _iLevel$[ebp]
	jne	SHORT $LN1@GetNumTene
	mov	ecx, DWORD PTR _eTenet$226145[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@GetNumTene

; 4803 : 		{
; 4804 : 			iNumFound++;

	mov	eax, DWORD PTR _iNumFound$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumFound$[ebp], eax
$LN1@GetNumTene:

; 4805 : 		}
; 4806 : 	}

	jmp	SHORT $LN3@GetNumTene
$LN2@GetNumTene:

; 4807 : 
; 4808 : 	return iNumFound;

	mov	eax, DWORD PTR _iNumFound$[ebp]

; 4809 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetNumTenetsOfLevel@CvPlayerPolicies@@QBEHW4PolicyBranchTypes@@H@Z ENDP ; CvPlayerPolicies::GetNumTenetsOfLevel
_TEXT	ENDS
PUBLIC	?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ	; CvPlayerPolicies::CanGetAdvancedTenet
; Function compile flags: /Odtp
;	COMDAT ?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_eTenet$226159 = -20					; size = 4
_pEntry$226160 = -16					; size = 4
_iI$226154 = -12					; size = 4
_eIdeology$ = -8					; size = 4
_pkPolicies$ = -4					; size = 4
?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ PROC	; CvPlayerPolicies::CanGetAdvancedTenet, COMDAT
; _this$ = ecx

; 4813 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 4814 : 	PolicyBranchTypes eIdeology = GetLateGamePolicyTree();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLateGamePolicyTree@CvPlayerPolicies@@QBE?AW4PolicyBranchTypes@@XZ ; CvPlayerPolicies::GetLateGamePolicyTree
	mov	DWORD PTR _eIdeology$[ebp], eax

; 4815 : 	if (eIdeology == NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eIdeology$[ebp], -1
	jne	SHORT $LN5@CanGetAdva

; 4816 : 	{
; 4817 : 		return false;

	xor	al, al
	jmp	$LN6@CanGetAdva
$LN5@CanGetAdva:

; 4818 : 	}
; 4819 : 		
; 4820 : 	CvPolicyXMLEntries* pkPolicies = GC.GetGamePolicies();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGamePolicies@CvGlobals@@QBEPAVCvPolicyXMLEntries@@XZ ; CvGlobals::GetGamePolicies
	mov	DWORD PTR _pkPolicies$[ebp], eax

; 4821 : #ifdef AUI_WARNING_FIXES
; 4822 : 	for (uint iI = 0; iI < GC.getNumPolicyInfos(); iI++)
; 4823 : #else
; 4824 : 	for(int iI = 0; iI < GC.getNumPolicyInfos(); iI++)

	mov	DWORD PTR _iI$226154[ebp], 0
	jmp	SHORT $LN4@CanGetAdva
$LN3@CanGetAdva:
	mov	eax, DWORD PTR _iI$226154[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226154[ebp], eax
$LN4@CanGetAdva:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPolicyInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPolicyInfos
	cmp	DWORD PTR _iI$226154[ebp], eax
	jge	SHORT $LN2@CanGetAdva

; 4825 : #endif
; 4826 : 	{
; 4827 : 		const PolicyTypes eTenet(static_cast<PolicyTypes>(iI));

	mov	ecx, DWORD PTR _iI$226154[ebp]
	mov	DWORD PTR _eTenet$226159[ebp], ecx

; 4828 : 		CvPolicyEntry* pEntry = pkPolicies->GetPolicyEntry(eTenet);

	mov	edx, DWORD PTR _eTenet$226159[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkPolicies$[ebp]
	call	?GetPolicyEntry@CvPolicyXMLEntries@@QAEPAVCvPolicyEntry@@H@Z ; CvPolicyXMLEntries::GetPolicyEntry
	mov	DWORD PTR _pEntry$226160[ebp], eax

; 4829 : 		if (pEntry && pEntry->GetPolicyBranchType() == eIdeology && pEntry->GetLevel() > 1 && !HasPolicy(eTenet) && CanAdoptPolicy(eTenet))

	cmp	DWORD PTR _pEntry$226160[ebp], 0
	je	SHORT $LN1@CanGetAdva
	mov	ecx, DWORD PTR _pEntry$226160[ebp]
	call	?GetPolicyBranchType@CvPolicyEntry@@QBEHXZ ; CvPolicyEntry::GetPolicyBranchType
	cmp	eax, DWORD PTR _eIdeology$[ebp]
	jne	SHORT $LN1@CanGetAdva
	mov	ecx, DWORD PTR _pEntry$226160[ebp]
	call	?GetLevel@CvPolicyEntry@@QBEHXZ		; CvPolicyEntry::GetLevel
	cmp	eax, 1
	jle	SHORT $LN1@CanGetAdva
	mov	eax, DWORD PTR _eTenet$226159[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@CanGetAdva
	push	0
	mov	edx, DWORD PTR _eTenet$226159[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanAdoptPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@_N@Z ; CvPlayerPolicies::CanAdoptPolicy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@CanGetAdva

; 4830 : 		{
; 4831 : 			return true;

	mov	al, 1
	jmp	SHORT $LN6@CanGetAdva
$LN1@CanGetAdva:

; 4832 : 		}
; 4833 : 	}

	jmp	SHORT $LN3@CanGetAdva
$LN2@CanGetAdva:

; 4834 : 
; 4835 : 	return false;

	xor	al, al
$LN6@CanGetAdva:

; 4836 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CanGetAdvancedTenet@CvPlayerPolicies@@QBE_NXZ ENDP	; CvPlayerPolicies::CanGetAdvancedTenet
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DoPolicyAI@CvPlayerPolicies@@QAEXXZ		; CvPlayerPolicies::DoPolicyAI
EXTRN	?doAdoptPolicy@CvPlayer@@QAEXW4PolicyTypes@@@Z:PROC ; CvPlayer::doAdoptPolicy
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z:PROC ; CvPolicyAI::ChooseNextPolicy
EXTRN	?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z:PROC ; CvPolicyAI::DoConsiderIdeologySwitch
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ$0
__ehfuncinfo$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
xdata$x	ENDS
;	COMDAT ?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
_iNextPolicy$226171 = -48				; size = 4
_strBuffer$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?DoPolicyAI@CvPlayerPolicies@@QAEXXZ PROC		; CvPlayerPolicies::DoPolicyAI, COMDAT
; _this$ = ecx

; 4842 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 4843 : 	CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4844 : 
; 4845 : 	m_pPolicyAI->DoConsiderIdeologySwitch(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?DoConsiderIdeologySwitch@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoConsiderIdeologySwitch

; 4846 : 
; 4847 : 	// Do we have enough points to buy a new policy?
; 4848 : 	if(m_pPlayer->getNextPolicyCost() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	test	eax, eax
	jle	$LN7@DoPolicyAI
$LN6@DoPolicyAI:

; 4849 : 	{
; 4850 : 		// Adopt new policies until we run out of freebies and culture (usually only one per turn)
; 4851 : 		while(m_pPlayer->getJONSCulture() >= m_pPlayer->getNextPolicyCost() || m_pPlayer->GetNumFreePolicies() > 0 || m_pPlayer->GetNumFreeTenets() > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?getJONSCulture@CvPlayer@@QBEHXZ	; CvPlayer::getJONSCulture
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	cmp	esi, eax
	jge	SHORT $LN4@DoPolicyAI
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	call	?GetNumFreePolicies@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreePolicies
	test	eax, eax
	jg	SHORT $LN4@DoPolicyAI
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetNumFreeTenets@CvPlayer@@QBEHXZ	; CvPlayer::GetNumFreeTenets
	test	eax, eax
	jle	SHORT $LN7@DoPolicyAI
$LN4@DoPolicyAI:

; 4852 : 		{
; 4853 : 			// Choose the policy we want next (or a branch)
; 4854 : #ifdef AUI_WARNING_FIXES
; 4855 : 			uint iNextPolicy = m_pPolicyAI->ChooseNextPolicy(m_pPlayer);
; 4856 : 			if (iNextPolicy == (uint)NO_POLICY)
; 4857 : #else
; 4858 : 			int iNextPolicy = m_pPolicyAI->ChooseNextPolicy(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	call	?ChooseNextPolicy@CvPolicyAI@@QAEHPAVCvPlayer@@@Z ; CvPolicyAI::ChooseNextPolicy
	mov	DWORD PTR _iNextPolicy$226171[ebp], eax

; 4859 : 			if (iNextPolicy == NO_POLICY)

	cmp	DWORD PTR _iNextPolicy$226171[ebp], -1
	jne	SHORT $LN3@DoPolicyAI

; 4860 : #endif
; 4861 : 				break;

	jmp	SHORT $LN7@DoPolicyAI
$LN3@DoPolicyAI:

; 4862 : 
; 4863 : 			// These actions should spend our number of free policies or our culture, otherwise we'll loop forever
; 4864 : 			if(iNextPolicy < m_pPolicies->GetNumPolicyBranches()) // Low return values indicate a branch has been chosen

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	cmp	DWORD PTR _iNextPolicy$226171[ebp], eax
	jge	SHORT $LN2@DoPolicyAI

; 4865 : 			{
; 4866 : 				m_pPlayer->GetPlayerPolicies()->DoUnlockPolicyBranch((PolicyBranchTypes)iNextPolicy);

	mov	eax, DWORD PTR _iNextPolicy$226171[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?DoUnlockPolicyBranch@CvPlayerPolicies@@QAEXW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::DoUnlockPolicyBranch

; 4867 : 			}
; 4868 : 			else

	jmp	SHORT $LN1@DoPolicyAI
$LN2@DoPolicyAI:

; 4869 : 			{
; 4870 : 				m_pPlayer->doAdoptPolicy((PolicyTypes)(iNextPolicy - m_pPolicies->GetNumPolicyBranches()));

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	call	?GetNumPolicyBranches@CvPolicyXMLEntries@@QAEHXZ ; CvPolicyXMLEntries::GetNumPolicyBranches
	mov	ecx, DWORD PTR _iNextPolicy$226171[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?doAdoptPolicy@CvPlayer@@QAEXW4PolicyTypes@@@Z ; CvPlayer::doAdoptPolicy
$LN1@DoPolicyAI:

; 4871 : 			}
; 4872 : 		}

	jmp	$LN6@DoPolicyAI
$LN7@DoPolicyAI:

; 4873 : 	}
; 4874 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strBuffer$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoPolicyAI@CvPlayerPolicies@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoPolicyAI@CvPlayerPolicies@@QAEXXZ ENDP		; CvPlayerPolicies::DoPolicyAI
PUBLIC	?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ	; CvPlayerPolicies::DoChooseIdeology
EXTRN	?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z:PROC ; CvPolicyAI::DoChooseIdeology
; Function compile flags: /Odtp
;	COMDAT ?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ PROC		; CvPlayerPolicies::DoChooseIdeology, COMDAT
; _this$ = ecx

; 4878 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4879 : 	m_pPolicyAI->DoChooseIdeology(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?DoChooseIdeology@CvPolicyAI@@QAEXPAVCvPlayer@@@Z ; CvPolicyAI::DoChooseIdeology

; 4880 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoChooseIdeology@CvPlayerPolicies@@QAEXXZ ENDP		; CvPlayerPolicies::DoChooseIdeology
_TEXT	ENDS
PUBLIC	??_C@_0BE@EEBBMCFH@FLAVOR_CITY_DEFENSE?$AA@	; `string'
PUBLIC	??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@		; `string'
PUBLIC	??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@	; `string'
PUBLIC	??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@		; `string'
PUBLIC	??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@ ; `string'
EXTRN	?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z:PROC ; CvPolicyAI::AddFlavorWeights
EXTRN	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z:PROC ; CvPlayer::GetUnhappiness
EXTRN	?GetHappiness@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetHappiness
EXTRN	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z:PROC ; CvEconomicAI::IsUsingStrategy
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
EXTRN	?getAtWarCount@CvTeam@@QBEH_N@Z:PROC		; CvTeam::getAtWarCount
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
;	COMDAT ??_C@_0BE@EEBBMCFH@FLAVOR_CITY_DEFENSE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
CONST	SEGMENT
??_C@_0BE@EEBBMCFH@FLAVOR_CITY_DEFENSE?$AA@ DB 'FLAVOR_CITY_DEFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
CONST	SEGMENT
??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@ DB 'FLAVOR_DEFENSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@
CONST	SEGMENT
??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@ DB 'FLAVOR_HAPPINESS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
CONST	SEGMENT
??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@ DB 'FLAVOR_GOLD', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
CONST	SEGMENT
??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@ DB 'ECONOMICAISTRA'
	DB	'TEGY_LOSING_MONEY', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpolicyclasses.cpp
CONST	ENDS
;	COMDAT ?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T236200 = -32						; size = 4
$T236199 = -28						; size = 4
$T236190 = -24						; size = 4
_bInDeficit$226196 = -18				; size = 1
_bIsAtWarWithSomeone$226195 = -17			; size = 1
_kTeam$226194 = -16					; size = 4
_eStrategyLosingMoney$226190 = -12			; size = 4
_iFlavor$226185 = -8					; size = 4
_iFlavorValue$ = -4					; size = 4
_iPropagatePercent$ = 8					; size = 4
?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z PROC	; CvPlayerPolicies::AddFlavorAsStrategies, COMDAT
; _this$ = ecx

; 4886 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 4887 : 	int iFlavorValue;
; 4888 : 
; 4889 : 	// Start by resetting the AI
; 4890 : 	m_pPolicyAI->Reset();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	call	?Reset@CvPolicyAI@@QAEXXZ		; CvPolicyAI::Reset

; 4891 : 
; 4892 : 	// Now populate the AI with the current flavor information
; 4893 : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$226185[ebp], 0
	jmp	SHORT $LN12@AddFlavorA
$LN11@AddFlavorA:
	mov	ecx, DWORD PTR _iFlavor$226185[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavor$226185[ebp], ecx
$LN12@AddFlavorA:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T236190[ebp], edx
	mov	eax, DWORD PTR _iFlavor$226185[ebp]
	cmp	eax, DWORD PTR $T236190[ebp]
	jge	$LN13@AddFlavorA

; 4894 : 	{
; 4895 : //		OLD WAY: use CURRENT player flavors
; 4896 : //		iFlavorValue = GetLatestFlavorValue((FlavorTypes) iFlavor);
; 4897 : 
; 4898 : //		NEW WAY: use PERSONALITY flavors (since policy choices are LONG-TERM)
; 4899 : //		EVEN NEWER WAY: add in a modifier for the Grand Strategy we are running (since these are also long term)
; 4900 : 		iFlavorValue = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavor);

	mov	ecx, DWORD PTR _iFlavor$226185[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorValue$[ebp], eax

; 4901 : 
; 4902 : //		Boost flavor even further based on in-game conditions
; 4903 : 		
; 4904 : 
; 4905 : 		EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY", true);

	push	1
	push	OFFSET ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyLosingMoney$226190[ebp], eax

; 4906 : 		if (eStrategyLosingMoney == NO_ECONOMICAISTRATEGY)

	cmp	DWORD PTR _eStrategyLosingMoney$226190[ebp], -1
	jne	SHORT $LN9@AddFlavorA

; 4907 : 		{
; 4908 : 			continue;

	jmp	SHORT $LN11@AddFlavorA
$LN9@AddFlavorA:

; 4909 : 		}
; 4910 : 		CvTeam& kTeam = GET_TEAM(m_pPlayer->getTeam());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR $T236199[ebp], ecx
	mov	edx, DWORD PTR $T236199[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236200[ebp], eax
	mov	ecx, DWORD PTR $T236200[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$226194[ebp], ecx

; 4911 : 		bool bIsAtWarWithSomeone = (kTeam.getAtWarCount(false) > 0);

	push	0
	mov	ecx, DWORD PTR _kTeam$226194[ebp]
	call	?getAtWarCount@CvTeam@@QBEH_N@Z		; CvTeam::getAtWarCount
	xor	edx, edx
	test	eax, eax
	setg	dl
	mov	BYTE PTR _bIsAtWarWithSomeone$226195[ebp], dl

; 4912 : 		bool bInDeficit = m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	eax, DWORD PTR _eStrategyLosingMoney$226190[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	mov	BYTE PTR _bInDeficit$226196[ebp], al

; 4913 : 
; 4914 : 		if(bInDeficit && iFlavor == GC.getInfoTypeForString("FLAVOR_GOLD"))

	movzx	edx, BYTE PTR _bInDeficit$226196[ebp]
	test	edx, edx
	je	SHORT $LN8@AddFlavorA
	push	0
	push	OFFSET ??_C@_0M@IKAIFEKA@FLAVOR_GOLD?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _iFlavor$226185[ebp], eax
	jne	SHORT $LN8@AddFlavorA

; 4915 : 		{
; 4916 : 			iFlavorValue += 5;

	mov	eax, DWORD PTR _iFlavorValue$[ebp]
	add	eax, 5
	mov	DWORD PTR _iFlavorValue$[ebp], eax
	jmp	$LN7@AddFlavorA
$LN8@AddFlavorA:

; 4917 : 		}
; 4918 : 		else if(m_pPlayer->GetHappiness() < m_pPlayer->GetUnhappiness() && iFlavor == GC.getInfoTypeForString("FLAVOR_HAPPINESS"))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?GetHappiness@CvPlayer@@QBEHXZ		; CvPlayer::GetHappiness
	mov	esi, eax
	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	cmp	esi, eax
	jge	SHORT $LN6@AddFlavorA
	push	0
	push	OFFSET ??_C@_0BB@OGEJLBEB@FLAVOR_HAPPINESS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _iFlavor$226185[ebp], eax
	jne	SHORT $LN6@AddFlavorA

; 4919 : 		{
; 4920 : 			iFlavorValue += 5;

	mov	eax, DWORD PTR _iFlavorValue$[ebp]
	add	eax, 5
	mov	DWORD PTR _iFlavorValue$[ebp], eax
	jmp	SHORT $LN7@AddFlavorA
$LN6@AddFlavorA:

; 4921 : 		}
; 4922 : 		else if(bIsAtWarWithSomeone && iFlavor == GC.getInfoTypeForString("FLAVOR_DEFENSE"))

	movzx	ecx, BYTE PTR _bIsAtWarWithSomeone$226195[ebp]
	test	ecx, ecx
	je	SHORT $LN4@AddFlavorA
	push	0
	push	OFFSET ??_C@_0P@CHEPBLFE@FLAVOR_DEFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _iFlavor$226185[ebp], eax
	jne	SHORT $LN4@AddFlavorA

; 4923 : 		{
; 4924 : 			iFlavorValue += 3;

	mov	edx, DWORD PTR _iFlavorValue$[ebp]
	add	edx, 3
	mov	DWORD PTR _iFlavorValue$[ebp], edx
	jmp	SHORT $LN7@AddFlavorA
$LN4@AddFlavorA:

; 4925 : 		}
; 4926 : 		else if(bIsAtWarWithSomeone && iFlavor == GC.getInfoTypeForString("FLAVOR_CITY_DEFENSE"))

	movzx	eax, BYTE PTR _bIsAtWarWithSomeone$226195[ebp]
	test	eax, eax
	je	SHORT $LN7@AddFlavorA
	push	0
	push	OFFSET ??_C@_0BE@EEBBMCFH@FLAVOR_CITY_DEFENSE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	cmp	DWORD PTR _iFlavor$226185[ebp], eax
	jne	SHORT $LN7@AddFlavorA

; 4927 : 		{
; 4928 : 			iFlavorValue += 3;

	mov	ecx, DWORD PTR _iFlavorValue$[ebp]
	add	ecx, 3
	mov	DWORD PTR _iFlavorValue$[ebp], ecx
$LN7@AddFlavorA:

; 4929 : 		}
; 4930 : 
; 4931 : 		if(iFlavorValue > 0)

	cmp	DWORD PTR _iFlavorValue$[ebp], 0
	jle	SHORT $LN1@AddFlavorA

; 4932 : 		{
; 4933 : 			m_pPolicyAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue, iPropagatePercent);

	mov	edx, DWORD PTR _iPropagatePercent$[ebp]
	push	edx
	mov	eax, DWORD PTR _iFlavorValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iFlavor$226185[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+56]
	call	?AddFlavorWeights@CvPolicyAI@@QAEXW4FlavorTypes@@HH@Z ; CvPolicyAI::AddFlavorWeights
$LN1@AddFlavorA:

; 4934 : 		}

	jmp	$LN11@AddFlavorA
$LN13@AddFlavorA:

; 4935 : 	}
; 4936 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?AddFlavorAsStrategies@CvPlayerPolicies@@AAEXH@Z ENDP	; CvPlayerPolicies::AddFlavorAsStrategies
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z PROC ; CvPlayerPolicies::LogFlavors, COMDAT
; _this$ = ecx

; 4939 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 4940 : 	return; // Now using personality flavors, so this is unnecessary (or is it?)
; 4941 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?LogFlavors@CvPlayerPolicies@@EAEXW4FlavorTypes@@@Z ENDP ; CvPlayerPolicies::LogFlavors
_TEXT	ENDS
PUBLIC	?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumPlayersWithBranchUnlocked
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
; Function compile flags: /Odtp
;	COMDAT ?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
$T236219 = -13						; size = 1
_kPlayer$226222 = -12					; size = 4
_iI$226218 = -8						; size = 4
_iRtnValue$ = -4					; size = 4
_eBranch$ = 8						; size = 4
?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z PROC ; PolicyHelpers::GetNumPlayersWithBranchUnlocked, COMDAT

; 4946 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4947 : 	int iRtnValue = 0;

	mov	DWORD PTR _iRtnValue$[ebp], 0

; 4948 : 
; 4949 : 	for (int iI = 0; iI < MAX_CIV_PLAYERS; iI++)

	mov	DWORD PTR _iI$226218[ebp], 0
	jmp	SHORT $LN5@GetNumPlay
$LN4@GetNumPlay:
	mov	eax, DWORD PTR _iI$226218[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$226218[ebp], eax
$LN5@GetNumPlay:
	cmp	DWORD PTR _iI$226218[ebp], 63		; 0000003fH
	jge	SHORT $LN3@GetNumPlay

; 4950 : 	{
; 4951 : 		CvPlayer &kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$226218[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _kPlayer$226222[ebp], ecx

; 4952 : 
; 4953 : 		if (kPlayer.isAlive() && !kPlayer.isMinorCiv() && !kPlayer.isBarbarian())

	mov	edx, DWORD PTR _kPlayer$226222[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T236219[ebp], al
	movzx	ecx, BYTE PTR $T236219[ebp]
	test	ecx, ecx
	je	SHORT $LN2@GetNumPlay
	mov	ecx, DWORD PTR _kPlayer$226222[ebp]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@GetNumPlay
	mov	ecx, DWORD PTR _kPlayer$226222[ebp]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetNumPlay

; 4954 : 		{
; 4955 : 			if (kPlayer.GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))

	mov	ecx, DWORD PTR _eBranch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPlayer$226222[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@GetNumPlay

; 4956 : 			{
; 4957 : 				iRtnValue++;

	mov	eax, DWORD PTR _iRtnValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _iRtnValue$[ebp], eax
$LN2@GetNumPlay:

; 4958 : 			}
; 4959 : 		}
; 4960 : 	}

	jmp	SHORT $LN4@GetNumPlay
$LN3@GetNumPlay:

; 4961 : 
; 4962 : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[ebp]

; 4963 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ENDP ; PolicyHelpers::GetNumPlayersWithBranchUnlocked
_TEXT	ENDS
EXTRN	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getStartEra
; Function compile flags: /Odtp
;	COMDAT ?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z
_TEXT	SEGMENT
$T236225 = -16						; size = 4
_iNumPreviousUnlockers$226233 = -12			; size = 4
_pkEntry$ = -8						; size = 4
_iFreePolicies$ = -4					; size = 4
_eBranch$ = 8						; size = 4
?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z PROC ; PolicyHelpers::GetNumFreePolicies, COMDAT

; 4966 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 4967 : 	int iFreePolicies = 0;

	mov	DWORD PTR _iFreePolicies$[ebp], 0

; 4968 : 
; 4969 : 	CvPolicyBranchEntry *pkEntry = GC.getPolicyBranchInfo(eBranch);

	mov	eax, DWORD PTR _eBranch$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPolicyBranchInfo@CvGlobals@@QAEPAVCvPolicyBranchEntry@@W4PolicyBranchTypes@@@Z ; CvGlobals::getPolicyBranchInfo
	mov	DWORD PTR _pkEntry$[ebp], eax

; 4970 : 	if (pkEntry)

	cmp	DWORD PTR _pkEntry$[ebp], 0
	je	SHORT $LN5@GetNumFree@2

; 4971 : 	{
; 4972 : 		if (pkEntry->GetEraPrereq() >= GC.getGame().getStartEra())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236225[ebp], ecx
	mov	ecx, DWORD PTR _pkEntry$[ebp]
	call	?GetEraPrereq@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetEraPrereq
	mov	esi, eax
	mov	ecx, DWORD PTR $T236225[ebp]
	call	?getStartEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getStartEra
	cmp	esi, eax
	jl	SHORT $LN5@GetNumFree@2

; 4973 : 		{
; 4974 : 			int iNumPreviousUnlockers = PolicyHelpers::GetNumPlayersWithBranchUnlocked(eBranch);

	mov	edx, DWORD PTR _eBranch$[ebp]
	push	edx
	call	?GetNumPlayersWithBranchUnlocked@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ; PolicyHelpers::GetNumPlayersWithBranchUnlocked
	add	esp, 4
	mov	DWORD PTR _iNumPreviousUnlockers$226233[ebp], eax

; 4975 : 			if (iNumPreviousUnlockers == 0)

	cmp	DWORD PTR _iNumPreviousUnlockers$226233[ebp], 0
	jne	SHORT $LN3@GetNumFree@2

; 4976 : 			{
; 4977 : 				iFreePolicies = pkEntry->GetFirstAdopterFreePolicies();

	mov	ecx, DWORD PTR _pkEntry$[ebp]
	call	?GetFirstAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetFirstAdopterFreePolicies
	mov	DWORD PTR _iFreePolicies$[ebp], eax
	jmp	SHORT $LN5@GetNumFree@2
$LN3@GetNumFree@2:

; 4978 : 			}
; 4979 : 			else if (iNumPreviousUnlockers == 1)

	cmp	DWORD PTR _iNumPreviousUnlockers$226233[ebp], 1
	jne	SHORT $LN5@GetNumFree@2

; 4980 : 			{
; 4981 : 				iFreePolicies = pkEntry->GetSecondAdopterFreePolicies();

	mov	ecx, DWORD PTR _pkEntry$[ebp]
	call	?GetSecondAdopterFreePolicies@CvPolicyBranchEntry@@QBEHXZ ; CvPolicyBranchEntry::GetSecondAdopterFreePolicies
	mov	DWORD PTR _iFreePolicies$[ebp], eax
$LN5@GetNumFree@2:

; 4982 : 			}
; 4983 : 		}
; 4984 : 	}
; 4985 : 
; 4986 : 	return iFreePolicies;

	mov	eax, DWORD PTR _iFreePolicies$[ebp]

; 4987 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumFreePolicies@PolicyHelpers@@YAHW4PolicyBranchTypes@@@Z ENDP ; PolicyHelpers::GetNumFreePolicies
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T236229 = -2						; size = 1
$T236228 = -1						; size = 1
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ PROC ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >, COMDAT
; _this$ = ecx

; 228  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T236228[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236229[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >

; 229  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$multimap@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@@std@@QAE@XZ ENDP ; std::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >::multimap<int,int,std::less<int>,std::allocator<std::pair<int const ,int> > >
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv137 = -192						; size = 4
tv163 = -188						; size = 4
tv189 = -184						; size = 4
_this$ = -180						; size = 4
$T236408 = -46						; size = 1
$T236390 = -45						; size = 1
$T236379 = -44						; size = 4
$T236400 = -40						; size = 4
$T236372 = -36						; size = 4
$T236362 = -28						; size = 4
$T236348 = -21						; size = 1
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T236408[ebp]
	mov	DWORD PTR $T236362[ebp], eax
	lea	ecx, DWORD PTR $T236390[ebp]
	mov	DWORD PTR $T236372[ebp], ecx
	push	ecx
	mov	edx, esp
	mov	DWORD PTR $T236400[ebp], esp
	mov	DWORD PTR $T236379[ebp], edx
	lea	eax, DWORD PTR $T236348[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	mov	DWORD PTR tv189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-196]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T236827 = -8						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236827[ebp], eax
	mov	ecx, DWORD PTR $T236827[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
; Function compile flags: /Odtp
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z
_TEXT	SEGMENT
tv93 = -48						; size = 4
_this$ = -44						; size = 4
$T236926 = -40						; size = 4
$T236905 = -36						; size = 4
$T236894 = -32						; size = 4
$T236885 = -28						; size = 4
$T236845 = -16						; size = 4
$T236843 = -12						; size = 4
$T236842 = -8						; size = 4
__Where$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find, COMDAT
; _this$ = ecx

; 986  : 		{	// find an element in nonmutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		const_iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
	mov	DWORD PTR $T236885[ebp], eax
	mov	ecx, DWORD PTR $T236885[ebp]
	mov	DWORD PTR __Where$[ebp], ecx

; 988  : 		return (_Where == end()
; 989  : 			|| _DEBUG_LT_PRED(this->comp,
; 990  : 				_Keyval, _Key(_Where._Mynode()))
; 991  : 					? end() : _Where);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T236894[ebp], eax
	mov	ecx, DWORD PTR $T236894[ebp]
	mov	DWORD PTR $T236843[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T236843[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T236905[ebp], edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	mov	ecx, DWORD PTR $T236905[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+12]
	setl	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@find
	lea	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv93[ebp], edx
	jmp	SHORT $LN4@find
$LN3@find:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T236926[ebp], ecx
	mov	edx, DWORD PTR $T236926[ebp]
	mov	DWORD PTR $T236845[ebp], edx
	lea	eax, DWORD PTR $T236845[ebp]
	mov	DWORD PTR tv93[ebp], eax
$LN4@find:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T236842[ebp], ecx
	mov	edx, DWORD PTR $T236842[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 992  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QBE?AVconst_iterator@12@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::find
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$1
__ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -376						; size = 4
$T236983 = -52						; size = 4
$T236982 = -48						; size = 4
__Tmp$236981 = -44					; size = 4
$T236976 = -40						; size = 4
$T236975 = -36						; size = 4
__Tmp$236974 = -32					; size = 4
__Tmp$226337 = -24					; size = 12
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap, COMDAT
; _this$ = ecx

; 1033 : 		{	// exchange contents with _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1034 : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN16@swap
	jmp	$LN5@swap

; 1035 : 			;	// same object, do nothing
; 1036 : 		else if (get_allocator() == _Right.get_allocator())

$LN16@swap:
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN31@swap

; 1037 : 			{	// same allocator, swap control information
; 1038 : 
; 1039 :  #if _HAS_ITERATOR_DEBUGGING
; 1040 : 			this->_Swap_all(_Right);
; 1041 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1042 : 
; 1043 : 			this->_Swap_aux(_Right);
; 1044 : 
; 1045 : 			_STD _Swap_adl(this->comp, _Right.comp);
; 1046 : 			_STD swap(_Myhead, _Right._Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 4
	mov	DWORD PTR $T236976[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T236975[ebp], ecx
	mov	edx, DWORD PTR $T236975[ebp]
	cmp	edx, DWORD PTR $T236976[ebp]
	je	SHORT $LN26@swap
	mov	eax, DWORD PTR $T236975[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$236974[ebp], ecx
	mov	edx, DWORD PTR $T236975[ebp]
	mov	eax, DWORD PTR $T236976[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T236976[ebp]
	mov	eax, DWORD PTR __Tmp$236974[ebp]
	mov	DWORD PTR [edx], eax
$LN26@swap:

; 1047 : 			_STD swap(_Mysize, _Right._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 8
	mov	DWORD PTR $T236983[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T236982[ebp], edx
	mov	eax, DWORD PTR $T236982[ebp]
	cmp	eax, DWORD PTR $T236983[ebp]
	je	SHORT $LN29@swap
	mov	ecx, DWORD PTR $T236982[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$236981[ebp], edx
	mov	eax, DWORD PTR $T236982[ebp]
	mov	ecx, DWORD PTR $T236983[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T236983[ebp]
	mov	ecx, DWORD PTR __Tmp$236981[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@swap:

; 1048 : 			}
; 1049 : 		else

	jmp	SHORT $LN5@swap

; 1050 : 			{	// different allocator, do multiple assigns
; 1051 : 			this->_Swap_aux(_Right);

$LN31@swap:

; 1052 : 
; 1053 : 			_Myt _Tmp = *this;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$226337[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1054 : 
; 1055 : 			*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=

; 1056 : 			_Right = _Tmp;

	lea	ecx, DWORD PTR __Tmp$226337[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=

; 1057 : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Tmp$226337[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN5@swap:

; 1058 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$0:
	lea	ecx, DWORD PTR __Tmp$226337[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
__unwindfunclet$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z$1:
	lea	ecx, DWORD PTR __Tmp$226337[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?swap@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::swap
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
PUBLIC	?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T238278 = -30						; size = 1
$T238265 = -29						; size = 1
$T238261 = -28						; size = 4
$T238254 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T238278[ebp]
	mov	DWORD PTR $T238254[ebp], eax
	lea	ecx, DWORD PTR $T238265[ebp]
	mov	DWORD PTR $T238261[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -212						; size = 4
tv148 = -208						; size = 4
tv172 = -204						; size = 4
_this$ = -200						; size = 4
$T238440 = -164						; size = 4
$T238439 = -160						; size = 4
$T238438 = -156						; size = 4
$T238428 = -152						; size = 4
$T238427 = -148						; size = 4
__Cat$238436 = -143					; size = 1
$T238434 = -142						; size = 1
$T238433 = -141						; size = 1
$T238407 = -140						; size = 4
$T238398 = -136						; size = 4
$T238367 = -48						; size = 4
$T238363 = -42						; size = 1
$T238350 = -41						; size = 1
$T238346 = -40						; size = 4
$T238339 = -32						; size = 4
$T238330 = -28						; size = 4
$T238329 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T238363[ebp]
	mov	DWORD PTR $T238339[ebp], eax
	lea	ecx, DWORD PTR $T238350[ebp]
	mov	DWORD PTR $T238346[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T238367[ebp], eax
	mov	ecx, DWORD PTR $T238367[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN3@vector

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238398[ebp], ecx
	mov	edx, DWORD PTR $T238398[ebp]
	mov	DWORD PTR $T238329[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238407[ebp], ecx
	mov	edx, DWORD PTR $T238407[ebp]
	mov	DWORD PTR $T238330[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238440[ebp], ecx
	mov	edx, DWORD PTR $T238329[ebp]
	mov	DWORD PTR $T238439[ebp], edx
	mov	eax, DWORD PTR $T238330[ebp]
	mov	DWORD PTR $T238438[ebp], eax
	mov	ecx, DWORD PTR $T238440[ebp]
	mov	DWORD PTR $T238428[ebp], ecx
	mov	edx, DWORD PTR $T238438[ebp]
	mov	DWORD PTR $T238427[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T238433[ebp], al
	mov	cl, BYTE PTR __Cat$238436[ebp]
	mov	BYTE PTR $T238434[ebp], cl
	movzx	edx, BYTE PTR $T238433[ebp]
	push	edx
	movzx	eax, BYTE PTR $T238434[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238428[ebp]
	push	edx
	mov	eax, DWORD PTR $T238439[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238427[ebp]
	push	ecx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN5@vector
__catch$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
PUBLIC	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
PUBLIC	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$4
__ehfuncinfo$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv170 = -204						; size = 4
tv168 = -200						; size = 4
_this$ = -196						; size = 4
$T238825 = -192						; size = 4
$T238824 = -188						; size = 4
$T238820 = -184						; size = 4
$T238819 = -180						; size = 4
$T238801 = -176						; size = 4
$T238800 = -172						; size = 4
$T238784 = -168						; size = 4
__Cat$238807 = -162					; size = 1
$T238804 = -161						; size = 1
$T238752 = -160						; size = 4
$T238751 = -156						; size = 4
$T238732 = -152						; size = 4
$T238715 = -145						; size = 1
$T238714 = -144						; size = 4
$T238704 = -140						; size = 4
$T238703 = -136						; size = 4
__Cat$238746 = -130					; size = 1
$T238743 = -129						; size = 1
$T238742 = -128						; size = 1
__Cat$238739 = -127					; size = 1
$T238736 = -126						; size = 1
$T238735 = -125						; size = 1
$T238673 = -124						; size = 4
$T238657 = -120						; size = 4
__Count$238626 = -36					; size = 4
$T238607 = -32						; size = 4
$T238606 = -28						; size = 4
__Size$226585 = -24					; size = 4
__Ptr$226533 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 188				; 000000bcH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	DWORD PTR __Count$238626[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$238626[ebp], 0
	jbe	SHORT $LN16@reserve
	mov	eax, DWORD PTR __Count$238626[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN12@reserve
$LN16@reserve:
	mov	DWORD PTR tv168[ebp], 1
$LN12@reserve:
	mov	ecx, DWORD PTR tv168[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
	jmp	$LN7@reserve
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN26@reserve
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN24@reserve
$LN26@reserve:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR tv170[ebp], edx
$LN24@reserve:
	mov	eax, DWORD PTR tv170[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	add	esp, 8
	mov	DWORD PTR __Ptr$226533[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T238657[ebp], eax
	mov	ecx, DWORD PTR $T238657[ebp]
	mov	DWORD PTR $T238606[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238673[ebp], eax
	mov	ecx, DWORD PTR $T238673[ebp]
	mov	DWORD PTR $T238607[ebp], ecx
	mov	edx, DWORD PTR $T238606[ebp]
	mov	DWORD PTR $T238752[ebp], edx
	mov	eax, DWORD PTR $T238607[ebp]
	mov	DWORD PTR $T238751[ebp], eax
	mov	ecx, DWORD PTR __Ptr$226533[ebp]
	mov	DWORD PTR $T238732[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238735[ebp], dl
	mov	al, BYTE PTR __Cat$238739[ebp]
	mov	BYTE PTR $T238736[ebp], al
	mov	cl, BYTE PTR $T238735[ebp]
	mov	BYTE PTR $T238715[ebp], cl
	mov	edx, DWORD PTR $T238732[ebp]
	mov	DWORD PTR $T238714[ebp], edx
	mov	eax, DWORD PTR $T238714[ebp]
	mov	DWORD PTR $T238704[ebp], eax
	mov	ecx, DWORD PTR $T238751[ebp]
	mov	DWORD PTR $T238703[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238742[ebp], dl
	mov	al, BYTE PTR __Cat$238746[ebp]
	mov	BYTE PTR $T238743[ebp], al
	movzx	ecx, BYTE PTR $T238742[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T238743[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238704[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238752[ebp]
	push	edx
	mov	eax, DWORD PTR $T238703[ebp]
	push	eax
	call	??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@reserve
__catch$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Ptr$226533[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@reserve
	ret	0
$LN8@reserve:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 615  : 
; 616  : 			size_type _Size = size();

$LN61@reserve:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR __Size$226585[ebp], ecx

; 617  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN1@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T238820[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238819[ebp], eax
	mov	ecx, DWORD PTR $T238820[ebp]
	mov	DWORD PTR $T238801[ebp], ecx
	mov	edx, DWORD PTR $T238819[ebp]
	mov	DWORD PTR $T238800[ebp], edx
	mov	al, BYTE PTR __Cat$238807[ebp]
	mov	BYTE PTR $T238804[ebp], al
	mov	ecx, DWORD PTR $T238800[ebp]
	mov	DWORD PTR $T238784[ebp], ecx
	jmp	SHORT $LN71@reserve
$LN70@reserve:
	mov	edx, DWORD PTR $T238784[ebp]
	add	edx, 4
	mov	DWORD PTR $T238784[ebp], edx
$LN71@reserve:
	mov	eax, DWORD PTR $T238784[ebp]
	cmp	eax, DWORD PTR $T238801[ebp]
	je	SHORT $LN63@reserve
	jmp	SHORT $LN70@reserve
$LN63@reserve:

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T238825[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T238824[ebp], edx
	mov	eax, DWORD PTR $T238824[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$226533[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 628  : 			_Mylast = _Ptr + _Size;

	mov	edx, DWORD PTR __Size$226585[ebp]
	mov	eax, DWORD PTR __Ptr$226533[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$226533[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXI@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::reserve
PUBLIC	?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::insert
PUBLIC	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T238886 = -32						; size = 4
$T238876 = -28						; size = 4
$T238866 = -24						; size = 4
__Cat$238873 = -19					; size = 1
$T238870 = -18						; size = 1
$T238869 = -17						; size = 1
$T238843 = -16						; size = 4
$T238839 = -12						; size = 4
$T238838 = -8						; size = 4
$T238837 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T238843[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back
$LN9@push_back:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back:
	mov	ecx, DWORD PTR $T238843[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T238876[ebp], eax
	mov	ecx, DWORD PTR $T238876[ebp]
	mov	DWORD PTR $T238866[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T238869[ebp], dl
	mov	al, BYTE PTR __Cat$238873[ebp]
	mov	BYTE PTR $T238870[ebp], al
	movzx	ecx, BYTE PTR $T238869[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T238870[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T238866[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T238876[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T238886[ebp], eax
	mov	ecx, DWORD PTR $T238886[ebp]
	mov	DWORD PTR $T238838[ebp], ecx
	mov	edx, DWORD PTR $T238838[ebp]
	mov	DWORD PTR $T238837[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238837[ebp]
	push	ecx
	lea	edx, DWORD PTR $T238839[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::insert
$LN3@push_back:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAEXABW4BuildingTypes@@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T238983 = -30						; size = 1
$T238970 = -29						; size = 1
$T238966 = -28						; size = 4
$T238959 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T238983[ebp]
	mov	DWORD PTR $T238959[ebp], eax
	lea	ecx, DWORD PTR $T238970[ebp]
	mov	DWORD PTR $T238966[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
PUBLIC	??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv215 = -212						; size = 4
tv148 = -208						; size = 4
tv172 = -204						; size = 4
_this$ = -200						; size = 4
$T239145 = -164						; size = 4
$T239144 = -160						; size = 4
$T239143 = -156						; size = 4
$T239133 = -152						; size = 4
$T239132 = -148						; size = 4
__Cat$239142 = -143					; size = 1
$T239139 = -142						; size = 1
$T239138 = -141						; size = 1
$T239112 = -140						; size = 4
$T239103 = -136						; size = 4
$T239072 = -48						; size = 4
$T239068 = -42						; size = 1
$T239055 = -41						; size = 1
$T239051 = -40						; size = 4
$T239044 = -32						; size = 4
$T239035 = -28						; size = 4
$T239034 = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T239068[ebp]
	mov	DWORD PTR $T239044[ebp], eax
	lea	ecx, DWORD PTR $T239055[ebp]
	mov	DWORD PTR $T239051[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv148[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T239072[ebp], eax
	mov	ecx, DWORD PTR $T239072[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy
	movzx	edx, al
	test	edx, edx
	je	$LN3@vector@2

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T239103[ebp], ecx
	mov	edx, DWORD PTR $T239103[ebp]
	mov	DWORD PTR $T239034[ebp], edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239112[ebp], ecx
	mov	edx, DWORD PTR $T239112[ebp]
	mov	DWORD PTR $T239035[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239145[ebp], ecx
	mov	edx, DWORD PTR $T239034[ebp]
	mov	DWORD PTR $T239144[ebp], edx
	mov	eax, DWORD PTR $T239035[ebp]
	mov	DWORD PTR $T239143[ebp], eax
	mov	ecx, DWORD PTR $T239145[ebp]
	mov	DWORD PTR $T239133[ebp], ecx
	mov	edx, DWORD PTR $T239143[ebp]
	mov	DWORD PTR $T239132[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T239138[ebp], al
	mov	cl, BYTE PTR __Cat$239142[ebp]
	mov	BYTE PTR $T239139[ebp], cl
	movzx	edx, BYTE PTR $T239138[ebp]
	push	edx
	movzx	eax, BYTE PTR $T239139[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239133[ebp]
	push	edx
	mov	eax, DWORD PTR $T239144[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239132[ebp]
	push	ecx
	call	??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H
	mov	DWORD PTR tv215[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv215[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN5@vector@2
__catch$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@2
	ret	0
$LN5@vector@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@2:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-216]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -48						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >
PUBLIC	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
PUBLIC	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>
PUBLIC	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$4
__ehfuncinfo$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv170 = -204						; size = 4
tv168 = -200						; size = 4
_this$ = -196						; size = 4
$T239530 = -192						; size = 4
$T239529 = -188						; size = 4
$T239525 = -184						; size = 4
$T239524 = -180						; size = 4
$T239506 = -176						; size = 4
$T239505 = -172						; size = 4
$T239489 = -168						; size = 4
__Cat$239513 = -162					; size = 1
$T239511 = -161						; size = 1
$T239457 = -160						; size = 4
$T239456 = -156						; size = 4
$T239437 = -152						; size = 4
$T239420 = -145						; size = 1
$T239419 = -144						; size = 4
$T239409 = -140						; size = 4
$T239408 = -136						; size = 4
__Cat$239455 = -130					; size = 1
$T239452 = -129						; size = 1
$T239451 = -128						; size = 1
__Cat$239445 = -127					; size = 1
$T239443 = -126						; size = 1
$T239442 = -125						; size = 1
$T239378 = -124						; size = 4
$T239362 = -120						; size = 4
__Count$239328 = -36					; size = 4
$T239312 = -32						; size = 4
$T239311 = -28						; size = 4
__Size$226807 = -24					; size = 4
__Ptr$226755 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 188				; 000000bcH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 		if (max_size() < _Count)

	mov	DWORD PTR __Count$239328[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$239328[ebp], 0
	jbe	SHORT $LN16@reserve@2
	mov	eax, DWORD PTR __Count$239328[ebp]
	mov	DWORD PTR tv168[ebp], eax
	jmp	SHORT $LN12@reserve@2
$LN16@reserve@2:
	mov	DWORD PTR tv168[ebp], 1
$LN12@reserve@2:
	mov	ecx, DWORD PTR tv168[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve@2

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
	jmp	$LN7@reserve@2
$LN5@reserve@2:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN26@reserve@2
	mov	DWORD PTR tv170[ebp], 0
	jmp	SHORT $LN24@reserve@2
$LN26@reserve@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR tv170[ebp], edx
$LN24@reserve@2:
	mov	eax, DWORD PTR tv170[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve@2

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>
	add	esp, 8
	mov	DWORD PTR __Ptr$226755[ebp], eax

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239362[ebp], eax
	mov	ecx, DWORD PTR $T239362[ebp]
	mov	DWORD PTR $T239311[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239378[ebp], eax
	mov	ecx, DWORD PTR $T239378[ebp]
	mov	DWORD PTR $T239312[ebp], ecx
	mov	edx, DWORD PTR $T239311[ebp]
	mov	DWORD PTR $T239457[ebp], edx
	mov	eax, DWORD PTR $T239312[ebp]
	mov	DWORD PTR $T239456[ebp], eax
	mov	ecx, DWORD PTR __Ptr$226755[ebp]
	mov	DWORD PTR $T239437[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239442[ebp], dl
	mov	al, BYTE PTR __Cat$239445[ebp]
	mov	BYTE PTR $T239443[ebp], al
	mov	cl, BYTE PTR $T239442[ebp]
	mov	BYTE PTR $T239420[ebp], cl
	mov	edx, DWORD PTR $T239437[ebp]
	mov	DWORD PTR $T239419[ebp], edx
	mov	eax, DWORD PTR $T239419[ebp]
	mov	DWORD PTR $T239409[ebp], eax
	mov	ecx, DWORD PTR $T239456[ebp]
	mov	DWORD PTR $T239408[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239451[ebp], dl
	mov	al, BYTE PTR __Cat$239455[ebp]
	mov	BYTE PTR $T239452[ebp], al
	movzx	ecx, BYTE PTR $T239451[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239452[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239409[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239457[ebp]
	push	edx
	mov	eax, DWORD PTR $T239408[ebp]
	push	eax
	call	??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN8@reserve@2
__catch$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Ptr$226755[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 614  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@reserve@2
	ret	0
$LN8@reserve@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 615  : 
; 616  : 			size_type _Size = size();

$LN61@reserve@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR __Size$226807[ebp], ecx

; 617  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN1@reserve@2

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T239525[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239524[ebp], eax
	mov	ecx, DWORD PTR $T239525[ebp]
	mov	DWORD PTR $T239506[ebp], ecx
	mov	edx, DWORD PTR $T239524[ebp]
	mov	DWORD PTR $T239505[ebp], edx
	mov	al, BYTE PTR __Cat$239513[ebp]
	mov	BYTE PTR $T239511[ebp], al
	mov	ecx, DWORD PTR $T239505[ebp]
	mov	DWORD PTR $T239489[ebp], ecx
	jmp	SHORT $LN71@reserve@2
$LN70@reserve@2:
	mov	edx, DWORD PTR $T239489[ebp]
	add	edx, 4
	mov	DWORD PTR $T239489[ebp], edx
$LN71@reserve@2:
	mov	eax, DWORD PTR $T239489[ebp]
	cmp	eax, DWORD PTR $T239506[ebp]
	je	SHORT $LN63@reserve@2
	jmp	SHORT $LN70@reserve@2
$LN63@reserve@2:

; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T239530[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239529[ebp], edx
	mov	eax, DWORD PTR $T239529[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@reserve@2:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$226755[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 628  : 			_Mylast = _Ptr + _Size;

	mov	edx, DWORD PTR __Size$226807[ebp]
	mov	eax, DWORD PTR __Ptr$226755[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 629  : 			_Myfirst = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$226755[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN7@reserve@2:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXI@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::reserve
PUBLIC	?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::insert
PUBLIC	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z
_TEXT	SEGMENT
tv129 = -64						; size = 4
_this$ = -60						; size = 4
$T239591 = -32						; size = 4
$T239581 = -28						; size = 4
$T239571 = -24						; size = 4
__Cat$239579 = -19					; size = 1
$T239577 = -18						; size = 1
$T239576 = -17						; size = 1
$T239548 = -16						; size = 4
$T239544 = -12						; size = 4
$T239543 = -8						; size = 4
$T239542 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T239548[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@2
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@2
$LN9@push_back@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@2:
	mov	ecx, DWORD PTR $T239548[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239581[ebp], eax
	mov	ecx, DWORD PTR $T239581[ebp]
	mov	DWORD PTR $T239571[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T239576[ebp], dl
	mov	al, BYTE PTR __Cat$239579[ebp]
	mov	BYTE PTR $T239577[ebp], al
	movzx	ecx, BYTE PTR $T239576[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T239577[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR $T239571[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H
	mov	eax, 1
	shl	eax, 2
	add	eax, DWORD PTR $T239581[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239591[ebp], eax
	mov	ecx, DWORD PTR $T239591[ebp]
	mov	DWORD PTR $T239543[ebp], ecx
	mov	edx, DWORD PTR $T239543[ebp]
	mov	DWORD PTR $T239542[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239542[ebp]
	push	ecx
	lea	edx, DWORD PTR $T239544[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::insert
$LN3@push_back@2:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAEXABW4PolicyTypes@@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::~_Tree_val<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::~_Vector_val<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::~_Vector_val<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >::~_Vector_val<enum BuildingTypes,std::allocator<enum BuildingTypes> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >::~_Vector_val<enum PolicyTypes,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv89 = -72						; size = 4
tv147 = -68						; size = 4
tv173 = -64						; size = 4
tv199 = -60						; size = 4
_this$ = -56						; size = 4
$T239793 = -47						; size = 1
$T239768 = -46						; size = 1
$T239750 = -45						; size = 1
$T239739 = -44						; size = 4
$T239781 = -40						; size = 4
$T239732 = -36						; size = 4
$T239725 = -28						; size = 4
$T239718 = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T239793[ebp]
	mov	DWORD PTR $T239718[ebp], eax
	lea	ecx, DWORD PTR $T239768[ebp]
	mov	DWORD PTR $T239725[ebp], ecx
	lea	edx, DWORD PTR $T239750[ebp]
	mov	DWORD PTR $T239732[ebp], edx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T239781[ebp], esp
	mov	DWORD PTR $T239739[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv173[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T239870 = -32						; size = 4
$T239857 = -28						; size = 4
$T239845 = -24						; size = 4
$T239835 = -20						; size = 4
$T239834 = -16						; size = 4
$T239833 = -12						; size = 4
$T239832 = -8						; size = 4
$T239831 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239845[ebp], edx
	mov	eax, DWORD PTR $T239845[ebp]
	mov	DWORD PTR $T239832[ebp], eax
	mov	ecx, DWORD PTR $T239832[ebp]
	mov	DWORD PTR $T239831[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239857[ebp], eax
	mov	ecx, DWORD PTR $T239857[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239870[ebp], edx
	mov	eax, DWORD PTR $T239870[ebp]
	mov	DWORD PTR $T239834[ebp], eax
	mov	ecx, DWORD PTR $T239834[ebp]
	mov	DWORD PTR $T239833[ebp], ecx
	mov	edx, DWORD PTR $T239831[ebp]
	push	edx
	mov	eax, DWORD PTR $T239833[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239835[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
$LN1@operator:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::operator=
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv90 = -156						; size = 4
_this$ = -152						; size = 4
$T240297 = -148						; size = 4
$T240277 = -144						; size = 4
$T240262 = -140						; size = 4
$T240245 = -136						; size = 4
$T240232 = -132						; size = 4
$T240218 = -128						; size = 4
$T240174 = -45						; size = 1
$T240173 = -44						; size = 4
$T240172 = -37						; size = 1
$T240171 = -36						; size = 4
$T240170 = -29						; size = 1
$T240169 = -28						; size = 4
$T240168 = -24						; size = 4
$T240167 = -17						; size = 1
__Where$226874 = -16					; size = 4
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Trynode$[ebp], edx

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1

; 634  : 		while (!_Isnil(_Trynode))

$LN19@insert:
	mov	edx, DWORD PTR __Trynode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN9@insert

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [edx]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+12]
	setl	dl
	mov	BYTE PTR __Addleft$[ebp], dl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	eax, BYTE PTR __Addleft$[ebp]
	test	eax, eax
	je	SHORT $LN33@insert
	mov	ecx, DWORD PTR __Trynode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $LN14@insert
$LN33@insert:
	mov	eax, DWORD PTR __Trynode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv90[ebp], ecx
$LN14@insert:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], edx

; 640  : 			}

	jmp	SHORT $LN19@insert
$LN9@insert:

; 641  : 
; 642  : 		if (this->_Multi)

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN8@insert

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T240167[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T240168[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	DWORD PTR $T240218[ebp], eax
	mov	edx, DWORD PTR $T240218[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T240167[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 644  : 		else

	jmp	$LN11@insert
$LN8@insert:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Where$226874[ebp], ecx

; 647  : 			if (!_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	jne	SHORT $LN6@insert
	jmp	$LN79@insert
$LN6@insert:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240232[ebp], ecx
	mov	edx, DWORD PTR $T240232[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240245[ebp], eax
	mov	ecx, DWORD PTR $T240245[ebp]
	mov	DWORD PTR $T240169[ebp], ecx
	mov	edx, DWORD PTR __Where$226874[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T240169[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@insert

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T240170[ebp], 1
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T240171[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	DWORD PTR $T240262[ebp], eax
	mov	edx, DWORD PTR $T240262[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T240170[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert

; 651  : 			else

	jmp	SHORT $LN79@insert
$LN4@insert:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$226874[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

$LN79@insert:
	mov	ecx, DWORD PTR __Where$226874[ebp]
	mov	DWORD PTR $T240277[ebp], ecx
	mov	edx, DWORD PTR $T240277[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax]
	setl	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T240172[ebp], 1
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T240173[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
	mov	DWORD PTR $T240297[ebp], eax
	mov	edx, DWORD PTR $T240297[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	al, BYTE PTR $T240172[ebp]
	mov	BYTE PTR [edx+4], al
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert

; 657  : 			else

	jmp	SHORT $LN11@insert
$LN2@insert:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T240174[ebp], 0
	mov	ecx, DWORD PTR __Where$226874[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cl, BYTE PTR $T240174[ebp]
	mov	BYTE PTR [eax+4], cl
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@_N@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::insert
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T240418 = -40						; size = 4
$T240405 = -36						; size = 4
$T240384 = -32						; size = 4
$T240371 = -28						; size = 4
$T240366 = -24						; size = 4
$T240345 = -20						; size = 4
$T240333 = -16						; size = 4
$T240324 = -12						; size = 4
$T240320 = -8						; size = 4
$T240311 = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T240311[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T240320[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR $T240311[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	edx, DWORD PTR $T240320[ebp]
	mov	DWORD PTR [edx], eax

; 1064 : 		_Mysize = _Right.size();

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T240324[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T240324[ebp]
	mov	DWORD PTR [edx+8], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T240333[ebp], edx
	mov	eax, DWORD PTR $T240333[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN2@Copy

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T240345[ebp], ecx
	mov	edx, DWORD PTR $T240345[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240366[ebp], eax
$LN31@Copy:
	mov	ecx, DWORD PTR $T240366[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN27@Copy
	mov	ecx, DWORD PTR $T240366[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T240366[ebp], edx
	jmp	SHORT $LN31@Copy
$LN27@Copy:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240371[ebp], ecx
	mov	edx, DWORD PTR $T240371[ebp]
	mov	eax, DWORD PTR $T240366[ebp]
	mov	DWORD PTR [edx], eax

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T240384[ebp], edx
	mov	eax, DWORD PTR $T240384[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240405[ebp], ecx
$LN49@Copy:
	mov	edx, DWORD PTR $T240405[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN53@Copy
	mov	edx, DWORD PTR $T240405[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240405[ebp], eax
	jmp	SHORT $LN49@Copy
$LN53@Copy:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR $T240405[ebp]
	mov	DWORD PTR [edx+8], eax

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240418[ebp], edx
	mov	eax, DWORD PTR $T240418[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax
$LN3@Copy:

; 1072 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$226901 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$226901[ebp], eax
	jmp	SHORT $LN6@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$226901[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN6@Erase:
	mov	edx, DWORD PTR __Pnode$226901[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$226901[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$226901[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$226901[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T240470 = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+21], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240470[ebp], eax
	mov	ecx, DWORD PTR $T240470[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1182 : 		_Mysize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound, COMDAT
; _this$ = ecx

; 1349 : 		{	// find leftmost node greater than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1350 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1351 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1352 : 
; 1353 : 		while (!_Isnil(_Pnode))

$LN11@Ubound:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN3@Ubound

; 1354 : 			if (_DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	mov	ecx, DWORD PTR __Keyval$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+12]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN23@Ubound

; 1355 : 				{	// _Pnode greater than _Keyval, remember it
; 1356 : 				_Wherenode = _Pnode;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1357 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1358 : 				}
; 1359 : 			else

	jmp	SHORT $LN1@Ubound

; 1360 : 				_Pnode = _Right(_Pnode);	// descend right subtree

$LN23@Ubound:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Ubound:
	jmp	SHORT $LN11@Ubound
$LN3@Ubound:

; 1361 : 
; 1362 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1363 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Ubound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Ubound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T240760 = -88						; size = 4
$T240726 = -84						; size = 4
$T240559 = -32						; size = 4
$T240546 = -28						; size = 4
$T240534 = -24						; size = 4
$T240524 = -20						; size = 4
$T240523 = -16						; size = 4
$T240522 = -12						; size = 4
$T240521 = -8						; size = 4
$T240520 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240534[ebp], ecx
	mov	edx, DWORD PTR $T240534[ebp]
	mov	DWORD PTR $T240521[ebp], edx
	mov	eax, DWORD PTR $T240521[ebp]
	mov	DWORD PTR $T240520[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240546[ebp], edx
	mov	eax, DWORD PTR $T240546[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240559[ebp], ecx
	mov	edx, DWORD PTR $T240559[ebp]
	mov	DWORD PTR $T240523[ebp], edx
	mov	eax, DWORD PTR $T240523[ebp]
	mov	DWORD PTR $T240522[ebp], eax
	mov	ecx, DWORD PTR $T240520[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240522[ebp]
	push	edx
	lea	eax, DWORD PTR $T240524[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240726[ebp], edx

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240760[ebp], ecx
	mov	edx, DWORD PTR $T240760[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPolicyEntry * *,CvPolicyEntry * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T240853 = -52						; size = 4
$T240842 = -48						; size = 4
$T240841 = -44						; size = 4
__Cat$240849 = -40					; size = 1
$T240846 = -39						; size = 1
__Ptr$226945 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPolicyEntry * *,CvPolicyEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$226945[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240853[ebp], edx
	mov	eax, DWORD PTR $T240853[ebp]
	mov	DWORD PTR $T240842[ebp], eax
	mov	ecx, DWORD PTR __Ptr$226945[ebp]
	mov	DWORD PTR $T240841[ebp], ecx
	mov	dl, BYTE PTR __Cat$240849[ebp]
	mov	BYTE PTR $T240846[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$226945[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@2@0@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$240871 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$240871[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$240871[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$240871[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T240934 = -28						; size = 4
$T240933 = -24						; size = 4
$T240929 = -20						; size = 4
$T240928 = -16						; size = 4
$T240917 = -12						; size = 4
$T240916 = -8						; size = 4
__Cat$240924 = -2					; size = 1
$T240921 = -1						; size = 1
?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T240929[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240928[ebp], ecx
	mov	edx, DWORD PTR $T240929[ebp]
	mov	DWORD PTR $T240917[ebp], edx
	mov	eax, DWORD PTR $T240928[ebp]
	mov	DWORD PTR $T240916[ebp], eax
	mov	cl, BYTE PTR __Cat$240924[ebp]
	mov	BYTE PTR $T240921[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T240934[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240933[ebp], eax
	mov	ecx, DWORD PTR $T240933[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T241027 = -52						; size = 4
$T241016 = -48						; size = 4
$T241015 = -44						; size = 4
__Cat$241023 = -40					; size = 1
$T241020 = -39						; size = 1
__Ptr$226978 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$226978[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241027[ebp], edx
	mov	eax, DWORD PTR $T241027[ebp]
	mov	DWORD PTR $T241016[ebp], eax
	mov	ecx, DWORD PTR __Ptr$226978[ebp]
	mov	DWORD PTR $T241015[ebp], ecx
	mov	dl, BYTE PTR __Cat$241023[ebp]
	mov	BYTE PTR $T241020[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$226978[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@2@0@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyBranchEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$241042 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$241042[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$241042[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$241042[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z ; std::_Allocate<CvPolicyBranchEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T241108 = -28						; size = 4
$T241107 = -24						; size = 4
$T241103 = -20						; size = 4
$T241102 = -16						; size = 4
$T241091 = -12						; size = 4
$T241090 = -8						; size = 4
__Cat$241097 = -2					; size = 1
$T241095 = -1						; size = 1
?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241103[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241102[ebp], ecx
	mov	edx, DWORD PTR $T241103[ebp]
	mov	DWORD PTR $T241091[ebp], edx
	mov	eax, DWORD PTR $T241102[ebp]
	mov	DWORD PTR $T241090[ebp], eax
	mov	cl, BYTE PTR __Cat$241097[ebp]
	mov	BYTE PTR $T241095[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T241108[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241107[ebp], eax
	mov	ecx, DWORD PTR $T241107[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$241163 = -24					; size = 4
$T241146 = -20						; size = 4
$T241127 = -16						; size = 4
$T241114 = -12						; size = 4
$T241111 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241127[ebp], ecx
	mov	edx, DWORD PTR $T241127[ebp]
	mov	DWORD PTR $T241111[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T241111[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T241146[ebp], edx
	mov	eax, DWORD PTR $T241146[ebp]
	mov	DWORD PTR $T241114[ebp], eax
	mov	ecx, DWORD PTR $T241114[ebp]
	mov	DWORD PTR __Tmp$241163[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$241163[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$241163[ebp], ecx
	mov	edx, DWORD PTR __Tmp$241163[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@ABW4BuildingTypes@@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$241182 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$241182[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$241182[ebp], 0
	jbe	SHORT $LN11@Buy@3
	mov	eax, DWORD PTR __Count$241182[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@3
$LN11@Buy@3:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@3:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@3:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T241279 = -32						; size = 4
$T241278 = -28						; size = 4
$T241274 = -24						; size = 4
$T241273 = -20						; size = 4
$T241255 = -16						; size = 4
$T241254 = -12						; size = 4
$T241238 = -8						; size = 4
__Cat$241260 = -2					; size = 1
$T241258 = -1						; size = 1
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241274[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241273[ebp], ecx
	mov	edx, DWORD PTR $T241274[ebp]
	mov	DWORD PTR $T241255[ebp], edx
	mov	eax, DWORD PTR $T241273[ebp]
	mov	DWORD PTR $T241254[ebp], eax
	mov	cl, BYTE PTR __Cat$241260[ebp]
	mov	BYTE PTR $T241258[ebp], cl
	mov	edx, DWORD PTR $T241254[ebp]
	mov	DWORD PTR $T241238[ebp], edx
	jmp	SHORT $LN12@Tidy@3
$LN11@Tidy@3:
	mov	eax, DWORD PTR $T241238[ebp]
	add	eax, 4
	mov	DWORD PTR $T241238[ebp], eax
$LN12@Tidy@3:
	mov	ecx, DWORD PTR $T241238[ebp]
	cmp	ecx, DWORD PTR $T241255[ebp]
	je	SHORT $LN4@Tidy@3
	jmp	SHORT $LN11@Tidy@3
$LN4@Tidy@3:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T241279[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241278[ebp], eax
	mov	ecx, DWORD PTR $T241278[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T241283 = -80						; size = 28
$T241282 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T241283[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T241282[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T241282[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T241283[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241282[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T241282[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T241282[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T241283[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T241283[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T241282[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T241360 = -16						; size = 4
$T241339 = -12						; size = 4
$T241332 = -8						; size = 4
__Pnode$227098 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 389  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN6@Inc
	jmp	$LN7@Inc
$LN6@Inc:

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;
; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 8
	mov	DWORD PTR $T241332[ebp], ecx
	mov	edx, DWORD PTR $T241332[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN27@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 8
	mov	DWORD PTR $T241339[ebp], eax
	mov	ecx, DWORD PTR $T241339[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T241360[ebp], edx
$LN23@Inc:
	mov	eax, DWORD PTR $T241360[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN19@Inc
	mov	eax, DWORD PTR $T241360[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241360[ebp], ecx
	jmp	SHORT $LN23@Inc
$LN19@Inc:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T241360[ebp]
	mov	DWORD PTR [edx], eax

; 398  : 			else

	jmp	SHORT $LN7@Inc

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

$LN27@Inc:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227098[ebp], eax
	mov	ecx, DWORD PTR __Pnode$227098[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN1@Inc
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$227098[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$227098[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN27@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$227098[ebp]
	mov	DWORD PTR [edx], eax
$LN7@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$241424 = -24					; size = 4
$T241407 = -20						; size = 4
$T241388 = -16						; size = 4
$T241375 = -12						; size = 4
$T241372 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241388[ebp], ecx
	mov	edx, DWORD PTR $T241388[ebp]
	mov	DWORD PTR $T241372[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T241372[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T241407[ebp], edx
	mov	eax, DWORD PTR $T241407[ebp]
	mov	DWORD PTR $T241375[ebp], eax
	mov	ecx, DWORD PTR $T241375[ebp]
	mov	DWORD PTR __Tmp$241424[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$241424[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$241424[ebp], ecx
	mov	edx, DWORD PTR __Tmp$241424[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@QAE?AV?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@ABW4PolicyTypes@@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$241443 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$241443[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$241443[ebp], 0
	jbe	SHORT $LN11@Buy@4
	mov	eax, DWORD PTR __Count$241443[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@4
$LN11@Buy@4:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@4:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@4:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T241540 = -32						; size = 4
$T241539 = -28						; size = 4
$T241535 = -24						; size = 4
$T241534 = -20						; size = 4
$T241516 = -16						; size = 4
$T241515 = -12						; size = 4
$T241499 = -8						; size = 4
__Cat$241523 = -2					; size = 1
$T241521 = -1						; size = 1
?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241535[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241534[ebp], ecx
	mov	edx, DWORD PTR $T241535[ebp]
	mov	DWORD PTR $T241516[ebp], edx
	mov	eax, DWORD PTR $T241534[ebp]
	mov	DWORD PTR $T241515[ebp], eax
	mov	cl, BYTE PTR __Cat$241523[ebp]
	mov	BYTE PTR $T241521[ebp], cl
	mov	edx, DWORD PTR $T241515[ebp]
	mov	DWORD PTR $T241499[ebp], edx
	jmp	SHORT $LN12@Tidy@4
$LN11@Tidy@4:
	mov	eax, DWORD PTR $T241499[ebp]
	add	eax, 4
	mov	DWORD PTR $T241499[ebp], eax
$LN12@Tidy@4:
	mov	ecx, DWORD PTR $T241499[ebp]
	cmp	ecx, DWORD PTR $T241516[ebp]
	je	SHORT $LN4@Tidy@4
	jmp	SHORT $LN11@Tidy@4
$LN4@Tidy@4:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T241540[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241539[ebp], eax
	mov	ecx, DWORD PTR $T241539[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T241544 = -80						; size = 28
$T241543 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T241544[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T241543[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T241543[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T241544[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241543[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T241543[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T241543[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T241544[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T241544[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T241543[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T241783 = -72						; size = 4
$T241777 = -68						; size = 4
__Tmp$241765 = -48					; size = 4
$T241693 = -44						; size = 4
$T241680 = -40						; size = 4
$T241610 = -28						; size = 4
$T241587 = -24						; size = 4
$T241574 = -20						; size = 4
$T241568 = -16						; size = 4
$T241567 = -12						; size = 4
$T241566 = -8						; size = 4
$T241565 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241574[ebp], ecx
	mov	edx, DWORD PTR $T241574[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241587[ebp], eax
	mov	ecx, DWORD PTR $T241587[ebp]
	mov	DWORD PTR $T241565[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T241565[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241610[ebp], eax
	mov	ecx, DWORD PTR $T241610[ebp]
	mov	DWORD PTR $T241566[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR $T241566[ebp]
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN72@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::clear

; 938  : 			return (begin());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241680[ebp], eax
	mov	ecx, DWORD PTR $T241680[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T241693[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T241693[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@3

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@3

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

$LN72@erase@3:
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase@3

; 943  : 				erase(_First++);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Tmp$241765[ebp], eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc
	mov	ecx, DWORD PTR __Tmp$241765[ebp]
	mov	DWORD PTR $T241567[ebp], ecx
	mov	edx, DWORD PTR $T241567[ebp]
	push	edx
	lea	eax, DWORD PTR $T241568[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
	jmp	SHORT $LN72@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T241783[ebp], ecx
	mov	edx, DWORD PTR $T241783[ebp]
	mov	DWORD PTR $T241777[ebp], edx
	mov	eax, DWORD PTR $T241777[ebp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@3:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
tv141 = -40						; size = 4
tv153 = -36						; size = 4
_this$ = -32						; size = 4
__Pnode$227256 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	$LN3@Copy@2

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	movzx	edx, BYTE PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR __Pnode$227256[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN2@Copy@2

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$227256[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@2:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$227256[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR tv153[ebp], eax
	mov	eax, DWORD PTR __Pnode$227256[ebp]
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR [eax], ecx

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	edx, DWORD PTR __Pnode$227256[ebp]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR __Pnode$227256[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $LN6@Copy@2
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	ecx, DWORD PTR __Newroot$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@2
	ret	0
$LN6@Copy@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@2:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@2:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Copy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
_TEXT	SEGMENT
tv277 = -196						; size = 4
_this$ = -192						; size = 4
$T242380 = -188						; size = 4
$T242292 = -172						; size = 4
$T242207 = -160						; size = 4
$T242191 = -156						; size = 4
$T242172 = -152						; size = 4
$T242168 = -148						; size = 4
$T242083 = -136						; size = 4
$T241982 = -120						; size = 4
$T241960 = -116						; size = 4
$T241953 = -112						; size = 4
$T241949 = -108						; size = 4
$T241910 = -104						; size = 4
$T241901 = -100						; size = 4
$T241881 = -96						; size = 4
__Count$241863 = -92					; size = 4
$T241847 = -88						; size = 28
$T241846 = -60						; size = 40
__Pnode$227273 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	DWORD PTR __Count$241863[ebp], 536870911 ; 1fffffffH
	cmp	DWORD PTR __Count$241863[ebp], 0
	jbe	SHORT $LN25@Insert
	mov	eax, DWORD PTR __Count$241863[ebp]
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN21@Insert
$LN25@Insert:
	mov	DWORD PTR tv277[ebp], 1
$LN21@Insert:
	mov	ecx, DWORD PTR tv277[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T241847[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T241847[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241846[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T241846[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T241846[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T241847[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 		if (_Wherenode == _Myhead)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T241881[ebp], edx
	mov	eax, DWORD PTR $T241881[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN52@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241901[ebp], eax
	mov	ecx, DWORD PTR $T241901[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241910[ebp], ecx
	mov	edx, DWORD PTR $T241910[ebp]
	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

$LN52@Insert:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	eax, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$227273[ebp], eax
$LN64@Insert:
	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+20]
	test	eax, eax
	jne	$LN360@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T241949[ebp], edx
	mov	eax, DWORD PTR $T241949[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241953[ebp], ecx
	mov	edx, DWORD PTR __Pnode$227273[ebp]
	mov	eax, DWORD PTR $T241953[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN216@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$227273[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T241960[ebp], eax
	mov	ecx, DWORD PTR $T241960[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN100@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$227273[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$227273[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T241982[ebp], ecx
	mov	edx, DWORD PTR $T241982[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227273[ebp], eax

; 1222 : 					}
; 1223 : 				else

	jmp	SHORT $LN6@Insert

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

$LN100@Insert:
	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$227273[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN155@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$227273[ebp], edx

; 1228 : 						_Lrotate(_Pnode);

	mov	eax, DWORD PTR __Pnode$227273[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN155@Insert:
	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+20], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$227273[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T242083[ebp], ecx
	mov	edx, DWORD PTR $T242083[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

$LN216@Insert:
	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T242168[ebp], edx
	mov	eax, DWORD PTR $T242168[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T242172[ebp], ecx
	mov	edx, DWORD PTR $T242172[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN240@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$227273[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	BYTE PTR [ecx+20], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	eax, DWORD PTR __Pnode$227273[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	DWORD PTR $T242191[ebp], ecx
	mov	edx, DWORD PTR $T242191[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227273[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN4@Insert

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

$LN240@Insert:
	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T242207[ebp], edx
	mov	eax, DWORD PTR $T242207[ebp]
	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN297@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$227273[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Pnode$227273[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

$LN297@Insert:
	mov	edx, DWORD PTR __Pnode$227273[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax+20], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$227273[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 4
	mov	DWORD PTR $T242292[ebp], edx
	mov	eax, DWORD PTR $T242292[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx+20], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$227273[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN64@Insert

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

$LN360@Insert:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	DWORD PTR $T242380[ebp], eax
	mov	ecx, DWORD PTR $T242380[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z$0:
	lea	ecx, DWORD PTR $T241847[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABU?$pair@$$CBHH@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Insert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Pnode$[ebp], edx

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

$LN11@Lbound:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN3@Lbound

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Keyval$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN1@Lbound:

; 1274 : 				}

	jmp	SHORT $LN11@Lbound
$LN3@Lbound:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lbound
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
_TEXT	SEGMENT
tv72 = -96						; size = 4
tv182 = -92						; size = 4
tv177 = -88						; size = 4
_this$ = -84						; size = 4
$T242545 = -80						; size = 4
__Vptr$242543 = -76					; size = 4
$T242516 = -72						; size = 4
__Vptr$242514 = -68					; size = 4
$T242487 = -64						; size = 4
__Vptr$242485 = -60					; size = 4
$T242447 = -36						; size = 4
$T242446 = -32						; size = 4
$T242445 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T242445[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR __Vptr$242485[ebp], eax
	mov	ecx, DWORD PTR __Vptr$242485[ebp]
	mov	DWORD PTR $T242487[ebp], ecx
	cmp	DWORD PTR $T242487[ebp], 0
	je	SHORT $LN23@Buynode
	mov	edx, DWORD PTR $T242487[ebp]
	mov	eax, DWORD PTR $T242445[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T242487[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN19@Buynode
$LN23@Buynode:
	mov	DWORD PTR tv177[ebp], 0
$LN19@Buynode:

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T242446[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 4
	mov	DWORD PTR __Vptr$242514[ebp], eax
	mov	ecx, DWORD PTR __Vptr$242514[ebp]
	mov	DWORD PTR $T242516[ebp], ecx
	cmp	DWORD PTR $T242516[ebp], 0
	je	SHORT $LN33@Buynode
	mov	edx, DWORD PTR $T242516[ebp]
	mov	eax, DWORD PTR $T242446[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T242516[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	jmp	SHORT $LN29@Buynode
$LN33@Buynode:
	mov	DWORD PTR tv182[ebp], 0
$LN29@Buynode:

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T242447[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	add	eax, 8
	mov	DWORD PTR __Vptr$242543[ebp], eax
	mov	ecx, DWORD PTR __Vptr$242543[ebp]
	mov	DWORD PTR $T242545[ebp], ecx
	cmp	DWORD PTR $T242545[ebp], 0
	je	SHORT $LN43@Buynode
	mov	edx, DWORD PTR $T242545[ebp]
	mov	eax, DWORD PTR $T242447[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR $T242545[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN39@Buynode
$LN43@Buynode:
	mov	DWORD PTR tv72[ebp], 0
$LN39@Buynode:
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)
; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1396 : 		if (0 < _Linkcnt)
; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN61@Buynode
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1401 : 		_Color(_Wherenode) = _Black;

$LN61@Buynode:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	BYTE PTR [ecx+21], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T242593 = -80						; size = 28
$T242592 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T242593[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T242592[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T242592[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T242593[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242592[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T242592[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T242592[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T242593[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T242593[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T242592[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPolicyEntry@@V?$allocator@PAVCvPolicyEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPolicyEntry *,std::allocator<CvPolicyEntry *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T242615 = -80						; size = 28
$T242614 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T242615[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T242614[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T242614[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T242615[ebp]
	push	eax
	lea	ecx, DWORD PTR $T242614[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T242614[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T242614[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T242615[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T242615[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T242614[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvPolicyBranchEntry@@V?$allocator@PAVCvPolicyBranchEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvPolicyBranchEntry *,std::allocator<CvPolicyBranchEntry *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
PUBLIC	??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv302 = -420						; size = 4
tv288 = -416						; size = 4
tv280 = -412						; size = 4
_this$ = -408						; size = 4
$T243317 = -404						; size = 4
$T243309 = -400						; size = 4
$T243308 = -396						; size = 4
$T243285 = -390						; size = 1
$T243284 = -389						; size = 1
$T243283 = -388						; size = 4
$T243282 = -384						; size = 4
$T243270 = -377						; size = 1
$T243269 = -376						; size = 4
$T243268 = -372						; size = 4
$T243267 = -368						; size = 4
__Cat$243301 = -364					; size = 1
$T243299 = -363						; size = 1
$T243298 = -362						; size = 1
__Cat$243291 = -360					; size = 1
$T243289 = -359						; size = 1
$T243288 = -358						; size = 1
$T243287 = -357						; size = 1
$T243242 = -356						; size = 4
$T243223 = -352						; size = 4
$T243206 = -345						; size = 1
$T243205 = -344						; size = 4
$T243195 = -340						; size = 4
$T243194 = -336						; size = 4
__Cat$243237 = -330					; size = 1
$T243235 = -329						; size = 1
$T243234 = -328						; size = 1
__Cat$243230 = -327					; size = 1
$T243228 = -326						; size = 1
$T243227 = -325						; size = 1
$T243170 = -324						; size = 4
$T243162 = -320						; size = 4
$T243154 = -316						; size = 4
$T243136 = -312						; size = 4
$T243135 = -308						; size = 4
$T243119 = -304						; size = 4
__Cat$243141 = -298					; size = 1
$T243139 = -297						; size = 1
$T243093 = -296						; size = 4
$T243092 = -292						; size = 4
$T243082 = -288						; size = 4
__Cat$243088 = -283					; size = 1
$T243086 = -282						; size = 1
$T243085 = -281						; size = 1
$T243066 = -280						; size = 4
$T243047 = -276						; size = 4
$T243030 = -269						; size = 1
$T243029 = -268						; size = 4
$T243019 = -264						; size = 4
$T243018 = -260						; size = 4
__Cat$243061 = -254					; size = 1
$T243058 = -253						; size = 1
$T243057 = -252						; size = 1
__Cat$243054 = -251					; size = 1
$T243051 = -250						; size = 1
$T243050 = -249						; size = 1
$T242994 = -248						; size = 4
$T242993 = -244						; size = 4
$T242989 = -240						; size = 4
$T242988 = -236						; size = 4
$T242970 = -232						; size = 4
$T242969 = -228						; size = 4
$T242953 = -224						; size = 4
__Cat$242976 = -218					; size = 1
$T242973 = -217						; size = 1
$T242904 = -216						; size = 4
$T242903 = -212						; size = 4
$T242887 = -208						; size = 4
__Cat$242910 = -202					; size = 1
$T242907 = -201						; size = 1
$T242844 = -200						; size = 4
$T242843 = -196						; size = 4
$T242827 = -192						; size = 4
__Cat$242850 = -186					; size = 1
$T242847 = -185						; size = 1
$T242801 = -184						; size = 4
$T242789 = -180						; size = 4
$T242779 = -173						; size = 1
$T242778 = -172						; size = 4
__Cat$242796 = -167					; size = 1
$T242793 = -166						; size = 1
$T242792 = -165						; size = 1
$T242766 = -164						; size = 4
$T242754 = -160						; size = 4
$T242744 = -153						; size = 1
$T242743 = -152						; size = 4
__Cat$242761 = -147					; size = 1
$T242758 = -146						; size = 1
$T242757 = -145						; size = 1
$T242731 = -144						; size = 4
$T242721 = -140						; size = 4
__Cat$242728 = -135					; size = 1
$T242725 = -134						; size = 1
$T242724 = -133						; size = 1
__Count$242691 = -120					; size = 4
__Count$242665 = -48					; size = 4
__Tmp$227437 = -44					; size = 4
__Oldend$227438 = -40					; size = 4
__Tmp$227427 = -36					; size = 4
__Ncopied$227414 = -32					; size = 4
__Newvec$227412 = -28					; size = 4
__Whereoff$227413 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z PROC ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n
$LN29@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$242665[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$242665[ebp], 0
	jbe	SHORT $LN35@Insert_n
	mov	edx, DWORD PTR __Count$242665[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n
$LN35@Insert_n:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@KAXXZ ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Xlen
	jmp	$LN16@Insert_n

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$242691[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$242691[ebp], 0
	jbe	SHORT $LN48@Insert_n
	mov	ecx, DWORD PTR __Count$242691[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n
$LN48@Insert_n:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ; std::_Allocate<enum BuildingTypes>
	add	esp, 8
	mov	DWORD PTR __Newvec$227412[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$227413[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$227414[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$227413[ebp]
	mov	ecx, DWORD PTR __Newvec$227412[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T242731[ebp], edx
	mov	eax, DWORD PTR $T242731[ebp]
	mov	DWORD PTR $T242721[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242724[ebp], cl
	mov	dl, BYTE PTR __Cat$242728[ebp]
	mov	BYTE PTR $T242725[ebp], dl
	movzx	eax, BYTE PTR $T242724[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T242725[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242721[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$227414[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$227414[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T242766[ebp], edx
	mov	eax, DWORD PTR __Newvec$227412[ebp]
	mov	DWORD PTR $T242754[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242757[ebp], cl
	mov	dl, BYTE PTR __Cat$242761[ebp]
	mov	BYTE PTR $T242758[ebp], dl
	mov	al, BYTE PTR $T242757[ebp]
	mov	BYTE PTR $T242744[ebp], al
	mov	ecx, DWORD PTR $T242754[ebp]
	mov	DWORD PTR $T242743[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242743[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242766[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$227414[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$227414[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T242801[ebp], edx
	mov	eax, DWORD PTR __Whereoff$227413[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$227412[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T242789[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242792[ebp], al
	mov	cl, BYTE PTR __Cat$242796[ebp]
	mov	BYTE PTR $T242793[ebp], cl
	mov	dl, BYTE PTR $T242792[ebp]
	mov	BYTE PTR $T242779[ebp], dl
	mov	eax, DWORD PTR $T242789[ebp]
	mov	DWORD PTR $T242778[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242778[ebp]
	push	edx
	mov	eax, DWORD PTR $T242801[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n
__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$227414[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$227413[ebp]
	mov	eax, DWORD PTR __Newvec$227412[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T242844[ebp], ecx
	mov	edx, DWORD PTR __Newvec$227412[ebp]
	mov	DWORD PTR $T242843[ebp], edx
	mov	al, BYTE PTR __Cat$242850[ebp]
	mov	BYTE PTR $T242847[ebp], al
	mov	ecx, DWORD PTR $T242843[ebp]
	mov	DWORD PTR $T242827[ebp], ecx
	jmp	SHORT $LN91@Insert_n
$LN90@Insert_n:
	mov	edx, DWORD PTR $T242827[ebp]
	add	edx, 4
	mov	DWORD PTR $T242827[ebp], edx
$LN91@Insert_n:
	mov	eax, DWORD PTR $T242827[ebp]
	cmp	eax, DWORD PTR $T242844[ebp]
	je	SHORT $LN7@Insert_n
	jmp	SHORT $LN90@Insert_n
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$227414[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$227413[ebp]
	mov	edx, DWORD PTR __Newvec$227412[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T242904[ebp], edx
	mov	eax, DWORD PTR __Whereoff$227413[ebp]
	mov	ecx, DWORD PTR __Newvec$227412[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T242903[ebp], edx
	mov	al, BYTE PTR __Cat$242910[ebp]
	mov	BYTE PTR $T242907[ebp], al
	mov	ecx, DWORD PTR $T242903[ebp]
	mov	DWORD PTR $T242887[ebp], ecx
	jmp	SHORT $LN106@Insert_n
$LN105@Insert_n:
	mov	edx, DWORD PTR $T242887[ebp]
	add	edx, 4
	mov	DWORD PTR $T242887[ebp], edx
$LN106@Insert_n:
	mov	eax, DWORD PTR $T242887[ebp]
	cmp	eax, DWORD PTR $T242904[ebp]
	je	SHORT $LN6@Insert_n
	jmp	SHORT $LN105@Insert_n
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$227412[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T242989[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T242988[ebp], eax
	mov	ecx, DWORD PTR $T242989[ebp]
	mov	DWORD PTR $T242970[ebp], ecx
	mov	edx, DWORD PTR $T242988[ebp]
	mov	DWORD PTR $T242969[ebp], edx
	mov	al, BYTE PTR __Cat$242976[ebp]
	mov	BYTE PTR $T242973[ebp], al
	mov	ecx, DWORD PTR $T242969[ebp]
	mov	DWORD PTR $T242953[ebp], ecx
	jmp	SHORT $LN125@Insert_n
$LN124@Insert_n:
	mov	edx, DWORD PTR $T242953[ebp]
	add	edx, 4
	mov	DWORD PTR $T242953[ebp], edx
$LN125@Insert_n:
	mov	eax, DWORD PTR $T242953[ebp]
	cmp	eax, DWORD PTR $T242970[ebp]
	je	SHORT $LN117@Insert_n
	jmp	SHORT $LN124@Insert_n
$LN117@Insert_n:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T242994[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T242993[ebp], edx
	mov	eax, DWORD PTR $T242993[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$227412[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$227412[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$227412[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227427[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243066[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T243047[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243050[ebp], dl
	mov	al, BYTE PTR __Cat$243054[ebp]
	mov	BYTE PTR $T243051[ebp], al
	mov	cl, BYTE PTR $T243050[ebp]
	mov	BYTE PTR $T243030[ebp], cl
	mov	edx, DWORD PTR $T243047[ebp]
	mov	DWORD PTR $T243029[ebp], edx
	mov	eax, DWORD PTR $T243029[ebp]
	mov	DWORD PTR $T243019[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T243018[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243057[ebp], dl
	mov	al, BYTE PTR __Cat$243061[ebp]
	mov	BYTE PTR $T243058[ebp], al
	movzx	ecx, BYTE PTR $T243057[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T243058[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243019[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243066[ebp]
	push	edx
	mov	eax, DWORD PTR $T243018[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T243093[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243092[ebp], edx
	mov	eax, DWORD PTR $T243092[ebp]
	mov	DWORD PTR $T243082[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T243085[ebp], cl
	mov	dl, BYTE PTR __Cat$243088[ebp]
	mov	BYTE PTR $T243086[ebp], dl
	movzx	eax, BYTE PTR $T243085[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T243086[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$227427[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243093[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243082[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T243154[ebp], eax
	mov	ecx, DWORD PTR $T243154[ebp]
	mov	DWORD PTR $T243136[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T243135[ebp], ecx
	mov	dl, BYTE PTR __Cat$243141[ebp]
	mov	BYTE PTR $T243139[ebp], dl
	mov	eax, DWORD PTR $T243135[ebp]
	mov	DWORD PTR $T243119[ebp], eax
	jmp	SHORT $LN160@Insert_n
$LN159@Insert_n:
	mov	ecx, DWORD PTR $T243119[ebp]
	add	ecx, 4
	mov	DWORD PTR $T243119[ebp], ecx
$LN160@Insert_n:
	mov	edx, DWORD PTR $T243119[ebp]
	cmp	edx, DWORD PTR $T243136[ebp]
	je	SHORT $LN152@Insert_n
	jmp	SHORT $LN159@Insert_n
$LN152@Insert_n:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T243170[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T243162[ebp], edx
	jmp	SHORT $LN171@Insert_n
$LN170@Insert_n:
	mov	eax, DWORD PTR $T243162[ebp]
	add	eax, 4
	mov	DWORD PTR $T243162[ebp], eax
$LN171@Insert_n:
	mov	ecx, DWORD PTR $T243162[ebp]
	cmp	ecx, DWORD PTR $T243170[ebp]
	je	SHORT $LN167@Insert_n
	mov	edx, DWORD PTR $T243162[ebp]
	mov	eax, DWORD PTR __Tmp$227427[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN170@Insert_n
$LN167@Insert_n:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227437[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$227438[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243242[ebp], eax
	mov	ecx, DWORD PTR $T243242[ebp]
	mov	DWORD PTR $T243223[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243227[ebp], dl
	mov	al, BYTE PTR __Cat$243230[ebp]
	mov	BYTE PTR $T243228[ebp], al
	mov	cl, BYTE PTR $T243227[ebp]
	mov	BYTE PTR $T243206[ebp], cl
	mov	edx, DWORD PTR $T243223[ebp]
	mov	DWORD PTR $T243205[ebp], edx
	mov	eax, DWORD PTR $T243205[ebp]
	mov	DWORD PTR $T243195[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$227438[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T243194[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T243234[ebp], al
	mov	cl, BYTE PTR __Cat$243237[ebp]
	mov	BYTE PTR $T243235[ebp], cl
	movzx	edx, BYTE PTR $T243234[ebp]
	push	edx
	movzx	eax, BYTE PTR $T243235[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243195[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$227438[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243194[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$227438[ebp]
	mov	DWORD PTR $T243309[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T243308[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243287[ebp], dl
	mov	al, BYTE PTR __Cat$243291[ebp]
	mov	BYTE PTR $T243288[ebp], al
	mov	cl, BYTE PTR $T243287[ebp]
	mov	BYTE PTR $T243285[ebp], cl
	mov	dl, BYTE PTR $T243289[ebp]
	mov	BYTE PTR $T243284[ebp], dl
	mov	eax, DWORD PTR $T243309[ebp]
	mov	DWORD PTR $T243283[ebp], eax
	mov	ecx, DWORD PTR $T243308[ebp]
	mov	DWORD PTR $T243282[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243298[ebp], dl
	mov	al, BYTE PTR __Cat$243301[ebp]
	mov	BYTE PTR $T243299[ebp], al
	mov	cl, BYTE PTR $T243298[ebp]
	mov	BYTE PTR $T243270[ebp], cl
	mov	edx, DWORD PTR $T243283[ebp]
	mov	DWORD PTR $T243269[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$227438[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T243268[ebp], ecx
	mov	edx, DWORD PTR $T243282[ebp]
	mov	DWORD PTR $T243267[ebp], edx
$LN197@Insert_n:
	mov	eax, DWORD PTR $T243267[ebp]
	cmp	eax, DWORD PTR $T243268[ebp]
	je	SHORT $LN186@Insert_n
	mov	ecx, DWORD PTR $T243268[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T243268[ebp], ecx
	mov	edx, DWORD PTR $T243269[ebp]
	sub	edx, 4
	mov	DWORD PTR $T243269[ebp], edx
	mov	eax, DWORD PTR $T243269[ebp]
	mov	ecx, DWORD PTR $T243268[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN197@Insert_n
$LN186@Insert_n:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T243317[ebp], eax
	jmp	SHORT $LN204@Insert_n
$LN203@Insert_n:
	mov	ecx, DWORD PTR $T243317[ebp]
	add	ecx, 4
	mov	DWORD PTR $T243317[ebp], ecx
$LN204@Insert_n:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T243317[ebp], ecx
	je	SHORT $LN16@Insert_n
	mov	edx, DWORD PTR $T243317[ebp]
	mov	eax, DWORD PTR __Tmp$227437[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN203@Insert_n
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@2@IABW4BuildingTypes@@@Z ENDP ; std::vector<enum BuildingTypes,std::allocator<enum BuildingTypes> >::_Insert_n
PUBLIC	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
PUBLIC	??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$2
__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
_TEXT	SEGMENT
tv84 = -424						; size = 4
tv302 = -420						; size = 4
tv288 = -416						; size = 4
tv280 = -412						; size = 4
_this$ = -408						; size = 4
$T244019 = -404						; size = 4
$T244011 = -400						; size = 4
$T244010 = -396						; size = 4
$T243987 = -390						; size = 1
$T243986 = -389						; size = 1
$T243985 = -388						; size = 4
$T243984 = -384						; size = 4
$T243972 = -377						; size = 1
$T243971 = -376						; size = 4
$T243970 = -372						; size = 4
$T243969 = -368						; size = 4
__Cat$244004 = -364					; size = 1
$T244001 = -363						; size = 1
$T244000 = -362						; size = 1
__Cat$243995 = -360					; size = 1
$T243992 = -359						; size = 1
$T243991 = -358						; size = 1
$T243990 = -357						; size = 1
$T243944 = -356						; size = 4
$T243925 = -352						; size = 4
$T243908 = -345						; size = 1
$T243907 = -344						; size = 4
$T243897 = -340						; size = 4
$T243896 = -336						; size = 4
__Cat$243940 = -330					; size = 1
$T243937 = -329						; size = 1
$T243936 = -328						; size = 1
__Cat$243933 = -327					; size = 1
$T243930 = -326						; size = 1
$T243929 = -325						; size = 1
$T243872 = -324						; size = 4
$T243864 = -320						; size = 4
$T243856 = -316						; size = 4
$T243838 = -312						; size = 4
$T243837 = -308						; size = 4
$T243821 = -304						; size = 4
__Cat$243844 = -298					; size = 1
$T243841 = -297						; size = 1
$T243795 = -296						; size = 4
$T243794 = -292						; size = 4
$T243784 = -288						; size = 4
__Cat$243791 = -283					; size = 1
$T243788 = -282						; size = 1
$T243787 = -281						; size = 1
$T243768 = -280						; size = 4
$T243749 = -276						; size = 4
$T243732 = -269						; size = 1
$T243731 = -268						; size = 4
$T243721 = -264						; size = 4
$T243720 = -260						; size = 4
__Cat$243757 = -254					; size = 1
$T243755 = -253						; size = 1
$T243754 = -252						; size = 1
__Cat$243765 = -251					; size = 1
$T243763 = -250						; size = 1
$T243762 = -249						; size = 1
$T243696 = -248						; size = 4
$T243695 = -244						; size = 4
$T243691 = -240						; size = 4
$T243690 = -236						; size = 4
$T243672 = -232						; size = 4
$T243671 = -228						; size = 4
$T243655 = -224						; size = 4
__Cat$243679 = -218					; size = 1
$T243677 = -217						; size = 1
$T243606 = -216						; size = 4
$T243605 = -212						; size = 4
$T243589 = -208						; size = 4
__Cat$243613 = -202					; size = 1
$T243611 = -201						; size = 1
$T243546 = -200						; size = 4
$T243545 = -196						; size = 4
$T243529 = -192						; size = 4
__Cat$243552 = -186					; size = 1
$T243550 = -185						; size = 1
$T243503 = -184						; size = 4
$T243491 = -180						; size = 4
$T243481 = -173						; size = 1
$T243480 = -172						; size = 4
__Cat$243499 = -167					; size = 1
$T243497 = -166						; size = 1
$T243496 = -165						; size = 1
$T243468 = -164						; size = 4
$T243456 = -160						; size = 4
$T243446 = -153						; size = 1
$T243445 = -152						; size = 4
__Cat$243464 = -147					; size = 1
$T243462 = -146						; size = 1
$T243461 = -145						; size = 1
$T243433 = -144						; size = 4
$T243423 = -140						; size = 4
__Cat$243429 = -135					; size = 1
$T243427 = -134						; size = 1
$T243426 = -133						; size = 1
__Count$243392 = -120					; size = 4
__Count$243366 = -48					; size = 4
__Tmp$227496 = -44					; size = 4
__Oldend$227497 = -40					; size = 4
__Tmp$227486 = -36					; size = 4
__Ncopied$227473 = -32					; size = 4
__Newvec$227471 = -28					; size = 4
__Whereoff$227472 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z PROC ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@2
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@2
$LN29@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@2:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$243366[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$243366[ebp], 0
	jbe	SHORT $LN35@Insert_n@2
	mov	edx, DWORD PTR __Count$243366[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@2
$LN35@Insert_n@2:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@KAXXZ ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Xlen
	jmp	$LN16@Insert_n@2

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$243392[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$243392[ebp], 0
	jbe	SHORT $LN48@Insert_n@2
	mov	ecx, DWORD PTR __Count$243392[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@2
$LN48@Insert_n@2:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@2:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@2:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ; std::_Allocate<enum PolicyTypes>
	add	esp, 8
	mov	DWORD PTR __Newvec$227471[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$227472[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$227473[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$227472[ebp]
	mov	ecx, DWORD PTR __Newvec$227471[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T243433[ebp], edx
	mov	eax, DWORD PTR $T243433[ebp]
	mov	DWORD PTR $T243423[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T243426[ebp], cl
	mov	dl, BYTE PTR __Cat$243429[ebp]
	mov	BYTE PTR $T243427[ebp], dl
	movzx	eax, BYTE PTR $T243426[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T243427[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243423[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$227473[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$227473[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243468[ebp], edx
	mov	eax, DWORD PTR __Newvec$227471[ebp]
	mov	DWORD PTR $T243456[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T243461[ebp], cl
	mov	dl, BYTE PTR __Cat$243464[ebp]
	mov	BYTE PTR $T243462[ebp], dl
	mov	al, BYTE PTR $T243461[ebp]
	mov	BYTE PTR $T243446[ebp], al
	mov	ecx, DWORD PTR $T243456[ebp]
	mov	DWORD PTR $T243445[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T243445[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243468[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$227473[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$227473[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243503[ebp], edx
	mov	eax, DWORD PTR __Whereoff$227472[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$227471[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T243491[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T243496[ebp], al
	mov	cl, BYTE PTR __Cat$243499[ebp]
	mov	BYTE PTR $T243497[ebp], cl
	mov	dl, BYTE PTR $T243496[ebp]
	mov	BYTE PTR $T243481[ebp], dl
	mov	eax, DWORD PTR $T243491[ebp]
	mov	DWORD PTR $T243480[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243480[ebp]
	push	edx
	mov	eax, DWORD PTR $T243503[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@2
__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$227473[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$227472[ebp]
	mov	eax, DWORD PTR __Newvec$227471[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T243546[ebp], ecx
	mov	edx, DWORD PTR __Newvec$227471[ebp]
	mov	DWORD PTR $T243545[ebp], edx
	mov	al, BYTE PTR __Cat$243552[ebp]
	mov	BYTE PTR $T243550[ebp], al
	mov	ecx, DWORD PTR $T243545[ebp]
	mov	DWORD PTR $T243529[ebp], ecx
	jmp	SHORT $LN91@Insert_n@2
$LN90@Insert_n@2:
	mov	edx, DWORD PTR $T243529[ebp]
	add	edx, 4
	mov	DWORD PTR $T243529[ebp], edx
$LN91@Insert_n@2:
	mov	eax, DWORD PTR $T243529[ebp]
	cmp	eax, DWORD PTR $T243546[ebp]
	je	SHORT $LN7@Insert_n@2
	jmp	SHORT $LN90@Insert_n@2
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$227473[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$227472[ebp]
	mov	edx, DWORD PTR __Newvec$227471[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T243606[ebp], edx
	mov	eax, DWORD PTR __Whereoff$227472[ebp]
	mov	ecx, DWORD PTR __Newvec$227471[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T243605[ebp], edx
	mov	al, BYTE PTR __Cat$243613[ebp]
	mov	BYTE PTR $T243611[ebp], al
	mov	ecx, DWORD PTR $T243605[ebp]
	mov	DWORD PTR $T243589[ebp], ecx
	jmp	SHORT $LN106@Insert_n@2
$LN105@Insert_n@2:
	mov	edx, DWORD PTR $T243589[ebp]
	add	edx, 4
	mov	DWORD PTR $T243589[ebp], edx
$LN106@Insert_n@2:
	mov	eax, DWORD PTR $T243589[ebp]
	cmp	eax, DWORD PTR $T243606[ebp]
	je	SHORT $LN6@Insert_n@2
	jmp	SHORT $LN105@Insert_n@2
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$227471[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN115@Insert_n@2
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN115@Insert_n@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243691[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T243690[ebp], eax
	mov	ecx, DWORD PTR $T243691[ebp]
	mov	DWORD PTR $T243672[ebp], ecx
	mov	edx, DWORD PTR $T243690[ebp]
	mov	DWORD PTR $T243671[ebp], edx
	mov	al, BYTE PTR __Cat$243679[ebp]
	mov	BYTE PTR $T243677[ebp], al
	mov	ecx, DWORD PTR $T243671[ebp]
	mov	DWORD PTR $T243655[ebp], ecx
	jmp	SHORT $LN125@Insert_n@2
$LN124@Insert_n@2:
	mov	edx, DWORD PTR $T243655[ebp]
	add	edx, 4
	mov	DWORD PTR $T243655[ebp], edx
$LN125@Insert_n@2:
	mov	eax, DWORD PTR $T243655[ebp]
	cmp	eax, DWORD PTR $T243672[ebp]
	je	SHORT $LN117@Insert_n@2
	jmp	SHORT $LN124@Insert_n@2
$LN117@Insert_n@2:

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR $T243696[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T243695[ebp], edx
	mov	eax, DWORD PTR $T243695[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	mov	edx, DWORD PTR __Newvec$227471[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$227471[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newvec$227471[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR __Where$[ebp]
	sar	eax, 2
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227486[ebp], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T243768[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T243749[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243762[ebp], dl
	mov	al, BYTE PTR __Cat$243765[ebp]
	mov	BYTE PTR $T243763[ebp], al
	mov	cl, BYTE PTR $T243762[ebp]
	mov	BYTE PTR $T243732[ebp], cl
	mov	edx, DWORD PTR $T243749[ebp]
	mov	DWORD PTR $T243731[ebp], edx
	mov	eax, DWORD PTR $T243731[ebp]
	mov	DWORD PTR $T243721[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T243720[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243754[ebp], dl
	mov	al, BYTE PTR __Cat$243757[ebp]
	mov	BYTE PTR $T243755[ebp], al
	movzx	ecx, BYTE PTR $T243754[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T243755[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243721[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243768[ebp]
	push	edx
	mov	eax, DWORD PTR $T243720[ebp]
	push	eax
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR $T243795[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T243794[ebp], edx
	mov	eax, DWORD PTR $T243794[ebp]
	mov	DWORD PTR $T243784[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T243787[ebp], cl
	mov	dl, BYTE PTR __Cat$243791[ebp]
	mov	BYTE PTR $T243788[ebp], dl
	movzx	eax, BYTE PTR $T243787[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T243788[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR __Tmp$227486[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243795[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243784[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T243856[ebp], eax
	mov	ecx, DWORD PTR $T243856[ebp]
	mov	DWORD PTR $T243838[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T243837[ebp], ecx
	mov	dl, BYTE PTR __Cat$243844[ebp]
	mov	BYTE PTR $T243841[ebp], dl
	mov	eax, DWORD PTR $T243837[ebp]
	mov	DWORD PTR $T243821[ebp], eax
	jmp	SHORT $LN160@Insert_n@2
$LN159@Insert_n@2:
	mov	ecx, DWORD PTR $T243821[ebp]
	add	ecx, 4
	mov	DWORD PTR $T243821[ebp], ecx
$LN160@Insert_n@2:
	mov	edx, DWORD PTR $T243821[ebp]
	cmp	edx, DWORD PTR $T243838[ebp]
	je	SHORT $LN152@Insert_n@2
	jmp	SHORT $LN159@Insert_n@2
$LN152@Insert_n@2:

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T243872[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T243864[ebp], edx
	jmp	SHORT $LN171@Insert_n@2
$LN170@Insert_n@2:
	mov	eax, DWORD PTR $T243864[ebp]
	add	eax, 4
	mov	DWORD PTR $T243864[ebp], eax
$LN171@Insert_n@2:
	mov	ecx, DWORD PTR $T243864[ebp]
	cmp	ecx, DWORD PTR $T243872[ebp]
	je	SHORT $LN167@Insert_n@2
	mov	edx, DWORD PTR $T243864[ebp]
	mov	eax, DWORD PTR __Tmp$227486[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN170@Insert_n@2
$LN167@Insert_n@2:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$227496[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$227497[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T243944[ebp], eax
	mov	ecx, DWORD PTR $T243944[ebp]
	mov	DWORD PTR $T243925[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243929[ebp], dl
	mov	al, BYTE PTR __Cat$243933[ebp]
	mov	BYTE PTR $T243930[ebp], al
	mov	cl, BYTE PTR $T243929[ebp]
	mov	BYTE PTR $T243908[ebp], cl
	mov	edx, DWORD PTR $T243925[ebp]
	mov	DWORD PTR $T243907[ebp], edx
	mov	eax, DWORD PTR $T243907[ebp]
	mov	DWORD PTR $T243897[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$227497[ebp]
	sub	edx, ecx
	mov	DWORD PTR $T243896[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T243936[ebp], al
	mov	cl, BYTE PTR __Cat$243940[ebp]
	mov	BYTE PTR $T243937[ebp], cl
	movzx	edx, BYTE PTR $T243936[ebp]
	push	edx
	movzx	eax, BYTE PTR $T243937[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T243897[ebp]
	push	edx
	mov	eax, DWORD PTR __Oldend$227497[ebp]
	push	eax
	mov	ecx, DWORD PTR $T243896[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$227497[ebp]
	mov	DWORD PTR $T244011[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244010[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T243990[ebp], dl
	mov	al, BYTE PTR __Cat$243995[ebp]
	mov	BYTE PTR $T243991[ebp], al
	mov	cl, BYTE PTR $T243990[ebp]
	mov	BYTE PTR $T243987[ebp], cl
	mov	dl, BYTE PTR $T243992[ebp]
	mov	BYTE PTR $T243986[ebp], dl
	mov	eax, DWORD PTR $T244011[ebp]
	mov	DWORD PTR $T243985[ebp], eax
	mov	ecx, DWORD PTR $T244010[ebp]
	mov	DWORD PTR $T243984[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T244000[ebp], dl
	mov	al, BYTE PTR __Cat$244004[ebp]
	mov	BYTE PTR $T244001[ebp], al
	mov	cl, BYTE PTR $T244000[ebp]
	mov	BYTE PTR $T243972[ebp], cl
	mov	edx, DWORD PTR $T243985[ebp]
	mov	DWORD PTR $T243971[ebp], edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$227497[ebp]
	sub	ecx, eax
	mov	DWORD PTR $T243970[ebp], ecx
	mov	edx, DWORD PTR $T243984[ebp]
	mov	DWORD PTR $T243969[ebp], edx
$LN197@Insert_n@2:
	mov	eax, DWORD PTR $T243969[ebp]
	cmp	eax, DWORD PTR $T243970[ebp]
	je	SHORT $LN186@Insert_n@2
	mov	ecx, DWORD PTR $T243970[ebp]
	sub	ecx, 4
	mov	DWORD PTR $T243970[ebp], ecx
	mov	edx, DWORD PTR $T243971[ebp]
	sub	edx, 4
	mov	DWORD PTR $T243971[ebp], edx
	mov	eax, DWORD PTR $T243971[ebp]
	mov	ecx, DWORD PTR $T243970[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN197@Insert_n@2
$LN186@Insert_n@2:

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244019[ebp], eax
	jmp	SHORT $LN204@Insert_n@2
$LN203@Insert_n@2:
	mov	ecx, DWORD PTR $T244019[ebp]
	add	ecx, 4
	mov	DWORD PTR $T244019[ebp], ecx
$LN204@Insert_n@2:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR $T244019[ebp], ecx
	je	SHORT $LN16@Insert_n@2
	mov	edx, DWORD PTR $T244019[ebp]
	mov	eax, DWORD PTR __Tmp$227496[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN203@Insert_n@2
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-428]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@2@IABW4PolicyTypes@@@Z ENDP ; std::vector<enum PolicyTypes,std::allocator<enum PolicyTypes> >::_Insert_n
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R0?AVout_of_range@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -216						; size = 4
tv165 = -212						; size = 4
_this$ = -208						; size = 4
$T244898 = -204						; size = 4
$T244892 = -200						; size = 4
$T244297 = -136						; size = 4
$T244296 = -132						; size = 4
__Tmp$244295 = -125					; size = 1
$T244272 = -124						; size = 4
$T244265 = -120						; size = 4
$T244195 = -116						; size = 4
$T244159 = -112						; size = 4
$T244154 = -108						; size = 4
$T244126 = -104						; size = 4
$T244050 = -100						; size = 4
$T244041 = -96						; size = 28
$T244040 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244050[ebp], eax
	mov	ecx, DWORD PTR $T244050[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN55@erase@4

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T244041[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T244041[ebp]
	push	eax
	lea	ecx, DWORD PTR $T244040[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR $T244040[ebp], OFFSET ??_7out_of_range@std@@6B@
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T244040[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T244041[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

$LN55@erase@4:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Erasednode$[ebp], edx

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Inc

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN67@erase@4

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@4

; 786  : 		else if (_Isnil(_Right(_Pnode)))

$LN67@erase@4:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN71@erase@4

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@4

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

$LN71@erase@4:
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Pnode$[ebp], edx

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Fixnode$[ebp], ecx
$LN38@erase@4:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	$LN137@erase@4

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 797  : 			if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN81@erase@4

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

$LN81@erase@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN89@erase@4

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN32@erase@4

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

$LN89@erase@4:
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN93@erase@4

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [edx], eax

; 804  : 			else

	jmp	SHORT $LN32@erase@4

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

$LN93@erase@4:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN32@erase@4:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244126[ebp], ecx
	mov	edx, DWORD PTR $T244126[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN115@erase@4

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN43@erase@4
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN44@erase@4
$LN43@erase@4:
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T244154[ebp], ecx
$LN107@erase@4:
	mov	edx, DWORD PTR $T244154[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN103@erase@4
	mov	edx, DWORD PTR $T244154[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T244154[ebp], eax
	jmp	SHORT $LN107@erase@4
$LN103@erase@4:
	mov	ecx, DWORD PTR $T244154[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN44@erase@4:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244159[ebp], eax
	mov	ecx, DWORD PTR $T244159[ebp]
	mov	edx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [ecx], edx

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

$LN115@erase@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@4

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	je	SHORT $LN45@erase@4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN131@erase@4
$LN45@erase@4:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR $T244195[ebp], eax
$LN127@erase@4:
	mov	ecx, DWORD PTR $T244195[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN123@erase@4
	mov	ecx, DWORD PTR $T244195[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T244195[ebp], edx
	jmp	SHORT $LN127@erase@4
$LN123@erase@4:
	mov	eax, DWORD PTR $T244195[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN131@erase@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR [edx+8], eax
$LN28@erase@4:

; 816  : 			}
; 817  : 		else

	jmp	$LN192@erase@4

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

$LN137@erase@4:
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN145@erase@4

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 824  : 			else

	jmp	SHORT $LN161@erase@4

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

$LN145@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN151@erase@4

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [edx+4], eax

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

$LN151@erase@4:
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

$LN161@erase@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN169@erase@4

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN183@erase@4

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

$LN169@erase@4:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244265[ebp], ecx
	mov	edx, DWORD PTR $T244265[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN179@erase@4

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T244272[ebp], edx
	mov	eax, DWORD PTR $T244272[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN183@erase@4

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

$LN179@erase@4:
	mov	edx, DWORD PTR __Erasednode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

$LN183@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR $T244297[ebp], edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR $T244296[ebp], eax
	mov	ecx, DWORD PTR $T244296[ebp]
	cmp	ecx, DWORD PTR $T244297[ebp]
	je	SHORT $LN192@erase@4
	mov	edx, DWORD PTR $T244296[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR __Tmp$244295[ebp], al
	mov	ecx, DWORD PTR $T244296[ebp]
	mov	edx, DWORD PTR $T244297[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR $T244297[ebp]
	mov	dl, BYTE PTR __Tmp$244295[ebp]
	mov	BYTE PTR [ecx], dl

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

$LN192@erase@4:
	mov	eax, DWORD PTR __Erasednode$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	$LN588@erase@4

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN196@erase@4
$LN194@erase@4:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax
$LN196@erase@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Fixnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	$LN586@erase@4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	cmp	edx, 1
	jne	$LN586@erase@4

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN395@erase@4

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN263@erase@4

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

$LN263@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN267@erase@4

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@4

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

$LN267@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@4
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN277@erase@4

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	SHORT $LN12@erase@4

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

$LN277@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN338@erase@4

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+20], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Pnode$[ebp], eax

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN338@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	BYTE PTR [eax+20], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN586@erase@4
$LN12@erase@4:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@4

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

$LN395@erase@4:
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	movsx	edx, BYTE PTR [ecx+20]
	test	edx, edx
	jne	SHORT $LN454@erase@4

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

$LN454@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN458@erase@4

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@4

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

$LN458@erase@4:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@4
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+20]
	cmp	ecx, 1
	jne	SHORT $LN468@erase@4

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [edx+20], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 902  : 						}
; 903  : 					else

	jmp	SHORT $LN8@erase@4

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

$LN468@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+20]
	cmp	eax, 1
	jne	SHORT $LN529@erase@4

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx+20], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	BYTE PTR [eax+20], 0

; 909  : 							_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Pnode$[ebp], eax

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

$LN529@erase@4:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	al, BYTE PTR [edx+20]
	mov	BYTE PTR [ecx+20], al

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	BYTE PTR [ecx+20], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	BYTE PTR [eax+20], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN586@erase@4
$LN8@erase@4:

; 918  : 						}
; 919  : 					}

	jmp	$LN194@erase@4

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

$LN586@erase@4:
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	BYTE PTR [edx+20], 1

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

$LN588@erase@4:

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	mov	eax, DWORD PTR __Erasednode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN1@erase@4

; 928  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$LN1@erase@4:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T244898[ebp], edx
	mov	eax, DWORD PTR $T244898[ebp]
	mov	DWORD PTR $T244892[ebp], eax
	mov	ecx, DWORD PTR $T244892[ebp]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@4:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T244041[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 134  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T244978 = -12						; size = 4
$T244971 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Lrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN34@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Lrotate

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

$LN34@Lrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T244971[ebp], eax
	mov	ecx, DWORD PTR $T244971[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN44@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T244978[ebp], ecx
	mov	edx, DWORD PTR $T244978[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx], eax

; 1297 : 		else

	jmp	SHORT $LN46@Lrotate

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

$LN44@Lrotate:
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

$LN46@Lrotate:
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1302 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Lrotate
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T245078 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	movsx	ecx, BYTE PTR [eax+21]
	test	ecx, ecx
	jne	SHORT $LN24@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

$LN24@Rrotate:
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN36@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN46@Rrotate

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

$LN36@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN42@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1341 : 		else

	jmp	SHORT $LN46@Rrotate

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

$LN42@Rrotate:
	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T245078[ebp], eax
	mov	ecx, DWORD PTR $T245078[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], edx

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

$LN46@Rrotate:
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Rrotate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$3
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
_TEXT	SEGMENT
tv86 = -52						; size = 4
_this$ = -48						; size = 4
$T245088 = -28						; size = 4
$T245087 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	0
	push	1
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
	add	esp, 8
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR $T245088[ebp], eax
	cmp	DWORD PTR $T245088[ebp], 0
	je	SHORT $LN4@Buynode@2
	mov	ecx, DWORD PTR $T245088[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T245088[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR $T245088[ebp]
	mov	eax, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T245088[ebp]
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR $T245088[ebp]
	mov	al, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [edx+20], al
	mov	ecx, DWORD PTR $T245088[ebp]
	mov	BYTE PTR [ecx+21], 0
	mov	edx, DWORD PTR $T245088[ebp]
	mov	DWORD PTR tv86[ebp], edx
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@2:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T245087[ebp], eax
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@PAU342@00ABU?$pair@$$CBHH@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv145 = -28						; size = 4
_this$ = -24						; size = 4
$T245150 = -19						; size = 1
$T245149 = -18						; size = 1
$T245141 = -17						; size = 1
$T245137 = -16						; size = 4
$T245130 = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T245149[ebp]
	mov	DWORD PTR $T245130[ebp], eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T245150[ebp], dl
	lea	eax, DWORD PTR $T245141[ebp]
	mov	DWORD PTR $T245137[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], edx

; 53   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@IAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z
_TEXT	SEGMENT
tv87 = -20						; size = 4
_this$ = -16						; size = 4
$T245173 = -9						; size = 1
$T245169 = -8						; size = 4
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z PROC ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T245173[ebp]
	mov	DWORD PTR $T245169[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv87[ebp], ecx

; 40   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@QAE@U?$less@H@1@V?$allocator@U?$pair@$$CBHH@std@@@1@@Z ENDP ; std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T245216 = -16						; size = 4
$T245195 = -12						; size = 4
$T245188 = -8						; size = 4
__Pnode$227681 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 336  :    				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move

	jmp	$LN10@Dec
$LN8@Dec:

; 348  : #endif
; 349  : 			}

	jmp	$LN10@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T245188[ebp], edx
	mov	eax, DWORD PTR $T245188[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	jne	SHORT $LN34@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T245195[ebp], ecx
	mov	edx, DWORD PTR $T245195[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T245216[ebp], eax
$LN30@Dec:
	mov	ecx, DWORD PTR $T245216[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN26@Dec
	mov	ecx, DWORD PTR $T245216[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T245216[ebp], edx
	jmp	SHORT $LN30@Dec
$LN26@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T245216[ebp]
	mov	DWORD PTR [eax], ecx

; 352  : 			else

	jmp	SHORT $LN10@Dec

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

$LN34@Dec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Pnode$227681[ebp], ecx
	mov	edx, DWORD PTR __Pnode$227681[ebp]
	movsx	eax, BYTE PTR [edx+21]
	test	eax, eax
	jne	SHORT $LN40@Dec
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$227681[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN40@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$227681[ebp]
	mov	DWORD PTR [ecx], edx
	jmp	SHORT $LN34@Dec

; 358  : 				if (_Isnil(_Ptr))

$LN40@Dec:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx+21]
	test	edx, edx
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move

	jmp	SHORT $LN10@Dec

; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN10@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$227681[ebp]
	mov	DWORD PTR [eax], ecx
$LN10@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::const_iterator::_Dec
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$227741 = -18					; size = 1
_tValue$227736 = -17					; size = 1
_iType$227734 = -16					; size = 4
_bValid$227733 = -9					; size = 1
_iI$227729 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$227729[ebp], 0
	jmp	SHORT $LN7@ReadHashed
$LN6@ReadHashed:
	mov	ecx, DWORD PTR _iI$227729[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227729[ebp], ecx
$LN7@ReadHashed:
	mov	edx, DWORD PTR _iI$227729[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$227733[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$227734[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$227734[ebp], -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$227736[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$227734[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iType$227734[ebp]
	mov	dl, BYTE PTR _tValue$227736[ebp]
	mov	BYTE PTR [ecx], dl
$LN3@ReadHashed:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	movzx	eax, BYTE PTR _bValid$227733[ebp]
	test	eax, eax
	jne	SHORT $LN2@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	ecx, DWORD PTR _tValue$227741[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN2@ReadHashed:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed
$LN8@ReadHashed:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z
_TEXT	SEGMENT
_eType$227748 = -12					; size = 4
_iI$227744 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z PROC ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>, COMDAT

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 456  : 	uint uiNumEntries;
; 457  : 
; 458  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 459  : 
; 460  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$227744[ebp], 0
	jmp	SHORT $LN4@ReadHashed@2
$LN3@ReadHashed@2:
	mov	ecx, DWORD PTR _iI$227744[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227744[ebp], ecx
$LN4@ReadHashed@2:
	mov	edx, DWORD PTR _iI$227744[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN5@ReadHashed@2

; 461  : 	{
; 462  : 		TType eType = (TType)ReadHashed(kStream);

	push	0
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _eType$227748[ebp], eax

; 463  : 		if(iI < uiArraySize)

	mov	ecx, DWORD PTR _iI$227744[ebp]
	cmp	ecx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN1@ReadHashed@2

; 464  : 			paArray[iI] = eType;

	mov	edx, DWORD PTR _iI$227744[ebp]
	mov	eax, DWORD PTR _paArray$[ebp]
	mov	ecx, DWORD PTR _eType$227748[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$LN1@ReadHashed@2:

; 465  : 	}

	jmp	SHORT $LN3@ReadHashed@2
$LN5@ReadHashed@2:

; 466  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ENDP ; CvInfosSerializationHelper::ReadHashedTypeArray<enum PolicyBranchTypes>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_eType$227763 = -8					; size = 4
_iI$227759 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$227759[ebp], 0
	jmp	SHORT $LN4@WriteHashe
$LN3@WriteHashe:
	mov	ecx, DWORD PTR _iI$227759[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227759[ebp], ecx
$LN4@WriteHashe:
	mov	edx, DWORD PTR _iI$227759[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$227759[ebp]
	mov	DWORD PTR _eType$227763[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$227763[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iI$227759[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN1@WriteHashe:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe
$LN5@WriteHashe:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4PolicyTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_eType$227771 = -8					; size = 4
_iI$227767 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$227767[ebp], 0
	jmp	SHORT $LN4@WriteHashe@2
$LN3@WriteHashe@2:
	mov	ecx, DWORD PTR _iI$227767[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227767[ebp], ecx
$LN4@WriteHashe@2:
	mov	edx, DWORD PTR _iI$227767[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe@2

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$227767[ebp]
	mov	DWORD PTR _eType$227771[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$227771[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _paArray$[ebp]
	add	ecx, DWORD PTR _iI$227767[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN1@WriteHashe@2:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe@2
$LN5@WriteHashe@2:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4PolicyBranchTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum PolicyBranchTypes,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z
_TEXT	SEGMENT
_iI$227775 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>, COMDAT

; 673  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 674  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 675  : 
; 676  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$227775[ebp], 0
	jmp	SHORT $LN3@WriteHashe@3
$LN2@WriteHashe@3:
	mov	ecx, DWORD PTR _iI$227775[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227775[ebp], ecx
$LN3@WriteHashe@3:
	mov	edx, DWORD PTR _iI$227775[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN4@WriteHashe@3

; 677  : 	{
; 678  : 		WriteHashed(kStream, paArray[iI]);

	mov	eax, DWORD PTR _iI$227775[ebp]
	mov	ecx, DWORD PTR _paArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4PolicyBranchTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8

; 679  : 	}

	jmp	SHORT $LN2@WriteHashe@3
$LN4@WriteHashe@3:

; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedTypeArray@W4PolicyBranchTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4PolicyBranchTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedTypeArray<enum PolicyBranchTypes>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@3

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1
__ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
_TEXT	SEGMENT
$T245294 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
_arg2$ = 20						; size = 4
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z PROC ; GetLocalizedText<char const *,char const *>, COMDAT

; 514  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T245294[ebp], 0

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 516  : 	text << arg1 << arg2;

	mov	edx, DWORD PTR _arg2$[ebp]
	push	edx
	mov	eax, DWORD PTR _arg1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 517  : 
; 518  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 519  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[ebp]
	push	edx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 520  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 521  : 	str.assign(szComposedString, bytes);

	mov	eax, DWORD PTR _bytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szComposedString$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 522  : 	return str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T245294[ebp]
	or	eax, 1
	mov	DWORD PTR $T245294[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z$2:
	mov	eax, DWORD PTR $T245294[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@2
	and	DWORD PTR $T245294[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@2:
	ret	0
__ehhandler$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBDPBD@@YA?AVCvString@@PBDABQBD1@Z ENDP ; GetLocalizedText<char const *,char const *>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0
	DD	01H
	DD	FLAT:__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1
__ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
_TEXT	SEGMENT
$T245320 = -140						; size = 4
_str$ = -136						; size = 28
__$ArrayPad$ = -108					; size = 4
_bytes$ = -104						; size = 4
_text$ = -100						; size = 80
_szComposedString$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
_arg1$ = 16						; size = 4
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z PROC	; GetLocalizedText<char const *>, COMDAT

; 501  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T245320[ebp], 0

; 502  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _text$[ebp]
	push	ecx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 503  : 	text << arg1;

	lea	edx, DWORD PTR _arg1$[ebp]
	push	edx
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ; operator<<<char const *>
	add	esp, 8

; 504  : 
; 505  : 	size_t bytes = 0;

	mov	DWORD PTR _bytes$[ebp], 0

; 506  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	ecx, DWORD PTR _bytes$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z
	mov	DWORD PTR _szComposedString$[ebp], eax

; 507  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 508  : 	str.assign(szComposedString, bytes);

	mov	edx, DWORD PTR _bytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _szComposedString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z

; 509  : 	return str;

	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T245320[ebp]
	or	edx, 1
	mov	DWORD PTR $T245320[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 510  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z$2:
	mov	eax, DWORD PTR $T245320[ebp]
	and	eax, 1
	je	$LN6@GetLocaliz@3
	and	DWORD PTR $T245320[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLocaliz@3:
	ret	0
__ehhandler$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$GetLocalizedText@PBD@@YA?AVCvString@@PBD0@Z ENDP	; GetLocalizedText<char const *>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T245362 = -26						; size = 1
$T245361 = -25						; size = 1
$T245360 = -24						; size = 4
$T245359 = -20						; size = 4
__Off$245355 = -16					; size = 4
__Result$245356 = -12					; size = 4
__Cat$245347 = -4					; size = 1
$T245344 = -3						; size = 1
$T245343 = -2						; size = 1
$T245342 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPolicyEntry * *,CvPolicyEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T245342[ebp], al
	mov	cl, BYTE PTR __Cat$245347[ebp]
	mov	BYTE PTR $T245343[ebp], cl
	mov	dl, BYTE PTR $T245342[ebp]
	mov	BYTE PTR $T245362[ebp], dl
	mov	al, BYTE PTR $T245344[ebp]
	mov	BYTE PTR $T245361[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T245360[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245359[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T245359[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$245355[ebp], eax
	mov	ecx, DWORD PTR __Off$245355[ebp]
	mov	edx, DWORD PTR $T245360[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$245356[ebp], eax
	cmp	DWORD PTR __Off$245355[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$245355[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T245359[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$245355[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T245360[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$245356[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvPolicyEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPolicyEntry * *,CvPolicyEntry * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T245385 = -26						; size = 1
$T245384 = -25						; size = 1
$T245383 = -24						; size = 4
$T245382 = -20						; size = 4
__Off$245378 = -16					; size = 4
__Result$245379 = -12					; size = 4
__Cat$245370 = -4					; size = 1
$T245367 = -3						; size = 1
$T245366 = -2						; size = 1
$T245365 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T245365[ebp], al
	mov	cl, BYTE PTR __Cat$245370[ebp]
	mov	BYTE PTR $T245366[ebp], cl
	mov	dl, BYTE PTR $T245365[ebp]
	mov	BYTE PTR $T245385[ebp], dl
	mov	al, BYTE PTR $T245367[ebp]
	mov	BYTE PTR $T245384[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T245383[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245382[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T245382[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$245378[ebp], eax
	mov	ecx, DWORD PTR __Off$245378[ebp]
	mov	edx, DWORD PTR $T245383[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$245379[ebp], eax
	cmp	DWORD PTR __Off$245378[ebp], 0
	jle	SHORT $LN8@unchecked_@2
	mov	ecx, DWORD PTR __Off$245378[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T245382[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$245378[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T245383[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	mov	eax, DWORD PTR __Result$245379[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvPolicyBranchEntry@@PAPAV1@@stdext@@YAPAPAVCvPolicyBranchEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvPolicyBranchEntry * *,CvPolicyBranchEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T245392 = -16						; size = 4
$T245388 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z PROC ; std::_Allocate<enum BuildingTypes>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T245392[ebp], 0
	lea	eax, DWORD PTR $T245392[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245388[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T245388[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T245388[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4BuildingTypes@@@std@@YAPAW4BuildingTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum BuildingTypes>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z
_TEXT	SEGMENT
$T245406 = -16						; size = 4
$T245402 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z PROC ; std::_Allocate<enum PolicyTypes>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T245406[ebp], 0
	lea	eax, DWORD PTR $T245406[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245402[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T245402[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T245402[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4PolicyTypes@@@std@@YAPAW4PolicyTypes@@IPAW41@@Z ENDP ; std::_Allocate<enum PolicyTypes>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T245413 = -16						; size = 4
$T245409 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvPolicyEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T245413[ebp], 0
	lea	eax, DWORD PTR $T245413[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245409[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T245409[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T245409[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvPolicyEntry@@@std@@YAPAPAVCvPolicyEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPolicyEntry *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T245420 = -16						; size = 4
$T245416 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvPolicyBranchEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T245420[ebp], 0
	lea	eax, DWORD PTR $T245420[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245416[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T245416[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T245416[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvPolicyBranchEntry@@@std@@YAPAPAVCvPolicyBranchEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvPolicyBranchEntry *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T245427 = -16						; size = 4
$T245423 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T245427[ebp], 0
	lea	eax, DWORD PTR $T245427[ebp]
	push	eax
	lea	ecx, DWORD PTR $T245423[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T245423[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T245423[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HHU?$less@H@std@@V?$allocator@U?$pair@$$CBHH@std@@@2@$00@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,int,std::less<int>,std::allocator<std::pair<int const ,int> >,1> >::_Node>
_TEXT	ENDS
EXTRN	__imp_?PushArgument@String@Localization@@QAE_NPBD@Z:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvlocalization\include\cvlocalization.h
;	COMDAT ??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_val$ = 12						; size = 4
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z PROC	; operator<<<char const *>, COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp

; 491  : 	s.PushArgument(val);

	mov	eax, DWORD PTR _val$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _s$[ebp]
	call	DWORD PTR __imp_?PushArgument@String@Localization@@QAE_NPBD@Z

; 492  : 	return s;

	mov	eax, DWORD PTR _s$[ebp]

; 493  : }

	pop	ebp
	ret	0
??$?6PBD@@YAAAVString@Localization@@AAV01@ABQBD@Z ENDP	; operator<<<char const *>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T245457 = -28						; size = 4
__Vptr$245455 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$245455[ebp], eax
	mov	ecx, DWORD PTR __Vptr$245455[ebp]
	mov	DWORD PTR $T245457[ebp], ecx
	cmp	DWORD PTR $T245457[ebp], 0
	je	SHORT $LN18@Uninit_fil
	mov	edx, DWORD PTR $T245457[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T245457[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@Uninit_fil
$LN18@Uninit_fil:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_fil:
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4BuildingTypes@@IW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAXPAW4BuildingTypes@@IABW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum BuildingTypes *,unsigned int,enum BuildingTypes,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T245506 = -28						; size = 4
__Vptr$245504 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Vptr$245504[ebp], eax
	mov	ecx, DWORD PTR __Vptr$245504[ebp]
	mov	DWORD PTR $T245506[ebp], ecx
	cmp	DWORD PTR $T245506[ebp], 0
	je	SHORT $LN18@Uninit_fil@2
	mov	edx, DWORD PTR $T245506[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T245506[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN14@Uninit_fil@2
$LN18@Uninit_fil@2:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_fil@2:
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_fil@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4PolicyTypes@@IW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAXPAW4PolicyTypes@@IABW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum PolicyTypes *,unsigned int,enum PolicyTypes,std::allocator<enum PolicyTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv94 = -36						; size = 4
$T245574 = -32						; size = 4
$T245569 = -28						; size = 4
__Vptr$245567 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245574[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245567[ebp], edx
	mov	eax, DWORD PTR __Vptr$245567[ebp]
	mov	DWORD PTR $T245569[ebp], eax
	cmp	DWORD PTR $T245569[ebp], 0
	je	SHORT $LN26@Uninit_cop
	mov	ecx, DWORD PTR $T245569[ebp]
	mov	edx, DWORD PTR $T245574[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T245569[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN22@Uninit_cop
$LN26@Uninit_cop:
	mov	DWORD PTR tv94[ebp], 0
$LN22@Uninit_cop:
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_const_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv94 = -36						; size = 4
$T245638 = -32						; size = 4
$T245633 = -28						; size = 4
__Vptr$245631 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN16@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN16@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245638[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245631[ebp], edx
	mov	eax, DWORD PTR __Vptr$245631[ebp]
	mov	DWORD PTR $T245633[ebp], eax
	cmp	DWORD PTR $T245633[ebp], 0
	je	SHORT $LN26@Uninit_cop@2
	mov	ecx, DWORD PTR $T245633[ebp]
	mov	edx, DWORD PTR $T245638[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T245633[ebp]
	mov	DWORD PTR tv94[ebp], ecx
	jmp	SHORT $LN22@Uninit_cop@2
$LN26@Uninit_cop@2:
	mov	DWORD PTR tv94[ebp], 0
$LN22@Uninit_cop@2:
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_const_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_const_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z
_TEXT	SEGMENT
__Cat$245662 = -3					; size = 1
$T245659 = -2						; size = 1
$T245658 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T245658[ebp], al
	mov	cl, BYTE PTR __Cat$245662[ebp]
	mov	BYTE PTR $T245659[ebp], cl
	movzx	edx, BYTE PTR $T245658[ebp]
	push	edx
	movzx	eax, BYTE PTR $T245659[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@stdext@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z
_TEXT	SEGMENT
__Cat$245670 = -3					; size = 1
$T245667 = -2						; size = 1
$T245666 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T245666[ebp], al
	mov	cl, BYTE PTR __Cat$245670[ebp]
	mov	BYTE PTR $T245667[ebp], cl
	movzx	edx, BYTE PTR $T245666[ebp]
	push	edx
	movzx	eax, BYTE PTR $T245667[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@stdext@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv143 = -36						; size = 4
$T245728 = -32						; size = 4
$T245723 = -28						; size = 4
__Vptr$245721 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN18@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN18@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245728[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245721[ebp], edx
	mov	eax, DWORD PTR __Vptr$245721[ebp]
	mov	DWORD PTR $T245723[ebp], eax
	cmp	DWORD PTR $T245723[ebp], 0
	je	SHORT $LN30@Uninit_cop@3
	mov	ecx, DWORD PTR $T245723[ebp]
	mov	edx, DWORD PTR $T245728[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T245723[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	jmp	SHORT $LN26@Uninit_cop@3
$LN30@Uninit_cop@3:
	mov	DWORD PTR tv143[ebp], 0
$LN26@Uninit_cop@3:
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@std@@PAW4BuildingTypes@@V?$allocator@W4BuildingTypes@@@2@@std@@YAPAW4BuildingTypes@@V?$_Vector_iterator@W4BuildingTypes@@V?$allocator@W4BuildingTypes@@@std@@@0@0PAW41@AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<enum BuildingTypes,std::allocator<enum BuildingTypes> >,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv143 = -36						; size = 4
$T245802 = -32						; size = 4
$T245794 = -28						; size = 4
__Vptr$245800 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN18@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN18@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR __Last$[ebp]
	sete	cl
	movzx	edx, cl
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T245802[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245800[ebp], edx
	mov	eax, DWORD PTR __Vptr$245800[ebp]
	mov	DWORD PTR $T245794[ebp], eax
	cmp	DWORD PTR $T245794[ebp], 0
	je	SHORT $LN30@Uninit_cop@4
	mov	ecx, DWORD PTR $T245794[ebp]
	mov	edx, DWORD PTR $T245802[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T245794[ebp]
	mov	DWORD PTR tv143[ebp], ecx
	jmp	SHORT $LN26@Uninit_cop@4
$LN30@Uninit_cop@4:
	mov	DWORD PTR tv143[ebp], 0
$LN26@Uninit_cop@4:
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@std@@PAW4PolicyTypes@@V?$allocator@W4PolicyTypes@@@2@@std@@YAPAW4PolicyTypes@@V?$_Vector_iterator@W4PolicyTypes@@V?$allocator@W4PolicyTypes@@@std@@@0@0PAW41@AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::_Vector_iterator<enum PolicyTypes,std::allocator<enum PolicyTypes> >,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T245844 = -28						; size = 4
__Vptr$245850 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@5
$LN5@Uninit_cop@5:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@5:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@5

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245850[ebp], ecx
	mov	edx, DWORD PTR __Vptr$245850[ebp]
	mov	DWORD PTR $T245844[ebp], edx
	cmp	DWORD PTR $T245844[ebp], 0
	je	SHORT $LN18@Uninit_cop@5
	mov	eax, DWORD PTR $T245844[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T245844[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@Uninit_cop@5
$LN18@Uninit_cop@5:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_cop@5:
	jmp	SHORT $LN5@Uninit_cop@5
$LN4@Uninit_cop@5:
	jmp	SHORT $LN10@Uninit_cop@5
__catch$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@5
$LN2@Uninit_cop@5:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@5:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@5

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@5
$LN1@Uninit_cop@5:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@5:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4BuildingTypes@@PAW41@V?$allocator@W4BuildingTypes@@@std@@@std@@YAPAW4BuildingTypes@@PAW41@00AAV?$allocator@W4BuildingTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum BuildingTypes *,enum BuildingTypes *,std::allocator<enum BuildingTypes> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv83 = -32						; size = 4
$T245893 = -28						; size = 4
__Vptr$245899 = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@6
$LN5@Uninit_cop@6:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@6:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Vptr$245899[ebp], ecx
	mov	edx, DWORD PTR __Vptr$245899[ebp]
	mov	DWORD PTR $T245893[ebp], edx
	cmp	DWORD PTR $T245893[ebp], 0
	je	SHORT $LN18@Uninit_cop@6
	mov	eax, DWORD PTR $T245893[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T245893[ebp]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN14@Uninit_cop@6
$LN18@Uninit_cop@6:
	mov	DWORD PTR tv83[ebp], 0
$LN14@Uninit_cop@6:
	jmp	SHORT $LN5@Uninit_cop@6
$LN4@Uninit_cop@6:
	jmp	SHORT $LN10@Uninit_cop@6
__catch$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@6
$LN2@Uninit_cop@6:
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Next$[ebp], ecx
$LN3@Uninit_cop@6:
	mov	edx, DWORD PTR __Next$[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@6

; 134  : 		_Al.destroy(_Next);

	jmp	SHORT $LN2@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@6:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4PolicyTypes@@PAW41@V?$allocator@W4PolicyTypes@@@std@@@std@@YAPAW4PolicyTypes@@PAW41@00AAV?$allocator@W4PolicyTypes@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum PolicyTypes *,enum PolicyTypes *,std::allocator<enum PolicyTypes> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T245928 = -8						; size = 4
_i$172577 = -4						; size = 4
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T245928[ebp], eax
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR $T245928[ebp]
	mov	DWORD PTR [eax], ecx

; 126  : 	if(iDefault == 0)

	cmp	DWORD PTR _iDefault$[ebp], 0
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	mov	edx, DWORD PTR _count$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 129  : 	}
; 130  : 	else

	jmp	SHORT $LN6@Initialize
$LN5@Initialize:

; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	mov	DWORD PTR _i$172577[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	edx, DWORD PTR _i$172577[ebp]
	add	edx, 1
	mov	DWORD PTR _i$172577[ebp], edx
$LN3@Initialize:
	mov	eax, DWORD PTR _i$172577[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jae	SHORT $LN6@Initialize

; 133  : 			pArray[i] = iDefault;

	mov	ecx, DWORD PTR _pArray$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$172577[ebp]
	mov	ecx, DWORD PTR _iDefault$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN2@Initialize
$LN6@Initialize:

; 134  : 	}
; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -132						; size = 4
tv145 = -128						; size = 4
_this$ = -124						; size = 4
$T245961 = -30						; size = 1
$T245948 = -29						; size = 1
$T245944 = -28						; size = 4
$T245937 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T245961[ebp]
	mov	DWORD PTR $T245937[ebp], eax
	lea	ecx, DWORD PTR $T245948[ebp]
	mov	DWORD PTR $T245944[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv145[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$246088 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$246088[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$246088[ebp], 0
	jbe	SHORT $LN11@Buy@5
	mov	eax, DWORD PTR __Count$246088[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@5
$LN11@Buy@5:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@5:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@5:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T246151 = -28						; size = 4
$T246150 = -24						; size = 4
$T246146 = -20						; size = 4
$T246145 = -16						; size = 4
$T246134 = -12						; size = 4
$T246133 = -8						; size = 4
__Cat$246140 = -2					; size = 1
$T246138 = -1						; size = 1
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246146[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246145[ebp], ecx
	mov	edx, DWORD PTR $T246146[ebp]
	mov	DWORD PTR $T246134[ebp], edx
	mov	eax, DWORD PTR $T246145[ebp]
	mov	DWORD PTR $T246133[ebp], eax
	mov	cl, BYTE PTR __Cat$246140[ebp]
	mov	BYTE PTR $T246138[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T246151[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T246150[ebp], eax
	mov	ecx, DWORD PTR $T246150[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T246169 = -80						; size = 28
$T246168 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T246169[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T246168[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T246168[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T246169[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246168[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T246168[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T246168[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T246169[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T246169[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T246168[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T246194 = -16						; size = 4
$T246190 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T246194[ebp], 0
	lea	eax, DWORD PTR $T246194[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246190[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T246190[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T246190[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv129 = -96						; size = 4
_this$ = -92						; size = 4
$T246287 = -64						; size = 4
$T246277 = -60						; size = 4
$T246265 = -56						; size = 4
$T246255 = -49						; size = 1
$T246254 = -48						; size = 4
__Cat$246272 = -19					; size = 1
$T246270 = -18						; size = 1
$T246269 = -17						; size = 1
$T246206 = -16						; size = 4
$T246202 = -12						; size = 4
$T246201 = -8						; size = 4
$T246200 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T246206[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN9@push_back@3
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN7@push_back@3
$LN9@push_back@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv129[ebp], eax
$LN7@push_back@3:
	mov	ecx, DWORD PTR $T246206[ebp]
	cmp	ecx, DWORD PTR tv129[ebp]
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246277[ebp], eax
	mov	ecx, DWORD PTR $T246277[ebp]
	mov	DWORD PTR $T246265[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246269[ebp], dl
	mov	al, BYTE PTR __Cat$246272[ebp]
	mov	BYTE PTR $T246270[ebp], al
	mov	cl, BYTE PTR $T246269[ebp]
	mov	BYTE PTR $T246255[ebp], cl
	mov	edx, DWORD PTR $T246265[ebp]
	mov	DWORD PTR $T246254[ebp], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR $T246254[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH
	mov	edx, 1
	shl	edx, 2
	add	edx, DWORD PTR $T246277[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@3
$LN2@push_back@3:

; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T246287[ebp], edx
	mov	eax, DWORD PTR $T246287[ebp]
	mov	DWORD PTR $T246201[ebp], eax
	mov	ecx, DWORD PTR $T246201[ebp]
	mov	DWORD PTR $T246200[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR $T246200[ebp]
	push	eax
	lea	ecx, DWORD PTR $T246202[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
$LN3@push_back@3:

; 824  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
tv77 = -32						; size = 4
_this$ = -28						; size = 4
__Tmp$246412 = -24					; size = 4
$T246390 = -20						; size = 4
$T246371 = -16						; size = 4
$T246358 = -12						; size = 4
$T246355 = -8						; size = 4
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	test	edx, edx
	jne	SHORT $LN3@insert@4
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246371[ebp], ecx
	mov	edx, DWORD PTR $T246371[ebp]
	mov	DWORD PTR $T246355[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	sub	eax, DWORD PTR $T246355[ebp]
	sar	eax, 2
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@4:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246390[ebp], edx
	mov	eax, DWORD PTR $T246390[ebp]
	mov	DWORD PTR $T246358[ebp], eax
	mov	ecx, DWORD PTR $T246358[ebp]
	mov	DWORD PTR __Tmp$246412[ebp], ecx
	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR __Tmp$246412[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Tmp$246412[ebp], ecx
	mov	edx, DWORD PTR __Tmp$246412[ebp]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2
__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0
__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$5
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$6
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
tv84 = -432						; size = 4
tv302 = -428						; size = 4
tv288 = -424						; size = 4
tv280 = -420						; size = 4
_this$ = -416						; size = 4
$T246966 = -412						; size = 4
$T246914 = -368						; size = 4
$T246902 = -364						; size = 4
$T246892 = -357						; size = 1
$T246891 = -356						; size = 4
__Cat$246909 = -327					; size = 1
$T246906 = -326						; size = 1
$T246905 = -325						; size = 1
$T246863 = -324						; size = 4
$T246855 = -320						; size = 4
$T246847 = -316						; size = 4
$T246836 = -312						; size = 4
$T246835 = -308						; size = 4
__Cat$246842 = -302					; size = 1
$T246839 = -301						; size = 1
$T246764 = -276						; size = 4
$T246745 = -272						; size = 4
$T246728 = -265						; size = 1
$T246727 = -264						; size = 4
$T246717 = -260						; size = 4
$T246716 = -256						; size = 4
__Cat$246762 = -250					; size = 1
$T246760 = -249						; size = 1
$T246759 = -248						; size = 1
__Cat$246754 = -247					; size = 1
$T246751 = -246						; size = 1
$T246750 = -245						; size = 1
$T246692 = -244						; size = 4
$T246691 = -240						; size = 4
$T246687 = -236						; size = 4
$T246686 = -232						; size = 4
$T246675 = -228						; size = 4
$T246674 = -224						; size = 4
__Cat$246682 = -218					; size = 1
$T246680 = -217						; size = 1
$T246639 = -216						; size = 4
$T246638 = -212						; size = 4
__Cat$246646 = -206					; size = 1
$T246644 = -205						; size = 1
$T246609 = -204						; size = 4
$T246608 = -200						; size = 4
__Cat$246616 = -194					; size = 1
$T246614 = -193						; size = 1
$T246589 = -192						; size = 4
$T246577 = -188						; size = 4
$T246567 = -181						; size = 1
$T246566 = -180						; size = 4
__Cat$246585 = -175					; size = 1
$T246582 = -174						; size = 1
$T246581 = -173						; size = 1
$T246554 = -172						; size = 4
$T246542 = -168						; size = 4
$T246532 = -161						; size = 1
$T246531 = -160						; size = 4
__Cat$246550 = -155					; size = 1
$T246547 = -154						; size = 1
$T246546 = -153						; size = 1
$T246519 = -152						; size = 4
$T246507 = -148						; size = 4
$T246497 = -141						; size = 1
$T246496 = -140						; size = 4
__Cat$246515 = -135					; size = 1
$T246513 = -134						; size = 1
$T246512 = -133						; size = 1
__Count$246470 = -120					; size = 4
__Count$246444 = -48					; size = 4
__Tmp$214818 = -44					; size = 4
__Oldend$214819 = -40					; size = 4
__Tmp$214808 = -36					; size = 4
__Ncopied$214795 = -32					; size = 4
__Newvec$214793 = -28					; size = 4
__Whereoff$214794 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN29@Insert_n@3
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN27@Insert_n@3
$LN29@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv280[ebp], eax
$LN27@Insert_n@3:
	mov	ecx, DWORD PTR tv280[ebp]
	mov	DWORD PTR __Capacity$[ebp], ecx

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	DWORD PTR __Count$246444[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$246444[ebp], 0
	jbe	SHORT $LN35@Insert_n@3
	mov	edx, DWORD PTR __Count$246444[ebp]
	mov	DWORD PTR tv288[ebp], edx
	jmp	SHORT $LN37@Insert_n@3
$LN35@Insert_n@3:
	mov	DWORD PTR tv288[ebp], 1
$LN37@Insert_n@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	eax, DWORD PTR tv288[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN42@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
	jmp	$LN16@Insert_n@3

; 1167 : 		else if (_Capacity < size() + _Count)

$LN42@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	DWORD PTR __Count$246470[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$246470[ebp], 0
	jbe	SHORT $LN48@Insert_n@3
	mov	ecx, DWORD PTR __Count$246470[ebp]
	mov	DWORD PTR tv302[ebp], ecx
	jmp	SHORT $LN44@Insert_n@3
$LN48@Insert_n@3:
	mov	DWORD PTR tv302[ebp], 1
$LN44@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR tv302[ebp]
	sub	eax, edx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], ecx
$LN18@Insert_n@3:
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1171 : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], edx
	jae	SHORT $LN54@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

$LN54@Insert_n@3:
	push	0
	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8
	mov	DWORD PTR __Newvec$214793[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR __Whereoff$214794[ebp], edx

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$214795[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T246519[ebp], edx
	mov	eax, DWORD PTR $T246519[ebp]
	mov	DWORD PTR $T246507[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T246512[ebp], cl
	mov	dl, BYTE PTR __Cat$246515[ebp]
	mov	BYTE PTR $T246513[ebp], dl
	mov	al, BYTE PTR $T246512[ebp]
	mov	BYTE PTR $T246497[ebp], al
	mov	ecx, DWORD PTR $T246507[ebp]
	mov	DWORD PTR $T246496[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246496[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246554[ebp], ecx
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T246542[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T246546[ebp], al
	mov	cl, BYTE PTR __Cat$246550[ebp]
	mov	BYTE PTR $T246547[ebp], cl
	mov	dl, BYTE PTR $T246546[ebp]
	mov	BYTE PTR $T246532[ebp], dl
	mov	eax, DWORD PTR $T246542[ebp]
	mov	DWORD PTR $T246531[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246531[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246554[ebp]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$214795[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$214795[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T246589[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T246577[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246581[ebp], dl
	mov	al, BYTE PTR __Cat$246585[ebp]
	mov	BYTE PTR $T246582[ebp], al
	mov	cl, BYTE PTR $T246581[ebp]
	mov	BYTE PTR $T246567[ebp], cl
	mov	edx, DWORD PTR $T246577[ebp]
	mov	DWORD PTR $T246566[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246566[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246589[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	jmp	$LN19@Insert_n@3
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	ecx, DWORD PTR __Whereoff$214794[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T246609[ebp], eax
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR $T246608[ebp], ecx
	mov	dl, BYTE PTR __Cat$246616[ebp]
	mov	BYTE PTR $T246614[ebp], dl
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$214795[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	eax, DWORD PTR __Whereoff$214794[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T246639[ebp], ecx
	mov	edx, DWORD PTR __Whereoff$214794[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T246638[ebp], ecx
	mov	dl, BYTE PTR __Cat$246646[ebp]
	mov	BYTE PTR $T246644[ebp], dl
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Newvec$214793[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN103@Insert_n@3
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1193 : 
; 1194 : 			_Count += size();

$LN103@Insert_n@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246687[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T246686[ebp], edx
	mov	eax, DWORD PTR $T246687[ebp]
	mov	DWORD PTR $T246675[ebp], eax
	mov	ecx, DWORD PTR $T246686[ebp]
	mov	DWORD PTR $T246674[ebp], ecx
	mov	dl, BYTE PTR __Cat$246682[ebp]
	mov	BYTE PTR $T246680[ebp], dl

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	mov	DWORD PTR $T246692[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T246691[ebp], ecx
	mov	edx, DWORD PTR $T246691[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$214793[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$214793[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$214793[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$214808[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246764[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T246745[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T246750[ebp], cl
	mov	dl, BYTE PTR __Cat$246754[ebp]
	mov	BYTE PTR $T246751[ebp], dl
	mov	al, BYTE PTR $T246750[ebp]
	mov	BYTE PTR $T246728[ebp], al
	mov	ecx, DWORD PTR $T246745[ebp]
	mov	DWORD PTR $T246727[ebp], ecx
	mov	edx, DWORD PTR $T246727[ebp]
	mov	DWORD PTR $T246717[ebp], edx
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246716[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T246759[ebp], cl
	mov	dl, BYTE PTR __Cat$246762[ebp]
	mov	BYTE PTR $T246760[ebp], dl
	movzx	eax, BYTE PTR $T246759[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T246760[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR $T246717[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246764[ebp]
	push	ecx
	mov	edx, DWORD PTR $T246716[ebp]
	push	edx
	call	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
	add	esp, 24					; 00000018H

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$214808[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T246847[ebp], eax
	mov	ecx, DWORD PTR $T246847[ebp]
	mov	DWORD PTR $T246836[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T246835[ebp], ecx
	mov	dl, BYTE PTR __Cat$246842[ebp]
	mov	BYTE PTR $T246839[ebp], dl

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, edx
	mov	DWORD PTR $T246863[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246855[ebp], edx
	jmp	SHORT $LN151@Insert_n@3
$LN150@Insert_n@3:
	mov	eax, DWORD PTR $T246855[ebp]
	add	eax, 4
	mov	DWORD PTR $T246855[ebp], eax
$LN151@Insert_n@3:
	mov	ecx, DWORD PTR $T246855[ebp]
	cmp	ecx, DWORD PTR $T246863[ebp]
	je	SHORT $LN147@Insert_n@3
	mov	edx, DWORD PTR $T246855[ebp]
	mov	eax, DWORD PTR __Tmp$214808[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN150@Insert_n@3
$LN147@Insert_n@3:

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$214818[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Oldend$214819[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T246914[ebp], eax
	mov	ecx, DWORD PTR $T246914[ebp]
	mov	DWORD PTR $T246902[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T246905[ebp], dl
	mov	al, BYTE PTR __Cat$246909[ebp]
	mov	BYTE PTR $T246906[ebp], al
	mov	cl, BYTE PTR $T246905[ebp]
	mov	BYTE PTR $T246892[ebp], cl
	mov	edx, DWORD PTR $T246902[ebp]
	mov	DWORD PTR $T246891[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T246891[ebp]
	push	ecx
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$214819[ebp]
	sub	ecx, eax
	push	ecx
	call	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$214819[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$214819[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T246966[ebp], ecx
	jmp	SHORT $LN186@Insert_n@3
$LN185@Insert_n@3:
	mov	edx, DWORD PTR $T246966[ebp]
	add	edx, 4
	mov	DWORD PTR $T246966[ebp], edx
$LN186@Insert_n@3:
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR $T246966[ebp], edx
	je	SHORT $LN16@Insert_n@3
	mov	eax, DWORD PTR $T246966[ebp]
	mov	ecx, DWORD PTR __Tmp$214818[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN185@Insert_n@3
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-436]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T247037 = -40						; size = 4
$T247027 = -33						; size = 1
$T247026 = -32						; size = 4
__Cat$247032 = -3					; size = 1
$T247030 = -2						; size = 1
$T247029 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR $T247037[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T247029[ebp], cl
	mov	dl, BYTE PTR __Cat$247032[ebp]
	mov	BYTE PTR $T247030[ebp], dl
	mov	al, BYTE PTR $T247029[ebp]
	mov	BYTE PTR $T247027[ebp], al
	mov	ecx, DWORD PTR $T247037[ebp]
	mov	DWORD PTR $T247026[ebp], ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T247026[ebp]
	push	ecx
	call	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ; stdext::unchecked_fill_n<int *,unsigned int,int>
	add	esp, 12					; 0000000cH

; 1255 : 		return (_Ptr + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [eax+edx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
$T247082 = -38						; size = 1
$T247081 = -37						; size = 1
$T247080 = -36						; size = 4
$T247079 = -32						; size = 4
$T247066 = -25						; size = 1
$T247065 = -24						; size = 4
$T247064 = -20						; size = 4
__Off$247075 = -16					; size = 4
__Result$247076 = -12					; size = 4
__Cat$247071 = -8					; size = 1
$T247069 = -7						; size = 1
$T247068 = -6						; size = 1
__Cat$247046 = -4					; size = 1
$T247042 = -3						; size = 1
$T247041 = -2						; size = 1
$T247040 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T247040[ebp], al
	mov	cl, BYTE PTR __Cat$247046[ebp]
	mov	BYTE PTR $T247041[ebp], cl
	mov	dl, BYTE PTR $T247040[ebp]
	mov	BYTE PTR $T247082[ebp], dl
	mov	al, BYTE PTR $T247042[ebp]
	mov	BYTE PTR $T247081[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T247080[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247079[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T247068[ebp], al
	mov	cl, BYTE PTR __Cat$247071[ebp]
	mov	BYTE PTR $T247069[ebp], cl
	mov	dl, BYTE PTR $T247068[ebp]
	mov	BYTE PTR $T247066[ebp], dl
	mov	eax, DWORD PTR $T247080[ebp]
	mov	DWORD PTR $T247065[ebp], eax
	mov	ecx, DWORD PTR $T247079[ebp]
	mov	DWORD PTR $T247064[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T247064[ebp]
	sar	edx, 2
	mov	DWORD PTR __Off$247075[ebp], edx
	mov	eax, DWORD PTR __Off$247075[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR $T247065[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$247076[ebp], ecx
	cmp	DWORD PTR __Off$247075[ebp], 0
	jle	SHORT $LN7@Unchecked_
	mov	edx, DWORD PTR __Off$247075[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T247064[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$247075[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Result$247076[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN7@Unchecked_:
	mov	eax, DWORD PTR __Result$247076[ebp]

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
$T247112 = -22						; size = 1
$T247111 = -21						; size = 1
$T247110 = -20						; size = 4
$T247101 = -13						; size = 1
$T247100 = -12						; size = 4
$T247099 = -8						; size = 4
$T247103 = -4						; size = 1
$T247086 = -2						; size = 1
$T247085 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T247085[ebp], al
	mov	cl, BYTE PTR $T247085[ebp]
	mov	BYTE PTR $T247112[ebp], cl
	mov	dl, BYTE PTR $T247086[ebp]
	mov	BYTE PTR $T247111[ebp], dl
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247110[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T247103[ebp], cl
	mov	dl, BYTE PTR $T247103[ebp]
	mov	BYTE PTR $T247101[ebp], dl
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR $T247100[ebp], eax
	mov	ecx, DWORD PTR $T247110[ebp]
	mov	DWORD PTR $T247099[ebp], ecx
	jmp	SHORT $LN9@unchecked_@3
$LN8@unchecked_@3:
	mov	edx, DWORD PTR $T247100[ebp]
	sub	edx, 1
	mov	DWORD PTR $T247100[ebp], edx
	mov	eax, DWORD PTR $T247099[ebp]
	add	eax, 4
	mov	DWORD PTR $T247099[ebp], eax
$LN9@unchecked_@3:
	cmp	DWORD PTR $T247100[ebp], 0
	jbe	SHORT $LN1@unchecked_@3
	mov	ecx, DWORD PTR $T247099[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN8@unchecked_@3
$LN1@unchecked_@3:

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
$T247129 = -21						; size = 1
$T247128 = -20						; size = 4
$T247127 = -16						; size = 4
__Result$247125 = -12					; size = 4
__Count$247124 = -8					; size = 4
__Cat$247119 = -3					; size = 1
$T247116 = -2						; size = 1
$T247115 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T247115[ebp], al
	mov	cl, BYTE PTR __Cat$247119[ebp]
	mov	BYTE PTR $T247116[ebp], cl
	mov	dl, BYTE PTR $T247115[ebp]
	mov	BYTE PTR $T247129[ebp], dl
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T247128[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T247127[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR $T247127[ebp]
	sar	edx, 2
	mov	DWORD PTR __Count$247124[ebp], edx
	mov	eax, DWORD PTR __Count$247124[ebp]
	mov	ecx, DWORD PTR $T247128[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Result$247125[ebp], edx
	cmp	DWORD PTR __Count$247124[ebp], 0
	jbe	SHORT $LN6@unchecked_@4
	mov	eax, DWORD PTR __Count$247124[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T247127[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$247124[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR $T247128[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN6@unchecked_@4:
	mov	eax, DWORD PTR __Result$247125[ebp]

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@7

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@7:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
END
