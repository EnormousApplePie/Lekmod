; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvProjectClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvProjectEntry@@6B@				; CvProjectEntry::`vftable'
PUBLIC	??0CvProjectEntry@@QAE@XZ			; CvProjectEntry::CvProjectEntry
PUBLIC	?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvProjectEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_7CvProjectEntry@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_7CvProjectEntry@@6B@ DD FLAT:?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvProjectEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvProjectEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvProjectEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvProjectEntry@@QAE@XZ$1
__ehfuncinfo$??0CvProjectEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvProjectEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvProjectEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T217967 = -20						; size = 4
$T217962 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvProjectEntry@@QAE@XZ PROC				; CvProjectEntry::CvProjectEntry, COMDAT
; _this$ = ecx

; 21   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvProjectEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvProjectEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	mov	DWORD PTR $T217962[ebp], ecx
	mov	ecx, DWORD PTR $T217962[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 336				; 00000150H
	mov	DWORD PTR $T217967[ebp], edx
	mov	ecx, DWORD PTR $T217967[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+364], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+368], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+372], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+376], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+380], 0

; 22   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvProjectEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvProjectEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvProjectEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvProjectEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvProjectEntry@@QAE@XZ ENDP				; CvProjectEntry::CvProjectEntry
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T218034 = -48						; size = 4
$T218029 = -44						; size = 4
$T218024 = -40						; size = 4
$T218019 = -36						; size = 4
$T218014 = -32						; size = 4
$T218009 = -28						; size = 4
$T218004 = -24						; size = 4
$T217999 = -20						; size = 4
$T217994 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T217994[ebp], eax
	mov	ecx, DWORD PTR $T217994[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T217999[ebp], ecx
	mov	ecx, DWORD PTR $T217999[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T218004[ebp], edx
	mov	ecx, DWORD PTR $T218004[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T218009[ebp], eax
	mov	ecx, DWORD PTR $T218009[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T218014[ebp], ecx
	mov	ecx, DWORD PTR $T218014[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T218019[ebp], edx
	mov	ecx, DWORD PTR $T218019[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T218024[ebp], eax
	mov	ecx, DWORD PTR $T218024[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T218029[ebp], ecx
	mov	ecx, DWORD PTR $T218029[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T218034[ebp], edx
	mov	ecx, DWORD PTR $T218034[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??1CvProjectEntry@@QAE@XZ			; CvProjectEntry::~CvProjectEntry
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvProjectEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvProjectEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvProjectEntry@@QAE@XZ$1
__ehfuncinfo$??1CvProjectEntry@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvProjectEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvProjectEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T218085 = -60						; size = 4
$T218080 = -56						; size = 4
$T218075 = -52						; size = 4
$T218074 = -48						; size = 4
$T218069 = -44						; size = 4
$T218068 = -40						; size = 4
$T218063 = -36						; size = 4
$T218062 = -32						; size = 4
$T218057 = -28						; size = 4
$T218056 = -24						; size = 4
$T218051 = -20						; size = 4
$T218050 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvProjectEntry@@QAE@XZ PROC				; CvProjectEntry::~CvProjectEntry, COMDAT
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvProjectEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvProjectEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 26   : 	SAFE_DELETE_ARRAY(m_piResourceQuantityRequirements);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 364				; 0000016cH
	mov	DWORD PTR $T218051[ebp], ecx
	mov	edx, DWORD PTR $T218051[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T218050[ebp], eax
	mov	ecx, DWORD PTR $T218050[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T218051[ebp]
	mov	DWORD PTR [edx], 0

; 27   : 	SAFE_DELETE_ARRAY(m_piVictoryThreshold);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 368				; 00000170H
	mov	DWORD PTR $T218057[ebp], eax
	mov	ecx, DWORD PTR $T218057[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T218056[ebp], edx
	mov	eax, DWORD PTR $T218056[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T218057[ebp]
	mov	DWORD PTR [ecx], 0

; 28   : 	SAFE_DELETE_ARRAY(m_piVictoryMinThreshold);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 372				; 00000174H
	mov	DWORD PTR $T218063[ebp], edx
	mov	eax, DWORD PTR $T218063[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T218062[ebp], ecx
	mov	edx, DWORD PTR $T218062[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T218063[ebp]
	mov	DWORD PTR [eax], 0

; 29   : 	SAFE_DELETE_ARRAY(m_piProjectsNeeded);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	mov	DWORD PTR $T218069[ebp], ecx
	mov	edx, DWORD PTR $T218069[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T218068[ebp], eax
	mov	ecx, DWORD PTR $T218068[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T218069[ebp]
	mov	DWORD PTR [edx], 0

; 30   : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 380				; 0000017cH
	mov	DWORD PTR $T218075[ebp], eax
	mov	ecx, DWORD PTR $T218075[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T218074[ebp], edx
	mov	eax, DWORD PTR $T218074[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T218075[ebp]
	mov	DWORD PTR [ecx], 0

; 31   : }

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 336				; 00000150H
	mov	DWORD PTR $T218080[ebp], edx
	mov	ecx, DWORD PTR $T218080[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 308				; 00000134H
	mov	DWORD PTR $T218085[ebp], eax
	mov	ecx, DWORD PTR $T218085[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvProjectEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvProjectEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvProjectEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvProjectEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvProjectEntry@@QAE@XZ ENDP				; CvProjectEntry::~CvProjectEntry
PUBLIC	??_C@_08HOOLGGJD@Projects?$AA@			; `string'
PUBLIC	??_C@_0BA@BIIPOANB@Project_Prereqs?$AA@		; `string'
PUBLIC	??_C@_0BC@GIDBBOLB@PrereqProjectType?$AA@	; `string'
PUBLIC	??_C@_0N@KPIMNKAH@AmountNeeded?$AA@		; `string'
PUBLIC	??_C@_0BA@JGFAIFAF@Project_Flavors?$AA@		; `string'
PUBLIC	??_C@_0N@NKCBGLHP@MinThreshold?$AA@		; `string'
PUBLIC	??_C@_09HLCHFPPJ@Threshold?$AA@			; `string'
PUBLIC	??_C@_0M@CCKEBNNI@VictoryType?$AA@		; `string'
PUBLIC	??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ		; sprintf_s<512>
PUBLIC	??_C@_0GF@EPNPBIEP@select?5VictoryType?0?5Threshold?0?5M@ ; `string'
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
PUBLIC	??_C@_09GIGMJAEO@Victories?$AA@			; `string'
PUBLIC	??_C@_09FDCBPLKG@Resources?$AA@			; `string'
PUBLIC	??_C@_0CF@FCLLDLBK@Project_ResourceQuantityRequirem@ ; `string'
PUBLIC	??_C@_0N@EPHJOCBJ@ResourceType?$AA@		; `string'
PUBLIC	??_C@_0M@NCIHBKLG@ProjectType?$AA@		; `string'
PUBLIC	??_C@_08GACJPEFO@Quantity?$AA@			; `string'
PUBLIC	??_C@_0BE@IBPDNPHF@AnyonePrereqProject?$AA@	; `string'
PUBLIC	?SetCreateSound@CvProjectEntry@@QAEXPBD@Z	; CvProjectEntry::SetCreateSound
PUBLIC	??_C@_0M@GGJKJDLL@CreateSound?$AA@		; `string'
PUBLIC	??_C@_0BE@KFCJNGGM@EveryoneSpecialUnit?$AA@	; `string'
PUBLIC	??_C@_0L@IANCLNMF@TechPrereq?$AA@		; `string'
PUBLIC	??_C@_0O@KJJJODBC@VictoryPrereq?$AA@		; `string'
PUBLIC	??_C@_0P@IHBMJAKC@MovieDefineTag?$AA@		; `string'
PUBLIC	??_C@_0M@OEHPGJBL@AllowsNukes?$AA@		; `string'
PUBLIC	??_C@_09GIAKMNAJ@Spaceship?$AA@			; `string'
PUBLIC	??_C@_0BE@LHFNFGFO@VictoryDelayPercent?$AA@	; `string'
PUBLIC	??_C@_09LDHOCFOF@TechShare?$AA@			; `string'
PUBLIC	??_C@_0BI@MKOJJECB@CultureBranchesRequired?$AA@	; `string'
PUBLIC	??_C@_0BB@DJKDCDFM@NukeInterception?$AA@	; `string'
PUBLIC	??_C@_04FICPKHNF@Cost?$AA@			; `string'
PUBLIC	??_C@_0BB@GIBJGONN@MaxTeamInstances?$AA@	; `string'
PUBLIC	??_C@_0BD@BGLLFNNG@MaxGlobalInstances?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_??1Results@Database@@UAE@XZ:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z:PROC
EXTRN	__imp_??0Results@Database@@QAE@PBD@Z:PROC
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
EXTRN	_memset:PROC
;	COMDAT ??_C@_08HOOLGGJD@Projects?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_08HOOLGGJD@Projects?$AA@ DB 'Projects', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BIIPOANB@Project_Prereqs?$AA@
CONST	SEGMENT
??_C@_0BA@BIIPOANB@Project_Prereqs?$AA@ DB 'Project_Prereqs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GIDBBOLB@PrereqProjectType?$AA@
CONST	SEGMENT
??_C@_0BC@GIDBBOLB@PrereqProjectType?$AA@ DB 'PrereqProjectType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KPIMNKAH@AmountNeeded?$AA@
CONST	SEGMENT
??_C@_0N@KPIMNKAH@AmountNeeded?$AA@ DB 'AmountNeeded', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGFAIFAF@Project_Flavors?$AA@
CONST	SEGMENT
??_C@_0BA@JGFAIFAF@Project_Flavors?$AA@ DB 'Project_Flavors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NKCBGLHP@MinThreshold?$AA@
CONST	SEGMENT
??_C@_0N@NKCBGLHP@MinThreshold?$AA@ DB 'MinThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HLCHFPPJ@Threshold?$AA@
CONST	SEGMENT
??_C@_09HLCHFPPJ@Threshold?$AA@ DB 'Threshold', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CCKEBNNI@VictoryType?$AA@
CONST	SEGMENT
??_C@_0M@CCKEBNNI@VictoryType?$AA@ DB 'VictoryType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@EPNPBIEP@select?5VictoryType?0?5Threshold?0?5M@
CONST	SEGMENT
??_C@_0GF@EPNPBIEP@select?5VictoryType?0?5Threshold?0?5M@ DB 'select Vict'
	DB	'oryType, Threshold, MinThreshold from Project_VictoryThreshol'
	DB	'ds where ProjectType = ''%s'';', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GIGMJAEO@Victories?$AA@
CONST	SEGMENT
??_C@_09GIGMJAEO@Victories?$AA@ DB 'Victories', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FDCBPLKG@Resources?$AA@
CONST	SEGMENT
??_C@_09FDCBPLKG@Resources?$AA@ DB 'Resources', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FCLLDLBK@Project_ResourceQuantityRequirem@
CONST	SEGMENT
??_C@_0CF@FCLLDLBK@Project_ResourceQuantityRequirem@ DB 'Project_Resource'
	DB	'QuantityRequirements', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
CONST	SEGMENT
??_C@_0N@EPHJOCBJ@ResourceType?$AA@ DB 'ResourceType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NCIHBKLG@ProjectType?$AA@
CONST	SEGMENT
??_C@_0M@NCIHBKLG@ProjectType?$AA@ DB 'ProjectType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GACJPEFO@Quantity?$AA@
CONST	SEGMENT
??_C@_08GACJPEFO@Quantity?$AA@ DB 'Quantity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IBPDNPHF@AnyonePrereqProject?$AA@
CONST	SEGMENT
??_C@_0BE@IBPDNPHF@AnyonePrereqProject?$AA@ DB 'AnyonePrereqProject', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGJKJDLL@CreateSound?$AA@
CONST	SEGMENT
??_C@_0M@GGJKJDLL@CreateSound?$AA@ DB 'CreateSound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KFCJNGGM@EveryoneSpecialUnit?$AA@
CONST	SEGMENT
??_C@_0BE@KFCJNGGM@EveryoneSpecialUnit?$AA@ DB 'EveryoneSpecialUnit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IANCLNMF@TechPrereq?$AA@
CONST	SEGMENT
??_C@_0L@IANCLNMF@TechPrereq?$AA@ DB 'TechPrereq', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KJJJODBC@VictoryPrereq?$AA@
CONST	SEGMENT
??_C@_0O@KJJJODBC@VictoryPrereq?$AA@ DB 'VictoryPrereq', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHBMJAKC@MovieDefineTag?$AA@
CONST	SEGMENT
??_C@_0P@IHBMJAKC@MovieDefineTag?$AA@ DB 'MovieDefineTag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEHPGJBL@AllowsNukes?$AA@
CONST	SEGMENT
??_C@_0M@OEHPGJBL@AllowsNukes?$AA@ DB 'AllowsNukes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GIAKMNAJ@Spaceship?$AA@
CONST	SEGMENT
??_C@_09GIAKMNAJ@Spaceship?$AA@ DB 'Spaceship', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LHFNFGFO@VictoryDelayPercent?$AA@
CONST	SEGMENT
??_C@_0BE@LHFNFGFO@VictoryDelayPercent?$AA@ DB 'VictoryDelayPercent', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LDHOCFOF@TechShare?$AA@
CONST	SEGMENT
??_C@_09LDHOCFOF@TechShare?$AA@ DB 'TechShare', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MKOJJECB@CultureBranchesRequired?$AA@
CONST	SEGMENT
??_C@_0BI@MKOJJECB@CultureBranchesRequired?$AA@ DB 'CultureBranchesRequir'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DJKDCDFM@NukeInterception?$AA@
CONST	SEGMENT
??_C@_0BB@DJKDCDFM@NukeInterception?$AA@ DB 'NukeInterception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FICPKHNF@Cost?$AA@
CONST	SEGMENT
??_C@_04FICPKHNF@Cost?$AA@ DB 'Cost', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GIBJGONN@MaxTeamInstances?$AA@
CONST	SEGMENT
??_C@_0BB@GIBJGONN@MaxTeamInstances?$AA@ DB 'MaxTeamInstances', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BGLLFNNG@MaxGlobalInstances?$AA@
CONST	SEGMENT
??_C@_0BD@BGLLFNNG@MaxGlobalInstances?$AA@ DB 'MaxGlobalInstances', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
__ehfuncinfo$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_this$ = -672						; size = 4
$T218168 = -668						; size = 4
$T218157 = -648						; size = 4
$T218156 = -644						; size = 4
_iMinThreshold$217160 = -640				; size = 4
_idx$217157 = -636					; size = 4
_iThreshold$217158 = -632				; size = 4
_szVictoryType$217155 = -628				; size = 4
_iNumVictories$217136 = -624				; size = 4
_kDBResults$217143 = -620				; size = 64
_szQuery$217144 = -556					; size = 512
__$ArrayPad$ = -40					; size = 4
_szTechPrereq$ = -36					; size = 4
_szCreateSound$ = -32					; size = 4
_szEveryoneSpecialUnit$ = -28				; size = 4
_szAnyonePrereqProject$ = -24				; size = 4
_szProjectType$ = -20					; size = 4
_szVictoryPrereq$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvProjectEntry::CacheResults, COMDAT
; _this$ = ecx

; 34   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 660				; 00000294H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@CacheResul

; 36   : 		return false;

	xor	al, al
	jmp	$LN5@CacheResul
$LN4@CacheResul:

; 37   : 
; 38   : 	m_iMaxGlobalInstances = kResults.GetInt("MaxGlobalInstances");

	push	OFFSET ??_C@_0BD@BGLLFNNG@MaxGlobalInstances?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], eax

; 39   : 	m_iMaxTeamInstances = kResults.GetInt("MaxTeamInstances");

	push	OFFSET ??_C@_0BB@GIBJGONN@MaxTeamInstances?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], eax

; 40   : 	m_iProductionCost = kResults.GetInt("Cost");

	push	OFFSET ??_C@_04FICPKHNF@Cost?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], eax

; 41   : 	m_iNukeInterception = kResults.GetInt("NukeInterception");

	push	OFFSET ??_C@_0BB@DJKDCDFM@NukeInterception?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], eax

; 42   : 	m_iCultureBranchesRequired = kResults.GetInt("CultureBranchesRequired");

	push	OFFSET ??_C@_0BI@MKOJJECB@CultureBranchesRequired?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax

; 43   : 	m_iTechShare = kResults.GetInt("TechShare");

	push	OFFSET ??_C@_09LDHOCFOF@TechShare?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], eax

; 44   : 	m_iVictoryDelayPercent = kResults.GetInt("VictoryDelayPercent");

	push	OFFSET ??_C@_0BE@LHFNFGFO@VictoryDelayPercent?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 45   : 
; 46   : 	m_bSpaceship = kResults.GetBool("Spaceship");

	push	OFFSET ??_C@_09GIAKMNAJ@Spaceship?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+304], al

; 47   : 	m_bAllowsNukes = kResults.GetBool("AllowsNukes");

	push	OFFSET ??_C@_0M@OEHPGJBL@AllowsNukes?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+305], al

; 48   : 
; 49   : 	m_strMovieArtDef = kResults.GetText("MovieDefineTag");

	push	OFFSET ??_C@_0P@IHBMJAKC@MovieDefineTag?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR $T218157[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 336				; 00000150H
	mov	DWORD PTR $T218156[ebp], edx
	cmp	DWORD PTR $T218157[ebp], 0
	je	SHORT $LN9@CacheResul
	mov	eax, DWORD PTR $T218157[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218156[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN10@CacheResul
$LN9@CacheResul:
	mov	ecx, DWORD PTR $T218156[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN10@CacheResul:

; 50   : 
; 51   : 	const char* szVictoryPrereq = kResults.GetText("VictoryPrereq");

	push	OFFSET ??_C@_0O@KJJJODBC@VictoryPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szVictoryPrereq$[ebp], eax

; 52   : 	m_iVictoryPrereq = GC.getInfoTypeForString(szVictoryPrereq, true);

	push	1
	mov	ecx, DWORD PTR _szVictoryPrereq$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+260], eax

; 53   : 
; 54   : 	const char* szTechPrereq = kResults.GetText("TechPrereq");

	push	OFFSET ??_C@_0L@IANCLNMF@TechPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTechPrereq$[ebp], eax

; 55   : 	m_iTechPrereq = GC.getInfoTypeForString(szTechPrereq, true);

	push	1
	mov	eax, DWORD PTR _szTechPrereq$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], eax

; 56   : 
; 57   : 	const char* szEveryoneSpecialUnit = kResults.GetText("EveryoneSpecialUnit");

	push	OFFSET ??_C@_0BE@KFCJNGGM@EveryoneSpecialUnit?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szEveryoneSpecialUnit$[ebp], eax

; 58   : 	m_iEveryoneSpecialUnit = GC.getInfoTypeForString(szEveryoneSpecialUnit, true);

	push	1
	mov	edx, DWORD PTR _szEveryoneSpecialUnit$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 59   : 
; 60   : 	const char* szCreateSound = kResults.GetText("CreateSound");

	push	OFFSET ??_C@_0M@GGJKJDLL@CreateSound?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szCreateSound$[ebp], eax

; 61   : 	SetCreateSound(szCreateSound);

	mov	edx, DWORD PTR _szCreateSound$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetCreateSound@CvProjectEntry@@QAEXPBD@Z ; CvProjectEntry::SetCreateSound

; 62   : 
; 63   : 	const char* szAnyonePrereqProject = kResults.GetText("AnyonePrereqProject");

	push	OFFSET ??_C@_0BE@IBPDNPHF@AnyonePrereqProject?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szAnyonePrereqProject$[ebp], eax

; 64   : 	m_iAnyoneProjectPrereq = GC.getInfoTypeForString(szAnyonePrereqProject, true);

	push	1
	mov	eax, DWORD PTR _szAnyonePrereqProject$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+268], eax

; 65   : 
; 66   : 	//Arrays
; 67   : 	const char* szProjectType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szProjectType$[ebp], eax

; 68   : 	kUtility.PopulateArrayByValue(m_piResourceQuantityRequirements, "Resources", "Project_ResourceQuantityRequirements", "ResourceType", "ProjectType", szProjectType, "Quantity");

	push	0
	push	0
	push	OFFSET ??_C@_08GACJPEFO@Quantity?$AA@
	mov	edx, DWORD PTR _szProjectType$[ebp]
	push	edx
	push	OFFSET ??_C@_0M@NCIHBKLG@ProjectType?$AA@
	push	OFFSET ??_C@_0N@EPHJOCBJ@ResourceType?$AA@
	push	OFFSET ??_C@_0CF@FCLLDLBK@Project_ResourceQuantityRequirem@
	push	OFFSET ??_C@_09FDCBPLKG@Resources?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 364				; 0000016cH
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 69   : 
; 70   : 	//Victory Thresholds
; 71   : 	{
; 72   : 		const int iNumVictories = kUtility.MaxRows("Victories");

	push	OFFSET ??_C@_09GIGMJAEO@Victories?$AA@
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows
	mov	DWORD PTR _iNumVictories$217136[ebp], eax

; 73   : 
; 74   : 		kUtility.InitializeArray(m_piVictoryThreshold, iNumVictories);

	push	0
	mov	ecx, DWORD PTR _iNumVictories$217136[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 368				; 00000170H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 75   : 		kUtility.InitializeArray(m_piVictoryMinThreshold, iNumVictories);

	push	0
	mov	eax, DWORD PTR _iNumVictories$217136[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray

; 76   : 
; 77   : 		Database::Results kDBResults;

	push	0
	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	call	DWORD PTR __imp_??0Results@Database@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 78   : 		char szQuery[512] = {0};

	mov	BYTE PTR _szQuery$217144[ebp], 0
	push	511					; 000001ffH
	push	0
	lea	edx, DWORD PTR _szQuery$217144[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 79   : 		sprintf_s(szQuery, "select VictoryType, Threshold, MinThreshold from Project_VictoryThresholds where ProjectType = '%s';", szProjectType);

	mov	eax, DWORD PTR _szProjectType$[ebp]
	push	eax
	push	OFFSET ??_C@_0GF@EPNPBIEP@select?5VictoryType?0?5Threshold?0?5M@
	lea	ecx, DWORD PTR _szQuery$217144[ebp]
	push	ecx
	call	??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ	; sprintf_s<512>
	add	esp, 12					; 0000000cH

; 80   : 		if(DB.Execute(kDBResults, szQuery))

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+912
	mov	DWORD PTR $T218168[ebp], edx
	push	-1
	lea	eax, DWORD PTR _szQuery$217144[ebp]
	push	eax
	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T218168[ebp]
	call	DWORD PTR __imp_?Execute@Connection@Database@@QBE_NAAVResults@2@PBDH@Z
	movzx	edx, al
	test	edx, edx
	je	$LN3@CacheResul
$LN2@CacheResul:

; 81   : 		{
; 82   : 			while(kDBResults.Step())

	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	movzx	eax, al
	test	eax, eax
	je	$LN3@CacheResul

; 83   : 			{
; 84   : 				const char* szVictoryType = kDBResults.GetText("VictoryType");

	push	OFFSET ??_C@_0M@CCKEBNNI@VictoryType?$AA@
	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szVictoryType$217155[ebp], eax

; 85   : 				const int idx = GC.getInfoTypeForString(szVictoryType, true);

	push	1
	mov	ecx, DWORD PTR _szVictoryType$217155[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _idx$217157[ebp], eax

; 86   : 
; 87   : 				const int iThreshold = kDBResults.GetInt("Threshold");

	push	OFFSET ??_C@_09HLCHFPPJ@Threshold?$AA@
	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR _iThreshold$217158[ebp], eax

; 88   : 				const int iMinThreshold = kDBResults.GetInt("MinThreshold");

	push	OFFSET ??_C@_0N@NKCBGLHP@MinThreshold?$AA@
	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	DWORD PTR _iMinThreshold$217160[ebp], eax

; 89   : 
; 90   : 				m_piVictoryThreshold[idx] = iThreshold;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+368]
	mov	ecx, DWORD PTR _idx$217157[ebp]
	mov	edx, DWORD PTR _iThreshold$217158[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 91   : 				m_piVictoryMinThreshold[idx] = iMinThreshold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+372]
	mov	edx, DWORD PTR _idx$217157[ebp]
	mov	eax, DWORD PTR _iMinThreshold$217160[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 92   : 			}

	jmp	$LN2@CacheResul
$LN3@CacheResul:

; 93   : 		}
; 94   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	call	DWORD PTR __imp_??1Results@Database@@UAE@XZ

; 95   : 
; 96   : 	kUtility.SetFlavors(m_piFlavorValue, "Project_Flavors", "ProjectType", szProjectType);

	push	0
	mov	ecx, DWORD PTR _szProjectType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0M@NCIHBKLG@ProjectType?$AA@
	push	OFFSET ??_C@_0BA@JGFAIFAF@Project_Flavors?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 380				; 0000017cH
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 97   : 	kUtility.PopulateArrayByValue(m_piProjectsNeeded, "Projects", "Project_Prereqs", "PrereqProjectType", "ProjectType", szProjectType, "AmountNeeded");

	push	0
	push	0
	push	OFFSET ??_C@_0N@KPIMNKAH@AmountNeeded?$AA@
	mov	eax, DWORD PTR _szProjectType$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@NCIHBKLG@ProjectType?$AA@
	push	OFFSET ??_C@_0BC@GIDBBOLB@PrereqProjectType?$AA@
	push	OFFSET ??_C@_0BA@BIIPOANB@Project_Prereqs?$AA@
	push	OFFSET ??_C@_08HOOLGGJD@Projects?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 376				; 00000178H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 98   : 
; 99   : 	return true;

	mov	al, 1
$LN5@CacheResul:

; 100  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _kDBResults$217143[ebp]
	jmp	DWORD PTR __imp_??1Results@Database@@UAE@XZ
__ehhandler$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-664]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvProjectEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvProjectEntry::CacheResults
PUBLIC	?GetVictoryPrereq@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetVictoryPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetVictoryPrereq@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVictoryPrereq@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetVictoryPrereq, COMDAT
; _this$ = ecx

; 104  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 	return m_iVictoryPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+260]

; 106  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetVictoryPrereq@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetVictoryPrereq
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvProjectEntry@@QBEHXZ		; CvProjectEntry::GetTechPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetTechPrereq@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechPrereq@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 110  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+264]

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechPrereq@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetAnyoneProjectPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetAnyoneProjectPrereq, COMDAT
; _this$ = ecx

; 116  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 	return m_iAnyoneProjectPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 118  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAnyoneProjectPrereq@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetAnyoneProjectPrereq
_TEXT	ENDS
PUBLIC	?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z	; CvProjectEntry::SetAnyoneProjectPrereq
; Function compile flags: /Odtp
;	COMDAT ?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z PROC	; CvProjectEntry::SetAnyoneProjectPrereq, COMDAT
; _this$ = ecx

; 122  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 	m_iAnyoneProjectPrereq = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+268], ecx

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetAnyoneProjectPrereq@CvProjectEntry@@QAEXH@Z ENDP	; CvProjectEntry::SetAnyoneProjectPrereq
_TEXT	ENDS
PUBLIC	?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetMaxGlobalInstances
; Function compile flags: /Odtp
;	COMDAT ?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetMaxGlobalInstances, COMDAT
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 	return m_iMaxGlobalInstances;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxGlobalInstances@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetMaxGlobalInstances
_TEXT	ENDS
PUBLIC	?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetMaxTeamInstances
; Function compile flags: /Odtp
;	COMDAT ?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetMaxTeamInstances, COMDAT
; _this$ = ecx

; 134  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 135  : 	return m_iMaxTeamInstances;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+276]

; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxTeamInstances@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetMaxTeamInstances
_TEXT	ENDS
PUBLIC	?GetProductionCost@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetProductionCost
; Function compile flags: /Odtp
;	COMDAT ?GetProductionCost@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProductionCost@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetProductionCost, COMDAT
; _this$ = ecx

; 140  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 	return m_iProductionCost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProductionCost@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetProductionCost
_TEXT	ENDS
PUBLIC	?GetNukeInterception@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetNukeInterception
; Function compile flags: /Odtp
;	COMDAT ?GetNukeInterception@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNukeInterception@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetNukeInterception, COMDAT
; _this$ = ecx

; 146  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 	return m_iNukeInterception;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNukeInterception@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetNukeInterception
_TEXT	ENDS
PUBLIC	?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ ; CvProjectEntry::GetCultureBranchesRequired
; Function compile flags: /Odtp
;	COMDAT ?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetCultureBranchesRequired, COMDAT
; _this$ = ecx

; 152  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 	return m_iCultureBranchesRequired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCultureBranchesRequired@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetCultureBranchesRequired
_TEXT	ENDS
PUBLIC	?GetTechShare@CvProjectEntry@@QBEHXZ		; CvProjectEntry::GetTechShare
; Function compile flags: /Odtp
;	COMDAT ?GetTechShare@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechShare@CvProjectEntry@@QBEHXZ PROC		; CvProjectEntry::GetTechShare, COMDAT
; _this$ = ecx

; 158  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	return m_iTechShare;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 160  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechShare@CvProjectEntry@@QBEHXZ ENDP		; CvProjectEntry::GetTechShare
_TEXT	ENDS
PUBLIC	?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetEveryoneSpecialUnit
; Function compile flags: /Odtp
;	COMDAT ?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetEveryoneSpecialUnit, COMDAT
; _this$ = ecx

; 164  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 	return m_iEveryoneSpecialUnit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEveryoneSpecialUnit@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetEveryoneSpecialUnit
_TEXT	ENDS
PUBLIC	?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ	; CvProjectEntry::GetVictoryDelayPercent
; Function compile flags: /Odtp
;	COMDAT ?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ PROC	; CvProjectEntry::GetVictoryDelayPercent, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	return m_iVictoryDelayPercent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetVictoryDelayPercent@CvProjectEntry@@QBEHXZ ENDP	; CvProjectEntry::GetVictoryDelayPercent
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvProjectEntry@@QBEHH@Z		; CvProjectEntry::GetFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetFlavorValue@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T218205 = -4						; size = 4
_i$ = 8							; size = 4
?GetFlavorValue@CvProjectEntry@@QBEHH@Z PROC		; CvProjectEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 176  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 178  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 179  : 
; 180  : 	if(i > -1 && i < GC.getNumFlavorTypes() && m_piFlavorValue)

	cmp	DWORD PTR _i$[ebp], -1
	jle	SHORT $LN1@GetFlavorV
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T218205[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR $T218205[ebp]
	jge	SHORT $LN1@GetFlavorV
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+380], 0
	je	SHORT $LN1@GetFlavorV

; 181  : 	{
; 182  : 		return  m_piFlavorValue[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+380]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@GetFlavorV
$LN1@GetFlavorV:

; 183  : 	}
; 184  : 
; 185  : 	return 0;

	xor	eax, eax
$LN2@GetFlavorV:

; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetFlavorValue@CvProjectEntry@@QBEHH@Z ENDP		; CvProjectEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?IsSpaceship@CvProjectEntry@@QBE_NXZ		; CvProjectEntry::IsSpaceship
; Function compile flags: /Odtp
;	COMDAT ?IsSpaceship@CvProjectEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSpaceship@CvProjectEntry@@QBE_NXZ PROC		; CvProjectEntry::IsSpaceship, COMDAT
; _this$ = ecx

; 190  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 	return m_bSpaceship;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+304]

; 192  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSpaceship@CvProjectEntry@@QBE_NXZ ENDP		; CvProjectEntry::IsSpaceship
_TEXT	ENDS
PUBLIC	?IsAllowsNukes@CvProjectEntry@@QBE_NXZ		; CvProjectEntry::IsAllowsNukes
; Function compile flags: /Odtp
;	COMDAT ?IsAllowsNukes@CvProjectEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowsNukes@CvProjectEntry@@QBE_NXZ PROC		; CvProjectEntry::IsAllowsNukes, COMDAT
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 197  : 	return m_bAllowsNukes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+305]

; 198  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAllowsNukes@CvProjectEntry@@QBE_NXZ ENDP		; CvProjectEntry::IsAllowsNukes
_TEXT	ENDS
PUBLIC	?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ	; CvProjectEntry::GetMovieArtDef
; Function compile flags: /Odtp
;	COMDAT ?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ PROC		; CvProjectEntry::GetMovieArtDef, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	return m_strMovieArtDef;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMovieArtDef@CvProjectEntry@@QBEPBDXZ ENDP		; CvProjectEntry::GetMovieArtDef
_TEXT	ENDS
PUBLIC	?GetCreateSound@CvProjectEntry@@QBEPBDXZ	; CvProjectEntry::GetCreateSound
; Function compile flags: /Odtp
;	COMDAT ?GetCreateSound@CvProjectEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCreateSound@CvProjectEntry@@QBEPBDXZ PROC		; CvProjectEntry::GetCreateSound, COMDAT
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 	return m_strCreateSound;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCreateSound@CvProjectEntry@@QBEPBDXZ ENDP		; CvProjectEntry::GetCreateSound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetCreateSound@CvProjectEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T218227 = -4						; size = 4
_szVal$ = 8						; size = 4
?SetCreateSound@CvProjectEntry@@QAEXPBD@Z PROC		; CvProjectEntry::SetCreateSound, COMDAT
; _this$ = ecx

; 214  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 	m_strCreateSound = szVal;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 308				; 00000134H
	mov	DWORD PTR $T218227[ebp], eax
	cmp	DWORD PTR _szVal$[ebp], 0
	je	SHORT $LN4@SetCreateS
	mov	ecx, DWORD PTR _szVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T218227[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN1@SetCreateS
$LN4@SetCreateS:
	mov	ecx, DWORD PTR $T218227[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN1@SetCreateS:

; 216  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCreateSound@CvProjectEntry@@QAEXPBD@Z ENDP		; CvProjectEntry::SetCreateSound
_TEXT	ENDS
PUBLIC	?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetResourceQuantityRequirement
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
; Function compile flags: /Odtp
;	COMDAT ?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z PROC ; CvProjectEntry::GetResourceQuantityRequirement, COMDAT
; _this$ = ecx

; 229  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 	CvAssertMsg(i < GC.getNumResourceInfos(), "Index out of bounds");
; 231  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 232  : 
; 233  : 	if(i > -1 && i < GC.getNumResourceInfos() && m_piResourceQuantityRequirements)

	cmp	DWORD PTR _i$[ebp], -1
	jle	SHORT $LN1@GetResourc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN1@GetResourc
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+364], 0
	je	SHORT $LN1@GetResourc

; 234  : #endif
; 235  : 	{
; 236  : 		return  m_piResourceQuantityRequirements[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+364]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2@GetResourc
$LN1@GetResourc:

; 237  : 	}
; 238  : 
; 239  : 	return -1;

	or	eax, -1
$LN2@GetResourc:

; 240  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetResourceQuantityRequirement@CvProjectEntry@@QBEHH@Z ENDP ; CvProjectEntry::GetResourceQuantityRequirement
_TEXT	ENDS
PUBLIC	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z	; CvProjectEntry::GetVictoryThreshold
EXTRN	?getNumVictoryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumVictoryInfos
; Function compile flags: /Odtp
;	COMDAT ?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z PROC	; CvProjectEntry::GetVictoryThreshold, COMDAT
; _this$ = ecx

; 251  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 	CvAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
; 253  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 254  : 
; 255  : 	if(i > -1 && i < GC.getNumVictoryInfos() && m_piVictoryThreshold)

	cmp	DWORD PTR _i$[ebp], -1
	jle	SHORT $LN1@GetVictory
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN1@GetVictory
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+368], 0
	je	SHORT $LN1@GetVictory

; 256  : #endif
; 257  : 	{
; 258  : 		return  m_piVictoryThreshold[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+368]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2@GetVictory
$LN1@GetVictory:

; 259  : 	}
; 260  : 
; 261  : 	return -1;

	or	eax, -1
$LN2@GetVictory:

; 262  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ENDP	; CvProjectEntry::GetVictoryThreshold
_TEXT	ENDS
PUBLIC	?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z	; CvProjectEntry::GetVictoryMinThreshold
; Function compile flags: /Odtp
;	COMDAT ?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z PROC	; CvProjectEntry::GetVictoryMinThreshold, COMDAT
; _this$ = ecx

; 273  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	CvAssertMsg(i < GC.getNumVictoryInfos(), "Index out of bounds");
; 275  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 276  : 
; 277  : 	if(i > -1 && i < GC.getNumVictoryInfos())

	cmp	DWORD PTR _i$[ebp], -1
	jle	SHORT $LN2@GetVictory@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumVictoryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumVictoryInfos
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN2@GetVictory@2

; 278  : #endif
; 279  : 	{
; 280  : 		if(m_piVictoryMinThreshold && m_piVictoryMinThreshold[i] != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+372], 0
	je	SHORT $LN1@GetVictory@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+372]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN1@GetVictory@2

; 281  : 		{
; 282  : 			return m_piVictoryMinThreshold[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+372]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN3@GetVictory@2
$LN1@GetVictory@2:

; 283  : 		}
; 284  : 
; 285  : 		return GetVictoryThreshold(i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVictoryThreshold@CvProjectEntry@@QBEHH@Z ; CvProjectEntry::GetVictoryThreshold
	jmp	SHORT $LN3@GetVictory@2
$LN2@GetVictory@2:

; 286  : 	}
; 287  : 
; 288  : 	return 0;

	xor	eax, eax
$LN3@GetVictory@2:

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetVictoryMinThreshold@CvProjectEntry@@QBEHH@Z ENDP	; CvProjectEntry::GetVictoryMinThreshold
_TEXT	ENDS
PUBLIC	?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z	; CvProjectEntry::GetProjectsNeeded
EXTRN	?getNumProjectInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumProjectInfos
; Function compile flags: /Odtp
;	COMDAT ?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z PROC		; CvProjectEntry::GetProjectsNeeded, COMDAT
; _this$ = ecx

; 300  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 	CvAssertMsg(i < GC.getNumProjectInfos(), "Index out of bounds");
; 302  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 303  : 
; 304  : 	if(i > -1 && i < GC.getNumProjectInfos() && m_piProjectsNeeded)

	cmp	DWORD PTR _i$[ebp], -1
	jle	SHORT $LN1@GetProject
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumProjectInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumProjectInfos
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $LN1@GetProject
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+376], 0
	je	SHORT $LN1@GetProject

; 305  : #endif
; 306  : 	{
; 307  : 		return m_piProjectsNeeded[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+376]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN2@GetProject
$LN1@GetProject:

; 308  : 	}
; 309  : 
; 310  : 	return 0;

	xor	eax, eax
$LN2@GetProject:

; 311  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetProjectsNeeded@CvProjectEntry@@QBEHH@Z ENDP		; CvProjectEntry::GetProjectsNeeded
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Buy
PUBLIC	??0CvProjectXMLEntries@@QAE@XZ			; CvProjectXMLEntries::CvProjectXMLEntries
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvProjectXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvProjectXMLEntries@@QAE@XZ$1
__ehfuncinfo$??0CvProjectXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvProjectXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvProjectXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T218269 = -30						; size = 1
$T218256 = -29						; size = 1
$T218252 = -28						; size = 4
$T218245 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvProjectXMLEntries@@QAE@XZ PROC			; CvProjectXMLEntries::CvProjectXMLEntries, COMDAT
; _this$ = ecx

; 318  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvProjectXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T218269[ebp]
	mov	DWORD PTR $T218245[ebp], eax
	lea	ecx, DWORD PTR $T218256[ebp]
	mov	DWORD PTR $T218252[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 319  : 
; 320  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvProjectXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvProjectXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvProjectXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvProjectXMLEntries@@QAE@XZ ENDP			; CvProjectXMLEntries::CvProjectXMLEntries
PUBLIC	??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvProjectXMLEntries@@QAEXXZ	; CvProjectXMLEntries::DeleteArray
PUBLIC	??1CvProjectXMLEntries@@QAE@XZ			; CvProjectXMLEntries::~CvProjectXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvProjectXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvProjectXMLEntries@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvProjectXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvProjectXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvProjectXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvprojectclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvProjectXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvProjectXMLEntries@@QAE@XZ PROC			; CvProjectXMLEntries::~CvProjectXMLEntries, COMDAT
; _this$ = ecx

; 324  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvProjectXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 325  : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvProjectXMLEntries@@QAEXXZ ; CvProjectXMLEntries::DeleteArray

; 326  : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvProjectXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
__unwindfunclet$??1CvProjectXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvProjectXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvProjectXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvProjectXMLEntries@@QAE@XZ ENDP			; CvProjectXMLEntries::~CvProjectXMLEntries
PUBLIC	?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ; CvProjectXMLEntries::GetProjectEntries
; Function compile flags: /Odtp
;	COMDAT ?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ PROC ; CvProjectXMLEntries::GetProjectEntries, COMDAT
; _this$ = ecx

; 330  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 	return m_paProjectEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProjectEntries@CvProjectXMLEntries@@QAEAAV?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@XZ ENDP ; CvProjectXMLEntries::GetProjectEntries
_TEXT	ENDS
PUBLIC	?GetNumProjects@CvProjectXMLEntries@@QAEHXZ	; CvProjectXMLEntries::GetNumProjects
; Function compile flags: /Odtp
;	COMDAT ?GetNumProjects@CvProjectXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumProjects@CvProjectXMLEntries@@QAEHXZ PROC	; CvProjectXMLEntries::GetNumProjects, COMDAT
; _this$ = ecx

; 340  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 	return m_paProjectEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 342  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumProjects@CvProjectXMLEntries@@QAEHXZ ENDP	; CvProjectXMLEntries::GetNumProjects
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::erase
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvProjectXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv143 = -116						; size = 4
_this$ = -112						; size = 4
$T218512 = -56						; size = 4
$T218496 = -52						; size = 4
$T218617 = -48						; size = 4
$T218616 = -44						; size = 4
$T218615 = -40						; size = 4
$T218614 = -36						; size = 4
$T218613 = -32						; size = 4
$T218480 = -28						; size = 4
$T218473 = -24						; size = 4
$T218472 = -20						; size = 4
$T218439 = -16						; size = 4
$T218415 = -12						; size = 4
$T218405 = -8						; size = 4
_it$217418 = -4						; size = 4
?DeleteArray@CvProjectXMLEntries@@QAEXXZ PROC		; CvProjectXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 346  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 347  : 	for(std::vector<CvProjectEntry*>::iterator it = m_paProjectEntries.begin(); it != m_paProjectEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T218415[ebp], ecx
	mov	edx, DWORD PTR $T218415[ebp]
	mov	DWORD PTR _it$217418[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$217418[ebp]
	add	eax, 4
	mov	DWORD PTR _it$217418[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218439[ebp], edx
	mov	eax, DWORD PTR $T218439[ebp]
	mov	DWORD PTR $T218405[ebp], eax
	mov	ecx, DWORD PTR _it$217418[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T218405[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 348  : 	{
; 349  : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$217418[ebp]
	mov	DWORD PTR $T218480[ebp], edx
	mov	eax, DWORD PTR $T218480[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T218473[ebp], ecx
	mov	edx, DWORD PTR $T218473[ebp]
	mov	DWORD PTR $T218472[ebp], edx
	cmp	DWORD PTR $T218472[ebp], 0
	je	SHORT $LN32@DeleteArra
	mov	ecx, DWORD PTR $T218472[ebp]
	call	??1CvProjectEntry@@QAE@XZ		; CvProjectEntry::~CvProjectEntry
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN35@DeleteArra
	mov	ecx, DWORD PTR $T218472[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN35@DeleteArra:
	mov	edx, DWORD PTR $T218472[ebp]
	mov	DWORD PTR tv143[ebp], edx
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv143[ebp], 0
$LN33@DeleteArra:
	mov	eax, DWORD PTR $T218480[ebp]
	mov	DWORD PTR [eax], 0

; 350  : 	}

	jmp	$LN2@DeleteArra
$LN1@DeleteArra:

; 351  : 
; 352  : 	m_paProjectEntries.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218496[ebp], edx
	mov	eax, DWORD PTR $T218496[ebp]
	mov	DWORD PTR $T218614[ebp], eax
	mov	ecx, DWORD PTR $T218614[ebp]
	mov	DWORD PTR $T218613[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218512[ebp], eax
	mov	ecx, DWORD PTR $T218512[ebp]
	mov	DWORD PTR $T218616[ebp], ecx
	mov	edx, DWORD PTR $T218616[ebp]
	mov	DWORD PTR $T218615[ebp], edx
	mov	eax, DWORD PTR $T218613[ebp]
	push	eax
	mov	ecx, DWORD PTR $T218615[ebp]
	push	ecx
	lea	edx, DWORD PTR $T218617[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::erase

; 353  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvProjectXMLEntries@@QAEXXZ ENDP		; CvProjectXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ; CvProjectXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z PROC ; CvProjectXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 361  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 	return m_paProjectEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 363  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvProjectXMLEntries@@QAEPAVCvProjectEntry@@H@Z ENDP ; CvProjectXMLEntries::GetEntry
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >::~_Vector_val<CvProjectEntry *,std::allocator<CvProjectEntry *> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvProjectEntry * *,CvProjectEntry * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T218789 = -52						; size = 4
$T218778 = -48						; size = 4
$T218777 = -44						; size = 4
__Cat$218785 = -40					; size = 1
$T218783 = -39						; size = 1
__Ptr$217482 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvProjectEntry * *,CvProjectEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$217482[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218789[ebp], edx
	mov	eax, DWORD PTR $T218789[ebp]
	mov	DWORD PTR $T218778[ebp], eax
	mov	ecx, DWORD PTR __Ptr$217482[ebp]
	mov	DWORD PTR $T218777[ebp], ecx
	mov	dl, BYTE PTR __Cat$218785[ebp]
	mov	BYTE PTR $T218783[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$217482[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@2@0@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z ; std::_Allocate<CvProjectEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$218804 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$218804[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$218804[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$218804[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z ; std::_Allocate<CvProjectEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T218870 = -28						; size = 4
$T218869 = -24						; size = 4
$T218865 = -20						; size = 4
$T218864 = -16						; size = 4
$T218853 = -12						; size = 4
$T218852 = -8						; size = 4
__Cat$218860 = -2					; size = 1
$T218858 = -1						; size = 1
?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T218865[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T218864[ebp], ecx
	mov	edx, DWORD PTR $T218865[ebp]
	mov	DWORD PTR $T218853[ebp], edx
	mov	eax, DWORD PTR $T218864[ebp]
	mov	DWORD PTR $T218852[ebp], eax
	mov	cl, BYTE PTR __Cat$218860[ebp]
	mov	BYTE PTR $T218858[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T218870[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T218869[ebp], eax
	mov	ecx, DWORD PTR $T218869[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T218874 = -80						; size = 28
$T218873 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T218874[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T218873[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T218873[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T218874[ebp]
	push	eax
	lea	ecx, DWORD PTR $T218873[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T218873[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T218873[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T218874[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T218874[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T218873[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvProjectEntry@@V?$allocator@PAVCvProjectEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvProjectEntry *,std::allocator<CvProjectEntry *> >::_Xlen
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ PROC		; sprintf_s<512>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	512					; 00000200H
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
??$sprintf_s@$0CAA@@@YAHAAY0CAA@DPBDZZ ENDP		; sprintf_s<512>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T218917 = -26						; size = 1
$T218916 = -25						; size = 1
$T218915 = -24						; size = 4
$T218914 = -20						; size = 4
__Off$218910 = -16					; size = 4
__Result$218911 = -12					; size = 4
__Cat$218902 = -4					; size = 1
$T218899 = -3						; size = 1
$T218898 = -2						; size = 1
$T218897 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvProjectEntry * *,CvProjectEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T218897[ebp], al
	mov	cl, BYTE PTR __Cat$218902[ebp]
	mov	BYTE PTR $T218898[ebp], cl
	mov	dl, BYTE PTR $T218897[ebp]
	mov	BYTE PTR $T218917[ebp], dl
	mov	al, BYTE PTR $T218899[ebp]
	mov	BYTE PTR $T218916[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T218915[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T218914[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T218914[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$218910[ebp], eax
	mov	ecx, DWORD PTR __Off$218910[ebp]
	mov	edx, DWORD PTR $T218915[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$218911[ebp], eax
	cmp	DWORD PTR __Off$218910[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$218910[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T218914[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$218910[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T218915[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$218911[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvProjectEntry@@PAPAV1@@stdext@@YAPAPAVCvProjectEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvProjectEntry * *,CvProjectEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T218924 = -16						; size = 4
$T218920 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvProjectEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T218924[ebp], 0
	lea	eax, DWORD PTR $T218924[ebp]
	push	eax
	lea	ecx, DWORD PTR $T218920[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T218920[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T218920[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvProjectEntry@@@std@@YAPAPAVCvProjectEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvProjectEntry *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T218969 = -8						; size = 4
_i$172577 = -4						; size = 4
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _count$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T218969[ebp], eax
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR $T218969[ebp]
	mov	DWORD PTR [eax], ecx

; 126  : 	if(iDefault == 0)

	cmp	DWORD PTR _iDefault$[ebp], 0
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	mov	edx, DWORD PTR _count$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _pArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 129  : 	}
; 130  : 	else

	jmp	SHORT $LN6@Initialize
$LN5@Initialize:

; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	mov	DWORD PTR _i$172577[ebp], 0
	jmp	SHORT $LN3@Initialize
$LN2@Initialize:
	mov	edx, DWORD PTR _i$172577[ebp]
	add	edx, 1
	mov	DWORD PTR _i$172577[ebp], edx
$LN3@Initialize:
	mov	eax, DWORD PTR _i$172577[ebp]
	cmp	eax, DWORD PTR _count$[ebp]
	jae	SHORT $LN6@Initialize

; 133  : 			pArray[i] = iDefault;

	mov	ecx, DWORD PTR _pArray$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$172577[ebp]
	mov	ecx, DWORD PTR _iDefault$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	jmp	SHORT $LN2@Initialize
$LN6@Initialize:

; 134  : 	}
; 135  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
