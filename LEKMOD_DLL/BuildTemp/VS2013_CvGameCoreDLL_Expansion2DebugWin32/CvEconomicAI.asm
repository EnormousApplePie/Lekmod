; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvEconomicAI.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvEconomicAIStrategyXMLEntry@@6B@		; CvEconomicAIStrategyXMLEntry::`vftable'
PUBLIC	??0CvEconomicAIStrategyXMLEntry@@QAE@XZ		; CvEconomicAIStrategyXMLEntry::CvEconomicAIStrategyXMLEntry
PUBLIC	?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvEconomicAIStrategyXMLEntry::CacheResults
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
EXTRN	??_ECvEconomicAIStrategyXMLEntry@@UAEPAXI@Z:PROC ; CvEconomicAIStrategyXMLEntry::`vector deleting destructor'
;	COMDAT ??_7CvEconomicAIStrategyXMLEntry@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_7CvEconomicAIStrategyXMLEntry@@6B@ DD FLAT:?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvEconomicAIStrategyXMLEntry::`vftable'
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
	DD	FLAT:??_ECvEconomicAIStrategyXMLEntry@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ$0
__ehfuncinfo$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T230800 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEconomicAIStrategyXMLEntry@@QAE@XZ PROC		; CvEconomicAIStrategyXMLEntry::CvEconomicAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 43   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvEconomicAIStrategyXMLEntry@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+260], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+264], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+268], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+276], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+280], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+288], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 304				; 00000130H
	mov	DWORD PTR $T230800[ebp], eax
	mov	ecx, DWORD PTR $T230800[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], 1

; 44   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvEconomicAIStrategyXMLEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEconomicAIStrategyXMLEntry@@QAE@XZ ENDP		; CvEconomicAIStrategyXMLEntry::CvEconomicAIStrategyXMLEntry
PUBLIC	??1CvEconomicAIStrategyXMLEntry@@UAE@XZ		; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvEconomicAIStrategyXMLEntry@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvEconomicAIStrategyXMLEntry@@UAEPAXI@Z PROC	; CvEconomicAIStrategyXMLEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvEconomicAIStrategyXMLEntry@@UAE@XZ	; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvEconomicAIStrategyXMLEntry@@UAEPAXI@Z ENDP	; CvEconomicAIStrategyXMLEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T230869 = -48						; size = 4
$T230864 = -44						; size = 4
$T230859 = -40						; size = 4
$T230854 = -36						; size = 4
$T230849 = -32						; size = 4
$T230844 = -28						; size = 4
$T230839 = -24						; size = 4
$T230834 = -20						; size = 4
$T230829 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 232				; 000000e8H
	mov	DWORD PTR $T230829[ebp], eax
	mov	ecx, DWORD PTR $T230829[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	mov	DWORD PTR $T230834[ebp], ecx
	mov	ecx, DWORD PTR $T230834[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 176				; 000000b0H
	mov	DWORD PTR $T230839[ebp], edx
	mov	ecx, DWORD PTR $T230839[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 148				; 00000094H
	mov	DWORD PTR $T230844[ebp], eax
	mov	ecx, DWORD PTR $T230844[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	mov	DWORD PTR $T230849[ebp], ecx
	mov	ecx, DWORD PTR $T230849[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR $T230854[ebp], edx
	mov	ecx, DWORD PTR $T230854[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T230859[ebp], eax
	mov	ecx, DWORD PTR $T230859[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR $T230864[ebp], ecx
	mov	ecx, DWORD PTR $T230864[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	DWORD PTR $T230869[ebp], edx
	mov	ecx, DWORD PTR $T230869[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ$0
__ehfuncinfo$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T230902 = -40						; size = 4
$T230897 = -36						; size = 4
$T230895 = -32						; size = 4
$T230891 = -28						; size = 4
$T230889 = -24						; size = 4
$T230885 = -20						; size = 4
$T230883 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEconomicAIStrategyXMLEntry@@UAE@XZ PROC		; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry, COMDAT
; _this$ = ecx

; 47   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvEconomicAIStrategyXMLEntry@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 48   : 	SAFE_DELETE_ARRAY(m_piPlayerFlavorValue);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	mov	DWORD PTR $T230885[ebp], ecx
	mov	edx, DWORD PTR $T230885[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T230883[ebp], eax
	mov	ecx, DWORD PTR $T230883[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T230885[ebp]
	mov	DWORD PTR [edx], 0

; 49   : 	SAFE_DELETE_ARRAY(m_piCityFlavorValue);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 264				; 00000108H
	mov	DWORD PTR $T230891[ebp], eax
	mov	ecx, DWORD PTR $T230891[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T230889[ebp], edx
	mov	eax, DWORD PTR $T230889[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T230891[ebp]
	mov	DWORD PTR [ecx], 0

; 50   : 	SAFE_DELETE_ARRAY(m_piPersonalityFlavorThresholdMod);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 272				; 00000110H
	mov	DWORD PTR $T230897[ebp], edx
	mov	eax, DWORD PTR $T230897[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T230895[ebp], ecx
	mov	edx, DWORD PTR $T230895[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T230897[ebp]
	mov	DWORD PTR [eax], 0

; 51   : }

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 304				; 00000130H
	mov	DWORD PTR $T230902[ebp], ecx
	mov	ecx, DWORD PTR $T230902[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__ehhandler$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvEconomicAIStrategyXMLEntry@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEconomicAIStrategyXMLEntry@@UAE@XZ ENDP		; CvEconomicAIStrategyXMLEntry::~CvEconomicAIStrategyXMLEntry
PUBLIC	??_C@_0DC@GLMFJHHA@AIEconomicStrategy_PersonalityFl@ ; `string'
PUBLIC	??_C@_0CA@JACMPKOA@AIEconomicStrategy_City_Flavors?$AA@ ; `string'
PUBLIC	??_C@_0CC@HBNMCKMO@AIEconomicStrategy_Player_Flavor@ ; `string'
PUBLIC	??_C@_0BH@NCAFLNII@AIEconomicStrategyType?$AA@	; `string'
PUBLIC	??_C@_0N@COMAJFAF@TechObsolete?$AA@		; `string'
PUBLIC	??_C@_0L@IANCLNMF@TechPrereq?$AA@		; `string'
PUBLIC	??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@ ; `string'
PUBLIC	??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@		; `string'
PUBLIC	??_C@_07IMKJABN@SCIENCE?$AA@			; `string'
PUBLIC	??_C@_07OLAKHONA@FOREIGN?$AA@			; `string'
PUBLIC	??_C@_08LKDCODGK@ECONOMIC?$AA@			; `string'
PUBLIC	??_C@_08EBHPNIPO@MILITARY?$AA@			; `string'
PUBLIC	??_C@_07GOECOJOI@Advisor?$AA@			; `string'
PUBLIC	??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@	; `string'
PUBLIC	??_C@_0BA@BKBCAEL@WeightThreshold?$AA@		; `string'
PUBLIC	??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@	; `string'
PUBLIC	??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@	; `string'
PUBLIC	??_C@_0M@PGLGACOH@NoMinorCivs?$AA@		; `string'
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT ??_C@_0DC@GLMFJHHA@AIEconomicStrategy_PersonalityFl@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
CONST	SEGMENT
??_C@_0DC@GLMFJHHA@AIEconomicStrategy_PersonalityFl@ DB 'AIEconomicStrate'
	DB	'gy_PersonalityFlavorThresholdMods', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JACMPKOA@AIEconomicStrategy_City_Flavors?$AA@
CONST	SEGMENT
??_C@_0CA@JACMPKOA@AIEconomicStrategy_City_Flavors?$AA@ DB 'AIEconomicStr'
	DB	'ategy_City_Flavors', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HBNMCKMO@AIEconomicStrategy_Player_Flavor@
CONST	SEGMENT
??_C@_0CC@HBNMCKMO@AIEconomicStrategy_Player_Flavor@ DB 'AIEconomicStrate'
	DB	'gy_Player_Flavors', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NCAFLNII@AIEconomicStrategyType?$AA@
CONST	SEGMENT
??_C@_0BH@NCAFLNII@AIEconomicStrategyType?$AA@ DB 'AIEconomicStrategyType'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@COMAJFAF@TechObsolete?$AA@
CONST	SEGMENT
??_C@_0N@COMAJFAF@TechObsolete?$AA@ DB 'TechObsolete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IANCLNMF@TechPrereq?$AA@
CONST	SEGMENT
??_C@_0L@IANCLNMF@TechPrereq?$AA@ DB 'TechPrereq', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@
CONST	SEGMENT
??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@ DB 'AdvisorCounselImport'
	DB	'ance', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@
CONST	SEGMENT
??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@ DB 'AdvisorCounsel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMKJABN@SCIENCE?$AA@
CONST	SEGMENT
??_C@_07IMKJABN@SCIENCE?$AA@ DB 'SCIENCE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLAKHONA@FOREIGN?$AA@
CONST	SEGMENT
??_C@_07OLAKHONA@FOREIGN?$AA@ DB 'FOREIGN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LKDCODGK@ECONOMIC?$AA@
CONST	SEGMENT
??_C@_08LKDCODGK@ECONOMIC?$AA@ DB 'ECONOMIC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBHPNIPO@MILITARY?$AA@
CONST	SEGMENT
??_C@_08EBHPNIPO@MILITARY?$AA@ DB 'MILITARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GOECOJOI@Advisor?$AA@
CONST	SEGMENT
??_C@_07GOECOJOI@Advisor?$AA@ DB 'Advisor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@
CONST	SEGMENT
??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@ DB 'FirstTurnExecuted', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BKBCAEL@WeightThreshold?$AA@
CONST	SEGMENT
??_C@_0BA@BKBCAEL@WeightThreshold?$AA@ DB 'WeightThreshold', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@
CONST	SEGMENT
??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@ DB 'MinimumNumTurnsExecut'
	DB	'ed', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@
CONST	SEGMENT
??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@ DB 'CheckTriggerTurnCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGLGACOH@NoMinorCivs?$AA@
CONST	SEGMENT
??_C@_0M@PGLGACOH@NoMinorCivs?$AA@ DB 'NoMinorCivs', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
tv152 = -104						; size = 4
tv326 = -100						; size = 4
tv321 = -94						; size = 1
tv314 = -93						; size = 1
tv309 = -92						; size = 4
tv311 = -88						; size = 4
tv146 = -84						; size = 4
tv303 = -80						; size = 4
tv298 = -74						; size = 1
tv291 = -73						; size = 1
tv286 = -72						; size = 4
tv288 = -68						; size = 4
tv140 = -64						; size = 4
tv280 = -60						; size = 4
tv275 = -54						; size = 1
tv268 = -53						; size = 1
tv263 = -52						; size = 4
tv265 = -48						; size = 4
tv134 = -44						; size = 4
tv257 = -40						; size = 4
tv252 = -34						; size = 1
tv245 = -33						; size = 1
tv240 = -32						; size = 4
tv242 = -28						; size = 4
_this$ = -24						; size = 4
$T230972 = -20						; size = 4
$T230971 = -16						; size = 4
_szType$ = -12						; size = 4
_strAdvisor$ = -8					; size = 4
_szTextVal$ = -4					; size = 4
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvEconomicAIStrategyXMLEntry::CacheResults, COMDAT
; _this$ = ecx

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kResults$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN9@CacheResul

; 56   : 		return false;

	xor	al, al
	jmp	$LN10@CacheResul
$LN9@CacheResul:

; 57   : 
; 58   : 	//Basic Properties
; 59   : 	m_bNoMinorCivs					= kResults.GetBool("NoMinorCivs");

	push	OFFSET ??_C@_0M@PGLGACOH@NoMinorCivs?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+276], al

; 60   : 	m_iCheckTriggerTurnCount		= kResults.GetInt("CheckTriggerTurnCount");

	push	OFFSET ??_C@_0BG@BFKLKDMO@CheckTriggerTurnCount?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], eax

; 61   : 	m_iMinimumNumTurnsExecuted		= kResults.GetInt("MinimumNumTurnsExecuted");

	push	OFFSET ??_C@_0BI@CIDKLIKO@MinimumNumTurnsExecuted?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax

; 62   : 	m_iWeightThreshold				= kResults.GetInt("WeightThreshold");

	push	OFFSET ??_C@_0BA@BKBCAEL@WeightThreshold?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+268], eax

; 63   : 	m_iFirstTurnExecuted            = kResults.GetInt("FirstTurnExecuted");

	push	OFFSET ??_C@_0BC@LIGEGMEA@FirstTurnExecuted?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+296], eax

; 64   : 
; 65   : 	const char* strAdvisor = kResults.GetText("Advisor");

	push	OFFSET ??_C@_07GOECOJOI@Advisor?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _strAdvisor$[ebp], eax

; 66   : 	m_eAdvisor = NO_ADVISOR_TYPE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], -1

; 67   : 	if(strAdvisor)

	cmp	DWORD PTR _strAdvisor$[ebp], 0
	je	$LN8@CacheResul

; 68   : 	{
; 69   : 		if(strcmp(strAdvisor, "MILITARY") == 0)

	mov	DWORD PTR tv242[ebp], OFFSET ??_C@_08EBHPNIPO@MILITARY?$AA@
	mov	eax, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv240[ebp], eax
$LL18@CacheResul:
	mov	ecx, DWORD PTR tv240[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv245[ebp], dl
	mov	eax, DWORD PTR tv242[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN19@CacheResul
	cmp	BYTE PTR tv245[ebp], 0
	je	SHORT $LN20@CacheResul
	mov	ecx, DWORD PTR tv240[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv252[ebp], dl
	mov	eax, DWORD PTR tv242[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN19@CacheResul
	add	DWORD PTR tv240[ebp], 2
	add	DWORD PTR tv242[ebp], 2
	cmp	BYTE PTR tv252[ebp], 0
	jne	SHORT $LL18@CacheResul
$LN20@CacheResul:
	mov	DWORD PTR tv257[ebp], 0
	jmp	SHORT $LN21@CacheResul
$LN19@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv257[ebp], ecx
$LN21@CacheResul:
	mov	edx, DWORD PTR tv257[ebp]
	mov	DWORD PTR tv134[ebp], edx
	cmp	DWORD PTR tv134[ebp], 0
	jne	SHORT $LN7@CacheResul

; 70   : 		{
; 71   : 			m_eAdvisor = ADVISOR_MILITARY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+300], 0
	jmp	$LN8@CacheResul
$LN7@CacheResul:

; 72   : 		}
; 73   : 		else if(strcmp(strAdvisor, "ECONOMIC") == 0)

	mov	DWORD PTR tv265[ebp], OFFSET ??_C@_08LKDCODGK@ECONOMIC?$AA@
	mov	ecx, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv263[ebp], ecx
$LL22@CacheResul:
	mov	edx, DWORD PTR tv263[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv268[ebp], al
	mov	ecx, DWORD PTR tv265[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN23@CacheResul
	cmp	BYTE PTR tv268[ebp], 0
	je	SHORT $LN24@CacheResul
	mov	edx, DWORD PTR tv263[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv275[ebp], al
	mov	ecx, DWORD PTR tv265[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN23@CacheResul
	add	DWORD PTR tv263[ebp], 2
	add	DWORD PTR tv265[ebp], 2
	cmp	BYTE PTR tv275[ebp], 0
	jne	SHORT $LL22@CacheResul
$LN24@CacheResul:
	mov	DWORD PTR tv280[ebp], 0
	jmp	SHORT $LN25@CacheResul
$LN23@CacheResul:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv280[ebp], edx
$LN25@CacheResul:
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR tv140[ebp], eax
	cmp	DWORD PTR tv140[ebp], 0
	jne	SHORT $LN5@CacheResul

; 74   : 		{
; 75   : 			m_eAdvisor = ADVISOR_ECONOMIC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+300], 1
	jmp	$LN8@CacheResul
$LN5@CacheResul:

; 76   : 		}
; 77   : 		else if(strcmp(strAdvisor, "FOREIGN") == 0)

	mov	DWORD PTR tv288[ebp], OFFSET ??_C@_07OLAKHONA@FOREIGN?$AA@
	mov	edx, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv286[ebp], edx
$LL26@CacheResul:
	mov	eax, DWORD PTR tv286[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv291[ebp], cl
	mov	edx, DWORD PTR tv288[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN27@CacheResul
	cmp	BYTE PTR tv291[ebp], 0
	je	SHORT $LN28@CacheResul
	mov	eax, DWORD PTR tv286[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv298[ebp], cl
	mov	edx, DWORD PTR tv288[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN27@CacheResul
	add	DWORD PTR tv286[ebp], 2
	add	DWORD PTR tv288[ebp], 2
	cmp	BYTE PTR tv298[ebp], 0
	jne	SHORT $LL26@CacheResul
$LN28@CacheResul:
	mov	DWORD PTR tv303[ebp], 0
	jmp	SHORT $LN29@CacheResul
$LN27@CacheResul:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv303[ebp], eax
$LN29@CacheResul:
	mov	ecx, DWORD PTR tv303[ebp]
	mov	DWORD PTR tv146[ebp], ecx
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $LN3@CacheResul

; 78   : 		{
; 79   : 			m_eAdvisor = ADVISOR_FOREIGN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+300], 2
	jmp	SHORT $LN8@CacheResul
$LN3@CacheResul:

; 80   : 		}
; 81   : 		else if(strcmp(strAdvisor, "SCIENCE") == 0)

	mov	DWORD PTR tv311[ebp], OFFSET ??_C@_07IMKJABN@SCIENCE?$AA@
	mov	eax, DWORD PTR _strAdvisor$[ebp]
	mov	DWORD PTR tv309[ebp], eax
$LL30@CacheResul:
	mov	ecx, DWORD PTR tv309[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv314[ebp], dl
	mov	eax, DWORD PTR tv311[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN31@CacheResul
	cmp	BYTE PTR tv314[ebp], 0
	je	SHORT $LN32@CacheResul
	mov	ecx, DWORD PTR tv309[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv321[ebp], dl
	mov	eax, DWORD PTR tv311[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN31@CacheResul
	add	DWORD PTR tv309[ebp], 2
	add	DWORD PTR tv311[ebp], 2
	cmp	BYTE PTR tv321[ebp], 0
	jne	SHORT $LL30@CacheResul
$LN32@CacheResul:
	mov	DWORD PTR tv326[ebp], 0
	jmp	SHORT $LN33@CacheResul
$LN31@CacheResul:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv326[ebp], ecx
$LN33@CacheResul:
	mov	edx, DWORD PTR tv326[ebp]
	mov	DWORD PTR tv152[ebp], edx
	cmp	DWORD PTR tv152[ebp], 0
	jne	SHORT $LN8@CacheResul

; 82   : 		{
; 83   : 			m_eAdvisor = ADVISOR_SCIENCE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+300], 3
$LN8@CacheResul:

; 84   : 		}
; 85   : 	}
; 86   : 
; 87   : 	m_strAdvisorCounselText = kResults.GetText("AdvisorCounsel");

	push	OFFSET ??_C@_0P@KBBBKHGN@AdvisorCounsel?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR $T230972[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 304				; 00000130H
	mov	DWORD PTR $T230971[ebp], ecx
	cmp	DWORD PTR $T230972[ebp], 0
	je	SHORT $LN13@CacheResul
	mov	edx, DWORD PTR $T230972[ebp]
	push	edx
	mov	ecx, DWORD PTR $T230971[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN14@CacheResul
$LN13@CacheResul:
	mov	ecx, DWORD PTR $T230971[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN14@CacheResul:

; 88   : 	m_iAdvisorCounselImportance = kResults.GetInt("AdvisorCounselImportance");

	push	OFFSET ??_C@_0BJ@EDJBOKGB@AdvisorCounselImportance?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], eax

; 89   : 
; 90   : 	//References
; 91   : 	const char* szTextVal = NULL;

	mov	DWORD PTR _szTextVal$[ebp], 0

; 92   : 	szTextVal = kResults.GetText("TechPrereq");

	push	OFFSET ??_C@_0L@IANCLNMF@TechPrereq?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 93   : 	m_iTechPrereq = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], eax

; 94   : 
; 95   : 	szTextVal = kResults.GetText("TechObsolete");

	push	OFFSET ??_C@_0N@COMAJFAF@TechObsolete?$AA@
	mov	ecx, DWORD PTR _kResults$[ebp]
	call	DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	mov	DWORD PTR _szTextVal$[ebp], eax

; 96   : 	m_iTechObsolete = GC.getInfoTypeForString(szTextVal, true);

	push	1
	mov	edx, DWORD PTR _szTextVal$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], eax

; 97   : 
; 98   : 	//Arrays
; 99   : 	//Arrays
; 100  : 	const char* szType = GetType();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _szType$[ebp], eax

; 101  : 	kUtility.SetFlavors(m_piPlayerFlavorValue, "AIEconomicStrategy_Player_Flavors",
; 102  : 	                    "AIEconomicStrategyType", szType);

	push	0
	mov	edx, DWORD PTR _szType$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@NCAFLNII@AIEconomicStrategyType?$AA@
	push	OFFSET ??_C@_0CC@HBNMCKMO@AIEconomicStrategy_Player_Flavor@
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 103  : 	kUtility.SetFlavors(m_piCityFlavorValue, "AIEconomicStrategy_City_Flavors",
; 104  : 		"AIEconomicStrategyType", szType);

	push	0
	mov	ecx, DWORD PTR _szType$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@NCAFLNII@AIEconomicStrategyType?$AA@
	push	OFFSET ??_C@_0CA@JACMPKOA@AIEconomicStrategy_City_Flavors?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 264				; 00000108H
	push	edx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 105  : 
; 106  : 
; 107  : 	kUtility.SetFlavors(m_piPersonalityFlavorThresholdMod,
; 108  : 	                    "AIEconomicStrategy_PersonalityFlavorThresholdMods",
; 109  : 	                    "AIEconomicStrategyType", szType);

	push	0
	mov	eax, DWORD PTR _szType$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@NCAFLNII@AIEconomicStrategyType?$AA@
	push	OFFSET ??_C@_0DC@GLMFJHHA@AIEconomicStrategy_PersonalityFl@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 272				; 00000110H
	push	ecx
	mov	ecx, DWORD PTR _kUtility$[ebp]
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 110  : 
; 111  : 	return true;

	mov	al, 1
$LN10@CacheResul:

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CacheResults@CvEconomicAIStrategyXMLEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvEconomicAIStrategyXMLEntry::CacheResults
_TEXT	ENDS
PUBLIC	?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z PROC ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue, COMDAT
; _this$ = ecx

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 118  : 	FAssertMsg(i > -1, "Index out of bounds");
; 119  : 	return m_piPlayerFlavorValue ? m_piPlayerFlavorValue[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+260], 0
	je	SHORT $LN3@GetPlayerF
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+260]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPlayerF
$LN3@GetPlayerF:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPlayerF:
	mov	eax, DWORD PTR tv69[ebp]

; 120  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue
_TEXT	ENDS
PUBLIC	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
; Function compile flags: /Odtp
;	COMDAT ?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z PROC ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue, COMDAT
; _this$ = ecx

; 124  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 126  : 	FAssertMsg(i > -1, "Index out of bounds");
; 127  : 	return m_piCityFlavorValue ? m_piCityFlavorValue[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+264], 0
	je	SHORT $LN3@GetCityFla
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetCityFla
$LN3@GetCityFla:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetCityFla:
	mov	eax, DWORD PTR tv69[ebp]

; 128  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
_TEXT	ENDS
PUBLIC	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
; Function compile flags: /Odtp
;	COMDAT ?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold, COMDAT
; _this$ = ecx

; 132  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 	return m_iWeightThreshold;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 134  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
_TEXT	ENDS
PUBLIC	?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
; Function compile flags: /Odtp
;	COMDAT ?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z PROC ; CvEconomicAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod, COMDAT
; _this$ = ecx

; 138  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 	FAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 140  : 	FAssertMsg(i > -1, "Index out of bounds");
; 141  : 	return m_piPersonalityFlavorThresholdMod ? m_piPersonalityFlavorThresholdMod[i] : -1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+272], 0
	je	SHORT $LN3@GetPersona
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN4@GetPersona
$LN3@GetPersona:
	mov	DWORD PTR tv69[ebp], -1
$LN4@GetPersona:
	mov	eax, DWORD PTR tv69[ebp]

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ENDP ; CvEconomicAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
_TEXT	ENDS
PUBLIC	?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ ; CvEconomicAIStrategyXMLEntry::IsNoMinorCivs
; Function compile flags: /Odtp
;	COMDAT ?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ PROC ; CvEconomicAIStrategyXMLEntry::IsNoMinorCivs, COMDAT
; _this$ = ecx

; 146  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 	return m_bNoMinorCivs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+276]

; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ ENDP ; CvEconomicAIStrategyXMLEntry::IsNoMinorCivs
_TEXT	ENDS
PUBLIC	?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechPrereq
; Function compile flags: /Odtp
;	COMDAT ?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetTechPrereq, COMDAT
; _this$ = ecx

; 152  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 	return m_iTechPrereq;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+280]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetTechPrereq
_TEXT	ENDS
PUBLIC	?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
; Function compile flags: /Odtp
;	COMDAT ?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetTechObsolete, COMDAT
; _this$ = ecx

; 158  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	return m_iTechObsolete;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+284]

; 160  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
_TEXT	ENDS
PUBLIC	?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
; Function compile flags: /Odtp
;	COMDAT ?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted, COMDAT
; _this$ = ecx

; 164  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 	return m_iMinimumNumTurnsExecuted;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]

; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
_TEXT	ENDS
PUBLIC	?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount
; Function compile flags: /Odtp
;	COMDAT ?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	return m_iCheckTriggerTurnCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+292]

; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount
_TEXT	ENDS
PUBLIC	?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetFirstTurnExecuted
; Function compile flags: /Odtp
;	COMDAT ?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetFirstTurnExecuted, COMDAT
; _this$ = ecx

; 176  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 	return m_iFirstTurnExecuted;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+296]

; 178  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetFirstTurnExecuted
_TEXT	ENDS
PUBLIC	?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ; CvEconomicAIStrategyXMLEntry::GetAdvisor
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ PROC ; CvEconomicAIStrategyXMLEntry::GetAdvisor, COMDAT
; _this$ = ecx

; 181  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 	return m_eAdvisor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+300]

; 183  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisor@CvEconomicAIStrategyXMLEntry@@QBE?AW4AdvisorTypes@@XZ ENDP ; CvEconomicAIStrategyXMLEntry::GetAdvisor
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselText
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ PROC ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselText, COMDAT
; _this$ = ecx

; 186  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 	return m_strAdvisorCounselText.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 304				; 00000130H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 188  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisorCounselText@CvEconomicAIStrategyXMLEntry@@QBEPBDXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselText
_TEXT	ENDS
PUBLIC	?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselImportance
; Function compile flags: /Odtp
;	COMDAT ?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ PROC ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselImportance, COMDAT
; _this$ = ecx

; 191  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 192  : 	return m_iAdvisorCounselImportance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+332]

; 193  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAdvisorCounselImportance@CvEconomicAIStrategyXMLEntry@@QBEHXZ ENDP ; CvEconomicAIStrategyXMLEntry::GetAdvisorCounselImportance
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
PUBLIC	?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Buy
PUBLIC	??0CvEconomicAIStrategyXMLEntries@@QAE@XZ	; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ$1
__ehfuncinfo$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??0CvEconomicAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
tv92 = -132						; size = 4
tv149 = -128						; size = 4
_this$ = -124						; size = 4
$T231057 = -30						; size = 1
$T231044 = -29						; size = 1
$T231040 = -28						; size = 4
$T231033 = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEconomicAIStrategyXMLEntries@@QAE@XZ PROC		; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 200  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T231057[ebp]
	mov	DWORD PTR $T231033[ebp], eax
	lea	ecx, DWORD PTR $T231044[ebp]
	mov	DWORD PTR $T231040[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv92[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Buy
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 201  : 
; 202  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvEconomicAIStrategyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEconomicAIStrategyXMLEntries@@QAE@XZ ENDP		; CvEconomicAIStrategyXMLEntries::CvEconomicAIStrategyXMLEntries
PUBLIC	??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
PUBLIC	?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy
PUBLIC	?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ ; CvEconomicAIStrategyXMLEntries::DeleteArray
PUBLIC	??1CvEconomicAIStrategyXMLEntries@@QAE@XZ	; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ$1
__ehfuncinfo$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEconomicAIStrategyXMLEntries@@QAE@XZ PROC		; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries, COMDAT
; _this$ = ecx

; 206  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 207  : 	DeleteArray();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ ; CvEconomicAIStrategyXMLEntries::DeleteArray

; 208  : }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
__unwindfunclet$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvEconomicAIStrategyXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEconomicAIStrategyXMLEntries@@QAE@XZ ENDP		; CvEconomicAIStrategyXMLEntries::~CvEconomicAIStrategyXMLEntries
PUBLIC	?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
; Function compile flags: /Odtp
;	COMDAT ?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ PROC ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries, COMDAT
; _this$ = ecx

; 212  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 	return m_paAIStrategyEntries;

	mov	eax, DWORD PTR _this$[ebp]

; 214  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEconomicAIStrategyEntries@CvEconomicAIStrategyXMLEntries@@QAEAAV?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@XZ ENDP ; CvEconomicAIStrategyXMLEntries::GetEconomicAIStrategyEntries
_TEXT	ENDS
PUBLIC	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
; Function compile flags: /Odtp
;	COMDAT ?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ PROC ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies, COMDAT
; _this$ = ecx

; 218  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 	return m_paAIStrategyEntries.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ENDP ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ
_TEXT	SEGMENT
tv145 = -116						; size = 4
_this$ = -112						; size = 4
$T231293 = -56						; size = 4
$T231277 = -52						; size = 4
$T231398 = -48						; size = 4
$T231397 = -44						; size = 4
$T231396 = -40						; size = 4
$T231395 = -36						; size = 4
$T231394 = -32						; size = 4
$T231261 = -28						; size = 4
$T231257 = -24						; size = 4
$T231256 = -20						; size = 4
$T231227 = -16						; size = 4
$T231203 = -12						; size = 4
$T231193 = -8						; size = 4
_it$224931 = -4						; size = 4
?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ PROC ; CvEconomicAIStrategyXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 	for(std::vector<CvEconomicAIStrategyXMLEntry*>::iterator it = m_paAIStrategyEntries.begin(); it != m_paAIStrategyEntries.end(); ++it)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T231203[ebp], ecx
	mov	edx, DWORD PTR $T231203[ebp]
	mov	DWORD PTR _it$224931[ebp], edx
	jmp	SHORT $LN3@DeleteArra
$LN2@DeleteArra:
	mov	eax, DWORD PTR _it$224931[ebp]
	add	eax, 4
	mov	DWORD PTR _it$224931[ebp], eax
$LN3@DeleteArra:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T231227[ebp], edx
	mov	eax, DWORD PTR $T231227[ebp]
	mov	DWORD PTR $T231193[ebp], eax
	mov	ecx, DWORD PTR _it$224931[ebp]
	xor	edx, edx
	cmp	ecx, DWORD PTR $T231193[ebp]
	sete	dl
	movzx	eax, dl
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@DeleteArra

; 226  : 	{
; 227  : 		SAFE_DELETE(*it);

	mov	edx, DWORD PTR _it$224931[ebp]
	mov	DWORD PTR $T231261[ebp], edx
	mov	eax, DWORD PTR $T231261[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231257[ebp], ecx
	mov	edx, DWORD PTR $T231257[ebp]
	mov	DWORD PTR $T231256[ebp], edx
	cmp	DWORD PTR $T231256[ebp], 0
	je	SHORT $LN32@DeleteArra
	push	1
	mov	eax, DWORD PTR $T231256[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T231256[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN33@DeleteArra
$LN32@DeleteArra:
	mov	DWORD PTR tv145[ebp], 0
$LN33@DeleteArra:
	mov	ecx, DWORD PTR $T231261[ebp]
	mov	DWORD PTR [ecx], 0

; 228  : 	}

	jmp	SHORT $LN2@DeleteArra
$LN1@DeleteArra:

; 229  : 
; 230  : 	m_paAIStrategyEntries.clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T231277[ebp], eax
	mov	ecx, DWORD PTR $T231277[ebp]
	mov	DWORD PTR $T231395[ebp], ecx
	mov	edx, DWORD PTR $T231395[ebp]
	mov	DWORD PTR $T231394[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T231293[ebp], ecx
	mov	edx, DWORD PTR $T231293[ebp]
	mov	DWORD PTR $T231397[ebp], edx
	mov	eax, DWORD PTR $T231397[ebp]
	mov	DWORD PTR $T231396[ebp], eax
	mov	ecx, DWORD PTR $T231394[ebp]
	push	ecx
	mov	edx, DWORD PTR $T231396[ebp]
	push	edx
	lea	eax, DWORD PTR $T231398[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::erase

; 231  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DeleteArray@CvEconomicAIStrategyXMLEntries@@QAEXXZ ENDP ; CvEconomicAIStrategyXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
; Function compile flags: /Odtp
;	COMDAT ?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z PROC ; CvEconomicAIStrategyXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 235  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 	return m_paAIStrategyEntries[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 237  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ENDP ; CvEconomicAIStrategyXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
PUBLIC	??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
PUBLIC	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
PUBLIC	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
PUBLIC	??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
PUBLIC	??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>
PUBLIC	??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
PUBLIC	??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
PUBLIC	??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
PUBLIC	??0CvEconomicAI@@QAE@XZ				; CvEconomicAI::CvEconomicAI
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??0CvEconomicAI@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CvEconomicAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CvEconomicAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CvEconomicAI@@QAE@XZ$6
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??0CvEconomicAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -80						; size = 4
__$EHRec$ = -12						; size = 12
??0CvEconomicAI@@QAE@XZ PROC				; CvEconomicAI::CvEconomicAI, COMDAT
; _this$ = ecx

; 249  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvEconomicAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	call	??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>

; 250  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	jmp	??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__unwindfunclet$??0CvEconomicAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__ehhandler$??0CvEconomicAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvEconomicAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvEconomicAI@@QAE@XZ ENDP				; CvEconomicAI::CvEconomicAI
PUBLIC	??1?$BaseVector@I$0A@@@QAE@XZ			; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
PUBLIC	??1?$BaseVector@H$0A@@@QAE@XZ			; BaseVector<int,0>::~BaseVector<int,0>
PUBLIC	??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
PUBLIC	??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ		; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
PUBLIC	??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
PUBLIC	?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z		; BaseVector<int,0>::Destroy
PUBLIC	?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::Destroy
PUBLIC	?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z ; BaseVector<CvUnit *,0>::Destroy
PUBLIC	?Uninit@CvEconomicAI@@QAEXXZ			; CvEconomicAI::Uninit
PUBLIC	??1CvEconomicAI@@QAE@XZ				; CvEconomicAI::~CvEconomicAI
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__ehfuncinfo$??1CvEconomicAI@@QAE@XZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$??1CvEconomicAI@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvEconomicAI@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$8
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$11
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$12
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$13
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvEconomicAI@@QAE@XZ$15
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ??1CvEconomicAI@@QAE@XZ
_TEXT	SEGMENT
_this$ = -112						; size = 4
$T231785 = -108						; size = 4
$T231765 = -104						; size = 4
$T231764 = -100						; size = 4
_i$231775 = -96						; size = 4
$T231737 = -92						; size = 4
$T231717 = -88						; size = 4
$T231716 = -84						; size = 4
_i$231727 = -80						; size = 4
$T231689 = -76						; size = 4
$T231676 = -72						; size = 4
$T231675 = -68						; size = 4
$T231663 = -64						; size = 4
$T231650 = -60						; size = 4
$T231649 = -56						; size = 4
$T231637 = -52						; size = 4
$T231624 = -48						; size = 4
$T231623 = -44						; size = 4
$T231587 = -24						; size = 4
$T231574 = -20						; size = 4
$T231573 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvEconomicAI@@QAE@XZ PROC				; CvEconomicAI::~CvEconomicAI, COMDAT
; _this$ = ecx

; 254  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvEconomicAI@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7

; 255  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@CvEconomicAI@@QAEXXZ		; CvEconomicAI::Uninit

; 256  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 288				; 00000120H
	mov	DWORD PTR $T231587[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T231587[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231574[ebp], edx
	mov	eax, DWORD PTR $T231587[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231573[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN14@CvEconomic
	mov	eax, DWORD PTR $T231574[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231573[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231587[ebp]
	call	?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z ; BaseVector<CvUnit *,0>::Destroy
$LN14@CvEconomic:
	mov	edx, DWORD PTR $T231573[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T231637[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T231637[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231624[ebp], edx
	mov	eax, DWORD PTR $T231637[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231623[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN42@CvEconomic
	mov	eax, DWORD PTR $T231624[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231623[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231637[ebp]
	call	?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::Destroy
$LN42@CvEconomic:
	mov	edx, DWORD PTR $T231623[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H
	mov	DWORD PTR $T231663[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T231663[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231650[ebp], edx
	mov	eax, DWORD PTR $T231663[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231649[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN52@CvEconomic
	mov	eax, DWORD PTR $T231650[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231649[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231663[ebp]
	call	?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z	; BaseVector<int,0>::Destroy
$LN52@CvEconomic:
	mov	edx, DWORD PTR $T231649[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR $T231689[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T231689[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231676[ebp], edx
	mov	eax, DWORD PTR $T231689[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231675[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN62@CvEconomic
	mov	eax, DWORD PTR $T231676[ebp]
	push	eax
	mov	ecx, DWORD PTR $T231675[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231689[ebp]
	call	?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z	; BaseVector<int,0>::Destroy
$LN62@CvEconomic:
	mov	edx, DWORD PTR $T231675[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR $T231737[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T231737[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T231717[ebp], edx
	mov	eax, DWORD PTR $T231737[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231716[ebp], ecx
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN72@CvEconomic
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN72@CvEconomic
	mov	DWORD PTR _i$231727[ebp], 0
	jmp	SHORT $LN77@CvEconomic
$LN76@CvEconomic:
	mov	ecx, DWORD PTR _i$231727[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$231727[ebp], ecx
$LN77@CvEconomic:
	mov	edx, DWORD PTR _i$231727[ebp]
	cmp	edx, DWORD PTR $T231717[ebp]
	jae	SHORT $LN72@CvEconomic
	jmp	SHORT $LN76@CvEconomic
$LN72@CvEconomic:
	mov	eax, DWORD PTR $T231716[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	mov	DWORD PTR $T231785[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	edx, DWORD PTR $T231785[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T231765[ebp], eax
	mov	ecx, DWORD PTR $T231785[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231764[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN88@CvEconomic
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN88@CvEconomic
	mov	DWORD PTR _i$231775[ebp], 0
	jmp	SHORT $LN93@CvEconomic
$LN92@CvEconomic:
	mov	edx, DWORD PTR _i$231775[ebp]
	add	edx, 1
	mov	DWORD PTR _i$231775[ebp], edx
$LN93@CvEconomic:
	mov	eax, DWORD PTR _i$231775[ebp]
	cmp	eax, DWORD PTR $T231765[ebp]
	jae	SHORT $LN88@CvEconomic
	jmp	SHORT $LN92@CvEconomic
$LN88@CvEconomic:
	mov	ecx, DWORD PTR $T231764[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	jmp	??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	jmp	??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	jmp	??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$8:
	mov	ecx, DWORD PTR $T231587[ebp]
	jmp	??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ	; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$11:
	mov	ecx, DWORD PTR $T231637[ebp]
	jmp	??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$12:
	mov	ecx, DWORD PTR $T231663[ebp]
	jmp	??1?$BaseVector@H$0A@@@QAE@XZ		; BaseVector<int,0>::~BaseVector<int,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$13:
	mov	ecx, DWORD PTR $T231689[ebp]
	jmp	??1?$BaseVector@H$0A@@@QAE@XZ		; BaseVector<int,0>::~BaseVector<int,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$14:
	mov	ecx, DWORD PTR $T231737[ebp]
	jmp	??1?$BaseVector@H$0A@@@QAE@XZ		; BaseVector<int,0>::~BaseVector<int,0>
__unwindfunclet$??1CvEconomicAI@@QAE@XZ$15:
	mov	ecx, DWORD PTR $T231785[ebp]
	jmp	??1?$BaseVector@I$0A@@@QAE@XZ		; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
__ehhandler$??1CvEconomicAI@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvEconomicAI@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvEconomicAI@@QAE@XZ ENDP				; CvEconomicAI::~CvEconomicAI
PUBLIC	?Reset@CvEconomicAI@@QAEXXZ			; CvEconomicAI::Reset
PUBLIC	?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy
PUBLIC	?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z ; CvEconomicAI::Init
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Odtp
;	COMDAT ?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T231853 = -64						; size = 4
_i$231849 = -60						; size = 4
$T231820 = -28						; size = 4
_i$231816 = -24						; size = 4
$T231801 = -20						; size = 4
$T231797 = -16						; size = 4
$T231796 = -12						; size = 4
$T231795 = -8						; size = 4
$T231794 = -4						; size = 4
_pAIStrategies$ = 8					; size = 4
_pPlayer$ = 12						; size = 4
?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z PROC ; CvEconomicAI::Init, COMDAT
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	// Store off the pointer to the AIStrategies active for this game
; 262  : 	m_pAIStrategies = pAIStrategies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pAIStrategies$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 263  : 
; 264  : 	m_pPlayer = pPlayer;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [edx+4], eax

; 265  : 
; 266  : 	// Initialize arrays
; 267  : 	FAssertMsg(m_pabUsingStrategy==NULL, "about to leak memory, CvStrategyAI::m_pabUsingStrategy");
; 268  : 	m_pabUsingStrategy = FNEW(bool[m_pAIStrategies->GetNumEconomicAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T231794[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T231794[ebp]
	mov	DWORD PTR [edx+12], eax

; 269  : 
; 270  : 	FAssertMsg(m_paiTurnStrategyAdopted==NULL, "about to leak memory, CvStrategyAI::m_paiTurnStrategyAdopted");
; 271  : 	m_paiTurnStrategyAdopted = FNEW(int[m_pAIStrategies->GetNumEconomicAIStrategies()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T231795[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T231795[ebp]
	mov	DWORD PTR [eax+16], ecx

; 272  : 
; 273  : 	FAssertMsg(m_aiTempFlavors==NULL, "about to leak memory, CvStrategyAI::m_aiTempFlavors");
; 274  : 	m_aiTempFlavors = FNEW(int[GC.getNumFlavorTypes()], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T231801[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T231801[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T231796[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T231796[ebp]
	mov	DWORD PTR [eax+20], ecx

; 275  : 
; 276  : 	m_auiYields.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 52					; 00000034H
	mov	DWORD PTR $T231820[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN11@Init
	mov	DWORD PTR _i$231816[ebp], 0
	jmp	SHORT $LN9@Init
$LN8@Init:
	mov	ecx, DWORD PTR _i$231816[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$231816[ebp], ecx
$LN9@Init:
	mov	edx, DWORD PTR $T231820[ebp]
	mov	eax, DWORD PTR _i$231816[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN11@Init
	jmp	SHORT $LN8@Init
$LN11@Init:
	mov	ecx, DWORD PTR $T231820[ebp]
	mov	DWORD PTR [ecx+4], 0

; 277  : #ifdef AUI_WARNING_FIXES
; 278  : 	m_auiYields.push_back_copy(0, uint(NUM_YIELD_TYPES));
; 279  : #else
; 280  : 	m_auiYields.push_back_copy(-1, NUM_YIELD_TYPES);

	mov	DWORD PTR $T231797[ebp], -1
	push	6
	lea	edx, DWORD PTR $T231797[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy

; 281  : #endif
; 282  : 	m_RequestedSavings.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	mov	DWORD PTR $T231853[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN46@Init
	mov	DWORD PTR _i$231849[ebp], 0
	jmp	SHORT $LN44@Init
$LN43@Init:
	mov	edx, DWORD PTR _i$231849[ebp]
	add	edx, 1
	mov	DWORD PTR _i$231849[ebp], edx
$LN44@Init:
	mov	eax, DWORD PTR $T231853[ebp]
	mov	ecx, DWORD PTR _i$231849[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN46@Init
	jmp	SHORT $LN43@Init
$LN46@Init:
	mov	edx, DWORD PTR $T231853[ebp]
	mov	DWORD PTR [edx+4], 0

; 283  : 
; 284  : 	Reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reset@CvEconomicAI@@QAEXXZ		; CvEconomicAI::Reset

; 285  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Init@CvEconomicAI@@QAEXPAVCvEconomicAIStrategyXMLEntries@@PAVCvPlayer@@@Z ENDP ; CvEconomicAI::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T231873 = -24						; size = 4
$T231871 = -20						; size = 4
$T231867 = -16						; size = 4
$T231865 = -12						; size = 4
$T231861 = -8						; size = 4
$T231859 = -4						; size = 4
?Uninit@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::Uninit, COMDAT
; _this$ = ecx

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 290  : 	SAFE_DELETE_ARRAY(m_pabUsingStrategy);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T231861[ebp], eax
	mov	ecx, DWORD PTR $T231861[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T231859[ebp], edx
	mov	eax, DWORD PTR $T231859[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T231861[ebp]
	mov	DWORD PTR [ecx], 0

; 291  : 	SAFE_DELETE_ARRAY(m_paiTurnStrategyAdopted);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR $T231867[ebp], edx
	mov	eax, DWORD PTR $T231867[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T231865[ebp], ecx
	mov	edx, DWORD PTR $T231865[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T231867[ebp]
	mov	DWORD PTR [eax], 0

; 292  : 	SAFE_DELETE_ARRAY(m_aiTempFlavors);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T231873[ebp], ecx
	mov	edx, DWORD PTR $T231873[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T231871[ebp], eax
	mov	ecx, DWORD PTR $T231871[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T231873[ebp]
	mov	DWORD PTR [edx], 0

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::Uninit
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::push_back
; Function compile flags: /Odtp
;	COMDAT ?Reset@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T231920 = -56						; size = 4
$T231916 = -52						; size = 4
$T231902 = -44						; size = 4
$T231892 = -40						; size = 4
$T231882 = -36						; size = 4
_request$224994 = -32					; size = 12
_ui$224990 = -20					; size = 4
_ui$224986 = -16					; size = 4
_ui$224982 = -12					; size = 4
_ui$224978 = -8						; size = 4
_iI$ = -4						; size = 4
?Reset@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::Reset, COMDAT
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	int iI;
; 299  : 
; 300  : 	for(iI = 0; iI < m_pAIStrategies->GetNumEconomicAIStrategies(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN15@Reset
$LN14@Reset:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN15@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
	cmp	DWORD PTR _iI$[ebp], eax
	jge	SHORT $LN13@Reset

; 301  : 	{
; 302  : 		m_pabUsingStrategy[iI] = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 303  : 		m_paiTurnStrategyAdopted[iI] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 304  : 	}

	jmp	SHORT $LN14@Reset
$LN13@Reset:

; 305  : 
; 306  : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$224978[ebp], 0
	jmp	SHORT $LN12@Reset
$LN11@Reset:
	mov	edx, DWORD PTR _ui$224978[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$224978[ebp], edx
$LN12@Reset:
	cmp	DWORD PTR _ui$224978[ebp], 6
	jae	SHORT $LN10@Reset

; 307  : 	{
; 308  : 		m_auiYields[ui] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _ui$224978[ebp]
	mov	DWORD PTR [ecx+edx*4], 0

; 309  : 	}

	jmp	SHORT $LN11@Reset
$LN10@Reset:

; 310  : 
; 311  : 	for(uint ui = 0; ui < m_aiExplorationPlots.size(); ui++)

	mov	DWORD PTR _ui$224982[ebp], 0
	jmp	SHORT $LN9@Reset
$LN8@Reset:
	mov	eax, DWORD PTR _ui$224982[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$224982[ebp], eax
$LN9@Reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR $T231882[ebp], edx
	mov	eax, DWORD PTR _ui$224982[ebp]
	cmp	eax, DWORD PTR $T231882[ebp]
	jae	SHORT $LN7@Reset

; 312  : 	{
; 313  : 		m_aiExplorationPlots[ui] = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _ui$224982[ebp]
	mov	DWORD PTR [edx+eax*4], -1

; 314  : 		m_aiExplorationPlotRatings[ui] = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _ui$224982[ebp]
	mov	DWORD PTR [edx+eax*4], -1

; 315  : 	}

	jmp	SHORT $LN8@Reset
$LN7@Reset:

; 316  : 
; 317  : 	for(uint ui = 0; ui < m_aiGoodyHutPlots.size(); ui++)

	mov	DWORD PTR _ui$224986[ebp], 0
	jmp	SHORT $LN6@Reset
$LN5@Reset:
	mov	ecx, DWORD PTR _ui$224986[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$224986[ebp], ecx
$LN6@Reset:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR $T231892[ebp], eax
	mov	ecx, DWORD PTR _ui$224986[ebp]
	cmp	ecx, DWORD PTR $T231892[ebp]
	jae	SHORT $LN4@Reset

; 318  : 	{
; 319  : 		m_aiGoodyHutPlots[ui] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR _ui$224986[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 320  : 		m_aiGoodyHutUnitAssignments[ui].Clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _ui$224986[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T231902[ebp], edx
	mov	eax, DWORD PTR $T231902[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T231902[ebp]
	mov	DWORD PTR [ecx+4], -1

; 321  : 	}

	jmp	SHORT $LN5@Reset
$LN4@Reset:

; 322  : 
; 323  : 	m_bExplorationPlotsDirty = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx], 1

; 324  : 
; 325  : 	for(uint ui = 0; ui < NUM_PURCHASE_TYPES; ui++)

	mov	DWORD PTR _ui$224990[ebp], 0
	jmp	SHORT $LN3@Reset
$LN2@Reset:
	mov	eax, DWORD PTR _ui$224990[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$224990[ebp], eax
$LN3@Reset:
	cmp	DWORD PTR _ui$224990[ebp], 6
	jae	SHORT $LN1@Reset

; 326  : 	{
; 327  : 		CvPurchaseRequest request;

	mov	DWORD PTR _request$224994[ebp], -1
	mov	DWORD PTR _request$224994[ebp+4], 0
	mov	DWORD PTR _request$224994[ebp+8], 0

; 328  : 		request.m_eType = (PurchaseType)ui;

	mov	ecx, DWORD PTR _ui$224990[ebp]
	mov	DWORD PTR _request$224994[ebp], ecx

; 329  : 		request.m_iAmount = 0;

	mov	DWORD PTR _request$224994[ebp+4], 0

; 330  : 		request.m_iPriority = 0;

	mov	DWORD PTR _request$224994[ebp+8], 0

; 331  : 		m_RequestedSavings.push_back(request);

	lea	edx, DWORD PTR _request$224994[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::push_back

; 332  : 	}

	jmp	SHORT $LN2@Reset
$LN1@Reset:

; 333  : 
; 334  : 	m_iExplorersDisbanded = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 335  : 	m_eReconState = NO_RECON_STATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], -1

; 336  : 	m_eNavalReconState = NO_RECON_STATE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], -1

; 337  : 	m_iLastTurnWorkerDisbanded = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], -1

; 338  : 	m_iVisibleAntiquitySites = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 339  : 
; 340  : 	// Cached AI defines
; 341  : 	m_iMinimumSettleFertility = GC.getAI_STRATEGY_MINIMUM_SETTLE_FERTILITY();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2028
	mov	DWORD PTR $T231916[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T231916[ebp]
	mov	DWORD PTR [eax+48], ecx

; 342  : 
; 343  : 	// Basic number of cities desired for early growth is in XML (10)
; 344  : 	// Later will scale that up or down based on ratio of FLAVOR_EXPANSION to FLAVOR_GROWTH
; 345  : 	m_iEarlyCityNumberTarget = GC.getAI_STRATEGY_EARLY_EXPANSION_NUM_CITIES_LIMIT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2012
	mov	DWORD PTR $T231920[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T231920[ebp]
	mov	DWORD PTR [eax+24], ecx

; 346  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Reset@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::Reset
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z ; operator>>
PUBLIC	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
PUBLIC	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
PUBLIC	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
PUBLIC	?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z	; CvEconomicAI::Read
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv349 = -212						; size = 4
tv330 = -208						; size = 4
tv164 = -204						; size = 4
tv279 = -200						; size = 4
tv260 = -196						; size = 4
tv93 = -192						; size = 4
_this$ = -188						; size = 4
$T232099 = -184						; size = 4
$T232092 = -180						; size = 4
$T232085 = -176						; size = 4
$T232078 = -172						; size = 4
$T232077 = -168						; size = 4
$T232068 = -164						; size = 4
$T232074 = -160						; size = 4
$T232057 = -156						; size = 4
$T232056 = -152						; size = 4
$T232047 = -148						; size = 4
$T232053 = -144						; size = 4
$T232033 = -140						; size = 4
$T232018 = -136						; size = 4
$T232011 = -132						; size = 4
$T232004 = -128						; size = 4
$T232003 = -124						; size = 4
$T231994 = -120						; size = 4
$T232000 = -116						; size = 4
$T231983 = -112						; size = 4
$T231982 = -108						; size = 4
$T231973 = -104						; size = 4
$T231979 = -100						; size = 4
$T231959 = -96						; size = 4
$T231947 = -92						; size = 4
$T231940 = -88						; size = 4
$T231939 = -84						; size = 4
$T231935 = -80						; size = 4
$T231934 = -76						; size = 4
$T231924 = -72						; size = 4
$T231923 = -68						; size = 4
_i$225100 = -64						; size = 4
_iDummy$225096 = -60					; size = 4
_i$225092 = -56						; size = 4
_i$225088 = -52						; size = 4
_iDummy$225086 = -48					; size = 4
_i$225082 = -44						; size = 4
_i$225078 = -40						; size = 4
_ui$225067 = -36					; size = 4
_wrapGetNumEconomicAIStrategies$ = -32			; size = 8
_iEntriesToRead$ = -24					; size = 4
_iMaxEntriesToRead$ = -20				; size = 4
_uiVersion$ = -16					; size = 4
_wrapGetNumEconomicAIStrategies2$ = -12			; size = 8
_iTemp$ = -4						; size = 4
_kStream$ = 8						; size = 4
?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z PROC		; CvEconomicAI::Read, COMDAT
; _this$ = ecx

; 350  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	mov	DWORD PTR _this$[ebp], ecx

; 351  : 	// Version number to maintain backwards compatibility
; 352  : 	uint uiVersion;
; 353  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 354  : 
; 355  : 	int iEntriesToRead;
; 356  : 
; 357  : 	FAssertMsg(m_pAIStrategies != NULL && m_pAIStrategies->GetNumEconomicAIStrategies() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 358  : 
; 359  : 	kStream >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 360  : 
; 361  : #ifdef _MSC_VER
; 362  : #pragma warning ( push )
; 363  : #pragma warning ( disable : 6011 ) // no clear solution or recovery if m_pAIStrategies is ever NULL
; 364  : #endif//_MSC_VER
; 365  : 	ArrayWrapper<bool> wrapGetNumEconomicAIStrategies(iEntriesToRead, m_pabUsingStrategy);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T231935[ebp], eax
	mov	ecx, DWORD PTR _iEntriesToRead$[ebp]
	mov	DWORD PTR $T231934[ebp], ecx
	mov	edx, DWORD PTR $T231935[ebp]
	mov	DWORD PTR _wrapGetNumEconomicAIStrategies$[ebp], edx
	mov	eax, DWORD PTR $T231934[ebp]
	mov	DWORD PTR _wrapGetNumEconomicAIStrategies$[ebp+4], eax

; 366  : #ifdef _MSC_VER
; 367  : #pragma warning ( pop )
; 368  : #endif//_MSC_VER
; 369  : 
; 370  : 	kStream >> wrapGetNumEconomicAIStrategies;

	lea	ecx, DWORD PTR _wrapGetNumEconomicAIStrategies$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ; operator>><bool>
	add	esp, 8

; 371  : 
; 372  : 	ArrayWrapper<int> wrapGetNumEconomicAIStrategies2(iEntriesToRead, m_paiTurnStrategyAdopted);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T231940[ebp], ecx
	mov	edx, DWORD PTR _iEntriesToRead$[ebp]
	mov	DWORD PTR $T231939[ebp], edx
	mov	eax, DWORD PTR $T231940[ebp]
	mov	DWORD PTR _wrapGetNumEconomicAIStrategies2$[ebp], eax
	mov	ecx, DWORD PTR $T231939[ebp]
	mov	DWORD PTR _wrapGetNumEconomicAIStrategies2$[ebp+4], ecx

; 373  : 	kStream >> wrapGetNumEconomicAIStrategies2;

	lea	edx, DWORD PTR _wrapGetNumEconomicAIStrategies2$[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
	add	esp, 8

; 374  : 
; 375  : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$225067[ebp], 0
	jmp	SHORT $LN18@Read
$LN17@Read:
	mov	ecx, DWORD PTR _ui$225067[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225067[ebp], ecx
$LN18@Read:
	cmp	DWORD PTR _ui$225067[ebp], 6
	jae	SHORT $LN16@Read

; 376  : 	{
; 377  : 		kStream >> m_auiYields[ui];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _ui$225067[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T231947[ebp], edx
	mov	eax, DWORD PTR $T231947[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 378  : 	}

	jmp	SHORT $LN17@Read
$LN16@Read:

; 379  : 
; 380  : 	kStream >> m_bExplorationPlotsDirty;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 381  : 
; 382  : 	kStream >> iEntriesToRead;

	lea	edx, DWORD PTR _iEntriesToRead$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 383  : 
; 384  : #define MAX_PLOT_ARRAY_SIZE	((152+1)*(96+1))
; 385  : 	int iMaxEntriesToRead = MIN(MAX_PLOT_ARRAY_SIZE, iEntriesToRead);

	mov	DWORD PTR $T231923[ebp], 14841		; 000039f9H
	mov	eax, DWORD PTR _iEntriesToRead$[ebp]
	cmp	eax, DWORD PTR $T231923[ebp]
	jge	SHORT $LN39@Read
	lea	ecx, DWORD PTR _iEntriesToRead$[ebp]
	mov	DWORD PTR tv93[ebp], ecx
	jmp	SHORT $LN40@Read
$LN39@Read:
	lea	edx, DWORD PTR $T231923[ebp]
	mov	DWORD PTR tv93[ebp], edx
$LN40@Read:
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR $T231959[ebp], eax
	mov	ecx, DWORD PTR $T231959[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iMaxEntriesToRead$[ebp], edx

; 386  : 
; 387  : 	m_aiExplorationPlots.resize(iMaxEntriesToRead);

	mov	eax, DWORD PTR _iMaxEntriesToRead$[ebp]
	mov	DWORD PTR $T231983[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR $T231982[ebp], ecx
	mov	edx, DWORD PTR $T231982[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR $T231983[ebp]
	jae	SHORT $LN41@Read
	mov	ecx, DWORD PTR $T231983[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T231982[ebp]
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN41@Read:
	mov	edx, DWORD PTR $T231982[ebp]
	add	edx, 8
	mov	DWORD PTR $T231973[ebp], edx
	mov	eax, DWORD PTR $T231973[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T231983[ebp]
	jae	SHORT $LN46@Read
	mov	edx, DWORD PTR $T231973[ebp]
	mov	DWORD PTR tv260[ebp], edx
	jmp	SHORT $LN47@Read
$LN46@Read:
	lea	eax, DWORD PTR $T231983[ebp]
	mov	DWORD PTR tv260[ebp], eax
$LN47@Read:
	mov	ecx, DWORD PTR tv260[ebp]
	mov	DWORD PTR $T231979[ebp], ecx
	mov	edx, DWORD PTR $T231982[ebp]
	mov	eax, DWORD PTR $T231979[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 388  : 	m_aiExplorationPlotRatings.resize(iMaxEntriesToRead);

	mov	edx, DWORD PTR _iMaxEntriesToRead$[ebp]
	mov	DWORD PTR $T232004[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH
	mov	DWORD PTR $T232003[ebp], eax
	mov	ecx, DWORD PTR $T232003[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR $T232004[ebp]
	jae	SHORT $LN48@Read
	mov	eax, DWORD PTR $T232004[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232003[ebp]
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN48@Read:
	mov	ecx, DWORD PTR $T232003[ebp]
	add	ecx, 8
	mov	DWORD PTR $T231994[ebp], ecx
	mov	edx, DWORD PTR $T231994[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR $T232004[ebp]
	jae	SHORT $LN53@Read
	mov	ecx, DWORD PTR $T231994[ebp]
	mov	DWORD PTR tv279[ebp], ecx
	jmp	SHORT $LN54@Read
$LN53@Read:
	lea	edx, DWORD PTR $T232004[ebp]
	mov	DWORD PTR tv279[ebp], edx
$LN54@Read:
	mov	eax, DWORD PTR tv279[ebp]
	mov	DWORD PTR $T232000[ebp], eax
	mov	ecx, DWORD PTR $T232003[ebp]
	mov	edx, DWORD PTR $T232000[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 389  : 
; 390  : 	for(int i = 0; i < iMaxEntriesToRead; i++)

	mov	DWORD PTR _i$225078[ebp], 0
	jmp	SHORT $LN15@Read
$LN14@Read:
	mov	ecx, DWORD PTR _i$225078[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$225078[ebp], ecx
$LN15@Read:
	mov	edx, DWORD PTR _i$225078[ebp]
	cmp	edx, DWORD PTR _iMaxEntriesToRead$[ebp]
	jge	SHORT $LN13@Read

; 391  : 	{
; 392  : 		kStream >> m_aiExplorationPlots[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _i$225078[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T232011[ebp], eax
	mov	ecx, DWORD PTR $T232011[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 393  : 		kStream >> m_aiExplorationPlotRatings[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _i$225078[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T232018[ebp], edx
	mov	eax, DWORD PTR $T232018[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 394  : 	}

	jmp	SHORT $LN14@Read
$LN13@Read:

; 395  : 
; 396  : 	// Skip any ones that go over the limit
; 397  : 	for(int i = iMaxEntriesToRead; i < iEntriesToRead; i++)

	mov	ecx, DWORD PTR _iMaxEntriesToRead$[ebp]
	mov	DWORD PTR _i$225082[ebp], ecx
	jmp	SHORT $LN12@Read
$LN11@Read:
	mov	edx, DWORD PTR _i$225082[ebp]
	add	edx, 1
	mov	DWORD PTR _i$225082[ebp], edx
$LN12@Read:
	mov	eax, DWORD PTR _i$225082[ebp]
	cmp	eax, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN10@Read

; 398  : 	{
; 399  : 		int iDummy;
; 400  : 		kStream >> iDummy;

	lea	ecx, DWORD PTR _iDummy$225086[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 401  : 		kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$225086[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 402  : 	}

	jmp	SHORT $LN11@Read
$LN10@Read:

; 403  : 
; 404  : 	// goody hut plots
; 405  : 	kStream >> iEntriesToRead;

	lea	eax, DWORD PTR _iEntriesToRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 406  : 	iMaxEntriesToRead = MIN(MAX_PLOT_ARRAY_SIZE, iEntriesToRead);

	mov	DWORD PTR $T231924[ebp], 14841		; 000039f9H
	mov	ecx, DWORD PTR _iEntriesToRead$[ebp]
	cmp	ecx, DWORD PTR $T231924[ebp]
	jge	SHORT $LN71@Read
	lea	edx, DWORD PTR _iEntriesToRead$[ebp]
	mov	DWORD PTR tv164[ebp], edx
	jmp	SHORT $LN72@Read
$LN71@Read:
	lea	eax, DWORD PTR $T231924[ebp]
	mov	DWORD PTR tv164[ebp], eax
$LN72@Read:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR $T232033[ebp], ecx
	mov	edx, DWORD PTR $T232033[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _iMaxEntriesToRead$[ebp], eax

; 407  : 	m_aiGoodyHutPlots.resize(iMaxEntriesToRead);

	mov	ecx, DWORD PTR _iMaxEntriesToRead$[ebp]
	mov	DWORD PTR $T232057[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 88					; 00000058H
	mov	DWORD PTR $T232056[ebp], edx
	mov	eax, DWORD PTR $T232056[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR $T232057[ebp]
	jae	SHORT $LN73@Read
	mov	edx, DWORD PTR $T232057[ebp]
	push	edx
	mov	ecx, DWORD PTR $T232056[ebp]
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN73@Read:
	mov	eax, DWORD PTR $T232056[ebp]
	add	eax, 8
	mov	DWORD PTR $T232047[ebp], eax
	mov	ecx, DWORD PTR $T232047[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR $T232057[ebp]
	jae	SHORT $LN78@Read
	mov	eax, DWORD PTR $T232047[ebp]
	mov	DWORD PTR tv330[ebp], eax
	jmp	SHORT $LN79@Read
$LN78@Read:
	lea	ecx, DWORD PTR $T232057[ebp]
	mov	DWORD PTR tv330[ebp], ecx
$LN79@Read:
	mov	edx, DWORD PTR tv330[ebp]
	mov	DWORD PTR $T232053[ebp], edx
	mov	eax, DWORD PTR $T232056[ebp]
	mov	ecx, DWORD PTR $T232053[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 408  : 	m_aiGoodyHutUnitAssignments.resize(iMaxEntriesToRead);

	mov	eax, DWORD PTR _iMaxEntriesToRead$[ebp]
	mov	DWORD PTR $T232078[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR $T232077[ebp], ecx
	mov	edx, DWORD PTR $T232077[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR $T232078[ebp]
	jae	SHORT $LN80@Read
	mov	ecx, DWORD PTR $T232078[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T232077[ebp]
	call	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
$LN80@Read:
	mov	edx, DWORD PTR $T232077[ebp]
	add	edx, 8
	mov	DWORD PTR $T232068[ebp], edx
	mov	eax, DWORD PTR $T232068[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR $T232078[ebp]
	jae	SHORT $LN85@Read
	mov	edx, DWORD PTR $T232068[ebp]
	mov	DWORD PTR tv349[ebp], edx
	jmp	SHORT $LN86@Read
$LN85@Read:
	lea	eax, DWORD PTR $T232078[ebp]
	mov	DWORD PTR tv349[ebp], eax
$LN86@Read:
	mov	ecx, DWORD PTR tv349[ebp]
	mov	DWORD PTR $T232074[ebp], ecx
	mov	edx, DWORD PTR $T232077[ebp]
	mov	eax, DWORD PTR $T232074[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], ecx

; 409  : 
; 410  : 	for(int i = 0; i < iMaxEntriesToRead; i++)

	mov	DWORD PTR _i$225088[ebp], 0
	jmp	SHORT $LN9@Read
$LN8@Read:
	mov	edx, DWORD PTR _i$225088[ebp]
	add	edx, 1
	mov	DWORD PTR _i$225088[ebp], edx
$LN9@Read:
	mov	eax, DWORD PTR _i$225088[ebp]
	cmp	eax, DWORD PTR _iMaxEntriesToRead$[ebp]
	jge	SHORT $LN7@Read

; 411  : 	{
; 412  : 		kStream >> m_aiGoodyHutPlots[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _i$225088[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T232085[ebp], ecx
	mov	edx, DWORD PTR $T232085[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 413  : 		m_aiGoodyHutUnitAssignments[i].Clear();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _i$225088[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T232092[ebp], eax
	mov	ecx, DWORD PTR $T232092[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T232092[ebp]
	mov	DWORD PTR [edx+4], -1

; 414  : 		kStream >> m_aiGoodyHutUnitAssignments[i].m_iUnitID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _i$225088[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T232099[ebp], eax
	mov	ecx, DWORD PTR $T232099[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 415  : 	}

	jmp	$LN8@Read
$LN7@Read:

; 416  : 
; 417  : 	// Skip any ones that go over the limit
; 418  : 	for(int i = iMaxEntriesToRead; i < iEntriesToRead; i++)

	mov	edx, DWORD PTR _iMaxEntriesToRead$[ebp]
	mov	DWORD PTR _i$225092[ebp], edx
	jmp	SHORT $LN6@Read
$LN5@Read:
	mov	eax, DWORD PTR _i$225092[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225092[ebp], eax
$LN6@Read:
	mov	ecx, DWORD PTR _i$225092[ebp]
	cmp	ecx, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN4@Read

; 419  : 	{
; 420  : 		int iDummy;
; 421  : 		kStream >> iDummy;

	lea	edx, DWORD PTR _iDummy$225096[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 422  : 		kStream >> iDummy;

	lea	eax, DWORD PTR _iDummy$225096[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 423  : 	}

	jmp	SHORT $LN5@Read
$LN4@Read:

; 424  : 
; 425  : 	int iTemp;
; 426  : 	kStream >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 427  : 	m_eReconState = (ReconState)iTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR [edx+28], eax

; 428  : 	kStream >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 429  : 	m_eNavalReconState = (ReconState)iTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR [edx+32], eax

; 430  : 
; 431  : 	kStream >> m_iExplorersDisbanded;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 432  : 	kStream >> m_iLastTurnWorkerDisbanded;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 433  : 	kStream >> m_iVisibleAntiquitySites;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 434  : 
; 435  : 	kStream >> iEntriesToRead;

	lea	ecx, DWORD PTR _iEntriesToRead$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 436  : 	for(int i = 0; i < iEntriesToRead; i++)

	mov	DWORD PTR _i$225100[ebp], 0
	jmp	SHORT $LN3@Read
$LN2@Read:
	mov	edx, DWORD PTR _i$225100[ebp]
	add	edx, 1
	mov	DWORD PTR _i$225100[ebp], edx
$LN3@Read:
	mov	eax, DWORD PTR _i$225100[ebp]
	cmp	eax, DWORD PTR _iEntriesToRead$[ebp]
	jge	SHORT $LN19@Read

; 437  : 	{
; 438  : 		kStream >> m_RequestedSavings[i];

	mov	ecx, DWORD PTR _i$225100[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+112]
	push	ecx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z ; operator>>
	add	esp, 8
	jmp	SHORT $LN2@Read
$LN19@Read:

; 439  : 	}
; 440  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvEconomicAI@@QAEXAAVFDataStream@@@Z ENDP		; CvEconomicAI::Read
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z ; operator<<
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
PUBLIC	?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z	; CvEconomicAI::Write
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T232238 = -120						; size = 4
$T232231 = -116						; size = 4
$T232212 = -112						; size = 4
$T232205 = -108						; size = 4
$T232198 = -104						; size = 4
$T232191 = -100						; size = 4
$T232187 = -96						; size = 4
$T232180 = -92						; size = 4
$T232173 = -88						; size = 4
$T232166 = -84						; size = 4
$T232159 = -80						; size = 4
$T232152 = -76						; size = 4
$T232151 = -72						; size = 4
$T232147 = -68						; size = 4
$T232146 = -64						; size = 4
$T232136 = -60						; size = 4
$T232135 = -56						; size = 4
$T232134 = -52						; size = 4
$T232133 = -48						; size = 4
$T232132 = -44						; size = 4
$T232131 = -40						; size = 8
$T232130 = -32						; size = 8
$T232129 = -24						; size = 4
_ui$225166 = -20					; size = 4
_ui$225156 = -16					; size = 4
_ui$225151 = -12					; size = 4
_ui$225146 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z PROC	; CvEconomicAI::Write, COMDAT
; _this$ = ecx

; 444  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 	// Current version number
; 446  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 447  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 448  : 
; 449  : 	FAssertMsg(GC.getNumEconomicAIStrategyInfos() > 0, "Number of AIStrategies to serialize is expected to greater than 0");
; 450  : 	kStream << m_pAIStrategies->GetNumEconomicAIStrategies();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	call	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
	mov	DWORD PTR $T232129[ebp], eax
	lea	edx, DWORD PTR $T232129[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 451  : 	kStream << ArrayWrapper<bool>(m_pAIStrategies->GetNumEconomicAIStrategies(), m_pabUsingStrategy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T232147[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	call	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
	mov	DWORD PTR $T232146[ebp], eax
	mov	eax, DWORD PTR $T232147[ebp]
	mov	DWORD PTR $T232130[ebp], eax
	mov	ecx, DWORD PTR $T232146[ebp]
	mov	DWORD PTR $T232130[ebp+4], ecx
	lea	edx, DWORD PTR $T232130[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
	add	esp, 8

; 452  : 	kStream << ArrayWrapper<int>(m_pAIStrategies->GetNumEconomicAIStrategies(), m_paiTurnStrategyAdopted);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T232152[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	call	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
	mov	DWORD PTR $T232151[ebp], eax
	mov	ecx, DWORD PTR $T232152[ebp]
	mov	DWORD PTR $T232131[ebp], ecx
	mov	edx, DWORD PTR $T232151[ebp]
	mov	DWORD PTR $T232131[ebp+4], edx
	lea	eax, DWORD PTR $T232131[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
	add	esp, 8

; 453  : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$225146[ebp], 0
	jmp	SHORT $LN12@Write
$LN11@Write:
	mov	edx, DWORD PTR _ui$225146[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$225146[ebp], edx
$LN12@Write:
	cmp	DWORD PTR _ui$225146[ebp], 6
	jae	SHORT $LN10@Write

; 454  : 	{
; 455  : 		kStream << m_auiYields[ui];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _ui$225146[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T232159[ebp], eax
	mov	ecx, DWORD PTR $T232159[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 456  : 	}

	jmp	SHORT $LN11@Write
$LN10@Write:

; 457  : 
; 458  : 	kStream << m_bExplorationPlotsDirty;

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 459  : 	kStream << m_aiExplorationPlots.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR $T232166[ebp], ecx
	mov	edx, DWORD PTR $T232166[ebp]
	mov	DWORD PTR $T232132[ebp], edx
	lea	eax, DWORD PTR $T232132[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 460  : 	for(uint ui = 0; ui < m_aiExplorationPlots.size(); ui++)

	mov	DWORD PTR _ui$225151[ebp], 0
	jmp	SHORT $LN9@Write
$LN8@Write:
	mov	ecx, DWORD PTR _ui$225151[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225151[ebp], ecx
$LN9@Write:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR $T232173[ebp], eax
	mov	ecx, DWORD PTR _ui$225151[ebp]
	cmp	ecx, DWORD PTR $T232173[ebp]
	jae	SHORT $LN7@Write

; 461  : 	{
; 462  : 		kStream << m_aiExplorationPlots[ui];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	ecx, DWORD PTR _ui$225151[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T232180[ebp], edx
	mov	eax, DWORD PTR $T232180[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 463  : 		kStream << m_aiExplorationPlotRatings[ui];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _ui$225151[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T232187[ebp], ecx
	mov	edx, DWORD PTR $T232187[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 464  : 	}

	jmp	SHORT $LN8@Write
$LN7@Write:

; 465  : 
; 466  : 	kStream << m_aiGoodyHutPlots.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T232191[ebp], ecx
	mov	edx, DWORD PTR $T232191[ebp]
	mov	DWORD PTR $T232133[ebp], edx
	lea	eax, DWORD PTR $T232133[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 467  : 	for(uint ui = 0; ui < m_aiGoodyHutPlots.size(); ui++)

	mov	DWORD PTR _ui$225156[ebp], 0
	jmp	SHORT $LN6@Write
$LN5@Write:
	mov	ecx, DWORD PTR _ui$225156[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225156[ebp], ecx
$LN6@Write:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR $T232198[ebp], eax
	mov	ecx, DWORD PTR _ui$225156[ebp]
	cmp	ecx, DWORD PTR $T232198[ebp]
	jae	SHORT $LN4@Write

; 468  : 	{
; 469  : 		kStream << m_aiGoodyHutPlots[ui];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR _ui$225156[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T232205[ebp], edx
	mov	eax, DWORD PTR $T232205[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 470  : 		kStream << m_aiGoodyHutUnitAssignments[ui].m_iUnitID;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _ui$225156[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T232212[ebp], ecx
	mov	edx, DWORD PTR $T232212[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 471  : 	}

	jmp	SHORT $LN5@Write
$LN4@Write:

; 472  : 
; 473  : 	kStream << (int)m_eReconState;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T232134[ebp], ecx
	lea	edx, DWORD PTR $T232134[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 474  : 	kStream << (int)m_eNavalReconState;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T232135[ebp], ecx
	lea	edx, DWORD PTR $T232135[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 475  : 	kStream << m_iExplorersDisbanded;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 476  : 	kStream << m_iLastTurnWorkerDisbanded;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 477  : 	kStream << m_iVisibleAntiquitySites;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 478  : 
; 479  : 	kStream << (int)m_RequestedSavings.size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR $T232231[ebp], ecx
	mov	edx, DWORD PTR $T232231[ebp]
	mov	DWORD PTR $T232136[ebp], edx
	lea	eax, DWORD PTR $T232136[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 480  : 	for(uint ui = 0; ui < m_RequestedSavings.size(); ui++)

	mov	DWORD PTR _ui$225166[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	ecx, DWORD PTR _ui$225166[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225166[ebp], ecx
$LN3@Write:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR $T232238[ebp], eax
	mov	ecx, DWORD PTR _ui$225166[ebp]
	cmp	ecx, DWORD PTR $T232238[ebp]
	jae	SHORT $LN13@Write

; 481  : 	{
; 482  : 		kStream << m_RequestedSavings[ui];

	mov	edx, DWORD PTR _ui$225166[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+112]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z ; operator<<
	add	esp, 8
	jmp	SHORT $LN2@Write
$LN13@Write:

; 483  : 	}
; 484  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvEconomicAI@@QAEXAAVFDataStream@@@Z ENDP	; CvEconomicAI::Write
_TEXT	ENDS
PUBLIC	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ	; CvEconomicAI::GetPlayer
; Function compile flags: /Odtp
;	COMDAT ?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ PROC	; CvEconomicAI::GetPlayer, COMDAT
; _this$ = ecx

; 488  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 489  : 	return m_pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 490  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ENDP	; CvEconomicAI::GetPlayer
_TEXT	ENDS
PUBLIC	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
; Function compile flags: /Odtp
;	COMDAT ?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ PROC ; CvEconomicAI::GetEconomicAIStrategies, COMDAT
; _this$ = ecx

; 494  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 495  : 	return m_pAIStrategies;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 496  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ENDP ; CvEconomicAI::GetEconomicAIStrategies
_TEXT	ENDS
PUBLIC	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
; Function compile flags: /Odtp
;	COMDAT ?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z PROC ; CvEconomicAI::IsUsingStrategy, COMDAT
; _this$ = ecx

; 504  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_pabUsingStrategy[(int) eStrategy];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	al, BYTE PTR [ecx+edx]

; 506  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ENDP ; CvEconomicAI::IsUsingStrategy
_TEXT	ENDS
PUBLIC	?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::LogStrategy
PUBLIC	?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z ; CvEconomicAI::SetTurnStrategyAdopted
PUBLIC	?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::SetUsingStrategy
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Odtp
;	COMDAT ?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T232253 = -4						; size = 4
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z PROC ; CvEconomicAI::SetUsingStrategy, COMDAT
; _this$ = ecx

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 	if(m_pabUsingStrategy[eStrategy] != bValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	movzx	eax, BYTE PTR [ecx+edx]
	movzx	ecx, BYTE PTR _bValue$[ebp]
	cmp	eax, ecx
	je	SHORT $LN4@SetUsingSt

; 512  : 	{
; 513  : 		m_pabUsingStrategy[eStrategy] = bValue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	mov	dl, BYTE PTR _bValue$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 514  : 
; 515  : 		if(bValue)

	movzx	eax, BYTE PTR _bValue$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetUsingSt

; 516  : 		{
; 517  : 			SetTurnStrategyAdopted(eStrategy, GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232253[ebp], ecx
	mov	ecx, DWORD PTR $T232253[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z ; CvEconomicAI::SetTurnStrategyAdopted

; 518  : 		}
; 519  : 		else

	jmp	SHORT $LN1@SetUsingSt
$LN2@SetUsingSt:

; 520  : 		{
; 521  : 			SetTurnStrategyAdopted(eStrategy, -1);

	push	-1
	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z ; CvEconomicAI::SetTurnStrategyAdopted
$LN1@SetUsingSt:

; 522  : 		}
; 523  : 
; 524  : 		LogStrategy(eStrategy, bValue);

	movzx	ecx, BYTE PTR _bValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::LogStrategy
$LN4@SetUsingSt:

; 525  : 	}
; 526  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z ENDP ; CvEconomicAI::SetUsingStrategy
_TEXT	ENDS
PUBLIC	?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::GetTurnStrategyAdopted
; Function compile flags: /Odtp
;	COMDAT ?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z PROC ; CvEconomicAI::GetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 534  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 	return m_paiTurnStrategyAdopted[(int) eStrategy];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 536  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z ENDP ; CvEconomicAI::GetTurnStrategyAdopted
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_iValue$ = 12						; size = 4
?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z PROC ; CvEconomicAI::SetTurnStrategyAdopted, COMDAT
; _this$ = ecx

; 540  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 541  : 	if(m_paiTurnStrategyAdopted[(int) eStrategy] != iValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _eStrategy$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR _iValue$[ebp]
	je	SHORT $LN2@SetTurnStr

; 542  : 	{
; 543  : 		m_paiTurnStrategyAdopted[(int) eStrategy] = iValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _eStrategy$[ebp]
	mov	ecx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN2@SetTurnStr:

; 544  : 	}
; 545  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTurnStrategyAdopted@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@H@Z ENDP ; CvEconomicAI::SetTurnStrategyAdopted
_TEXT	ENDS
PUBLIC	?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ ; CvEconomicAI::DisbandExtraArchaeologists
PUBLIC	?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DisbandExtraWorkers
PUBLIC	?DoPlotPurchases@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoPlotPurchases
PUBLIC	?DoHurry@CvEconomicAI@@AAEXXZ			; CvEconomicAI::DoHurry
PUBLIC	??_C@_0BM@BLKCLAIM@EconomicStrategyCanActivate?$AA@ ; `string'
PUBLIC	?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_StartedPiety
PUBLIC	??_C@_0CB@EPJOLIIN@ECONOMICAISTRATEGY_STARTED_PIETY@ ; `string'
PUBLIC	?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ConcertTour
PUBLIC	??_C@_0CA@PBGIMIOP@ECONOMICAISTRATEGY_CONCERT_TOUR?$AA@ ; `string'
PUBLIC	?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedGuilds
PUBLIC	??_C@_0BP@OKANEKEH@ECONOMICAISTRATEGY_NEED_GUILDS?$AA@ ; `string'
PUBLIC	?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedMuseums
PUBLIC	??_C@_0CA@LJEEDGCK@ECONOMICAISTRATEGY_NEED_MUSEUMS?$AA@ ; `string'
PUBLIC	?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists
PUBLIC	??_C@_0CJ@OJNNMPCJ@ECONOMICAISTRATEGY_ENOUGH_ARCHAE@ ; `string'
PUBLIC	?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists
PUBLIC	??_C@_0CH@JBCPGFFK@ECONOMICAISTRATEGY_NEED_ARCHAEOL@ ; `string'
PUBLIC	?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TechLeader
PUBLIC	??_C@_0BP@LMEKCLA@ECONOMICAISTRATEGY_TECH_LEADER?$AA@ ; `string'
PUBLIC	?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion
PUBLIC	??_C@_0CH@GNLJCNLK@ECONOMICAISTRATEGY_DEVELOPING_RE@ ; `string'
PUBLIC	?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap
PUBLIC	??_C@_0CK@OCGLJEIH@ECONOMICAISTRATEGY_OFFSHORE_EXPA@ ; `string'
PUBLIC	?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NavalMap
PUBLIC	??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@ ; `string'
PUBLIC	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
PUBLIC	??_C@_0CM@MOIMHCNJ@ECONOMICAISTRATEGY_GS_SPACESHIP_@ ; `string'
PUBLIC	?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship
PUBLIC	??_C@_0CA@GMLPPGJD@ECONOMICAISTRATEGY_GS_SPACESHIP?$AA@ ; `string'
PUBLIC	?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy
PUBLIC	??_C@_0CA@DAOBKCOE@ECONOMICAISTRATEGY_GS_DIPLOMACY?$AA@ ; `string'
PUBLIC	?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Conquest
PUBLIC	??_C@_0BP@JJIICCGD@ECONOMICAISTRATEGY_GS_CONQUEST?$AA@ ; `string'
PUBLIC	?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Culture
PUBLIC	??_C@_0BO@KOACKBDH@ECONOMICAISTRATEGY_GS_CULTURE?$AA@ ; `string'
PUBLIC	?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy
PUBLIC	??_C@_0CD@HFHBGCBF@ECONOMICAISTRATEGY_GROW_LIKE_CRA@ ; `string'
PUBLIC	?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy
PUBLIC	??_C@_0CF@GIOLCFEP@ECONOMICAISTRATEGY_EXPAND_LIKE_C@ ; `string'
PUBLIC	?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast
PUBLIC	??_C@_0CH@HOLHLIDH@ECONOMICAISTRATEGY_MOSTLY_ON_THE@ ; `string'
PUBLIC	?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents
PUBLIC	??_C@_0DF@EDEAHICP@ECONOMICAISTRATEGY_REALLY_EXPAND@ ; `string'
PUBLIC	?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents
PUBLIC	??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@ ; `string'
PUBLIC	?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_IslandStart
PUBLIC	??_C@_0CA@GADCJDII@ECONOMICAISTRATEGY_ISLAND_START?$AA@ ; `string'
PUBLIC	?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TooManyUnits
PUBLIC	??_C@_0CC@ECECMFD@ECONOMICAISTRATEGY_TOO_MANY_UNIT@ ; `string'
PUBLIC	?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings
PUBLIC	??_C@_0CJ@BNOKMBDA@ECONOMICAISTRATEGY_HALT_GROWTH_B@ ; `string'
PUBLIC	?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_LosingMoney
PUBLIC	??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@ ; `string'
PUBLIC	?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities
PUBLIC	??_C@_0CP@JJNEAOJM@ECONOMICAISTRATEGY_ONE_OR_FEWER_@ ; `string'
PUBLIC	??_C@_0CP@DDBIBPAO@ECONOMICAISTRATEGY_NEED_IMPROVEM@ ; `string'
PUBLIC	?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
PUBLIC	??_C@_0CJ@IKFAHECC@ECONOMICAISTRATEGY_NEED_IMPROVEM@ ; `string'
PUBLIC	?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState
PUBLIC	??_C@_0CJ@MGEMDMLI@ECONOMICAISTRATEGY_TRADE_WITH_CI@ ; `string'
PUBLIC	?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_FoundCity
PUBLIC	??_C@_0BO@DCCLOFML@ECONOMICAISTRATEGY_FOUND_CITY?$AA@ ; `string'
PUBLIC	?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement
PUBLIC	??_C@_0DG@KIGJKIPP@ECONOMICAISTRATEGY_CITIES_NEED_N@ ; `string'
PUBLIC	?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth
PUBLIC	??_C@_0CM@CPBLKKDC@ECONOMICAISTRATEGY_CITIES_NEED_N@ ; `string'
PUBLIC	?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical
PUBLIC	??_C@_0CL@FDIIBLEP@ECONOMICAISTRATEGY_NEED_HAPPINES@ ; `string'
PUBLIC	?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappiness
PUBLIC	??_C@_0CC@LFBHKCEL@ECONOMICAISTRATEGY_NEED_HAPPINES@ ; `string'
PUBLIC	?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion
PUBLIC	??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@ ; `string'
PUBLIC	?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion
PUBLIC	??_C@_0CD@CKIOFBEO@ECONOMICAISTRATEGY_EARLY_EXPANSI@ ; `string'
PUBLIC	?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughReconSea
PUBLIC	??_C@_0CE@KPCDAIBO@ECONOMICAISTRATEGY_ENOUGH_RECON_@ ; `string'
PUBLIC	?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedReconSea
PUBLIC	??_C@_0CC@OOHNBBFB@ECONOMICAISTRATEGY_NEED_RECON_SE@ ; `string'
PUBLIC	?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea
PUBLIC	??_C@_0CJ@OIJNFMCA@ECONOMICAISTRATEGY_REALLY_NEED_R@ ; `string'
PUBLIC	?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughRecon
PUBLIC	??_C@_0CA@LMJCENAC@ECONOMICAISTRATEGY_ENOUGH_RECON?$AA@ ; `string'
PUBLIC	?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedRecon
PUBLIC	??_C@_0BO@IOIAMMNH@ECONOMICAISTRATEGY_NEED_RECON?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?DoAntiquitySites@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoAntiquitySites
PUBLIC	?DoReconState@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoReconState
PUBLIC	?LogCityMonitor@CvEconomicAI@@QAEXXZ		; CvEconomicAI::LogCityMonitor
PUBLIC	?LogMonitor@CvEconomicAI@@QAEXXZ		; CvEconomicAI::LogMonitor
PUBLIC	?UpdatePlots@CvEconomicAI@@QAEXXZ		; CvEconomicAI::UpdatePlots
PUBLIC	__$ArrayPad$
PUBLIC	?DoTurn@CvEconomicAI@@QAEXXZ			; CvEconomicAI::DoTurn
EXTRN	?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ:PROC	; CvPlayerCulture::DoSwapGreatWorks
EXTRN	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ:PROC ; CvPlayer::GetCulture
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z:PROC ; CvFlavorManager::ChangeFlavors
EXTRN	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ:PROC ; CvPlayer::GetFlavorManager
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z:PROC	; CvTeamTechs::HasTech
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
;	COMDAT ??_C@_0BM@BLKCLAIM@EconomicStrategyCanActivate?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BM@BLKCLAIM@EconomicStrategyCanActivate?$AA@ DB 'EconomicStrategyC'
	DB	'anActivate', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EPJOLIIN@ECONOMICAISTRATEGY_STARTED_PIETY@
CONST	SEGMENT
??_C@_0CB@EPJOLIIN@ECONOMICAISTRATEGY_STARTED_PIETY@ DB 'ECONOMICAISTRATE'
	DB	'GY_STARTED_PIETY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PBGIMIOP@ECONOMICAISTRATEGY_CONCERT_TOUR?$AA@
CONST	SEGMENT
??_C@_0CA@PBGIMIOP@ECONOMICAISTRATEGY_CONCERT_TOUR?$AA@ DB 'ECONOMICAISTR'
	DB	'ATEGY_CONCERT_TOUR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OKANEKEH@ECONOMICAISTRATEGY_NEED_GUILDS?$AA@
CONST	SEGMENT
??_C@_0BP@OKANEKEH@ECONOMICAISTRATEGY_NEED_GUILDS?$AA@ DB 'ECONOMICAISTRA'
	DB	'TEGY_NEED_GUILDS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LJEEDGCK@ECONOMICAISTRATEGY_NEED_MUSEUMS?$AA@
CONST	SEGMENT
??_C@_0CA@LJEEDGCK@ECONOMICAISTRATEGY_NEED_MUSEUMS?$AA@ DB 'ECONOMICAISTR'
	DB	'ATEGY_NEED_MUSEUMS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OJNNMPCJ@ECONOMICAISTRATEGY_ENOUGH_ARCHAE@
CONST	SEGMENT
??_C@_0CJ@OJNNMPCJ@ECONOMICAISTRATEGY_ENOUGH_ARCHAE@ DB 'ECONOMICAISTRATE'
	DB	'GY_ENOUGH_ARCHAEOLOGISTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JBCPGFFK@ECONOMICAISTRATEGY_NEED_ARCHAEOL@
CONST	SEGMENT
??_C@_0CH@JBCPGFFK@ECONOMICAISTRATEGY_NEED_ARCHAEOL@ DB 'ECONOMICAISTRATE'
	DB	'GY_NEED_ARCHAEOLOGISTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LMEKCLA@ECONOMICAISTRATEGY_TECH_LEADER?$AA@
CONST	SEGMENT
??_C@_0BP@LMEKCLA@ECONOMICAISTRATEGY_TECH_LEADER?$AA@ DB 'ECONOMICAISTRAT'
	DB	'EGY_TECH_LEADER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GNLJCNLK@ECONOMICAISTRATEGY_DEVELOPING_RE@
CONST	SEGMENT
??_C@_0CH@GNLJCNLK@ECONOMICAISTRATEGY_DEVELOPING_RE@ DB 'ECONOMICAISTRATE'
	DB	'GY_DEVELOPING_RELIGION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OCGLJEIH@ECONOMICAISTRATEGY_OFFSHORE_EXPA@
CONST	SEGMENT
??_C@_0CK@OCGLJEIH@ECONOMICAISTRATEGY_OFFSHORE_EXPA@ DB 'ECONOMICAISTRATE'
	DB	'GY_OFFSHORE_EXPANSION_MAP', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@
CONST	SEGMENT
??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@ DB 'ECONOMICAISTRATE'
	DB	'GY_NAVAL_MAP', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MOIMHCNJ@ECONOMICAISTRATEGY_GS_SPACESHIP_@
CONST	SEGMENT
??_C@_0CM@MOIMHCNJ@ECONOMICAISTRATEGY_GS_SPACESHIP_@ DB 'ECONOMICAISTRATE'
	DB	'GY_GS_SPACESHIP_HOMESTRETCH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GMLPPGJD@ECONOMICAISTRATEGY_GS_SPACESHIP?$AA@
CONST	SEGMENT
??_C@_0CA@GMLPPGJD@ECONOMICAISTRATEGY_GS_SPACESHIP?$AA@ DB 'ECONOMICAISTR'
	DB	'ATEGY_GS_SPACESHIP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAOBKCOE@ECONOMICAISTRATEGY_GS_DIPLOMACY?$AA@
CONST	SEGMENT
??_C@_0CA@DAOBKCOE@ECONOMICAISTRATEGY_GS_DIPLOMACY?$AA@ DB 'ECONOMICAISTR'
	DB	'ATEGY_GS_DIPLOMACY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JJIICCGD@ECONOMICAISTRATEGY_GS_CONQUEST?$AA@
CONST	SEGMENT
??_C@_0BP@JJIICCGD@ECONOMICAISTRATEGY_GS_CONQUEST?$AA@ DB 'ECONOMICAISTRA'
	DB	'TEGY_GS_CONQUEST', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KOACKBDH@ECONOMICAISTRATEGY_GS_CULTURE?$AA@
CONST	SEGMENT
??_C@_0BO@KOACKBDH@ECONOMICAISTRATEGY_GS_CULTURE?$AA@ DB 'ECONOMICAISTRAT'
	DB	'EGY_GS_CULTURE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HFHBGCBF@ECONOMICAISTRATEGY_GROW_LIKE_CRA@
CONST	SEGMENT
??_C@_0CD@HFHBGCBF@ECONOMICAISTRATEGY_GROW_LIKE_CRA@ DB 'ECONOMICAISTRATE'
	DB	'GY_GROW_LIKE_CRAZY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GIOLCFEP@ECONOMICAISTRATEGY_EXPAND_LIKE_C@
CONST	SEGMENT
??_C@_0CF@GIOLCFEP@ECONOMICAISTRATEGY_EXPAND_LIKE_C@ DB 'ECONOMICAISTRATE'
	DB	'GY_EXPAND_LIKE_CRAZY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HOLHLIDH@ECONOMICAISTRATEGY_MOSTLY_ON_THE@
CONST	SEGMENT
??_C@_0CH@HOLHLIDH@ECONOMICAISTRATEGY_MOSTLY_ON_THE@ DB 'ECONOMICAISTRATE'
	DB	'GY_MOSTLY_ON_THE_COAST', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EDEAHICP@ECONOMICAISTRATEGY_REALLY_EXPAND@
CONST	SEGMENT
??_C@_0DF@EDEAHICP@ECONOMICAISTRATEGY_REALLY_EXPAND@ DB 'ECONOMICAISTRATE'
	DB	'GY_REALLY_EXPAND_TO_OTHER_CONTINENTS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@
CONST	SEGMENT
??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@ DB 'ECONOMICAISTRATE'
	DB	'GY_EXPAND_TO_OTHER_CONTINENTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GADCJDII@ECONOMICAISTRATEGY_ISLAND_START?$AA@
CONST	SEGMENT
??_C@_0CA@GADCJDII@ECONOMICAISTRATEGY_ISLAND_START?$AA@ DB 'ECONOMICAISTR'
	DB	'ATEGY_ISLAND_START', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ECECMFD@ECONOMICAISTRATEGY_TOO_MANY_UNIT@
CONST	SEGMENT
??_C@_0CC@ECECMFD@ECONOMICAISTRATEGY_TOO_MANY_UNIT@ DB 'ECONOMICAISTRATEG'
	DB	'Y_TOO_MANY_UNITS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BNOKMBDA@ECONOMICAISTRATEGY_HALT_GROWTH_B@
CONST	SEGMENT
??_C@_0CJ@BNOKMBDA@ECONOMICAISTRATEGY_HALT_GROWTH_B@ DB 'ECONOMICAISTRATE'
	DB	'GY_HALT_GROWTH_BUILDINGS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
CONST	SEGMENT
??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@ DB 'ECONOMICAISTRA'
	DB	'TEGY_LOSING_MONEY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JJNEAOJM@ECONOMICAISTRATEGY_ONE_OR_FEWER_@
CONST	SEGMENT
??_C@_0CP@JJNEAOJM@ECONOMICAISTRATEGY_ONE_OR_FEWER_@ DB 'ECONOMICAISTRATE'
	DB	'GY_ONE_OR_FEWER_COASTAL_CITIES', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DDBIBPAO@ECONOMICAISTRATEGY_NEED_IMPROVEM@
CONST	SEGMENT
??_C@_0CP@DDBIBPAO@ECONOMICAISTRATEGY_NEED_IMPROVEM@ DB 'ECONOMICAISTRATE'
	DB	'GY_NEED_IMPROVEMENT_PRODUCTION', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IKFAHECC@ECONOMICAISTRATEGY_NEED_IMPROVEM@
CONST	SEGMENT
??_C@_0CJ@IKFAHECC@ECONOMICAISTRATEGY_NEED_IMPROVEM@ DB 'ECONOMICAISTRATE'
	DB	'GY_NEED_IMPROVEMENT_FOOD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MGEMDMLI@ECONOMICAISTRATEGY_TRADE_WITH_CI@
CONST	SEGMENT
??_C@_0CJ@MGEMDMLI@ECONOMICAISTRATEGY_TRADE_WITH_CI@ DB 'ECONOMICAISTRATE'
	DB	'GY_TRADE_WITH_CITY_STATE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DCCLOFML@ECONOMICAISTRATEGY_FOUND_CITY?$AA@
CONST	SEGMENT
??_C@_0BO@DCCLOFML@ECONOMICAISTRATEGY_FOUND_CITY?$AA@ DB 'ECONOMICAISTRAT'
	DB	'EGY_FOUND_CITY', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KIGJKIPP@ECONOMICAISTRATEGY_CITIES_NEED_N@
CONST	SEGMENT
??_C@_0DG@KIGJKIPP@ECONOMICAISTRATEGY_CITIES_NEED_N@ DB 'ECONOMICAISTRATE'
	DB	'GY_CITIES_NEED_NAVAL_TILE_IMPROVEMENT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CPBLKKDC@ECONOMICAISTRATEGY_CITIES_NEED_N@
CONST	SEGMENT
??_C@_0CM@CPBLKKDC@ECONOMICAISTRATEGY_CITIES_NEED_N@ DB 'ECONOMICAISTRATE'
	DB	'GY_CITIES_NEED_NAVAL_GROWTH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FDIIBLEP@ECONOMICAISTRATEGY_NEED_HAPPINES@
CONST	SEGMENT
??_C@_0CL@FDIIBLEP@ECONOMICAISTRATEGY_NEED_HAPPINES@ DB 'ECONOMICAISTRATE'
	DB	'GY_NEED_HAPPINESS_CRITICAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LFBHKCEL@ECONOMICAISTRATEGY_NEED_HAPPINES@
CONST	SEGMENT
??_C@_0CC@LFBHKCEL@ECONOMICAISTRATEGY_NEED_HAPPINES@ DB 'ECONOMICAISTRATE'
	DB	'GY_NEED_HAPPINESS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@
CONST	SEGMENT
??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@ DB 'ECONOMICAISTRATE'
	DB	'GY_ENOUGH_EXPANSION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CKIOFBEO@ECONOMICAISTRATEGY_EARLY_EXPANSI@
CONST	SEGMENT
??_C@_0CD@CKIOFBEO@ECONOMICAISTRATEGY_EARLY_EXPANSI@ DB 'ECONOMICAISTRATE'
	DB	'GY_EARLY_EXPANSION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KPCDAIBO@ECONOMICAISTRATEGY_ENOUGH_RECON_@
CONST	SEGMENT
??_C@_0CE@KPCDAIBO@ECONOMICAISTRATEGY_ENOUGH_RECON_@ DB 'ECONOMICAISTRATE'
	DB	'GY_ENOUGH_RECON_SEA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OOHNBBFB@ECONOMICAISTRATEGY_NEED_RECON_SE@
CONST	SEGMENT
??_C@_0CC@OOHNBBFB@ECONOMICAISTRATEGY_NEED_RECON_SE@ DB 'ECONOMICAISTRATE'
	DB	'GY_NEED_RECON_SEA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OIJNFMCA@ECONOMICAISTRATEGY_REALLY_NEED_R@
CONST	SEGMENT
??_C@_0CJ@OIJNFMCA@ECONOMICAISTRATEGY_REALLY_NEED_R@ DB 'ECONOMICAISTRATE'
	DB	'GY_REALLY_NEED_RECON_SEA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMJCENAC@ECONOMICAISTRATEGY_ENOUGH_RECON?$AA@
CONST	SEGMENT
??_C@_0CA@LMJCENAC@ECONOMICAISTRATEGY_ENOUGH_RECON?$AA@ DB 'ECONOMICAISTR'
	DB	'ATEGY_ENOUGH_RECON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IOIAMMNH@ECONOMICAISTRATEGY_NEED_RECON?$AA@
CONST	SEGMENT
??_C@_0BO@IOIAMMNH@ECONOMICAISTRATEGY_NEED_RECON?$AA@ DB 'ECONOMICAISTRAT'
	DB	'EGY_NEED_RECON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoTurn@CvEconomicAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$1
__ehfuncinfo$?DoTurn@CvEconomicAI@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DoTurn@CvEconomicAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?DoTurn@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
tv792 = -176						; size = 4
tv785 = -172						; size = 4
tv772 = -168						; size = 4
tv959 = -164						; size = 4
_this$ = -160						; size = 4
$T232371 = -156						; size = 4
$T232367 = -152						; size = 4
$T232363 = -148						; size = 4
$T232359 = -144						; size = 4
$T232351 = -140						; size = 4
$T232347 = -136						; size = 4
$T232332 = -132						; size = 4
$T232320 = -128						; size = 4
$T232316 = -124						; size = 4
$T232312 = -120						; size = 4
$T232311 = -116						; size = 4
$T232302 = -112						; size = 4
$T232298 = -108						; size = 4
$T232294 = -104						; size = 4
$T232290 = -100						; size = 4
$T232286 = -96						; size = 4
$T232285 = -92						; size = 4
$T232276 = -88						; size = 4
$T232272 = -84						; size = 4
$T232271 = -80						; size = 4
_iFlavorLoop$225382 = -76				; size = 4
_bResult$225368 = -69					; size = 1
_args$225367 = -68					; size = 4
_strStrategyName$225242 = -64				; size = 28
__$ArrayPad$ = -36					; size = 4
_pkScriptSystem$225365 = -32				; size = 4
_bAdoptOrEndStrategy$225372 = -28			; size = 1
_bStrategyShouldBeActive$225238 = -27			; size = 1
_bTestStrategyEnd$225230 = -26				; size = 1
_bTestStrategyStart$225222 = -25			; size = 1
_eStrategy$225218 = -24					; size = 4
_pStrategy$225220 = -20					; size = 4
_iStrategiesLoop$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?DoTurn@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::DoTurn, COMDAT
; _this$ = ecx

; 551  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoTurn@CvEconomicAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 552  : 	AI_PERF_FORMAT("AI-perf.csv", ("CvEconomicAI::DoTurn, Turn %03d, %s", GC.getGame().getElapsedGameTurns(), GetPlayer()->getCivilizationShortDescription()) );
; 553  : 
; 554  : 	UpdatePlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots

; 555  : 	LogMonitor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogMonitor@CvEconomicAI@@QAEXXZ	; CvEconomicAI::LogMonitor

; 556  : 	LogCityMonitor();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogCityMonitor@CvEconomicAI@@QAEXXZ	; CvEconomicAI::LogCityMonitor

; 557  : 
; 558  : 	// Functions that need to run before we look at strategies
; 559  : 	DoReconState();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoReconState@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DoReconState

; 560  : 	DoAntiquitySites();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoAntiquitySites@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DoAntiquitySites

; 561  : 
; 562  : 	int iStrategiesLoop = 0;

	mov	DWORD PTR _iStrategiesLoop$[ebp], 0

; 563  : 
; 564  : 	// Loop through all strategies
; 565  : 	for(iStrategiesLoop = 0; iStrategiesLoop < GetEconomicAIStrategies()->GetNumEconomicAIStrategies(); iStrategiesLoop++)

	mov	DWORD PTR _iStrategiesLoop$[ebp], 0
	jmp	SHORT $LN127@DoTurn
$LN126@DoTurn:
	mov	eax, DWORD PTR _iStrategiesLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iStrategiesLoop$[ebp], eax
$LN127@DoTurn:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetNumEconomicAIStrategies@CvEconomicAIStrategyXMLEntries@@QAEHXZ ; CvEconomicAIStrategyXMLEntries::GetNumEconomicAIStrategies
	cmp	DWORD PTR _iStrategiesLoop$[ebp], eax
	jge	$LN125@DoTurn

; 566  : 	{
; 567  : 		EconomicAIStrategyTypes eStrategy = (EconomicAIStrategyTypes) iStrategiesLoop;

	mov	ecx, DWORD PTR _iStrategiesLoop$[ebp]
	mov	DWORD PTR _eStrategy$225218[ebp], ecx

; 568  : 		CvEconomicAIStrategyXMLEntry* pStrategy = GetEconomicAIStrategies()->GetEntry(iStrategiesLoop);

	mov	edx, DWORD PTR _iStrategiesLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$225220[ebp], eax

; 569  : 
; 570  : 		// Minor Civs can't run some Strategies
; 571  : 		if(m_pPlayer->isMinorCiv() && pStrategy->IsNoMinorCivs())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN124@DoTurn
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?IsNoMinorCivs@CvEconomicAIStrategyXMLEntry@@QBE_NXZ ; CvEconomicAIStrategyXMLEntry::IsNoMinorCivs
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN124@DoTurn

; 572  : 		{
; 573  : 			continue;

	jmp	SHORT $LN126@DoTurn
$LN124@DoTurn:

; 574  : 		}
; 575  : 
; 576  : 		bool bTestStrategyStart = true;

	mov	BYTE PTR _bTestStrategyStart$225222[ebp], 1

; 577  : 
; 578  : 		// Do we already have this Strategy adopted?
; 579  : 		if(IsUsingStrategy(eStrategy))

	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN123@DoTurn

; 580  : 		{
; 581  : 			bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$225222[ebp], 0

; 582  : 		}
; 583  : 		else

	jmp	$LN122@DoTurn
$LN123@DoTurn:

; 584  : 		{
; 585  : 			// Has the prereq Tech necessary?
; 586  : 			if(pStrategy->GetTechPrereq() != NO_TECH && !GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechPrereq()))

	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechPrereq
	cmp	eax, -1
	je	SHORT $LN121@DoTurn
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	DWORD PTR $T232271[ebp], eax
	mov	edx, DWORD PTR $T232271[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232272[ebp], eax
	mov	ecx, DWORD PTR $T232272[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232276[ebp], ecx
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetTechPrereq@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechPrereq
	push	eax
	mov	ecx, DWORD PTR $T232276[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN121@DoTurn

; 587  : 			{
; 588  : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$225222[ebp], 0
$LN121@DoTurn:

; 589  : 			}
; 590  : 
; 591  : 			// Has the Tech which obsoletes this Strategy?
; 592  : 			if(bTestStrategyStart && pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	movzx	eax, BYTE PTR _bTestStrategyStart$225222[ebp]
	test	eax, eax
	je	SHORT $LN120@DoTurn
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
	cmp	eax, -1
	je	SHORT $LN120@DoTurn
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	DWORD PTR $T232285[ebp], eax
	mov	ecx, DWORD PTR $T232285[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232286[ebp], eax
	mov	eax, DWORD PTR $T232286[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232290[ebp], eax
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
	push	eax
	mov	ecx, DWORD PTR $T232290[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN120@DoTurn

; 593  : 			{
; 594  : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$225222[ebp], 0
$LN120@DoTurn:

; 595  : 			}
; 596  : 
; 597  : 			// Not time to check this yet?
; 598  : 			if(GC.getGame().getGameTurn() < pStrategy->GetFirstTurnExecuted())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232294[ebp], edx
	mov	ecx, DWORD PTR $T232294[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetFirstTurnExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetFirstTurnExecuted
	cmp	esi, eax
	jge	SHORT $LN122@DoTurn

; 599  : 			{
; 600  : 				bTestStrategyStart = false;

	mov	BYTE PTR _bTestStrategyStart$225222[ebp], 0
$LN122@DoTurn:

; 601  : 			}
; 602  : 		}
; 603  : 
; 604  : 		bool bTestStrategyEnd = false;

	mov	BYTE PTR _bTestStrategyEnd$225230[ebp], 0

; 605  : 
; 606  : 		// Strategy is active, check to see if we should even try to disable it
; 607  : 		if(IsUsingStrategy(eStrategy))

	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	$LN118@DoTurn

; 608  : 		{
; 609  : 			if(pStrategy->GetCheckTriggerTurnCount() > 0)

	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount
	test	eax, eax
	jle	SHORT $LN117@DoTurn

; 610  : 			{
; 611  : 				// Is it a turn where we want to check to see if this Strategy is maintained?
; 612  : 				if((GC.getGame().getGameTurn() - GetTurnStrategyAdopted(eStrategy)) % pStrategy->GetCheckTriggerTurnCount() == 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232298[ebp], edx
	mov	ecx, DWORD PTR $T232298[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::GetTurnStrategyAdopted
	sub	esi, eax
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetCheckTriggerTurnCount@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetCheckTriggerTurnCount
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN117@DoTurn

; 613  : 				{
; 614  : 					bTestStrategyEnd = true;

	mov	BYTE PTR _bTestStrategyEnd$225230[ebp], 1
$LN117@DoTurn:

; 615  : 				}
; 616  : 			}
; 617  : 
; 618  : 			if(bTestStrategyEnd && pStrategy->GetMinimumNumTurnsExecuted() > 0)

	movzx	edx, BYTE PTR _bTestStrategyEnd$225230[ebp]
	test	edx, edx
	je	SHORT $LN118@DoTurn
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
	test	eax, eax
	jle	SHORT $LN118@DoTurn

; 619  : 			{
; 620  : 				// Has the minimum # of turns passed for this Strategy?
; 621  : 				if(GC.getGame().getGameTurn() < GetTurnStrategyAdopted(eStrategy) + pStrategy->GetMinimumNumTurnsExecuted())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T232302[ebp], eax
	mov	ecx, DWORD PTR $T232302[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	esi, eax
	mov	ecx, DWORD PTR _eStrategy$225218[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTurnStrategyAdopted@CvEconomicAI@@QAEHW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::GetTurnStrategyAdopted
	mov	edi, eax
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
	add	edi, eax
	cmp	esi, edi
	jge	SHORT $LN118@DoTurn

; 622  : 				{
; 623  : 					bTestStrategyEnd = false;

	mov	BYTE PTR _bTestStrategyEnd$225230[ebp], 0
$LN118@DoTurn:

; 624  : 				}
; 625  : 			}
; 626  : 		}
; 627  : 
; 628  : 		// Check Strategy Triggers
; 629  : 		// Functionality and existence of specific Strategies is hardcoded here, but data is stored in XML so it's easier to modify
; 630  : 
; 631  : 		if(bTestStrategyStart || bTestStrategyEnd)

	movzx	edx, BYTE PTR _bTestStrategyStart$225222[ebp]
	test	edx, edx
	jne	SHORT $LN112@DoTurn
	movzx	eax, BYTE PTR _bTestStrategyEnd$225230[ebp]
	test	eax, eax
	je	$LN113@DoTurn
$LN112@DoTurn:

; 632  : 		{
; 633  : 			bool bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], 0

; 634  : 
; 635  : 			// Has the Tech which obsoletes this Strategy? If so, Strategy should be deactivated regardless of other factors
; 636  : 			if(pStrategy->GetTechObsolete() != NO_TECH && GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->HasTech((TechTypes) pStrategy->GetTechObsolete()))

	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
	cmp	eax, -1
	je	SHORT $LN111@DoTurn
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	DWORD PTR $T232311[ebp], eax
	mov	ecx, DWORD PTR $T232311[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T232312[ebp], eax
	mov	eax, DWORD PTR $T232312[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T232316[ebp], eax
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetTechObsolete@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetTechObsolete
	push	eax
	mov	ecx, DWORD PTR $T232316[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN111@DoTurn

; 637  : 			{
; 638  : 				bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], 0

; 639  : 			}
; 640  : 			// Strategy isn't obsolete, so test triggers as normal
; 641  : 			else

	jmp	$LN110@DoTurn
$LN111@DoTurn:

; 642  : 			{
; 643  : 				CvString strStrategyName = (CvString) pStrategy->GetType();

	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T232320[ebp], eax
	cmp	DWORD PTR $T232320[ebp], 0
	je	SHORT $LN160@DoTurn
	mov	edx, DWORD PTR $T232320[ebp]
	mov	DWORD PTR tv959[ebp], edx
	jmp	SHORT $LN161@DoTurn
$LN160@DoTurn:
	mov	DWORD PTR tv959[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN161@DoTurn:
	mov	eax, DWORD PTR tv959[ebp]
	push	eax
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 644  : 
; 645  : 				// Check all of the Strategy Triggers
; 646  : 				if(strStrategyName == "ECONOMICAISTRATEGY_NEED_RECON")

	push	OFFSET ??_C@_0BO@IOIAMMNH@ECONOMICAISTRATEGY_NEED_RECON?$AA@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN109@DoTurn

; 647  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedRecon(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedRecon
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN109@DoTurn:

; 648  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_RECON")

	push	OFFSET ??_C@_0CA@LMJCENAC@ECONOMICAISTRATEGY_ENOUGH_RECON?$AA@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN107@DoTurn

; 649  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughRecon(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughRecon
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN107@DoTurn:

; 650  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_REALLY_NEED_RECON_SEA")

	push	OFFSET ??_C@_0CJ@OIJNFMCA@ECONOMICAISTRATEGY_REALLY_NEED_R@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN105@DoTurn

; 651  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN105@DoTurn:

; 652  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_RECON_SEA")

	push	OFFSET ??_C@_0CC@OOHNBBFB@ECONOMICAISTRATEGY_NEED_RECON_SE@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN103@DoTurn

; 653  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedReconSea(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedReconSea
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN103@DoTurn:

; 654  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_RECON_SEA")

	push	OFFSET ??_C@_0CE@KPCDAIBO@ECONOMICAISTRATEGY_ENOUGH_RECON_@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN101@DoTurn

; 655  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughReconSea(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughReconSea
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN101@DoTurn:

; 656  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_EARLY_EXPANSION")

	push	OFFSET ??_C@_0CD@CKIOFBEO@ECONOMICAISTRATEGY_EARLY_EXPANSI@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN99@DoTurn

; 657  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EarlyExpansion(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN99@DoTurn:

; 658  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_EXPANSION")

	push	OFFSET ??_C@_0CE@OFIOLJNP@ECONOMICAISTRATEGY_ENOUGH_EXPANS@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN97@DoTurn

; 659  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughExpansion(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$225218[ebp]
	push	edx
	call	?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN97@DoTurn:

; 660  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_HAPPINESS")

	push	OFFSET ??_C@_0CC@LFBHKCEL@ECONOMICAISTRATEGY_NEED_HAPPINES@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN95@DoTurn

; 661  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedHappiness(eStrategy, m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$225218[ebp]
	push	ecx
	call	?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappiness
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN95@DoTurn:

; 662  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_HAPPINESS_CRITICAL")

	push	OFFSET ??_C@_0CL@FDIIBLEP@ECONOMICAISTRATEGY_NEED_HAPPINES@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN93@DoTurn

; 663  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	call	?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN93@DoTurn:

; 664  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_CITIES_NEED_NAVAL_GROWTH")

	push	OFFSET ??_C@_0CM@CPBLKKDC@ECONOMICAISTRATEGY_CITIES_NEED_N@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN91@DoTurn

; 665  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$225218[ebp]
	push	edx
	call	?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN91@DoTurn:

; 666  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_CITIES_NEED_NAVAL_TILE_IMPROVEMENT")

	push	OFFSET ??_C@_0DG@KIGJKIPP@ECONOMICAISTRATEGY_CITIES_NEED_N@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN89@DoTurn

; 667  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement(eStrategy, m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$225218[ebp]
	push	ecx
	call	?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN89@DoTurn:

; 668  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_FOUND_CITY")

	push	OFFSET ??_C@_0BO@DCCLOFML@ECONOMICAISTRATEGY_FOUND_CITY?$AA@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN87@DoTurn

; 669  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_FoundCity(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	call	?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_FoundCity
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN87@DoTurn:

; 670  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_TRADE_WITH_CITY_STATE")

	push	OFFSET ??_C@_0CJ@MGEMDMLI@ECONOMICAISTRATEGY_TRADE_WITH_CI@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN85@DoTurn

; 671  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_TradeWithCityState(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$225218[ebp]
	push	edx
	call	?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN85@DoTurn:

; 672  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_IMPROVEMENT_FOOD")

	push	OFFSET ??_C@_0CJ@IKFAHECC@ECONOMICAISTRATEGY_NEED_IMPROVEM@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN83@DoTurn

; 673  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedImprovement(m_pPlayer, YIELD_FOOD);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN83@DoTurn:

; 674  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_IMPROVEMENT_PRODUCTION")

	push	OFFSET ??_C@_0CP@DDBIBPAO@ECONOMICAISTRATEGY_NEED_IMPROVEM@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN81@DoTurn

; 675  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedImprovement(m_pPlayer, YIELD_PRODUCTION);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN81@DoTurn:

; 676  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ONE_OR_FEWER_COASTAL_CITIES")

	push	OFFSET ??_C@_0CP@JJNEAOJM@ECONOMICAISTRATEGY_ONE_OR_FEWER_@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN79@DoTurn

; 677  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN79@DoTurn:

; 678  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_LOSING_MONEY")

	push	OFFSET ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN77@DoTurn

; 679  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_LosingMoney(eStrategy, m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$225218[ebp]
	push	ecx
	call	?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_LosingMoney
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN77@DoTurn:

; 680  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_HALT_GROWTH_BUILDINGS")

	push	OFFSET ??_C@_0CJ@BNOKMBDA@ECONOMICAISTRATEGY_HALT_GROWTH_B@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN75@DoTurn

; 681  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN75@DoTurn:

; 682  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_TOO_MANY_UNITS")

	push	OFFSET ??_C@_0CC@ECECMFD@ECONOMICAISTRATEGY_TOO_MANY_UNIT@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN73@DoTurn

; 683  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_TooManyUnits(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TooManyUnits
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN73@DoTurn:

; 684  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ISLAND_START")

	push	OFFSET ??_C@_0CA@GADCJDII@ECONOMICAISTRATEGY_ISLAND_START?$AA@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN71@DoTurn

; 685  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_IslandStart(eStrategy, m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _eStrategy$225218[ebp]
	push	edx
	call	?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_IslandStart
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN71@DoTurn:

; 686  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS")

	push	OFFSET ??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN69@DoTurn

; 687  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN69@DoTurn:

; 688  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS")

	push	OFFSET ??_C@_0DF@EDEAHICP@ECONOMICAISTRATEGY_REALLY_EXPAND@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN67@DoTurn

; 689  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents(m_pPlayer);				

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN67@DoTurn:

; 690  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_MOSTLY_ON_THE_COAST")

	push	OFFSET ??_C@_0CH@HOLHLIDH@ECONOMICAISTRATEGY_MOSTLY_ON_THE@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN65@DoTurn

; 691  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN65@DoTurn:

; 692  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_EXPAND_LIKE_CRAZY")

	push	OFFSET ??_C@_0CF@GIOLCFEP@ECONOMICAISTRATEGY_EXPAND_LIKE_C@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN63@DoTurn

; 693  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy(eStrategy, m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$225218[ebp]
	push	ecx
	call	?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN63@DoTurn:

; 694  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GROW_LIKE_CRAZY")

	push	OFFSET ??_C@_0CD@HFHBGCBF@ECONOMICAISTRATEGY_GROW_LIKE_CRA@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN61@DoTurn

; 695  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	call	?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN61@DoTurn:

; 696  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_CULTURE")

	push	OFFSET ??_C@_0BO@KOACKBDH@ECONOMICAISTRATEGY_GS_CULTURE?$AA@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN59@DoTurn

; 697  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Culture(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Culture
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN59@DoTurn:

; 698  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_CONQUEST")

	push	OFFSET ??_C@_0BP@JJIICCGD@ECONOMICAISTRATEGY_GS_CONQUEST?$AA@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN57@DoTurn

; 699  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Conquest(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Conquest
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN57@DoTurn:

; 700  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_DIPLOMACY")

	push	OFFSET ??_C@_0CA@DAOBKCOE@ECONOMICAISTRATEGY_GS_DIPLOMACY?$AA@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN55@DoTurn

; 701  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Diplomacy(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN55@DoTurn:

; 702  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_SPACESHIP")

	push	OFFSET ??_C@_0CA@GMLPPGJD@ECONOMICAISTRATEGY_GS_SPACESHIP?$AA@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN53@DoTurn

; 703  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_Spaceship(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN53@DoTurn:

; 704  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_GS_SPACESHIP_HOMESTRETCH")

	push	OFFSET ??_C@_0CM@MOIMHCNJ@ECONOMICAISTRATEGY_GS_SPACESHIP_@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN51@DoTurn

; 705  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN51@DoTurn:

; 706  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NAVAL_MAP")

	push	OFFSET ??_C@_0BN@CEBPEMPC@ECONOMICAISTRATEGY_NAVAL_MAP?$AA@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN49@DoTurn

; 707  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NavalMap(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NavalMap
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN49@DoTurn:

; 708  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_OFFSHORE_EXPANSION_MAP")

	push	OFFSET ??_C@_0CK@OCGLJEIH@ECONOMICAISTRATEGY_OFFSHORE_EXPA@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN47@DoTurn

; 709  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN47@DoTurn:

; 710  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_DEVELOPING_RELIGION")

	push	OFFSET ??_C@_0CH@GNLJCNLK@ECONOMICAISTRATEGY_DEVELOPING_RE@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN45@DoTurn

; 711  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_DevelopingReligion(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN45@DoTurn:

; 712  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_TECH_LEADER")

	push	OFFSET ??_C@_0BP@LMEKCLA@ECONOMICAISTRATEGY_TECH_LEADER?$AA@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN43@DoTurn

; 713  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_TechLeader(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_TechLeader
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN43@DoTurn:

; 714  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_ARCHAEOLOGISTS")

	push	OFFSET ??_C@_0CH@JBCPGFFK@ECONOMICAISTRATEGY_NEED_ARCHAEOL@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN41@DoTurn

; 715  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedArchaeologists(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN41@DoTurn:

; 716  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_ENOUGH_ARCHAEOLOGISTS")

	push	OFFSET ??_C@_0CJ@OJNNMPCJ@ECONOMICAISTRATEGY_ENOUGH_ARCHAE@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN39@DoTurn

; 717  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists(m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN39@DoTurn:

; 718  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_MUSEUMS")

	push	OFFSET ??_C@_0CA@LJEEDGCK@ECONOMICAISTRATEGY_NEED_MUSEUMS?$AA@
	lea	eax, DWORD PTR _strStrategyName$225242[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN37@DoTurn

; 719  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedMuseums(m_pPlayer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedMuseums
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	$LN108@DoTurn
$LN37@DoTurn:

; 720  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_NEED_GUILDS")

	push	OFFSET ??_C@_0BP@OKANEKEH@ECONOMICAISTRATEGY_NEED_GUILDS?$AA@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN35@DoTurn

; 721  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_NeedGuilds(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_NeedGuilds
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	SHORT $LN108@DoTurn
$LN35@DoTurn:

; 722  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_CONCERT_TOUR")

	push	OFFSET ??_C@_0CA@PBGIMIOP@ECONOMICAISTRATEGY_CONCERT_TOUR?$AA@
	lea	edx, DWORD PTR _strStrategyName$225242[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN33@DoTurn

; 723  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_ConcertTour(eStrategy, m_pPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	call	?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_ConcertTour
	add	esp, 8
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al
	jmp	SHORT $LN108@DoTurn
$LN33@DoTurn:

; 724  : 				else if(strStrategyName == "ECONOMICAISTRATEGY_STARTED_PIETY")

	push	OFFSET ??_C@_0CB@EPJOLIIN@ECONOMICAISTRATEGY_STARTED_PIETY@
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN31@DoTurn

; 725  : 					bStrategyShouldBeActive = EconomicAIHelpers::IsTestStrategy_StartedPiety(m_pPlayer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ; EconomicAIHelpers::IsTestStrategy_StartedPiety
	add	esp, 4
	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], al

; 726  : 
; 727  : 				// Never found it?  Assume it is scenario-specific and should be on unless disabled by Lua hook
; 728  : 				else

	jmp	SHORT $LN108@DoTurn
$LN31@DoTurn:

; 729  : 				{
; 730  : 					bStrategyShouldBeActive = true;

	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], 1
$LN108@DoTurn:

; 731  : 				}
; 732  : 
; 733  : 				// Check Lua hook
; 734  : 				ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	edx, DWORD PTR $T232332[ebp]
	mov	DWORD PTR tv772[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv772[ebp], eax
	mov	ecx, DWORD PTR tv772[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv772[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$225365[ebp], eax

; 735  : 				if(pkScriptSystem && bStrategyShouldBeActive)

	cmp	DWORD PTR _pkScriptSystem$225365[ebp], 0
	je	$LN29@DoTurn
	movzx	ecx, BYTE PTR _bStrategyShouldBeActive$225238[ebp]
	test	ecx, ecx
	je	$LN29@DoTurn

; 736  : 				{
; 737  : 					CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225367[ebp]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 738  : 					args->Push(iStrategiesLoop);

	mov	edx, DWORD PTR _args$225367[ebp]
	mov	DWORD PTR tv785[ebp], edx
	mov	eax, DWORD PTR _iStrategiesLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv785[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv785[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 739  : 					args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR _args$225367[ebp]
	mov	DWORD PTR tv792[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T232347[ebp], ecx
	mov	edx, DWORD PTR $T232347[ebp]
	push	edx
	mov	eax, DWORD PTR tv792[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv792[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 740  : 
; 741  : 					// Attempt to execute the game events.
; 742  : 					// Will return false if there are no registered listeners.
; 743  : 					bool bResult = false;

	mov	BYTE PTR _bResult$225368[ebp], 0

; 744  : 					if(LuaSupport::CallTestAll(pkScriptSystem, "EconomicStrategyCanActivate", args.get(), bResult))

	mov	ecx, DWORD PTR _args$225367[ebp]
	mov	DWORD PTR $T232351[ebp], ecx
	lea	edx, DWORD PTR _bResult$225368[ebp]
	push	edx
	mov	eax, DWORD PTR $T232351[ebp]
	push	eax
	push	OFFSET ??_C@_0BM@BLKCLAIM@EconomicStrategyCanActivate?$AA@
	mov	ecx, DWORD PTR _pkScriptSystem$225365[ebp]
	push	ecx
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN28@DoTurn

; 745  : 					{
; 746  : 						// Check the result.
; 747  : 						if(bResult == false)

	movzx	eax, BYTE PTR _bResult$225368[ebp]
	test	eax, eax
	jne	SHORT $LN28@DoTurn

; 748  : 						{
; 749  : 							bStrategyShouldBeActive = false;

	mov	BYTE PTR _bStrategyShouldBeActive$225238[ebp], 0
$LN28@DoTurn:

; 750  : 						}
; 751  : 					}
; 752  : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _args$225367[ebp]
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN29@DoTurn:

; 753  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN110@DoTurn:

; 754  : 
; 755  : 			// This variable keeps track of whether or not we should be doing something (i.e. Strategy is active now but should be turned off, OR Strategy is inactive and should be enabled)
; 756  : 			bool bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$225372[ebp], 0

; 757  : 
; 758  : 			// Strategy should be on, and if it's not, turn it on
; 759  : 			if(bStrategyShouldBeActive)

	movzx	ecx, BYTE PTR _bStrategyShouldBeActive$225238[ebp]
	test	ecx, ecx
	je	SHORT $LN26@DoTurn

; 760  : 			{
; 761  : 				if(bTestStrategyStart)

	movzx	edx, BYTE PTR _bTestStrategyStart$225222[ebp]
	test	edx, edx
	je	SHORT $LN25@DoTurn

; 762  : 				{
; 763  : 					bAdoptOrEndStrategy = true;

	mov	BYTE PTR _bAdoptOrEndStrategy$225372[ebp], 1
	jmp	SHORT $LN24@DoTurn
$LN25@DoTurn:

; 764  : 				}
; 765  : 				else if(bTestStrategyEnd)

	movzx	eax, BYTE PTR _bTestStrategyEnd$225230[ebp]
	test	eax, eax
	je	SHORT $LN24@DoTurn

; 766  : 				{
; 767  : 					bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$225372[ebp], 0
$LN24@DoTurn:

; 768  : 				}
; 769  : 			}
; 770  : 			// Strategy should be off, and if it's not, turn it off
; 771  : 			else

	jmp	SHORT $LN22@DoTurn
$LN26@DoTurn:

; 772  : 			{
; 773  : 				if(bTestStrategyStart)

	movzx	ecx, BYTE PTR _bTestStrategyStart$225222[ebp]
	test	ecx, ecx
	je	SHORT $LN21@DoTurn

; 774  : 				{
; 775  : 					bAdoptOrEndStrategy = false;

	mov	BYTE PTR _bAdoptOrEndStrategy$225372[ebp], 0
	jmp	SHORT $LN22@DoTurn
$LN21@DoTurn:

; 776  : 				}
; 777  : 				else if(bTestStrategyEnd)

	movzx	edx, BYTE PTR _bTestStrategyEnd$225230[ebp]
	test	edx, edx
	je	SHORT $LN22@DoTurn

; 778  : 				{
; 779  : 					bAdoptOrEndStrategy = true;

	mov	BYTE PTR _bAdoptOrEndStrategy$225372[ebp], 1
$LN22@DoTurn:

; 780  : 				}
; 781  : 			}
; 782  : 
; 783  : 			// Flavor propagation
; 784  : 			if(bAdoptOrEndStrategy)

	movzx	eax, BYTE PTR _bAdoptOrEndStrategy$225372[ebp]
	test	eax, eax
	je	$LN113@DoTurn

; 785  : 			{
; 786  : 				int iFlavorLoop;
; 787  : 
; 788  : 				// We should adopt this Strategy
; 789  : 				if(bTestStrategyStart)

	movzx	ecx, BYTE PTR _bTestStrategyStart$225222[ebp]
	test	ecx, ecx
	je	$LN17@DoTurn

; 790  : 				{
; 791  : 					SetUsingStrategy(eStrategy, true);

	push	1
	mov	edx, DWORD PTR _eStrategy$225218[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::SetUsingStrategy

; 792  : 
; 793  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225382[ebp], 0
	jmp	SHORT $LN16@DoTurn
$LN15@DoTurn:
	mov	eax, DWORD PTR _iFlavorLoop$225382[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$225382[ebp], eax
$LN16@DoTurn:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T232359[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$225382[ebp]
	cmp	edx, DWORD PTR $T232359[ebp]
	jge	SHORT $LN14@DoTurn

; 794  : 					{
; 795  : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	eax, DWORD PTR _iFlavorLoop$225382[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _iFlavorLoop$225382[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 796  : 					}

	jmp	SHORT $LN15@DoTurn
$LN14@DoTurn:

; 797  : 
; 798  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 799  : 
; 800  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225382[ebp], 0
	jmp	SHORT $LN13@DoTurn
$LN12@DoTurn:
	mov	ecx, DWORD PTR _iFlavorLoop$225382[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$225382[ebp], ecx
$LN13@DoTurn:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T232363[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$225382[ebp]
	cmp	eax, DWORD PTR $T232363[ebp]
	jge	SHORT $LN11@DoTurn

; 801  : 					{
; 802  : 						m_aiTempFlavors[iFlavorLoop] = pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$225382[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _iFlavorLoop$225382[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 803  : 					}

	jmp	SHORT $LN12@DoTurn
$LN11@DoTurn:

; 804  : 
; 805  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors
	jmp	$LN113@DoTurn
$LN17@DoTurn:

; 806  : 				}
; 807  : 				// End the Strategy
; 808  : 				else if(bTestStrategyEnd)

	movzx	edx, BYTE PTR _bTestStrategyEnd$225230[ebp]
	test	edx, edx
	je	$LN113@DoTurn

; 809  : 				{
; 810  : 					SetUsingStrategy(eStrategy, false);

	push	0
	mov	eax, DWORD PTR _eStrategy$225218[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetUsingStrategy@CvEconomicAI@@QAEXW4EconomicAIStrategyTypes@@_N@Z ; CvEconomicAI::SetUsingStrategy

; 811  : 
; 812  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225382[ebp], 0
	jmp	SHORT $LN8@DoTurn
$LN7@DoTurn:
	mov	ecx, DWORD PTR _iFlavorLoop$225382[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$225382[ebp], ecx
$LN8@DoTurn:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T232367[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$225382[ebp]
	cmp	eax, DWORD PTR $T232367[ebp]
	jge	SHORT $LN6@DoTurn

; 813  : 					{
; 814  : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetPlayerFlavorValue(iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$225382[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetPlayerFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetPlayerFlavorValue
	neg	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _iFlavorLoop$225382[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 815  : 					}

	jmp	SHORT $LN7@DoTurn
$LN6@DoTurn:

; 816  : 
; 817  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, true);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors

; 818  : 
; 819  : 					for(iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$225382[ebp], 0
	jmp	SHORT $LN5@DoTurn
$LN4@DoTurn:
	mov	edx, DWORD PTR _iFlavorLoop$225382[ebp]
	add	edx, 1
	mov	DWORD PTR _iFlavorLoop$225382[ebp], edx
$LN5@DoTurn:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T232371[ebp], eax
	mov	ecx, DWORD PTR _iFlavorLoop$225382[ebp]
	cmp	ecx, DWORD PTR $T232371[ebp]
	jge	SHORT $LN3@DoTurn

; 820  : 					{
; 821  : 						m_aiTempFlavors[iFlavorLoop] = -pStrategy->GetCityFlavorValue(iFlavorLoop);

	mov	edx, DWORD PTR _iFlavorLoop$225382[ebp]
	push	edx
	mov	ecx, DWORD PTR _pStrategy$225220[ebp]
	call	?GetCityFlavorValue@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetCityFlavorValue
	neg	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _iFlavorLoop$225382[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 822  : 					}

	jmp	SHORT $LN4@DoTurn
$LN3@DoTurn:

; 823  : 
; 824  : 					GetPlayer()->GetFlavorManager()->ChangeFlavors(m_aiTempFlavors, false);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?ChangeFlavors@CvFlavorManager@@QAEXPAH_N@Z ; CvFlavorManager::ChangeFlavors
$LN113@DoTurn:

; 825  : 				}
; 826  : 			}
; 827  : 		}
; 828  : 	}

	jmp	$LN126@DoTurn
$LN125@DoTurn:

; 829  : 
; 830  : 	if(!m_pPlayer->isHuman())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN128@DoTurn

; 831  : 	{
; 832  : 		DoHurry();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoHurry@CvEconomicAI@@AAEXXZ		; CvEconomicAI::DoHurry

; 833  : 		DoPlotPurchases();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoPlotPurchases@CvEconomicAI@@AAEXXZ	; CvEconomicAI::DoPlotPurchases

; 834  : 		DisbandExtraWorkers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ ; CvEconomicAI::DisbandExtraWorkers

; 835  : 		if (!m_pPlayer->isMinorCiv() && !m_pPlayer->isBarbarian())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN128@DoTurn
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN128@DoTurn

; 836  : 		{
; 837  : 			DisbandExtraArchaeologists();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ ; CvEconomicAI::DisbandExtraArchaeologists

; 838  : 			m_pPlayer->GetCulture()->DoSwapGreatWorks();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?DoSwapGreatWorks@CvPlayerCulture@@QAEXXZ ; CvPlayerCulture::DoSwapGreatWorks
$LN128@DoTurn:

; 839  : 		}
; 840  : 	}
; 841  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strStrategyName$225242[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoTurn@CvEconomicAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _args$225367[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?DoTurn@CvEconomicAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-176]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoTurn@CvEconomicAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoTurn@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::DoTurn
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ; CvEconomicAI::GetBestGreatWorkCity
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z:PROC ; CvPlayerCulture::HasAvailableGreatWorkSlot
EXTRN	?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z:PROC ; CultureHelpers::GetGreatWorkSlot
; Function compile flags: /Odtp
;	COMDAT ?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T232405 = -40						; size = 4
$T232401 = -36						; size = 4
$T232397 = -32						; size = 4
$T232388 = -28						; size = 4
_iDistance$225415 = -24					; size = 4
_iBestDistance$ = -20					; size = 4
_eGreatWorkSlot$ = -16					; size = 4
_pBestCity$ = -12					; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_pStartPlot$ = 8					; size = 4
_eGreatWork$ = 12					; size = 4
?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z PROC ; CvEconomicAI::GetBestGreatWorkCity, COMDAT
; _this$ = ecx

; 845  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 846  : 	CvCity* pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[ebp], 0

; 847  : 	CvCity* pLoopCity;
; 848  : 	int iLoop;
; 849  : 	int iBestDistance = MAX_INT;

	mov	DWORD PTR _iBestDistance$[ebp], 2147483647 ; 7fffffffH

; 850  : 
; 851  : 	// Make sure there is an undamaged city with a Great Work slot
; 852  : 	GreatWorkSlotType eGreatWorkSlot = CultureHelpers::GetGreatWorkSlot(eGreatWork);

	mov	eax, DWORD PTR _eGreatWork$[ebp]
	push	eax
	call	?GetGreatWorkSlot@CultureHelpers@@YA?AW4GreatWorkSlotType@@W4GreatWorkType@@@Z ; CultureHelpers::GetGreatWorkSlot
	add	esp, 4
	mov	DWORD PTR _eGreatWorkSlot$[ebp], eax

; 853  : 	if (m_pPlayer->GetCulture()->HasAvailableGreatWorkSlot(eGreatWorkSlot))

	mov	ecx, DWORD PTR _eGreatWorkSlot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?HasAvailableGreatWorkSlot@CvPlayerCulture@@QAE_NW4GreatWorkSlotType@@@Z ; CvPlayerCulture::HasAvailableGreatWorkSlot
	movzx	eax, al
	test	eax, eax
	je	$LN6@GetBestGre

; 854  : 	{
; 855  : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN5@GetBestGre
$LN4@GetBestGre:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN5@GetBestGre:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN6@GetBestGre

; 856  : 		{
; 857  : 			if (pLoopCity->getDamage() == 0)

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	test	eax, eax
	jne	SHORT $LN2@GetBestGre

; 858  : 			{
; 859  : 				int iDistance = plotDistance(pStartPlot->getX(), pStartPlot->getY(), pLoopCity->getX(), pLoopCity->getY());

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T232388[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T232397[ebp], edx
	mov	eax, DWORD PTR _pStartPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T232401[ebp], ecx
	mov	edx, DWORD PTR _pStartPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T232405[ebp], eax
	mov	ecx, DWORD PTR $T232388[ebp]
	push	ecx
	mov	edx, DWORD PTR $T232397[ebp]
	push	edx
	mov	eax, DWORD PTR $T232401[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232405[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225415[ebp], eax

; 860  : 				if(iDistance < iBestDistance)

	mov	edx, DWORD PTR _iDistance$225415[ebp]
	cmp	edx, DWORD PTR _iBestDistance$[ebp]
	jge	SHORT $LN2@GetBestGre

; 861  : 				{
; 862  : 					iBestDistance = iDistance;

	mov	eax, DWORD PTR _iDistance$225415[ebp]
	mov	DWORD PTR _iBestDistance$[ebp], eax

; 863  : 					pBestCity = pLoopCity;

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestCity$[ebp], ecx
$LN2@GetBestGre:

; 864  : 				}
; 865  : 			}
; 866  : 		}

	jmp	SHORT $LN4@GetBestGre
$LN6@GetBestGre:

; 867  : 	}
; 868  : 
; 869  : 	return pBestCity;

	mov	eax, DWORD PTR _pBestCity$[ebp]

; 870  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBestGreatWorkCity@CvEconomicAI@@QBEPAVCvCity@@PAVCvPlot@@W4GreatWorkType@@@Z ENDP ; CvEconomicAI::GetBestGreatWorkCity
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T232573 = -80						; size = 4
$T232547 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T232547[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T232547[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T232547[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T232573[ebp], edx
	mov	eax, DWORD PTR $T232573[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T232597 = -16						; size = 4
$T232589 = -12						; size = 4
$T232585 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T232585[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T232589[ebp], ecx
	movzx	edx, BYTE PTR $T232585[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T232589[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T232589[ebp]
	mov	DWORD PTR $T232597[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T232589[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T232589[ebp]
	mov	DWORD PTR $T232597[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T232597[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T232597[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T232618 = -16						; size = 4
$T232610 = -12						; size = 4
$T232606 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T232606[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T232610[ebp], ecx
	movzx	edx, BYTE PTR $T232606[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T232610[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T232610[ebp]
	mov	DWORD PTR $T232618[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T232610[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T232610[ebp]
	mov	DWORD PTR $T232618[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T232618[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T232618[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	?AppendToLog@@YAXAAVCvString@@0V1@1@Z		; AppendToLog
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$1
__ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@1@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@@YAXAAVCvString@@0V1@1@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_strValue$ = 44						; size = 28
?AppendToLog@@YAXAAVCvString@@0V1@1@Z PROC		; AppendToLog, COMDAT

; 877  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 878  : 	strHeader += strHeaderValue;

	lea	eax, DWORD PTR _strHeaderValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 879  : 	strHeader += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 880  : 	strLog += strValue;

	lea	ecx, DWORD PTR _strValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 881  : 	strLog += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 882  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$0:
	lea	ecx, DWORD PTR _strValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@1@Z$1:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@@YAXAAVCvString@@0V1@1@Z ENDP		; AppendToLog
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
PUBLIC	??_C@_03DPLIHHLN@?$CFd?0?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?AppendToLog@@YAXAAVCvString@@0V1@H@Z		; AppendToLog
;	COMDAT ??_C@_03DPLIHHLN@?$CFd?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_03DPLIHHLN@?$CFd?0?$AA@ DB '%d,', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$1
__ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@@YAXAAVCvString@@0V1@H@Z
_TEXT	SEGMENT
_str$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_iValue$ = 44						; size = 4
?AppendToLog@@YAXAAVCvString@@0V1@H@Z PROC		; AppendToLog, COMDAT

; 889  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 890  : 	strHeader += strHeaderValue;

	lea	eax, DWORD PTR _strHeaderValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 891  : 	strHeader += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 892  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 893  : 	str.Format("%d,", iValue);

	mov	ecx, DWORD PTR _iValue$[ebp]
	push	ecx
	push	OFFSET ??_C@_03DPLIHHLN@?$CFd?0?$AA@
	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 894  : 	strLog += str;

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 895  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@H@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@@YAXAAVCvString@@0V1@H@Z ENDP		; AppendToLog
PUBLIC	??_C@_05EIOELHKK@?$CF?42f?0?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?AppendToLog@@YAXAAVCvString@@0V1@M@Z		; AppendToLog
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_05EIOELHKK@?$CF?42f?0?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_05EIOELHKK@?$CF?42f?0?$AA@ DB '%.2f,', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@M@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$1
__ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@M@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AppendToLog@@YAXAAVCvString@@0V1@M@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AppendToLog@@YAXAAVCvString@@0V1@M@Z
_TEXT	SEGMENT
_str$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strHeader$ = 8						; size = 4
_strLog$ = 12						; size = 4
_strHeaderValue$ = 16					; size = 28
_fValue$ = 44						; size = 4
?AppendToLog@@YAXAAVCvString@@0V1@M@Z PROC		; AppendToLog, COMDAT

; 902  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@M@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 903  : 	strHeader += strHeaderValue;

	lea	eax, DWORD PTR _strHeaderValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 904  : 	strHeader += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 905  : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 906  : 	str.Format("%.2f,", fValue);

	cvtss2sd xmm0, DWORD PTR _fValue$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_05EIOELHKK@?$CF?42f?0?$AA@
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 907  : 	strLog += str;

	lea	edx, DWORD PTR _str$[ebp]
	push	edx
	mov	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 908  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$0:
	lea	ecx, DWORD PTR _strHeaderValue$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?AppendToLog@@YAXAAVCvString@@0V1@M@Z$1:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?AppendToLog@@YAXAAVCvString@@0V1@M@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AppendToLog@@YAXAAVCvString@@0V1@M@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AppendToLog@@YAXAAVCvString@@0V1@M@Z ENDP		; AppendToLog
PUBLIC	?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlots
; Function compile flags: /Odtp
;	COMDAT ?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ PROC ; CvEconomicAI::GetExplorationPlots, COMDAT
; _this$ = ecx

; 911  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 912  : 	if(m_bExplorationPlotsDirty)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@GetExplora

; 913  : 	{
; 914  : 		UpdatePlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots
$LN1@GetExplora:

; 915  : 	}
; 916  : 
; 917  : 	return m_aiExplorationPlots;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H

; 918  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExplorationPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ENDP ; CvEconomicAI::GetExplorationPlots
_TEXT	ENDS
PUBLIC	?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetExplorationPlotRatings
; Function compile flags: /Odtp
;	COMDAT ?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ PROC ; CvEconomicAI::GetExplorationPlotRatings, COMDAT
; _this$ = ecx

; 921  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 922  : 	if(m_bExplorationPlotsDirty)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@GetExplora@2

; 923  : 	{
; 924  : 		UpdatePlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots
$LN1@GetExplora@2:

; 925  : 	}
; 926  : 
; 927  : 	return m_aiExplorationPlotRatings;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 76					; 0000004cH

; 928  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetExplorationPlotRatings@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ENDP ; CvEconomicAI::GetExplorationPlotRatings
_TEXT	ENDS
PUBLIC	?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ; CvEconomicAI::GetGoodyHutPlots
; Function compile flags: /Odtp
;	COMDAT ?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ PROC ; CvEconomicAI::GetGoodyHutPlots, COMDAT
; _this$ = ecx

; 931  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 932  : 	if(m_bExplorationPlotsDirty)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@GetGoodyHu

; 933  : 	{
; 934  : 		UpdatePlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots
$LN1@GetGoodyHu:

; 935  : 	}
; 936  : 
; 937  : 	return m_aiGoodyHutPlots;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 88					; 00000058H

; 938  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetGoodyHutPlots@CvEconomicAI@@QAEAAV?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@XZ ENDP ; CvEconomicAI::GetGoodyHutPlots
_TEXT	ENDS
PUBLIC	?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z ; CvEconomicAI::GetUnitTargetGoodyPlot
; Function compile flags: /Odtp
;	COMDAT ?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z
_TEXT	SEGMENT
tv163 = -56						; size = 4
tv135 = -52						; size = 4
tv157 = -48						; size = 4
_this$ = -44						; size = 4
$T232751 = -40						; size = 4
$T232744 = -36						; size = 4
$T232737 = -32						; size = 4
$T232733 = -28						; size = 4
$T232723 = -24						; size = 4
$T232716 = -20						; size = 4
$T232706 = -16						; size = 4
_iStepPlotID$225493 = -12				; size = 4
_ui$225487 = -8						; size = 4
_iUnitID$ = -4						; size = 4
_pUnit$ = 8						; size = 4
_ppkStepPlot$ = 12					; size = 4
?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z PROC ; CvEconomicAI::GetUnitTargetGoodyPlot, COMDAT
; _this$ = ecx

; 942  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 943  : 	if(m_bExplorationPlotsDirty)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@GetUnitTar

; 944  : 	{
; 945  : 		UpdatePlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlots@CvEconomicAI@@QAEXXZ	; CvEconomicAI::UpdatePlots

; 946  : 	}
; 947  : 
; 948  : 	int iUnitID = pUnit->GetID();

$LN13@GetUnitTar:
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR _iUnitID$[ebp], eax

; 949  : 	for(uint ui = 0; ui < m_aiGoodyHutUnitAssignments.size(); ui++)

	mov	DWORD PTR _ui$225487[ebp], 0
	jmp	SHORT $LN5@GetUnitTar
$LN4@GetUnitTar:
	mov	ecx, DWORD PTR _ui$225487[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225487[ebp], ecx
$LN5@GetUnitTar:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	DWORD PTR $T232706[ebp], eax
	mov	ecx, DWORD PTR _ui$225487[ebp]
	cmp	ecx, DWORD PTR $T232706[ebp]
	jae	$LN3@GetUnitTar

; 950  : 	{
; 951  : 		if(iUnitID == m_aiGoodyHutUnitAssignments[ui].m_iUnitID)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _ui$225487[ebp]
	mov	edx, DWORD PTR _iUnitID$[ebp]
	cmp	edx, DWORD PTR [eax+ecx*8]
	jne	$LN2@GetUnitTar

; 952  : 		{
; 953  : 			if (ppkStepPlot)

	cmp	DWORD PTR _ppkStepPlot$[ebp], 0
	je	SHORT $LN1@GetUnitTar

; 954  : 			{
; 955  : 				int iStepPlotID = m_aiGoodyHutUnitAssignments[ui].m_iStepPlotID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _ui$225487[ebp]
	mov	eax, DWORD PTR [ecx+edx*8+4]
	mov	DWORD PTR _iStepPlotID$225493[ebp], eax

; 956  : 				*ppkStepPlot = (iStepPlotID != -1)?GC.getMap().plotByIndex(iStepPlotID):NULL;

	cmp	DWORD PTR _iStepPlotID$225493[ebp], -1
	je	SHORT $LN9@GetUnitTar
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T232716[ebp], ecx
	cmp	DWORD PTR _iStepPlotID$225493[ebp], 0
	jl	SHORT $LN25@GetUnitTar
	mov	edx, DWORD PTR $T232716[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T232723[ebp], eax
	mov	ecx, DWORD PTR _iStepPlotID$225493[ebp]
	cmp	ecx, DWORD PTR $T232723[ebp]
	jge	SHORT $LN25@GetUnitTar
	mov	edx, DWORD PTR _iStepPlotID$225493[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T232716[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv157[ebp], edx
	jmp	SHORT $LN23@GetUnitTar
$LN25@GetUnitTar:
	mov	DWORD PTR tv157[ebp], 0
$LN23@GetUnitTar:
	mov	ecx, DWORD PTR tv157[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	jmp	SHORT $LN10@GetUnitTar
$LN9@GetUnitTar:
	mov	DWORD PTR tv135[ebp], 0
$LN10@GetUnitTar:
	mov	edx, DWORD PTR _ppkStepPlot$[ebp]
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR [edx], eax
$LN1@GetUnitTar:

; 957  : 			}
; 958  : 			return GC.getMap().plotByIndex(m_aiGoodyHutPlots[ui]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _ui$225487[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T232733[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T232737[ebp], edx
	mov	eax, DWORD PTR $T232733[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T232751[ebp], ecx
	cmp	DWORD PTR $T232751[ebp], 0
	jl	SHORT $LN35@GetUnitTar
	mov	edx, DWORD PTR $T232737[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T232744[ebp], eax
	mov	ecx, DWORD PTR $T232751[ebp]
	cmp	ecx, DWORD PTR $T232744[ebp]
	jge	SHORT $LN35@GetUnitTar
	mov	edx, DWORD PTR $T232751[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T232737[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv163[ebp], edx
	jmp	SHORT $LN33@GetUnitTar
$LN35@GetUnitTar:
	mov	DWORD PTR tv163[ebp], 0
$LN33@GetUnitTar:
	mov	eax, DWORD PTR tv163[ebp]
	jmp	SHORT $LN7@GetUnitTar
$LN2@GetUnitTar:

; 959  : 		}
; 960  : 	}

	jmp	$LN4@GetUnitTar
$LN3@GetUnitTar:

; 961  : 
; 962  : 	return NULL;

	xor	eax, eax
$LN7@GetUnitTar:

; 963  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetUnitTargetGoodyPlot@CvEconomicAI@@QAEPAVCvPlot@@PAVCvUnit@@PAPAV2@@Z ENDP ; CvEconomicAI::GetUnitTargetGoodyPlot
_TEXT	ENDS
PUBLIC	?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z ; CvEconomicAI::ClearUnitTargetGoodyStepPlot
; Function compile flags: /Odtp
;	COMDAT ?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T232765 = -12						; size = 4
_ui$225499 = -8						; size = 4
_iUnitID$ = -4						; size = 4
_pUnit$ = 8						; size = 4
?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z PROC ; CvEconomicAI::ClearUnitTargetGoodyStepPlot, COMDAT
; _this$ = ecx

; 969  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 970  : 	int iUnitID = pUnit->GetID();

	mov	eax, DWORD PTR _pUnit$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _iUnitID$[ebp], ecx

; 971  : 	for(uint ui = 0; ui < m_aiGoodyHutUnitAssignments.size(); ui++)

	mov	DWORD PTR _ui$225499[ebp], 0
	jmp	SHORT $LN4@ClearUnitT
$LN3@ClearUnitT:
	mov	edx, DWORD PTR _ui$225499[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$225499[ebp], edx
$LN4@ClearUnitT:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR $T232765[ebp], ecx
	mov	edx, DWORD PTR _ui$225499[ebp]
	cmp	edx, DWORD PTR $T232765[ebp]
	jae	SHORT $LN5@ClearUnitT

; 972  : 	{
; 973  : 		if(iUnitID == m_aiGoodyHutUnitAssignments[ui].m_iUnitID)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _ui$225499[ebp]
	mov	eax, DWORD PTR _iUnitID$[ebp]
	cmp	eax, DWORD PTR [ecx+edx*8]
	jne	SHORT $LN1@ClearUnitT

; 974  : 		{
; 975  : 			m_aiGoodyHutUnitAssignments[ui].m_iStepPlotID = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _ui$225499[ebp]
	mov	DWORD PTR [edx+eax*8+4], -1
$LN1@ClearUnitT:

; 976  : 		}

	jmp	SHORT $LN3@ClearUnitT
$LN5@ClearUnitT:

; 977  : 	}
; 978  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ClearUnitTargetGoodyStepPlot@CvEconomicAI@@QAEXPAVCvUnit@@@Z ENDP ; CvEconomicAI::ClearUnitTargetGoodyStepPlot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
PUBLIC	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
EXTRN	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ:PROC	; CvFeatureInfo::getSeeThroughChange
EXTRN	?isImpassable@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::isImpassable
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z:PROC ; CvPlot::canSeePlot
EXTRN	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isAdjacentRevealed
; Function compile flags: /Odtp
;	COMDAT ?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z
_TEXT	SEGMENT
tv172 = -376						; size = 4
$T233097 = -296						; size = 4
$T233093 = -292						; size = 4
_f$233068 = -285					; size = 1
$T233025 = -240						; size = 4
$T233021 = -236						; size = 4
_uiOffset$233016 = -232					; size = 4
$T232853 = -148						; size = 4
$T232849 = -144						; size = 4
$T232808 = -96						; size = 4
$T232804 = -92						; size = 4
_uiOffset$232799 = -88					; size = 4
_eFeature$225550 = -64					; size = 4
_iDistance$225540 = -60					; size = 4
_i$225533 = -56						; size = 4
_bViewBlocked$225532 = -49				; size = 1
_pAdjacentPlot$225531 = -48				; size = 4
_iDistance$225564 = -44					; size = 4
_iY$225522 = -40					; size = 4
_iX$225518 = -36					; size = 4
_iPlotY$ = -32						; size = 4
_iBadScore$ = -28					; size = 4
_iGoodScore$ = -24					; size = 4
_iReallyGoodScore$ = -20				; size = 4
_pEvalPlot$ = -16					; size = 4
_iResultValue$ = -12					; size = 4
_iPlotX$ = -8						; size = 4
_iAdjacencyBonus$ = -4					; size = 4
_pPlot$ = 8						; size = 4
_eTeam$ = 12						; size = 4
_iRange$ = 16						; size = 4
_eDomainType$ = 20					; size = 4
?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z PROC ; CvEconomicAI::ScoreExplorePlot, COMDAT

; 982  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H

; 983  : 	int iResultValue = 0;

	mov	DWORD PTR _iResultValue$[ebp], 0

; 984  : 	int iAdjacencyBonus = 1;

	mov	DWORD PTR _iAdjacencyBonus$[ebp], 1

; 985  : 	int iBadScore = 10;

	mov	DWORD PTR _iBadScore$[ebp], 10		; 0000000aH

; 986  : 	int iGoodScore = 100;

	mov	DWORD PTR _iGoodScore$[ebp], 100	; 00000064H

; 987  : 	int iReallyGoodScore = 200;

	mov	DWORD PTR _iReallyGoodScore$[ebp], 200	; 000000c8H

; 988  : 	//int iGoodyHutScore = 100000;
; 989  : 
; 990  : 	int iPlotX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iPlotX$[ebp], ecx

; 991  : 	int iPlotY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 992  : 
; 993  : 	FAssertMsg(pPlot->isRevealed(eTeam), "Plot isn't revealed. This isn't good.");
; 994  : 	CvPlot* pEvalPlot = NULL;

	mov	DWORD PTR _pEvalPlot$[ebp], 0

; 995  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 996  : 	int iMaxDX, iX;
; 997  : 	for (int iY = -iRange; iY <= iRange; iY++)
; 998  : 	{
; 999  : 		iMaxDX = iRange - MAX(0, iY);
; 1000 : 		for (iX = -iRange - MIN(0, iY); iX <= iMaxDX; iX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1001 : 		{
; 1002 : 			// No need for range check because loops are set up properly
; 1003 : 			pEvalPlot = plotXY(iPlotX, iPlotY, iX, iY);
; 1004 : #else
; 1005 : 	for(int iX = -iRange; iX <= iRange; iX++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iX$225518[ebp], ecx
	jmp	SHORT $LN36@ScoreExplo
$LN35@ScoreExplo:
	mov	edx, DWORD PTR _iX$225518[ebp]
	add	edx, 1
	mov	DWORD PTR _iX$225518[ebp], edx
$LN36@ScoreExplo:
	mov	eax, DWORD PTR _iX$225518[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	$LN34@ScoreExplo

; 1006 : 	{
; 1007 : 		for(int iY = -iRange; iY <= iRange; iY++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iY$225522[ebp], ecx
	jmp	SHORT $LN33@ScoreExplo
$LN32@ScoreExplo:
	mov	edx, DWORD PTR _iY$225522[ebp]
	add	edx, 1
	mov	DWORD PTR _iY$225522[ebp], edx
$LN33@ScoreExplo:
	mov	eax, DWORD PTR _iY$225522[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	$LN31@ScoreExplo

; 1008 : 		{
; 1009 : 			pEvalPlot = plotXYWithRangeCheck(iPlotX, iPlotY, iX, iY, iRange);

	mov	ecx, DWORD PTR _iRange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iY$225522[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$225518[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotX$[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pEvalPlot$[ebp], eax

; 1010 : #endif
; 1011 : 			if(!pEvalPlot)

	cmp	DWORD PTR _pEvalPlot$[ebp], 0
	jne	SHORT $LN30@ScoreExplo

; 1012 : 			{
; 1013 : 				continue;

	jmp	SHORT $LN32@ScoreExplo
$LN30@ScoreExplo:

; 1014 : 			}
; 1015 : 
; 1016 : 			if(pEvalPlot == pPlot)

	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	cmp	eax, DWORD PTR _pPlot$[ebp]
	jne	SHORT $LN29@ScoreExplo

; 1017 : 			{
; 1018 : 				continue;

	jmp	SHORT $LN32@ScoreExplo
$LN29@ScoreExplo:

; 1019 : 			}
; 1020 : 
; 1021 : 			if(pEvalPlot->isRevealed(eTeam))

	mov	ecx, DWORD PTR _eTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$232799[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$232799[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$232799[ebp]
	mov	edx, DWORD PTR _pEvalPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN28@ScoreExplo

; 1022 : 			{
; 1023 : 				continue;

	jmp	SHORT $LN32@ScoreExplo
$LN28@ScoreExplo:

; 1024 : 			}
; 1025 : 
; 1026 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1027 : 			int iMainDistance = hexDistance(iX, iY);
; 1028 : #endif
; 1029 : 			if(pEvalPlot->isAdjacentRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEvalPlot$[ebp]
	call	?isAdjacentRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isAdjacentRevealed
	movzx	eax, al
	test	eax, eax
	je	$LN27@ScoreExplo

; 1030 : 			{
; 1031 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1032 : 				if (iMainDistance > 1)
; 1033 : #else
; 1034 : 				if(plotDistance(iPlotX, iPlotY, pEvalPlot->getX(), pEvalPlot->getY()) > 1)

	mov	ecx, DWORD PTR _pEvalPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T232804[ebp], edx
	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T232808[ebp], ecx
	mov	edx, DWORD PTR $T232804[ebp]
	push	edx
	mov	eax, DWORD PTR $T232808[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotX$[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jle	$LN26@ScoreExplo

; 1035 : #endif
; 1036 : 				{
; 1037 : 					CvPlot* pAdjacentPlot;
; 1038 : 					bool bViewBlocked = true;

	mov	BYTE PTR _bViewBlocked$225532[ebp], 1

; 1039 : 					for(int i = 0; i < NUM_DIRECTION_TYPES; ++i)

	mov	DWORD PTR _i$225533[ebp], 0
	jmp	SHORT $LN25@ScoreExplo
$LN24@ScoreExplo:
	mov	eax, DWORD PTR _i$225533[ebp]
	add	eax, 1
	mov	DWORD PTR _i$225533[ebp], eax
$LN25@ScoreExplo:
	cmp	DWORD PTR _i$225533[ebp], 6
	jge	$LN23@ScoreExplo

; 1040 : 					{
; 1041 : 						pAdjacentPlot = plotDirection(pEvalPlot->getX(), pEvalPlot->getY(), ((DirectionTypes)i));

	mov	ecx, DWORD PTR _pEvalPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T232849[ebp], edx
	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T232853[ebp], ecx
	mov	edx, DWORD PTR _i$225533[ebp]
	push	edx
	mov	eax, DWORD PTR $T232849[ebp]
	push	eax
	mov	ecx, DWORD PTR $T232853[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$225531[ebp], eax

; 1042 : 						if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$225531[ebp], 0
	je	$LN22@ScoreExplo

; 1043 : 						{
; 1044 : 							if(pAdjacentPlot->isRevealed(eTeam))

	mov	edx, DWORD PTR _eTeam$[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$233016[ebp], edx
	mov	eax, DWORD PTR _uiOffset$233016[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _eTeam$[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$233016[ebp]
	mov	ecx, DWORD PTR _pAdjacentPlot$225531[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN22@ScoreExplo

; 1045 : 							{
; 1046 : 								int iDistance = plotDistance(iPlotX, iPlotY, pAdjacentPlot->getX(), pAdjacentPlot->getY());

	mov	ecx, DWORD PTR _pAdjacentPlot$225531[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T233021[ebp], edx
	mov	eax, DWORD PTR _pAdjacentPlot$225531[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T233025[ebp], ecx
	mov	edx, DWORD PTR $T233021[ebp]
	push	edx
	mov	eax, DWORD PTR $T233025[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotX$[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225540[ebp], eax

; 1047 : 								if(iDistance > iRange)

	mov	eax, DWORD PTR _iDistance$225540[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN20@ScoreExplo

; 1048 : 								{
; 1049 : 									continue;

	jmp	$LN24@ScoreExplo
$LN20@ScoreExplo:

; 1050 : 								}
; 1051 : 
; 1052 : 								// this cheats, because we can't be sure that between the target and the viewer
; 1053 : 								if(pPlot->canSeePlot(pEvalPlot, eTeam, iRange, NO_DIRECTION))

	push	-1
	mov	ecx, DWORD PTR _iRange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _eTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN19@ScoreExplo

; 1054 : 								{
; 1055 : 									bViewBlocked = false;

	mov	BYTE PTR _bViewBlocked$225532[ebp], 0
$LN19@ScoreExplo:

; 1056 : 								}
; 1057 : 
; 1058 : 								if(!bViewBlocked)

	movzx	edx, BYTE PTR _bViewBlocked$225532[ebp]
	test	edx, edx
	jne	SHORT $LN22@ScoreExplo

; 1059 : 								{
; 1060 : 									break;

	jmp	SHORT $LN23@ScoreExplo
$LN22@ScoreExplo:

; 1061 : 								}
; 1062 : 							}
; 1063 : 						}
; 1064 : 					}

	jmp	$LN24@ScoreExplo
$LN23@ScoreExplo:

; 1065 : 
; 1066 : 					if(bViewBlocked)

	movzx	eax, BYTE PTR _bViewBlocked$225532[ebp]
	test	eax, eax
	je	SHORT $LN26@ScoreExplo

; 1067 : 					{
; 1068 : 						continue;

	jmp	$LN32@ScoreExplo
$LN26@ScoreExplo:

; 1069 : 					}
; 1070 : 				}
; 1071 : 
; 1072 : 				// "cheating" to look to see what the next tile is.
; 1073 : 				// a human should be able to do this by looking at the transition from the tile to the next
; 1074 : 				switch(eDomainType)

	mov	ecx, DWORD PTR _eDomainType$[ebp]
	mov	DWORD PTR tv172[ebp], ecx
	cmp	DWORD PTR tv172[ebp], 0
	je	SHORT $LN192@ScoreExplo
	cmp	DWORD PTR tv172[ebp], 2
	je	$LN200@ScoreExplo
	jmp	$LN15@ScoreExplo

; 1075 : 				{
; 1076 : 				case DOMAIN_SEA:
; 1077 : 				{
; 1078 : 					FeatureTypes eFeature = pEvalPlot->getFeatureType();

$LN192@ScoreExplo:
	mov	edx, DWORD PTR _pEvalPlot$[ebp]
	mov	al, BYTE PTR [edx+432]
	mov	BYTE PTR _f$233068[ebp], al
	movsx	ecx, BYTE PTR _f$233068[ebp]
	mov	DWORD PTR _eFeature$225550[ebp], ecx

; 1079 : 					if(pEvalPlot->isWater() || (eFeature != NO_FEATURE && GC.getFeatureInfo(eFeature)->isImpassable()))

	mov	edx, DWORD PTR _pEvalPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN12@ScoreExplo
	cmp	DWORD PTR _eFeature$225550[ebp], -1
	je	SHORT $LN196@ScoreExplo
	mov	eax, DWORD PTR _eFeature$225550[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?isImpassable@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::isImpassable
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN196@ScoreExplo
$LN12@ScoreExplo:

; 1080 : 					{
; 1081 : 						iResultValue += iBadScore;

	mov	edx, DWORD PTR _iResultValue$[ebp]
	add	edx, DWORD PTR _iBadScore$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], edx
	jmp	SHORT $LN11@ScoreExplo

; 1082 : 					}
; 1083 : 					else if(pEvalPlot->isMountain() || pEvalPlot->isHills() || (eFeature != NO_FEATURE && GC.getFeatureInfo(eFeature)->getSeeThroughChange() > 0))

$LN196@ScoreExplo:
	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN9@ScoreExplo
	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN9@ScoreExplo
	cmp	DWORD PTR _eFeature$225550[ebp], -1
	je	SHORT $LN10@ScoreExplo
	mov	eax, DWORD PTR _eFeature$225550[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	ecx, eax
	call	?getSeeThroughChange@CvFeatureInfo@@QBEHXZ ; CvFeatureInfo::getSeeThroughChange
	test	eax, eax
	jle	SHORT $LN10@ScoreExplo
$LN9@ScoreExplo:

; 1084 : 					{
; 1085 : 						iResultValue += iGoodScore;

	mov	ecx, DWORD PTR _iResultValue$[ebp]
	add	ecx, DWORD PTR _iGoodScore$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], ecx

; 1086 : 					}
; 1087 : 					else

	jmp	SHORT $LN11@ScoreExplo
$LN10@ScoreExplo:

; 1088 : 					{
; 1089 : 						iResultValue += iReallyGoodScore;

	mov	edx, DWORD PTR _iResultValue$[ebp]
	add	edx, DWORD PTR _iReallyGoodScore$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], edx
$LN11@ScoreExplo:

; 1090 : 					}
; 1091 : 				}
; 1092 : 				break;

	jmp	SHORT $LN15@ScoreExplo

; 1093 : 				case DOMAIN_LAND:
; 1094 : 					if(pEvalPlot->isMountain() || pEvalPlot->isWater())

$LN200@ScoreExplo:
	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN5@ScoreExplo
	mov	eax, DWORD PTR _pEvalPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN204@ScoreExplo
$LN5@ScoreExplo:

; 1095 : 					{
; 1096 : 						iResultValue += iBadScore;

	mov	ecx, DWORD PTR _iResultValue$[ebp]
	add	ecx, DWORD PTR _iBadScore$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], ecx
	jmp	SHORT $LN15@ScoreExplo

; 1097 : 					}
; 1098 : 					else if(pEvalPlot->isHills())

$LN204@ScoreExplo:
	mov	edx, DWORD PTR _pEvalPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@ScoreExplo

; 1099 : 					{
; 1100 : 						iResultValue += iReallyGoodScore;

	mov	edx, DWORD PTR _iResultValue$[ebp]
	add	edx, DWORD PTR _iReallyGoodScore$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], edx

; 1101 : 					}
; 1102 : 					else

	jmp	SHORT $LN15@ScoreExplo
$LN3@ScoreExplo:

; 1103 : 					{
; 1104 : 						iResultValue += iGoodScore;

	mov	eax, DWORD PTR _iResultValue$[ebp]
	add	eax, DWORD PTR _iGoodScore$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], eax
$LN15@ScoreExplo:

; 1105 : 					}
; 1106 : 					break;
; 1107 : 				}
; 1108 : 			}
; 1109 : 			else

	jmp	SHORT $LN1@ScoreExplo
$LN27@ScoreExplo:

; 1110 : 			{
; 1111 : 				iResultValue += iGoodScore;

	mov	ecx, DWORD PTR _iResultValue$[ebp]
	add	ecx, DWORD PTR _iGoodScore$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], ecx
$LN1@ScoreExplo:

; 1112 : 			}
; 1113 : 
; 1114 : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 1115 : 			iResultValue += (iRange - iMainDistance) * iAdjacencyBonus;
; 1116 : #else
; 1117 : 			int iDistance = plotDistance(iPlotX, iPlotY, pEvalPlot->getX(), pEvalPlot->getY());

	mov	edx, DWORD PTR _pEvalPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T233093[ebp], eax
	mov	ecx, DWORD PTR _pEvalPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T233097[ebp], edx
	mov	eax, DWORD PTR $T233093[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233097[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iPlotX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$225564[ebp], eax

; 1118 : 			iResultValue += (iRange - iDistance) * iAdjacencyBonus;

	mov	ecx, DWORD PTR _iRange$[ebp]
	sub	ecx, DWORD PTR _iDistance$225564[ebp]
	imul	ecx, DWORD PTR _iAdjacencyBonus$[ebp]
	add	ecx, DWORD PTR _iResultValue$[ebp]
	mov	DWORD PTR _iResultValue$[ebp], ecx

; 1119 : #endif
; 1120 : 		}

	jmp	$LN32@ScoreExplo
$LN31@ScoreExplo:

; 1121 : 	}

	jmp	$LN35@ScoreExplo
$LN34@ScoreExplo:

; 1122 : 
; 1123 : 	return iResultValue;

	mov	eax, DWORD PTR _iResultValue$[ebp]

; 1124 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ENDP ; CvEconomicAI::ScoreExplorePlot
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T233381 = -80						; size = 4
$T233336 = -76						; size = 4
$T233323 = -72						; size = 4
$T233319 = -68						; size = 4
$T233305 = -64						; size = 4
$T233301 = -57						; size = 1
$T233290 = -56						; size = 4
$T233286 = -49						; size = 1
_iMapY$233345 = -48					; size = 4
_iMapX$233344 = -44					; size = 4
$T233279 = -40						; size = 4
$T233255 = -36						; size = 4
$T233218 = -32						; size = 4
$T233206 = -28						; size = 4
$T233202 = -21						; size = 1
$T233191 = -20						; size = 4
$T233187 = -13						; size = 1
_iMapY$233234 = -12					; size = 4
_iMapX$233233 = -8					; size = 4
$T233180 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233180[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T233255[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T233180[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T233187[ebp], dl
	mov	eax, DWORD PTR $T233180[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233191[ebp], ecx
	movzx	edx, BYTE PTR $T233187[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T233191[ebp]
	add	edx, DWORD PTR $T233191[ebp]
	mov	DWORD PTR _iMapX$233233[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T233191[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T233191[ebp]
	mov	DWORD PTR _iMapX$233233[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$233233[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T233180[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T233202[ebp], al
	mov	ecx, DWORD PTR $T233180[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T233206[ebp], edx
	movzx	eax, BYTE PTR $T233202[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T233206[ebp]
	add	edx, DWORD PTR $T233206[ebp]
	mov	DWORD PTR _iMapY$233234[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T233206[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T233206[ebp]
	mov	DWORD PTR _iMapY$233234[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$233234[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$233234[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$233233[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T233180[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T233180[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T233218[ebp], eax
	mov	ecx, DWORD PTR _iMapY$233234[ebp]
	imul	ecx, DWORD PTR $T233218[ebp]
	add	ecx, DWORD PTR _iMapX$233233[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T233180[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T233255[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T233255[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233279[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T233381[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T233279[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T233286[ebp], dl
	mov	eax, DWORD PTR $T233279[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233290[ebp], ecx
	movzx	edx, BYTE PTR $T233286[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T233290[ebp]
	add	edx, DWORD PTR $T233290[ebp]
	mov	DWORD PTR _iMapX$233344[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T233290[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T233290[ebp]
	mov	DWORD PTR _iMapX$233344[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$233344[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T233279[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T233301[ebp], al
	mov	ecx, DWORD PTR $T233279[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T233305[ebp], edx
	movzx	eax, BYTE PTR $T233301[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T233305[ebp]
	add	edx, DWORD PTR $T233305[ebp]
	mov	DWORD PTR _iMapY$233345[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T233305[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T233305[ebp]
	mov	DWORD PTR _iMapY$233345[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$233345[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$233344[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T233279[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233319[ebp], ecx
	mov	edx, DWORD PTR _iMapX$233344[ebp]
	cmp	edx, DWORD PTR $T233319[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$233345[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T233279[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T233323[ebp], ecx
	mov	edx, DWORD PTR _iMapY$233345[ebp]
	cmp	edx, DWORD PTR $T233323[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T233279[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233336[ebp], ecx
	mov	edx, DWORD PTR _iMapY$233345[ebp]
	imul	edx, DWORD PTR $T233336[ebp]
	add	edx, DWORD PTR _iMapX$233344[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T233279[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T233381[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T233381[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$218147 = -20					; size = 4
_iAbsDX$218146 = -16					; size = 4
_iAbsDY$218144 = -12					; size = 4
_iAbsDX$218143 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$218143[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$218144[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$218143[ebp]
	add	edx, DWORD PTR _iAbsDY$218144[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$218146[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$218147[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$218146[ebp]
	cmp	eax, DWORD PTR _iAbsDY$218147[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$218146[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$218147[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T233636 = -56						; size = 4
$T233591 = -52						; size = 4
$T233578 = -48						; size = 4
$T233574 = -44						; size = 4
$T233560 = -40						; size = 4
$T233556 = -33						; size = 1
$T233545 = -32						; size = 4
$T233541 = -25						; size = 1
_iMapY$233635 = -24					; size = 4
_iMapX$233634 = -20					; size = 4
$T233534 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233534[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T233636[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T233534[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T233541[ebp], dl
	mov	eax, DWORD PTR $T233534[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233545[ebp], ecx
	movzx	edx, BYTE PTR $T233541[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T233545[ebp]
	add	edx, DWORD PTR $T233545[ebp]
	mov	DWORD PTR _iMapX$233634[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T233545[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T233545[ebp]
	mov	DWORD PTR _iMapX$233634[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$233634[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T233534[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T233556[ebp], al
	mov	ecx, DWORD PTR $T233534[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T233560[ebp], edx
	movzx	eax, BYTE PTR $T233556[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T233560[ebp]
	add	edx, DWORD PTR $T233560[ebp]
	mov	DWORD PTR _iMapY$233635[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T233560[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T233560[ebp]
	mov	DWORD PTR _iMapY$233635[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$233635[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$233634[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T233534[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233574[ebp], ecx
	mov	edx, DWORD PTR _iMapX$233634[ebp]
	cmp	edx, DWORD PTR $T233574[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$233635[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T233534[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T233578[ebp], ecx
	mov	edx, DWORD PTR _iMapY$233635[ebp]
	cmp	edx, DWORD PTR $T233578[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T233534[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T233591[ebp], ecx
	mov	edx, DWORD PTR _iMapY$233635[ebp]
	imul	edx, DWORD PTR $T233591[ebp]
	add	edx, DWORD PTR _iMapX$233634[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T233534[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T233636[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T233636[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z ; CvEconomicAI::StartSaveForPurchase
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
;	COMDAT ?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_request$ = -16						; size = 12
_iIndex$ = -4						; size = 4
_ePurchase$ = 8						; size = 4
_iAmount$ = 12						; size = 4
_iPriority$ = 16					; size = 4
?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z PROC ; CvEconomicAI::StartSaveForPurchase, COMDAT
; _this$ = ecx

; 1128 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1129 : 	int iIndex = (int)ePurchase;

	mov	eax, DWORD PTR _ePurchase$[ebp]
	mov	DWORD PTR _iIndex$[ebp], eax

; 1130 : 	CvPurchaseRequest request;

	mov	DWORD PTR _request$[ebp], -1
	mov	DWORD PTR _request$[ebp+4], 0
	mov	DWORD PTR _request$[ebp+8], 0

; 1131 : 	request.m_eType = ePurchase;

	mov	ecx, DWORD PTR _ePurchase$[ebp]
	mov	DWORD PTR _request$[ebp], ecx

; 1132 : 	request.m_iAmount = iAmount;

	mov	edx, DWORD PTR _iAmount$[ebp]
	mov	DWORD PTR _request$[ebp+4], edx

; 1133 : 	request.m_iPriority = iPriority;

	mov	eax, DWORD PTR _iPriority$[ebp]
	mov	DWORD PTR _request$[ebp+8], eax

; 1134 : 	m_RequestedSavings[iIndex] = request;

	mov	ecx, DWORD PTR _iIndex$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	add	eax, ecx
	mov	ecx, DWORD PTR _request$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _request$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _request$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 1135 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StartSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@HH@Z ENDP ; CvEconomicAI::StartSaveForPurchase
_TEXT	ENDS
PUBLIC	?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z ; CvEconomicAI::IsSavingForThisPurchase
; Function compile flags: /Odtp
;	COMDAT ?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ePurchase$ = 8						; size = 4
?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z PROC ; CvEconomicAI::IsSavingForThisPurchase, COMDAT
; _this$ = ecx

; 1143 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1144 : 	return (m_RequestedSavings[(int)ePurchase].m_iAmount > 0);

	mov	eax, DWORD PTR _ePurchase$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	xor	ecx, ecx
	cmp	DWORD PTR [edx+eax+4], 0
	setg	cl
	mov	al, cl

; 1145 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?IsSavingForThisPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@@Z ENDP ; CvEconomicAI::IsSavingForThisPurchase
_TEXT	ENDS
PUBLIC	?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ; CvEconomicAI::CancelSaveForPurchase
; Function compile flags: /Odtp
;	COMDAT ?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_request$ = -16						; size = 12
_iIndex$ = -4						; size = 4
_ePurchase$ = 8						; size = 4
?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z PROC ; CvEconomicAI::CancelSaveForPurchase, COMDAT
; _this$ = ecx

; 1149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1150 : 	int iIndex = (int)ePurchase;

	mov	eax, DWORD PTR _ePurchase$[ebp]
	mov	DWORD PTR _iIndex$[ebp], eax

; 1151 : 	CvPurchaseRequest request;

	mov	DWORD PTR _request$[ebp], -1
	mov	DWORD PTR _request$[ebp+4], 0
	mov	DWORD PTR _request$[ebp+8], 0

; 1152 : 	request.m_eType = ePurchase;

	mov	ecx, DWORD PTR _ePurchase$[ebp]
	mov	DWORD PTR _request$[ebp], ecx

; 1153 : 	request.m_iAmount = 0;

	mov	DWORD PTR _request$[ebp+4], 0

; 1154 : 	request.m_iPriority = 0;

	mov	DWORD PTR _request$[ebp+8], 0

; 1155 : 	m_RequestedSavings[iIndex] = request;

	mov	edx, DWORD PTR _iIndex$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	add	ecx, edx
	mov	edx, DWORD PTR _request$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _request$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _request$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 1156 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CancelSaveForPurchase@CvEconomicAI@@QAEXW4PurchaseType@@@Z ENDP ; CvEconomicAI::CancelSaveForPurchase
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
PUBLIC	??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=
PUBLIC	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
EXTRN	?GetGold@CvTreasury@@QBEHXZ:PROC		; CvTreasury::GetGold
EXTRN	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ:PROC ; CvPlayer::GetTreasury
; Function compile flags: /Odtp
;	COMDAT ?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z
_TEXT	SEGMENT
_this$ = -100						; size = 4
$T233748 = -96						; size = 4
$T233687 = -48						; size = 4
$T233683 = -44						; size = 4
$T233682 = -40						; size = 4
_request$225606 = -24					; size = 12
_iI$225601 = -12					; size = 4
_iIndex$225594 = -8					; size = 4
_iBalance$ = -4						; size = 4
_ePurchase$ = 8						; size = 4
_iAmount$ = 12						; size = 4
_iPriority$ = 16					; size = 4
?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z PROC ; CvEconomicAI::CanWithdrawMoneyForPurchase, COMDAT
; _this$ = ecx

; 1161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 1162 : 	int iBalance = m_pPlayer->GetTreasury()->GetGold();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	DWORD PTR _iBalance$[ebp], eax

; 1163 : 
; 1164 : 	// Update this item's priority
; 1165 : 	if(iPriority != -1)

	cmp	DWORD PTR _iPriority$[ebp], -1
	je	SHORT $LN8@CanWithdra

; 1166 : 	{
; 1167 : 		int iIndex = (int)ePurchase;

	mov	ecx, DWORD PTR _ePurchase$[ebp]
	mov	DWORD PTR _iIndex$225594[ebp], ecx

; 1168 : 		m_RequestedSavings[iIndex].m_iPriority = iPriority;

	mov	edx, DWORD PTR _iIndex$225594[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	eax, DWORD PTR _iPriority$[ebp]
	mov	DWORD PTR [ecx+edx+8], eax
$LN8@CanWithdra:

; 1169 : 	}
; 1170 : 
; 1171 : 	// Copy into temp array and sort by priority
; 1172 : 	m_TempRequestedSavings = m_RequestedSavings;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=

; 1173 : 	std::stable_sort(m_TempRequestedSavings.begin(), m_TempRequestedSavings.end());

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	mov	DWORD PTR $T233682[ebp], edx
	mov	eax, DWORD PTR $T233682[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR $T233682[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T233683[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	mov	DWORD PTR $T233687[ebp], ecx
	mov	edx, DWORD PTR $T233687[ebp]
	cmp	edx, DWORD PTR $T233683[ebp]
	je	SHORT $LN32@CanWithdra
	push	0
	push	0
	mov	eax, DWORD PTR $T233683[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233687[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H
$LN32@CanWithdra:

; 1174 : 
; 1175 : 	for(int iI = 0; iI < (int)m_TempRequestedSavings.size(); iI++)

	mov	DWORD PTR _iI$225601[ebp], 0
	jmp	SHORT $LN7@CanWithdra
$LN6@CanWithdra:
	mov	edx, DWORD PTR _iI$225601[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225601[ebp], edx
$LN7@CanWithdra:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	DWORD PTR $T233748[ebp], ecx
	mov	edx, DWORD PTR _iI$225601[ebp]
	cmp	edx, DWORD PTR $T233748[ebp]
	jge	SHORT $LN5@CanWithdra

; 1176 : 	{
; 1177 : 		CvPurchaseRequest request = m_TempRequestedSavings[iI];

	mov	eax, DWORD PTR _iI$225601[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _request$225606[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _request$225606[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _request$225606[ebp+8], edx

; 1178 : 
; 1179 : 		// Is this higher priority than the request we care about?
; 1180 : 		if(request.m_eType != ePurchase)

	mov	eax, DWORD PTR _request$225606[ebp]
	cmp	eax, DWORD PTR _ePurchase$[ebp]
	je	SHORT $LN4@CanWithdra

; 1181 : 		{
; 1182 : 			iBalance -= request.m_iAmount;

	mov	ecx, DWORD PTR _iBalance$[ebp]
	sub	ecx, DWORD PTR _request$225606[ebp+4]
	mov	DWORD PTR _iBalance$[ebp], ecx

; 1183 : 
; 1184 : 			// No money left?
; 1185 : 			if(iBalance <= 0)

	cmp	DWORD PTR _iBalance$[ebp], 0
	jg	SHORT $LN3@CanWithdra

; 1186 : 			{
; 1187 : 				return false;

	xor	al, al
	jmp	SHORT $LN9@CanWithdra
$LN3@CanWithdra:

; 1188 : 			}
; 1189 : 		}

	jmp	SHORT $LN2@CanWithdra
$LN4@CanWithdra:

; 1190 : 
; 1191 : 		// Is this the one, if so, check balance remaining
; 1192 : 		else if(request.m_eType == ePurchase)

	mov	edx, DWORD PTR _request$225606[ebp]
	cmp	edx, DWORD PTR _ePurchase$[ebp]
	jne	SHORT $LN2@CanWithdra

; 1193 : 		{
; 1194 : 			return (iBalance >=iAmount);

	mov	eax, DWORD PTR _iBalance$[ebp]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _iAmount$[ebp]
	setge	cl
	mov	al, cl
	jmp	SHORT $LN9@CanWithdra
$LN2@CanWithdra:

; 1195 : 		}
; 1196 : 	}

	jmp	SHORT $LN6@CanWithdra
$LN5@CanWithdra:

; 1197 : 
; 1198 : 	CvAssert(false);
; 1199 : 	return false;  // Should never reach here

	xor	al, al
$LN9@CanWithdra:

; 1200 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ENDP ; CvEconomicAI::CanWithdrawMoneyForPurchase
_TEXT	ENDS
PUBLIC	?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z ; CvEconomicAI::AmountAvailableForPurchase
; Function compile flags: /Odtp
;	COMDAT ?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
$T233839 = -92						; size = 4
$T233778 = -44						; size = 4
$T233774 = -40						; size = 4
$T233773 = -36						; size = 4
_request$225621 = -20					; size = 12
_iI$225616 = -8						; size = 4
_iBalance$ = -4						; size = 4
_ePurchase$ = 8						; size = 4
?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z PROC ; CvEconomicAI::AmountAvailableForPurchase, COMDAT
; _this$ = ecx

; 1208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1209 : 	int iBalance = m_pPlayer->GetTreasury()->GetGold();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	DWORD PTR _iBalance$[ebp], eax

; 1210 : 
; 1211 : 	// Copy into temp array and sort by priority
; 1212 : #ifdef AUI_WARNING_FIXES
; 1213 : 	FStaticVector<CvPurchaseRequest, NUM_PURCHASE_TYPES, true, c_eCiv5GameplayDLL, 0> vTempRequestedSavings = m_RequestedSavings;
; 1214 : 	std::stable_sort(vTempRequestedSavings.begin(), vTempRequestedSavings.end());
; 1215 : 
; 1216 : 	for (FStaticVector<CvPurchaseRequest, NUM_PURCHASE_TYPES, true, c_eCiv5GameplayDLL, 0>::iterator it = vTempRequestedSavings.begin(); it != vTempRequestedSavings.end(); ++it)
; 1217 : 	{
; 1218 : 		CvPurchaseRequest request = *it;
; 1219 : #else
; 1220 : 	m_TempRequestedSavings = m_RequestedSavings;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 200				; 000000c8H
	call	??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=

; 1221 : 	std::stable_sort(m_TempRequestedSavings.begin(), m_TempRequestedSavings.end());

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 200				; 000000c8H
	mov	DWORD PTR $T233773[ebp], edx
	mov	eax, DWORD PTR $T233773[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR $T233773[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T233774[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+200]
	mov	DWORD PTR $T233778[ebp], ecx
	mov	edx, DWORD PTR $T233778[ebp]
	cmp	edx, DWORD PTR $T233774[ebp]
	je	SHORT $LN29@AmountAvai
	push	0
	push	0
	mov	eax, DWORD PTR $T233774[ebp]
	push	eax
	mov	ecx, DWORD PTR $T233778[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H
$LN29@AmountAvai:

; 1222 : 
; 1223 : 	for(int iI = 0; iI < (int)m_TempRequestedSavings.size(); iI++)

	mov	DWORD PTR _iI$225616[ebp], 0
	jmp	SHORT $LN7@AmountAvai
$LN6@AmountAvai:
	mov	edx, DWORD PTR _iI$225616[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$225616[ebp], edx
$LN7@AmountAvai:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	DWORD PTR $T233839[ebp], ecx
	mov	edx, DWORD PTR _iI$225616[ebp]
	cmp	edx, DWORD PTR $T233839[ebp]
	jge	SHORT $LN5@AmountAvai

; 1224 : 	{
; 1225 : 		CvPurchaseRequest request = m_TempRequestedSavings[iI];

	mov	eax, DWORD PTR _iI$225616[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	add	edx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _request$225621[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _request$225621[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR _request$225621[ebp+8], edx

; 1226 : #endif
; 1227 : 
; 1228 : 		// Is this higher priority than the request we care about?
; 1229 : 		if(request.m_eType != ePurchase)

	mov	eax, DWORD PTR _request$225621[ebp]
	cmp	eax, DWORD PTR _ePurchase$[ebp]
	je	SHORT $LN4@AmountAvai

; 1230 : 		{
; 1231 : 			iBalance -= request.m_iAmount;

	mov	ecx, DWORD PTR _iBalance$[ebp]
	sub	ecx, DWORD PTR _request$225621[ebp+4]
	mov	DWORD PTR _iBalance$[ebp], ecx

; 1232 : 
; 1233 : 			// No money left?
; 1234 : 			if(iBalance <= 0)

	cmp	DWORD PTR _iBalance$[ebp], 0
	jg	SHORT $LN3@AmountAvai

; 1235 : 			{
; 1236 : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN8@AmountAvai
$LN3@AmountAvai:

; 1237 : 			}
; 1238 : 		}

	jmp	SHORT $LN2@AmountAvai
$LN4@AmountAvai:

; 1239 : 
; 1240 : 		// Is this the one, if so, check balance remaining
; 1241 : 		else if(request.m_eType == ePurchase)

	mov	edx, DWORD PTR _request$225621[ebp]
	cmp	edx, DWORD PTR _ePurchase$[ebp]
	jne	SHORT $LN2@AmountAvai

; 1242 : 		{
; 1243 : 			return (iBalance);

	mov	eax, DWORD PTR _iBalance$[ebp]
	jmp	SHORT $LN8@AmountAvai
$LN2@AmountAvai:

; 1244 : 		}
; 1245 : 	}

	jmp	SHORT $LN6@AmountAvai
$LN5@AmountAvai:

; 1246 : 
; 1247 : 	CvAssert(false);
; 1248 : #ifdef AUI_WARNING_FIXES
; 1249 : 	return iBalance;
; 1250 : #else
; 1251 : 	return false;  // Should never reach here

	xor	eax, eax
$LN8@AmountAvai:

; 1252 : #endif
; 1253 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AmountAvailableForPurchase@CvEconomicAI@@QAEHW4PurchaseType@@@Z ENDP ; CvEconomicAI::AmountAvailableForPurchase
_TEXT	ENDS
PUBLIC	?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ	; CvEconomicAI::GetWorkersToCitiesRatio
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z:PROC ; CvPlayer::GetNumUnitsWithUnitAI
; Function compile flags: /Odtp
;	COMDAT ?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_iNumWorkers$ = -16					; size = 4
_iNumCities$ = -12					; size = 4
_fCurrentRatio$ = -8					; size = 8
?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ PROC	; CvEconomicAI::GetWorkersToCitiesRatio, COMDAT
; _this$ = ecx

; 1261 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1262 : 	int iNumWorkers = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false); // includes workers currently being produced

	push	0
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumWorkers$[ebp], eax

; 1263 : 	int iNumCities = m_pPlayer->getNumCities();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR _iNumCities$[ebp], eax

; 1264 : 	double fCurrentRatio = iNumWorkers / (double)iNumCities;

	cvtsi2sd xmm0, DWORD PTR _iNumWorkers$[ebp]
	cvtsi2sd xmm1, DWORD PTR _iNumCities$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _fCurrentRatio$[ebp], xmm0

; 1265 : 
; 1266 : 	return fCurrentRatio;

	fld	QWORD PTR _fCurrentRatio$[ebp]

; 1267 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWorkersToCitiesRatio@CvEconomicAI@@QAENXZ ENDP	; CvEconomicAI::GetWorkersToCitiesRatio
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ ; CvEconomicAI::GetImprovedToImprovablePlotsRatio
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ:PROC ; CvPlayer::GetPlots
;	COMDAT __real@3ff0000000000000
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ
_TEXT	SEGMENT
tv164 = -60						; size = 4
_this$ = -56						; size = 4
$T233875 = -48						; size = 4
$T233868 = -44						; size = 4
$T233861 = -40						; size = 4
$T233857 = -36						; size = 4
$T233850 = -32						; size = 4
_pPlot$225644 = -28					; size = 4
_ui$225639 = -24					; size = 4
_aiPlots$ = -20						; size = 4
_fCurrentRatio$ = -16					; size = 8
_iNumValidPlots$ = -8					; size = 4
_iNumImprovedPlots$ = -4				; size = 4
?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ PROC ; CvEconomicAI::GetImprovedToImprovablePlotsRatio, COMDAT
; _this$ = ecx

; 1275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1276 : 	const CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	DWORD PTR _aiPlots$[ebp], eax

; 1277 : 	int iNumValidPlots = 0;

	mov	DWORD PTR _iNumValidPlots$[ebp], 0

; 1278 : 	int iNumImprovedPlots = 0;

	mov	DWORD PTR _iNumImprovedPlots$[ebp], 0

; 1279 : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	mov	DWORD PTR _ui$225639[ebp], 0
	jmp	SHORT $LN9@GetImprove
$LN8@GetImprove:
	mov	ecx, DWORD PTR _ui$225639[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225639[ebp], ecx
$LN9@GetImprove:
	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T233850[ebp], eax
	mov	ecx, DWORD PTR _ui$225639[ebp]
	cmp	ecx, DWORD PTR $T233850[ebp]
	jae	$LN7@GetImprove

; 1280 : 	{
; 1281 : 		if(aiPlots[ui] == -1)

	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$225639[ebp]
	cmp	DWORD PTR [eax+ecx*4], -1
	jne	SHORT $LN6@GetImprove

; 1282 : 		{
; 1283 : 			continue;

	jmp	SHORT $LN8@GetImprove
$LN6@GetImprove:

; 1284 : 		}
; 1285 : 
; 1286 : 		const CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);

	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ui$225639[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T233857[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T233861[ebp], eax
	mov	ecx, DWORD PTR $T233857[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T233875[ebp], edx
	cmp	DWORD PTR $T233875[ebp], 0
	jl	SHORT $LN22@GetImprove
	mov	eax, DWORD PTR $T233861[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T233868[ebp], ecx
	mov	edx, DWORD PTR $T233875[ebp]
	cmp	edx, DWORD PTR $T233868[ebp]
	jge	SHORT $LN22@GetImprove
	mov	eax, DWORD PTR $T233875[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T233861[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN23@GetImprove
$LN22@GetImprove:
	mov	DWORD PTR tv164[ebp], 0
$LN23@GetImprove:
	mov	edx, DWORD PTR tv164[ebp]
	mov	DWORD PTR _pPlot$225644[ebp], edx

; 1287 : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$225644[ebp], 0
	jne	SHORT $LN5@GetImprove

; 1288 : 		{
; 1289 : 			continue;

	jmp	$LN8@GetImprove
$LN5@GetImprove:

; 1290 : 		}
; 1291 : 
; 1292 : 		if(pPlot->isWater() || pPlot->isImpassable() || pPlot->isMountain() || pPlot->isCity())

	mov	eax, DWORD PTR _pPlot$225644[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _pPlot$225644[ebp]
	mov	dl, BYTE PTR [ecx+462]
	shr	dl, 7
	and	dl, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _pPlot$225644[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN3@GetImprove
	mov	ecx, DWORD PTR _pPlot$225644[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@GetImprove
$LN3@GetImprove:

; 1293 : 		{
; 1294 : 			continue;

	jmp	$LN8@GetImprove
$LN4@GetImprove:

; 1295 : 		}
; 1296 : 
; 1297 : 		iNumValidPlots++;

	mov	edx, DWORD PTR _iNumValidPlots$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumValidPlots$[ebp], edx

; 1298 : 
; 1299 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT && !pPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pPlot$225644[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN2@GetImprove
	mov	ecx, DWORD PTR _pPlot$225644[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@GetImprove

; 1300 : 		{
; 1301 : 			iNumImprovedPlots++;

	mov	ecx, DWORD PTR _iNumImprovedPlots$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumImprovedPlots$[ebp], ecx
$LN2@GetImprove:

; 1302 : 		}
; 1303 : 	}

	jmp	$LN8@GetImprove
$LN7@GetImprove:

; 1304 : 	// Avoid potential division by 0
; 1305 : 	if(iNumValidPlots <= 0)

	cmp	DWORD PTR _iNumValidPlots$[ebp], 0
	jg	SHORT $LN1@GetImprove

; 1306 : 	{
; 1307 : 		return 1.0;

	fld1
	jmp	SHORT $LN10@GetImprove
$LN1@GetImprove:

; 1308 : 	}
; 1309 : 	double fCurrentRatio = iNumImprovedPlots / (double)iNumValidPlots;

	cvtsi2sd xmm0, DWORD PTR _iNumImprovedPlots$[ebp]
	cvtsi2sd xmm1, DWORD PTR _iNumValidPlots$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _fCurrentRatio$[ebp], xmm0

; 1310 : 
; 1311 : 	return fCurrentRatio;

	fld	QWORD PTR _fCurrentRatio$[ebp]
$LN10@GetImprove:

; 1312 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetImprovedToImprovablePlotsRatio@CvEconomicAI@@QAENXZ ENDP ; CvEconomicAI::GetImprovedToImprovablePlotsRatio
_TEXT	ENDS
PUBLIC	??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
PUBLIC	??_C@_07JKJOCFLM@Net?5GPT?$AA@			; `string'
PUBLIC	??_C@_0P@GAMOBAMD@Total?5Expenses?$AA@		; `string'
PUBLIC	??_C@_0O@KGDDIJJA@Improve?5Maint?$AA@		; `string'
PUBLIC	??_C@_0M@IDBOIBIH@Build?5Maint?$AA@		; `string'
PUBLIC	??_C@_0L@BNHIDPKB@Unit?5Maint?$AA@		; `string'
PUBLIC	??_C@_0N@FGLODKOD@Total?5Income?$AA@		; `string'
PUBLIC	??_C@_0N@CFBKLDPF@GPT?5?9?5Traits?$AA@		; `string'
PUBLIC	??_C@_0P@PPABGCDB@GPT?5?9?5Religion?$AA@	; `string'
PUBLIC	??_C@_0M@OPNDOILH@GPT?5?9?5Diplo?$AA@		; `string'
PUBLIC	??_C@_0P@KFICJKND@GPT?5?9?5Connects?$AA@	; `string'
PUBLIC	??_C@_08IJAAGGEL@Treasury?$AA@			; `string'
PUBLIC	??_C@_0BH@MGLBPLFG@Gold?5From?5Trade?5Routes?$AA@ ; `string'
PUBLIC	??_C@_0BB@IKGHBEPE@Gold?5From?5Cities?$AA@	; `string'
PUBLIC	??_C@_0BH@FMGEJMDA@Trade?5Routes?5available?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GPDMDGKG@Trade?5Routes?5established?$AA@ ; `string'
PUBLIC	??_C@_0P@FHPLPJCO@Improved?5tiles?$AA@		; `string'
PUBLIC	??_C@_0BI@NDOPNBOH@Worked?5?$CInon?9city?$CJ?5tiles?$AA@ ; `string'
PUBLIC	??_C@_05HGPOGKME@Tiles?$AA@			; `string'
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::push_back_copy
PUBLIC	??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
PUBLIC	??_C@_0O@MHIDIHOD@Net?5Happiness?$AA@		; `string'
PUBLIC	??_C@_0BD@GINDFFEB@Negative?5Happiness?$AA@	; `string'
PUBLIC	??_C@_0BD@OKCDJMKP@Positive?5Happiness?$AA@	; `string'
PUBLIC	??_C@_09OPGEBAIG@?$CD?5Workers?$AA@		; `string'
PUBLIC	??_C@_0BD@DBGPFMPN@Culture?5?$CIlifetime?$CJ?$AA@ ; `string'
PUBLIC	??_C@_08NDDAPGNJ@Policies?$AA@			; `string'
PUBLIC	??_C@_09POJPAGK@Num?5Techs?$AA@			; `string'
PUBLIC	??_C@_05ILJMHAHK@Faith?$AA@			; `string'
PUBLIC	??_C@_07ODOFOAEI@Culture?$AA@			; `string'
PUBLIC	??_C@_07MOBEOMP@Science?$AA@			; `string'
PUBLIC	??_C@_09GLEOMJK@City?5Gold?$AA@			; `string'
PUBLIC	??_C@_0L@LLIJAGM@Production?$AA@		; `string'
PUBLIC	??_C@_04MPDBGAOA@Food?$AA@			; `string'
PUBLIC	??_C@_03HJACNKKK@Pop?$AA@			; `string'
PUBLIC	??_C@_08BJGNLGP@?$CD?5Cities?$AA@		; `string'
PUBLIC	??_C@_04EKEMLFA@Turn?$AA@			; `string'
PUBLIC	??_C@_08IFIFDOPL@Civ?5Name?$AA@			; `string'
PUBLIC	??_C@_0BH@DMOHBKKB@EconomicMonitorLog?4csv?$AA@	; `string'
PUBLIC	??_C@_04EBGNMJBD@?4csv?$AA@			; `string'
PUBLIC	??_C@_0BE@FCCDMGLG@EconomicMonitorLog_?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetImprovementGoldMaintenance
EXTRN	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetBuildingGoldMaintenance
EXTRN	?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetCityConnectionGoldTimes100
EXTRN	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetGoldPerTurnFromTraits
EXTRN	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetGoldPerTurnFromReligion
EXTRN	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ:PROC ; CvTreasury::GetGoldPerTurnFromDiplomacy
EXTRN	?GetCityConnectionGold@CvTreasury@@QBEHXZ:PROC	; CvTreasury::GetCityConnectionGold
EXTRN	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z:PROC ; CvTreasury::GetGoldFromCitiesTimes100
EXTRN	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ:PROC ; CvPlayerTrade::GetNumTradeRoutesPossible
EXTRN	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z:PROC ; CvPlayerTrade::GetNumTradeRoutesUsed
EXTRN	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ:PROC ; CvPlayer::GetTrade
EXTRN	?isBeingWorked@CvPlot@@QBE_NXZ:PROC		; CvPlot::isBeingWorked
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?GetExcessHappiness@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetExcessHappiness
EXTRN	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z:PROC ; CvPlayer::GetUnhappiness
EXTRN	?GetHappiness@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetHappiness
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?GetFaith@CvPlayer@@QBEHXZ:PROC			; CvPlayer::GetFaith
EXTRN	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetJONSCultureEverGenerated
EXTRN	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ:PROC ; CvPlayerPolicies::GetNumPoliciesOwned
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ:PROC	; CvTeamTechs::GetNumTechsKnown
EXTRN	?GetTotalFaithPerTurn@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetTotalFaithPerTurn
EXTRN	?GetTotalJONSCulturePerTurn@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetTotalJONSCulturePerTurn
EXTRN	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z:PROC ; CvPlayer::calculateTotalYield
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT ??_C@_07JKJOCFLM@Net?5GPT?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_07JKJOCFLM@Net?5GPT?$AA@ DB 'Net GPT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAMOBAMD@Total?5Expenses?$AA@
CONST	SEGMENT
??_C@_0P@GAMOBAMD@Total?5Expenses?$AA@ DB 'Total Expenses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KGDDIJJA@Improve?5Maint?$AA@
CONST	SEGMENT
??_C@_0O@KGDDIJJA@Improve?5Maint?$AA@ DB 'Improve Maint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDBOIBIH@Build?5Maint?$AA@
CONST	SEGMENT
??_C@_0M@IDBOIBIH@Build?5Maint?$AA@ DB 'Build Maint', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BNHIDPKB@Unit?5Maint?$AA@
CONST	SEGMENT
??_C@_0L@BNHIDPKB@Unit?5Maint?$AA@ DB 'Unit Maint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FGLODKOD@Total?5Income?$AA@
CONST	SEGMENT
??_C@_0N@FGLODKOD@Total?5Income?$AA@ DB 'Total Income', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CFBKLDPF@GPT?5?9?5Traits?$AA@
CONST	SEGMENT
??_C@_0N@CFBKLDPF@GPT?5?9?5Traits?$AA@ DB 'GPT - Traits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PPABGCDB@GPT?5?9?5Religion?$AA@
CONST	SEGMENT
??_C@_0P@PPABGCDB@GPT?5?9?5Religion?$AA@ DB 'GPT - Religion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPNDOILH@GPT?5?9?5Diplo?$AA@
CONST	SEGMENT
??_C@_0M@OPNDOILH@GPT?5?9?5Diplo?$AA@ DB 'GPT - Diplo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KFICJKND@GPT?5?9?5Connects?$AA@
CONST	SEGMENT
??_C@_0P@KFICJKND@GPT?5?9?5Connects?$AA@ DB 'GPT - Connects', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJAAGGEL@Treasury?$AA@
CONST	SEGMENT
??_C@_08IJAAGGEL@Treasury?$AA@ DB 'Treasury', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MGLBPLFG@Gold?5From?5Trade?5Routes?$AA@
CONST	SEGMENT
??_C@_0BH@MGLBPLFG@Gold?5From?5Trade?5Routes?$AA@ DB 'Gold From Trade Rou'
	DB	'tes', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IKGHBEPE@Gold?5From?5Cities?$AA@
CONST	SEGMENT
??_C@_0BB@IKGHBEPE@Gold?5From?5Cities?$AA@ DB 'Gold From Cities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FMGEJMDA@Trade?5Routes?5available?$AA@
CONST	SEGMENT
??_C@_0BH@FMGEJMDA@Trade?5Routes?5available?$AA@ DB 'Trade Routes availab'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GPDMDGKG@Trade?5Routes?5established?$AA@
CONST	SEGMENT
??_C@_0BJ@GPDMDGKG@Trade?5Routes?5established?$AA@ DB 'Trade Routes estab'
	DB	'lished', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FHPLPJCO@Improved?5tiles?$AA@
CONST	SEGMENT
??_C@_0P@FHPLPJCO@Improved?5tiles?$AA@ DB 'Improved tiles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NDOPNBOH@Worked?5?$CInon?9city?$CJ?5tiles?$AA@
CONST	SEGMENT
??_C@_0BI@NDOPNBOH@Worked?5?$CInon?9city?$CJ?5tiles?$AA@ DB 'Worked (non-'
	DB	'city) tiles', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05HGPOGKME@Tiles?$AA@
CONST	SEGMENT
??_C@_05HGPOGKME@Tiles?$AA@ DB 'Tiles', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MHIDIHOD@Net?5Happiness?$AA@
CONST	SEGMENT
??_C@_0O@MHIDIHOD@Net?5Happiness?$AA@ DB 'Net Happiness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GINDFFEB@Negative?5Happiness?$AA@
CONST	SEGMENT
??_C@_0BD@GINDFFEB@Negative?5Happiness?$AA@ DB 'Negative Happiness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OKCDJMKP@Positive?5Happiness?$AA@
CONST	SEGMENT
??_C@_0BD@OKCDJMKP@Positive?5Happiness?$AA@ DB 'Positive Happiness', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OPGEBAIG@?$CD?5Workers?$AA@
CONST	SEGMENT
??_C@_09OPGEBAIG@?$CD?5Workers?$AA@ DB '# Workers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBGPFMPN@Culture?5?$CIlifetime?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DBGPFMPN@Culture?5?$CIlifetime?$CJ?$AA@ DB 'Culture (lifetime)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NDDAPGNJ@Policies?$AA@
CONST	SEGMENT
??_C@_08NDDAPGNJ@Policies?$AA@ DB 'Policies', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09POJPAGK@Num?5Techs?$AA@
CONST	SEGMENT
??_C@_09POJPAGK@Num?5Techs?$AA@ DB 'Num Techs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05ILJMHAHK@Faith?$AA@
CONST	SEGMENT
??_C@_05ILJMHAHK@Faith?$AA@ DB 'Faith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODOFOAEI@Culture?$AA@
CONST	SEGMENT
??_C@_07ODOFOAEI@Culture?$AA@ DB 'Culture', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MOBEOMP@Science?$AA@
CONST	SEGMENT
??_C@_07MOBEOMP@Science?$AA@ DB 'Science', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GLEOMJK@City?5Gold?$AA@
CONST	SEGMENT
??_C@_09GLEOMJK@City?5Gold?$AA@ DB 'City Gold', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LLIJAGM@Production?$AA@
CONST	SEGMENT
??_C@_0L@LLIJAGM@Production?$AA@ DB 'Production', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MPDBGAOA@Food?$AA@
CONST	SEGMENT
??_C@_04MPDBGAOA@Food?$AA@ DB 'Food', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HJACNKKK@Pop?$AA@
CONST	SEGMENT
??_C@_03HJACNKKK@Pop?$AA@ DB 'Pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJGNLGP@?$CD?5Cities?$AA@
CONST	SEGMENT
??_C@_08BJGNLGP@?$CD?5Cities?$AA@ DB '# Cities', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKEMLFA@Turn?$AA@
CONST	SEGMENT
??_C@_04EKEMLFA@Turn?$AA@ DB 'Turn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFIFDOPL@Civ?5Name?$AA@
CONST	SEGMENT
??_C@_08IFIFDOPL@Civ?5Name?$AA@ DB 'Civ Name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DMOHBKKB@EconomicMonitorLog?4csv?$AA@
CONST	SEGMENT
??_C@_0BH@DMOHBKKB@EconomicMonitorLog?4csv?$AA@ DB 'EconomicMonitorLog.cs'
	DB	'v', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBGNMJBD@?4csv?$AA@
CONST	SEGMENT
??_C@_04EBGNMJBD@?4csv?$AA@ DB '.csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FCCDMGLG@EconomicMonitorLog_?$AA@
CONST	SEGMENT
??_C@_0BE@FCCDMGLG@EconomicMonitorLog_?$AA@ DB 'EconomicMonitorLog_', 00H ; `string'
CONST	ENDS
;	COMDAT ?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA
_DATA	SEGMENT
?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA DB 01H ; `CvEconomicAI::LogMonitor'::`8'::bFirstRun
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogMonitor@CvEconomicAI@@QAEXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogMonitor@CvEconomicAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogMonitor@CvEconomicAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$7
	DD	06H
	DD	FLAT:__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$26
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogMonitor@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
tv1242 = -1040						; size = 4
tv1934 = -1036						; size = 4
tv1239 = -1032						; size = 4
tv1921 = -1028						; size = 4
tv1236 = -1024						; size = 4
tv1876 = -1020						; size = 4
tv1233 = -1016						; size = 4
tv1863 = -1012						; size = 4
tv1230 = -1008						; size = 4
tv1850 = -1004						; size = 4
tv1227 = -1000						; size = 4
tv1837 = -996						; size = 4
tv1224 = -992						; size = 4
tv1824 = -988						; size = 4
tv1221 = -984						; size = 4
tv1811 = -980						; size = 4
tv1218 = -976						; size = 4
tv1798 = -972						; size = 4
tv1215 = -968						; size = 4
tv1785 = -964						; size = 4
tv1212 = -960						; size = 4
tv1772 = -956						; size = 4
tv1209 = -952						; size = 4
tv1759 = -948						; size = 4
tv1206 = -944						; size = 4
tv1746 = -940						; size = 4
tv1203 = -936						; size = 4
tv1733 = -932						; size = 4
tv1200 = -928						; size = 4
tv1720 = -924						; size = 4
tv1197 = -920						; size = 4
tv1707 = -916						; size = 4
tv1194 = -912						; size = 4
tv1694 = -908						; size = 4
tv1191 = -904						; size = 4
tv1649 = -900						; size = 4
tv1640 = -896						; size = 4
tv1187 = -892						; size = 4
tv1609 = -888						; size = 4
tv1184 = -884						; size = 4
tv1596 = -880						; size = 4
tv1181 = -876						; size = 4
tv1583 = -872						; size = 4
tv1178 = -868						; size = 4
tv1570 = -864						; size = 4
tv1175 = -860						; size = 4
tv1525 = -856						; size = 4
tv1172 = -852						; size = 4
tv1512 = -848						; size = 4
tv1169 = -844						; size = 4
tv1499 = -840						; size = 4
tv1166 = -836						; size = 4
tv1486 = -832						; size = 4
tv1163 = -828						; size = 4
tv1468 = -824						; size = 4
tv1160 = -820						; size = 4
tv1455 = -816						; size = 4
tv1157 = -812						; size = 4
tv1442 = -808						; size = 4
tv1154 = -804						; size = 4
tv1429 = -800						; size = 4
tv1151 = -796						; size = 4
tv1416 = -792						; size = 4
tv1148 = -788						; size = 4
tv1403 = -784						; size = 4
tv271 = -780						; size = 4
tv1145 = -776						; size = 4
tv1390 = -772						; size = 4
tv1142 = -768						; size = 4
tv1377 = -764						; size = 4
tv1139 = -760						; size = 4
tv1364 = -756						; size = 4
tv1136 = -752						; size = 4
tv1351 = -748						; size = 4
tv1133 = -744						; size = 4
tv154 = -740						; size = 4
tv1887 = -736						; size = 4
tv1128 = -732						; size = 4
tv1932 = -728						; size = 4
_this$ = -724						; size = 4
$T234438 = -708						; size = 4
$T234434 = -704						; size = 4
$T234430 = -700						; size = 4
$T234421 = -696						; size = 4
$T234412 = -692						; size = 4
$T234403 = -688						; size = 4
$T234394 = -684						; size = 4
$T234385 = -680						; size = 4
$T234381 = -676						; size = 4
$T234377 = -672						; size = 4
$T234368 = -668						; size = 4
$T234359 = -664						; size = 4
$T234350 = -660						; size = 4
$T234341 = -656						; size = 4
$T234332 = -652						; size = 4
$T234323 = -648						; size = 4
$T234314 = -644						; size = 4
$T234305 = -640						; size = 4
$T234296 = -636						; size = 4
$T234287 = -632						; size = 4
$T234278 = -628						; size = 4
$T234269 = -624						; size = 4
$T234255 = -616						; size = 4
$T234248 = -612						; size = 4
$T234241 = -608						; size = 4
$T234237 = -604						; size = 4
$T234230 = -600						; size = 4
$T234203 = -580						; size = 4
$T234194 = -576						; size = 4
$T234185 = -572						; size = 4
$T234176 = -568						; size = 4
$T234167 = -564						; size = 4
$T234158 = -560						; size = 4
$T234149 = -556						; size = 4
$T234140 = -552						; size = 4
$T234131 = -548						; size = 4
$T234127 = -544						; size = 4
$T234126 = -540						; size = 4
$T234117 = -536						; size = 4
$T234108 = -532						; size = 4
$T234099 = -528						; size = 4
$T234090 = -524						; size = 4
$T234081 = -520						; size = 4
$T234072 = -516						; size = 4
$T234063 = -512						; size = 4
$T234054 = -508						; size = 4
$T234045 = -504						; size = 4
$T234036 = -500						; size = 4
$T234032 = -496						; size = 4
$T234023 = -492						; size = 4
$T234014 = -488						; size = 4
$T234005 = -484						; size = 4
$T233997 = -480						; size = 4
$T233934 = -476						; size = 4
$T233933 = -472						; size = 4
$T233932 = -468						; size = 4
$T233931 = -464						; size = 4
$T233930 = -460						; size = 4
$T233929 = -456						; size = 4
$T233928 = -452						; size = 4
$T233927 = -448						; size = 4
$T233926 = -444						; size = 4
$T233925 = -440						; size = 4
$T233924 = -436						; size = 4
$T233923 = -432						; size = 4
$T233922 = -428						; size = 4
$T233921 = -424						; size = 4
$T233920 = -420						; size = 4
$T233919 = -416						; size = 4
$T233918 = -412						; size = 4
$T233917 = -408						; size = 4
$T233916 = -404						; size = 4
$T233915 = -400						; size = 4
$T233914 = -396						; size = 4
$T233913 = -392						; size = 4
$T233912 = -388						; size = 4
$T233911 = -384						; size = 4
$T233910 = -380						; size = 4
$T233909 = -376						; size = 4
$T233908 = -372						; size = 4
$T233907 = -368						; size = 4
$T233906 = -364						; size = 4
$T233905 = -360						; size = 4
$T233904 = -356						; size = 4
$T233903 = -352						; size = 4
$T233902 = -348						; size = 4
$T233901 = -344						; size = 4
$T233900 = -340						; size = 4
$T233899 = -336						; size = 4
$T233898 = -332						; size = 4
$T233897 = -328						; size = 4
$T233896 = -324						; size = 28
$T233895 = -296						; size = 28
_pPlot$225830 = -268					; size = 4
_uiPlotIndex$225825 = -264				; size = 4
_ui$225691 = -260					; size = 4
_str$ = -256						; size = 28
_iLoopCity$ = -228					; size = 4
_m_aiNumImprovements$ = -224				; size = 12
_iGPTFromTraits$ = -212					; size = 4
_aiPlots$ = -208					; size = 4
_pTreasury$ = -204					; size = 4
_strLog$ = -200						; size = 28
_iGPTFromDiplomacy$ = -172				; size = 4
_iGPTFromReligion$ = -168				; size = 4
_iGoldFromCitiesMinusTR$ = -164				; size = 4
_iTotalIncome$ = -160					; size = 4
_iLoopUnit$ = -156					; size = 4
_iTiles$ = -152						; size = 4
_iInternationalTradeGPT$ = -148				; size = 4
_iExpenses$ = -144					; size = 4
_bBuildHeader$ = -137					; size = 1
_strPlayerName$ = -136					; size = 28
_iWorkedTiles$ = -108					; size = 4
_iGoldFromCityConnect$ = -104				; size = 4
_pLoopUnit$ = -100					; size = 4
_strLogName$ = -96					; size = 28
_pLog$ = -68						; size = 4
_iImprovedTiles$ = -64					; size = 4
_iTradeRouteGold$ = -60					; size = 4
_iPop$ = -56						; size = 4
_strHeader$ = -52					; size = 28
__$ArrayPad$ = -24					; size = 4
_pLoopCity$ = -20					; size = 4
_iWorkerCount$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogMonitor@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::LogMonitor, COMDAT
; _this$ = ecx

; 1317 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogMonitor@CvEconomicAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1028				; 00000404H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1318 : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN32@LogMonitor
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN33@LogMonitor
$LN32@LogMonitor:

; 1319 : 	{
; 1320 : 		return;

	jmp	$LN34@LogMonitor
$LN33@LogMonitor:

; 1321 : 	}
; 1322 : 
; 1323 : 	// don't log minor civs for now
; 1324 : 	if(m_pPlayer->isMinorCiv())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@LogMonitor

; 1325 : 	{
; 1326 : 		return;

	jmp	$LN34@LogMonitor
$LN31@LogMonitor:

; 1327 : 	}
; 1328 : 
; 1329 : 	static bool bFirstRun = true;
; 1330 : 	bool bBuildHeader = false;

	mov	BYTE PTR _bBuildHeader$[ebp], 0

; 1331 : 	CvString strHeader;

	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1332 : 	if(bFirstRun)

	movzx	ecx, BYTE PTR ?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA
	test	ecx, ecx
	je	SHORT $LN30@LogMonitor

; 1333 : 	{
; 1334 : 		bFirstRun = false;

	mov	BYTE PTR ?bFirstRun@?7??LogMonitor@CvEconomicAI@@QAEXXZ@4_NA, 0

; 1335 : 		bBuildHeader = true;

	mov	BYTE PTR _bBuildHeader$[ebp], 1
$LN30@LogMonitor:

; 1336 : 	}
; 1337 : 
; 1338 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1339 : 
; 1340 : 	// Find the name of this civ and city
; 1341 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1342 : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T233997[ebp], eax
	cmp	DWORD PTR $T233997[ebp], 0
	je	SHORT $LN91@LogMonitor
	mov	eax, DWORD PTR $T233997[ebp]
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN92@LogMonitor
$LN91@LogMonitor:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN92@LogMonitor:

; 1343 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1344 : 
; 1345 : 	// Open the log file
; 1346 : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	ecx, al
	test	ecx, ecx
	je	$LN29@LogMonitor

; 1347 : 	{
; 1348 : 		strLogName = "EconomicMonitorLog_" + strPlayerName + ".csv";

	lea	edx, DWORD PTR _strPlayerName$[ebp]
	push	edx
	push	OFFSET ??_C@_0BE@FCCDMGLG@EconomicMonitorLog_?$AA@
	lea	eax, DWORD PTR $T233895[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1932[ebp], eax
	mov	ecx, DWORD PTR tv1932[ebp]
	mov	DWORD PTR tv1128[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv1128[ebp]
	push	edx
	lea	eax, DWORD PTR $T233896[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1887[ebp], eax
	mov	ecx, DWORD PTR tv1887[ebp]
	mov	DWORD PTR $T234005[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T234005[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T233896[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T233895[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1349 : 	}
; 1350 : 	else

	jmp	SHORT $LN28@LogMonitor
$LN29@LogMonitor:

; 1351 : 	{
; 1352 : 		strLogName = "EconomicMonitorLog.csv";

	mov	edx, OFFSET ??_C@_0BH@DMOHBKKB@EconomicMonitorLog?4csv?$AA@
	test	edx, edx
	je	SHORT $LN100@LogMonitor
	push	OFFSET ??_C@_0BH@DMOHBKKB@EconomicMonitorLog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN28@LogMonitor
$LN100@LogMonitor:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN28@LogMonitor:

; 1353 : 	}
; 1354 : 
; 1355 : 	FILogFile* pLog;
; 1356 : 	pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv154[ebp], eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T234014[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T234014[ebp]
	push	eax
	mov	ecx, DWORD PTR tv154[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv154[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$[ebp], eax

; 1357 : 
; 1358 : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 1359 : 
; 1360 : 	// civ name
; 1361 : 	AppendToLog(strHeader, strLog, "Civ Name", strPlayerName);

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233897[ebp], esp
	mov	DWORD PTR $T234023[ebp], ecx
	lea	edx, DWORD PTR _strPlayerName$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234023[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T234023[ebp]
	mov	DWORD PTR tv1133[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233898[ebp], esp
	mov	DWORD PTR $T234032[ebp], ecx
	mov	edx, OFFSET ??_C@_08IFIFDOPL@Civ?5Name?$AA@
	test	edx, edx
	je	SHORT $LN113@LogMonitor
	mov	DWORD PTR tv1351[ebp], OFFSET ??_C@_08IFIFDOPL@Civ?5Name?$AA@
	jmp	SHORT $LN114@LogMonitor
$LN113@LogMonitor:
	mov	DWORD PTR tv1351[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN114@LogMonitor:
	mov	eax, DWORD PTR tv1351[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234032[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234032[ebp]
	mov	DWORD PTR tv1136[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	call	?AppendToLog@@YAXAAVCvString@@0V1@1@Z	; AppendToLog
	add	esp, 64					; 00000040H

; 1362 : 
; 1363 : 	// turn
; 1364 : 	AppendToLog(strHeader, strLog, "Turn", GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234036[ebp], ecx
	mov	ecx, DWORD PTR $T234036[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233899[ebp], esp
	mov	DWORD PTR $T234045[ebp], edx
	mov	eax, OFFSET ??_C@_04EKEMLFA@Turn?$AA@
	test	eax, eax
	je	SHORT $LN120@LogMonitor
	mov	DWORD PTR tv1364[ebp], OFFSET ??_C@_04EKEMLFA@Turn?$AA@
	jmp	SHORT $LN121@LogMonitor
$LN120@LogMonitor:
	mov	DWORD PTR tv1364[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN121@LogMonitor:
	mov	ecx, DWORD PTR tv1364[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234045[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234045[ebp]
	mov	DWORD PTR tv1139[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1365 : 
; 1366 : 	// # cities
; 1367 : 	AppendToLog(strHeader, strLog, "# Cities", GetPlayer()->getNumCities());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233900[ebp], esp
	mov	DWORD PTR $T234054[ebp], edx
	mov	eax, OFFSET ??_C@_08BJGNLGP@?$CD?5Cities?$AA@
	test	eax, eax
	je	SHORT $LN125@LogMonitor
	mov	DWORD PTR tv1377[ebp], OFFSET ??_C@_08BJGNLGP@?$CD?5Cities?$AA@
	jmp	SHORT $LN126@LogMonitor
$LN125@LogMonitor:
	mov	DWORD PTR tv1377[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN126@LogMonitor:
	mov	ecx, DWORD PTR tv1377[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234054[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234054[ebp]
	mov	DWORD PTR tv1142[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1368 : 
; 1369 : 	// total pop
; 1370 : 	int iPop = 0;

	mov	DWORD PTR _iPop$[ebp], 0

; 1371 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 1372 : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 1373 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoopCity))

	push	0
	lea	edx, DWORD PTR _iLoopCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN27@LogMonitor
$LN26@LogMonitor:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN27@LogMonitor:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN25@LogMonitor

; 1374 : 	{
; 1375 : 		iPop += pLoopCity->getPopulation();

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	add	eax, DWORD PTR _iPop$[ebp]
	mov	DWORD PTR _iPop$[ebp], eax

; 1376 : 	}

	jmp	SHORT $LN26@LogMonitor
$LN25@LogMonitor:

; 1377 : 	AppendToLog(strHeader, strLog, "Pop", iPop);

	mov	edx, DWORD PTR _iPop$[ebp]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233901[ebp], esp
	mov	DWORD PTR $T234063[ebp], eax
	mov	ecx, OFFSET ??_C@_03HJACNKKK@Pop?$AA@
	test	ecx, ecx
	je	SHORT $LN130@LogMonitor
	mov	DWORD PTR tv1390[ebp], OFFSET ??_C@_03HJACNKKK@Pop?$AA@
	jmp	SHORT $LN131@LogMonitor
$LN130@LogMonitor:
	mov	DWORD PTR tv1390[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN131@LogMonitor:
	mov	edx, DWORD PTR tv1390[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234063[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234063[ebp]
	mov	DWORD PTR tv1145[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1378 : 
; 1379 : 	// total yields this turn
; 1380 : 	for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$225691[ebp], 0
	jmp	SHORT $LN24@LogMonitor
$LN23@LogMonitor:
	mov	eax, DWORD PTR _ui$225691[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$225691[ebp], eax
$LN24@LogMonitor:
	cmp	DWORD PTR _ui$225691[ebp], 6
	jae	$LN22@LogMonitor

; 1381 : 	{
; 1382 : 		switch(ui)

	mov	ecx, DWORD PTR _ui$225691[ebp]
	mov	DWORD PTR tv271[ebp], ecx
	cmp	DWORD PTR tv271[ebp], 5
	ja	$LN20@LogMonitor
	mov	edx, DWORD PTR tv271[ebp]
	jmp	DWORD PTR $LN378@LogMonitor[edx*4]
$LN19@LogMonitor:

; 1383 : 		{
; 1384 : 		case YIELD_FOOD:
; 1385 : 			AppendToLog(strHeader, strLog, "Food", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	eax, DWORD PTR _ui$225691[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233902[ebp], esp
	mov	DWORD PTR $T234072[ebp], edx
	mov	eax, OFFSET ??_C@_04MPDBGAOA@Food?$AA@
	test	eax, eax
	je	SHORT $LN135@LogMonitor
	mov	DWORD PTR tv1403[ebp], OFFSET ??_C@_04MPDBGAOA@Food?$AA@
	jmp	SHORT $LN136@LogMonitor
$LN135@LogMonitor:
	mov	DWORD PTR tv1403[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN136@LogMonitor:
	mov	ecx, DWORD PTR tv1403[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234072[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234072[ebp]
	mov	DWORD PTR tv1148[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1386 : 			break;

	jmp	$LN20@LogMonitor
$LN18@LogMonitor:

; 1387 : 		case YIELD_PRODUCTION:
; 1388 : 			AppendToLog(strHeader, strLog, "Production", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	edx, DWORD PTR _ui$225691[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233903[ebp], esp
	mov	DWORD PTR $T234081[ebp], ecx
	mov	edx, OFFSET ??_C@_0L@LLIJAGM@Production?$AA@
	test	edx, edx
	je	SHORT $LN140@LogMonitor
	mov	DWORD PTR tv1416[ebp], OFFSET ??_C@_0L@LLIJAGM@Production?$AA@
	jmp	SHORT $LN141@LogMonitor
$LN140@LogMonitor:
	mov	DWORD PTR tv1416[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN141@LogMonitor:
	mov	eax, DWORD PTR tv1416[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234081[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234081[ebp]
	mov	DWORD PTR tv1151[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1389 : 			break;

	jmp	$LN20@LogMonitor
$LN17@LogMonitor:

; 1390 : 		case YIELD_GOLD:
; 1391 : 			AppendToLog(strHeader, strLog, "City Gold", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	ecx, DWORD PTR _ui$225691[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233904[ebp], esp
	mov	DWORD PTR $T234090[ebp], eax
	mov	ecx, OFFSET ??_C@_09GLEOMJK@City?5Gold?$AA@
	test	ecx, ecx
	je	SHORT $LN145@LogMonitor
	mov	DWORD PTR tv1429[ebp], OFFSET ??_C@_09GLEOMJK@City?5Gold?$AA@
	jmp	SHORT $LN146@LogMonitor
$LN145@LogMonitor:
	mov	DWORD PTR tv1429[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN146@LogMonitor:
	mov	edx, DWORD PTR tv1429[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234090[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234090[ebp]
	mov	DWORD PTR tv1154[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1392 : 			break;

	jmp	$LN20@LogMonitor
$LN16@LogMonitor:

; 1393 : 		case YIELD_SCIENCE:
; 1394 : 			AppendToLog(strHeader, strLog, "Science", m_pPlayer->calculateTotalYield((YieldTypes)ui));

	mov	eax, DWORD PTR _ui$225691[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?calculateTotalYield@CvPlayer@@QBEHW4YieldTypes@@@Z ; CvPlayer::calculateTotalYield
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233905[ebp], esp
	mov	DWORD PTR $T234099[ebp], edx
	mov	eax, OFFSET ??_C@_07MOBEOMP@Science?$AA@
	test	eax, eax
	je	SHORT $LN150@LogMonitor
	mov	DWORD PTR tv1442[ebp], OFFSET ??_C@_07MOBEOMP@Science?$AA@
	jmp	SHORT $LN151@LogMonitor
$LN150@LogMonitor:
	mov	DWORD PTR tv1442[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN151@LogMonitor:
	mov	ecx, DWORD PTR tv1442[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234099[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234099[ebp]
	mov	DWORD PTR tv1157[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1395 : 			break;

	jmp	$LN20@LogMonitor
$LN15@LogMonitor:

; 1396 : 		case YIELD_CULTURE:
; 1397 : 			AppendToLog(strHeader, strLog, "Culture", m_pPlayer->GetTotalJONSCulturePerTurn());

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTotalJONSCulturePerTurn@CvPlayer@@QBEHXZ ; CvPlayer::GetTotalJONSCulturePerTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233906[ebp], esp
	mov	DWORD PTR $T234108[ebp], eax
	mov	ecx, OFFSET ??_C@_07ODOFOAEI@Culture?$AA@
	test	ecx, ecx
	je	SHORT $LN155@LogMonitor
	mov	DWORD PTR tv1455[ebp], OFFSET ??_C@_07ODOFOAEI@Culture?$AA@
	jmp	SHORT $LN156@LogMonitor
$LN155@LogMonitor:
	mov	DWORD PTR tv1455[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN156@LogMonitor:
	mov	edx, DWORD PTR tv1455[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234108[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234108[ebp]
	mov	DWORD PTR tv1160[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1398 : 			break;

	jmp	SHORT $LN20@LogMonitor
$LN14@LogMonitor:

; 1399 : 		case YIELD_FAITH:
; 1400 : 			AppendToLog(strHeader, strLog, "Faith", m_pPlayer->GetTotalFaithPerTurn());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetTotalFaithPerTurn@CvPlayer@@QBEHXZ	; CvPlayer::GetTotalFaithPerTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233907[ebp], esp
	mov	DWORD PTR $T234117[ebp], ecx
	mov	edx, OFFSET ??_C@_05ILJMHAHK@Faith?$AA@
	test	edx, edx
	je	SHORT $LN160@LogMonitor
	mov	DWORD PTR tv1468[ebp], OFFSET ??_C@_05ILJMHAHK@Faith?$AA@
	jmp	SHORT $LN161@LogMonitor
$LN160@LogMonitor:
	mov	DWORD PTR tv1468[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN161@LogMonitor:
	mov	eax, DWORD PTR tv1468[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234117[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234117[ebp]
	mov	DWORD PTR tv1163[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN20@LogMonitor:

; 1401 : 			break;
; 1402 : 		}
; 1403 : 	}

	jmp	$LN23@LogMonitor
$LN22@LogMonitor:

; 1404 : 
; 1405 : 	// Num Techs
; 1406 : 	AppendToLog(strHeader, strLog, "Num Techs", GET_TEAM(GetPlayer()->getTeam()).GetTeamTechs()->GetNumTechsKnown());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	DWORD PTR $T234126[ebp], eax
	mov	ecx, DWORD PTR $T234126[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T234127[ebp], eax
	mov	eax, DWORD PTR $T234127[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T234131[ebp], eax
	mov	ecx, DWORD PTR $T234131[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233908[ebp], esp
	mov	DWORD PTR $T234140[ebp], ecx
	mov	edx, OFFSET ??_C@_09POJPAGK@Num?5Techs?$AA@
	test	edx, edx
	je	SHORT $LN171@LogMonitor
	mov	DWORD PTR tv1486[ebp], OFFSET ??_C@_09POJPAGK@Num?5Techs?$AA@
	jmp	SHORT $LN172@LogMonitor
$LN171@LogMonitor:
	mov	DWORD PTR tv1486[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN172@LogMonitor:
	mov	eax, DWORD PTR tv1486[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234140[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234140[ebp]
	mov	DWORD PTR tv1166[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1407 : 
; 1408 : 	// Culture
; 1409 : 	AppendToLog(strHeader, strLog, "Policies", GetPlayer()->GetPlayerPolicies()->GetNumPoliciesOwned());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumPoliciesOwned@CvPlayerPolicies@@QBEHXZ ; CvPlayerPolicies::GetNumPoliciesOwned
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233909[ebp], esp
	mov	DWORD PTR $T234149[ebp], ecx
	mov	edx, OFFSET ??_C@_08NDDAPGNJ@Policies?$AA@
	test	edx, edx
	je	SHORT $LN176@LogMonitor
	mov	DWORD PTR tv1499[ebp], OFFSET ??_C@_08NDDAPGNJ@Policies?$AA@
	jmp	SHORT $LN177@LogMonitor
$LN176@LogMonitor:
	mov	DWORD PTR tv1499[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN177@LogMonitor:
	mov	eax, DWORD PTR tv1499[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234149[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234149[ebp]
	mov	DWORD PTR tv1169[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1410 : 	AppendToLog(strHeader, strLog, "Culture (lifetime)", GetPlayer()->GetJONSCultureEverGenerated());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?GetJONSCultureEverGenerated@CvPlayer@@QBEHXZ ; CvPlayer::GetJONSCultureEverGenerated
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233910[ebp], esp
	mov	DWORD PTR $T234158[ebp], ecx
	mov	edx, OFFSET ??_C@_0BD@DBGPFMPN@Culture?5?$CIlifetime?$CJ?$AA@
	test	edx, edx
	je	SHORT $LN181@LogMonitor
	mov	DWORD PTR tv1512[ebp], OFFSET ??_C@_0BD@DBGPFMPN@Culture?5?$CIlifetime?$CJ?$AA@
	jmp	SHORT $LN182@LogMonitor
$LN181@LogMonitor:
	mov	DWORD PTR tv1512[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN182@LogMonitor:
	mov	eax, DWORD PTR tv1512[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234158[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234158[ebp]
	mov	DWORD PTR tv1172[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1411 : 
; 1412 : 	// Faith
; 1413 : 	AppendToLog(strHeader, strLog, "Faith", GetPlayer()->GetFaith());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?GetFaith@CvPlayer@@QBEHXZ		; CvPlayer::GetFaith
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233911[ebp], esp
	mov	DWORD PTR $T234167[ebp], ecx
	mov	edx, OFFSET ??_C@_05ILJMHAHK@Faith?$AA@
	test	edx, edx
	je	SHORT $LN186@LogMonitor
	mov	DWORD PTR tv1525[ebp], OFFSET ??_C@_05ILJMHAHK@Faith?$AA@
	jmp	SHORT $LN187@LogMonitor
$LN186@LogMonitor:
	mov	DWORD PTR tv1525[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN187@LogMonitor:
	mov	eax, DWORD PTR tv1525[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234167[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234167[ebp]
	mov	DWORD PTR tv1175[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1414 : 
; 1415 : 	// workers
; 1416 : 	int iWorkerCount = 0;

	mov	DWORD PTR _iWorkerCount$[ebp], 0

; 1417 : 	CvUnit* pLoopUnit;
; 1418 : 	int iLoopUnit;
; 1419 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	ecx, DWORD PTR _iLoopUnit$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN13@LogMonitor
$LN12@LogMonitor:
	push	0
	lea	eax, DWORD PTR _iLoopUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN13@LogMonitor:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN11@LogMonitor

; 1420 : 	{
; 1421 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	jne	SHORT $LN10@LogMonitor

; 1422 : 		{
; 1423 : 			iWorkerCount++;

	mov	edx, DWORD PTR _iWorkerCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iWorkerCount$[ebp], edx
$LN10@LogMonitor:

; 1424 : 		}
; 1425 : 	}

	jmp	SHORT $LN12@LogMonitor
$LN11@LogMonitor:

; 1426 : 	AppendToLog(strHeader, strLog, "# Workers", iWorkerCount);

	mov	eax, DWORD PTR _iWorkerCount$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233912[ebp], esp
	mov	DWORD PTR $T234176[ebp], ecx
	mov	edx, OFFSET ??_C@_09OPGEBAIG@?$CD?5Workers?$AA@
	test	edx, edx
	je	SHORT $LN191@LogMonitor
	mov	DWORD PTR tv1570[ebp], OFFSET ??_C@_09OPGEBAIG@?$CD?5Workers?$AA@
	jmp	SHORT $LN192@LogMonitor
$LN191@LogMonitor:
	mov	DWORD PTR tv1570[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN192@LogMonitor:
	mov	eax, DWORD PTR tv1570[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234176[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234176[ebp]
	mov	DWORD PTR tv1178[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1427 : 	AppendToLog(strHeader, strLog, "Positive Happiness",  m_pPlayer->GetHappiness());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetHappiness@CvPlayer@@QBEHXZ		; CvPlayer::GetHappiness
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233913[ebp], esp
	mov	DWORD PTR $T234185[ebp], edx
	mov	eax, OFFSET ??_C@_0BD@OKCDJMKP@Positive?5Happiness?$AA@
	test	eax, eax
	je	SHORT $LN196@LogMonitor
	mov	DWORD PTR tv1583[ebp], OFFSET ??_C@_0BD@OKCDJMKP@Positive?5Happiness?$AA@
	jmp	SHORT $LN197@LogMonitor
$LN196@LogMonitor:
	mov	DWORD PTR tv1583[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN197@LogMonitor:
	mov	ecx, DWORD PTR tv1583[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234185[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234185[ebp]
	mov	DWORD PTR tv1181[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1428 : 	AppendToLog(strHeader, strLog, "Negative Happiness", m_pPlayer->GetUnhappiness());

	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233914[ebp], esp
	mov	DWORD PTR $T234194[ebp], eax
	mov	ecx, OFFSET ??_C@_0BD@GINDFFEB@Negative?5Happiness?$AA@
	test	ecx, ecx
	je	SHORT $LN201@LogMonitor
	mov	DWORD PTR tv1596[ebp], OFFSET ??_C@_0BD@GINDFFEB@Negative?5Happiness?$AA@
	jmp	SHORT $LN202@LogMonitor
$LN201@LogMonitor:
	mov	DWORD PTR tv1596[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN202@LogMonitor:
	mov	edx, DWORD PTR tv1596[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234194[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234194[ebp]
	mov	DWORD PTR tv1184[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1429 : 	AppendToLog(strHeader, strLog, "Net Happiness", m_pPlayer->GetExcessHappiness());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233915[ebp], esp
	mov	DWORD PTR $T234203[ebp], ecx
	mov	edx, OFFSET ??_C@_0O@MHIDIHOD@Net?5Happiness?$AA@
	test	edx, edx
	je	SHORT $LN206@LogMonitor
	mov	DWORD PTR tv1609[ebp], OFFSET ??_C@_0O@MHIDIHOD@Net?5Happiness?$AA@
	jmp	SHORT $LN207@LogMonitor
$LN206@LogMonitor:
	mov	DWORD PTR tv1609[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN207@LogMonitor:
	mov	eax, DWORD PTR tv1609[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234203[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234203[ebp]
	mov	DWORD PTR tv1187[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1430 : 
; 1431 : 	// # of each improvement constructed
; 1432 : 	FFastVector<int, true> m_aiNumImprovements;

	push	0
	lea	ecx, DWORD PTR _m_aiNumImprovements$[ebp]
	call	??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 1433 : 	m_aiNumImprovements.push_back_copy(-1, GC.getNumImprovementInfos());

	mov	DWORD PTR $T233916[ebp], -1
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	push	eax
	lea	ecx, DWORD PTR $T233916[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_aiNumImprovements$[ebp]
	call	?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::push_back_copy

; 1434 : 
; 1435 : 	// go through all the plots the player has under their control
; 1436 : 	CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	DWORD PTR _aiPlots$[ebp], eax

; 1437 : 
; 1438 : 	// worked tiles
; 1439 : 	int iTiles = 0;

	mov	DWORD PTR _iTiles$[ebp], 0

; 1440 : 	int iWorkedTiles = 0;

	mov	DWORD PTR _iWorkedTiles$[ebp], 0

; 1441 : 	int iImprovedTiles = 0;

	mov	DWORD PTR _iImprovedTiles$[ebp], 0

; 1442 : 	for(uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)

	mov	DWORD PTR _uiPlotIndex$225825[ebp], 0
	jmp	SHORT $LN9@LogMonitor
$LN8@LogMonitor:
	mov	eax, DWORD PTR _uiPlotIndex$225825[ebp]
	add	eax, 1
	mov	DWORD PTR _uiPlotIndex$225825[ebp], eax
$LN9@LogMonitor:
	mov	ecx, DWORD PTR _aiPlots$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T234230[ebp], edx
	mov	eax, DWORD PTR _uiPlotIndex$225825[ebp]
	cmp	eax, DWORD PTR $T234230[ebp]
	jae	$LN7@LogMonitor

; 1443 : 	{
; 1444 : 		// when we encounter the first plot that is invalid, the rest of the list will be invalid
; 1445 : 		if(aiPlots[uiPlotIndex] == -1)

	mov	ecx, DWORD PTR _aiPlots$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _uiPlotIndex$225825[ebp]
	cmp	DWORD PTR [edx+eax*4], -1
	jne	SHORT $LN6@LogMonitor

; 1446 : 		{
; 1447 : 			break;

	jmp	$LN7@LogMonitor
$LN6@LogMonitor:

; 1448 : 		}
; 1449 : 
; 1450 : 		CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[uiPlotIndex]);

	mov	ecx, DWORD PTR _aiPlots$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _uiPlotIndex$225825[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T234237[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T234241[ebp], edx
	mov	eax, DWORD PTR $T234237[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T234255[ebp], ecx
	cmp	DWORD PTR $T234255[ebp], 0
	jl	SHORT $LN239@LogMonitor
	mov	edx, DWORD PTR $T234241[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T234248[ebp], eax
	mov	ecx, DWORD PTR $T234255[ebp]
	cmp	ecx, DWORD PTR $T234248[ebp]
	jge	SHORT $LN239@LogMonitor
	mov	edx, DWORD PTR $T234255[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T234241[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv1640[ebp], edx
	jmp	SHORT $LN237@LogMonitor
$LN239@LogMonitor:
	mov	DWORD PTR tv1640[ebp], 0
$LN237@LogMonitor:
	mov	ecx, DWORD PTR tv1640[ebp]
	mov	DWORD PTR _pPlot$225830[ebp], ecx

; 1451 : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$225830[ebp], 0
	jne	SHORT $LN5@LogMonitor

; 1452 : 		{
; 1453 : 			continue;

	jmp	$LN8@LogMonitor
$LN5@LogMonitor:

; 1454 : 		}
; 1455 : 
; 1456 : 		iTiles++;

	mov	edx, DWORD PTR _iTiles$[ebp]
	add	edx, 1
	mov	DWORD PTR _iTiles$[ebp], edx

; 1457 : 
; 1458 : 		// plot has city in it, don't count
; 1459 : 		if(pPlot->getPlotCity())

	mov	ecx, DWORD PTR _pPlot$225830[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	je	SHORT $LN4@LogMonitor

; 1460 : 		{
; 1461 : 			continue;

	jmp	$LN8@LogMonitor
$LN4@LogMonitor:

; 1462 : 		}
; 1463 : 
; 1464 : 		if(pPlot->isBeingWorked())

	mov	ecx, DWORD PTR _pPlot$225830[ebp]
	call	?isBeingWorked@CvPlot@@QBE_NXZ		; CvPlot::isBeingWorked
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@LogMonitor

; 1465 : 		{
; 1466 : 			iWorkedTiles++;

	mov	ecx, DWORD PTR _iWorkedTiles$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iWorkedTiles$[ebp], ecx
$LN3@LogMonitor:

; 1467 : 		}
; 1468 : 
; 1469 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pPlot$225830[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN2@LogMonitor

; 1470 : 		{
; 1471 : 			iImprovedTiles++;

	mov	edx, DWORD PTR _iImprovedTiles$[ebp]
	add	edx, 1
	mov	DWORD PTR _iImprovedTiles$[ebp], edx
$LN2@LogMonitor:

; 1472 : 		}
; 1473 : 	}

	jmp	$LN8@LogMonitor
$LN7@LogMonitor:

; 1474 : 
; 1475 : 	AppendToLog(strHeader, strLog, "Tiles", iTiles);

	mov	eax, DWORD PTR _iTiles$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233917[ebp], esp
	mov	DWORD PTR $T234269[ebp], ecx
	mov	edx, OFFSET ??_C@_05HGPOGKME@Tiles?$AA@
	test	edx, edx
	je	SHORT $LN250@LogMonitor
	mov	DWORD PTR tv1649[ebp], OFFSET ??_C@_05HGPOGKME@Tiles?$AA@
	jmp	SHORT $LN251@LogMonitor
$LN250@LogMonitor:
	mov	DWORD PTR tv1649[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN251@LogMonitor:
	mov	eax, DWORD PTR tv1649[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234269[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234269[ebp]
	mov	DWORD PTR tv1191[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1476 : 	AppendToLog(strHeader, strLog, "Worked (non-city) tiles", iWorkedTiles);

	mov	ecx, DWORD PTR _iWorkedTiles$[ebp]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233918[ebp], esp
	mov	DWORD PTR $T234278[ebp], edx
	mov	eax, OFFSET ??_C@_0BI@NDOPNBOH@Worked?5?$CInon?9city?$CJ?5tiles?$AA@
	test	eax, eax
	je	SHORT $LN255@LogMonitor
	mov	DWORD PTR tv1694[ebp], OFFSET ??_C@_0BI@NDOPNBOH@Worked?5?$CInon?9city?$CJ?5tiles?$AA@
	jmp	SHORT $LN256@LogMonitor
$LN255@LogMonitor:
	mov	DWORD PTR tv1694[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN256@LogMonitor:
	mov	ecx, DWORD PTR tv1694[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234278[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234278[ebp]
	mov	DWORD PTR tv1194[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1477 : 	AppendToLog(strHeader, strLog, "Improved tiles", iImprovedTiles);

	mov	edx, DWORD PTR _iImprovedTiles$[ebp]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233919[ebp], esp
	mov	DWORD PTR $T234287[ebp], eax
	mov	ecx, OFFSET ??_C@_0P@FHPLPJCO@Improved?5tiles?$AA@
	test	ecx, ecx
	je	SHORT $LN260@LogMonitor
	mov	DWORD PTR tv1707[ebp], OFFSET ??_C@_0P@FHPLPJCO@Improved?5tiles?$AA@
	jmp	SHORT $LN261@LogMonitor
$LN260@LogMonitor:
	mov	DWORD PTR tv1707[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN261@LogMonitor:
	mov	edx, DWORD PTR tv1707[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234287[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234287[ebp]
	mov	DWORD PTR tv1197[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1478 : 
; 1479 : 	AppendToLog(strHeader, strLog, "Trade Routes established", m_pPlayer->GetTrade()->GetNumTradeRoutesUsed(false));

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumTradeRoutesUsed@CvPlayerTrade@@QAEH_N@Z ; CvPlayerTrade::GetNumTradeRoutesUsed
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233920[ebp], esp
	mov	DWORD PTR $T234296[ebp], ecx
	mov	edx, OFFSET ??_C@_0BJ@GPDMDGKG@Trade?5Routes?5established?$AA@
	test	edx, edx
	je	SHORT $LN265@LogMonitor
	mov	DWORD PTR tv1720[ebp], OFFSET ??_C@_0BJ@GPDMDGKG@Trade?5Routes?5established?$AA@
	jmp	SHORT $LN266@LogMonitor
$LN265@LogMonitor:
	mov	DWORD PTR tv1720[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN266@LogMonitor:
	mov	eax, DWORD PTR tv1720[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234296[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234296[ebp]
	mov	DWORD PTR tv1200[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1480 : 	AppendToLog(strHeader, strLog, "Trade Routes available", (int)m_pPlayer->GetTrade()->GetNumTradeRoutesPossible());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetTrade@CvPlayer@@QBEPAVCvPlayerTrade@@XZ ; CvPlayer::GetTrade
	mov	ecx, eax
	call	?GetNumTradeRoutesPossible@CvPlayerTrade@@QAEIXZ ; CvPlayerTrade::GetNumTradeRoutesPossible
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233921[ebp], esp
	mov	DWORD PTR $T234305[ebp], edx
	mov	eax, OFFSET ??_C@_0BH@FMGEJMDA@Trade?5Routes?5available?$AA@
	test	eax, eax
	je	SHORT $LN270@LogMonitor
	mov	DWORD PTR tv1733[ebp], OFFSET ??_C@_0BH@FMGEJMDA@Trade?5Routes?5available?$AA@
	jmp	SHORT $LN271@LogMonitor
$LN270@LogMonitor:
	mov	DWORD PTR tv1733[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN271@LogMonitor:
	mov	ecx, DWORD PTR tv1733[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234305[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234305[ebp]
	mov	DWORD PTR tv1203[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1481 : 
; 1482 : 	CvTreasury *pTreasury = m_pPlayer->GetTreasury();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	DWORD PTR _pTreasury$[ebp], eax

; 1483 : 
; 1484 : 	int iInternationalTradeGPT = pTreasury->GetGoldFromCitiesTimes100(false) - pTreasury->GetGoldFromCitiesTimes100(true);

	push	0
	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	mov	esi, eax
	push	1
	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	sub	esi, eax
	mov	DWORD PTR _iInternationalTradeGPT$[ebp], esi

; 1485 : 	AppendToLog(strHeader, strLog, "Gold From Cities", pTreasury->GetGoldFromCitiesTimes100(true) / 100);

	push	1
	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233922[ebp], esp
	mov	DWORD PTR $T234314[ebp], edx
	mov	eax, OFFSET ??_C@_0BB@IKGHBEPE@Gold?5From?5Cities?$AA@
	test	eax, eax
	je	SHORT $LN275@LogMonitor
	mov	DWORD PTR tv1746[ebp], OFFSET ??_C@_0BB@IKGHBEPE@Gold?5From?5Cities?$AA@
	jmp	SHORT $LN276@LogMonitor
$LN275@LogMonitor:
	mov	DWORD PTR tv1746[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN276@LogMonitor:
	mov	ecx, DWORD PTR tv1746[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234314[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234314[ebp]
	mov	DWORD PTR tv1206[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1486 : 	AppendToLog(strHeader, strLog, "Gold From Trade Routes", (int)(iInternationalTradeGPT / 100));

	mov	eax, DWORD PTR _iInternationalTradeGPT$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233923[ebp], esp
	mov	DWORD PTR $T234323[ebp], edx
	mov	eax, OFFSET ??_C@_0BH@MGLBPLFG@Gold?5From?5Trade?5Routes?$AA@
	test	eax, eax
	je	SHORT $LN280@LogMonitor
	mov	DWORD PTR tv1759[ebp], OFFSET ??_C@_0BH@MGLBPLFG@Gold?5From?5Trade?5Routes?$AA@
	jmp	SHORT $LN281@LogMonitor
$LN280@LogMonitor:
	mov	DWORD PTR tv1759[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN281@LogMonitor:
	mov	ecx, DWORD PTR tv1759[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234323[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234323[ebp]
	mov	DWORD PTR tv1209[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1487 : 	AppendToLog(strHeader, strLog, "Treasury", pTreasury->GetGold());

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233924[ebp], esp
	mov	DWORD PTR $T234332[ebp], edx
	mov	eax, OFFSET ??_C@_08IJAAGGEL@Treasury?$AA@
	test	eax, eax
	je	SHORT $LN285@LogMonitor
	mov	DWORD PTR tv1772[ebp], OFFSET ??_C@_08IJAAGGEL@Treasury?$AA@
	jmp	SHORT $LN286@LogMonitor
$LN285@LogMonitor:
	mov	DWORD PTR tv1772[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN286@LogMonitor:
	mov	ecx, DWORD PTR tv1772[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234332[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234332[ebp]
	mov	DWORD PTR tv1212[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1488 : 	AppendToLog(strHeader, strLog, "GPT - Connects", pTreasury->GetCityConnectionGold());

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetCityConnectionGold@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionGold
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233925[ebp], esp
	mov	DWORD PTR $T234341[ebp], edx
	mov	eax, OFFSET ??_C@_0P@KFICJKND@GPT?5?9?5Connects?$AA@
	test	eax, eax
	je	SHORT $LN290@LogMonitor
	mov	DWORD PTR tv1785[ebp], OFFSET ??_C@_0P@KFICJKND@GPT?5?9?5Connects?$AA@
	jmp	SHORT $LN291@LogMonitor
$LN290@LogMonitor:
	mov	DWORD PTR tv1785[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN291@LogMonitor:
	mov	ecx, DWORD PTR tv1785[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234341[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234341[ebp]
	mov	DWORD PTR tv1215[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1489 : 	AppendToLog(strHeader, strLog, "GPT - Diplo", pTreasury->GetGoldPerTurnFromDiplomacy());

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromDiplomacy
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233926[ebp], esp
	mov	DWORD PTR $T234350[ebp], edx
	mov	eax, OFFSET ??_C@_0M@OPNDOILH@GPT?5?9?5Diplo?$AA@
	test	eax, eax
	je	SHORT $LN295@LogMonitor
	mov	DWORD PTR tv1798[ebp], OFFSET ??_C@_0M@OPNDOILH@GPT?5?9?5Diplo?$AA@
	jmp	SHORT $LN296@LogMonitor
$LN295@LogMonitor:
	mov	DWORD PTR tv1798[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN296@LogMonitor:
	mov	ecx, DWORD PTR tv1798[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234350[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234350[ebp]
	mov	DWORD PTR tv1218[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1490 : 	AppendToLog(strHeader, strLog, "GPT - Religion", pTreasury->GetGoldPerTurnFromReligion());

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromReligion
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233927[ebp], esp
	mov	DWORD PTR $T234359[ebp], edx
	mov	eax, OFFSET ??_C@_0P@PPABGCDB@GPT?5?9?5Religion?$AA@
	test	eax, eax
	je	SHORT $LN300@LogMonitor
	mov	DWORD PTR tv1811[ebp], OFFSET ??_C@_0P@PPABGCDB@GPT?5?9?5Religion?$AA@
	jmp	SHORT $LN301@LogMonitor
$LN300@LogMonitor:
	mov	DWORD PTR tv1811[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN301@LogMonitor:
	mov	ecx, DWORD PTR tv1811[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234359[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234359[ebp]
	mov	DWORD PTR tv1221[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1491 : 	AppendToLog(strHeader, strLog, "GPT - Traits", pTreasury->GetGoldPerTurnFromTraits());

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTraits
	push	eax
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233928[ebp], esp
	mov	DWORD PTR $T234368[ebp], edx
	mov	eax, OFFSET ??_C@_0N@CFBKLDPF@GPT?5?9?5Traits?$AA@
	test	eax, eax
	je	SHORT $LN305@LogMonitor
	mov	DWORD PTR tv1824[ebp], OFFSET ??_C@_0N@CFBKLDPF@GPT?5?9?5Traits?$AA@
	jmp	SHORT $LN306@LogMonitor
$LN305@LogMonitor:
	mov	DWORD PTR tv1824[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN306@LogMonitor:
	mov	ecx, DWORD PTR tv1824[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234368[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234368[ebp]
	mov	DWORD PTR tv1224[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1492 : 
; 1493 : 	int iGoldFromCitiesMinusTR = pTreasury->GetGoldFromCitiesTimes100(true) / 100;

	push	1
	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldFromCitiesTimes100@CvTreasury@@QBEH_N@Z ; CvTreasury::GetGoldFromCitiesTimes100
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGoldFromCitiesMinusTR$[ebp], eax

; 1494 : 	int iGPTFromDiplomacy = pTreasury->GetGoldPerTurnFromDiplomacy();

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldPerTurnFromDiplomacy@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromDiplomacy
	mov	DWORD PTR _iGPTFromDiplomacy$[ebp], eax

; 1495 : 	int iGoldFromCityConnect = pTreasury->GetCityConnectionGoldTimes100() / 100;

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetCityConnectionGoldTimes100@CvTreasury@@QBEHXZ ; CvTreasury::GetCityConnectionGoldTimes100
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iGoldFromCityConnect$[ebp], eax

; 1496 : 	int iGPTFromReligion = pTreasury->GetGoldPerTurnFromReligion();

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldPerTurnFromReligion@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromReligion
	mov	DWORD PTR _iGPTFromReligion$[ebp], eax

; 1497 : 	int iGPTFromTraits = pTreasury->GetGoldPerTurnFromTraits();

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetGoldPerTurnFromTraits@CvTreasury@@QBEHXZ ; CvTreasury::GetGoldPerTurnFromTraits
	mov	DWORD PTR _iGPTFromTraits$[ebp], eax

; 1498 : 	int iTradeRouteGold = (int)(iInternationalTradeGPT / 100);

	mov	eax, DWORD PTR _iInternationalTradeGPT$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _iTradeRouteGold$[ebp], eax

; 1499 : 	int iTotalIncome = iGoldFromCitiesMinusTR + iGPTFromDiplomacy + iGoldFromCityConnect + iGPTFromReligion + iGPTFromTraits + iTradeRouteGold;

	mov	edx, DWORD PTR _iGoldFromCitiesMinusTR$[ebp]
	add	edx, DWORD PTR _iGPTFromDiplomacy$[ebp]
	add	edx, DWORD PTR _iGoldFromCityConnect$[ebp]
	add	edx, DWORD PTR _iGPTFromReligion$[ebp]
	add	edx, DWORD PTR _iGPTFromTraits$[ebp]
	add	edx, DWORD PTR _iTradeRouteGold$[ebp]
	mov	DWORD PTR _iTotalIncome$[ebp], edx

; 1500 : 	AppendToLog(strHeader, strLog, "Total Income", iTotalIncome);

	mov	eax, DWORD PTR _iTotalIncome$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233929[ebp], esp
	mov	DWORD PTR $T234377[ebp], ecx
	mov	edx, OFFSET ??_C@_0N@FGLODKOD@Total?5Income?$AA@
	test	edx, edx
	je	SHORT $LN310@LogMonitor
	mov	DWORD PTR tv1837[ebp], OFFSET ??_C@_0N@FGLODKOD@Total?5Income?$AA@
	jmp	SHORT $LN311@LogMonitor
$LN310@LogMonitor:
	mov	DWORD PTR tv1837[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN311@LogMonitor:
	mov	eax, DWORD PTR tv1837[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234377[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234377[ebp]
	mov	DWORD PTR tv1227[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1501 : 
; 1502 : 	// Gold breakdown
; 1503 : 	int iExpenses = pTreasury->GetExpensePerTurnUnitMaintenance() + pTreasury->GetBuildingGoldMaintenance() + pTreasury->GetImprovementGoldMaintenance();

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T234381[ebp], edx
	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBuildingGoldMaintenance
	mov	esi, eax
	add	esi, DWORD PTR $T234381[ebp]
	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
	add	esi, eax
	mov	DWORD PTR _iExpenses$[ebp], esi

; 1504 : 	AppendToLog(strHeader, strLog, "Unit Maint", pTreasury->GetExpensePerTurnUnitMaintenance());

	mov	eax, DWORD PTR _pTreasury$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T234385[ebp], ecx
	mov	edx, DWORD PTR $T234385[ebp]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233930[ebp], esp
	mov	DWORD PTR $T234394[ebp], eax
	mov	ecx, OFFSET ??_C@_0L@BNHIDPKB@Unit?5Maint?$AA@
	test	ecx, ecx
	je	SHORT $LN319@LogMonitor
	mov	DWORD PTR tv1850[ebp], OFFSET ??_C@_0L@BNHIDPKB@Unit?5Maint?$AA@
	jmp	SHORT $LN320@LogMonitor
$LN319@LogMonitor:
	mov	DWORD PTR tv1850[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN320@LogMonitor:
	mov	edx, DWORD PTR tv1850[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234394[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234394[ebp]
	mov	DWORD PTR tv1230[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1505 : 	AppendToLog(strHeader, strLog, "Build Maint", pTreasury->GetBuildingGoldMaintenance());

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetBuildingGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetBuildingGoldMaintenance
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233931[ebp], esp
	mov	DWORD PTR $T234403[ebp], eax
	mov	ecx, OFFSET ??_C@_0M@IDBOIBIH@Build?5Maint?$AA@
	test	ecx, ecx
	je	SHORT $LN324@LogMonitor
	mov	DWORD PTR tv1863[ebp], OFFSET ??_C@_0M@IDBOIBIH@Build?5Maint?$AA@
	jmp	SHORT $LN325@LogMonitor
$LN324@LogMonitor:
	mov	DWORD PTR tv1863[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN325@LogMonitor:
	mov	edx, DWORD PTR tv1863[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234403[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234403[ebp]
	mov	DWORD PTR tv1233[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1506 : 	AppendToLog(strHeader, strLog, "Improve Maint", pTreasury->GetImprovementGoldMaintenance());

	mov	ecx, DWORD PTR _pTreasury$[ebp]
	call	?GetImprovementGoldMaintenance@CvTreasury@@QBEHXZ ; CvTreasury::GetImprovementGoldMaintenance
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T233932[ebp], esp
	mov	DWORD PTR $T234412[ebp], eax
	mov	ecx, OFFSET ??_C@_0O@KGDDIJJA@Improve?5Maint?$AA@
	test	ecx, ecx
	je	SHORT $LN329@LogMonitor
	mov	DWORD PTR tv1876[ebp], OFFSET ??_C@_0O@KGDDIJJA@Improve?5Maint?$AA@
	jmp	SHORT $LN330@LogMonitor
$LN329@LogMonitor:
	mov	DWORD PTR tv1876[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN330@LogMonitor:
	mov	edx, DWORD PTR tv1876[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234412[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234412[ebp]
	mov	DWORD PTR tv1236[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1507 : 	AppendToLog(strHeader, strLog, "Total Expenses", iExpenses);

	mov	eax, DWORD PTR _iExpenses$[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T233933[ebp], esp
	mov	DWORD PTR $T234421[ebp], ecx
	mov	edx, OFFSET ??_C@_0P@GAMOBAMD@Total?5Expenses?$AA@
	test	edx, edx
	je	SHORT $LN334@LogMonitor
	mov	DWORD PTR tv1921[ebp], OFFSET ??_C@_0P@GAMOBAMD@Total?5Expenses?$AA@
	jmp	SHORT $LN335@LogMonitor
$LN334@LogMonitor:
	mov	DWORD PTR tv1921[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN335@LogMonitor:
	mov	eax, DWORD PTR tv1921[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234421[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234421[ebp]
	mov	DWORD PTR tv1239[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1508 : 	AppendToLog(strHeader, strLog, "Net GPT", iTotalIncome - iExpenses);

	mov	ecx, DWORD PTR _iTotalIncome$[ebp]
	sub	ecx, DWORD PTR _iExpenses$[ebp]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T233934[ebp], esp
	mov	DWORD PTR $T234430[ebp], edx
	mov	eax, OFFSET ??_C@_07JKJOCFLM@Net?5GPT?$AA@
	test	eax, eax
	je	SHORT $LN339@LogMonitor
	mov	DWORD PTR tv1934[ebp], OFFSET ??_C@_07JKJOCFLM@Net?5GPT?$AA@
	jmp	SHORT $LN340@LogMonitor
$LN339@LogMonitor:
	mov	DWORD PTR tv1934[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN340@LogMonitor:
	mov	ecx, DWORD PTR tv1934[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234430[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234430[ebp]
	mov	DWORD PTR tv1242[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1509 : 
; 1510 : 	if(bBuildHeader)

	movzx	edx, BYTE PTR _bBuildHeader$[ebp]
	test	edx, edx
	je	SHORT $LN1@LogMonitor

; 1511 : 	{
; 1512 : 		pLog->Msg(strHeader);

	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T234434[ebp], eax
	mov	eax, DWORD PTR $T234434[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8
$LN1@LogMonitor:

; 1513 : 	}
; 1514 : 	pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T234438[ebp], eax
	mov	edx, DWORD PTR $T234438[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 1515 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _m_aiNumImprovements$[ebp]
	call	??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN34@LogMonitor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN378@LogMonitor:
	DD	$LN19@LogMonitor
	DD	$LN18@LogMonitor
	DD	$LN17@LogMonitor
	DD	$LN16@LogMonitor
	DD	$LN15@LogMonitor
	DD	$LN14@LogMonitor
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T233895[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T233896[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$7:
	mov	ecx, DWORD PTR $T233897[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogMonitor@CvEconomicAI@@QAEXXZ$26:
	lea	ecx, DWORD PTR _m_aiNumImprovements$[ebp]
	jmp	??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
__ehhandler$?LogMonitor@CvEconomicAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1036]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogMonitor@CvEconomicAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogMonitor@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::LogMonitor
PUBLIC	??_C@_0BC@BMNJLBAI@improved?5?1?5worked?$AA@	; `string'
PUBLIC	??_C@_0BJ@OOOJAFFK@faith?5specialist?5?1?5faith?$AA@ ; `string'
PUBLIC	??_C@_0BN@NJMPOJDK@culture?5specialist?5?1?5culture?$AA@ ; `string'
PUBLIC	??_C@_0BH@KOPGKHCB@gold?5specialist?5?1?5gold?$AA@ ; `string'
PUBLIC	??_C@_0BN@FDNNIAFN@science?5specialist?5?1?5science?$AA@ ; `string'
PUBLIC	??_C@_0CD@IHGELMMI@production?5specialist?5?1?5producti@ ; `string'
PUBLIC	??_C@_0BH@HBLNFIPP@food?5specialist?5?1?5food?$AA@ ; `string'
PUBLIC	??_C@_0BB@PNDBABGF@faith?5specialist?$AA@	; `string'
PUBLIC	??_C@_0BD@BLLFPBDP@culture?5specialist?$AA@	; `string'
PUBLIC	??_C@_0BA@LCIOHNDM@gold?5specialist?$AA@	; `string'
PUBLIC	??_C@_0BD@PFOCINIA@science?5specialist?$AA@	; `string'
PUBLIC	??_C@_0BG@KGIKPENA@production?5specialist?$AA@	; `string'
PUBLIC	??_C@_0BA@GAIHMJHG@food?5specialist?$AA@	; `string'
PUBLIC	??_C@_0M@KOKBELOB@faith?5?1?5pop?$AA@		; `string'
PUBLIC	??_C@_0O@LDLDBMPJ@culture?5?1?5pop?$AA@		; `string'
PUBLIC	??_C@_0L@NMIALKKI@gold?5?1?5pop?$AA@		; `string'
PUBLIC	??_C@_0O@FCMNBJKE@science?5?1?5pop?$AA@		; `string'
PUBLIC	??_C@_0BB@KLANKHFD@production?5?1?5pop?$AA@	; `string'
PUBLIC	??_C@_0L@CEIDFJKN@food?5?1?5pop?$AA@		; `string'
PUBLIC	__real@00000000
PUBLIC	??_C@_05IMDAHFEM@faith?$AA@			; `string'
PUBLIC	??_C@_07BKJDICBO@culture?$AA@			; `string'
PUBLIC	??_C@_09IICIMAEO@city?5gold?$AA@		; `string'
PUBLIC	??_C@_07PFJHCMJJ@science?$AA@			; `string'
PUBLIC	??_C@_0L@INCEBPLL@production?$AA@		; `string'
PUBLIC	??_C@_04OPAEPOE@food?$AA@			; `string'
PUBLIC	??_C@_0L@KFAOFODH@Population?$AA@		; `string'
PUBLIC	??_C@_09PDKCKCKO@City?5Name?$AA@		; `string'
PUBLIC	?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy
PUBLIC	??_C@_0BL@KNODLBCC@EconomicCityMonitorLog?4csv?$AA@ ; `string'
PUBLIC	??_C@_0BI@MPIIMPLH@EconomicCityMonitorLog_?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ:PROC	; CvPlot::getWorkingCity
EXTRN	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z:PROC ; CvCityCitizens::IsCanWork
EXTRN	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ:PROC ; CvCity::GetCityCitizens
EXTRN	?getExtraSpecialistYield@CvCity@@QBEHW4YieldTypes@@@Z:PROC ; CvCity::getExtraSpecialistYield
EXTRN	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z:PROC ; CvCity::getYieldRate
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
;	COMDAT ??_C@_0BC@BMNJLBAI@improved?5?1?5worked?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BC@BMNJLBAI@improved?5?1?5worked?$AA@ DB 'improved / worked', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OOOJAFFK@faith?5specialist?5?1?5faith?$AA@
CONST	SEGMENT
??_C@_0BJ@OOOJAFFK@faith?5specialist?5?1?5faith?$AA@ DB 'faith specialist'
	DB	' / faith', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NJMPOJDK@culture?5specialist?5?1?5culture?$AA@
CONST	SEGMENT
??_C@_0BN@NJMPOJDK@culture?5specialist?5?1?5culture?$AA@ DB 'culture spec'
	DB	'ialist / culture', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KOPGKHCB@gold?5specialist?5?1?5gold?$AA@
CONST	SEGMENT
??_C@_0BH@KOPGKHCB@gold?5specialist?5?1?5gold?$AA@ DB 'gold specialist / '
	DB	'gold', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FDNNIAFN@science?5specialist?5?1?5science?$AA@
CONST	SEGMENT
??_C@_0BN@FDNNIAFN@science?5specialist?5?1?5science?$AA@ DB 'science spec'
	DB	'ialist / science', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IHGELMMI@production?5specialist?5?1?5producti@
CONST	SEGMENT
??_C@_0CD@IHGELMMI@production?5specialist?5?1?5producti@ DB 'production s'
	DB	'pecialist / production', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HBLNFIPP@food?5specialist?5?1?5food?$AA@
CONST	SEGMENT
??_C@_0BH@HBLNFIPP@food?5specialist?5?1?5food?$AA@ DB 'food specialist / '
	DB	'food', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PNDBABGF@faith?5specialist?$AA@
CONST	SEGMENT
??_C@_0BB@PNDBABGF@faith?5specialist?$AA@ DB 'faith specialist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BLLFPBDP@culture?5specialist?$AA@
CONST	SEGMENT
??_C@_0BD@BLLFPBDP@culture?5specialist?$AA@ DB 'culture specialist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LCIOHNDM@gold?5specialist?$AA@
CONST	SEGMENT
??_C@_0BA@LCIOHNDM@gold?5specialist?$AA@ DB 'gold specialist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PFOCINIA@science?5specialist?$AA@
CONST	SEGMENT
??_C@_0BD@PFOCINIA@science?5specialist?$AA@ DB 'science specialist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KGIKPENA@production?5specialist?$AA@
CONST	SEGMENT
??_C@_0BG@KGIKPENA@production?5specialist?$AA@ DB 'production specialist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GAIHMJHG@food?5specialist?$AA@
CONST	SEGMENT
??_C@_0BA@GAIHMJHG@food?5specialist?$AA@ DB 'food specialist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KOKBELOB@faith?5?1?5pop?$AA@
CONST	SEGMENT
??_C@_0M@KOKBELOB@faith?5?1?5pop?$AA@ DB 'faith / pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDLDBMPJ@culture?5?1?5pop?$AA@
CONST	SEGMENT
??_C@_0O@LDLDBMPJ@culture?5?1?5pop?$AA@ DB 'culture / pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMIALKKI@gold?5?1?5pop?$AA@
CONST	SEGMENT
??_C@_0L@NMIALKKI@gold?5?1?5pop?$AA@ DB 'gold / pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FCMNBJKE@science?5?1?5pop?$AA@
CONST	SEGMENT
??_C@_0O@FCMNBJKE@science?5?1?5pop?$AA@ DB 'science / pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLANKHFD@production?5?1?5pop?$AA@
CONST	SEGMENT
??_C@_0BB@KLANKHFD@production?5?1?5pop?$AA@ DB 'production / pop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CEIDFJKN@food?5?1?5pop?$AA@
CONST	SEGMENT
??_C@_0L@CEIDFJKN@food?5?1?5pop?$AA@ DB 'food / pop', 00H ; `string'
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_05IMDAHFEM@faith?$AA@
CONST	SEGMENT
??_C@_05IMDAHFEM@faith?$AA@ DB 'faith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BKJDICBO@culture?$AA@
CONST	SEGMENT
??_C@_07BKJDICBO@culture?$AA@ DB 'culture', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IICIMAEO@city?5gold?$AA@
CONST	SEGMENT
??_C@_09IICIMAEO@city?5gold?$AA@ DB 'city gold', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFJHCMJJ@science?$AA@
CONST	SEGMENT
??_C@_07PFJHCMJJ@science?$AA@ DB 'science', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@INCEBPLL@production?$AA@
CONST	SEGMENT
??_C@_0L@INCEBPLL@production?$AA@ DB 'production', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPAEPOE@food?$AA@
CONST	SEGMENT
??_C@_04OPAEPOE@food?$AA@ DB 'food', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KFAOFODH@Population?$AA@
CONST	SEGMENT
??_C@_0L@KFAOFODH@Population?$AA@ DB 'Population', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDKCKCKO@City?5Name?$AA@
CONST	SEGMENT
??_C@_09PDKCKCKO@City?5Name?$AA@ DB 'City Name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KNODLBCC@EconomicCityMonitorLog?4csv?$AA@
CONST	SEGMENT
??_C@_0BL@KNODLBCC@EconomicCityMonitorLog?4csv?$AA@ DB 'EconomicCityMonit'
	DB	'orLog.csv', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MPIIMPLH@EconomicCityMonitorLog_?$AA@
CONST	SEGMENT
??_C@_0BI@MPIIMPLH@EconomicCityMonitorLog_?$AA@ DB 'EconomicCityMonitorLo'
	DB	'g_', 00H					; `string'
CONST	ENDS
;	COMDAT ?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA
_DATA	SEGMENT
?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA DB 01H ; `CvEconomicAI::LogCityMonitor'::`8'::bFirstRun
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogCityMonitor@CvEconomicAI@@QAEXXZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogCityMonitor@CvEconomicAI@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogCityMonitor@CvEconomicAI@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$9
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$12
	DD	08H
	DD	FLAT:__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$13
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogCityMonitor@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
tv1245 = -1056						; size = 4
tv1940 = -1052						; size = 4
tv1242 = -1048						; size = 4
tv1927 = -1044						; size = 4
tv1239 = -1040						; size = 4
tv1914 = -1036						; size = 4
tv1236 = -1032						; size = 4
tv1890 = -1028						; size = 4
tv1886 = -1024						; size = 4
tv1233 = -1020						; size = 4
tv1873 = -1016						; size = 4
tv1230 = -1012						; size = 4
tv1860 = -1008						; size = 4
tv1227 = -1004						; size = 4
tv1847 = -1000						; size = 4
tv1224 = -996						; size = 4
tv1834 = -992						; size = 4
tv1221 = -988						; size = 4
tv1821 = -984						; size = 4
tv1218 = -980						; size = 4
tv1808 = -976						; size = 4
tv831 = -972						; size = 4
tv1215 = -968						; size = 4
tv1795 = -964						; size = 4
tv1212 = -960						; size = 4
tv1782 = -956						; size = 4
tv1209 = -952						; size = 4
tv1769 = -948						; size = 4
tv1206 = -944						; size = 4
tv1756 = -940						; size = 4
tv1203 = -936						; size = 4
tv1743 = -932						; size = 4
tv1200 = -928						; size = 4
tv1730 = -924						; size = 4
tv658 = -920						; size = 4
tv1197 = -916						; size = 4
tv1717 = -912						; size = 4
tv1194 = -908						; size = 4
tv1704 = -904						; size = 4
tv1191 = -900						; size = 4
tv1691 = -896						; size = 4
tv1188 = -892						; size = 4
tv1678 = -888						; size = 4
tv1185 = -884						; size = 4
tv1665 = -880						; size = 4
tv1182 = -876						; size = 4
tv1620 = -872						; size = 4
tv542 = -868						; size = 4
tv2444 = -864						; size = 4
tv1179 = -860						; size = 4
tv1607 = -856						; size = 4
tv1176 = -852						; size = 4
tv1594 = -848						; size = 4
tv1173 = -844						; size = 4
tv1581 = -840						; size = 4
tv1170 = -836						; size = 4
tv1568 = -832						; size = 4
tv1167 = -828						; size = 4
tv1555 = -824						; size = 4
tv1164 = -820						; size = 4
tv1542 = -816						; size = 4
tv347 = -812						; size = 4
tv1161 = -808						; size = 4
tv1529 = -804						; size = 4
tv1158 = -800						; size = 4
tv1516 = -796						; size = 4
tv1155 = -792						; size = 4
tv170 = -788						; size = 4
tv1151 = -784						; size = 4
tv1475 = -780						; size = 4
tv1148 = -776						; size = 4
tv1462 = -772						; size = 4
tv1145 = -768						; size = 4
tv157 = -764						; size = 4
tv1925 = -760						; size = 4
tv1138 = -756						; size = 4
tv1938 = -752						; size = 4
_this$ = -748						; size = 4
$T235101 = -720						; size = 4
$T235097 = -716						; size = 4
$T235093 = -712						; size = 4
$T235084 = -708						; size = 4
$T235075 = -704						; size = 4
$T235066 = -700						; size = 4
$T235052 = -692						; size = 4
$T235045 = -688						; size = 4
$T235038 = -684						; size = 4
$T235034 = -680						; size = 4
$T235027 = -676						; size = 4
$T235023 = -672						; size = 4
$T235014 = -668						; size = 4
$T235005 = -664						; size = 4
$T234996 = -660						; size = 4
$T234987 = -656						; size = 4
$T234978 = -652						; size = 4
$T234966 = -648						; size = 4
$T234959 = -644						; size = 4
$T234947 = -640						; size = 4
$T234935 = -636						; size = 4
$T234923 = -632						; size = 4
$T234911 = -628						; size = 4
$T234899 = -624						; size = 4
$T234887 = -620						; size = 4
$T234883 = -616						; size = 4
$T234874 = -612						; size = 4
$T234865 = -608						; size = 4
$T234856 = -604						; size = 4
$T234847 = -600						; size = 4
$T234838 = -596						; size = 4
$T234829 = -592						; size = 4
$T234825 = -588						; size = 4
$T234813 = -584						; size = 4
$T234801 = -580						; size = 4
$T234789 = -576						; size = 4
$T234777 = -572						; size = 4
$T234765 = -568						; size = 4
$T234753 = -564						; size = 4
$T234749 = -560						; size = 4
$T234740 = -556						; size = 4
$T234731 = -552						; size = 4
$T234722 = -548						; size = 4
$T234718 = -544						; size = 4
$T234709 = -540						; size = 4
$T234705 = -536						; size = 4
$T234696 = -532						; size = 4
$T234678 = -528						; size = 4
$T234671 = -524						; size = 4
$T234617 = -488						; size = 4
$T234608 = -484						; size = 4
$T234600 = -480						; size = 4
$T234538 = -476						; size = 4
$T234537 = -472						; size = 4
$T234536 = -468						; size = 4
$T234535 = -464						; size = 4
$T234534 = -460						; size = 4
$T234533 = -456						; size = 4
$T234532 = -452						; size = 4
$T234531 = -448						; size = 4
$T234530 = -444						; size = 4
$T234529 = -440						; size = 4
$T234528 = -436						; size = 4
$T234527 = -432						; size = 4
$T234526 = -428						; size = 4
$T234525 = -424						; size = 4
$T234524 = -420						; size = 4
$T234523 = -416						; size = 4
$T234522 = -412						; size = 4
$T234521 = -408						; size = 4
$T234520 = -404						; size = 4
$T234519 = -400						; size = 4
$T234518 = -396						; size = 4
$T234517 = -392						; size = 4
$T234516 = -388						; size = 4
$T234515 = -384						; size = 4
$T234514 = -380						; size = 4
$T234513 = -376						; size = 4
$T234512 = -372						; size = 4
$T234511 = -368						; size = 4
$T234510 = -364						; size = 4
$T234509 = -360						; size = 4
$T234508 = -356						; size = 4
$T234507 = -352						; size = 28
$T234506 = -324						; size = 4
$T234505 = -320						; size = 4
$T234504 = -316						; size = 4
$T234503 = -312						; size = 4
$T234502 = -308						; size = 4
$T234501 = -304						; size = 28
$T234500 = -276						; size = 28
_pPlot$226071 = -248					; size = 4
_uiPlotIndex$226066 = -244				; size = 4
_ui$226035 = -240					; size = 4
_ui$226008 = -236					; size = 4
_ui$225980 = -232					; size = 4
_ui$225953 = -228					; size = 4
_ui$225940 = -224					; size = 4
_ui$225936 = -220					; size = 4
_iTiles$226063 = -216					; size = 4
_iWorkedTiles$226064 = -212				; size = 4
_iImprovedTiles$226065 = -208				; size = 4
_str$ = -204						; size = 28
_iLoopCity$ = -176					; size = 4
_aiCityYields$ = -172					; size = 12
_aiPlots$ = -160					; size = 4
_strLog$ = -156						; size = 28
_bBuildHeader$ = -125					; size = 1
_strPlayerName$ = -124					; size = 28
_fRatio$ = -96						; size = 4
_strLogName$ = -92					; size = 28
_pLog$ = -64						; size = 4
_aiSpecialistsYields$ = -60				; size = 12
_strHeader$ = -48					; size = 28
__$ArrayPad$ = -20					; size = 4
_pLoopCity$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LogCityMonitor@CvEconomicAI@@QAEXXZ PROC		; CvEconomicAI::LogCityMonitor, COMDAT
; _this$ = ecx

; 1518 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogCityMonitor@CvEconomicAI@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1044				; 00000414H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1519 : 	if(!(GC.getLogging() && GC.getAILogging()))

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN71@LogCityMon
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN72@LogCityMon
$LN71@LogCityMon:

; 1520 : 	{
; 1521 : 		return;

	jmp	$LN73@LogCityMon
$LN72@LogCityMon:

; 1522 : 	}
; 1523 : 
; 1524 : 	// don't log minor civs for now
; 1525 : 	if(m_pPlayer->isMinorCiv())

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN70@LogCityMon

; 1526 : 	{
; 1527 : 		return;

	jmp	$LN73@LogCityMon
$LN70@LogCityMon:

; 1528 : 	}
; 1529 : 
; 1530 : 	static bool bFirstRun = true;
; 1531 : 	bool bBuildHeader = false;

	mov	BYTE PTR _bBuildHeader$[ebp], 0

; 1532 : 	CvString strHeader;

	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1533 : 	if(bFirstRun)

	movzx	ecx, BYTE PTR ?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA
	test	ecx, ecx
	je	SHORT $LN69@LogCityMon

; 1534 : 	{
; 1535 : 		bFirstRun = false;

	mov	BYTE PTR ?bFirstRun@?7??LogCityMonitor@CvEconomicAI@@QAEXXZ@4_NA, 0

; 1536 : 		bBuildHeader = true;

	mov	BYTE PTR _bBuildHeader$[ebp], 1
$LN69@LogCityMon:

; 1537 : 	}
; 1538 : 
; 1539 : 	// go through all the plots the player has under their control
; 1540 : 	CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	DWORD PTR _aiPlots$[ebp], eax

; 1541 : 
; 1542 : 	CvString strLog;

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1543 : 
; 1544 : 	// Find the name of this civ and city
; 1545 : 	CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1546 : 	strPlayerName = m_pPlayer->getCivilizationShortDescription();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T234600[ebp], eax
	cmp	DWORD PTR $T234600[ebp], 0
	je	SHORT $LN129@LogCityMon
	mov	ecx, DWORD PTR $T234600[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN128@LogCityMon
$LN129@LogCityMon:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN128@LogCityMon:

; 1547 : 	CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1548 : 
; 1549 : 	// Open the log file
; 1550 : 	if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	edx, al
	test	edx, edx
	je	$LN68@LogCityMon

; 1551 : 	{
; 1552 : 		strLogName = "EconomicCityMonitorLog_" + strPlayerName + ".csv";

	lea	eax, DWORD PTR _strPlayerName$[ebp]
	push	eax
	push	OFFSET ??_C@_0BI@MPIIMPLH@EconomicCityMonitorLog_?$AA@
	lea	ecx, DWORD PTR $T234500[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1938[ebp], eax
	mov	edx, DWORD PTR tv1938[ebp]
	mov	DWORD PTR tv1138[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	eax, DWORD PTR tv1138[ebp]
	push	eax
	lea	ecx, DWORD PTR $T234501[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1925[ebp], eax
	mov	edx, DWORD PTR tv1925[ebp]
	mov	DWORD PTR $T234608[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR $T234608[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T234501[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T234500[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1553 : 	}
; 1554 : 	else

	jmp	SHORT $LN139@LogCityMon
$LN68@LogCityMon:

; 1555 : 	{
; 1556 : 		strLogName = "EconomicCityMonitorLog.csv";

	mov	eax, OFFSET ??_C@_0BL@KNODLBCC@EconomicCityMonitorLog?4csv?$AA@
	test	eax, eax
	je	SHORT $LN138@LogCityMon
	push	OFFSET ??_C@_0BL@KNODLBCC@EconomicCityMonitorLog?4csv?$AA@
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN137@LogCityMon
$LN138@LogCityMon:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN137@LogCityMon:
$LN139@LogCityMon:

; 1557 : 	}
; 1558 : 
; 1559 : 	FILogFile* pLog;
; 1560 : 	pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv157[ebp], eax
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T234617[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T234617[ebp]
	push	ecx
	mov	edx, DWORD PTR tv157[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv157[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$[ebp], eax

; 1561 : 
; 1562 : 	CvString str;

	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 1563 : 
; 1564 : 	float fRatio;
; 1565 : 
; 1566 : 	// per city
; 1567 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 1568 : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 1569 : 
; 1570 : 	FFastVector<int> aiCityYields;

	push	0
	lea	ecx, DWORD PTR _aiCityYields$[ebp]
	call	??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 1571 : 	aiCityYields.push_back_copy(-1, NUM_YIELD_TYPES);

	mov	DWORD PTR $T234502[ebp], -1
	push	6
	lea	eax, DWORD PTR $T234502[ebp]
	push	eax
	lea	ecx, DWORD PTR _aiCityYields$[ebp]
	call	?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy

; 1572 : 
; 1573 : 	FFastVector<int> aiSpecialistsYields;

	push	0
	lea	ecx, DWORD PTR _aiSpecialistsYields$[ebp]
	call	??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 1574 : 	aiSpecialistsYields.push_back_copy(-1, NUM_YIELD_TYPES);

	mov	DWORD PTR $T234503[ebp], -1
	push	6
	lea	ecx, DWORD PTR $T234503[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aiSpecialistsYields$[ebp]
	call	?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy

; 1575 : 
; 1576 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoopCity))

	push	0
	lea	edx, DWORD PTR _iLoopCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN66@LogCityMon
$LN65@LogCityMon:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN66@LogCityMon:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN64@LogCityMon

; 1577 : 	{
; 1578 : 		for(uint ui = 0; ui < aiCityYields.size(); ui++)

	mov	DWORD PTR _ui$225936[ebp], 0
	jmp	SHORT $LN63@LogCityMon
$LN62@LogCityMon:
	mov	edx, DWORD PTR _ui$225936[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$225936[ebp], edx
$LN63@LogCityMon:
	mov	eax, DWORD PTR _aiCityYields$[ebp+4]
	mov	DWORD PTR $T234671[ebp], eax
	mov	ecx, DWORD PTR _ui$225936[ebp]
	cmp	ecx, DWORD PTR $T234671[ebp]
	jae	SHORT $LN61@LogCityMon

; 1579 : 		{
; 1580 : 			aiCityYields[ui] = 0;

	mov	edx, DWORD PTR _ui$225936[ebp]
	mov	eax, DWORD PTR _aiCityYields$[ebp]
	mov	DWORD PTR [eax+edx*4], 0

; 1581 : 		}

	jmp	SHORT $LN62@LogCityMon
$LN61@LogCityMon:

; 1582 : 
; 1583 : 		for(uint ui = 0; ui < aiSpecialistsYields.size(); ui++)

	mov	DWORD PTR _ui$225940[ebp], 0
	jmp	SHORT $LN60@LogCityMon
$LN59@LogCityMon:
	mov	ecx, DWORD PTR _ui$225940[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$225940[ebp], ecx
$LN60@LogCityMon:
	mov	edx, DWORD PTR _aiSpecialistsYields$[ebp+4]
	mov	DWORD PTR $T234678[ebp], edx
	mov	eax, DWORD PTR _ui$225940[ebp]
	cmp	eax, DWORD PTR $T234678[ebp]
	jae	SHORT $LN58@LogCityMon

; 1584 : 		{
; 1585 : 			aiSpecialistsYields[ui] = 0;

	mov	ecx, DWORD PTR _ui$225940[ebp]
	mov	edx, DWORD PTR _aiSpecialistsYields$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0

; 1586 : 		}

	jmp	SHORT $LN59@LogCityMon
$LN58@LogCityMon:

; 1587 : 
; 1588 : 		strHeader = "";

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	eax, eax
	je	SHORT $LN195@LogCityMon
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN194@LogCityMon
$LN195@LogCityMon:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN194@LogCityMon:

; 1589 : 		strLog = "";

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	test	ecx, ecx
	je	SHORT $LN199@LogCityMon
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN198@LogCityMon
$LN199@LogCityMon:
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN198@LogCityMon:

; 1590 : 
; 1591 : 		// civ name
; 1592 : 		AppendToLog(strHeader, strLog, "Civ Name", strPlayerName);

	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234504[ebp], esp
	mov	DWORD PTR $T234696[ebp], edx
	lea	eax, DWORD PTR _strPlayerName$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234696[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T234696[ebp]
	mov	DWORD PTR tv1145[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234505[ebp], esp
	mov	DWORD PTR $T234705[ebp], edx
	mov	eax, OFFSET ??_C@_08IFIFDOPL@Civ?5Name?$AA@
	test	eax, eax
	je	SHORT $LN207@LogCityMon
	mov	DWORD PTR tv1462[ebp], OFFSET ??_C@_08IFIFDOPL@Civ?5Name?$AA@
	jmp	SHORT $LN208@LogCityMon
$LN207@LogCityMon:
	mov	DWORD PTR tv1462[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN208@LogCityMon:
	mov	ecx, DWORD PTR tv1462[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234705[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234705[ebp]
	mov	DWORD PTR tv1148[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	call	?AppendToLog@@YAXAAVCvString@@0V1@1@Z	; AppendToLog
	add	esp, 64					; 00000040H

; 1593 : 
; 1594 : 		// turn
; 1595 : 		AppendToLog(strHeader, strLog, "Turn", GC.getGame().getGameTurn());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T234709[ebp], edx
	mov	ecx, DWORD PTR $T234709[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234506[ebp], esp
	mov	DWORD PTR $T234718[ebp], eax
	mov	ecx, OFFSET ??_C@_04EKEMLFA@Turn?$AA@
	test	ecx, ecx
	je	SHORT $LN214@LogCityMon
	mov	DWORD PTR tv1475[ebp], OFFSET ??_C@_04EKEMLFA@Turn?$AA@
	jmp	SHORT $LN215@LogCityMon
$LN214@LogCityMon:
	mov	DWORD PTR tv1475[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN215@LogCityMon:
	mov	edx, DWORD PTR tv1475[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234718[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234718[ebp]
	mov	DWORD PTR tv1151[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1596 : 
; 1597 : 		// city name
; 1598 : 		str = pLoopCity->getName();

	lea	eax, DWORD PTR $T234507[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv170[ebp], eax
	mov	ecx, DWORD PTR tv170[ebp]
	mov	DWORD PTR $T234722[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	edx, DWORD PTR $T234722[ebp]
	push	edx
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T234507[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1599 : 		AppendToLog(strHeader, strLog, "City Name", str);

	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234508[ebp], esp
	mov	DWORD PTR $T234731[ebp], eax
	lea	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234731[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T234731[ebp]
	mov	DWORD PTR tv1155[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234509[ebp], esp
	mov	DWORD PTR $T234740[ebp], eax
	mov	ecx, OFFSET ??_C@_09PDKCKCKO@City?5Name?$AA@
	test	ecx, ecx
	je	SHORT $LN227@LogCityMon
	mov	DWORD PTR tv1516[ebp], OFFSET ??_C@_09PDKCKCKO@City?5Name?$AA@
	jmp	SHORT $LN228@LogCityMon
$LN227@LogCityMon:
	mov	DWORD PTR tv1516[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN228@LogCityMon:
	mov	edx, DWORD PTR tv1516[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234740[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234740[ebp]
	mov	DWORD PTR tv1158[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	call	?AppendToLog@@YAXAAVCvString@@0V1@1@Z	; AppendToLog
	add	esp, 64					; 00000040H

; 1600 : 
; 1601 : 		//	pop
; 1602 : 		AppendToLog(strHeader, strLog, "Population", pLoopCity->getPopulation());

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234510[ebp], esp
	mov	DWORD PTR $T234749[ebp], eax
	mov	ecx, OFFSET ??_C@_0L@KFAOFODH@Population?$AA@
	test	ecx, ecx
	je	SHORT $LN232@LogCityMon
	mov	DWORD PTR tv1529[ebp], OFFSET ??_C@_0L@KFAOFODH@Population?$AA@
	jmp	SHORT $LN233@LogCityMon
$LN232@LogCityMon:
	mov	DWORD PTR tv1529[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN233@LogCityMon:
	mov	edx, DWORD PTR tv1529[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234749[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234749[ebp]
	mov	DWORD PTR tv1161[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1603 : 
; 1604 : 		//	total yields
; 1605 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$225953[ebp], 0
	jmp	SHORT $LN57@LogCityMon
$LN56@LogCityMon:
	mov	eax, DWORD PTR _ui$225953[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$225953[ebp], eax
$LN57@LogCityMon:
	cmp	DWORD PTR _ui$225953[ebp], 6
	jae	$LN55@LogCityMon

; 1606 : 		{
; 1607 : 			aiCityYields[ui] = pLoopCity->getYieldRate((YieldTypes)ui, false);

	mov	ecx, DWORD PTR _ui$225953[ebp]
	mov	edx, DWORD PTR _aiCityYields$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T234753[ebp], eax
	push	0
	mov	ecx, DWORD PTR _ui$225953[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getYieldRate@CvCity@@QBEHW4YieldTypes@@_N@Z ; CvCity::getYieldRate
	mov	edx, DWORD PTR $T234753[ebp]
	mov	DWORD PTR [edx], eax

; 1608 : 			switch(ui)

	mov	eax, DWORD PTR _ui$225953[ebp]
	mov	DWORD PTR tv347[ebp], eax
	cmp	DWORD PTR tv347[ebp], 5
	ja	$LN53@LogCityMon
	mov	ecx, DWORD PTR tv347[ebp]
	jmp	DWORD PTR $LN482@LogCityMon[ecx*4]
$LN52@LogCityMon:

; 1609 : 			{
; 1610 : 			case YIELD_FOOD:
; 1611 : 				AppendToLog(strHeader, strLog, "food", aiCityYields[ui]);

	mov	edx, DWORD PTR _ui$225953[ebp]
	mov	eax, DWORD PTR _aiCityYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234511[ebp], esp
	mov	DWORD PTR $T234765[ebp], edx
	mov	eax, OFFSET ??_C@_04OPAEPOE@food?$AA@
	test	eax, eax
	je	SHORT $LN241@LogCityMon
	mov	DWORD PTR tv1542[ebp], OFFSET ??_C@_04OPAEPOE@food?$AA@
	jmp	SHORT $LN242@LogCityMon
$LN241@LogCityMon:
	mov	DWORD PTR tv1542[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN242@LogCityMon:
	mov	ecx, DWORD PTR tv1542[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234765[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234765[ebp]
	mov	DWORD PTR tv1164[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1612 : 				break;

	jmp	$LN53@LogCityMon
$LN51@LogCityMon:

; 1613 : 			case YIELD_PRODUCTION:
; 1614 : 				AppendToLog(strHeader, strLog, "production", aiCityYields[ui]);

	mov	edx, DWORD PTR _ui$225953[ebp]
	mov	eax, DWORD PTR _aiCityYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234512[ebp], esp
	mov	DWORD PTR $T234777[ebp], edx
	mov	eax, OFFSET ??_C@_0L@INCEBPLL@production?$AA@
	test	eax, eax
	je	SHORT $LN248@LogCityMon
	mov	DWORD PTR tv1555[ebp], OFFSET ??_C@_0L@INCEBPLL@production?$AA@
	jmp	SHORT $LN249@LogCityMon
$LN248@LogCityMon:
	mov	DWORD PTR tv1555[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN249@LogCityMon:
	mov	ecx, DWORD PTR tv1555[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234777[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234777[ebp]
	mov	DWORD PTR tv1167[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1615 : 				break;

	jmp	$LN53@LogCityMon
$LN50@LogCityMon:

; 1616 : 			case YIELD_SCIENCE:
; 1617 : 				AppendToLog(strHeader, strLog, "science", aiCityYields[ui]);

	mov	edx, DWORD PTR _ui$225953[ebp]
	mov	eax, DWORD PTR _aiCityYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234513[ebp], esp
	mov	DWORD PTR $T234789[ebp], edx
	mov	eax, OFFSET ??_C@_07PFJHCMJJ@science?$AA@
	test	eax, eax
	je	SHORT $LN255@LogCityMon
	mov	DWORD PTR tv1568[ebp], OFFSET ??_C@_07PFJHCMJJ@science?$AA@
	jmp	SHORT $LN256@LogCityMon
$LN255@LogCityMon:
	mov	DWORD PTR tv1568[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN256@LogCityMon:
	mov	ecx, DWORD PTR tv1568[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234789[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234789[ebp]
	mov	DWORD PTR tv1170[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1618 : 				break;

	jmp	$LN53@LogCityMon
$LN49@LogCityMon:

; 1619 : 			case YIELD_GOLD:
; 1620 : 				AppendToLog(strHeader, strLog, "city gold", aiCityYields[ui]);

	mov	edx, DWORD PTR _ui$225953[ebp]
	mov	eax, DWORD PTR _aiCityYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234514[ebp], esp
	mov	DWORD PTR $T234801[ebp], edx
	mov	eax, OFFSET ??_C@_09IICIMAEO@city?5gold?$AA@
	test	eax, eax
	je	SHORT $LN262@LogCityMon
	mov	DWORD PTR tv1581[ebp], OFFSET ??_C@_09IICIMAEO@city?5gold?$AA@
	jmp	SHORT $LN263@LogCityMon
$LN262@LogCityMon:
	mov	DWORD PTR tv1581[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN263@LogCityMon:
	mov	ecx, DWORD PTR tv1581[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234801[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234801[ebp]
	mov	DWORD PTR tv1173[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1621 : 				break;

	jmp	$LN53@LogCityMon
$LN48@LogCityMon:

; 1622 : 			case YIELD_CULTURE:
; 1623 : 				AppendToLog(strHeader, strLog, "culture", aiCityYields[ui]);

	mov	edx, DWORD PTR _ui$225953[ebp]
	mov	eax, DWORD PTR _aiCityYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234515[ebp], esp
	mov	DWORD PTR $T234813[ebp], edx
	mov	eax, OFFSET ??_C@_07BKJDICBO@culture?$AA@
	test	eax, eax
	je	SHORT $LN269@LogCityMon
	mov	DWORD PTR tv1594[ebp], OFFSET ??_C@_07BKJDICBO@culture?$AA@
	jmp	SHORT $LN270@LogCityMon
$LN269@LogCityMon:
	mov	DWORD PTR tv1594[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN270@LogCityMon:
	mov	ecx, DWORD PTR tv1594[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234813[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234813[ebp]
	mov	DWORD PTR tv1176[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1624 : 				break;

	jmp	SHORT $LN53@LogCityMon
$LN47@LogCityMon:

; 1625 : 			case YIELD_FAITH:
; 1626 : 				AppendToLog(strHeader, strLog, "faith", aiCityYields[ui]);

	mov	edx, DWORD PTR _ui$225953[ebp]
	mov	eax, DWORD PTR _aiCityYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234516[ebp], esp
	mov	DWORD PTR $T234825[ebp], edx
	mov	eax, OFFSET ??_C@_05IMDAHFEM@faith?$AA@
	test	eax, eax
	je	SHORT $LN276@LogCityMon
	mov	DWORD PTR tv1607[ebp], OFFSET ??_C@_05IMDAHFEM@faith?$AA@
	jmp	SHORT $LN277@LogCityMon
$LN276@LogCityMon:
	mov	DWORD PTR tv1607[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN277@LogCityMon:
	mov	ecx, DWORD PTR tv1607[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234825[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234825[ebp]
	mov	DWORD PTR tv1179[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN53@LogCityMon:

; 1627 : 				break;
; 1628 : 			}
; 1629 : 		}

	jmp	$LN56@LogCityMon
$LN55@LogCityMon:

; 1630 : 
; 1631 : 		//	yields / pop
; 1632 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$225980[ebp], 0
	jmp	SHORT $LN46@LogCityMon
$LN45@LogCityMon:
	mov	edx, DWORD PTR _ui$225980[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$225980[ebp], edx
$LN46@LogCityMon:
	cmp	DWORD PTR _ui$225980[ebp], 6
	jae	$LN44@LogCityMon

; 1633 : 		{
; 1634 : 			fRatio = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fRatio$[ebp], xmm0

; 1635 : 			if(pLoopCity->getPopulation() > 0)

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	test	eax, eax
	jle	SHORT $LN43@LogCityMon

; 1636 : 			{
; 1637 : 				fRatio = aiCityYields[ui] / (float)pLoopCity->getPopulation();

	mov	eax, DWORD PTR _ui$225980[ebp]
	mov	ecx, DWORD PTR _aiCityYields$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T234829[ebp], edx
	mov	eax, DWORD PTR $T234829[ebp]
	cvtsi2ss xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	movss	DWORD PTR tv2444[ebp], xmm0
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cvtsi2ss xmm0, eax
	movss	xmm1, DWORD PTR tv2444[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _fRatio$[ebp], xmm1
$LN43@LogCityMon:

; 1638 : 			}
; 1639 : 
; 1640 : 			switch(ui)

	mov	ecx, DWORD PTR _ui$225980[ebp]
	mov	DWORD PTR tv542[ebp], ecx
	cmp	DWORD PTR tv542[ebp], 5
	ja	$LN41@LogCityMon
	mov	edx, DWORD PTR tv542[ebp]
	jmp	DWORD PTR $LN483@LogCityMon[edx*4]
$LN40@LogCityMon:

; 1641 : 			{
; 1642 : 			case YIELD_FOOD:
; 1643 : 				AppendToLog(strHeader, strLog, "food / pop", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234517[ebp], esp
	mov	DWORD PTR $T234838[ebp], eax
	mov	ecx, OFFSET ??_C@_0L@CEIDFJKN@food?5?1?5pop?$AA@
	test	ecx, ecx
	je	SHORT $LN283@LogCityMon
	mov	DWORD PTR tv1620[ebp], OFFSET ??_C@_0L@CEIDFJKN@food?5?1?5pop?$AA@
	jmp	SHORT $LN284@LogCityMon
$LN283@LogCityMon:
	mov	DWORD PTR tv1620[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN284@LogCityMon:
	mov	edx, DWORD PTR tv1620[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234838[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234838[ebp]
	mov	DWORD PTR tv1182[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1644 : 				break;

	jmp	$LN41@LogCityMon
$LN39@LogCityMon:

; 1645 : 			case YIELD_PRODUCTION:
; 1646 : 				AppendToLog(strHeader, strLog, "production / pop", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234518[ebp], esp
	mov	DWORD PTR $T234847[ebp], eax
	mov	ecx, OFFSET ??_C@_0BB@KLANKHFD@production?5?1?5pop?$AA@
	test	ecx, ecx
	je	SHORT $LN288@LogCityMon
	mov	DWORD PTR tv1665[ebp], OFFSET ??_C@_0BB@KLANKHFD@production?5?1?5pop?$AA@
	jmp	SHORT $LN289@LogCityMon
$LN288@LogCityMon:
	mov	DWORD PTR tv1665[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN289@LogCityMon:
	mov	edx, DWORD PTR tv1665[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234847[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234847[ebp]
	mov	DWORD PTR tv1185[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1647 : 				break;

	jmp	$LN41@LogCityMon
$LN38@LogCityMon:

; 1648 : 			case YIELD_SCIENCE:
; 1649 : 				AppendToLog(strHeader, strLog, "science / pop", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234519[ebp], esp
	mov	DWORD PTR $T234856[ebp], eax
	mov	ecx, OFFSET ??_C@_0O@FCMNBJKE@science?5?1?5pop?$AA@
	test	ecx, ecx
	je	SHORT $LN293@LogCityMon
	mov	DWORD PTR tv1678[ebp], OFFSET ??_C@_0O@FCMNBJKE@science?5?1?5pop?$AA@
	jmp	SHORT $LN294@LogCityMon
$LN293@LogCityMon:
	mov	DWORD PTR tv1678[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN294@LogCityMon:
	mov	edx, DWORD PTR tv1678[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234856[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234856[ebp]
	mov	DWORD PTR tv1188[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1650 : 				break;

	jmp	$LN41@LogCityMon
$LN37@LogCityMon:

; 1651 : 			case YIELD_GOLD:
; 1652 : 				AppendToLog(strHeader, strLog, "gold / pop", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234520[ebp], esp
	mov	DWORD PTR $T234865[ebp], eax
	mov	ecx, OFFSET ??_C@_0L@NMIALKKI@gold?5?1?5pop?$AA@
	test	ecx, ecx
	je	SHORT $LN298@LogCityMon
	mov	DWORD PTR tv1691[ebp], OFFSET ??_C@_0L@NMIALKKI@gold?5?1?5pop?$AA@
	jmp	SHORT $LN299@LogCityMon
$LN298@LogCityMon:
	mov	DWORD PTR tv1691[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN299@LogCityMon:
	mov	edx, DWORD PTR tv1691[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234865[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234865[ebp]
	mov	DWORD PTR tv1191[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1653 : 				break;

	jmp	$LN41@LogCityMon
$LN36@LogCityMon:

; 1654 : 			case YIELD_CULTURE:
; 1655 : 				AppendToLog(strHeader, strLog, "culture / pop", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234521[ebp], esp
	mov	DWORD PTR $T234874[ebp], eax
	mov	ecx, OFFSET ??_C@_0O@LDLDBMPJ@culture?5?1?5pop?$AA@
	test	ecx, ecx
	je	SHORT $LN303@LogCityMon
	mov	DWORD PTR tv1704[ebp], OFFSET ??_C@_0O@LDLDBMPJ@culture?5?1?5pop?$AA@
	jmp	SHORT $LN304@LogCityMon
$LN303@LogCityMon:
	mov	DWORD PTR tv1704[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN304@LogCityMon:
	mov	edx, DWORD PTR tv1704[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234874[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234874[ebp]
	mov	DWORD PTR tv1194[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1656 : 				break;

	jmp	SHORT $LN41@LogCityMon
$LN35@LogCityMon:

; 1657 : 			case YIELD_FAITH:
; 1658 : 				AppendToLog(strHeader, strLog, "faith / pop", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234522[ebp], esp
	mov	DWORD PTR $T234883[ebp], eax
	mov	ecx, OFFSET ??_C@_0M@KOKBELOB@faith?5?1?5pop?$AA@
	test	ecx, ecx
	je	SHORT $LN308@LogCityMon
	mov	DWORD PTR tv1717[ebp], OFFSET ??_C@_0M@KOKBELOB@faith?5?1?5pop?$AA@
	jmp	SHORT $LN309@LogCityMon
$LN308@LogCityMon:
	mov	DWORD PTR tv1717[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN309@LogCityMon:
	mov	edx, DWORD PTR tv1717[ebp]
	push	edx
	mov	ecx, DWORD PTR $T234883[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T234883[ebp]
	mov	DWORD PTR tv1197[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN41@LogCityMon:

; 1659 : 				break;
; 1660 : 			}
; 1661 : 		}

	jmp	$LN45@LogCityMon
$LN44@LogCityMon:

; 1662 : 
; 1663 : 		//	yields from specialists
; 1664 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$226008[ebp], 0
	jmp	SHORT $LN34@LogCityMon
$LN33@LogCityMon:
	mov	eax, DWORD PTR _ui$226008[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$226008[ebp], eax
$LN34@LogCityMon:
	cmp	DWORD PTR _ui$226008[ebp], 6
	jae	$LN32@LogCityMon

; 1665 : 		{
; 1666 : 			aiSpecialistsYields[ui] = pLoopCity->getExtraSpecialistYield((YieldTypes)ui);

	mov	ecx, DWORD PTR _ui$226008[ebp]
	mov	edx, DWORD PTR _aiSpecialistsYields$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T234887[ebp], eax
	mov	ecx, DWORD PTR _ui$226008[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getExtraSpecialistYield@CvCity@@QBEHW4YieldTypes@@@Z ; CvCity::getExtraSpecialistYield
	mov	edx, DWORD PTR $T234887[ebp]
	mov	DWORD PTR [edx], eax

; 1667 : 			switch(ui)

	mov	eax, DWORD PTR _ui$226008[ebp]
	mov	DWORD PTR tv658[ebp], eax
	cmp	DWORD PTR tv658[ebp], 5
	ja	$LN30@LogCityMon
	mov	ecx, DWORD PTR tv658[ebp]
	jmp	DWORD PTR $LN484@LogCityMon[ecx*4]
$LN29@LogCityMon:

; 1668 : 			{
; 1669 : 			case YIELD_FOOD:
; 1670 : 				AppendToLog(strHeader, strLog, "food specialist", aiSpecialistsYields[ui]);

	mov	edx, DWORD PTR _ui$226008[ebp]
	mov	eax, DWORD PTR _aiSpecialistsYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234523[ebp], esp
	mov	DWORD PTR $T234899[ebp], edx
	mov	eax, OFFSET ??_C@_0BA@GAIHMJHG@food?5specialist?$AA@
	test	eax, eax
	je	SHORT $LN317@LogCityMon
	mov	DWORD PTR tv1730[ebp], OFFSET ??_C@_0BA@GAIHMJHG@food?5specialist?$AA@
	jmp	SHORT $LN318@LogCityMon
$LN317@LogCityMon:
	mov	DWORD PTR tv1730[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN318@LogCityMon:
	mov	ecx, DWORD PTR tv1730[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234899[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234899[ebp]
	mov	DWORD PTR tv1200[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1671 : 				break;

	jmp	$LN30@LogCityMon
$LN28@LogCityMon:

; 1672 : 			case YIELD_PRODUCTION:
; 1673 : 				AppendToLog(strHeader, strLog, "production specialist", aiSpecialistsYields[ui]);

	mov	edx, DWORD PTR _ui$226008[ebp]
	mov	eax, DWORD PTR _aiSpecialistsYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234524[ebp], esp
	mov	DWORD PTR $T234911[ebp], edx
	mov	eax, OFFSET ??_C@_0BG@KGIKPENA@production?5specialist?$AA@
	test	eax, eax
	je	SHORT $LN324@LogCityMon
	mov	DWORD PTR tv1743[ebp], OFFSET ??_C@_0BG@KGIKPENA@production?5specialist?$AA@
	jmp	SHORT $LN325@LogCityMon
$LN324@LogCityMon:
	mov	DWORD PTR tv1743[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN325@LogCityMon:
	mov	ecx, DWORD PTR tv1743[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234911[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234911[ebp]
	mov	DWORD PTR tv1203[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1674 : 				break;

	jmp	$LN30@LogCityMon
$LN27@LogCityMon:

; 1675 : 			case YIELD_SCIENCE:
; 1676 : 				AppendToLog(strHeader, strLog, "science specialist", aiSpecialistsYields[ui]);

	mov	edx, DWORD PTR _ui$226008[ebp]
	mov	eax, DWORD PTR _aiSpecialistsYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234525[ebp], esp
	mov	DWORD PTR $T234923[ebp], edx
	mov	eax, OFFSET ??_C@_0BD@PFOCINIA@science?5specialist?$AA@
	test	eax, eax
	je	SHORT $LN331@LogCityMon
	mov	DWORD PTR tv1756[ebp], OFFSET ??_C@_0BD@PFOCINIA@science?5specialist?$AA@
	jmp	SHORT $LN332@LogCityMon
$LN331@LogCityMon:
	mov	DWORD PTR tv1756[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN332@LogCityMon:
	mov	ecx, DWORD PTR tv1756[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234923[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234923[ebp]
	mov	DWORD PTR tv1206[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1677 : 				break;

	jmp	$LN30@LogCityMon
$LN26@LogCityMon:

; 1678 : 			case YIELD_GOLD:
; 1679 : 				AppendToLog(strHeader, strLog, "gold specialist", aiSpecialistsYields[ui]);

	mov	edx, DWORD PTR _ui$226008[ebp]
	mov	eax, DWORD PTR _aiSpecialistsYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234526[ebp], esp
	mov	DWORD PTR $T234935[ebp], edx
	mov	eax, OFFSET ??_C@_0BA@LCIOHNDM@gold?5specialist?$AA@
	test	eax, eax
	je	SHORT $LN338@LogCityMon
	mov	DWORD PTR tv1769[ebp], OFFSET ??_C@_0BA@LCIOHNDM@gold?5specialist?$AA@
	jmp	SHORT $LN339@LogCityMon
$LN338@LogCityMon:
	mov	DWORD PTR tv1769[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN339@LogCityMon:
	mov	ecx, DWORD PTR tv1769[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234935[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234935[ebp]
	mov	DWORD PTR tv1209[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1680 : 				break;

	jmp	$LN30@LogCityMon
$LN25@LogCityMon:

; 1681 : 			case YIELD_CULTURE:
; 1682 : 				AppendToLog(strHeader, strLog, "culture specialist", aiSpecialistsYields[ui]);

	mov	edx, DWORD PTR _ui$226008[ebp]
	mov	eax, DWORD PTR _aiSpecialistsYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234527[ebp], esp
	mov	DWORD PTR $T234947[ebp], edx
	mov	eax, OFFSET ??_C@_0BD@BLLFPBDP@culture?5specialist?$AA@
	test	eax, eax
	je	SHORT $LN345@LogCityMon
	mov	DWORD PTR tv1782[ebp], OFFSET ??_C@_0BD@BLLFPBDP@culture?5specialist?$AA@
	jmp	SHORT $LN346@LogCityMon
$LN345@LogCityMon:
	mov	DWORD PTR tv1782[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN346@LogCityMon:
	mov	ecx, DWORD PTR tv1782[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234947[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234947[ebp]
	mov	DWORD PTR tv1212[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1683 : 				break;

	jmp	SHORT $LN30@LogCityMon
$LN24@LogCityMon:

; 1684 : 			case YIELD_FAITH:
; 1685 : 				AppendToLog(strHeader, strLog, "faith specialist", aiSpecialistsYields[ui]);

	mov	edx, DWORD PTR _ui$226008[ebp]
	mov	eax, DWORD PTR _aiSpecialistsYields$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234528[ebp], esp
	mov	DWORD PTR $T234959[ebp], edx
	mov	eax, OFFSET ??_C@_0BB@PNDBABGF@faith?5specialist?$AA@
	test	eax, eax
	je	SHORT $LN352@LogCityMon
	mov	DWORD PTR tv1795[ebp], OFFSET ??_C@_0BB@PNDBABGF@faith?5specialist?$AA@
	jmp	SHORT $LN353@LogCityMon
$LN352@LogCityMon:
	mov	DWORD PTR tv1795[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN353@LogCityMon:
	mov	ecx, DWORD PTR tv1795[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T234959[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T234959[ebp]
	mov	DWORD PTR tv1215[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN30@LogCityMon:

; 1686 : 				break;
; 1687 : 			}
; 1688 : 		}

	jmp	$LN33@LogCityMon
$LN32@LogCityMon:

; 1689 : 
; 1690 : 		// ratio from specialists
; 1691 : 		for(uint ui = 0; ui < NUM_YIELD_TYPES; ui++)

	mov	DWORD PTR _ui$226035[ebp], 0
	jmp	SHORT $LN23@LogCityMon
$LN22@LogCityMon:
	mov	edx, DWORD PTR _ui$226035[ebp]
	add	edx, 1
	mov	DWORD PTR _ui$226035[ebp], edx
$LN23@LogCityMon:
	cmp	DWORD PTR _ui$226035[ebp], 6
	jae	$LN21@LogCityMon

; 1692 : 		{
; 1693 : 			fRatio = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fRatio$[ebp], xmm0

; 1694 : 			if(aiCityYields[ui] > 0)

	mov	eax, DWORD PTR _ui$226035[ebp]
	mov	ecx, DWORD PTR _aiCityYields$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jle	SHORT $LN20@LogCityMon

; 1695 : 			{
; 1696 : 				fRatio = aiSpecialistsYields[ui] / (float)aiCityYields[ui];

	mov	edx, DWORD PTR _ui$226035[ebp]
	mov	eax, DWORD PTR _aiSpecialistsYields$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T234966[ebp], ecx
	mov	edx, DWORD PTR $T234966[ebp]
	cvtsi2ss xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _ui$226035[ebp]
	mov	ecx, DWORD PTR _aiCityYields$[ebp]
	cvtsi2ss xmm1, DWORD PTR [ecx+eax*4]
	divss	xmm0, xmm1
	movss	DWORD PTR _fRatio$[ebp], xmm0
$LN20@LogCityMon:

; 1697 : 			}
; 1698 : 			switch(ui)

	mov	edx, DWORD PTR _ui$226035[ebp]
	mov	DWORD PTR tv831[ebp], edx
	cmp	DWORD PTR tv831[ebp], 5
	ja	$LN18@LogCityMon
	mov	eax, DWORD PTR tv831[ebp]
	jmp	DWORD PTR $LN485@LogCityMon[eax*4]
$LN17@LogCityMon:

; 1699 : 			{
; 1700 : 			case YIELD_FOOD:
; 1701 : 				AppendToLog(strHeader, strLog, "food specialist / food", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234529[ebp], esp
	mov	DWORD PTR $T234978[ebp], ecx
	mov	edx, OFFSET ??_C@_0BH@HBLNFIPP@food?5specialist?5?1?5food?$AA@
	test	edx, edx
	je	SHORT $LN363@LogCityMon
	mov	DWORD PTR tv1808[ebp], OFFSET ??_C@_0BH@HBLNFIPP@food?5specialist?5?1?5food?$AA@
	jmp	SHORT $LN364@LogCityMon
$LN363@LogCityMon:
	mov	DWORD PTR tv1808[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN364@LogCityMon:
	mov	eax, DWORD PTR tv1808[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234978[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234978[ebp]
	mov	DWORD PTR tv1218[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1702 : 				break;

	jmp	$LN18@LogCityMon
$LN16@LogCityMon:

; 1703 : 			case YIELD_PRODUCTION:
; 1704 : 				AppendToLog(strHeader, strLog, "production specialist / production", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234530[ebp], esp
	mov	DWORD PTR $T234987[ebp], ecx
	mov	edx, OFFSET ??_C@_0CD@IHGELMMI@production?5specialist?5?1?5producti@
	test	edx, edx
	je	SHORT $LN368@LogCityMon
	mov	DWORD PTR tv1821[ebp], OFFSET ??_C@_0CD@IHGELMMI@production?5specialist?5?1?5producti@
	jmp	SHORT $LN369@LogCityMon
$LN368@LogCityMon:
	mov	DWORD PTR tv1821[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN369@LogCityMon:
	mov	eax, DWORD PTR tv1821[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234987[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234987[ebp]
	mov	DWORD PTR tv1221[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1705 : 				break;

	jmp	$LN18@LogCityMon
$LN15@LogCityMon:

; 1706 : 			case YIELD_SCIENCE:
; 1707 : 				AppendToLog(strHeader, strLog, "science specialist / science", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234531[ebp], esp
	mov	DWORD PTR $T234996[ebp], ecx
	mov	edx, OFFSET ??_C@_0BN@FDNNIAFN@science?5specialist?5?1?5science?$AA@
	test	edx, edx
	je	SHORT $LN373@LogCityMon
	mov	DWORD PTR tv1834[ebp], OFFSET ??_C@_0BN@FDNNIAFN@science?5specialist?5?1?5science?$AA@
	jmp	SHORT $LN374@LogCityMon
$LN373@LogCityMon:
	mov	DWORD PTR tv1834[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN374@LogCityMon:
	mov	eax, DWORD PTR tv1834[ebp]
	push	eax
	mov	ecx, DWORD PTR $T234996[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T234996[ebp]
	mov	DWORD PTR tv1224[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1708 : 				break;

	jmp	$LN18@LogCityMon
$LN14@LogCityMon:

; 1709 : 			case YIELD_GOLD:
; 1710 : 				AppendToLog(strHeader, strLog, "gold specialist / gold", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234532[ebp], esp
	mov	DWORD PTR $T235005[ebp], ecx
	mov	edx, OFFSET ??_C@_0BH@KOPGKHCB@gold?5specialist?5?1?5gold?$AA@
	test	edx, edx
	je	SHORT $LN378@LogCityMon
	mov	DWORD PTR tv1847[ebp], OFFSET ??_C@_0BH@KOPGKHCB@gold?5specialist?5?1?5gold?$AA@
	jmp	SHORT $LN379@LogCityMon
$LN378@LogCityMon:
	mov	DWORD PTR tv1847[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN379@LogCityMon:
	mov	eax, DWORD PTR tv1847[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235005[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T235005[ebp]
	mov	DWORD PTR tv1227[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1711 : 				break;

	jmp	$LN18@LogCityMon
$LN13@LogCityMon:

; 1712 : 			case YIELD_CULTURE:
; 1713 : 				AppendToLog(strHeader, strLog, "culture specialist / culture", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234533[ebp], esp
	mov	DWORD PTR $T235014[ebp], ecx
	mov	edx, OFFSET ??_C@_0BN@NJMPOJDK@culture?5specialist?5?1?5culture?$AA@
	test	edx, edx
	je	SHORT $LN383@LogCityMon
	mov	DWORD PTR tv1860[ebp], OFFSET ??_C@_0BN@NJMPOJDK@culture?5specialist?5?1?5culture?$AA@
	jmp	SHORT $LN384@LogCityMon
$LN383@LogCityMon:
	mov	DWORD PTR tv1860[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN384@LogCityMon:
	mov	eax, DWORD PTR tv1860[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235014[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T235014[ebp]
	mov	DWORD PTR tv1230[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1714 : 				break;

	jmp	SHORT $LN18@LogCityMon
$LN12@LogCityMon:

; 1715 : 			case YIELD_FAITH:
; 1716 : 				AppendToLog(strHeader, strLog, "faith specialist / faith", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234534[ebp], esp
	mov	DWORD PTR $T235023[ebp], ecx
	mov	edx, OFFSET ??_C@_0BJ@OOOJAFFK@faith?5specialist?5?1?5faith?$AA@
	test	edx, edx
	je	SHORT $LN388@LogCityMon
	mov	DWORD PTR tv1873[ebp], OFFSET ??_C@_0BJ@OOOJAFFK@faith?5specialist?5?1?5faith?$AA@
	jmp	SHORT $LN389@LogCityMon
$LN388@LogCityMon:
	mov	DWORD PTR tv1873[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN389@LogCityMon:
	mov	eax, DWORD PTR tv1873[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235023[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T235023[ebp]
	mov	DWORD PTR tv1233[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H
$LN18@LogCityMon:

; 1717 : 				break;
; 1718 : 			}
; 1719 : 		}

	jmp	$LN22@LogCityMon
$LN21@LogCityMon:

; 1720 : 
; 1721 : 		//	% of worked tiles that are improved
; 1722 : 		// worked tiles
; 1723 : 		int iTiles = 0;

	mov	DWORD PTR _iTiles$226063[ebp], 0

; 1724 : 		int iWorkedTiles = 0;

	mov	DWORD PTR _iWorkedTiles$226064[ebp], 0

; 1725 : 		int iImprovedTiles = 0;

	mov	DWORD PTR _iImprovedTiles$226065[ebp], 0

; 1726 : 		for(uint uiPlotIndex = 0; uiPlotIndex < aiPlots.size(); uiPlotIndex++)

	mov	DWORD PTR _uiPlotIndex$226066[ebp], 0
	jmp	SHORT $LN11@LogCityMon
$LN10@LogCityMon:
	mov	ecx, DWORD PTR _uiPlotIndex$226066[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiPlotIndex$226066[ebp], ecx
$LN11@LogCityMon:
	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235027[ebp], eax
	mov	ecx, DWORD PTR _uiPlotIndex$226066[ebp]
	cmp	ecx, DWORD PTR $T235027[ebp]
	jae	$LN9@LogCityMon

; 1727 : 		{
; 1728 : 			// when we encounter the first plot that is invalid, the rest of the list will be invalid
; 1729 : 			if(aiPlots[uiPlotIndex] == -1)

	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _uiPlotIndex$226066[ebp]
	cmp	DWORD PTR [eax+ecx*4], -1
	jne	SHORT $LN8@LogCityMon

; 1730 : 			{
; 1731 : 				break;

	jmp	$LN9@LogCityMon
$LN8@LogCityMon:

; 1732 : 			}
; 1733 : 
; 1734 : 			CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[uiPlotIndex]);

	mov	edx, DWORD PTR _aiPlots$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _uiPlotIndex$226066[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR $T235034[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235038[ebp], eax
	mov	ecx, DWORD PTR $T235034[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T235052[ebp], edx
	cmp	DWORD PTR $T235052[ebp], 0
	jl	SHORT $LN401@LogCityMon
	mov	eax, DWORD PTR $T235038[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T235045[ebp], ecx
	mov	edx, DWORD PTR $T235052[ebp]
	cmp	edx, DWORD PTR $T235045[ebp]
	jge	SHORT $LN401@LogCityMon
	mov	eax, DWORD PTR $T235052[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR $T235038[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv1886[ebp], eax
	jmp	SHORT $LN402@LogCityMon
$LN401@LogCityMon:
	mov	DWORD PTR tv1886[ebp], 0
$LN402@LogCityMon:
	mov	edx, DWORD PTR tv1886[ebp]
	mov	DWORD PTR _pPlot$226071[ebp], edx

; 1735 : 			if(!pPlot)

	cmp	DWORD PTR _pPlot$226071[ebp], 0
	jne	SHORT $LN7@LogCityMon

; 1736 : 			{
; 1737 : 				continue;

	jmp	$LN10@LogCityMon
$LN7@LogCityMon:

; 1738 : 			}
; 1739 : 
; 1740 : 			// plot has city in it, don't count
; 1741 : 			if(pPlot->getPlotCity())

	mov	ecx, DWORD PTR _pPlot$226071[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	je	SHORT $LN6@LogCityMon

; 1742 : 			{
; 1743 : 				continue;

	jmp	$LN10@LogCityMon
$LN6@LogCityMon:

; 1744 : 			}
; 1745 : 
; 1746 : 			if(!pLoopCity->GetCityCitizens()->IsCanWork(pPlot))

	mov	eax, DWORD PTR _pPlot$226071[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityCitizens@CvCity@@QBEPAVCvCityCitizens@@XZ ; CvCity::GetCityCitizens
	mov	ecx, eax
	call	?IsCanWork@CvCityCitizens@@QBE_NPAVCvPlot@@@Z ; CvCityCitizens::IsCanWork
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@LogCityMon

; 1747 : 			{
; 1748 : 				continue;

	jmp	$LN10@LogCityMon
$LN5@LogCityMon:

; 1749 : 			}
; 1750 : 
; 1751 : 			iTiles++;

	mov	edx, DWORD PTR _iTiles$226063[ebp]
	add	edx, 1
	mov	DWORD PTR _iTiles$226063[ebp], edx

; 1752 : 
; 1753 : 			if(pPlot->getWorkingCity() == pLoopCity)

	mov	ecx, DWORD PTR _pPlot$226071[ebp]
	call	?getWorkingCity@CvPlot@@QBEPAVCvCity@@XZ ; CvPlot::getWorkingCity
	cmp	eax, DWORD PTR _pLoopCity$[ebp]
	jne	SHORT $LN4@LogCityMon

; 1754 : 			{
; 1755 : 				iWorkedTiles++;

	mov	eax, DWORD PTR _iWorkedTiles$226064[ebp]
	add	eax, 1
	mov	DWORD PTR _iWorkedTiles$226064[ebp], eax
$LN4@LogCityMon:

; 1756 : 			}
; 1757 : 
; 1758 : 			if(pPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pPlot$226071[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN3@LogCityMon

; 1759 : 			{
; 1760 : 				iImprovedTiles++;

	mov	ecx, DWORD PTR _iImprovedTiles$226065[ebp]
	add	ecx, 1
	mov	DWORD PTR _iImprovedTiles$226065[ebp], ecx
$LN3@LogCityMon:

; 1761 : 			}
; 1762 : 		}

	jmp	$LN10@LogCityMon
$LN9@LogCityMon:

; 1763 : 
; 1764 : 		AppendToLog(strHeader, strLog, "Tiles", iTiles);

	mov	edx, DWORD PTR _iTiles$226063[ebp]
	push	edx
	sub	esp, 28					; 0000001cH
	mov	eax, esp
	mov	DWORD PTR $T234535[ebp], esp
	mov	DWORD PTR $T235066[ebp], eax
	mov	ecx, OFFSET ??_C@_05HGPOGKME@Tiles?$AA@
	test	ecx, ecx
	je	SHORT $LN412@LogCityMon
	mov	DWORD PTR tv1890[ebp], OFFSET ??_C@_05HGPOGKME@Tiles?$AA@
	jmp	SHORT $LN413@LogCityMon
$LN412@LogCityMon:
	mov	DWORD PTR tv1890[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN413@LogCityMon:
	mov	edx, DWORD PTR tv1890[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235066[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T235066[ebp]
	mov	DWORD PTR tv1236[ebp], eax
	lea	ecx, DWORD PTR _strLog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _strHeader$[ebp]
	push	edx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1765 : 		AppendToLog(strHeader, strLog, "Worked (non-city) tiles", iWorkedTiles);

	mov	eax, DWORD PTR _iWorkedTiles$226064[ebp]
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T234536[ebp], esp
	mov	DWORD PTR $T235075[ebp], ecx
	mov	edx, OFFSET ??_C@_0BI@NDOPNBOH@Worked?5?$CInon?9city?$CJ?5tiles?$AA@
	test	edx, edx
	je	SHORT $LN417@LogCityMon
	mov	DWORD PTR tv1914[ebp], OFFSET ??_C@_0BI@NDOPNBOH@Worked?5?$CInon?9city?$CJ?5tiles?$AA@
	jmp	SHORT $LN418@LogCityMon
$LN417@LogCityMon:
	mov	DWORD PTR tv1914[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN418@LogCityMon:
	mov	eax, DWORD PTR tv1914[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235075[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T235075[ebp]
	mov	DWORD PTR tv1239[ebp], ecx
	lea	edx, DWORD PTR _strLog$[ebp]
	push	edx
	lea	eax, DWORD PTR _strHeader$[ebp]
	push	eax
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1766 : 		AppendToLog(strHeader, strLog, "Improved tiles", iImprovedTiles);

	mov	ecx, DWORD PTR _iImprovedTiles$226065[ebp]
	push	ecx
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234537[ebp], esp
	mov	DWORD PTR $T235084[ebp], edx
	mov	eax, OFFSET ??_C@_0P@FHPLPJCO@Improved?5tiles?$AA@
	test	eax, eax
	je	SHORT $LN422@LogCityMon
	mov	DWORD PTR tv1927[ebp], OFFSET ??_C@_0P@FHPLPJCO@Improved?5tiles?$AA@
	jmp	SHORT $LN423@LogCityMon
$LN422@LogCityMon:
	mov	DWORD PTR tv1927[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN423@LogCityMon:
	mov	ecx, DWORD PTR tv1927[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235084[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T235084[ebp]
	mov	DWORD PTR tv1242[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@H@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1767 : 
; 1768 : 		// % of worked tiles that are improved
; 1769 : 		// improved / worked tiles
; 1770 : 		fRatio = 0.0f;

	movss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _fRatio$[ebp], xmm0

; 1771 : 		if(iWorkedTiles > 0)

	cmp	DWORD PTR _iWorkedTiles$226064[ebp], 0
	jle	SHORT $LN2@LogCityMon

; 1772 : 		{
; 1773 : 			fRatio = iImprovedTiles / (float)iWorkedTiles;

	cvtsi2ss xmm0, DWORD PTR _iImprovedTiles$226065[ebp]
	cvtsi2ss xmm1, DWORD PTR _iWorkedTiles$226064[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _fRatio$[ebp], xmm0
$LN2@LogCityMon:

; 1774 : 		}
; 1775 : 		AppendToLog(strHeader, strLog, "improved / worked", fRatio);

	push	ecx
	fld	DWORD PTR _fRatio$[ebp]
	fstp	DWORD PTR [esp]
	sub	esp, 28					; 0000001cH
	mov	edx, esp
	mov	DWORD PTR $T234538[ebp], esp
	mov	DWORD PTR $T235093[ebp], edx
	mov	eax, OFFSET ??_C@_0BC@BMNJLBAI@improved?5?1?5worked?$AA@
	test	eax, eax
	je	SHORT $LN427@LogCityMon
	mov	DWORD PTR tv1940[ebp], OFFSET ??_C@_0BC@BMNJLBAI@improved?5?1?5worked?$AA@
	jmp	SHORT $LN428@LogCityMon
$LN427@LogCityMon:
	mov	DWORD PTR tv1940[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN428@LogCityMon:
	mov	ecx, DWORD PTR tv1940[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T235093[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T235093[ebp]
	mov	DWORD PTR tv1245[ebp], edx
	lea	eax, DWORD PTR _strLog$[ebp]
	push	eax
	lea	ecx, DWORD PTR _strHeader$[ebp]
	push	ecx
	call	?AppendToLog@@YAXAAVCvString@@0V1@M@Z	; AppendToLog
	add	esp, 40					; 00000028H

; 1776 : 
; 1777 : 		if(bBuildHeader)

	movzx	edx, BYTE PTR _bBuildHeader$[ebp]
	test	edx, edx
	je	SHORT $LN1@LogCityMon

; 1778 : 		{
; 1779 : 			bBuildHeader = false;

	mov	BYTE PTR _bBuildHeader$[ebp], 0

; 1780 : 			pLog->Msg(strHeader);

	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235097[ebp], eax
	mov	eax, DWORD PTR $T235097[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLog$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx]
	call	ecx
	add	esp, 8
$LN1@LogCityMon:

; 1781 : 		}
; 1782 : 		pLog->Msg(strLog);

	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T235101[ebp], eax
	mov	edx, DWORD PTR $T235101[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 1783 : 	}

	jmp	$LN65@LogCityMon
$LN64@LogCityMon:

; 1784 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _aiSpecialistsYields$[ebp]
	call	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _aiCityYields$[ebp]
	call	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _str$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _strLogName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLog$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strHeader$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN73@LogCityMon:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN482@LogCityMon:
	DD	$LN52@LogCityMon
	DD	$LN51@LogCityMon
	DD	$LN49@LogCityMon
	DD	$LN50@LogCityMon
	DD	$LN48@LogCityMon
	DD	$LN47@LogCityMon
$LN483@LogCityMon:
	DD	$LN40@LogCityMon
	DD	$LN39@LogCityMon
	DD	$LN37@LogCityMon
	DD	$LN38@LogCityMon
	DD	$LN36@LogCityMon
	DD	$LN35@LogCityMon
$LN484@LogCityMon:
	DD	$LN29@LogCityMon
	DD	$LN28@LogCityMon
	DD	$LN26@LogCityMon
	DD	$LN27@LogCityMon
	DD	$LN25@LogCityMon
	DD	$LN24@LogCityMon
$LN485@LogCityMon:
	DD	$LN17@LogCityMon
	DD	$LN16@LogCityMon
	DD	$LN14@LogCityMon
	DD	$LN15@LogCityMon
	DD	$LN13@LogCityMon
	DD	$LN12@LogCityMon
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strHeader$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strLog$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strPlayerName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strLogName$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T234500[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T234501[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$6:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$7:
	lea	ecx, DWORD PTR _aiCityYields$[ebp]
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$8:
	lea	ecx, DWORD PTR _aiSpecialistsYields$[ebp]
	jmp	??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$9:
	mov	ecx, DWORD PTR $T234504[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$12:
	lea	ecx, DWORD PTR $T234507[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogCityMonitor@CvEconomicAI@@QAEXXZ$13:
	mov	ecx, DWORD PTR $T234508[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogCityMonitor@CvEconomicAI@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1048]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogCityMonitor@CvEconomicAI@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogCityMonitor@CvEconomicAI@@QAEXXZ ENDP		; CvEconomicAI::LogCityMonitor
EXTRN	?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z:PROC ; CvCityStrategyAI::LogHurry
EXTRN	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ:PROC ; CvCity::GetCityStrategyAI
EXTRN	?hurry@CvCity@@QAEXW4HurryTypes@@@Z:PROC	; CvCity::hurry
EXTRN	?hurryPopulation@CvCity@@QBEHW4HurryTypes@@@Z:PROC ; CvCity::hurryPopulation
EXTRN	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::IsEmpireUnhappy
EXTRN	?getProductionPerPopulation@CvHurryInfo@@QBEHXZ:PROC ; CvHurryInfo::getProductionPerPopulation
EXTRN	?getGoldPerProduction@CvHurryInfo@@QBEHXZ:PROC	; CvHurryInfo::getGoldPerProduction
EXTRN	?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z:PROC ; CvGlobals::getHurryInfo
EXTRN	?getProductionTurnsLeft@CvCity@@QBEHXZ:PROC	; CvCity::getProductionTurnsLeft
EXTRN	?hurryProduction@CvCity@@QBEHW4HurryTypes@@@Z:PROC ; CvCity::hurryProduction
EXTRN	?canHurry@CvCity@@QBE_NW4HurryTypes@@_N@Z:PROC	; CvCity::canHurry
EXTRN	?getNumHurryInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumHurryInfos
EXTRN	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z:PROC ; CvCity::getOrderFromQueue
; Function compile flags: /Odtp
;	COMDAT ?DoHurry@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -52						; size = 4
_iHurryAmountAvailable$ = -48				; size = 4
_eBestHurryType$ = -44					; size = 4
_iTurnsSaved$ = -40					; size = 4
_iBestHurryTurnsSaved$ = -36				; size = 4
_iBestHurryAmountAvailable$ = -32			; size = 4
_iHurryAmount$ = -28					; size = 4
_iI$ = -24						; size = 4
_pBestHurryCity$ = -20					; size = 4
_iBestHurryAmount$ = -16				; size = 4
_pLoopCity$ = -12					; size = 4
_iLoop$ = -8						; size = 4
_pOrder$ = -4						; size = 4
?DoHurry@CvEconomicAI@@AAEXXZ PROC			; CvEconomicAI::DoHurry, COMDAT
; _this$ = ecx

; 1790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 1791 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[ebp], 0

; 1792 : 	OrderData* pOrder = 0;

	mov	DWORD PTR _pOrder$[ebp], 0

; 1793 : 
; 1794 : 	CvCity* pLoopCity = 0;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 1795 : 	int iTurnsSaved = 0;

	mov	DWORD PTR _iTurnsSaved$[ebp], 0

; 1796 : 	int iHurryAmount = 0;

	mov	DWORD PTR _iHurryAmount$[ebp], 0

; 1797 : 	int iHurryAmountAvailable = 0;

	mov	DWORD PTR _iHurryAmountAvailable$[ebp], 0

; 1798 : #ifdef AUI_WARNING_FIXES
; 1799 : 	uint iI = 0;
; 1800 : #else
; 1801 : 	int iI = 0;

	mov	DWORD PTR _iI$[ebp], 0

; 1802 : #endif
; 1803 : 
; 1804 : 	CvCity* pBestHurryCity = NULL;

	mov	DWORD PTR _pBestHurryCity$[ebp], 0

; 1805 : 	int iBestHurryTurnsSaved = 0;

	mov	DWORD PTR _iBestHurryTurnsSaved$[ebp], 0

; 1806 : 	int iBestHurryAmount = 0;

	mov	DWORD PTR _iBestHurryAmount$[ebp], 0

; 1807 : 	int iBestHurryAmountAvailable = 0;

	mov	DWORD PTR _iBestHurryAmountAvailable$[ebp], 0

; 1808 : 	HurryTypes eBestHurryType = NO_HURRY;

	mov	DWORD PTR _eBestHurryType$[ebp], -1

; 1809 : 
; 1810 : 	// Look at each of our cities
; 1811 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN15@DoHurry
$LN14@DoHurry:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN15@DoHurry:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN13@DoHurry

; 1812 : 	{
; 1813 : 		// What are we currently working on?
; 1814 : 		pOrder = pLoopCity->getOrderFromQueue(0);

	push	0
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getOrderFromQueue@CvCity@@QAEPAUOrderData@@H@Z ; CvCity::getOrderFromQueue
	mov	DWORD PTR _pOrder$[ebp], eax

; 1815 : 
; 1816 : 		// Did we want to rush it?
; 1817 : 		if(pOrder != NULL && pOrder->bRush)

	cmp	DWORD PTR _pOrder$[ebp], 0
	je	$LN12@DoHurry
	mov	ecx, DWORD PTR _pOrder$[ebp]
	movzx	edx, BYTE PTR [ecx+13]
	test	edx, edx
	je	$LN12@DoHurry

; 1818 : 		{
; 1819 : 			for(iI = 0; iI < GC.getNumHurryInfos(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN11@DoHurry
$LN10@DoHurry:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN11@DoHurry:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumHurryInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumHurryInfos
	cmp	DWORD PTR _iI$[ebp], eax
	jge	$LN12@DoHurry

; 1820 : 			{
; 1821 : 				iHurryAmount = 0;

	mov	DWORD PTR _iHurryAmount$[ebp], 0

; 1822 : 
; 1823 : 				if(pLoopCity->canHurry((HurryTypes)iI) &&
; 1824 : 					pLoopCity->hurryProduction((HurryTypes)iI) > 0)

	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?canHurry@CvCity@@QBE_NW4HurryTypes@@_N@Z ; CvCity::canHurry
	movzx	edx, al
	test	edx, edx
	je	$LN8@DoHurry
	mov	eax, DWORD PTR _iI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?hurryProduction@CvCity@@QBEHW4HurryTypes@@@Z ; CvCity::hurryProduction
	test	eax, eax
	jle	$LN8@DoHurry

; 1825 : 				{
; 1826 : 					iTurnsSaved = pLoopCity->getProductionTurnsLeft() - 1;

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getProductionTurnsLeft@CvCity@@QBEHXZ	; CvCity::getProductionTurnsLeft
	sub	eax, 1
	mov	DWORD PTR _iTurnsSaved$[ebp], eax

; 1827 : 					if(iTurnsSaved > 0)

	cmp	DWORD PTR _iTurnsSaved$[ebp], 0
	jle	$LN8@DoHurry

; 1828 : 					{
; 1829 : #ifdef AUI_WARNING_FIXES
; 1830 : 						CvHurryInfo* pHurryInfo = GC.getHurryInfo((HurryTypes)iI);
; 1831 : 						if (!pHurryInfo)
; 1832 : 							continue;
; 1833 : 						if (pHurryInfo->getGoldPerProduction() > 0)
; 1834 : #else
; 1835 : 						if(GC.getHurryInfo((HurryTypes)iI)->getGoldPerProduction() > 0)

	mov	ecx, DWORD PTR _iI$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z ; CvGlobals::getHurryInfo
	mov	ecx, eax
	call	?getGoldPerProduction@CvHurryInfo@@QBEHXZ ; CvHurryInfo::getGoldPerProduction
	test	eax, eax
	jle	SHORT $LN6@DoHurry
	jmp	SHORT $LN5@DoHurry
$LN6@DoHurry:

; 1836 : #endif
; 1837 : 						{
; 1838 : 							// Don't gold rush at all anymore (save gold to buy tiles)
; 1839 : 
; 1840 : 							// iHurryAmount = pLoopCity->hurryGold((HurryTypes)iI);
; 1841 : 							// iHurryAmountAvailable = m_pPlayer->getGold();
; 1842 : 						}
; 1843 : #ifdef AUI_WARNING_FIXES
; 1844 : 						else if (pHurryInfo->getProductionPerPopulation() > 0)
; 1845 : #else
; 1846 : 						else if(GC.getHurryInfo((HurryTypes)iI)->getProductionPerPopulation() > 0)

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHurryInfo@CvGlobals@@QAEPAVCvHurryInfo@@W4HurryTypes@@@Z ; CvGlobals::getHurryInfo
	mov	ecx, eax
	call	?getProductionPerPopulation@CvHurryInfo@@QBEHXZ ; CvHurryInfo::getProductionPerPopulation
	test	eax, eax
	jle	SHORT $LN5@DoHurry

; 1847 : #endif
; 1848 : 						{
; 1849 : 							// Only pop rush if over our current Happiness limit
; 1850 : 							if(m_pPlayer->IsEmpireUnhappy())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN5@DoHurry

; 1851 : 							{
; 1852 : 								iHurryAmount = pLoopCity->hurryPopulation((HurryTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?hurryPopulation@CvCity@@QBEHW4HurryTypes@@@Z ; CvCity::hurryPopulation
	mov	DWORD PTR _iHurryAmount$[ebp], eax

; 1853 : 								iHurryAmountAvailable = pLoopCity->getPopulation();

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	DWORD PTR _iHurryAmountAvailable$[ebp], eax
$LN5@DoHurry:

; 1854 : 							}
; 1855 : 						}
; 1856 : 
; 1857 : 						// Current hurry heuristic is to hurry whichever item has the most turns still to complete
; 1858 : 						if(iHurryAmount > 0 && iTurnsSaved >= iBestHurryTurnsSaved)

	cmp	DWORD PTR _iHurryAmount$[ebp], 0
	jle	SHORT $LN8@DoHurry
	mov	eax, DWORD PTR _iTurnsSaved$[ebp]
	cmp	eax, DWORD PTR _iBestHurryTurnsSaved$[ebp]
	jl	SHORT $LN8@DoHurry

; 1859 : 						{
; 1860 : 							iBestHurryTurnsSaved = iTurnsSaved;

	mov	ecx, DWORD PTR _iTurnsSaved$[ebp]
	mov	DWORD PTR _iBestHurryTurnsSaved$[ebp], ecx

; 1861 : 							iBestHurryAmount = iHurryAmount;

	mov	edx, DWORD PTR _iHurryAmount$[ebp]
	mov	DWORD PTR _iBestHurryAmount$[ebp], edx

; 1862 : 							iBestHurryAmountAvailable = iHurryAmountAvailable;

	mov	eax, DWORD PTR _iHurryAmountAvailable$[ebp]
	mov	DWORD PTR _iBestHurryAmountAvailable$[ebp], eax

; 1863 : 							pBestHurryCity = pLoopCity;

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestHurryCity$[ebp], ecx

; 1864 : 							eBestHurryType = (HurryTypes)iI;

	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR _eBestHurryType$[ebp], edx
$LN8@DoHurry:

; 1865 : 						}
; 1866 : 					}
; 1867 : 				}
; 1868 : 			}

	jmp	$LN10@DoHurry
$LN12@DoHurry:

; 1869 : 		}
; 1870 : 	}

	jmp	$LN14@DoHurry
$LN13@DoHurry:

; 1871 : 
; 1872 : 	// Now enact the best hurry we've found (only hurry one item per turn for now)
; 1873 : 	if(pBestHurryCity != NULL)

	cmp	DWORD PTR _pBestHurryCity$[ebp], 0
	je	SHORT $LN16@DoHurry

; 1874 : 	{
; 1875 : 		pBestHurryCity->hurry(eBestHurryType);

	mov	eax, DWORD PTR _eBestHurryType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBestHurryCity$[ebp]
	call	?hurry@CvCity@@QAEXW4HurryTypes@@@Z	; CvCity::hurry

; 1876 : 		pBestHurryCity->GetCityStrategyAI()->LogHurry(eBestHurryType, iBestHurryAmount, iBestHurryAmountAvailable, iBestHurryTurnsSaved);

	mov	ecx, DWORD PTR _iBestHurryTurnsSaved$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBestHurryAmountAvailable$[ebp]
	push	edx
	mov	eax, DWORD PTR _iBestHurryAmount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eBestHurryType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pBestHurryCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?LogHurry@CvCityStrategyAI@@QAEXW4HurryTypes@@HHH@Z ; CvCityStrategyAI::LogHurry
$LN16@DoHurry:

; 1877 : 	}
; 1878 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoHurry@CvEconomicAI@@AAEXXZ ENDP			; CvEconomicAI::DoHurry
_TEXT	ENDS
PUBLIC	??_C@_0EM@BLJLBMAN@Buying?5plot?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5Cost?3@ ; `string'
PUBLIC	??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@ ; `string'
PUBLIC	__$ArrayPad$
EXTRN	?BuyPlot@CvCity@@QAEXHH@Z:PROC			; CvCity::BuyPlot
EXTRN	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z:PROC ; CvHomelandAI::LogHomelandMessage
EXTRN	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ:PROC ; CvPlayer::GetHomelandAI
EXTRN	?GetBuyPlotCost@CvCity@@QBEHHH@Z:PROC		; CvCity::GetBuyPlotCost
EXTRN	?GetBuyPlotScore@CvCity@@QAEHAAH0@Z:PROC	; CvCity::GetBuyPlotScore
EXTRN	?CanBuyAnyPlot@CvCity@@QAE_NXZ:PROC		; CvCity::CanBuyAnyPlot
EXTRN	?GetBuyPlotCost@CvPlayer@@QBEHXZ:PROC		; CvPlayer::GetBuyPlotCost
EXTRN	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z:PROC ; CvMilitaryAI::IsUsingStrategy
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
;	COMDAT ??_C@_0EM@BLJLBMAN@Buying?5plot?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5Cost?3@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0EM@BLJLBMAN@Buying?5plot?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5Cost?3@ DB 'B'
	DB	'uying plot, X: %d, Y: %d, Cost: %d, Balance (before buy): %d,'
	DB	' Priority: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
CONST	SEGMENT
??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@ DB 'MILITARYAISTRATEGY_A'
	DB	'T_WAR', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoPlotPurchases@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoPlotPurchases@CvEconomicAI@@AAEXXZ$0
__ehfuncinfo$?DoPlotPurchases@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DoPlotPurchases@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?DoPlotPurchases@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -108						; size = 4
_strLogString$226154 = -104				; size = 28
__$ArrayPad$ = -76					; size = 4
_iCost$226151 = -72					; size = 4
_iDiscountPercent$226143 = -68				; size = 4
_iBalance$ = -64					; size = 4
_iTempX$ = -60						; size = 4
_eStrategyAtWar$ = -56					; size = 4
_iCurrentCost$ = -52					; size = 4
_pBestCity$ = -48					; size = 4
_iBestX$ = -44						; size = 4
_iTempY$ = -40						; size = 4
_iBestScore$ = -36					; size = 4
_iGoldForHalfCost$ = -32				; size = 4
_pLoopCity$ = -28					; size = 4
_iBestY$ = -24						; size = 4
_iScore$ = -20						; size = 4
_iLoop$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?DoPlotPurchases@CvEconomicAI@@AAEXXZ PROC		; CvEconomicAI::DoPlotPurchases, COMDAT
; _this$ = ecx

; 1882 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoPlotPurchases@CvEconomicAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1883 : 	CvCity* pLoopCity = 0;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 1884 : 	CvCity* pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[ebp], 0

; 1885 : 	int iBestX = -1;

	mov	DWORD PTR _iBestX$[ebp], -1

; 1886 : 	int iBestY = -1;

	mov	DWORD PTR _iBestY$[ebp], -1

; 1887 : 	int iTempX = 0, iTempY = 0;

	mov	DWORD PTR _iTempX$[ebp], 0
	mov	DWORD PTR _iTempY$[ebp], 0

; 1888 : 
; 1889 : 	int iScore = 0;

	mov	DWORD PTR _iScore$[ebp], 0

; 1890 : 	int iLoop = 0;

	mov	DWORD PTR _iLoop$[ebp], 0

; 1891 : 
; 1892 : 	// No plot buying for minors
; 1893 : 	if(m_pPlayer->isMinorCiv())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@DoPlotPurc

; 1894 : 	{
; 1895 : 		return;

	jmp	$LN14@DoPlotPurc
$LN13@DoPlotPurc:

; 1896 : 	}
; 1897 : 
; 1898 : 	// No plot buying when at war
; 1899 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 1900 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyAtWar$[ebp], -1
	je	SHORT $LN12@DoPlotPurc

; 1901 : 	{
; 1902 : 		if(m_pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	edx, DWORD PTR _eStrategyAtWar$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@DoPlotPurc

; 1903 : 		{
; 1904 : 			return;

	jmp	$LN14@DoPlotPurc
$LN12@DoPlotPurc:

; 1905 : 		}
; 1906 : 	}
; 1907 : 
; 1908 : 	// Set up the parameters
; 1909 : 	int iBestScore = /*150*/ GC.getAI_GOLD_PRIORITY_MINIMUM_PLOT_BUY_VALUE();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2068
	mov	DWORD PTR _iBestScore$[ebp], edx

; 1910 : 	int iCurrentCost = m_pPlayer->GetBuyPlotCost();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetBuyPlotCost@CvPlayer@@QBEHXZ	; CvPlayer::GetBuyPlotCost
	mov	DWORD PTR _iCurrentCost$[ebp], eax

; 1911 : 	int iGoldForHalfCost = /*1000*/ GC.getAI_GOLD_BALANCE_TO_HALVE_PLOT_BUY_MINIMUM();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2072
	mov	DWORD PTR _iGoldForHalfCost$[ebp], ecx

; 1912 : 	int iBalance = m_pPlayer->GetTreasury()->GetGold();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	mov	DWORD PTR _iBalance$[ebp], eax

; 1913 : 
; 1914 : 	// Let's always invest any money we have in plot purchases
; 1915 : 	//  (LATER -- save up money to spend at newly settled cities)
; 1916 : 	if(iCurrentCost < iBalance && iGoldForHalfCost > iCurrentCost)

	mov	eax, DWORD PTR _iCurrentCost$[ebp]
	cmp	eax, DWORD PTR _iBalance$[ebp]
	jge	$LN14@DoPlotPurc
	mov	ecx, DWORD PTR _iGoldForHalfCost$[ebp]
	cmp	ecx, DWORD PTR _iCurrentCost$[ebp]
	jle	$LN14@DoPlotPurc

; 1917 : 	{
; 1918 : 		// Lower our requirements if we're building up a sizable treasury
; 1919 : 		int iDiscountPercent = 50 * (iBalance - iCurrentCost) / (iGoldForHalfCost - iCurrentCost);

	mov	eax, DWORD PTR _iBalance$[ebp]
	sub	eax, DWORD PTR _iCurrentCost$[ebp]
	imul	eax, 50					; 00000032H
	mov	ecx, DWORD PTR _iGoldForHalfCost$[ebp]
	sub	ecx, DWORD PTR _iCurrentCost$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iDiscountPercent$226143[ebp], eax

; 1920 : 		iBestScore = iBestScore - (iBestScore * iDiscountPercent / 100);

	mov	eax, DWORD PTR _iBestScore$[ebp]
	imul	eax, DWORD PTR _iDiscountPercent$226143[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	edx, DWORD PTR _iBestScore$[ebp]
	sub	edx, eax
	mov	DWORD PTR _iBestScore$[ebp], edx

; 1921 : 
; 1922 : 		// Find the best city to buy a plot
; 1923 : 		for(pLoopCity = m_pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN9@DoPlotPurc
$LN8@DoPlotPurc:
	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN9@DoPlotPurc:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN7@DoPlotPurc

; 1924 : 		{
; 1925 : 			if(pLoopCity->CanBuyAnyPlot())

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?CanBuyAnyPlot@CvCity@@QAE_NXZ		; CvCity::CanBuyAnyPlot
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@DoPlotPurc

; 1926 : 			{
; 1927 : 				iScore = pLoopCity->GetBuyPlotScore(iTempX, iTempY);

	lea	edx, DWORD PTR _iTempY$[ebp]
	push	edx
	lea	eax, DWORD PTR _iTempX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetBuyPlotScore@CvCity@@QAEHAAH0@Z	; CvCity::GetBuyPlotScore
	mov	DWORD PTR _iScore$[ebp], eax

; 1928 : 
; 1929 : 				if(iScore > iBestScore)

	mov	ecx, DWORD PTR _iScore$[ebp]
	cmp	ecx, DWORD PTR _iBestScore$[ebp]
	jle	SHORT $LN6@DoPlotPurc

; 1930 : 				{
; 1931 : 					pBestCity = pLoopCity;

	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestCity$[ebp], edx

; 1932 : 					iBestScore = iScore;

	mov	eax, DWORD PTR _iScore$[ebp]
	mov	DWORD PTR _iBestScore$[ebp], eax

; 1933 : 					iBestX = iTempX;

	mov	ecx, DWORD PTR _iTempX$[ebp]
	mov	DWORD PTR _iBestX$[ebp], ecx

; 1934 : 					iBestY = iTempY;

	mov	edx, DWORD PTR _iTempY$[ebp]
	mov	DWORD PTR _iBestY$[ebp], edx
$LN6@DoPlotPurc:

; 1935 : 				}
; 1936 : 			}
; 1937 : 		}

	jmp	SHORT $LN8@DoPlotPurc
$LN7@DoPlotPurc:

; 1938 : 
; 1939 : 		if(pBestCity != NULL)

	cmp	DWORD PTR _pBestCity$[ebp], 0
	je	$LN14@DoPlotPurc

; 1940 : 		{
; 1941 : 			if(iBestX != -1 && iBestY != -1)

	cmp	DWORD PTR _iBestX$[ebp], -1
	je	$LN14@DoPlotPurc
	cmp	DWORD PTR _iBestY$[ebp], -1
	je	$LN14@DoPlotPurc

; 1942 : 			{
; 1943 : 				int iCost = pBestCity->GetBuyPlotCost(iBestX, iBestY);

	mov	eax, DWORD PTR _iBestY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBestX$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pBestCity$[ebp]
	call	?GetBuyPlotCost@CvCity@@QBEHHH@Z	; CvCity::GetBuyPlotCost
	mov	DWORD PTR _iCost$226151[ebp], eax

; 1944 : 
; 1945 : 				if(CanWithdrawMoneyForPurchase(PURCHASE_TYPE_TILE, iCost, iBestScore))

	mov	edx, DWORD PTR _iBestScore$[ebp]
	push	edx
	mov	eax, DWORD PTR _iCost$226151[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanWithdrawMoneyForPurchase@CvEconomicAI@@QAE_NW4PurchaseType@@HH@Z ; CvEconomicAI::CanWithdrawMoneyForPurchase
	movzx	ecx, al
	test	ecx, ecx
	je	$LN14@DoPlotPurc

; 1946 : 				{
; 1947 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@DoPlotPurc
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@DoPlotPurc

; 1948 : 					{
; 1949 : 						CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226154[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1950 : 						strLogString.Format("Buying plot, X: %d, Y: %d, Cost: %d, Balance (before buy): %d, Priority: %d", iBestX, iBestY,
; 1951 : 						                    iCost, m_pPlayer->GetTreasury()->GetGold(), iBestScore);

	mov	ecx, DWORD PTR _iBestScore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?GetGold@CvTreasury@@QBEHXZ		; CvTreasury::GetGold
	push	eax
	mov	eax, DWORD PTR _iCost$226151[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBestY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBestX$[ebp]
	push	edx
	push	OFFSET ??_C@_0EM@BLJLBMAN@Buying?5plot?0?5X?3?5?$CFd?0?5Y?3?5?$CFd?0?5Cost?3@
	lea	eax, DWORD PTR _strLogString$226154[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 1952 : 						m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$226154[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 1953 : 					}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$226154[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@DoPlotPurc:

; 1954 : 					pBestCity->BuyPlot(iBestX, iBestY);

	mov	eax, DWORD PTR _iBestY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iBestX$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pBestCity$[ebp]
	call	?BuyPlot@CvCity@@QAEXHH@Z		; CvCity::BuyPlot
$LN14@DoPlotPurc:

; 1955 : 				}
; 1956 : 			}
; 1957 : 		}
; 1958 : 	}
; 1959 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoPlotPurchases@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$226154[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoPlotPurchases@CvEconomicAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoPlotPurchases@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoPlotPurchases@CvEconomicAI@@AAEXXZ ENDP		; CvEconomicAI::DoPlotPurchases
PUBLIC	??_C@_0ED@DBBKDLBH@Assigning?5naval?5explorer?5back?5to@ ; `string'
PUBLIC	??_C@_0BD@DBIDKOHE@FLAVOR_NAVAL_RECON?$AA@	; `string'
PUBLIC	??_C@_0DH@EFEBOHDI@Assigning?5exploring?5?$CFs?5back?5to?5a@ ; `string'
PUBLIC	??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@		; `string'
PUBLIC	__$ArrayPad$
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?AI_setUnitAIType@CvUnit@@QAEXW4UnitAITypes@@@Z:PROC ; CvUnit::AI_setUnitAIType
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ:PROC	; CvUnit::getUnitInfo
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
;	COMDAT ??_C@_0ED@DBBKDLBH@Assigning?5naval?5explorer?5back?5to@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0ED@DBBKDLBH@Assigning?5naval?5explorer?5back?5to@ DB 'Assigning na'
	DB	'val explorer back to attack sea AI to %s, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBIDKOHE@FLAVOR_NAVAL_RECON?$AA@
CONST	SEGMENT
??_C@_0BD@DBIDKOHE@FLAVOR_NAVAL_RECON?$AA@ DB 'FLAVOR_NAVAL_RECON', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EFEBOHDI@Assigning?5exploring?5?$CFs?5back?5to?5a@
CONST	SEGMENT
??_C@_0DH@EFEBOHDI@Assigning?5exploring?5?$CFs?5back?5to?5a@ DB 'Assignin'
	DB	'g exploring %s back to attack AI, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@
CONST	SEGMENT
??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@ DB 'FLAVOR_RECON', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DoReconState@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$3
__ehfuncinfo$?DoReconState@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?DoReconState@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?DoReconState@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
tv480 = -412						; size = 4
tv517 = -408						; size = 4
_this$ = -404						; size = 4
$T235559 = -400						; size = 4
$T235555 = -396						; size = 4
$T235546 = -392						; size = 4
$T235533 = -388						; size = 4
$T235529 = -384						; size = 4
$T235514 = -380						; size = 4
$T235510 = -376						; size = 4
$T235501 = -372						; size = 4
$T235488 = -368						; size = 4
$T235484 = -364						; size = 4
$T235480 = -360						; size = 4
_uiOffset$235472 = -356					; size = 4
$T235463 = -352						; size = 4
$T235462 = -348						; size = 4
_uiOffset$235452 = -344					; size = 4
$T235443 = -340						; size = 4
$T235442 = -336						; size = 4
$T235290 = -260						; size = 4
$T235286 = -256						; size = 4
_uiOffset$235278 = -252					; size = 4
$T235269 = -248						; size = 4
$T235268 = -244						; size = 4
$T235256 = -240						; size = 4
$T235252 = -236						; size = 4
$T235248 = -232						; size = 4
$T235244 = -228						; size = 4
$T235240 = -224						; size = 4
$T235239 = -220						; size = 4
$T235226 = -216						; size = 28
$T235225 = -188						; size = 28
_strLogString$226241 = -160				; size = 28
_bSkipFirst$226233 = -129				; size = 1
_strLogString$226212 = -128				; size = 28
__$ArrayPad$ = -100					; size = 4
_bSkipFirst$226204 = -93				; size = 1
_iStrategyWeight$ = -92					; size = 4
_bNeedToLookAtDeepWaterAlso$ = -85			; size = 1
_pPlot$ = -84						; size = 4
_bIsLand$ = -77						; size = 1
_iCityLoop$ = -76					; size = 4
_iNumCoastalTilesWithAdjacentFog$ = -72			; size = 4
_iPlotLoop$ = -68					; size = 4
_bIsCoastalWater$ = -61					; size = 1
_iDirectionLoop$ = -60					; size = 4
_pLoopUnit$ = -56					; size = 4
_iNumLandPlotsRevealed$ = -52				; size = 4
_iNumLandPlotsWithAdjacentFog$ = -48			; size = 4
_iUnitLoop$ = -44					; size = 4
_bFoundCoastalCity$ = -37				; size = 1
_iNumCoastalTilesRevealed$ = -36			; size = 4
_pAdjacentPlot$ = -32					; size = 4
_iNumExploringUnits$ = -28				; size = 4
_pLoopCity$ = -24					; size = 4
_iWeightThreshold$ = -20				; size = 4
_iNumExplorerDivisor$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?DoReconState@CvEconomicAI@@AAEXXZ PROC			; CvEconomicAI::DoReconState, COMDAT
; _this$ = ecx

; 1964 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DoReconState@CvEconomicAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 400				; 00000190H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1965 : #ifdef AUI_WARNING_FIXES
; 1966 : 	uint iPlotLoop;
; 1967 : 	int iDirectionLoop, iUnitLoop;
; 1968 : #else
; 1969 : 	int iPlotLoop, iDirectionLoop, iUnitLoop;
; 1970 : #endif
; 1971 : 	CvPlot* pPlot;
; 1972 : 	CvPlot* pAdjacentPlot;
; 1973 : 	CvUnit* pLoopUnit;
; 1974 : 	bool bIsLand;
; 1975 : 	bool bIsCoastalWater;
; 1976 : 
; 1977 : 	if(GetPlayer()->isMinorCiv())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN48@DoReconSta

; 1978 : 	{
; 1979 : 		m_eReconState = RECON_STATE_ENOUGH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 1980 : 		m_eNavalReconState = RECON_STATE_ENOUGH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 1981 : 		return;

	jmp	$LN49@DoReconSta
$LN48@DoReconSta:

; 1982 : 	}
; 1983 : 
; 1984 : 	// Start at 1 so we don't get divide-by-0 errors
; 1985 : 	//   Land recon counters
; 1986 : 	int iNumLandPlotsRevealed = 1;

	mov	DWORD PTR _iNumLandPlotsRevealed$[ebp], 1

; 1987 : 	int iNumLandPlotsWithAdjacentFog = 1;

	mov	DWORD PTR _iNumLandPlotsWithAdjacentFog$[ebp], 1

; 1988 : 
; 1989 : 	//   Naval recon counters
; 1990 : 	int iNumCoastalTilesRevealed = 1;

	mov	DWORD PTR _iNumCoastalTilesRevealed$[ebp], 1

; 1991 : 	int iNumCoastalTilesWithAdjacentFog = 1;

	mov	DWORD PTR _iNumCoastalTilesWithAdjacentFog$[ebp], 1

; 1992 : 
; 1993 : 	bool bNeedToLookAtDeepWaterAlso = GET_TEAM(m_pPlayer->getTeam()).canEmbarkAllWaterPassage();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235239[ebp], ecx
	mov	edx, DWORD PTR $T235239[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235240[ebp], eax
	mov	ecx, DWORD PTR $T235240[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T235244[ebp], ecx
	mov	ecx, DWORD PTR $T235244[ebp]
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	mov	BYTE PTR _bNeedToLookAtDeepWaterAlso$[ebp], al

; 1994 : 
; 1995 : 	// Look at map size and gauge how much of it we know about
; 1996 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$[ebp], 0
	jmp	SHORT $LN47@DoReconSta
$LN46@DoReconSta:
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotLoop$[ebp], edx
$LN47@DoReconSta:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235248[ebp], eax
	mov	ecx, DWORD PTR $T235248[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T235252[ebp], edx
	mov	eax, DWORD PTR _iPlotLoop$[ebp]
	cmp	eax, DWORD PTR $T235252[ebp]
	jge	$LN45@DoReconSta

; 1997 : 	{
; 1998 : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235256[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T235256[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pPlot$[ebp], edx

; 1999 : 
; 2000 : 		if(pPlot->isRevealed(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235268[ebp], edx
	mov	eax, DWORD PTR $T235268[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235269[ebp], eax
	mov	edx, DWORD PTR $T235269[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$235278[ebp], edx
	mov	eax, DWORD PTR _uiOffset$235278[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T235269[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$235278[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN37@DoReconSta

; 2001 : 		{
; 2002 : 			bIsLand = false;

	mov	BYTE PTR _bIsLand$[ebp], 0

; 2003 : 			bIsCoastalWater = false;

	mov	BYTE PTR _bIsCoastalWater$[ebp], 0

; 2004 : 
; 2005 : 			// Count Revealed Land Plots
; 2006 : 			if(!pPlot->isWater())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN43@DoReconSta

; 2007 : 			{
; 2008 : 				bIsLand = true;

	mov	BYTE PTR _bIsLand$[ebp], 1

; 2009 : 				iNumLandPlotsRevealed++;

	mov	edx, DWORD PTR _iNumLandPlotsRevealed$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumLandPlotsRevealed$[ebp], edx
	jmp	SHORT $LN41@DoReconSta
$LN43@DoReconSta:

; 2010 : 			}
; 2011 : 			else if(pPlot->isShallowWater() || bNeedToLookAtDeepWaterAlso)

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN40@DoReconSta
	movzx	ecx, BYTE PTR _bNeedToLookAtDeepWaterAlso$[ebp]
	test	ecx, ecx
	je	SHORT $LN41@DoReconSta
$LN40@DoReconSta:

; 2012 : 			{
; 2013 : 				bIsCoastalWater = true;

	mov	BYTE PTR _bIsCoastalWater$[ebp], 1

; 2014 : 				iNumCoastalTilesRevealed++;

	mov	edx, DWORD PTR _iNumCoastalTilesRevealed$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumCoastalTilesRevealed$[ebp], edx
$LN41@DoReconSta:

; 2015 : 			}
; 2016 : 
; 2017 : 			// Check adjacent Plots for THEIR visibility
; 2018 : 			for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$[ebp], 0
	jmp	SHORT $LN39@DoReconSta
$LN38@DoReconSta:
	mov	eax, DWORD PTR _iDirectionLoop$[ebp]
	add	eax, 1
	mov	DWORD PTR _iDirectionLoop$[ebp], eax
$LN39@DoReconSta:
	cmp	DWORD PTR _iDirectionLoop$[ebp], 6
	jge	$LN37@DoReconSta

; 2019 : 			{
; 2020 : 				pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

	mov	ecx, DWORD PTR _pPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T235286[ebp], edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T235290[ebp], ecx
	mov	edx, DWORD PTR _iDirectionLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR $T235286[ebp]
	push	eax
	mov	ecx, DWORD PTR $T235290[ebp]
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$[ebp], eax

; 2021 : 
; 2022 : 				if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$[ebp], 0
	je	$LN31@DoReconSta

; 2023 : 				{
; 2024 : 					// Check to see if adjacent Tile is land or water...
; 2025 : 					if(pAdjacentPlot->isWater())

	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	$LN35@DoReconSta

; 2026 : 					{
; 2027 : 						// This is a slight cheat (because the AI rules out water tiles) but helps prevents the AI from building too many Land explorers
; 2028 : 						if((bNeedToLookAtDeepWaterAlso || pAdjacentPlot->isShallowWater()) && !pAdjacentPlot->isRevealed(m_pPlayer->getTeam()))

	movzx	eax, BYTE PTR _bNeedToLookAtDeepWaterAlso$[ebp]
	test	eax, eax
	jne	SHORT $LN33@DoReconSta
	mov	ecx, DWORD PTR _pAdjacentPlot$[ebp]
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN34@DoReconSta
$LN33@DoReconSta:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T235442[ebp], eax
	mov	ecx, DWORD PTR $T235442[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235443[ebp], eax
	mov	eax, DWORD PTR $T235443[ebp]
	shr	eax, 5
	mov	DWORD PTR _uiOffset$235452[ebp], eax
	mov	ecx, DWORD PTR _uiOffset$235452[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR $T235443[ebp]
	sub	edx, ecx
	mov	eax, 1
	mov	ecx, edx
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$235452[ebp]
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN34@DoReconSta

; 2029 : 						{
; 2030 : 							iNumCoastalTilesWithAdjacentFog++;

	mov	edx, DWORD PTR _iNumCoastalTilesWithAdjacentFog$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumCoastalTilesWithAdjacentFog$[ebp], edx

; 2031 : 							break;

	jmp	SHORT $LN37@DoReconSta
$LN34@DoReconSta:

; 2032 : 						}
; 2033 : 					}
; 2034 : 					else

	jmp	SHORT $LN31@DoReconSta
$LN35@DoReconSta:

; 2035 : 					{
; 2036 : 						// This is a slight cheat (because the AI rules out water tiles) but helps prevents the AI from building too many Land explorers
; 2037 : 						if(!pAdjacentPlot->isRevealed(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235462[ebp], ecx
	mov	edx, DWORD PTR $T235462[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235463[ebp], eax
	mov	ecx, DWORD PTR $T235463[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$235472[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$235472[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T235463[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$235472[ebp]
	mov	edx, DWORD PTR _pAdjacentPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN31@DoReconSta

; 2038 : 						{
; 2039 : 							iNumLandPlotsWithAdjacentFog++;

	mov	edx, DWORD PTR _iNumLandPlotsWithAdjacentFog$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumLandPlotsWithAdjacentFog$[ebp], edx

; 2040 : 							break;

	jmp	SHORT $LN37@DoReconSta
$LN31@DoReconSta:

; 2041 : 						}
; 2042 : 					}
; 2043 : 				}
; 2044 : 			}

	jmp	$LN38@DoReconSta
$LN37@DoReconSta:

; 2045 : 		}
; 2046 : 	}

	jmp	$LN46@DoReconSta
$LN45@DoReconSta:

; 2047 : 
; 2048 : 	// RECON ON OUR HOME CONTINENT
; 2049 : 
; 2050 : 	// How many Units do we have exploring or being trained to do this job? The more Units we have the less we want this Strategy
; 2051 : 	int iNumExploringUnits = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_EXPLORE, true, false) + m_iExplorersDisbanded;

	push	0
	push	1
	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _iNumExploringUnits$[ebp], eax

; 2052 : 	int iStrategyWeight = /*100*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1996
	mov	DWORD PTR _iStrategyWeight$[ebp], edx

; 2053 : 	int iWeightThreshold = 110;  // So result is a number from 10 to 100

	mov	DWORD PTR _iWeightThreshold$[ebp], 110	; 0000006eH

; 2054 : 	iWeightThreshold -= m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_RECON")) *
; 2055 : 	                    /*10*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2004
	mov	DWORD PTR $T235480[ebp], eax
	push	0
	push	OFFSET ??_C@_0N@PFDLLNAJ@FLAVOR_RECON?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	imul	eax, DWORD PTR $T235480[ebp]
	mov	edx, DWORD PTR _iWeightThreshold$[ebp]
	sub	edx, eax
	mov	DWORD PTR _iWeightThreshold$[ebp], edx

; 2056 : 
; 2057 : 	// Safety check even if personality flavor is higher than expected
; 2058 : 	if(iWeightThreshold > 100)

	cmp	DWORD PTR _iWeightThreshold$[ebp], 100	; 00000064H
	jle	SHORT $LN30@DoReconSta

; 2059 : 	{
; 2060 : 		iWeightThreshold = 100;

	mov	DWORD PTR _iWeightThreshold$[ebp], 100	; 00000064H
$LN30@DoReconSta:

; 2061 : 	}
; 2062 : 
; 2063 : 	iStrategyWeight *= iNumLandPlotsWithAdjacentFog;

	mov	eax, DWORD PTR _iStrategyWeight$[ebp]
	imul	eax, DWORD PTR _iNumLandPlotsWithAdjacentFog$[ebp]
	mov	DWORD PTR _iStrategyWeight$[ebp], eax

; 2064 : 	int iNumExplorerDivisor = iNumExploringUnits + /*1*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2000
	mov	DWORD PTR $T235484[ebp], ecx
	mov	edx, DWORD PTR _iNumExploringUnits$[ebp]
	add	edx, DWORD PTR $T235484[ebp]
	mov	DWORD PTR _iNumExplorerDivisor$[ebp], edx

; 2065 : 	iStrategyWeight /= (iNumExplorerDivisor * iNumExplorerDivisor);

	mov	ecx, DWORD PTR _iNumExplorerDivisor$[ebp]
	imul	ecx, DWORD PTR _iNumExplorerDivisor$[ebp]
	mov	eax, DWORD PTR _iStrategyWeight$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iStrategyWeight$[ebp], eax

; 2066 : 	iStrategyWeight /= (int)sqrt((double)iNumLandPlotsRevealed);

	cvtsi2sd xmm0, DWORD PTR _iNumLandPlotsRevealed$[ebp]
	sqrtsd	xmm0, xmm0
	cvttsd2si ecx, xmm0
	mov	eax, DWORD PTR _iStrategyWeight$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iStrategyWeight$[ebp], eax

; 2067 : 
; 2068 : 	if(iStrategyWeight > iWeightThreshold)

	mov	edx, DWORD PTR _iStrategyWeight$[ebp]
	cmp	edx, DWORD PTR _iWeightThreshold$[ebp]
	jle	SHORT $LN29@DoReconSta

; 2069 : 	{
; 2070 : 		m_eReconState = RECON_STATE_NEEDED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 2

; 2071 : 	}
; 2072 : 	else

	jmp	$LN23@DoReconSta
$LN29@DoReconSta:

; 2073 : 	{
; 2074 : 		if(iStrategyWeight > (iWeightThreshold / 4))

	mov	eax, DWORD PTR _iWeightThreshold$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	DWORD PTR _iStrategyWeight$[ebp], eax
	jle	SHORT $LN27@DoReconSta

; 2075 : 		{
; 2076 : 			m_eReconState = RECON_STATE_NEUTRAL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 1

; 2077 : 		}
; 2078 : 		else

	jmp	$LN23@DoReconSta
$LN27@DoReconSta:

; 2079 : 		{
; 2080 : 			m_eReconState = RECON_STATE_ENOUGH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 2081 : 
; 2082 : 			// Return all/most warriors/spears to normal unit AI since have enough recon.  Keep at least 1 explorer through Turn 100.
; 2083 : 			bool bSkipFirst = GC.getGame().getGameTurn() < 100;

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235488[ebp], eax
	mov	ecx, DWORD PTR $T235488[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	xor	ecx, ecx
	cmp	eax, 100				; 00000064H
	setl	cl
	mov	BYTE PTR _bSkipFirst$226204[ebp], cl

; 2084 : 			for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN25@DoReconSta
$LN24@DoReconSta:
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN25@DoReconSta:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN23@DoReconSta

; 2085 : 			{
; 2086 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE && pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_ATTACK))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	jne	$LN19@DoReconSta
	push	3
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	je	$LN19@DoReconSta

; 2087 : 				{
; 2088 : 					if(bSkipFirst)

	movzx	ecx, BYTE PTR _bSkipFirst$226204[ebp]
	test	ecx, ecx
	je	SHORT $LN21@DoReconSta

; 2089 : 					{
; 2090 : 						bSkipFirst = false;

	mov	BYTE PTR _bSkipFirst$226204[ebp], 0

; 2091 : 					}
; 2092 : 					else

	jmp	$LN19@DoReconSta
$LN21@DoReconSta:

; 2093 : 					{
; 2094 : 						pLoopUnit->AI_setUnitAIType(UNITAI_ATTACK);

	push	3
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_setUnitAIType@CvUnit@@QAEXW4UnitAITypes@@@Z ; CvUnit::AI_setUnitAIType

; 2095 : 						if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN19@DoReconSta
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN19@DoReconSta

; 2096 : 						{
; 2097 : 							CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226212[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2098 : 							strLogString.Format("Assigning exploring %s back to attack AI, X: %d, Y: %d", pLoopUnit->getName().GetCString(), pLoopUnit->getX(), pLoopUnit->getY());

	lea	ecx, DWORD PTR $T235225[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv517[ebp], eax
	mov	edx, DWORD PTR tv517[ebp]
	mov	DWORD PTR $T235514[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T235501[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T235510[ebp], eax
	mov	ecx, DWORD PTR $T235501[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235510[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235514[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0DH@EFEBOHDI@Assigning?5exploring?5?$CFs?5back?5to?5a@
	lea	eax, DWORD PTR _strLogString$226212[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T235225[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2099 : 							m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$226212[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2100 : 						}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$226212[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN19@DoReconSta:

; 2101 : 					}
; 2102 : 				}
; 2103 : 			}

	jmp	$LN24@DoReconSta
$LN23@DoReconSta:

; 2104 : 		}
; 2105 : 	}
; 2106 : 
; 2107 : 	// NAVAL RECON ACROSS THE ENTIRE MAP
; 2108 : 
; 2109 : 	// No coastal cities?  Moot point...
; 2110 : 	CvCity* pLoopCity;
; 2111 : 	int iCityLoop;
; 2112 : 	bool bFoundCoastalCity = false;

	mov	BYTE PTR _bFoundCoastalCity$[ebp], 0

; 2113 : 	for(pLoopCity = m_pPlayer->firstCity(&iCityLoop); pLoopCity != NULL && !bFoundCoastalCity; pLoopCity = m_pPlayer->nextCity(&iCityLoop))

	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN18@DoReconSta
$LN17@DoReconSta:
	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN18@DoReconSta:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN16@DoReconSta
	movzx	ecx, BYTE PTR _bFoundCoastalCity$[ebp]
	test	ecx, ecx
	jne	SHORT $LN16@DoReconSta

; 2114 : 	{
; 2115 : 		if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@DoReconSta

; 2116 : 		{
; 2117 : 			bFoundCoastalCity = true;

	mov	BYTE PTR _bFoundCoastalCity$[ebp], 1
$LN15@DoReconSta:

; 2118 : 		}
; 2119 : 	}

	jmp	SHORT $LN17@DoReconSta
$LN16@DoReconSta:

; 2120 : 
; 2121 : 	if(!bFoundCoastalCity)

	movzx	eax, BYTE PTR _bFoundCoastalCity$[ebp]
	test	eax, eax
	jne	SHORT $LN14@DoReconSta

; 2122 : 	{
; 2123 : 		m_eNavalReconState = RECON_STATE_ENOUGH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 2124 : 	}
; 2125 : 
; 2126 : 	else

	jmp	$LN5@DoReconSta
$LN14@DoReconSta:

; 2127 : 	{
; 2128 : 		// How many Units do we have exploring or being trained to do this job? The more Units we have the less we want this Strategy
; 2129 : 		iNumExploringUnits = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_EXPLORE_SEA, true, true);

	push	1
	push	1
	push	21					; 00000015H
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumExploringUnits$[ebp], eax

; 2130 : 		iStrategyWeight = /*100*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_STARTING_WEIGHT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1996
	mov	DWORD PTR _iStrategyWeight$[ebp], eax

; 2131 : 		iWeightThreshold = 110;  // So result is a number from 10 to 100

	mov	DWORD PTR _iWeightThreshold$[ebp], 110	; 0000006eH

; 2132 : 		iWeightThreshold -= m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_NAVAL_RECON")) *
; 2133 : 		                    /*10*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_WEIGHT_PER_FLAVOR();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2004
	mov	DWORD PTR $T235529[ebp], ecx
	push	0
	push	OFFSET ??_C@_0BD@DBIDKOHE@FLAVOR_NAVAL_RECON?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	imul	eax, DWORD PTR $T235529[ebp]
	mov	ecx, DWORD PTR _iWeightThreshold$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _iWeightThreshold$[ebp], ecx

; 2134 : 
; 2135 : 		// Safety check even if personality flavor is higher than expected
; 2136 : 		if(iWeightThreshold > 100)

	cmp	DWORD PTR _iWeightThreshold$[ebp], 100	; 00000064H
	jle	SHORT $LN12@DoReconSta

; 2137 : 		{
; 2138 : 			iWeightThreshold = 100;

	mov	DWORD PTR _iWeightThreshold$[ebp], 100	; 00000064H
$LN12@DoReconSta:

; 2139 : 		}
; 2140 : 
; 2141 : 		iStrategyWeight *= iNumCoastalTilesWithAdjacentFog;

	mov	edx, DWORD PTR _iStrategyWeight$[ebp]
	imul	edx, DWORD PTR _iNumCoastalTilesWithAdjacentFog$[ebp]
	mov	DWORD PTR _iStrategyWeight$[ebp], edx

; 2142 : 		iNumExplorerDivisor = iNumExploringUnits + /*1*/ GC.getAI_STRATEGY_EARLY_EXPLORATION_EXPLORERS_WEIGHT_DIVISOR();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2000
	mov	DWORD PTR $T235533[ebp], eax
	mov	ecx, DWORD PTR _iNumExploringUnits$[ebp]
	add	ecx, DWORD PTR $T235533[ebp]
	mov	DWORD PTR _iNumExplorerDivisor$[ebp], ecx

; 2143 : 		iStrategyWeight /= (iNumExplorerDivisor * iNumExplorerDivisor);

	mov	ecx, DWORD PTR _iNumExplorerDivisor$[ebp]
	imul	ecx, DWORD PTR _iNumExplorerDivisor$[ebp]
	mov	eax, DWORD PTR _iStrategyWeight$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iStrategyWeight$[ebp], eax

; 2144 : 		iStrategyWeight /= (int)sqrt((double)iNumCoastalTilesRevealed);

	cvtsi2sd xmm0, DWORD PTR _iNumCoastalTilesRevealed$[ebp]
	sqrtsd	xmm0, xmm0
	cvttsd2si ecx, xmm0
	mov	eax, DWORD PTR _iStrategyWeight$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iStrategyWeight$[ebp], eax

; 2145 : 
; 2146 : 		if(iStrategyWeight > iWeightThreshold/* || iNumExploringUnits == 0 && iNumCoastalTilesWithAdjacentFog > 50*/)

	mov	edx, DWORD PTR _iStrategyWeight$[ebp]
	cmp	edx, DWORD PTR _iWeightThreshold$[ebp]
	jle	SHORT $LN11@DoReconSta

; 2147 : 		{
; 2148 : 			m_eNavalReconState = RECON_STATE_NEEDED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 2

; 2149 : 		}
; 2150 : 		else

	jmp	$LN5@DoReconSta
$LN11@DoReconSta:

; 2151 : 		{
; 2152 : 			if(iStrategyWeight > (iWeightThreshold / 4))

	mov	eax, DWORD PTR _iWeightThreshold$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	cmp	DWORD PTR _iStrategyWeight$[ebp], eax
	jle	SHORT $LN9@DoReconSta

; 2153 : 			{
; 2154 : 				m_eNavalReconState = RECON_STATE_NEUTRAL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 1

; 2155 : 			}
; 2156 : 			else

	jmp	$LN5@DoReconSta
$LN9@DoReconSta:

; 2157 : 			{
; 2158 : 				m_eNavalReconState = RECON_STATE_ENOUGH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 2159 : 
; 2160 : 				// Return all/most boats to normal unit AI since have enough recon
; 2161 : 				bool bSkipFirst = (m_eNavalReconState == RECON_STATE_NEUTRAL);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+32], 1
	sete	cl
	mov	BYTE PTR _bSkipFirst$226233[ebp], cl

; 2162 : 				for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN7@DoReconSta
$LN6@DoReconSta:
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN7@DoReconSta:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	$LN5@DoReconSta

; 2163 : 				{
; 2164 : 					if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA && pLoopUnit->getUnitInfo().GetUnitAIType(UNITAI_ATTACK_SEA))

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	$LN1@DoReconSta
	push	18					; 00000012H
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitInfo@CvUnit@@QBEAAVCvUnitEntry@@XZ ; CvUnit::getUnitInfo
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	movzx	eax, al
	test	eax, eax
	je	$LN1@DoReconSta

; 2165 : 					{
; 2166 : 						if(bSkipFirst)

	movzx	ecx, BYTE PTR _bSkipFirst$226233[ebp]
	test	ecx, ecx
	je	SHORT $LN3@DoReconSta

; 2167 : 						{
; 2168 : 							bSkipFirst = false;

	mov	BYTE PTR _bSkipFirst$226233[ebp], 0

; 2169 : 						}
; 2170 : 						else

	jmp	$LN1@DoReconSta
$LN3@DoReconSta:

; 2171 : 						{
; 2172 : 							pLoopUnit->AI_setUnitAIType(UNITAI_ATTACK_SEA);

	push	18					; 00000012H
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_setUnitAIType@CvUnit@@QAEXW4UnitAITypes@@@Z ; CvUnit::AI_setUnitAIType

; 2173 : 							if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	edx, al
	test	edx, edx
	je	$LN1@DoReconSta
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	eax, al
	test	eax, eax
	je	$LN1@DoReconSta

; 2174 : 							{
; 2175 : 								CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$226241[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 2176 : 								strLogString.Format("Assigning naval explorer back to attack sea AI to %s, X: %d, Y: %d", pLoopUnit->getName().GetCString(), pLoopUnit->getX(), pLoopUnit->getY());

	lea	ecx, DWORD PTR $T235226[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv480[ebp], eax
	mov	edx, DWORD PTR tv480[ebp]
	mov	DWORD PTR $T235559[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T235546[ebp], ecx
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR $T235555[ebp], eax
	mov	ecx, DWORD PTR $T235546[ebp]
	push	ecx
	mov	edx, DWORD PTR $T235555[ebp]
	push	edx
	mov	ecx, DWORD PTR $T235559[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0ED@DBBKDLBH@Assigning?5naval?5explorer?5back?5to@
	lea	eax, DWORD PTR _strLogString$226241[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T235226[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2177 : 								m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	lea	ecx, DWORD PTR _strLogString$226241[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2178 : 							}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strLogString$226241[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@DoReconSta:

; 2179 : 						}
; 2180 : 					}
; 2181 : 				}

	jmp	$LN6@DoReconSta
$LN5@DoReconSta:
$LN49@DoReconSta:

; 2182 : 			}
; 2183 : 		}
; 2184 : 	}
; 2185 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _strLogString$226212[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR $T235225[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _strLogString$226241[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?DoReconState@CvEconomicAI@@AAEXXZ$3:
	lea	ecx, DWORD PTR $T235226[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?DoReconState@CvEconomicAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-404]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?DoReconState@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DoReconState@CvEconomicAI@@AAEXXZ ENDP			; CvEconomicAI::DoReconState
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
; Function compile flags: /Odtp
;	COMDAT ?DoAntiquitySites@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T235636 = -60						; size = 4
$T235635 = -56						; size = 4
$T235626 = -52						; size = 4
$T235625 = -48						; size = 4
_uiOffset$235615 = -44					; size = 4
$T235606 = -40						; size = 4
$T235605 = -36						; size = 4
$T235593 = -32						; size = 4
$T235589 = -28						; size = 4
$T235585 = -24						; size = 4
_pPlot$ = -20						; size = 4
_iPlotLoop$ = -16					; size = 4
_eArtifactResourceType$ = -12				; size = 4
_eHiddenArtifactResourceType$ = -8			; size = 4
_iNumSites$ = -4					; size = 4
?DoAntiquitySites@CvEconomicAI@@AAEXXZ PROC		; CvEconomicAI::DoAntiquitySites, COMDAT
; _this$ = ecx

; 2189 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 2190 : 	int iNumSites = 0;

	mov	DWORD PTR _iNumSites$[ebp], 0

; 2191 : #ifdef AUI_WARNING_FIXES
; 2192 : 	uint iPlotLoop;
; 2193 : #else
; 2194 : 	int iPlotLoop;
; 2195 : #endif
; 2196 : 	CvPlot *pPlot;
; 2197 : 	ResourceTypes eArtifactResourceType = static_cast<ResourceTypes>(GC.getARTIFACT_RESOURCE());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8408
	mov	DWORD PTR _eArtifactResourceType$[ebp], eax

; 2198 : 	ResourceTypes eHiddenArtifactResourceType = static_cast<ResourceTypes>(GC.getHIDDEN_ARTIFACT_RESOURCE());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8412
	mov	DWORD PTR _eHiddenArtifactResourceType$[ebp], ecx

; 2199 : 
; 2200 : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	DWORD PTR _iPlotLoop$[ebp], 0
	jmp	SHORT $LN6@DoAntiquit
$LN5@DoAntiquit:
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotLoop$[ebp], edx
$LN6@DoAntiquit:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235585[ebp], eax
	mov	ecx, DWORD PTR $T235585[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T235589[ebp], edx
	mov	eax, DWORD PTR _iPlotLoop$[ebp]
	cmp	eax, DWORD PTR $T235589[ebp]
	jge	$LN4@DoAntiquit

; 2201 : 	{
; 2202 : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235593[ebp], ecx
	mov	edx, DWORD PTR _iPlotLoop$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T235593[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pPlot$[ebp], edx

; 2203 : 		if(pPlot->isRevealed(m_pPlayer->getTeam()))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235605[ebp], edx
	mov	eax, DWORD PTR $T235605[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235606[ebp], eax
	mov	edx, DWORD PTR $T235606[ebp]
	shr	edx, 5
	mov	DWORD PTR _uiOffset$235615[ebp], edx
	mov	eax, DWORD PTR _uiOffset$235615[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR $T235606[ebp]
	sub	ecx, eax
	mov	edx, 1
	shl	edx, cl
	mov	eax, DWORD PTR _uiOffset$235615[ebp]
	mov	ecx, DWORD PTR _pPlot$[ebp]
	and	edx, DWORD PTR [ecx+eax*4+8]
	setne	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN3@DoAntiquit

; 2204 : 		{
; 2205 : 			if (pPlot->getResourceType(m_pPlayer->getTeam()) == eArtifactResourceType ||
; 2206 : 				pPlot->getResourceType(m_pPlayer->getTeam()) == eHiddenArtifactResourceType)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235625[ebp], edx
	mov	eax, DWORD PTR $T235625[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235626[ebp], eax
	mov	edx, DWORD PTR $T235626[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, DWORD PTR _eArtifactResourceType$[ebp]
	je	SHORT $LN1@DoAntiquit
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T235635[ebp], ecx
	mov	edx, DWORD PTR $T235635[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T235636[ebp], eax
	mov	ecx, DWORD PTR $T235636[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, DWORD PTR _eHiddenArtifactResourceType$[ebp]
	jne	SHORT $LN3@DoAntiquit
$LN1@DoAntiquit:

; 2207 : 			{
; 2208 : 				iNumSites++;

	mov	edx, DWORD PTR _iNumSites$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumSites$[ebp], edx
$LN3@DoAntiquit:

; 2209 : 			}
; 2210 : 		}
; 2211 : 	}

	jmp	$LN5@DoAntiquit
$LN4@DoAntiquit:

; 2212 : 
; 2213 : 	m_iVisibleAntiquitySites = iNumSites;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iNumSites$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 2214 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoAntiquitySites@CvEconomicAI@@AAEXXZ ENDP		; CvEconomicAI::DoAntiquitySites
_TEXT	ENDS
PUBLIC	?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ; CvEconomicAI::LogScrapUnit
PUBLIC	?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindWorkerToScrap
PUBLIC	__real@3fe5555555555555
PUBLIC	__real@3fd0000000000000
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
EXTRN	?scrap@CvUnit@@QAEXXZ:PROC			; CvUnit::scrap
EXTRN	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ:PROC	; CvCity::IsRouteToCapitalConnected
EXTRN	?area@CvCity@@QBEPAVCvArea@@XZ:PROC		; CvCity::area
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
EXTRN	?getNumUnits@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumUnits
EXTRN	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ:PROC ; CvPlayer::GetEconomicAI
;	COMDAT __real@3fe5555555555555
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
__real@3fe5555555555555 DQ 03fe5555555555555r	; 0.666667
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
tv262 = -172						; size = 4
tv269 = -168						; size = 4
tv77 = -164						; size = 4
_this$ = -160						; size = 4
$T235712 = -156						; size = 4
$T235702 = -152						; size = 4
$T235684 = -144						; size = 4
$T235677 = -140						; size = 4
$T235670 = -136						; size = 4
$T235666 = -132						; size = 4
$T235659 = -128						; size = 4
$T235652 = -124						; size = 4
$T235646 = -120						; size = 4
$T235641 = -116						; size = 4
$T235640 = -112						; size = 4
$T235639 = -108						; size = 4
_pPlot$226286 = -104					; size = 4
_ui$226281 = -100					; size = 4
_pCapital$ = -96					; size = 4
_pUnit$ = -92						; size = 4
_aiPlots$ = -88						; size = 4
_bInDeficit$ = -81					; size = 1
_iNumWorkers$ = -80					; size = 4
_iNumCities$ = -76					; size = 4
_fCurrentRatio$ = -72					; size = 8
_iNumUnimprovedPlots$ = -64				; size = 4
_pCity$ = -60						; size = 4
_fRatio$ = -56						; size = 8
_eStrategyLosingMoney$ = -44				; size = 4
_fWorstCaseRatio$ = -40					; size = 8
_iNumValidPlots$ = -28					; size = 4
_iWorkersPerUnimprovedPlot$ = -24			; size = 4
_iGoldSpentOnUnits$ = -20				; size = 4
_iNumImprovedPlots$ = -16				; size = 4
_iAverageGoldPerUnit$ = -12				; size = 4
_iMinWorkers$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ PROC		; CvEconomicAI::DisbandExtraWorkers, COMDAT
; _this$ = ecx

; 2217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 2218 : 	// Are we running at a deficit?
; 2219 : 	EconomicAIStrategyTypes eStrategyLosingMoney = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_LOSING_MONEY");

	push	0
	push	OFFSET ??_C@_0CA@OBBOJGK@ECONOMICAISTRATEGY_LOSING_MONEY?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyLosingMoney$[ebp], eax

; 2220 : 	bool bInDeficit = m_pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyLosingMoney);

	mov	eax, DWORD PTR _eStrategyLosingMoney$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	mov	BYTE PTR _bInDeficit$[ebp], al

; 2221 : 
; 2222 : 	int iGoldSpentOnUnits = m_pPlayer->GetTreasury()->GetExpensePerTurnUnitMaintenance();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	DWORD PTR $T235646[ebp], eax
	mov	eax, DWORD PTR $T235646[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _iGoldSpentOnUnits$[ebp], ecx

; 2223 : 	int iAverageGoldPerUnit = iGoldSpentOnUnits / (max(1,m_pPlayer->getNumUnits()));

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?getNumUnits@CvPlayer@@QBEHXZ		; CvPlayer::getNumUnits
	mov	DWORD PTR $T235639[ebp], eax
	mov	DWORD PTR $T235640[ebp], 1
	mov	eax, DWORD PTR $T235640[ebp]
	cmp	eax, DWORD PTR $T235639[ebp]
	jge	SHORT $LN30@DisbandExt
	lea	ecx, DWORD PTR $T235639[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN31@DisbandExt
$LN30@DisbandExt:
	lea	edx, DWORD PTR $T235640[ebp]
	mov	DWORD PTR tv77[ebp], edx
$LN31@DisbandExt:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR $T235652[ebp], eax
	mov	ecx, DWORD PTR $T235652[ebp]
	mov	eax, DWORD PTR _iGoldSpentOnUnits$[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iAverageGoldPerUnit$[ebp], eax

; 2224 : 
; 2225 : 	if(!bInDeficit && iAverageGoldPerUnit <= 4)

	movzx	edx, BYTE PTR _bInDeficit$[ebp]
	test	edx, edx
	jne	SHORT $LN22@DisbandExt
	cmp	DWORD PTR _iAverageGoldPerUnit$[ebp], 4
	jg	SHORT $LN22@DisbandExt

; 2226 : 	{
; 2227 : 		return;

	jmp	$LN23@DisbandExt
$LN22@DisbandExt:

; 2228 : 	}
; 2229 : 
; 2230 : 	//antonjs: consider: make calls to GetWorkersToCitiesRatio and GetImprovedToImprovablePlotsRatio instead, is the code similar enough?
; 2231 : 
; 2232 : 	double fWorstCaseRatio = 0.25; // one worker for four cities

	movsd	xmm0, QWORD PTR __real@3fd0000000000000
	movsd	QWORD PTR _fWorstCaseRatio$[ebp], xmm0

; 2233 : 	int iNumWorkers = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_WORKER, true, false);

	push	0
	push	1
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumWorkers$[ebp], eax

; 2234 : 	int iNumCities = m_pPlayer->getNumCities();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR _iNumCities$[ebp], eax

; 2235 : 
; 2236 : 	double fCurrentRatio = iNumWorkers / (double)iNumCities;

	cvtsi2sd xmm0, DWORD PTR _iNumWorkers$[ebp]
	cvtsi2sd xmm1, DWORD PTR _iNumCities$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _fCurrentRatio$[ebp], xmm0

; 2237 : 	if(fCurrentRatio <= fWorstCaseRatio || iNumWorkers == 1)

	movsd	xmm0, QWORD PTR _fWorstCaseRatio$[ebp]
	comisd	xmm0, QWORD PTR _fCurrentRatio$[ebp]
	jae	SHORT $LN20@DisbandExt
	cmp	DWORD PTR _iNumWorkers$[ebp], 1
	jne	SHORT $LN21@DisbandExt
$LN20@DisbandExt:

; 2238 : 	{
; 2239 : 		return;

	jmp	$LN23@DisbandExt
$LN21@DisbandExt:

; 2240 : 	}
; 2241 : 
; 2242 : 	const CvPlotsVector& aiPlots = m_pPlayer->GetPlots();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	DWORD PTR _aiPlots$[ebp], eax

; 2243 : 	int iNumValidPlots = 0;

	mov	DWORD PTR _iNumValidPlots$[ebp], 0

; 2244 : 	int iNumImprovedPlots = 0;

	mov	DWORD PTR _iNumImprovedPlots$[ebp], 0

; 2245 : 	for(uint ui = 0; ui < aiPlots.size(); ui++)

	mov	DWORD PTR _ui$226281[ebp], 0
	jmp	SHORT $LN19@DisbandExt
$LN18@DisbandExt:
	mov	eax, DWORD PTR _ui$226281[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$226281[ebp], eax
$LN19@DisbandExt:
	mov	ecx, DWORD PTR _aiPlots$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235659[ebp], edx
	mov	eax, DWORD PTR _ui$226281[ebp]
	cmp	eax, DWORD PTR $T235659[ebp]
	jae	$LN17@DisbandExt

; 2246 : 	{
; 2247 : 		if(aiPlots[ui] == -1)

	mov	ecx, DWORD PTR _aiPlots$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ui$226281[ebp]
	cmp	DWORD PTR [edx+eax*4], -1
	jne	SHORT $LN16@DisbandExt

; 2248 : 		{
; 2249 : 			continue;

	jmp	SHORT $LN18@DisbandExt
$LN16@DisbandExt:

; 2250 : 		}
; 2251 : 
; 2252 : 		const CvPlot* pPlot = GC.getMap().plotByIndex(aiPlots[ui]);

	mov	ecx, DWORD PTR _aiPlots$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ui$226281[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T235666[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235670[ebp], edx
	mov	eax, DWORD PTR $T235666[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T235684[ebp], ecx
	cmp	DWORD PTR $T235684[ebp], 0
	jl	SHORT $LN42@DisbandExt
	mov	edx, DWORD PTR $T235670[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T235677[ebp], eax
	mov	ecx, DWORD PTR $T235684[ebp]
	cmp	ecx, DWORD PTR $T235677[ebp]
	jge	SHORT $LN42@DisbandExt
	mov	edx, DWORD PTR $T235684[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T235670[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv269[ebp], edx
	jmp	SHORT $LN43@DisbandExt
$LN42@DisbandExt:
	mov	DWORD PTR tv269[ebp], 0
$LN43@DisbandExt:
	mov	ecx, DWORD PTR tv269[ebp]
	mov	DWORD PTR _pPlot$226286[ebp], ecx

; 2253 : 		if(!pPlot)

	cmp	DWORD PTR _pPlot$226286[ebp], 0
	jne	SHORT $LN15@DisbandExt

; 2254 : 		{
; 2255 : 			continue;

	jmp	$LN18@DisbandExt
$LN15@DisbandExt:

; 2256 : 		}
; 2257 : 
; 2258 : 		if(pPlot->isWater() || pPlot->isImpassable() || pPlot->isMountain() || pPlot->isCity())

	mov	edx, DWORD PTR _pPlot$226286[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN13@DisbandExt
	mov	eax, DWORD PTR _pPlot$226286[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN13@DisbandExt
	mov	eax, DWORD PTR _pPlot$226286[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN13@DisbandExt
	mov	ecx, DWORD PTR _pPlot$226286[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@DisbandExt
$LN13@DisbandExt:

; 2259 : 		{
; 2260 : 			continue;

	jmp	$LN18@DisbandExt
$LN14@DisbandExt:

; 2261 : 		}
; 2262 : 
; 2263 : 		iNumValidPlots++;

	mov	ecx, DWORD PTR _iNumValidPlots$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumValidPlots$[ebp], ecx

; 2264 : 
; 2265 : 		if(pPlot->getImprovementType() != NO_IMPROVEMENT && !pPlot->IsImprovementPillaged())

	mov	ecx, DWORD PTR _pPlot$226286[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN12@DisbandExt
	mov	ecx, DWORD PTR _pPlot$226286[ebp]
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@DisbandExt

; 2266 : 		{
; 2267 : 			iNumImprovedPlots++;

	mov	eax, DWORD PTR _iNumImprovedPlots$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumImprovedPlots$[ebp], eax
$LN12@DisbandExt:

; 2268 : 		}
; 2269 : 	}

	jmp	$LN18@DisbandExt
$LN17@DisbandExt:

; 2270 : 
; 2271 : 	// potential div by zero
; 2272 : 	if(iNumValidPlots <= 0)

	cmp	DWORD PTR _iNumValidPlots$[ebp], 0
	jg	SHORT $LN11@DisbandExt

; 2273 : 	{
; 2274 : 		return;

	jmp	$LN23@DisbandExt
$LN11@DisbandExt:

; 2275 : 	}
; 2276 : 
; 2277 : 	int iNumUnimprovedPlots = iNumValidPlots - iNumImprovedPlots;

	mov	ecx, DWORD PTR _iNumValidPlots$[ebp]
	sub	ecx, DWORD PTR _iNumImprovedPlots$[ebp]
	mov	DWORD PTR _iNumUnimprovedPlots$[ebp], ecx

; 2278 : 
; 2279 : 	// less than two thirds of the plots are improved, don't discard anybody
; 2280 : 	double fRatio = iNumImprovedPlots / (double)iNumValidPlots;

	cvtsi2sd xmm0, DWORD PTR _iNumImprovedPlots$[ebp]
	cvtsi2sd xmm1, DWORD PTR _iNumValidPlots$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _fRatio$[ebp], xmm0

; 2281 : 	if(fRatio < 2/(double)3)

	movsd	xmm0, QWORD PTR __real@3fe5555555555555
	comisd	xmm0, QWORD PTR _fRatio$[ebp]
	jbe	SHORT $LN10@DisbandExt

; 2282 : 	{
; 2283 : 		return;

	jmp	$LN23@DisbandExt
$LN10@DisbandExt:

; 2284 : 	}
; 2285 : 
; 2286 : 	int iWorkersPerUnimprovedPlot = 5;

	mov	DWORD PTR _iWorkersPerUnimprovedPlot$[ebp], 5

; 2287 : 	int iMinWorkers = iNumUnimprovedPlots / iWorkersPerUnimprovedPlot;

	mov	eax, DWORD PTR _iNumUnimprovedPlots$[ebp]
	cdq
	idiv	DWORD PTR _iWorkersPerUnimprovedPlot$[ebp]
	mov	DWORD PTR _iMinWorkers$[ebp], eax

; 2288 : 	if((iNumUnimprovedPlots % iWorkersPerUnimprovedPlot) > 0)

	mov	eax, DWORD PTR _iNumUnimprovedPlots$[ebp]
	cdq
	idiv	DWORD PTR _iWorkersPerUnimprovedPlot$[ebp]
	test	edx, edx
	jle	SHORT $LN9@DisbandExt

; 2289 : 	{
; 2290 : 		iMinWorkers += 1;

	mov	edx, DWORD PTR _iMinWorkers$[ebp]
	add	edx, 1
	mov	DWORD PTR _iMinWorkers$[ebp], edx
$LN9@DisbandExt:

; 2291 : 	}
; 2292 : 
; 2293 : 	CvCity* pCapital = m_pPlayer->getCapitalCity();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapital$[ebp], eax

; 2294 : 	if(!pCapital)

	cmp	DWORD PTR _pCapital$[ebp], 0
	jne	SHORT $LN8@DisbandExt

; 2295 : 	{
; 2296 : 		return;

	jmp	$LN23@DisbandExt
$LN8@DisbandExt:

; 2297 : 	}
; 2298 : 
; 2299 : 	int iLoop;
; 2300 : 	CvCity* pCity;
; 2301 : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pCity$[ebp], eax
	jmp	SHORT $LN7@DisbandExt
$LN6@DisbandExt:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[ebp], eax
$LN7@DisbandExt:
	cmp	DWORD PTR _pCity$[ebp], 0
	je	SHORT $LN5@DisbandExt

; 2302 : 	{
; 2303 : 		if(pCity == pCapital)

	mov	edx, DWORD PTR _pCity$[ebp]
	cmp	edx, DWORD PTR _pCapital$[ebp]
	jne	SHORT $LN4@DisbandExt

; 2304 : 		{
; 2305 : 			continue;

	jmp	SHORT $LN6@DisbandExt
$LN4@DisbandExt:

; 2306 : 		}
; 2307 : 
; 2308 : 		if(pCapital->area() == pCity->area() && !pCity->IsRouteToCapitalConnected())

	mov	ecx, DWORD PTR _pCapital$[ebp]
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	mov	esi, eax
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	cmp	esi, eax
	jne	SHORT $LN3@DisbandExt
	mov	ecx, DWORD PTR _pCity$[ebp]
	call	?IsRouteToCapitalConnected@CvCity@@QAE_NXZ ; CvCity::IsRouteToCapitalConnected
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@DisbandExt

; 2309 : 		{
; 2310 : 			iMinWorkers += 1;

	mov	ecx, DWORD PTR _iMinWorkers$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMinWorkers$[ebp], ecx
$LN3@DisbandExt:

; 2311 : 		}
; 2312 : 	}

	jmp	SHORT $LN6@DisbandExt
$LN5@DisbandExt:

; 2313 : 
; 2314 : 
; 2315 : 	if(iNumWorkers <= iMinWorkers)

	mov	edx, DWORD PTR _iNumWorkers$[ebp]
	cmp	edx, DWORD PTR _iMinWorkers$[ebp]
	jg	SHORT $LN2@DisbandExt

; 2316 : 	{
; 2317 : 		return;

	jmp	$LN23@DisbandExt
$LN2@DisbandExt:

; 2318 : 	}
; 2319 : 
; 2320 : 	m_iLastTurnWorkerDisbanded = GC.getGame().getGameTurn();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235702[ebp], eax
	mov	ecx, DWORD PTR $T235702[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2321 : 
; 2322 : 	CvUnit* pUnit = FindWorkerToScrap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindWorkerToScrap
	mov	DWORD PTR _pUnit$[ebp], eax

; 2323 : 	if(!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN1@DisbandExt

; 2324 : 	{
; 2325 : 		return;

	jmp	SHORT $LN23@DisbandExt
$LN1@DisbandExt:

; 2326 : 	}
; 2327 : 
; 2328 : 	pUnit->scrap();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 2329 : 	LogScrapUnit(pUnit, iNumWorkers, iNumCities, iNumImprovedPlots, iNumValidPlots);

	mov	edx, DWORD PTR _iNumValidPlots$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNumImprovedPlots$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumCities$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumWorkers$[ebp]
	push	edx
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR $T235641[ebp], esp
	mov	DWORD PTR $T235712[ebp], eax
	mov	ecx, DWORD PTR $T235712[ebp]
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T235712[ebp]
	mov	BYTE PTR [eax+4], 0
	mov	ecx, DWORD PTR $T235712[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN62@DisbandExt
	mov	edx, DWORD PTR $T235712[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN62@DisbandExt:
	mov	eax, DWORD PTR $T235712[ebp]
	mov	DWORD PTR tv262[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ; CvEconomicAI::LogScrapUnit
$LN23@DisbandExt:

; 2330 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?DisbandExtraWorkers@CvEconomicAI@@AAEXXZ ENDP		; CvEconomicAI::DisbandExtraWorkers
_TEXT	ENDS
PUBLIC	?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindArchaeologistToScrap
PUBLIC	??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@	; `string'
PUBLIC	??_C@_0BM@PALJPMHC@POLICY_EXPLORATION_FINISHER?$AA@ ; `string'
PUBLIC	__real@3fe0000000000000
EXTRN	?GetNumHiddenArchaeologySites@CvGame@@QBEHXZ:PROC ; CvGame::GetNumHiddenArchaeologySites
EXTRN	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z:PROC ; CvPlayerPolicies::HasPolicy
EXTRN	?GetNumArchaeologySites@CvGame@@QBEHXZ:PROC	; CvGame::GetNumArchaeologySites
;	COMDAT ??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@ DB 'UNIT_ARCHAEOLOGIST', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PALJPMHC@POLICY_EXPLORATION_FINISHER?$AA@
CONST	SEGMENT
??_C@_0BM@PALJPMHC@POLICY_EXPLORATION_FINISHER?$AA@ DB 'POLICY_EXPLORATIO'
	DB	'N_FINISHER', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
tv162 = -56						; size = 4
_this$ = -52						; size = 4
$T235738 = -48						; size = 4
$T235728 = -44						; size = 4
$T235724 = -40						; size = 4
$T235719 = -36						; size = 4
_eExpFinisher$ = -32					; size = 4
_pUnit$ = -28						; size = 4
_eArch$ = -24						; size = 4
_iNumArchaeologists$ = -20				; size = 4
_dMaxRatio$ = -16					; size = 8
_iNumSites$ = -4					; size = 4
?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ PROC	; CvEconomicAI::DisbandExtraArchaeologists, COMDAT
; _this$ = ecx

; 2331 : void CvEconomicAI::DisbandExtraArchaeologists(){

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 2332 : 	int iNumSites = GC.getGame().GetNumArchaeologySites();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235724[ebp], eax
	mov	ecx, DWORD PTR $T235724[ebp]
	call	?GetNumArchaeologySites@CvGame@@QBEHXZ	; CvGame::GetNumArchaeologySites
	mov	DWORD PTR _iNumSites$[ebp], eax

; 2333 : 	double dMaxRatio = .5; //Ratio of archaeologists to sites

	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _dMaxRatio$[ebp], xmm0

; 2334 : 	int iNumArchaeologists = m_pPlayer->GetNumUnitsWithUnitAI(UNITAI_ARCHAEOLOGIST, true);

	push	1
	push	1
	push	39					; 00000027H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumArchaeologists$[ebp], eax

; 2335 : 	PolicyTypes eExpFinisher = (PolicyTypes) GC.getInfoTypeForString("POLICY_EXPLORATION_FINISHER", true /*bHideAssert*/);

	push	1
	push	OFFSET ??_C@_0BM@PALJPMHC@POLICY_EXPLORATION_FINISHER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eExpFinisher$[ebp], eax

; 2336 : 	if (eExpFinisher != NO_POLICY)	

	cmp	DWORD PTR _eExpFinisher$[ebp], -1
	je	SHORT $LN4@DisbandExt@2

; 2337 : 	{
; 2338 : 		if (m_pPlayer->GetPlayerPolicies()->HasPolicy(eExpFinisher))

	mov	edx, DWORD PTR _eExpFinisher$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@DisbandExt@2

; 2339 : 		{
; 2340 : 			iNumSites += GC.getGame().GetNumHiddenArchaeologySites();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T235728[ebp], edx
	mov	ecx, DWORD PTR $T235728[ebp]
	call	?GetNumHiddenArchaeologySites@CvGame@@QBEHXZ ; CvGame::GetNumHiddenArchaeologySites
	add	eax, DWORD PTR _iNumSites$[ebp]
	mov	DWORD PTR _iNumSites$[ebp], eax
$LN4@DisbandExt@2:

; 2341 : 		}
; 2342 : 	}
; 2343 : 	
; 2344 : 	CvUnit* pUnit;
; 2345 : 	UnitTypes eArch = (UnitTypes) GC.getInfoTypeForString("UNIT_ARCHAEOLOGIST", true /*bHideAssert*/);

	push	1
	push	OFFSET ??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eArch$[ebp], eax

; 2346 : 	if(eArch == NO_UNIT){

	cmp	DWORD PTR _eArch$[ebp], -1
	jne	SHORT $LN3@DisbandExt@2

; 2347 : 		return;

	jmp	SHORT $LN6@DisbandExt@2
$LN3@DisbandExt@2:

; 2348 : 	}
; 2349 : 	if ((double)iNumSites * dMaxRatio + 1 < iNumArchaeologists ){

	cvtsi2sd xmm0, DWORD PTR _iNumSites$[ebp]
	mulsd	xmm0, QWORD PTR _dMaxRatio$[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsi2sd xmm1, DWORD PTR _iNumArchaeologists$[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN2@DisbandExt@2

; 2350 : 		pUnit = FindArchaeologistToScrap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ; CvEconomicAI::FindArchaeologistToScrap
	mov	DWORD PTR _pUnit$[ebp], eax

; 2351 : 	
; 2352 : 		if(!pUnit)

	cmp	DWORD PTR _pUnit$[ebp], 0
	jne	SHORT $LN1@DisbandExt@2

; 2353 : 		{
; 2354 : 			return;

	jmp	SHORT $LN6@DisbandExt@2
$LN1@DisbandExt@2:

; 2355 : 		}
; 2356 : 	
; 2357 : 		pUnit->scrap();

	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?scrap@CvUnit@@QAEXXZ			; CvUnit::scrap

; 2358 : 		LogScrapUnit(pUnit, iNumArchaeologists, iNumSites, 0, 0);

	push	0
	push	0
	mov	eax, DWORD PTR _iNumSites$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumArchaeologists$[ebp]
	push	ecx
	sub	esp, 8
	mov	edx, esp
	mov	DWORD PTR $T235719[ebp], esp
	mov	DWORD PTR $T235738[ebp], edx
	mov	eax, DWORD PTR $T235738[ebp]
	mov	ecx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T235738[ebp]
	mov	BYTE PTR [edx+4], 0
	mov	eax, DWORD PTR $T235738[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@DisbandExt@2
	mov	ecx, DWORD PTR $T235738[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN16@DisbandExt@2:
	mov	edx, DWORD PTR $T235738[ebp]
	mov	DWORD PTR tv162[ebp], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ; CvEconomicAI::LogScrapUnit
$LN2@DisbandExt@2:
$LN6@DisbandExt@2:

; 2359 : 	}
; 2360 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DisbandExtraArchaeologists@CvEconomicAI@@AAEXXZ ENDP	; CvEconomicAI::DisbandExtraArchaeologists
_TEXT	ENDS
PUBLIC	?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ	; CvEconomicAI::AssignHutsToExplorers
PUBLIC	?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ	; CvEconomicAI::AssignExplorersToHuts
PUBLIC	?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back
PUBLIC	?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back
PUBLIC	?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ:PROC ; CvUnit::GetMissionAIType
EXTRN	?IsAutomated@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsAutomated
EXTRN	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z:PROC ; CvPlot::getNumDefenders
EXTRN	?HasBarbarianCamp@CvPlot@@QAE_NXZ:PROC		; CvPlot::HasBarbarianCamp
EXTRN	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleEnemyUnit
EXTRN	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isRevealedGoody
; Function compile flags: /Odtp
;	COMDAT ?UpdatePlots@CvEconomicAI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -216						; size = 4
$T235956 = -212						; size = 4
$T235952 = -208						; size = 4
$T235941 = -200						; size = 4
_i$235937 = -196					; size = 4
$T235902 = -184						; size = 4
$T235895 = -180						; size = 4
$T235868 = -168						; size = 4
$T235864 = -164						; size = 4
$T235837 = -152						; size = 4
$T235833 = -148						; size = 4
_uiOffset$235823 = -144					; size = 4
$T235811 = -140						; size = 4
$T235807 = -136						; size = 4
$T235803 = -132						; size = 4
$T235799 = -128						; size = 4
$T235790 = -124						; size = 4
$T235781 = -120						; size = 4
$T235772 = -116						; size = 4
$T235762 = -112						; size = 4
$T235752 = -108						; size = 4
$T235748 = -104						; size = 4
$T235747 = -100						; size = 4
$T235746 = -96						; size = 8
$T235745 = -88						; size = 4
$T235744 = -84						; size = 8
$T235743 = -76						; size = 4
_eDomain$226375 = -72					; size = 4
_iScore$226377 = -68					; size = 4
_i$226359 = -64						; size = 4
_ui$226340 = -60					; size = 4
_ui$226336 = -56					; size = 4
_iLoopCity$ = -52					; size = 4
_iTotalX$ = -48						; size = 4
_pPlot$ = -44						; size = 4
_iCivCenterY$ = -40					; size = 4
_iLoopUnit$ = -36					; size = 4
_pLoopUnit$ = -32					; size = 4
_iCityCount$ = -28					; size = 4
_iCivCenterX$ = -24					; size = 4
_uiExplorationPlotIndex$ = -20				; size = 4
_uiGoodyHutPlotIndex$ = -16				; size = 4
_ePlayerTeam$ = -12					; size = 4
_iTotalY$ = -8						; size = 4
_pLoopCity$ = -4					; size = 4
?UpdatePlots@CvEconomicAI@@QAEXXZ PROC			; CvEconomicAI::UpdatePlots, COMDAT
; _this$ = ecx

; 2364 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	mov	DWORD PTR _this$[ebp], ecx

; 2365 : 	// reset all plots
; 2366 : 	for(uint ui = 0; ui < m_aiExplorationPlots.size(); ui++)

	mov	DWORD PTR _ui$226336[ebp], 0
	jmp	SHORT $LN32@UpdatePlot
$LN31@UpdatePlot:
	mov	eax, DWORD PTR _ui$226336[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$226336[ebp], eax
$LN32@UpdatePlot:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR $T235752[ebp], edx
	mov	eax, DWORD PTR _ui$226336[ebp]
	cmp	eax, DWORD PTR $T235752[ebp]
	jae	SHORT $LN30@UpdatePlot

; 2367 : 	{
; 2368 : 		m_aiExplorationPlots[ui] = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _ui$226336[ebp]
	mov	DWORD PTR [edx+eax*4], -1

; 2369 : 		m_aiExplorationPlotRatings[ui] = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _ui$226336[ebp]
	mov	DWORD PTR [edx+eax*4], -1

; 2370 : 	}

	jmp	SHORT $LN31@UpdatePlot
$LN30@UpdatePlot:

; 2371 : 
; 2372 : 	for(uint ui = 0; ui < m_aiGoodyHutPlots.size(); ui++)

	mov	DWORD PTR _ui$226340[ebp], 0
	jmp	SHORT $LN29@UpdatePlot
$LN28@UpdatePlot:
	mov	ecx, DWORD PTR _ui$226340[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$226340[ebp], ecx
$LN29@UpdatePlot:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR $T235762[ebp], eax
	mov	ecx, DWORD PTR _ui$226340[ebp]
	cmp	ecx, DWORD PTR $T235762[ebp]
	jae	SHORT $LN27@UpdatePlot

; 2373 : 	{
; 2374 : 		m_aiGoodyHutPlots[ui] = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR _ui$226340[ebp]
	mov	DWORD PTR [eax+ecx*4], -1

; 2375 : 		m_aiGoodyHutUnitAssignments[ui].Clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _ui$226340[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T235772[ebp], edx
	mov	eax, DWORD PTR $T235772[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T235772[ebp]
	mov	DWORD PTR [ecx+4], -1

; 2376 : 	}

	jmp	SHORT $LN28@UpdatePlot
$LN27@UpdatePlot:

; 2377 : 
; 2378 : 	// find the center of all the cities
; 2379 : 	int iTotalX = 0;

	mov	DWORD PTR _iTotalX$[ebp], 0

; 2380 : 	int iTotalY = 0;

	mov	DWORD PTR _iTotalY$[ebp], 0

; 2381 : 	int iCityCount = 0;

	mov	DWORD PTR _iCityCount$[ebp], 0

; 2382 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 2383 : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 2384 : 	for(pLoopCity = m_pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = m_pPlayer->nextCity(&iLoopCity))

	push	0
	lea	edx, DWORD PTR _iLoopCity$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN26@UpdatePlot
$LN25@UpdatePlot:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN26@UpdatePlot:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN24@UpdatePlot

; 2385 : 	{
; 2386 : 		iTotalX += pLoopCity->getX();

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T235781[ebp], ecx
	mov	edx, DWORD PTR _iTotalX$[ebp]
	add	edx, DWORD PTR $T235781[ebp]
	mov	DWORD PTR _iTotalX$[ebp], edx

; 2387 : 		iTotalY += pLoopCity->getY();

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR $T235790[ebp], ecx
	mov	edx, DWORD PTR _iTotalY$[ebp]
	add	edx, DWORD PTR $T235790[ebp]
	mov	DWORD PTR _iTotalY$[ebp], edx

; 2388 : 		iCityCount++;

	mov	eax, DWORD PTR _iCityCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _iCityCount$[ebp], eax

; 2389 : 	}

	jmp	SHORT $LN25@UpdatePlot
$LN24@UpdatePlot:

; 2390 : 
; 2391 : 	int iCivCenterX = -1;

	mov	DWORD PTR _iCivCenterX$[ebp], -1

; 2392 : 	int iCivCenterY = -1;

	mov	DWORD PTR _iCivCenterY$[ebp], -1

; 2393 : 	if(iCityCount > 0)

	cmp	DWORD PTR _iCityCount$[ebp], 0
	jle	SHORT $LN23@UpdatePlot

; 2394 : 	{
; 2395 : 		iCivCenterX = iTotalX / iCityCount;

	mov	eax, DWORD PTR _iTotalX$[ebp]
	cdq
	idiv	DWORD PTR _iCityCount$[ebp]
	mov	DWORD PTR _iCivCenterX$[ebp], eax

; 2396 : 		iCivCenterY = iTotalY / iCityCount;

	mov	eax, DWORD PTR _iTotalY$[ebp]
	cdq
	idiv	DWORD PTR _iCityCount$[ebp]
	mov	DWORD PTR _iCivCenterY$[ebp], eax
$LN23@UpdatePlot:

; 2397 : 	}
; 2398 : 
; 2399 : 	uint uiExplorationPlotIndex = 0;

	mov	DWORD PTR _uiExplorationPlotIndex$[ebp], 0

; 2400 : 	uint uiGoodyHutPlotIndex = 0;

	mov	DWORD PTR _uiGoodyHutPlotIndex$[ebp], 0

; 2401 : 	TeamTypes ePlayerTeam = m_pPlayer->getTeam();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T235799[ebp], edx
	mov	eax, DWORD PTR $T235799[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR _ePlayerTeam$[ebp], eax

; 2402 : 
; 2403 : 	CvPlot* pPlot;
; 2404 : #ifdef AUI_WARNING_FIXES
; 2405 : 	for (uint i = 0; i < GC.getMap().numPlots(); i++)
; 2406 : #else
; 2407 : 	for(int i = 0; i < GC.getMap().numPlots(); i++)

	mov	DWORD PTR _i$226359[ebp], 0
	jmp	SHORT $LN22@UpdatePlot
$LN21@UpdatePlot:
	mov	edx, DWORD PTR _i$226359[ebp]
	add	edx, 1
	mov	DWORD PTR _i$226359[ebp], edx
$LN22@UpdatePlot:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235803[ebp], eax
	mov	ecx, DWORD PTR $T235803[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T235807[ebp], edx
	mov	eax, DWORD PTR _i$226359[ebp]
	cmp	eax, DWORD PTR $T235807[ebp]
	jge	$LN20@UpdatePlot

; 2408 : #endif
; 2409 : 	{
; 2410 : 		pPlot = GC.getMap().plotByIndexUnchecked(i);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235811[ebp], ecx
	mov	edx, DWORD PTR _i$226359[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T235811[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pPlot$[ebp], edx

; 2411 : 		if(pPlot == NULL)

	jne	SHORT $LN19@UpdatePlot

; 2412 : 		{
; 2413 : 			continue;

	jmp	SHORT $LN21@UpdatePlot
$LN19@UpdatePlot:

; 2414 : 		}
; 2415 : 
; 2416 : 		if(!pPlot->isRevealed(ePlayerTeam))

	mov	ecx, DWORD PTR _ePlayerTeam$[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$235823[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$235823[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR _ePlayerTeam$[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$235823[ebp]
	mov	edx, DWORD PTR _pPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN18@UpdatePlot

; 2417 : 		{
; 2418 : 			continue;

	jmp	$LN21@UpdatePlot
$LN18@UpdatePlot:

; 2419 : 		}
; 2420 : 
; 2421 : 		if(pPlot->isRevealedGoody(ePlayerTeam) && !pPlot->isVisibleEnemyUnit(m_pPlayer->GetID()))

	mov	edx, DWORD PTR _ePlayerTeam$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isRevealedGoody@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isRevealedGoody
	movzx	eax, al
	test	eax, eax
	je	$LN17@UpdatePlot
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T235833[ebp], eax
	mov	ecx, DWORD PTR $T235833[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	edx, al
	test	edx, edx
	jne	$LN17@UpdatePlot

; 2422 : 		{
; 2423 : 			if(m_aiGoodyHutPlots.size() <= uiGoodyHutPlotIndex)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR $T235837[ebp], ecx
	mov	edx, DWORD PTR $T235837[ebp]
	cmp	edx, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	ja	SHORT $LN95@UpdatePlot

; 2424 : 			{
; 2425 : 				m_aiGoodyHutPlots.push_back(-1);

	mov	DWORD PTR $T235743[ebp], -1
	lea	eax, DWORD PTR $T235743[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back

; 2426 : 				m_aiGoodyHutUnitAssignments.push_back(GoodyHutUnitAssignment(-1, -1));

	mov	DWORD PTR $T235744[ebp], -1
	mov	DWORD PTR $T235744[ebp+4], -1
	lea	ecx, DWORD PTR $T235744[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back

; 2427 : 			}
; 2428 : 			m_aiGoodyHutPlots[uiGoodyHutPlotIndex] = i;

$LN95@UpdatePlot:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	mov	edx, DWORD PTR _i$226359[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 2429 : 			m_aiGoodyHutUnitAssignments[uiGoodyHutPlotIndex].Clear();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T235864[ebp], eax
	mov	ecx, DWORD PTR $T235864[ebp]
	mov	DWORD PTR [ecx], -1
	mov	edx, DWORD PTR $T235864[ebp]
	mov	DWORD PTR [edx+4], -1

; 2430 : 			++uiGoodyHutPlotIndex;

	mov	eax, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _uiGoodyHutPlotIndex$[ebp], eax
$LN17@UpdatePlot:

; 2431 : 		}
; 2432 : 		if(pPlot->HasBarbarianCamp())

	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?HasBarbarianCamp@CvPlot@@QAE_NXZ	; CvPlot::HasBarbarianCamp
	movzx	ecx, al
	test	ecx, ecx
	je	$LN15@UpdatePlot

; 2433 : 		{
; 2434 : 			if(pPlot->getNumDefenders(BARBARIAN_PLAYER) == 0)

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _pPlot$[ebp]
	call	?getNumDefenders@CvPlot@@QBEHW4PlayerTypes@@@Z ; CvPlot::getNumDefenders
	test	eax, eax
	jne	$LN15@UpdatePlot

; 2435 : 			{
; 2436 : 				if(m_aiGoodyHutPlots.size() <= uiGoodyHutPlotIndex)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR $T235868[ebp], eax
	mov	ecx, DWORD PTR $T235868[ebp]
	cmp	ecx, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	ja	SHORT $LN119@UpdatePlot

; 2437 : 				{
; 2438 : 					m_aiGoodyHutPlots.push_back(-1);

	mov	DWORD PTR $T235745[ebp], -1
	lea	edx, DWORD PTR $T235745[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back

; 2439 : 					m_aiGoodyHutUnitAssignments.push_back(GoodyHutUnitAssignment(-1, -1));

	mov	DWORD PTR $T235746[ebp], -1
	mov	DWORD PTR $T235746[ebp+4], -1
	lea	eax, DWORD PTR $T235746[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back

; 2440 : 				}
; 2441 : 				m_aiGoodyHutPlots[uiGoodyHutPlotIndex] = i;

$LN119@UpdatePlot:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	mov	ecx, DWORD PTR _i$226359[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2442 : 				m_aiGoodyHutUnitAssignments[uiGoodyHutPlotIndex].Clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T235895[ebp], edx
	mov	eax, DWORD PTR $T235895[ebp]
	mov	DWORD PTR [eax], -1
	mov	ecx, DWORD PTR $T235895[ebp]
	mov	DWORD PTR [ecx+4], -1

; 2443 : 				++uiGoodyHutPlotIndex;

	mov	edx, DWORD PTR _uiGoodyHutPlotIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _uiGoodyHutPlotIndex$[ebp], edx
$LN15@UpdatePlot:

; 2444 : 			}
; 2445 : 		}
; 2446 : 
; 2447 : 		DomainTypes eDomain = DOMAIN_LAND;

	mov	DWORD PTR _eDomain$226375[ebp], 2

; 2448 : 		if(pPlot->isWater())

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN12@UpdatePlot

; 2449 : 		{
; 2450 : 			eDomain = DOMAIN_SEA;

	mov	DWORD PTR _eDomain$226375[ebp], 0
$LN12@UpdatePlot:

; 2451 : 		}
; 2452 : 
; 2453 : 		int iScore = ScoreExplorePlot(pPlot, ePlayerTeam, 1, eDomain);

	mov	ecx, DWORD PTR _eDomain$226375[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _ePlayerTeam$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$[ebp]
	push	eax
	call	?ScoreExplorePlot@CvEconomicAI@@SAHPAVCvPlot@@W4TeamTypes@@HW4DomainTypes@@@Z ; CvEconomicAI::ScoreExplorePlot
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iScore$226377[ebp], eax

; 2454 : 		if(iScore <= 0)

	cmp	DWORD PTR _iScore$226377[ebp], 0
	jg	SHORT $LN11@UpdatePlot

; 2455 : 		{
; 2456 : 			continue;

	jmp	$LN21@UpdatePlot
$LN11@UpdatePlot:

; 2457 : 		}
; 2458 : 
; 2459 : 		// add an entry for this plot
; 2460 : 		if(m_aiExplorationPlots.size() <= uiExplorationPlotIndex)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR $T235902[ebp], edx
	mov	eax, DWORD PTR $T235902[ebp]
	cmp	eax, DWORD PTR _uiExplorationPlotIndex$[ebp]
	ja	SHORT $LN143@UpdatePlot

; 2461 : 		{
; 2462 : 			m_aiExplorationPlots.push_back(-1);

	mov	DWORD PTR $T235747[ebp], -1
	lea	ecx, DWORD PTR $T235747[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back

; 2463 : 			m_aiExplorationPlotRatings.push_back(-1);

	mov	DWORD PTR $T235748[ebp], -1
	lea	edx, DWORD PTR $T235748[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back

; 2464 : 		}
; 2465 : 
; 2466 : 		m_aiExplorationPlots[uiExplorationPlotIndex] = i;

$LN143@UpdatePlot:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _uiExplorationPlotIndex$[ebp]
	mov	eax, DWORD PTR _i$226359[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2467 : 		m_aiExplorationPlotRatings[uiExplorationPlotIndex] = iScore;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _uiExplorationPlotIndex$[ebp]
	mov	ecx, DWORD PTR _iScore$226377[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2468 : 		uiExplorationPlotIndex++;

	mov	edx, DWORD PTR _uiExplorationPlotIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _uiExplorationPlotIndex$[ebp], edx

; 2469 : 	}

	jmp	$LN21@UpdatePlot
$LN20@UpdatePlot:

; 2470 : 
; 2471 : 	// assign explorers to goody huts
; 2472 : 
; 2473 : 	// build explorer list
; 2474 : 	CvUnit* pLoopUnit;
; 2475 : 	int iLoopUnit;
; 2476 : 	m_apExplorers.clear();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 288				; 00000120H
	mov	DWORD PTR $T235941[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN153@UpdatePlot
	mov	DWORD PTR _i$235937[ebp], 0
	jmp	SHORT $LN151@UpdatePlot
$LN150@UpdatePlot:
	mov	edx, DWORD PTR _i$235937[ebp]
	add	edx, 1
	mov	DWORD PTR _i$235937[ebp], edx
$LN151@UpdatePlot:
	mov	eax, DWORD PTR $T235941[ebp]
	mov	ecx, DWORD PTR _i$235937[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN153@UpdatePlot
	jmp	SHORT $LN150@UpdatePlot
$LN153@UpdatePlot:
	mov	edx, DWORD PTR $T235941[ebp]
	mov	DWORD PTR [edx+4], 0

; 2477 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iLoopUnit); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoopUnit))

	push	0
	lea	eax, DWORD PTR _iLoopUnit$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN9@UpdatePlot
$LN8@UpdatePlot:
	push	0
	lea	edx, DWORD PTR _iLoopUnit$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN9@UpdatePlot:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN7@UpdatePlot

; 2478 : 	{
; 2479 : 		// non-automated human-controlled units should not be considered
; 2480 : 		if(m_pPlayer->isHuman() && !pLoopUnit->IsAutomated())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@UpdatePlot
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?IsAutomated@CvUnit@@QBE_NXZ		; CvUnit::IsAutomated
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@UpdatePlot

; 2481 : 		{
; 2482 : 			continue;

	jmp	SHORT $LN8@UpdatePlot
$LN6@UpdatePlot:

; 2483 : 		}
; 2484 : 
; 2485 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN5@UpdatePlot

; 2486 : 		{
; 2487 : 			continue;

	jmp	SHORT $LN8@UpdatePlot
$LN5@UpdatePlot:

; 2488 : 		}
; 2489 : 
; 2490 : 		if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE && pLoopUnit->GetMissionAIType() != MISSIONAI_EXPLORE)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN4@UpdatePlot
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetMissionAIType@CvUnit@@QAE?AW4MissionAITypes@@XZ ; CvUnit::GetMissionAIType
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN4@UpdatePlot

; 2491 : 		{
; 2492 : 			continue;

	jmp	SHORT $LN8@UpdatePlot
$LN4@UpdatePlot:

; 2493 : 		}
; 2494 : 
; 2495 : 		if(pLoopUnit->getArmyID() != FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN3@UpdatePlot

; 2496 : 		{
; 2497 : 			continue;

	jmp	SHORT $LN8@UpdatePlot
$LN3@UpdatePlot:

; 2498 : 		}
; 2499 : 
; 2500 : 		m_apExplorers.push_back(pLoopUnit);

	lea	ecx, DWORD PTR _pLoopUnit$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	call	?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back

; 2501 : 	}

	jmp	$LN8@UpdatePlot
$LN7@UpdatePlot:

; 2502 : 
; 2503 : 	if(m_apExplorers.size() >= m_aiGoodyHutPlots.size())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	mov	DWORD PTR $T235952[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR $T235956[ebp], edx
	mov	eax, DWORD PTR $T235952[ebp]
	cmp	eax, DWORD PTR $T235956[ebp]
	jb	SHORT $LN2@UpdatePlot

; 2504 : 	{
; 2505 : 		AssignExplorersToHuts();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ ; CvEconomicAI::AssignExplorersToHuts

; 2506 : 	}
; 2507 : 	else

	jmp	SHORT $LN1@UpdatePlot
$LN2@UpdatePlot:

; 2508 : 	{
; 2509 : 		AssignHutsToExplorers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ ; CvEconomicAI::AssignHutsToExplorers
$LN1@UpdatePlot:

; 2510 : 	}
; 2511 : 
; 2512 : 	m_bExplorationPlotsDirty = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx], 0

; 2513 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdatePlots@CvEconomicAI@@QAEXXZ ENDP			; CvEconomicAI::UpdatePlots
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
PUBLIC	??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ ; CvWeightedVector<CvUnit *,50,1>::SortItems
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::push_back
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::Destroy
PUBLIC	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
PUBLIC	__$ArrayPad$
EXTRN	?GetPlotIndex@CvPlot@@QBEHXZ:PROC		; CvPlot::GetPlotIndex
EXTRN	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ:PROC ; CvTwoLayerPathFinder::GetPathEndTurnPlot
EXTRN	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z:PROC ; CvTwoLayerPathFinder::GenerateUnitPath
EXTRN	?maxMoves@CvUnit@@QBEHXZ:PROC			; CvUnit::maxMoves
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$1
__ehfuncinfo$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
tv284 = -712						; size = 4
_this$ = -708						; size = 4
$T236220 = -676						; size = 4
$T236211 = -672						; size = 4
$T236207 = -668						; size = 4
$T236203 = -664						; size = 4
_i$236199 = -660					; size = 4
$T236153 = -644						; size = 4
$T236144 = -640						; size = 4
$T236135 = -636						; size = 4
$T236131 = -632						; size = 4
$T236103 = -620						; size = 4
_weightedElem$236095 = -616				; size = 8
$T236089 = -608						; size = 4
$T236048 = -560						; size = 4
$T236039 = -556						; size = 4
$T236030 = -552						; size = 4
$T236026 = -548						; size = 4
$T236019 = -544						; size = 4
$T236007 = -540						; size = 4
$T236000 = -536						; size = 4
$T235993 = -532						; size = 4
$T235989 = -528						; size = 4
$T235982 = -524						; size = 4
$T235970 = -520						; size = 4
$T235960 = -516						; size = 8
_uiExplorer$226653 = -508				; size = 4
_tempExplorers$226652 = -504				; size = 12
_pPlot$226639 = -492					; size = 4
_pUnit$226636 = -488					; size = 4
_bCanFindPath$226637 = -481				; size = 1
_i$226632 = -480					; size = 4
_iEstimateTurns$226629 = -476				; size = 4
_pUnit$226626 = -472					; size = 4
_iDistance$226627 = -468				; size = 4
_uiExplorer$226622 = -464				; size = 4
_uiListSize$226630 = -460				; size = 4
_pGoodyPlot$226619 = -456				; size = 4
_iStepPlotID$226621 = -452				; size = 4
_iUnitID$226620 = -448					; size = 4
_uiGoodyPlots$226614 = -444				; size = 4
_kPathFinder$ = -440					; size = 4
_aBestUnitList$ = -436					; size = 416
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ PROC	; CvEconomicAI::AssignExplorersToHuts, COMDAT
; _this$ = ecx

; 2519 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 700				; 000002bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2520 : #if defined(PATH_PLAN_LAST)
; 2521 : 	WeightedUnitVector aBestUnitList;

	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	call	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2522 : 	aBestUnitList.reserve(m_apExplorers.size());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	DWORD PTR $T235970[ebp], ecx
	mov	edx, DWORD PTR $T235970[ebp]
	push	edx
	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	call	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit

; 2523 : #endif
; 2524 : 
; 2525 : 	CvTwoLayerPathFinder& kPathFinder = GC.getPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR _kPathFinder$[ebp], eax

; 2526 : 	for(uint uiGoodyPlots = 0; uiGoodyPlots < m_aiGoodyHutPlots.size(); uiGoodyPlots++)

	mov	DWORD PTR _uiGoodyPlots$226614[ebp], 0
	jmp	SHORT $LN18@AssignExpl
$LN17@AssignExpl:
	mov	eax, DWORD PTR _uiGoodyPlots$226614[ebp]
	add	eax, 1
	mov	DWORD PTR _uiGoodyPlots$226614[ebp], eax
$LN18@AssignExpl:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR $T235982[ebp], edx
	mov	eax, DWORD PTR _uiGoodyPlots$226614[ebp]
	cmp	eax, DWORD PTR $T235982[ebp]
	jae	$LN16@AssignExpl

; 2527 : 	{
; 2528 : 		if(m_aiGoodyHutPlots[uiGoodyPlots] == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _uiGoodyPlots$226614[ebp]
	cmp	DWORD PTR [edx+eax*4], -1
	jne	SHORT $LN15@AssignExpl

; 2529 : 		{
; 2530 : 			continue;

	jmp	SHORT $LN17@AssignExpl
$LN15@AssignExpl:

; 2531 : 		}
; 2532 : 
; 2533 : 		CvPlot* pGoodyPlot = GC.getMap().plotByIndex(m_aiGoodyHutPlots[uiGoodyPlots]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	eax, DWORD PTR _uiGoodyPlots$226614[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T235989[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T235993[ebp], edx
	mov	eax, DWORD PTR $T235989[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236007[ebp], ecx
	cmp	DWORD PTR $T236007[ebp], 0
	jl	SHORT $LN42@AssignExpl
	mov	edx, DWORD PTR $T235993[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T236000[ebp], eax
	mov	ecx, DWORD PTR $T236007[ebp]
	cmp	ecx, DWORD PTR $T236000[ebp]
	jge	SHORT $LN42@AssignExpl
	mov	edx, DWORD PTR $T236007[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T235993[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv284[ebp], edx
	jmp	SHORT $LN40@AssignExpl
$LN42@AssignExpl:
	mov	DWORD PTR tv284[ebp], 0
$LN40@AssignExpl:
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR _pGoodyPlot$226619[ebp], ecx

; 2534 : #if !defined(PATH_PLAN_LAST)
; 2535 : 		int iClosestEstimateTurns = MAX_INT;
; 2536 : #endif
; 2537 : 		int iUnitID = NO_UNIT;

	mov	DWORD PTR _iUnitID$226620[ebp], -1

; 2538 : 		int iStepPlotID = -1;

	mov	DWORD PTR _iStepPlotID$226621[ebp], -1

; 2539 : 
; 2540 : 		aBestUnitList.clear();

	mov	edx, DWORD PTR _aBestUnitList$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _aBestUnitList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	call	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::Destroy
	mov	DWORD PTR _aBestUnitList$[ebp+4], 0

; 2541 : 
; 2542 : 		for(uint uiExplorer = 0; uiExplorer < m_apExplorers.size(); uiExplorer++)

	mov	DWORD PTR _uiExplorer$226622[ebp], 0
	jmp	SHORT $LN14@AssignExpl
$LN13@AssignExpl:
	mov	ecx, DWORD PTR _uiExplorer$226622[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiExplorer$226622[ebp], ecx
$LN14@AssignExpl:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	mov	DWORD PTR $T236019[ebp], eax
	mov	ecx, DWORD PTR _uiExplorer$226622[ebp]
	cmp	ecx, DWORD PTR $T236019[ebp]
	jae	$LN12@AssignExpl

; 2543 : 		{
; 2544 : 			CvUnit* pUnit = m_apExplorers[uiExplorer];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	mov	ecx, DWORD PTR _uiExplorer$226622[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pUnit$226626[ebp], edx

; 2545 : 
; 2546 : 			int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY());

	mov	eax, DWORD PTR _pGoodyPlot$226619[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236026[ebp], ecx
	mov	edx, DWORD PTR _pGoodyPlot$226619[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236030[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226626[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T236039[ebp], edx
	mov	eax, DWORD PTR _pUnit$226626[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T236048[ebp], ecx
	mov	edx, DWORD PTR $T236026[ebp]
	push	edx
	mov	eax, DWORD PTR $T236030[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236039[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236048[ebp]
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$226627[ebp], eax

; 2547 : 
; 2548 : #if defined(PATH_PLAN_LAST)
; 2549 : 			if(pUnit->maxMoves() >= 1)

	mov	ecx, DWORD PTR _pUnit$226626[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cmp	eax, 1
	jl	SHORT $LN11@AssignExpl

; 2550 : 			{
; 2551 : 				int iEstimateTurns = iDistance / (pUnit->maxMoves() / GC.getMOVE_DENOMINATOR());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T236089[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226626[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cdq
	idiv	DWORD PTR $T236089[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _iDistance$226627[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iEstimateTurns$226629[ebp], eax

; 2552 : 				aBestUnitList.push_back(pUnit, iEstimateTurns);

	mov	DWORD PTR _weightedElem$236095[ebp], 0
	mov	DWORD PTR _weightedElem$236095[ebp+4], 0
	mov	edx, DWORD PTR _pUnit$226626[ebp]
	mov	DWORD PTR _weightedElem$236095[ebp], edx
	mov	eax, DWORD PTR _iEstimateTurns$226629[ebp]
	mov	DWORD PTR _weightedElem$236095[ebp+4], eax
	lea	ecx, DWORD PTR _weightedElem$236095[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	call	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::push_back
$LN11@AssignExpl:

; 2553 : 			}
; 2554 : #else
; 2555 : 			int iEstimateTurns = MAX_INT;
; 2556 : 			if(pUnit->maxMoves() >= 1)
; 2557 : 			{
; 2558 : 				iEstimateTurns = iDistance / (pUnit->maxMoves() / GC.getMOVE_DENOMINATOR());
; 2559 : 			}
; 2560 : 
; 2561 : 			if(iEstimateTurns < iClosestEstimateTurns)
; 2562 : 			{
; 2563 : 				// Now check path
; 2564 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);
; 2565 : 				if(bCanFindPath)
; 2566 : 				{
; 2567 : 					iClosestEstimateTurns = iEstimateTurns;
; 2568 : 					iUnitID = pUnit->GetID();
; 2569 : 					CvPlot* pPlot = kPathFinder.GetPathEndTurnPlot();
; 2570 : 					if(pPlot)
; 2571 : 						iStepPlotID = pPlot->GetPlotIndex();
; 2572 : 				}
; 2573 : 			}
; 2574 : #endif
; 2575 : 		}

	jmp	$LN13@AssignExpl
$LN12@AssignExpl:

; 2576 : 
; 2577 : #if defined(PATH_PLAN_LAST)
; 2578 : 		uint uiListSize;
; 2579 : 		if ((uiListSize = aBestUnitList.size()) > 0)

	mov	edx, DWORD PTR _aBestUnitList$[ebp+4]
	mov	DWORD PTR $T236103[ebp], edx
	mov	eax, DWORD PTR $T236103[ebp]
	mov	DWORD PTR _uiListSize$226630[ebp], eax
	cmp	DWORD PTR _uiListSize$226630[ebp], 0
	jbe	$LN10@AssignExpl

; 2580 : 		{
; 2581 : 			aBestUnitList.SortItems();			// highest score will be first.

	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	call	?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ ; CvWeightedVector<CvUnit *,50,1>::SortItems

; 2582 : 			for (uint i = uiListSize; i--; )	// Go backward, we want the lowest score (distance)

	mov	ecx, DWORD PTR _uiListSize$226630[ebp]
	mov	DWORD PTR _i$226632[ebp], ecx
$LN9@AssignExpl:
	mov	edx, DWORD PTR _i$226632[ebp]
	mov	eax, DWORD PTR _i$226632[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$226632[ebp], eax
	test	edx, edx
	je	$LN10@AssignExpl

; 2583 : 			{
; 2584 : 				CvUnit* pUnit = aBestUnitList.GetElement(i);

	mov	ecx, DWORD PTR _i$226632[ebp]
	mov	edx, DWORD PTR _aBestUnitList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _pUnit$226636[ebp], eax

; 2585 : 				bool bCanFindPath = kPathFinder.GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	ecx, DWORD PTR _pGoodyPlot$226619[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236131[ebp], edx
	mov	eax, DWORD PTR _pGoodyPlot$226619[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T236135[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226636[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T236144[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226636[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T236153[ebp], edx
	push	1
	push	138					; 0000008aH
	mov	eax, DWORD PTR $T236131[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236135[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236144[ebp]
	push	edx
	mov	eax, DWORD PTR $T236153[ebp]
	push	eax
	mov	ecx, DWORD PTR _pUnit$226636[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kPathFinder$[ebp]
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
	mov	BYTE PTR _bCanFindPath$226637[ebp], al

; 2586 : 				if(bCanFindPath)

	movzx	edx, BYTE PTR _bCanFindPath$226637[ebp]
	test	edx, edx
	je	SHORT $LN7@AssignExpl

; 2587 : 				{
; 2588 : 					iUnitID = pUnit->GetID();

	mov	eax, DWORD PTR _pUnit$226636[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR _iUnitID$226620[ebp], ecx

; 2589 : 					// Since we've gone through the trouble of calculating a path, save where our turn will end so the Homeland AI doesn't need to re-do the path.
; 2590 : 					CvPlot* pPlot = kPathFinder.GetPathEndTurnPlot();

	mov	ecx, DWORD PTR _kPathFinder$[ebp]
	call	?GetPathEndTurnPlot@CvTwoLayerPathFinder@@QBEPAVCvPlot@@XZ ; CvTwoLayerPathFinder::GetPathEndTurnPlot
	mov	DWORD PTR _pPlot$226639[ebp], eax

; 2591 : 					if(pPlot)

	cmp	DWORD PTR _pPlot$226639[ebp], 0
	je	SHORT $LN6@AssignExpl

; 2592 : 						iStepPlotID = pPlot->GetPlotIndex();

	mov	ecx, DWORD PTR _pPlot$226639[ebp]
	call	?GetPlotIndex@CvPlot@@QBEHXZ		; CvPlot::GetPlotIndex
	mov	DWORD PTR _iStepPlotID$226621[ebp], eax
$LN6@AssignExpl:

; 2593 : 					break;

	jmp	SHORT $LN10@AssignExpl
$LN7@AssignExpl:

; 2594 : 				}
; 2595 : 			}

	jmp	$LN9@AssignExpl
$LN10@AssignExpl:

; 2596 : 		}
; 2597 : #endif
; 2598 : 
; 2599 : 		if(iUnitID != NO_UNIT)

	cmp	DWORD PTR _iUnitID$226620[ebp], -1
	je	$LN5@AssignExpl

; 2600 : 		{
; 2601 : 			m_aiGoodyHutUnitAssignments[uiGoodyPlots] = GoodyHutUnitAssignment(iUnitID, iStepPlotID);

	mov	edx, DWORD PTR _iUnitID$226620[ebp]
	mov	DWORD PTR $T235960[ebp], edx
	mov	eax, DWORD PTR _iStepPlotID$226621[ebp]
	mov	DWORD PTR $T235960[ebp+4], eax
	mov	ecx, DWORD PTR $T235960[ebp]
	mov	edx, DWORD PTR $T235960[ebp+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+100]
	mov	esi, DWORD PTR _uiGoodyPlots$226614[ebp]
	mov	DWORD PTR [eax+esi*8], ecx
	mov	DWORD PTR [eax+esi*8+4], edx

; 2602 : 
; 2603 : 			FFastVector<CvUnit*> tempExplorers = m_apExplorers;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	push	ecx
	lea	ecx, DWORD PTR _tempExplorers$226652[ebp]
	call	??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2604 : 			m_apExplorers.clear();

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 288				; 00000120H
	mov	DWORD PTR $T236203[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN149@AssignExpl
	mov	DWORD PTR _i$236199[ebp], 0
	jmp	SHORT $LN147@AssignExpl
$LN146@AssignExpl:
	mov	ecx, DWORD PTR _i$236199[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$236199[ebp], ecx
$LN147@AssignExpl:
	mov	edx, DWORD PTR $T236203[ebp]
	mov	eax, DWORD PTR _i$236199[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN149@AssignExpl
	jmp	SHORT $LN146@AssignExpl
$LN149@AssignExpl:
	mov	ecx, DWORD PTR $T236203[ebp]
	mov	DWORD PTR [ecx+4], 0

; 2605 : 			for(uint uiExplorer = 0; uiExplorer < tempExplorers.size(); uiExplorer++)

	mov	DWORD PTR _uiExplorer$226653[ebp], 0
	jmp	SHORT $LN4@AssignExpl
$LN3@AssignExpl:
	mov	edx, DWORD PTR _uiExplorer$226653[ebp]
	add	edx, 1
	mov	DWORD PTR _uiExplorer$226653[ebp], edx
$LN4@AssignExpl:
	mov	eax, DWORD PTR _tempExplorers$226652[ebp+4]
	mov	DWORD PTR $T236207[ebp], eax
	mov	ecx, DWORD PTR _uiExplorer$226653[ebp]
	cmp	ecx, DWORD PTR $T236207[ebp]
	jae	SHORT $LN2@AssignExpl

; 2606 : 			{
; 2607 : 				if(tempExplorers[uiExplorer]->GetID() != iUnitID)

	mov	edx, DWORD PTR _uiExplorer$226653[ebp]
	mov	eax, DWORD PTR _tempExplorers$226652[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T236211[ebp], ecx
	mov	edx, DWORD PTR $T236211[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T236220[ebp], ecx
	mov	edx, DWORD PTR $T236220[ebp]
	cmp	edx, DWORD PTR _iUnitID$226620[ebp]
	je	SHORT $LN1@AssignExpl

; 2608 : 				{
; 2609 : 					m_apExplorers.push_back(tempExplorers[uiExplorer]);

	mov	eax, DWORD PTR _uiExplorer$226653[ebp]
	mov	ecx, DWORD PTR _tempExplorers$226652[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 288				; 00000120H
	call	?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back
$LN1@AssignExpl:

; 2610 : 				}
; 2611 : 			}

	jmp	SHORT $LN3@AssignExpl
$LN2@AssignExpl:

; 2612 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tempExplorers$226652[ebp]
	call	??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
$LN5@AssignExpl:

; 2613 : 	}

	jmp	$LN17@AssignExpl
$LN16@AssignExpl:

; 2614 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aBestUnitList$[ebp]
	jmp	??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>
__unwindfunclet$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _tempExplorers$226652[ebp]
	jmp	??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
__ehhandler$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-708]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AssignExplorersToHuts@CvEconomicAI@@AAEXXZ ENDP	; CvEconomicAI::AssignExplorersToHuts
PUBLIC	??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
PUBLIC	?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back
PUBLIC	?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Alloc
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$1
__ehfuncinfo$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
_TEXT	SEGMENT
tv324 = -268						; size = 4
_this$ = -264						; size = 4
$T236517 = -232						; size = 4
_i$236509 = -228					; size = 4
$T236472 = -212						; size = 4
$T236460 = -208						; size = 4
$T236451 = -204						; size = 4
$T236442 = -200						; size = 4
$T236438 = -196						; size = 4
$T236434 = -192						; size = 4
$T236393 = -144						; size = 4
$T236384 = -140						; size = 4
$T236375 = -136						; size = 4
$T236371 = -132						; size = 4
$T236367 = -128						; size = 4
$T236360 = -124						; size = 4
$T236353 = -120						; size = 4
$T236349 = -116						; size = 4
$T236345 = -112						; size = 4
$T236338 = -108						; size = 4
$T236334 = -104						; size = 4
$T236327 = -100						; size = 4
$T236316 = -92						; size = 4
$T236301 = -88						; size = 8
_uiHut$226706 = -80					; size = 4
_tempHutIndices$226705 = -76				; size = 12
_bCanFindPath$226692 = -61				; size = 1
_iDistance$226688 = -60					; size = 4
_pGoodyPlot$226687 = -56				; size = 4
_iEstimateTurns$226689 = -52				; size = 4
_uiGoody$226682 = -48					; size = 4
_pUnit$226679 = -44					; size = 4
_uiHutIndex$226680 = -40				; size = 4
_iClosestEstimateTurns$226681 = -36			; size = 4
_uiExplorer$226675 = -32				; size = 4
_uiGoodyPlots$226671 = -28				; size = 4
_aiHutIndices$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ PROC	; CvEconomicAI::AssignHutsToExplorers, COMDAT
; _this$ = ecx

; 2618 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2619 : 	FFastVector<unsigned int> aiHutIndices;

	mov	DWORD PTR _aiHutIndices$[ebp], 0
	mov	DWORD PTR _aiHutIndices$[ebp+4], 0
	mov	DWORD PTR _aiHutIndices$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	ecx, DWORD PTR _aiHutIndices$[ebp]
	call	?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Alloc
	mov	DWORD PTR _aiHutIndices$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2620 : 
; 2621 : 	// Create temporary list of huts
; 2622 : 	for(uint uiGoodyPlots = 0; uiGoodyPlots < m_aiGoodyHutPlots.size(); uiGoodyPlots++)

	mov	DWORD PTR _uiGoodyPlots$226671[ebp], 0
	jmp	SHORT $LN18@AssignHuts
$LN17@AssignHuts:
	mov	eax, DWORD PTR _uiGoodyPlots$226671[ebp]
	add	eax, 1
	mov	DWORD PTR _uiGoodyPlots$226671[ebp], eax
$LN18@AssignHuts:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR $T236316[ebp], edx
	mov	eax, DWORD PTR _uiGoodyPlots$226671[ebp]
	cmp	eax, DWORD PTR $T236316[ebp]
	jae	SHORT $LN16@AssignHuts

; 2623 : 	{
; 2624 : 		aiHutIndices.push_back(uiGoodyPlots);

	lea	ecx, DWORD PTR _uiGoodyPlots$226671[ebp]
	push	ecx
	lea	ecx, DWORD PTR _aiHutIndices$[ebp]
	call	?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back

; 2625 : 	}

	jmp	SHORT $LN17@AssignHuts
$LN16@AssignHuts:

; 2626 : 
; 2627 : 	for(uint uiExplorer = 0; uiExplorer < m_apExplorers.size(); uiExplorer++)

	mov	DWORD PTR _uiExplorer$226675[ebp], 0
	jmp	SHORT $LN15@AssignHuts
$LN14@AssignHuts:
	mov	edx, DWORD PTR _uiExplorer$226675[ebp]
	add	edx, 1
	mov	DWORD PTR _uiExplorer$226675[ebp], edx
$LN15@AssignHuts:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	DWORD PTR $T236327[ebp], ecx
	mov	edx, DWORD PTR _uiExplorer$226675[ebp]
	cmp	edx, DWORD PTR $T236327[ebp]
	jae	$LN13@AssignHuts

; 2628 : 	{
; 2629 : 		CvUnit* pUnit = m_apExplorers[uiExplorer];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	mov	edx, DWORD PTR _uiExplorer$226675[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _pUnit$226679[ebp], eax

; 2630 : 		uint uiHutIndex = MAX_INT;

	mov	DWORD PTR _uiHutIndex$226680[ebp], 2147483647 ; 7fffffffH

; 2631 : 		int iClosestEstimateTurns = MAX_INT;

	mov	DWORD PTR _iClosestEstimateTurns$226681[ebp], 2147483647 ; 7fffffffH

; 2632 : 
; 2633 : 		for(uint uiGoody = 0; uiGoody < aiHutIndices.size(); uiGoody++)

	mov	DWORD PTR _uiGoody$226682[ebp], 0
	jmp	SHORT $LN12@AssignHuts
$LN11@AssignHuts:
	mov	ecx, DWORD PTR _uiGoody$226682[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiGoody$226682[ebp], ecx
$LN12@AssignHuts:
	mov	edx, DWORD PTR _aiHutIndices$[ebp+4]
	mov	DWORD PTR $T236334[ebp], edx
	mov	eax, DWORD PTR _uiGoody$226682[ebp]
	cmp	eax, DWORD PTR $T236334[ebp]
	jae	$LN10@AssignHuts

; 2634 : 		{
; 2635 : 			if(m_aiGoodyHutPlots[aiHutIndices[uiGoody]] == -1)

	mov	ecx, DWORD PTR _uiGoody$226682[ebp]
	mov	edx, DWORD PTR _aiHutIndices$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR $T236338[ebp], eax
	mov	ecx, DWORD PTR $T236338[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	cmp	DWORD PTR [ecx+edx*4], -1
	jne	SHORT $LN9@AssignHuts

; 2636 : 			{
; 2637 : 				continue;

	jmp	SHORT $LN11@AssignHuts
$LN9@AssignHuts:

; 2638 : 			}
; 2639 : 
; 2640 : 			CvPlot* pGoodyPlot = GC.getMap().plotByIndex(m_aiGoodyHutPlots[aiHutIndices[uiGoody]]);

	mov	edx, DWORD PTR _uiGoody$226682[ebp]
	mov	eax, DWORD PTR _aiHutIndices$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T236345[ebp], ecx
	mov	edx, DWORD PTR $T236345[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T236349[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236353[ebp], ecx
	mov	edx, DWORD PTR $T236349[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T236367[ebp], eax
	cmp	DWORD PTR $T236367[ebp], 0
	jl	SHORT $LN55@AssignHuts
	mov	ecx, DWORD PTR $T236353[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T236360[ebp], edx
	mov	eax, DWORD PTR $T236367[ebp]
	cmp	eax, DWORD PTR $T236360[ebp]
	jge	SHORT $LN55@AssignHuts
	mov	ecx, DWORD PTR $T236367[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T236353[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv324[ebp], ecx
	jmp	SHORT $LN53@AssignHuts
$LN55@AssignHuts:
	mov	DWORD PTR tv324[ebp], 0
$LN53@AssignHuts:
	mov	eax, DWORD PTR tv324[ebp]
	mov	DWORD PTR _pGoodyPlot$226687[ebp], eax

; 2641 : 			int iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY());

	mov	ecx, DWORD PTR _pGoodyPlot$226687[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR $T236371[ebp], edx
	mov	eax, DWORD PTR _pGoodyPlot$226687[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR $T236375[ebp], ecx
	mov	edx, DWORD PTR _pUnit$226679[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T236384[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226679[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T236393[ebp], edx
	mov	eax, DWORD PTR $T236371[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236375[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236384[ebp]
	push	edx
	mov	eax, DWORD PTR $T236393[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iDistance$226688[ebp], eax

; 2642 : 
; 2643 : 			int iEstimateTurns = MAX_INT;

	mov	DWORD PTR _iEstimateTurns$226689[ebp], 2147483647 ; 7fffffffH

; 2644 : 			if(pUnit->maxMoves() >= 1)

	mov	ecx, DWORD PTR _pUnit$226679[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cmp	eax, 1
	jl	SHORT $LN8@AssignHuts

; 2645 : 			{
; 2646 : 				iEstimateTurns = iDistance / (pUnit->maxMoves() / GC.getMOVE_DENOMINATOR());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6236
	mov	DWORD PTR $T236434[ebp], ecx
	mov	ecx, DWORD PTR _pUnit$226679[ebp]
	call	?maxMoves@CvUnit@@QBEHXZ		; CvUnit::maxMoves
	cdq
	idiv	DWORD PTR $T236434[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _iDistance$226688[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _iEstimateTurns$226689[ebp], eax
$LN8@AssignHuts:

; 2647 : 			}
; 2648 : 
; 2649 : 			if(iEstimateTurns < iClosestEstimateTurns)

	mov	edx, DWORD PTR _iEstimateTurns$226689[ebp]
	cmp	edx, DWORD PTR _iClosestEstimateTurns$226681[ebp]
	jge	$LN7@AssignHuts

; 2650 : 			{
; 2651 : 				// Now check path
; 2652 : 				bool bCanFindPath = GC.getPathFinder().GenerateUnitPath(pUnit, pUnit->getX(), pUnit->getY(), pGoodyPlot->getX(), pGoodyPlot->getY(), MOVE_TERRITORY_NO_ENEMY | MOVE_MAXIMIZE_EXPLORE | MOVE_UNITS_IGNORE_DANGER /*iFlags*/, true/*bReuse*/);

	mov	eax, DWORD PTR _pGoodyPlot$226687[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T236438[ebp], ecx
	mov	edx, DWORD PTR _pGoodyPlot$226687[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T236442[ebp], eax
	mov	ecx, DWORD PTR _pUnit$226679[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR $T236451[ebp], edx
	mov	eax, DWORD PTR _pUnit$226679[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T236460[ebp], ecx
	push	1
	push	138					; 0000008aH
	mov	edx, DWORD PTR $T236438[ebp]
	push	edx
	mov	eax, DWORD PTR $T236442[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236451[ebp]
	push	ecx
	mov	edx, DWORD PTR $T236460[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnit$226679[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?GenerateUnitPath@CvTwoLayerPathFinder@@QAE_NPBVCvUnit@@HHHHH_N@Z ; CvTwoLayerPathFinder::GenerateUnitPath
	mov	BYTE PTR _bCanFindPath$226692[ebp], al

; 2653 : 				if(bCanFindPath)

	movzx	ecx, BYTE PTR _bCanFindPath$226692[ebp]
	test	ecx, ecx
	je	SHORT $LN7@AssignHuts

; 2654 : 				{
; 2655 : 					iClosestEstimateTurns = iEstimateTurns;

	mov	edx, DWORD PTR _iEstimateTurns$226689[ebp]
	mov	DWORD PTR _iClosestEstimateTurns$226681[ebp], edx

; 2656 : 					uiHutIndex = aiHutIndices[uiGoody];

	mov	eax, DWORD PTR _uiGoody$226682[ebp]
	mov	ecx, DWORD PTR _aiHutIndices$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _uiHutIndex$226680[ebp], edx
$LN7@AssignHuts:

; 2657 : 				}
; 2658 : 			}
; 2659 : 		}

	jmp	$LN11@AssignHuts
$LN10@AssignHuts:

; 2660 : 
; 2661 : 		if(uiHutIndex != MAX_INT)

	cmp	DWORD PTR _uiHutIndex$226680[ebp], 2147483647 ; 7fffffffH
	je	$LN5@AssignHuts

; 2662 : 		{
; 2663 : 			m_aiGoodyHutUnitAssignments[uiHutIndex] = GoodyHutUnitAssignment( pUnit->GetID(), -1);

	mov	eax, DWORD PTR _pUnit$226679[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR $T236472[ebp], ecx
	mov	edx, DWORD PTR $T236472[ebp]
	mov	DWORD PTR $T236301[ebp], edx
	mov	DWORD PTR $T236301[ebp+4], -1
	mov	eax, DWORD PTR $T236301[ebp]
	mov	ecx, DWORD PTR $T236301[ebp+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+100]
	mov	esi, DWORD PTR _uiHutIndex$226680[ebp]
	mov	DWORD PTR [edx+esi*8], eax
	mov	DWORD PTR [edx+esi*8+4], ecx

; 2664 : 
; 2665 : 			FFastVector<unsigned int> tempHutIndices = aiHutIndices;

	lea	eax, DWORD PTR _aiHutIndices$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempHutIndices$226705[ebp]
	call	??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2666 : 			aiHutIndices.clear();

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN136@AssignHuts
	mov	DWORD PTR _i$236509[ebp], 0
	jmp	SHORT $LN134@AssignHuts
$LN133@AssignHuts:
	mov	edx, DWORD PTR _i$236509[ebp]
	add	edx, 1
	mov	DWORD PTR _i$236509[ebp], edx
$LN134@AssignHuts:
	mov	eax, DWORD PTR _i$236509[ebp]
	cmp	eax, DWORD PTR _aiHutIndices$[ebp+4]
	jae	SHORT $LN136@AssignHuts
	jmp	SHORT $LN133@AssignHuts
$LN136@AssignHuts:
	mov	DWORD PTR _aiHutIndices$[ebp+4], 0

; 2667 : 			for(uint uiHut = 0; uiHut < tempHutIndices.size(); uiHut++)

	mov	DWORD PTR _uiHut$226706[ebp], 0
	jmp	SHORT $LN4@AssignHuts
$LN3@AssignHuts:
	mov	ecx, DWORD PTR _uiHut$226706[ebp]
	add	ecx, 1
	mov	DWORD PTR _uiHut$226706[ebp], ecx
$LN4@AssignHuts:
	mov	edx, DWORD PTR _tempHutIndices$226705[ebp+4]
	mov	DWORD PTR $T236517[ebp], edx
	mov	eax, DWORD PTR _uiHut$226706[ebp]
	cmp	eax, DWORD PTR $T236517[ebp]
	jae	SHORT $LN2@AssignHuts

; 2668 : 			{
; 2669 : 				if(tempHutIndices[uiHut] != uiHutIndex)

	mov	ecx, DWORD PTR _uiHut$226706[ebp]
	mov	edx, DWORD PTR _tempHutIndices$226705[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, DWORD PTR _uiHutIndex$226680[ebp]
	je	SHORT $LN1@AssignHuts

; 2670 : 				{
; 2671 : 					aiHutIndices.push_back(tempHutIndices[uiHut]);

	mov	ecx, DWORD PTR _uiHut$226706[ebp]
	mov	edx, DWORD PTR _tempHutIndices$226705[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	lea	ecx, DWORD PTR _aiHutIndices$[ebp]
	call	?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back
$LN1@AssignHuts:

; 2672 : 				}
; 2673 : 			}

	jmp	SHORT $LN3@AssignHuts
$LN2@AssignHuts:

; 2674 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tempHutIndices$226705[ebp]
	call	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
$LN5@AssignHuts:

; 2675 : 	}

	jmp	$LN14@AssignHuts
$LN13@AssignHuts:

; 2676 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _aiHutIndices$[ebp]
	call	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$2:
	lea	ecx, DWORD PTR _aiHutIndices$[ebp]
	jmp	??1?$BaseVector@I$0A@@@QAE@XZ		; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$0:
	lea	ecx, DWORD PTR _aiHutIndices$[ebp]
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__unwindfunclet$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ$1:
	lea	ecx, DWORD PTR _tempHutIndices$226705[ebp]
	jmp	??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
__ehhandler$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?AssignHutsToExplorers@CvEconomicAI@@AAEXXZ ENDP	; CvEconomicAI::AssignHutsToExplorers
PUBLIC	??_C@_0M@INLNKHPF@UNIT_WORKER?$AA@		; `string'
EXTRN	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ:PROC ; CvUnit::getSpecialUnitType
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
;	COMDAT ??_C@_0M@INLNKHPF@UNIT_WORKER?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovariable.h
CONST	SEGMENT
??_C@_0M@INLNKHPF@UNIT_WORKER?$AA@ DB 'UNIT_WORKER', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_eWorker$226720 = -12					; size = 4
_pLoopUnit$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ PROC	; CvEconomicAI::FindWorkerToScrap, COMDAT
; _this$ = ecx

; 2679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2680 : 	CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$[ebp], 0

; 2681 : 	int iUnitLoop = 0;

	mov	DWORD PTR _iUnitLoop$[ebp], 0

; 2682 : 
; 2683 : 	// Look at map for loose workers
; 2684 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN5@FindWorker
$LN4@FindWorker:
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN5@FindWorker:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN3@FindWorker

; 2685 : 	{
; 2686 : 		if(!pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	jne	SHORT $LN2@FindWorker

; 2687 : 		{
; 2688 : 			continue;

	jmp	SHORT $LN4@FindWorker
$LN2@FindWorker:

; 2689 : 		}
; 2690 : 		UnitTypes eWorker = (UnitTypes) GC.getInfoTypeForString("UNIT_WORKER");

	push	0
	push	OFFSET ??_C@_0M@INLNKHPF@UNIT_WORKER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eWorker$226720[ebp], eax

; 2691 : 		if(pLoopUnit->getDomainType() == DOMAIN_LAND && pLoopUnit->getUnitType() == eWorker && !pLoopUnit->IsCombatUnit() && pLoopUnit->getSpecialUnitType() == NO_SPECIALUNIT)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN1@FindWorker
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	cmp	eax, DWORD PTR _eWorker$226720[ebp]
	jne	SHORT $LN1@FindWorker
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1044], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN1@FindWorker
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getSpecialUnitType@CvUnit@@QBE?AW4SpecialUnitTypes@@XZ ; CvUnit::getSpecialUnitType
	cmp	eax, -1
	jne	SHORT $LN1@FindWorker

; 2692 : 		{
; 2693 : 			return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN6@FindWorker
$LN1@FindWorker:

; 2694 : 		}
; 2695 : 	}

	jmp	SHORT $LN4@FindWorker
$LN3@FindWorker:

; 2696 : 
; 2697 : 	return NULL;

	xor	eax, eax
$LN6@FindWorker:

; 2698 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindWorkerToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ENDP	; CvEconomicAI::FindWorkerToScrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_eArch$226733 = -12					; size = 4
_pLoopUnit$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ PROC ; CvEconomicAI::FindArchaeologistToScrap, COMDAT
; _this$ = ecx

; 2701 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2702 : 	CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$[ebp], 0

; 2703 : 	int iUnitLoop = 0;

	mov	DWORD PTR _iUnitLoop$[ebp], 0

; 2704 : 
; 2705 : 	// Look at map for loose archaeologists
; 2706 : 	for(pLoopUnit = m_pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN5@FindArchae
$LN4@FindArchae:
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN5@FindArchae:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN3@FindArchae

; 2707 : 	{
; 2708 : 		if(!pLoopUnit)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	jne	SHORT $LN2@FindArchae

; 2709 : 		{
; 2710 : 			continue;

	jmp	SHORT $LN4@FindArchae
$LN2@FindArchae:

; 2711 : 		}
; 2712 : 		UnitTypes eArch = (UnitTypes) GC.getInfoTypeForString("UNIT_ARCHAEOLOGIST", true);

	push	1
	push	OFFSET ??_C@_0BD@FGIPIDOH@UNIT_ARCHAEOLOGIST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eArch$226733[ebp], eax

; 2713 : 		if(pLoopUnit->getUnitType() == eArch)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	cmp	eax, DWORD PTR _eArch$226733[ebp]
	jne	SHORT $LN1@FindArchae

; 2714 : 		{
; 2715 : 			return pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	jmp	SHORT $LN6@FindArchae
$LN1@FindArchae:

; 2716 : 		}
; 2717 : 	}

	jmp	SHORT $LN4@FindArchae
$LN3@FindArchae:

; 2718 : 
; 2719 : 	return NULL;

	xor	eax, eax
$LN6@FindArchae:

; 2720 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindArchaeologistToScrap@CvEconomicAI@@AAEPAVCvUnit@@XZ ENDP ; CvEconomicAI::FindArchaeologistToScrap
_TEXT	ENDS
PUBLIC	??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@		; `string'
PUBLIC	??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@	; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@	; `string'
PUBLIC	??_C@_0L@EJOHMCKE@TechAILog_?$AA@		; `string'
PUBLIC	??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_06NHKAIDD@?$CF03d?0?5?$AA@		; `string'
PUBLIC	??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@		; `string'
PUBLIC	??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@	; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z:PROC ; CvGlobals::getEconomicAIStrategyInfo
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
;	COMDAT ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@ DB 'TechAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@
CONST	SEGMENT
??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@ DB 'CityStrategyAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@
CONST	SEGMENT
??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@ DB 'CityStrategyAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
CONST	SEGMENT
??_C@_0L@EJOHMCKE@TechAILog_?$AA@ DB 'TechAILog_', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@ DB '%s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
CONST	SEGMENT
??_C@_06NHKAIDD@?$CF03d?0?5?$AA@ DB '%03d, ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@
CONST	SEGMENT
??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@ DB 'FlavorAILog_', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@
CONST	SEGMENT
??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@ DB 'FlavorAILog.csv', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$15
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
_TEXT	SEGMENT
tv343 = -632						; size = 4
tv328 = -628						; size = 4
tv311 = -624						; size = 4
tv598 = -620						; size = 4
tv379 = -616						; size = 4
tv597 = -612						; size = 4
tv377 = -608						; size = 4
tv596 = -604						; size = 4
tv375 = -600						; size = 4
tv79 = -596						; size = 4
tv387 = -592						; size = 4
tv237 = -588						; size = 4
tv400 = -584						; size = 4
tv368 = -580						; size = 4
tv424 = -576						; size = 4
tv364 = -572						; size = 4
tv435 = -568						; size = 4
tv140 = -564						; size = 4
tv450 = -560						; size = 4
tv359 = -556						; size = 4
tv493 = -552						; size = 4
tv402 = -548						; size = 4
tv389 = -544						; size = 4
_this$ = -540						; size = 4
$T236739 = -536						; size = 4
$T236735 = -532						; size = 4
$T236727 = -528						; size = 4
$T236723 = -524						; size = 4
$T236719 = -520						; size = 4
$T236711 = -516						; size = 4
$T236703 = -512						; size = 4
$T236699 = -508						; size = 4
$T236695 = -504						; size = 4
$T236691 = -500						; size = 4
$T236672 = -496						; size = 4
$T236664 = -492						; size = 4
$T236660 = -488						; size = 4
$T236648 = -484						; size = 4
$T236623 = -480						; size = 28
$T236622 = -452						; size = 28
$T236621 = -424						; size = 28
$T236620 = -396						; size = 28
$T236619 = -368						; size = 28
$T236618 = -340						; size = 28
$T236617 = -312						; size = 28
$T236616 = -284						; size = 28
$T236615 = -256						; size = 28
$T236614 = -228						; size = 28
_cityName$226763 = -200					; size = 28
_pLoopCity$226764 = -172				; size = 4
_iLoop$226765 = -168					; size = 4
_strTemp$226757 = -164					; size = 28
_playerName$226742 = -136				; size = 28
_strOutBuf$226754 = -108				; size = 28
_pEconomicAIStrategyEntry$226755 = -80			; size = 4
_strLogName$226743 = -76				; size = 28
_pLog$226749 = -48					; size = 4
_strBaseString$226750 = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eStrategy$ = 8						; size = 4
_bValue$ = 12						; size = 1
?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z PROC ; CvEconomicAI::LogStrategy, COMDAT
; _this$ = ecx

; 2724 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 620				; 0000026cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 2725 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	$LN9@LogStrateg
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@LogStrateg

; 2726 : 	{
; 2727 : 		// Find the name of this civ and city
; 2728 : 		CvString playerName = GetPlayer()->getCivilizationShortDescription();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	mov	DWORD PTR $T236648[ebp], eax
	cmp	DWORD PTR $T236648[ebp], 0
	je	SHORT $LN29@LogStrateg
	mov	edx, DWORD PTR $T236648[ebp]
	mov	DWORD PTR tv389[ebp], edx
	jmp	SHORT $LN30@LogStrateg
$LN29@LogStrateg:
	mov	DWORD PTR tv389[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN30@LogStrateg:
	mov	eax, DWORD PTR tv389[ebp]
	push	eax
	lea	ecx, DWORD PTR _playerName$226742[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2729 : 
; 2730 : 		// Open the log file
; 2731 : 		CvString strLogName = "FlavorAILog.csv";

	mov	ecx, OFFSET ??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@
	test	ecx, ecx
	je	SHORT $LN34@LogStrateg
	mov	DWORD PTR tv402[ebp], OFFSET ??_C@_0BA@PDOPNOIB@FlavorAILog?4csv?$AA@
	jmp	SHORT $LN35@LogStrateg
$LN34@LogStrateg:
	mov	DWORD PTR tv402[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN35@LogStrateg:
	mov	edx, DWORD PTR tv402[ebp]
	push	edx
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2732 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	eax, al
	test	eax, eax
	je	$LN7@LogStrateg

; 2733 : 		{
; 2734 : 			strLogName = "FlavorAILog_" + playerName + ".csv";

	lea	ecx, DWORD PTR _playerName$226742[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@IDMPFJHH@FlavorAILog_?$AA@
	lea	edx, DWORD PTR $T236614[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv493[ebp], eax
	mov	eax, DWORD PTR tv493[ebp]
	mov	DWORD PTR tv359[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	ecx, DWORD PTR tv359[ebp]
	push	ecx
	lea	edx, DWORD PTR $T236615[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv450[ebp], eax
	mov	eax, DWORD PTR tv450[ebp]
	mov	DWORD PTR $T236660[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T236660[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T236615[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236614[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@LogStrateg:

; 2735 : 		}
; 2736 : 
; 2737 : 		FILogFile* pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv140[ebp], eax
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236664[ebp], eax
	push	0
	push	1
	mov	ecx, DWORD PTR $T236664[ebp]
	push	ecx
	mov	edx, DWORD PTR tv140[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv140[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _pLog$226749[ebp], eax

; 2738 : 
; 2739 : 		// Get the leading info for this line
; 2740 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$226750[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 2741 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236672[ebp], eax
	mov	ecx, DWORD PTR $T236672[ebp]
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	push	OFFSET ??_C@_06NHKAIDD@?$CF03d?0?5?$AA@
	lea	ecx, DWORD PTR _strBaseString$226750[ebp]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 12					; 0000000cH

; 2742 : 		strBaseString += playerName + ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	edx, DWORD PTR _playerName$226742[ebp]
	push	edx
	lea	eax, DWORD PTR $T236616[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv435[ebp], eax
	mov	ecx, DWORD PTR tv435[ebp]
	mov	DWORD PTR tv364[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv364[ebp]
	push	edx
	lea	ecx, DWORD PTR _strBaseString$226750[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T236616[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2743 : 
; 2744 : 		CvString strOutBuf = strBaseString;

	lea	eax, DWORD PTR _strBaseString$226750[ebp]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 2745 : 
; 2746 : 		// Strategy Info
; 2747 : 		CvEconomicAIStrategyXMLEntry* pEconomicAIStrategyEntry = GC.getEconomicAIStrategyInfo(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getEconomicAIStrategyInfo@CvGlobals@@QAEPAVCvEconomicAIStrategyXMLEntry@@W4EconomicAIStrategyTypes@@@Z ; CvGlobals::getEconomicAIStrategyInfo
	mov	DWORD PTR _pEconomicAIStrategyEntry$226755[ebp], eax

; 2748 : 		if(pEconomicAIStrategyEntry != NULL)

	cmp	DWORD PTR _pEconomicAIStrategyEntry$226755[ebp], 0
	je	SHORT $LN6@LogStrateg

; 2749 : 		{
; 2750 : 			CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$226757[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 2751 : 			strTemp.Format("%s, %d", pEconomicAIStrategyEntry->GetType(), bValue);

	movzx	edx, BYTE PTR _bValue$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEconomicAIStrategyEntry$226755[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
	lea	eax, DWORD PTR _strTemp$226757[ebp]
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2752 : 			strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$226757[ebp]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 2753 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _strTemp$226757[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@LogStrateg:

; 2754 : 
; 2755 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236691[ebp], eax
	mov	edx, DWORD PTR $T236691[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$226749[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$226749[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8

; 2756 : 
; 2757 : 		// Also - write to Other Logs, so that we know what the player is doing in there as well
; 2758 : 
; 2759 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@LogStrateg

; 2760 : 		{
; 2761 : 			strLogName = "TechAILog_" + playerName + ".csv";

	lea	edx, DWORD PTR _playerName$226742[ebp]
	push	edx
	push	OFFSET ??_C@_0L@EJOHMCKE@TechAILog_?$AA@
	lea	eax, DWORD PTR $T236617[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv424[ebp], eax
	mov	ecx, DWORD PTR tv424[ebp]
	mov	DWORD PTR tv368[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	edx, DWORD PTR tv368[ebp]
	push	edx
	lea	eax, DWORD PTR $T236618[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv400[ebp], eax
	mov	ecx, DWORD PTR tv400[ebp]
	mov	DWORD PTR $T236695[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR $T236695[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T236618[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T236617[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2762 : 			pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv237[ebp], eax
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236699[ebp], eax
	push	0
	push	1
	mov	edx, DWORD PTR $T236699[ebp]
	push	edx
	mov	eax, DWORD PTR tv237[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv237[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226749[ebp], eax

; 2763 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236703[ebp], eax
	mov	ecx, DWORD PTR $T236703[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226749[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226749[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 2764 : 
; 2765 : 			CvString cityName;

	lea	ecx, DWORD PTR _cityName$226763[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 2766 : 
; 2767 : 			CvCity* pLoopCity;
; 2768 : 			int iLoop;
; 2769 : 
; 2770 : 			for(pLoopCity = GetPlayer()->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GetPlayer()->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$226765[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226764[ebp], eax
	jmp	SHORT $LN4@LogStrateg
$LN3@LogStrateg:
	push	0
	lea	ecx, DWORD PTR _iLoop$226765[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayer@CvEconomicAI@@QAEPAVCvPlayer@@XZ ; CvEconomicAI::GetPlayer
	mov	ecx, eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226764[ebp], eax
$LN4@LogStrateg:
	cmp	DWORD PTR _pLoopCity$226764[ebp], 0
	je	$LN2@LogStrateg

; 2771 : 			{
; 2772 : 				cityName = pLoopCity->getName();

	lea	edx, DWORD PTR $T236619[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$226764[ebp]
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	DWORD PTR tv387[ebp], eax
	mov	eax, DWORD PTR tv387[ebp]
	mov	DWORD PTR $T236711[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR $T236711[ebp]
	push	ecx
	lea	ecx, DWORD PTR _cityName$226763[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T236619[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2773 : 				strLogName = "CityStrategyAILog_" + playerName + "_" + cityName + ".csv";

	lea	edx, DWORD PTR _playerName$226742[ebp]
	push	edx
	push	OFFSET ??_C@_0BD@HCEGOALD@CityStrategyAILog_?$AA@
	lea	eax, DWORD PTR $T236620[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv375[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	push	OFFSET ??_C@_01IDAFKMJL@_?$AA@
	mov	edx, DWORD PTR tv375[ebp]
	push	edx
	lea	eax, DWORD PTR $T236621[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv596[ebp], eax
	mov	ecx, DWORD PTR tv596[ebp]
	mov	DWORD PTR tv377[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	lea	edx, DWORD PTR _cityName$226763[ebp]
	push	edx
	mov	eax, DWORD PTR tv377[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236622[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv597[ebp], eax
	mov	edx, DWORD PTR tv597[ebp]
	mov	DWORD PTR tv379[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	push	OFFSET ??_C@_04EBGNMJBD@?4csv?$AA@
	mov	eax, DWORD PTR tv379[ebp]
	push	eax
	lea	ecx, DWORD PTR $T236623[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv598[ebp], eax
	mov	edx, DWORD PTR tv598[ebp]
	mov	DWORD PTR $T236719[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR $T236719[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR $T236623[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	lea	ecx, DWORD PTR $T236622[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	lea	ecx, DWORD PTR $T236621[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T236620[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2774 : 				pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv311[ebp], eax
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236723[ebp], eax
	push	0
	push	1
	mov	eax, DWORD PTR $T236723[ebp]
	push	eax
	mov	ecx, DWORD PTR tv311[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv311[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226749[ebp], eax

; 2775 : 				pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236727[ebp], eax
	mov	ecx, DWORD PTR $T236727[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226749[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226749[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 2776 : 			}

	jmp	$LN3@LogStrateg
$LN2@LogStrateg:

; 2777 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _cityName$226763[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2778 : 		else

	jmp	$LN1@LogStrateg
$LN5@LogStrateg:

; 2779 : 		{
; 2780 : 			pLog = LOGFILEMGR.GetLog("CityStrategyAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv328[ebp], eax
	push	0
	push	1
	push	OFFSET ??_C@_0BG@MECKMOJJ@CityStrategyAILog?4csv?$AA@
	mov	eax, DWORD PTR tv328[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv328[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226749[ebp], eax

; 2781 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236735[ebp], eax
	mov	ecx, DWORD PTR $T236735[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226749[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226749[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8

; 2782 : 			pLog = LOGFILEMGR.GetLog("TechAILog.csv", FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv343[ebp], eax
	push	0
	push	1
	push	OFFSET ??_C@_0O@NLCAKOAJ@TechAILog?4csv?$AA@
	mov	eax, DWORD PTR tv343[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv343[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$226749[ebp], eax

; 2783 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T236739[ebp], eax
	mov	ecx, DWORD PTR $T236739[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLog$226749[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pLog$226749[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	call	edx
	add	esp, 8
$LN1@LogStrateg:

; 2784 : 		}
; 2785 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _strBaseString$226750[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _playerName$226742[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@LogStrateg:

; 2786 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _playerName$226742[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$1:
	lea	ecx, DWORD PTR _strLogName$226743[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$2:
	lea	ecx, DWORD PTR $T236614[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$3:
	lea	ecx, DWORD PTR $T236615[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$4:
	lea	ecx, DWORD PTR _strBaseString$226750[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$5:
	lea	ecx, DWORD PTR $T236616[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$6:
	lea	ecx, DWORD PTR _strOutBuf$226754[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$7:
	lea	ecx, DWORD PTR _strTemp$226757[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$8:
	lea	ecx, DWORD PTR $T236617[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$9:
	lea	ecx, DWORD PTR $T236618[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$10:
	lea	ecx, DWORD PTR _cityName$226763[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$11:
	lea	ecx, DWORD PTR $T236619[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$12:
	lea	ecx, DWORD PTR $T236620[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$13:
	lea	ecx, DWORD PTR $T236621[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$14:
	lea	ecx, DWORD PTR $T236622[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z$15:
	lea	ecx, DWORD PTR $T236623[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-624]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogStrategy@CvEconomicAI@@AAEXW4EconomicAIStrategyTypes@@_N@Z ENDP ; CvEconomicAI::LogStrategy
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
PUBLIC	??_C@_0GC@BOGDCENO@Disbanding?5worker?4?5?$CFs?0?5X?3?5?$CFd?0?5Y?3@ ; `string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0GC@BOGDCENO@Disbanding?5worker?4?5?$CFs?0?5X?3?5?$CFd?0?5Y?3@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
CONST	SEGMENT
??_C@_0GC@BOGDCENO@Disbanding?5worker?4?5?$CFs?0?5X?3?5?$CFd?0?5Y?3@ DB 'D'
	DB	'isbanding worker. %s, X: %d, Y: %d, iNumWorkers: %d, iNumCiti'
	DB	'es: %d, improved/valid plots: %d/%d', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$2
__ehfuncinfo$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
xdata$x	ENDS
;	COMDAT ?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
_TEXT	SEGMENT
tv151 = -104						; size = 4
_this$ = -100						; size = 4
$T236815 = -96						; size = 4
$T236811 = -92						; size = 4
$T236807 = -88						; size = 4
$T236798 = -84						; size = 4
$T236794 = -80						; size = 4
$T236785 = -76						; size = 4
$T236765 = -72						; size = 28
_strLogString$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_iNumWorkers$ = 16					; size = 4
_iNumCities$ = 20					; size = 4
_iNumImprovedPlots$ = 24				; size = 4
_iNumValidPlots$ = 28					; size = 4
?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z PROC ; CvEconomicAI::LogScrapUnit, COMDAT
; _this$ = ecx

; 2790 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2791 : 	if(!GC.getLogging() || !GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@LogScrapUn
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@LogScrapUn
$LN1@LogScrapUn:

; 2792 : 	{
; 2793 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN9@LogScrapUn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN9@LogScrapUn:
	jmp	$LN3@LogScrapUn
$LN2@LogScrapUn:

; 2794 : 	}
; 2795 : 
; 2796 : 	CvString strLogString;

	lea	ecx, DWORD PTR _strLogString$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2797 : 	strLogString.Format("Disbanding worker. %s, X: %d, Y: %d, iNumWorkers: %d, iNumCities: %d, improved/valid plots: %d/%d", pUnit->getName().GetCString(), pUnit->getX(), pUnit->getY(), iNumWorkers, iNumCities, iNumImprovedPlots, iNumValidPlots);

	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T236811[ebp], edx
	lea	eax, DWORD PTR $T236765[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236811[ebp]
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR tv151[ebp]
	mov	DWORD PTR $T236815[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T236785[ebp], edx
	mov	eax, DWORD PTR $T236785[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR $T236794[ebp], ecx
	mov	edx, DWORD PTR _pUnit$[ebp]
	mov	DWORD PTR $T236798[ebp], edx
	mov	eax, DWORD PTR $T236798[ebp]
	mov	ecx, DWORD PTR [eax+76]
	mov	DWORD PTR $T236807[ebp], ecx
	mov	edx, DWORD PTR _iNumValidPlots$[ebp]
	push	edx
	mov	eax, DWORD PTR _iNumImprovedPlots$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iNumCities$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iNumWorkers$[ebp]
	push	edx
	mov	eax, DWORD PTR $T236794[ebp]
	push	eax
	mov	ecx, DWORD PTR $T236807[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T236815[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0GC@BOGDCENO@Disbanding?5worker?4?5?$CFs?0?5X?3?5?$CFd?0?5Y?3@
	lea	edx, DWORD PTR _strLogString$[ebp]
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 36					; 00000024H
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T236765[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2798 : 	m_pPlayer->GetHomelandAI()->LogHomelandMessage(strLogString);

	lea	eax, DWORD PTR _strLogString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?GetHomelandAI@CvPlayer@@QBEPAVCvHomelandAI@@XZ ; CvPlayer::GetHomelandAI
	mov	ecx, eax
	call	?LogHomelandMessage@CvHomelandAI@@QAEXAAVCvString@@@Z ; CvHomelandAI::LogHomelandMessage

; 2799 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _strLogString$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR _pUnit$[ebp], 0
	je	SHORT $LN3@LogScrapUn
	mov	ecx, DWORD PTR _pUnit$[ebp]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN3@LogScrapUn:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$1:
	lea	ecx, DWORD PTR _strLogString$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z$2:
	lea	ecx, DWORD PTR $T236765[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogScrapUnit@CvEconomicAI@@AAEXV?$FObjectHandle@VCvUnit@@@@HHHH@Z ENDP ; CvEconomicAI::LogScrapUnit
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
$T236841 = -4						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z PROC ; operator<<, COMDAT

; 2802 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2803 : 	saveTo << (int)readFrom.m_eType;

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T236841[ebp], ecx
	lea	edx, DWORD PTR $T236841[ebp]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2804 : 	saveTo << readFrom.m_iAmount;

	mov	eax, DWORD PTR _readFrom$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2805 : 	saveTo << readFrom.m_iPriority;

	mov	ecx, DWORD PTR _readFrom$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 2806 : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 2807 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvPurchaseRequest@@@Z ENDP ; operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
_iTemp$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z PROC ; operator>>, COMDAT

; 2810 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2811 : 	int iTemp;
; 2812 : 	loadFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2813 : 	writeTo.m_eType = (PurchaseType)iTemp;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 2814 : 	loadFrom >> writeTo.m_iAmount;

	mov	eax, DWORD PTR _writeTo$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2815 : 	loadFrom >> writeTo.m_iPriority;

	mov	ecx, DWORD PTR _writeTo$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 2816 : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 2817 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvPurchaseRequest@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier
EXTRN	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z:PROC ; CvFlavorManager::GetPersonalityIndividualFlavor
; Function compile flags: /Odtp
;	COMDAT ?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236867 = -24						; size = 4
_iStrategyFlavorMod$226816 = -20			; size = 4
_iPersonalityFlavor$226815 = -16			; size = 4
_eFlavor$226813 = -12					; size = 4
_iFlavorLoop$226809 = -8				; size = 4
_iWeightThresholdModifier$ = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::GetWeightThresholdModifier, COMDAT

; 2828 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2829 : 	int iWeightThresholdModifier = 0;

	mov	DWORD PTR _iWeightThresholdModifier$[ebp], 0

; 2830 : 
; 2831 : 	// Look at all Flavors for the Player & this Strategy
; 2832 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes(); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226809[ebp], 0
	jmp	SHORT $LN3@GetWeightT
$LN2@GetWeightT:
	mov	eax, DWORD PTR _iFlavorLoop$226809[ebp]
	add	eax, 1
	mov	DWORD PTR _iFlavorLoop$226809[ebp], eax
$LN3@GetWeightT:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T236867[ebp], ecx
	mov	edx, DWORD PTR _iFlavorLoop$226809[ebp]
	cmp	edx, DWORD PTR $T236867[ebp]
	jge	SHORT $LN1@GetWeightT

; 2833 : 	{
; 2834 : 		FlavorTypes eFlavor = (FlavorTypes) iFlavorLoop;

	mov	eax, DWORD PTR _iFlavorLoop$226809[ebp]
	mov	DWORD PTR _eFlavor$226813[ebp], eax

; 2835 : 		int iPersonalityFlavor = pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavor);

	mov	ecx, DWORD PTR _eFlavor$226813[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	mov	DWORD PTR _iPersonalityFlavor$226815[ebp], eax

; 2836 : 		int iStrategyFlavorMod = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy)->GetPersonalityFlavorThresholdMod(eFlavor);

	mov	edx, DWORD PTR _eFlavor$226813[ebp]
	push	edx
	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	ecx, eax
	call	?GetPersonalityFlavorThresholdMod@CvEconomicAIStrategyXMLEntry@@QBEHH@Z ; CvEconomicAIStrategyXMLEntry::GetPersonalityFlavorThresholdMod
	mov	DWORD PTR _iStrategyFlavorMod$226816[ebp], eax

; 2837 : 
; 2838 : 		iWeightThresholdModifier += (iPersonalityFlavor * iStrategyFlavorMod);

	mov	ecx, DWORD PTR _iPersonalityFlavor$226815[ebp]
	imul	ecx, DWORD PTR _iStrategyFlavorMod$226816[ebp]
	add	ecx, DWORD PTR _iWeightThresholdModifier$[ebp]
	mov	DWORD PTR _iWeightThresholdModifier$[ebp], ecx

; 2839 : 	}

	jmp	SHORT $LN2@GetWeightT
$LN1@GetWeightT:

; 2840 : 
; 2841 : 	return iWeightThresholdModifier;

	mov	eax, DWORD PTR _iWeightThresholdModifier$[ebp]

; 2842 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::GetWeightThresholdModifier
_TEXT	ENDS
PUBLIC	?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z ; EconomicAIHelpers::IsAreaSafeForQuickColony
EXTRN	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ:PROC ; CvArea::getAreaBoundaries
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
; Function compile flags: /Odtp
;	COMDAT ?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236912 = -120						; size = 4
$T236903 = -116						; size = 4
$T236887 = -112						; size = 4
$T236881 = -108						; size = 4
$T236877 = -104						; size = 4
$T236873 = -100						; size = 16
$T236872 = -84						; size = 16
$T236871 = -68						; size = 16
$T236870 = -52						; size = 16
_pPlot$226842 = -36					; size = 4
_iPlotY$226838 = -32					; size = 4
_iPlotX$226834 = -28					; size = 4
_iEndSearchX$ = -24					; size = 4
_pArea$ = -20						; size = 4
_pCapitalCity$ = -16					; size = 4
_iEndSearchY$ = -12					; size = 4
_iBeginSearchX$ = -8					; size = 4
_iBeginSearchY$ = -4					; size = 4
_iAreaID$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsAreaSafeForQuickColony, COMDAT

; 2846 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 2847 : 	if(iAreaID == -1)

	cmp	DWORD PTR _iAreaID$[ebp], -1
	jne	SHORT $LN12@IsAreaSafe

; 2848 : 	{
; 2849 : 		return false;

	xor	al, al
	jmp	$LN13@IsAreaSafe
$LN12@IsAreaSafe:

; 2850 : 	}
; 2851 : 
; 2852 : 	// Can't be capitals area
; 2853 : 	CvCity* pCapitalCity = pPlayer->getCapitalCity();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	DWORD PTR _pCapitalCity$[ebp], eax

; 2854 : 	if(pCapitalCity != NULL)

	cmp	DWORD PTR _pCapitalCity$[ebp], 0
	je	SHORT $LN11@IsAreaSafe

; 2855 : 	{
; 2856 : 		if(iAreaID == pCapitalCity->getArea())

	mov	ecx, DWORD PTR _pCapitalCity$[ebp]
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	DWORD PTR _iAreaID$[ebp], eax
	jne	SHORT $LN11@IsAreaSafe

; 2857 : 		{
; 2858 : 			return false;

	xor	al, al
	jmp	$LN13@IsAreaSafe
$LN11@IsAreaSafe:

; 2859 : 		}
; 2860 : 	}
; 2861 : 
; 2862 : 	CvArea* pArea = GC.getMap().getArea(iAreaID);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236877[ebp], eax
	mov	ecx, DWORD PTR _iAreaID$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T236877[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pArea$[ebp], eax

; 2863 : 	int iBeginSearchX = pArea->getAreaBoundaries().m_iWestEdge;

	lea	edx, DWORD PTR $T236870[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _iBeginSearchX$[ebp], eax

; 2864 : 	int iBeginSearchY = pArea->getAreaBoundaries().m_iSouthEdge;

	lea	ecx, DWORD PTR $T236871[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _iBeginSearchY$[ebp], edx

; 2865 : 	int iEndSearchX   = pArea->getAreaBoundaries().m_iEastEdge;

	lea	eax, DWORD PTR $T236872[ebp]
	push	eax
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _iEndSearchX$[ebp], ecx

; 2866 : 	int iEndSearchY   = pArea->getAreaBoundaries().m_iNorthEdge;

	lea	edx, DWORD PTR $T236873[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iEndSearchY$[ebp], eax

; 2867 : 
; 2868 : 	for(int iPlotX = iBeginSearchX; iPlotX <= iEndSearchX; iPlotX++)

	mov	ecx, DWORD PTR _iBeginSearchX$[ebp]
	mov	DWORD PTR _iPlotX$226834[ebp], ecx
	jmp	SHORT $LN9@IsAreaSafe
$LN8@IsAreaSafe:
	mov	edx, DWORD PTR _iPlotX$226834[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotX$226834[ebp], edx
$LN9@IsAreaSafe:
	mov	eax, DWORD PTR _iPlotX$226834[ebp]
	cmp	eax, DWORD PTR _iEndSearchX$[ebp]
	jg	$LN7@IsAreaSafe

; 2869 : 	{
; 2870 : 		for(int iPlotY = iBeginSearchY; iPlotY <= iEndSearchY; iPlotY++)

	mov	ecx, DWORD PTR _iBeginSearchY$[ebp]
	mov	DWORD PTR _iPlotY$226838[ebp], ecx
	jmp	SHORT $LN6@IsAreaSafe
$LN5@IsAreaSafe:
	mov	edx, DWORD PTR _iPlotY$226838[ebp]
	add	edx, 1
	mov	DWORD PTR _iPlotY$226838[ebp], edx
$LN6@IsAreaSafe:
	mov	eax, DWORD PTR _iPlotY$226838[ebp]
	cmp	eax, DWORD PTR _iEndSearchY$[ebp]
	jg	$LN4@IsAreaSafe

; 2871 : 		{
; 2872 : 			CvPlot* pPlot = GC.getMap().plotCheckInvalid(iPlotX, iPlotY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236881[ebp], ecx
	cmp	DWORD PTR _iPlotX$226834[ebp], -2147483647 ; 80000001H
	je	SHORT $LN19@IsAreaSafe
	cmp	DWORD PTR _iPlotY$226838[ebp], -2147483647 ; 80000001H
	jne	SHORT $LN20@IsAreaSafe
$LN19@IsAreaSafe:
	mov	DWORD PTR _pPlot$226842[ebp], 0
	jmp	SHORT $LN21@IsAreaSafe
$LN20@IsAreaSafe:
	mov	edx, DWORD PTR $T236881[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T236887[ebp], eax
	mov	ecx, DWORD PTR _iPlotY$226838[ebp]
	imul	ecx, DWORD PTR $T236887[ebp]
	add	ecx, DWORD PTR _iPlotX$226834[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T236881[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$226842[ebp], ecx
$LN21@IsAreaSafe:

; 2873 : 			if(!pPlot)

	cmp	DWORD PTR _pPlot$226842[ebp], 0
	jne	SHORT $LN3@IsAreaSafe

; 2874 : 			{
; 2875 : 				continue;

	jmp	SHORT $LN5@IsAreaSafe
$LN3@IsAreaSafe:

; 2876 : 			}
; 2877 : 
; 2878 : 			if(pPlot->getArea() != iAreaID)

	mov	eax, DWORD PTR _pPlot$226842[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T236903[ebp], ecx
	mov	edx, DWORD PTR $T236903[ebp]
	cmp	edx, DWORD PTR _iAreaID$[ebp]
	je	SHORT $LN31@IsAreaSafe

; 2879 : 			{
; 2880 : 				continue;

	jmp	SHORT $LN5@IsAreaSafe

; 2881 : 			}
; 2882 : 
; 2883 : 			if(pPlot->isVisibleEnemyUnit(pPlayer->GetID()))

$LN31@IsAreaSafe:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T236912[ebp], ecx
	mov	edx, DWORD PTR $T236912[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlot$226842[ebp]
	call	?isVisibleEnemyUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleEnemyUnit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsAreaSafe

; 2884 : 			{
; 2885 : 				return false;

	xor	al, al
	jmp	SHORT $LN13@IsAreaSafe
$LN1@IsAreaSafe:

; 2886 : 			}
; 2887 : 		}

	jmp	$LN5@IsAreaSafe
$LN4@IsAreaSafe:

; 2888 : 	}

	jmp	$LN8@IsAreaSafe
$LN7@IsAreaSafe:

; 2889 : 	return true;

	mov	al, 1
$LN13@IsAreaSafe:

; 2890 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsAreaSafeForQuickColony
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236919 = -12						; size = 4
$T236918 = -8						; size = 4
_eStrategyAtWar$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedRecon, COMDAT

; 2894 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2895 : 	// Never desperate for explorers if we are at war
; 2896 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 2897 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyAtWar$[ebp], -1
	je	SHORT $LN2@IsTestStra

; 2898 : 	{
; 2899 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	eax, DWORD PTR _eStrategyAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsTestStra

; 2900 : 		{
; 2901 : 			return false;

	xor	al, al
	jmp	SHORT $LN3@IsTestStra
$LN2@IsTestStra:

; 2902 : 		}
; 2903 : 	}
; 2904 : 
; 2905 : 	return (pPlayer->GetEconomicAI()->GetReconState() == RECON_STATE_NEEDED);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T236918[ebp], eax
	mov	edx, DWORD PTR $T236918[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR $T236919[ebp], eax
	xor	eax, eax
	cmp	DWORD PTR $T236919[ebp], 2
	sete	al
$LN3@IsTestStra:

; 2906 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedRecon
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236926 = -8						; size = 4
$T236925 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughRecon, COMDAT

; 2910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2911 : 	return (pPlayer->GetEconomicAI()->GetReconState() == RECON_STATE_ENOUGH);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T236925[ebp], eax
	mov	eax, DWORD PTR $T236925[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR $T236926[ebp], ecx
	xor	eax, eax
	cmp	DWORD PTR $T236926[ebp], 0
	sete	al

; 2912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughRecon@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughRecon
_TEXT	ENDS
PUBLIC	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
EXTRN	?canEmbark@CvTeam@@QBE_NXZ:PROC			; CvTeam::canEmbark
EXTRN	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetFreePromotions
EXTRN	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetDefaultUnitAIType
EXTRN	?GetDomainType@CvUnitEntry@@QBEHXZ:PROC		; CvUnitEntry::GetDomainType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ:PROC ; CvCity::getProductionUnit
EXTRN	?isProductionUnit@CvCity@@QBE_NXZ:PROC		; CvCity::isProductionUnit
EXTRN	?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z:PROC ; CvPromotionEntry::GetTerrainPassableTech
EXTRN	?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z:PROC ; CvPromotionEntry::GetTerrainImpassable
EXTRN	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z:PROC ; CvGlobals::getPromotionInfo
EXTRN	?getNumPromotionInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumPromotionInfos
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236962 = -72						; size = 4
$T236958 = -68						; size = 4
$T236946 = -64						; size = 4
$T236942 = -60						; size = 4
$T236933 = -56						; size = 4
$T236932 = -52						; size = 4
_pkUnitEntry$226899 = -48				; size = 4
_pLoopUnit$226888 = -44					; size = 4
_pLoopCity$226889 = -40					; size = 4
_iLoop$226890 = -36					; size = 4
_pkUnitEntry$226882 = -32				; size = 4
_eLoopPromotion$226873 = -28				; size = 4
_pkPromotionInfo$226875 = -24				; size = 4
_iI$226869 = -20					; size = 4
_pLoopUnit$226861 = -16					; size = 4
_eOceanImpassablePromotion$226868 = -12			; size = 4
_pLoopCity$226862 = -8					; size = 4
_iLoop$226863 = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea, COMDAT

; 2916 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 2917 : 	if(pPlayer->GetEconomicAI()->GetNavalReconState() == RECON_STATE_NEEDED)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T236932[ebp], eax
	mov	eax, DWORD PTR $T236932[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T236933[ebp], ecx
	cmp	DWORD PTR $T236933[ebp], 2
	jne	$LN30@IsTestStra@2

; 2918 : 	{
; 2919 : 		if(GET_TEAM(pPlayer->getTeam()).canEmbarkAllWaterPassage())  // get a caravel out there NOW!

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236942[ebp], eax
	mov	ecx, DWORD PTR $T236942[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T236946[ebp], ecx
	mov	ecx, DWORD PTR $T236946[ebp]
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	movzx	edx, al
	test	edx, edx
	je	$LN45@IsTestStra@2

; 2920 : 		{
; 2921 : 			CvUnit* pLoopUnit;
; 2922 : 			CvCity* pLoopCity;
; 2923 : 			int iLoop;
; 2924 : 
; 2925 : 			// Current Units
; 2926 : 			for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$226863[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$226861[ebp], eax
	jmp	SHORT $LN28@IsTestStra@2
$LN27@IsTestStra@2:
	push	0
	lea	ecx, DWORD PTR _iLoop$226863[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$226861[ebp], eax
$LN28@IsTestStra@2:
	cmp	DWORD PTR _pLoopUnit$226861[ebp], 0
	je	SHORT $LN26@IsTestStra@2

; 2927 : 			{
; 2928 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA && !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	mov	ecx, DWORD PTR _pLoopUnit$226861[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN25@IsTestStra@2
	push	6
	mov	ecx, DWORD PTR _pLoopUnit$226861[ebp]
	add	ecx, 1972				; 000007b4H
	call	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
	xor	edx, edx
	cmp	DWORD PTR [eax], 0
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@IsTestStra@2

; 2929 : 				{
; 2930 : 					return false;

	xor	al, al
	jmp	$LN31@IsTestStra@2
$LN25@IsTestStra@2:

; 2931 : 				}
; 2932 : 			}

	jmp	SHORT $LN27@IsTestStra@2
$LN26@IsTestStra@2:

; 2933 : 
; 2934 : 			// Figure out which Promotion is the one which makes a unit not cross oceans
; 2935 : 			PromotionTypes eOceanImpassablePromotion = NO_PROMOTION;

	mov	DWORD PTR _eOceanImpassablePromotion$226868[ebp], -1

; 2936 : #ifdef AUI_WARNING_FIXES
; 2937 : 			for (uint iI = 0; iI < GC.getNumPromotionInfos(); iI++)
; 2938 : #else
; 2939 : 			for(int iI = 0; iI < GC.getNumPromotionInfos(); iI++)

	mov	DWORD PTR _iI$226869[ebp], 0
	jmp	SHORT $LN24@IsTestStra@2
$LN23@IsTestStra@2:
	mov	ecx, DWORD PTR _iI$226869[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$226869[ebp], ecx
$LN24@IsTestStra@2:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumPromotionInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumPromotionInfos
	cmp	DWORD PTR _iI$226869[ebp], eax
	jge	SHORT $LN22@IsTestStra@2

; 2940 : #endif
; 2941 : 			{
; 2942 : 				const PromotionTypes eLoopPromotion = static_cast<PromotionTypes>(iI);

	mov	edx, DWORD PTR _iI$226869[ebp]
	mov	DWORD PTR _eLoopPromotion$226873[ebp], edx

; 2943 : 				CvPromotionEntry* pkPromotionInfo = GC.getPromotionInfo(eLoopPromotion);

	mov	eax, DWORD PTR _eLoopPromotion$226873[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPromotionInfo@CvGlobals@@QAEPAVCvPromotionEntry@@W4PromotionTypes@@@Z ; CvGlobals::getPromotionInfo
	mov	DWORD PTR _pkPromotionInfo$226875[ebp], eax

; 2944 : 				if(pkPromotionInfo)

	cmp	DWORD PTR _pkPromotionInfo$226875[ebp], 0
	je	SHORT $LN21@IsTestStra@2

; 2945 : 				{
; 2946 : 					if(pkPromotionInfo->GetTerrainImpassable(TERRAIN_OCEAN) && pkPromotionInfo->GetTerrainPassableTech(TERRAIN_OCEAN) == -1)

	push	6
	mov	ecx, DWORD PTR _pkPromotionInfo$226875[ebp]
	call	?GetTerrainImpassable@CvPromotionEntry@@QBE_NH@Z ; CvPromotionEntry::GetTerrainImpassable
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@IsTestStra@2
	push	6
	mov	ecx, DWORD PTR _pkPromotionInfo$226875[ebp]
	call	?GetTerrainPassableTech@CvPromotionEntry@@QBEHH@Z ; CvPromotionEntry::GetTerrainPassableTech
	cmp	eax, -1
	jne	SHORT $LN21@IsTestStra@2

; 2947 : 					{
; 2948 : 						eOceanImpassablePromotion = eLoopPromotion;

	mov	edx, DWORD PTR _eLoopPromotion$226873[ebp]
	mov	DWORD PTR _eOceanImpassablePromotion$226868[ebp], edx

; 2949 : 						break;

	jmp	SHORT $LN22@IsTestStra@2
$LN21@IsTestStra@2:

; 2950 : 					}
; 2951 : 				}
; 2952 : 			}

	jmp	SHORT $LN23@IsTestStra@2
$LN22@IsTestStra@2:

; 2953 : 
; 2954 : 			// Units being trained now
; 2955 : 			for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$226863[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226862[ebp], eax
	jmp	SHORT $LN19@IsTestStra@2
$LN18@IsTestStra@2:
	push	0
	lea	ecx, DWORD PTR _iLoop$226863[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226862[ebp], eax
$LN19@IsTestStra@2:
	cmp	DWORD PTR _pLoopCity$226862[ebp], 0
	je	SHORT $LN17@IsTestStra@2

; 2956 : 			{
; 2957 : 				if(pLoopCity->isProductionUnit())

	mov	ecx, DWORD PTR _pLoopCity$226862[ebp]
	call	?isProductionUnit@CvCity@@QBE_NXZ	; CvCity::isProductionUnit
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN16@IsTestStra@2

; 2958 : 				{
; 2959 : 					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());

	mov	ecx, DWORD PTR _pLoopCity$226862[ebp]
	call	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ ; CvCity::getProductionUnit
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitEntry$226882[ebp], eax

; 2960 : 					if(pkUnitEntry)

	cmp	DWORD PTR _pkUnitEntry$226882[ebp], 0
	je	SHORT $LN16@IsTestStra@2

; 2961 : 					{
; 2962 : 						if(pkUnitEntry->GetDomainType() == DOMAIN_SEA && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pkUnitEntry$226882[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	test	eax, eax
	jne	SHORT $LN16@IsTestStra@2
	mov	ecx, DWORD PTR _pkUnitEntry$226882[ebp]
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN16@IsTestStra@2

; 2963 : 						{
; 2964 : 							if(!pkUnitEntry->GetFreePromotions(eOceanImpassablePromotion))

	mov	eax, DWORD PTR _eOceanImpassablePromotion$226868[ebp]
	push	eax
	mov	ecx, DWORD PTR _pkUnitEntry$226882[ebp]
	call	?GetFreePromotions@CvUnitEntry@@QBE_NH@Z ; CvUnitEntry::GetFreePromotions
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN16@IsTestStra@2

; 2965 : 							{
; 2966 : 								return false;

	xor	al, al
	jmp	$LN31@IsTestStra@2
$LN16@IsTestStra@2:

; 2967 : 							}
; 2968 : 						}
; 2969 : 					}
; 2970 : 				}
; 2971 : 			}

	jmp	SHORT $LN18@IsTestStra@2
$LN17@IsTestStra@2:

; 2972 : 			return true;

	mov	al, 1
	jmp	$LN31@IsTestStra@2
	jmp	$LN30@IsTestStra@2

; 2973 : 		}
; 2974 : 		else if(GET_TEAM(pPlayer->getTeam()).canEmbark())  // get a trireme out there NOW!

$LN45@IsTestStra@2:
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T236958[ebp], eax
	mov	ecx, DWORD PTR $T236958[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T236962[ebp], ecx
	mov	ecx, DWORD PTR $T236962[ebp]
	call	?canEmbark@CvTeam@@QBE_NXZ		; CvTeam::canEmbark
	movzx	edx, al
	test	edx, edx
	je	$LN30@IsTestStra@2

; 2975 : 		{
; 2976 : 			CvUnit* pLoopUnit;
; 2977 : 			CvCity* pLoopCity;
; 2978 : 			int iLoop;
; 2979 : 
; 2980 : 			// Current Units
; 2981 : 			for(pLoopUnit = pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$226890[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$226888[ebp], eax
	jmp	SHORT $LN10@IsTestStra@2
$LN9@IsTestStra@2:
	push	0
	lea	ecx, DWORD PTR _iLoop$226890[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$226888[ebp], eax
$LN10@IsTestStra@2:
	cmp	DWORD PTR _pLoopUnit$226888[ebp], 0
	je	SHORT $LN8@IsTestStra@2

; 2982 : 			{
; 2983 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pLoopUnit$226888[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN7@IsTestStra@2

; 2984 : 				{
; 2985 : 					return false;

	xor	al, al
	jmp	SHORT $LN31@IsTestStra@2
$LN7@IsTestStra@2:

; 2986 : 				}
; 2987 : 			}

	jmp	SHORT $LN9@IsTestStra@2
$LN8@IsTestStra@2:

; 2988 : 
; 2989 : 			// Units being trained now
; 2990 : 			for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$226890[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$226889[ebp], eax
	jmp	SHORT $LN6@IsTestStra@2
$LN5@IsTestStra@2:
	push	0
	lea	eax, DWORD PTR _iLoop$226890[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$226889[ebp], eax
$LN6@IsTestStra@2:
	cmp	DWORD PTR _pLoopCity$226889[ebp], 0
	je	SHORT $LN4@IsTestStra@2

; 2991 : 			{
; 2992 : 				if(pLoopCity->isProductionUnit())

	mov	ecx, DWORD PTR _pLoopCity$226889[ebp]
	call	?isProductionUnit@CvCity@@QBE_NXZ	; CvCity::isProductionUnit
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@IsTestStra@2

; 2993 : 				{
; 2994 : 					CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopCity->getProductionUnit());

	mov	ecx, DWORD PTR _pLoopCity$226889[ebp]
	call	?getProductionUnit@CvCity@@QBE?AW4UnitTypes@@XZ ; CvCity::getProductionUnit
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo
	mov	DWORD PTR _pkUnitEntry$226899[ebp], eax

; 2995 : 					if(pkUnitEntry)

	cmp	DWORD PTR _pkUnitEntry$226899[ebp], 0
	je	SHORT $LN3@IsTestStra@2

; 2996 : 					{
; 2997 : 						if(pkUnitEntry->GetDomainType() == DOMAIN_SEA && pkUnitEntry->GetDefaultUnitAIType() == UNITAI_EXPLORE_SEA)

	mov	ecx, DWORD PTR _pkUnitEntry$226899[ebp]
	call	?GetDomainType@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetDomainType
	test	eax, eax
	jne	SHORT $LN3@IsTestStra@2
	mov	ecx, DWORD PTR _pkUnitEntry$226899[ebp]
	call	?GetDefaultUnitAIType@CvUnitEntry@@QBEHXZ ; CvUnitEntry::GetDefaultUnitAIType
	cmp	eax, 21					; 00000015H
	jne	SHORT $LN3@IsTestStra@2

; 2998 : 						{
; 2999 : 							return false;

	xor	al, al
	jmp	SHORT $LN31@IsTestStra@2
$LN3@IsTestStra@2:

; 3000 : 						}
; 3001 : 					}
; 3002 : 				}
; 3003 : 			}

	jmp	SHORT $LN5@IsTestStra@2
$LN4@IsTestStra@2:

; 3004 : 			return true;

	mov	al, 1
	jmp	SHORT $LN31@IsTestStra@2
$LN30@IsTestStra@2:

; 3005 : 		}
; 3006 : 	}
; 3007 : 
; 3008 : 	return false;

	xor	al, al
$LN31@IsTestStra@2:

; 3009 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_ReallyNeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ReallyNeedReconSea
_TEXT	ENDS
PUBLIC	??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@ ; `string'
;	COMDAT ??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.h
CONST	SEGMENT
??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@ DB 'MILITARYAISTRA'
	DB	'TEGY_LOSING_WARS', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236969 = -12						; size = 4
$T236968 = -8						; size = 4
_eStrategyAtWar$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedReconSea, COMDAT

; 3013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3014 : 	// Never desperate for explorers if we are at war
; 3015 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_LOSING_WARS");

	push	0
	push	OFFSET ??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 3016 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyAtWar$[ebp], -1
	je	SHORT $LN2@IsTestStra@3

; 3017 : 	{
; 3018 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	eax, DWORD PTR _eStrategyAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsTestStra@3

; 3019 : 		{
; 3020 : 			return false;

	xor	al, al
	jmp	SHORT $LN3@IsTestStra@3
$LN2@IsTestStra@3:

; 3021 : 		}
; 3022 : 	}
; 3023 : 
; 3024 : 	return (pPlayer->GetEconomicAI()->GetNavalReconState() == RECON_STATE_NEEDED);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T236968[ebp], eax
	mov	edx, DWORD PTR $T236968[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR $T236969[ebp], eax
	xor	eax, eax
	cmp	DWORD PTR $T236969[ebp], 2
	sete	al
$LN3@IsTestStra@3:

; 3025 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedReconSea
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236976 = -8						; size = 4
$T236975 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughReconSea, COMDAT

; 3029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3030 : 	return (pPlayer->GetEconomicAI()->GetNavalReconState() == RECON_STATE_ENOUGH);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T236975[ebp], eax
	mov	eax, DWORD PTR $T236975[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR $T236976[ebp], ecx
	xor	eax, eax
	cmp	DWORD PTR $T236976[ebp], 0
	sete	al

; 3031 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughReconSea@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughReconSea
_TEXT	ENDS
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236982 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NavalMap, COMDAT

; 3035 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3036 : 	if(pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsTestStra@4

; 3037 : 	{
; 3038 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@IsTestStra@4
$LN1@IsTestStra@4:

; 3039 : 	}
; 3040 : 
; 3041 : 	return (GC.getMap().GetAIMapHint() & 1);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236982[ebp], ecx
	mov	ecx, DWORD PTR $T236982[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 1
$LN2@IsTestStra@4:

; 3042 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NavalMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NavalMap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T236988 = -4						; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap, COMDAT

; 3046 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3047 : 	if(pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@IsTestStra@5

; 3048 : 	{
; 3049 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@IsTestStra@5
$LN1@IsTestStra@5:

; 3050 : 	}
; 3051 : 
; 3052 : 	return (GC.getMap().GetAIMapHint() & 4);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236988[ebp], ecx
	mov	ecx, DWORD PTR $T236988[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 4
	setne	al
$LN2@IsTestStra@5:

; 3053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_OffshoreExpansionMap@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_OffshoreExpansionMap
_TEXT	ENDS
EXTRN	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ:PROC ; CvGameReligions::GetNumReligionsStillToFound
EXTRN	?HasCreatedPantheon@CvGameReligions@@QBE_NW4PlayerTypes@@@Z:PROC ; CvGameReligions::HasCreatedPantheon
EXTRN	?HasCreatedReligion@CvGameReligions@@QBE_NW4PlayerTypes@@@Z:PROC ; CvGameReligions::HasCreatedReligion
EXTRN	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ:PROC ; CvGame::GetGameReligions
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237012 = -16						; size = 4
$T237003 = -12						; size = 4
$T236994 = -8						; size = 4
_pReligions$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion, COMDAT

; 3057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3058 : 	if(pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@IsTestStra@6

; 3059 : 	{
; 3060 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsTestStra@6
$LN4@IsTestStra@6:

; 3061 : 	}
; 3062 : 
; 3063 : 	// Always true if we've already created a religion
; 3064 : 	CvGameReligions* pReligions = GC.getGame().GetGameReligions();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T236994[ebp], ecx
	mov	ecx, DWORD PTR $T236994[ebp]
	call	?GetGameReligions@CvGame@@QAEPAVCvGameReligions@@XZ ; CvGame::GetGameReligions
	mov	DWORD PTR _pReligions$[ebp], eax

; 3065 : 	if(pReligions->HasCreatedReligion(pPlayer->GetID()))

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR $T237003[ebp], eax
	mov	ecx, DWORD PTR $T237003[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?HasCreatedReligion@CvGameReligions@@QBE_NW4PlayerTypes@@@Z ; CvGameReligions::HasCreatedReligion
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN15@IsTestStra@6

; 3066 : 	{
; 3067 : 		return true;

	mov	al, 1
	jmp	SHORT $LN5@IsTestStra@6

; 3068 : 	}
; 3069 : 
; 3070 : 	// Also true if created a pantheon and there are religions left to create
; 3071 : 	if(pReligions->HasCreatedPantheon(pPlayer->GetID()))

$LN15@IsTestStra@6:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR $T237012[ebp], ecx
	mov	edx, DWORD PTR $T237012[ebp]
	push	edx
	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?HasCreatedPantheon@CvGameReligions@@QBE_NW4PlayerTypes@@@Z ; CvGameReligions::HasCreatedPantheon
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@IsTestStra@6

; 3072 : 	{
; 3073 : 		if(pReligions->GetNumReligionsStillToFound() > 0)

	mov	ecx, DWORD PTR _pReligions$[ebp]
	call	?GetNumReligionsStillToFound@CvGameReligions@@QBEHXZ ; CvGameReligions::GetNumReligionsStillToFound
	test	eax, eax
	jle	SHORT $LN2@IsTestStra@6

; 3074 : 		{
; 3075 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@IsTestStra@6
$LN2@IsTestStra@6:

; 3076 : 		}
; 3077 : 	}
; 3078 : 
; 3079 : 	return false;

	xor	al, al
$LN5@IsTestStra@6:

; 3080 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_DevelopingReligion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_DevelopingReligion
_TEXT	ENDS
PUBLIC	__real@3d4ccccd
PUBLIC	??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@	; `string'
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
EXTRN	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ:PROC ; CvPlayer::GetEspionageAI
;	COMDAT __real@3d4ccccd
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT ??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@
CONST	SEGMENT
??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@ DB 'FLAVOR_ESPIONAGE', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237074 = -84						; size = 4
$T237070 = -80						; size = 4
$T237066 = -76						; size = 4
$T237062 = -72						; size = 4
$T237053 = -68						; size = 4
$T237049 = -64						; size = 4
$T237040 = -57						; size = 1
$T237031 = -56						; size = 4
$T237027 = -52						; size = 4
$T237023 = -48						; size = 4
_eFlavor$226953 = -44					; size = 4
_iFlavor$226949 = -40					; size = 4
_fCutOff$226959 = -36					; size = 4
_eFlavorEspionage$226948 = -32				; size = 4
_fRatio$226957 = -28					; size = 4
_ePlayer$226941 = -24					; size = 4
_iNumTechs$226945 = -20					; size = 4
_ui$226937 = -16					; size = 4
_iNumPlayersAheadInTech$ = -12				; size = 4
_iNumOtherPlayers$ = -8					; size = 4
_iMyTechNum$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_TechLeader, COMDAT

; 3084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 3085 : 	if (pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@IsTestStra@7

; 3086 : 	{
; 3087 : 		return false;

	xor	al, al
	jmp	$LN1@IsTestStra@7
$LN16@IsTestStra@7:

; 3088 : 	}
; 3089 : 
; 3090 : 	// don't evaluate if espionage hasn't started yet
; 3091 : 	if (pPlayer->GetEspionageAI()->m_iTurnEspionageStarted == -1)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEspionageAI@CvPlayer@@QBEPAVCvEspionageAI@@XZ ; CvPlayer::GetEspionageAI
	cmp	DWORD PTR [eax+736], -1
	jne	SHORT $LN15@IsTestStra@7

; 3092 : 	{
; 3093 : 		return false;

	xor	al, al
	jmp	$LN1@IsTestStra@7
$LN15@IsTestStra@7:

; 3094 : 	}
; 3095 : 
; 3096 : 	int iMyTechNum = GET_TEAM(pPlayer->getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237023[ebp], eax
	mov	eax, DWORD PTR $T237023[ebp]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237027[ebp], eax
	mov	ecx, DWORD PTR $T237027[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	mov	DWORD PTR _iMyTechNum$[ebp], eax

; 3097 : 
; 3098 : 	int iNumOtherPlayers = 0;

	mov	DWORD PTR _iNumOtherPlayers$[ebp], 0

; 3099 : 	int iNumPlayersAheadInTech = 0;

	mov	DWORD PTR _iNumPlayersAheadInTech$[ebp], 0

; 3100 : 	for(uint ui = 0; ui < MAX_MAJOR_CIVS; ui++)

	mov	DWORD PTR _ui$226937[ebp], 0
	jmp	SHORT $LN14@IsTestStra@7
$LN13@IsTestStra@7:
	mov	ecx, DWORD PTR _ui$226937[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$226937[ebp], ecx
$LN14@IsTestStra@7:
	cmp	DWORD PTR _ui$226937[ebp], 22		; 00000016H
	jae	$LN12@IsTestStra@7

; 3101 : 	{
; 3102 : 		PlayerTypes ePlayer = (PlayerTypes)ui;

	mov	edx, DWORD PTR _ui$226937[ebp]
	mov	DWORD PTR _ePlayer$226941[ebp], edx

; 3103 : 		if(!GET_PLAYER(ePlayer).isAlive())

	mov	eax, DWORD PTR _ePlayer$226941[ebp]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237031[ebp], eax
	mov	ecx, DWORD PTR $T237031[ebp]
	mov	dl, BYTE PTR [ecx+2256]
	mov	BYTE PTR $T237040[ebp], dl
	movzx	eax, BYTE PTR $T237040[ebp]
	test	eax, eax
	jne	SHORT $LN11@IsTestStra@7

; 3104 : 		{
; 3105 : 			continue;

	jmp	SHORT $LN13@IsTestStra@7
$LN11@IsTestStra@7:

; 3106 : 		}
; 3107 : 
; 3108 : 		if (ePlayer == pPlayer->GetID())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR $T237049[ebp], edx
	mov	eax, DWORD PTR _ePlayer$226941[ebp]
	cmp	eax, DWORD PTR $T237049[ebp]
	jne	SHORT $LN10@IsTestStra@7

; 3109 : 		{
; 3110 : 			continue;

	jmp	SHORT $LN13@IsTestStra@7
$LN10@IsTestStra@7:

; 3111 : 		}
; 3112 : 
; 3113 : 		iNumOtherPlayers++;

	mov	ecx, DWORD PTR _iNumOtherPlayers$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumOtherPlayers$[ebp], ecx

; 3114 : 		int iNumTechs = GET_TEAM(GET_PLAYER(ePlayer).getTeam()).GetTeamTechs()->GetNumTechsKnown();

	mov	edx, DWORD PTR _ePlayer$226941[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T237053[ebp], edx
	mov	eax, DWORD PTR $T237053[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237062[ebp], eax
	mov	edx, DWORD PTR $T237062[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237066[ebp], edx
	mov	ecx, DWORD PTR $T237066[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ	; CvTeamTechs::GetNumTechsKnown
	mov	DWORD PTR _iNumTechs$226945[ebp], eax

; 3115 : 		if (iNumTechs > iMyTechNum)

	mov	eax, DWORD PTR _iNumTechs$226945[ebp]
	cmp	eax, DWORD PTR _iMyTechNum$[ebp]
	jle	SHORT $LN9@IsTestStra@7

; 3116 : 		{
; 3117 : 			iNumPlayersAheadInTech++;

	mov	ecx, DWORD PTR _iNumPlayersAheadInTech$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumPlayersAheadInTech$[ebp], ecx
$LN9@IsTestStra@7:

; 3118 : 		}
; 3119 : 	}

	jmp	$LN13@IsTestStra@7
$LN12@IsTestStra@7:

; 3120 : 
; 3121 : 	if (iNumOtherPlayers > 0)

	cmp	DWORD PTR _iNumOtherPlayers$[ebp], 0
	jle	$LN8@IsTestStra@7

; 3122 : 	{
; 3123 : 		FlavorTypes eFlavorEspionage = NO_FLAVOR;

	mov	DWORD PTR _eFlavorEspionage$226948[ebp], -1

; 3124 : 		for (int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	mov	DWORD PTR _iFlavor$226949[ebp], 0
	jmp	SHORT $LN7@IsTestStra@7
$LN6@IsTestStra@7:
	mov	edx, DWORD PTR _iFlavor$226949[ebp]
	add	edx, 1
	mov	DWORD PTR _iFlavor$226949[ebp], edx
$LN7@IsTestStra@7:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T237070[ebp], eax
	mov	ecx, DWORD PTR _iFlavor$226949[ebp]
	cmp	ecx, DWORD PTR $T237070[ebp]
	jge	SHORT $LN5@IsTestStra@7

; 3125 : 		{
; 3126 : 			FlavorTypes eFlavor = (FlavorTypes)iFlavor;

	mov	edx, DWORD PTR _iFlavor$226949[ebp]
	mov	DWORD PTR _eFlavor$226953[ebp], edx

; 3127 : 			if (GC.getFlavorTypes(eFlavor) == "FLAVOR_ESPIONAGE")

	mov	eax, DWORD PTR _eFlavor$226953[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T237074[ebp], eax
	push	OFFSET ??_C@_0BB@DNELEDCK@FLAVOR_ESPIONAGE?$AA@
	mov	ecx, DWORD PTR $T237074[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@IsTestStra@7

; 3128 : 			{
; 3129 : 				eFlavorEspionage = eFlavor;

	mov	eax, DWORD PTR _eFlavor$226953[ebp]
	mov	DWORD PTR _eFlavorEspionage$226948[ebp], eax
$LN4@IsTestStra@7:

; 3130 : 			}
; 3131 : 		}

	jmp	SHORT $LN6@IsTestStra@7
$LN5@IsTestStra@7:

; 3132 : 		CvAssertMsg(eFlavorEspionage != NO_FLAVOR, "Could not find espionage flavor!");
; 3133 : 
; 3134 : 		float fRatio = iNumPlayersAheadInTech / (float)iNumOtherPlayers;

	cvtsi2ss xmm0, DWORD PTR _iNumPlayersAheadInTech$[ebp]
	cvtsi2ss xmm1, DWORD PTR _iNumOtherPlayers$[ebp]
	divss	xmm0, xmm1
	movss	DWORD PTR _fRatio$226957[ebp], xmm0

; 3135 : 		float fCutOff = (0.05f * pPlayer->GetFlavorManager()->GetPersonalityIndividualFlavor(eFlavorEspionage));

	mov	ecx, DWORD PTR _eFlavorEspionage$226948[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFlavorManager@CvPlayer@@QBEPAVCvFlavorManager@@XZ ; CvPlayer::GetFlavorManager
	mov	ecx, eax
	call	?GetPersonalityIndividualFlavor@CvFlavorManager@@QAEHW4FlavorTypes@@@Z ; CvFlavorManager::GetPersonalityIndividualFlavor
	cvtsi2ss xmm0, eax
	mulss	xmm0, DWORD PTR __real@3d4ccccd
	movss	DWORD PTR _fCutOff$226959[ebp], xmm0

; 3136 : 
; 3137 : 		if (fRatio < fCutOff)

	movss	xmm0, DWORD PTR _fCutOff$226959[ebp]
	comiss	xmm0, DWORD PTR _fRatio$226957[ebp]
	jbe	SHORT $LN3@IsTestStra@7

; 3138 : 		{
; 3139 : 			return true;

	mov	al, 1
	jmp	SHORT $LN1@IsTestStra@7

; 3140 : 		}
; 3141 : 		else

	jmp	SHORT $LN2@IsTestStra@7
$LN3@IsTestStra@7:

; 3142 : 		{
; 3143 : 			return false;

	xor	al, al
	jmp	SHORT $LN1@IsTestStra@7
$LN2@IsTestStra@7:

; 3144 : 		}
; 3145 : 	}
; 3146 : 	else

	jmp	SHORT $LN1@IsTestStra@7
$LN8@IsTestStra@7:

; 3147 : 	{
; 3148 : 		return false;

	xor	al, al
$LN1@IsTestStra@7:

; 3149 : 	}
; 3150 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_TechLeader@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_TechLeader
_TEXT	ENDS
PUBLIC	??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@		; `string'
PUBLIC	??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@	; `string'
PUBLIC	??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@ ; `string'
PUBLIC	??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@	; `string'
EXTRN	?GetNumPuppetCities@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetNumPuppetCities
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?getNumUnownedTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumUnownedTiles
EXTRN	?getNumOwnedTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumOwnedTiles
EXTRN	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z:PROC	; CvPlayer::GetBestSettleAreas
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
EXTRN	?isOption@CvGame@@QBE_NPBD@Z:PROC		; CvGame::isOption
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
;	COMDAT ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@ DB 'FLAVOR_GROWTH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
CONST	SEGMENT
??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@ DB 'FLAVOR_EXPANSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
CONST	SEGMENT
??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@ DB 'GAMEOPTION_AI_GI'
	DB	'MP_NO_BUILDING_SETTLERS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
CONST	SEGMENT
??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@ DB 'GAMEOPTION_AI_TWEAKS', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv187 = -180						; size = 4
tv172 = -176						; size = 4
tv157 = -172						; size = 4
$T237180 = -168						; size = 4
$T237176 = -164						; size = 4
$T237169 = -160						; size = 4
$T237163 = -156						; size = 4
$T237159 = -152						; size = 4
$T237155 = -148						; size = 4
$T237154 = -144						; size = 4
$T237150 = -140						; size = 4
$T237146 = -136						; size = 4
$T237142 = -132						; size = 4
$T237135 = -128						; size = 4
$T237129 = -124						; size = 4
$T237128 = -120						; size = 4
$T237124 = -116						; size = 4
$T237117 = -112						; size = 4
$T237111 = -108						; size = 4
$T237107 = -104						; size = 4
$T237103 = -100						; size = 4
$T237099 = -96						; size = 4
$T237095 = -92						; size = 4
$T237091 = -88						; size = 4
$T237087 = -84						; size = 4
$T237083 = -80						; size = 4
$T237082 = -76						; size = 4
$T237081 = -72						; size = 4
$T237080 = -68						; size = 4
$T237079 = -64						; size = 4
_iNumTiles$227002 = -60					; size = 4
_iNumCities$227006 = -56				; size = 4
_iOwnageRatio$227005 = -52				; size = 4
_iNumUnownedTiles$227001 = -48				; size = 4
_iSettlersOnMap$227007 = -44				; size = 4
_iNumOwnedTiles$227000 = -40				; size = 4
_pArea$226995 = -36					; size = 4
_iBestArea$226996 = -32					; size = 4
_iSecondBestArea$226997 = -28				; size = 4
_iFlavorLoop$226975 = -24				; size = 4
_iDefaultNumTiles$ = -20				; size = 4
_iDesiredCities$ = -16					; size = 4
_iFlavorExpansion$ = -12				; size = 4
_iFlavorGrowth$ = -8					; size = 4
_iDifficulty$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion, COMDAT

; 3154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	esi

; 3155 : 	int iDesiredCities;
; 3156 : 	int iFlavorExpansion = 0;

	mov	DWORD PTR _iFlavorExpansion$[ebp], 0

; 3157 : 	int iFlavorGrowth = 0;

	mov	DWORD PTR _iFlavorGrowth$[ebp], 0

; 3158 : 
; 3159 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3160 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@IsTestStra@8
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237087[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T237087[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@IsTestStra@8
$LN13@IsTestStra@8:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN15@IsTestStra@8
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237091[ebp], ecx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T237091[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@IsTestStra@8
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237095[ebp], eax
	push	OFFSET ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
	mov	ecx, DWORD PTR $T237095[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@IsTestStra@8
$LN14@IsTestStra@8:

; 3161 : #else
; 3162 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3163 : #endif
; 3164 : 	{
; 3165 : 		return false;

	xor	al, al
	jmp	$LN16@IsTestStra@8
$LN15@IsTestStra@8:

; 3166 : 	}
; 3167 : 
; 3168 : 	iDesiredCities = pPlayer->GetEconomicAI()->GetEarlyCityNumberTarget();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237099[ebp], eax
	mov	edx, DWORD PTR $T237099[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _iDesiredCities$[ebp], eax

; 3169 : 	for(int iFlavorLoop = 0; iFlavorLoop < GC.getNumFlavorTypes() && (iFlavorExpansion == 0 || iFlavorGrowth == 0); iFlavorLoop++)

	mov	DWORD PTR _iFlavorLoop$226975[ebp], 0
	jmp	SHORT $LN11@IsTestStra@8
$LN10@IsTestStra@8:
	mov	ecx, DWORD PTR _iFlavorLoop$226975[ebp]
	add	ecx, 1
	mov	DWORD PTR _iFlavorLoop$226975[ebp], ecx
$LN11@IsTestStra@8:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	DWORD PTR $T237103[ebp], edx
	mov	eax, DWORD PTR _iFlavorLoop$226975[ebp]
	cmp	eax, DWORD PTR $T237103[ebp]
	jge	$LN9@IsTestStra@8
	cmp	DWORD PTR _iFlavorExpansion$[ebp], 0
	je	SHORT $LN8@IsTestStra@8
	cmp	DWORD PTR _iFlavorGrowth$[ebp], 0
	jne	$LN9@IsTestStra@8
$LN8@IsTestStra@8:

; 3170 : 	{
; 3171 : 		if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_EXPANSION")

	mov	ecx, DWORD PTR _iFlavorLoop$226975[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T237107[ebp], ecx
	push	OFFSET ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
	mov	edx, DWORD PTR $T237107[ebp]
	push	edx
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@IsTestStra@8

; 3172 : 		{
; 3173 : 			iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)iFlavorLoop);

	mov	ecx, DWORD PTR _iFlavorLoop$226975[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorExpansion$[ebp], eax
	jmp	SHORT $LN6@IsTestStra@8
$LN7@IsTestStra@8:

; 3174 : 		}
; 3175 : 		else if(GC.getFlavorTypes((FlavorTypes)iFlavorLoop) == "FLAVOR_GROWTH")

	mov	edx, DWORD PTR _iFlavorLoop$226975[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	mov	DWORD PTR $T237111[ebp], edx
	push	OFFSET ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
	mov	eax, DWORD PTR $T237111[ebp]
	push	eax
	call	DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@IsTestStra@8

; 3176 : 		{
; 3177 : 			iFlavorGrowth = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)iFlavorLoop);

	mov	edx, DWORD PTR _iFlavorLoop$226975[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorGrowth$[ebp], eax
$LN6@IsTestStra@8:

; 3178 : 		}
; 3179 : 	}

	jmp	$LN10@IsTestStra@8
$LN9@IsTestStra@8:

; 3180 : 
; 3181 : 	iDesiredCities = (iDesiredCities * iFlavorExpansion) / max(iFlavorGrowth, 1);

	mov	DWORD PTR $T237079[ebp], 1
	mov	eax, DWORD PTR _iFlavorGrowth$[ebp]
	cmp	eax, DWORD PTR $T237079[ebp]
	jge	SHORT $LN34@IsTestStra@8
	lea	ecx, DWORD PTR $T237079[ebp]
	mov	DWORD PTR tv157[ebp], ecx
	jmp	SHORT $LN35@IsTestStra@8
$LN34@IsTestStra@8:
	lea	edx, DWORD PTR _iFlavorGrowth$[ebp]
	mov	DWORD PTR tv157[ebp], edx
$LN35@IsTestStra@8:
	mov	eax, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T237117[ebp], eax
	mov	eax, DWORD PTR _iDesiredCities$[ebp]
	imul	eax, DWORD PTR _iFlavorExpansion$[ebp]
	mov	ecx, DWORD PTR $T237117[ebp]
	cdq
	idiv	DWORD PTR [ecx]
	mov	DWORD PTR _iDesiredCities$[ebp], eax

; 3182 : 	int iDifficulty = max(0,GC.getGame().getHandicapInfo().GetID() - 3);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237124[ebp], edx
	mov	ecx, DWORD PTR $T237124[ebp]
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	mov	DWORD PTR $T237128[ebp], eax
	mov	eax, DWORD PTR $T237128[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237129[ebp], ecx
	mov	edx, DWORD PTR $T237129[ebp]
	sub	edx, 3
	mov	DWORD PTR $T237080[ebp], edx
	mov	DWORD PTR $T237081[ebp], 0
	mov	eax, DWORD PTR $T237081[ebp]
	cmp	eax, DWORD PTR $T237080[ebp]
	jge	SHORT $LN42@IsTestStra@8
	lea	ecx, DWORD PTR $T237080[ebp]
	mov	DWORD PTR tv172[ebp], ecx
	jmp	SHORT $LN43@IsTestStra@8
$LN42@IsTestStra@8:
	lea	edx, DWORD PTR $T237081[ebp]
	mov	DWORD PTR tv172[ebp], edx
$LN43@IsTestStra@8:
	mov	eax, DWORD PTR tv172[ebp]
	mov	DWORD PTR $T237135[ebp], eax
	mov	ecx, DWORD PTR $T237135[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _iDifficulty$[ebp], edx

; 3183 : 	iDesiredCities += iDifficulty;

	mov	eax, DWORD PTR _iDesiredCities$[ebp]
	add	eax, DWORD PTR _iDifficulty$[ebp]
	mov	DWORD PTR _iDesiredCities$[ebp], eax

; 3184 : 
; 3185 : 	// scale this based on world size
; 3186 : 	const int iDefaultNumTiles = 80*52;

	mov	DWORD PTR _iDefaultNumTiles$[ebp], 4160	; 00001040H

; 3187 : 	iDesiredCities = (iDesiredCities * GC.getMap().numPlots()) / iDefaultNumTiles;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237142[ebp], ecx
	mov	edx, DWORD PTR $T237142[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T237146[ebp], eax
	mov	eax, DWORD PTR _iDesiredCities$[ebp]
	imul	eax, DWORD PTR $T237146[ebp]
	cdq
	mov	ecx, 4160				; 00001040H
	idiv	ecx
	mov	DWORD PTR _iDesiredCities$[ebp], eax

; 3188 : 
; 3189 : 	// See how many unowned Tiles there are on this player's landmass
; 3190 : 	if(pPlayer->getCapitalCity() != NULL)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	$LN4@IsTestStra@8

; 3191 : 	{
; 3192 : 		// Make sure city specialization has gotten one chance to specialize the capital before we adopt this
; 3193 : 		//if(GC.getGame().getGameTurn() > GC.getAI_CITY_SPECIALIZATION_EARLIEST_TURN())
; 3194 : 		{
; 3195 : 			CvArea* pArea = GC.getMap().getArea(pPlayer->getCapitalCity()->getArea());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237150[ebp], edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	ecx, DWORD PTR $T237150[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pArea$226995[ebp], eax

; 3196 : 
; 3197 : 			// Is this area still one of the best to settle?
; 3198 : 			int iBestArea, iSecondBestArea;
; 3199 : 			pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237154[ebp], eax
	mov	eax, DWORD PTR $T237154[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T237155[ebp], ecx
	lea	edx, DWORD PTR _iSecondBestArea$226997[ebp]
	push	edx
	lea	eax, DWORD PTR _iBestArea$226996[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237155[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3200 : 			if(iBestArea == pArea->GetID() || iSecondBestArea == pArea->GetID())

	mov	edx, DWORD PTR _pArea$226995[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237159[ebp], eax
	mov	ecx, DWORD PTR _iBestArea$226996[ebp]
	cmp	ecx, DWORD PTR $T237159[ebp]
	je	SHORT $LN2@IsTestStra@8
	mov	edx, DWORD PTR _pArea$226995[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237163[ebp], eax
	mov	ecx, DWORD PTR _iSecondBestArea$226997[ebp]
	cmp	ecx, DWORD PTR $T237163[ebp]
	jne	$LN4@IsTestStra@8
$LN2@IsTestStra@8:

; 3201 : 			{
; 3202 : 				int iNumOwnedTiles = pArea->getNumOwnedTiles();

	mov	ecx, DWORD PTR _pArea$226995[ebp]
	call	?getNumOwnedTiles@CvArea@@QBEHXZ	; CvArea::getNumOwnedTiles
	mov	DWORD PTR _iNumOwnedTiles$227000[ebp], eax

; 3203 : 				int iNumUnownedTiles = pArea->getNumUnownedTiles();

	mov	ecx, DWORD PTR _pArea$226995[ebp]
	call	?getNumUnownedTiles@CvArea@@QBEHXZ	; CvArea::getNumUnownedTiles
	mov	DWORD PTR _iNumUnownedTiles$227001[ebp], eax

; 3204 : 				int iNumTiles = max(1,pArea->getNumTiles());

	mov	ecx, DWORD PTR _pArea$226995[ebp]
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	DWORD PTR $T237082[ebp], eax
	mov	DWORD PTR $T237083[ebp], 1
	mov	edx, DWORD PTR $T237083[ebp]
	cmp	edx, DWORD PTR $T237082[ebp]
	jge	SHORT $LN58@IsTestStra@8
	lea	eax, DWORD PTR $T237082[ebp]
	mov	DWORD PTR tv187[ebp], eax
	jmp	SHORT $LN59@IsTestStra@8
$LN58@IsTestStra@8:
	lea	ecx, DWORD PTR $T237083[ebp]
	mov	DWORD PTR tv187[ebp], ecx
$LN59@IsTestStra@8:
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T237169[ebp], edx
	mov	eax, DWORD PTR $T237169[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iNumTiles$227002[ebp], ecx

; 3205 : 
; 3206 : 				int iOwnageRatio = iNumOwnedTiles * 100 / iNumTiles;

	mov	eax, DWORD PTR _iNumOwnedTiles$227000[ebp]
	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR _iNumTiles$227002[ebp]
	mov	DWORD PTR _iOwnageRatio$227005[ebp], eax

; 3207 : 				int iNumCities = pPlayer->getNumCities() - pPlayer->GetNumPuppetCities();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	esi, eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetNumPuppetCities@CvPlayer@@QBEHXZ	; CvPlayer::GetNumPuppetCities
	sub	esi, eax
	mov	DWORD PTR _iNumCities$227006[ebp], esi

; 3208 : 				int iSettlersOnMap = pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iSettlersOnMap$227007[ebp], eax

; 3209 : 
; 3210 : 				if(iOwnageRatio < GC.getAI_STRATEGY_AREA_IS_FULL_PERCENT()
; 3211 : 				        && (iNumCities + iSettlersOnMap) < iDesiredCities
; 3212 : 				        && iNumUnownedTiles >= GC.getAI_STRATEGY_EARLY_EXPANSION_NUM_UNOWNED_TILES_REQUIRED())

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2024
	mov	DWORD PTR $T237176[ebp], edx
	mov	eax, DWORD PTR _iOwnageRatio$227005[ebp]
	cmp	eax, DWORD PTR $T237176[ebp]
	jge	SHORT $LN4@IsTestStra@8
	mov	ecx, DWORD PTR _iNumCities$227006[ebp]
	add	ecx, DWORD PTR _iSettlersOnMap$227007[ebp]
	cmp	ecx, DWORD PTR _iDesiredCities$[ebp]
	jge	SHORT $LN4@IsTestStra@8
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2008
	mov	DWORD PTR $T237180[ebp], edx
	mov	eax, DWORD PTR _iNumUnownedTiles$227001[ebp]
	cmp	eax, DWORD PTR $T237180[ebp]
	jl	SHORT $LN4@IsTestStra@8

; 3213 : 				{
; 3214 : 					return true;

	mov	al, 1
	jmp	SHORT $LN16@IsTestStra@8
$LN4@IsTestStra@8:

; 3215 : 				}
; 3216 : 			}
; 3217 : 		}
; 3218 : 	}
; 3219 : 
; 3220 : 	return false;

	xor	al, al
$LN16@IsTestStra@8:

; 3221 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EarlyExpansion@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EarlyExpansion
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237203 = -60						; size = 4
$T237199 = -56						; size = 4
$T237198 = -52						; size = 4
$T237194 = -48						; size = 4
$T237190 = -44						; size = 4
$T237186 = -40						; size = 4
_eStrategyExpandToOtherContinents$227023 = -36		; size = 4
_iFlavorExpansion$227028 = -32				; size = 4
_iMaxSettlers$ = -28					; size = 4
_iNumExtraSettlers$ = -24				; size = 4
_iBestArea$ = -20					; size = 4
_iSecondBestArea$ = -16					; size = 4
_pStrategy$ = -12					; size = 4
_iSettlersOnMap$ = -8					; size = 4
_iNumSettleAreas$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion, COMDAT

; 3225 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 3226 : 	int iBestArea;
; 3227 : 	int iSecondBestArea;
; 3228 : 
; 3229 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3230 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@IsTestStra@9
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237186[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T237186[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@IsTestStra@9
$LN10@IsTestStra@9:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@IsTestStra@9
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237190[ebp], ecx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T237190[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN11@IsTestStra@9
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237194[ebp], eax
	push	OFFSET ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
	mov	ecx, DWORD PTR $T237194[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@IsTestStra@9
$LN11@IsTestStra@9:

; 3231 : #else
; 3232 : 	if (GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3233 : #endif
; 3234 : 	{
; 3235 : 		return true;

	mov	al, 1
	jmp	$LN13@IsTestStra@9
$LN12@IsTestStra@9:

; 3236 : 	}
; 3237 : 
; 3238 : 	int iNumSettleAreas = pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237198[ebp], eax
	mov	edx, DWORD PTR $T237198[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T237199[ebp], eax
	lea	ecx, DWORD PTR _iSecondBestArea$[ebp]
	push	ecx
	lea	edx, DWORD PTR _iBestArea$[ebp]
	push	edx
	mov	eax, DWORD PTR $T237199[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas
	mov	DWORD PTR _iNumSettleAreas$[ebp], eax

; 3239 : 	if (iNumSettleAreas == 0)

	cmp	DWORD PTR _iNumSettleAreas$[ebp], 0
	jne	SHORT $LN8@IsTestStra@9

; 3240 : 	{
; 3241 : 		return true;

	mov	al, 1
	jmp	$LN13@IsTestStra@9
$LN8@IsTestStra@9:

; 3242 : 	}
; 3243 : 
; 3244 : 	int iNumExtraSettlers = 0;

	mov	DWORD PTR _iNumExtraSettlers$[ebp], 0

; 3245 : 
; 3246 : 	if (!pPlayer->IsEmpireUnhappy())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN7@IsTestStra@9

; 3247 : 	{
; 3248 : 
; 3249 : 		// If we are running "ReallyExpandToOtherContinents"
; 3250 : 		EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_REALLY_EXPAND_TO_OTHER_CONTINENTS");

	push	0
	push	OFFSET ??_C@_0DF@EDEAHICP@ECONOMICAISTRATEGY_REALLY_EXPAND@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyExpandToOtherContinents$227023[ebp], eax

; 3251 : 		if (eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)

	cmp	DWORD PTR _eStrategyExpandToOtherContinents$227023[ebp], -1
	je	SHORT $LN6@IsTestStra@9

; 3252 : 		{
; 3253 : 			if (pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents))

	mov	edx, DWORD PTR _eStrategyExpandToOtherContinents$227023[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@IsTestStra@9

; 3254 : 			{
; 3255 : 				++iNumExtraSettlers;

	mov	ecx, DWORD PTR _iNumExtraSettlers$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumExtraSettlers$[ebp], ecx

; 3256 : 				if (GC.getMap().GetAIMapHint() & 4)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237203[ebp], edx
	mov	ecx, DWORD PTR $T237203[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 4
	je	SHORT $LN6@IsTestStra@9

; 3257 : 				{
; 3258 : 					++iNumExtraSettlers;

	mov	eax, DWORD PTR _iNumExtraSettlers$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumExtraSettlers$[ebp], eax
$LN6@IsTestStra@9:

; 3259 : 				}
; 3260 : 			}
; 3261 : 		}
; 3262 : 
; 3263 : 		// if we are generally expansionistic
; 3264 : 		int iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));

	push	0
	push	OFFSET ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorExpansion$227028[ebp], eax

; 3265 : 		if (iFlavorExpansion > 6)

	cmp	DWORD PTR _iFlavorExpansion$227028[ebp], 6
	jle	SHORT $LN3@IsTestStra@9

; 3266 : 		{
; 3267 : 			++iNumExtraSettlers;

	mov	ecx, DWORD PTR _iNumExtraSettlers$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumExtraSettlers$[ebp], ecx
$LN3@IsTestStra@9:

; 3268 : 		}
; 3269 : 		if (iFlavorExpansion > 8)

	cmp	DWORD PTR _iFlavorExpansion$227028[ebp], 8
	jle	SHORT $LN7@IsTestStra@9

; 3270 : 		{
; 3271 : 			++iNumExtraSettlers;

	mov	edx, DWORD PTR _iNumExtraSettlers$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumExtraSettlers$[ebp], edx
$LN7@IsTestStra@9:

; 3272 : 		}
; 3273 : 
; 3274 : 	}
; 3275 : 
; 3276 : 	int iSettlersOnMap = pPlayer->GetNumUnitsWithUnitAI(UNITAI_SETTLE, true);

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iSettlersOnMap$[ebp], eax

; 3277 : 
; 3278 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$[ebp], eax

; 3279 : 	int iMaxSettlers = /*1*/ pStrategy->GetWeightThreshold();

	mov	ecx, DWORD PTR _pStrategy$[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	mov	DWORD PTR _iMaxSettlers$[ebp], eax

; 3280 : 
; 3281 : 	if (iSettlersOnMap >= iMaxSettlers + iNumExtraSettlers)

	mov	ecx, DWORD PTR _iMaxSettlers$[ebp]
	add	ecx, DWORD PTR _iNumExtraSettlers$[ebp]
	cmp	DWORD PTR _iSettlersOnMap$[ebp], ecx
	jl	SHORT $LN1@IsTestStra@9

; 3282 : 	{
; 3283 : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@IsTestStra@9
$LN1@IsTestStra@9:

; 3284 : 	}
; 3285 : 
; 3286 : 	return false;

	xor	al, al
$LN13@IsTestStra@9:

; 3287 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughExpansion@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughExpansion
_TEXT	ENDS
EXTRN	?getTotalPopulation@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getTotalPopulation
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237209 = -20						; size = 4
_iWeightThresholdModifier$227044 = -16			; size = 4
_iDivisor$227045 = -12					; size = 4
_pStrategy$227043 = -8					; size = 4
_iExcessHappiness$227042 = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedHappiness, COMDAT

; 3291 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3292 : 	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237209[ebp], eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR $T237209[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@IsTestStra@10

; 3293 : 	{
; 3294 : 		return false;

	xor	al, al
	jmp	SHORT $LN4@IsTestStra@10
$LN3@IsTestStra@10:

; 3295 : 	}
; 3296 : 
; 3297 : 	if(pPlayer->getTotalPopulation() > 0 && pPlayer->GetUnhappiness() > 0)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getTotalPopulation@CvPlayer@@QBEHXZ	; CvPlayer::getTotalPopulation
	test	eax, eax
	jle	SHORT $LN2@IsTestStra@10
	push	0
	push	0
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	test	eax, eax
	jle	SHORT $LN2@IsTestStra@10

; 3298 : 	{
; 3299 : 		int iExcessHappiness = pPlayer->GetExcessHappiness();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	DWORD PTR _iExcessHappiness$227042[ebp], eax

; 3300 : 
; 3301 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$227043[ebp], eax

; 3302 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);	// 1 Weight per HAPPINESS Flavor

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$227044[ebp], eax

; 3303 : 
; 3304 : 		// This will range from 0 to 5. If Happiness is less than this we will activate the strategy
; 3305 : 		int iDivisor = /*2*/ pStrategy->GetWeightThreshold();

	mov	ecx, DWORD PTR _pStrategy$227043[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	mov	DWORD PTR _iDivisor$227045[ebp], eax

; 3306 : 		iWeightThresholdModifier /= iDivisor;

	mov	eax, DWORD PTR _iWeightThresholdModifier$227044[ebp]
	cdq
	idiv	DWORD PTR _iDivisor$227045[ebp]
	mov	DWORD PTR _iWeightThresholdModifier$227044[ebp], eax

; 3307 : 
; 3308 : 		if(iExcessHappiness <= iWeightThresholdModifier)

	mov	edx, DWORD PTR _iExcessHappiness$227042[ebp]
	cmp	edx, DWORD PTR _iWeightThresholdModifier$227044[ebp]
	jg	SHORT $LN2@IsTestStra@10

; 3309 : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@IsTestStra@10
$LN2@IsTestStra@10:

; 3310 : 	}
; 3311 : 
; 3312 : 	return false;

	xor	al, al
$LN4@IsTestStra@10:

; 3313 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedHappiness@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedHappiness
_TEXT	ENDS
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237215 = -16						; size = 4
_iThreshold$227056 = -12				; size = 4
_pStrategy$227055 = -8					; size = 4
_iExcessHappiness$227054 = -4				; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical, COMDAT

; 3317 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3318 : 	if(GC.getGame().isOption(GAMEOPTION_NO_HAPPINESS))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237215[ebp], eax
	push	19					; 00000013H
	mov	ecx, DWORD PTR $T237215[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsTestStra@11

; 3319 : 	{
; 3320 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsTestStra@11
$LN4@IsTestStra@11:

; 3321 : 	}
; 3322 : 
; 3323 : 	// If we're losing at war, return false
; 3324 : 	if(pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	SHORT $LN3@IsTestStra@11

; 3325 : 		return false;

	xor	al, al
	jmp	SHORT $LN5@IsTestStra@11
$LN3@IsTestStra@11:

; 3326 : 
; 3327 : 	if(pPlayer->getTotalPopulation() > 0 && pPlayer->GetUnhappiness() > 0)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getTotalPopulation@CvPlayer@@QBEHXZ	; CvPlayer::getTotalPopulation
	test	eax, eax
	jle	SHORT $LN2@IsTestStra@11
	push	0
	push	0
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetUnhappiness@CvPlayer@@QBEHPAVCvCity@@0@Z ; CvPlayer::GetUnhappiness
	test	eax, eax
	jle	SHORT $LN2@IsTestStra@11

; 3328 : 	{
; 3329 : 		int iExcessHappiness = pPlayer->GetExcessHappiness();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetExcessHappiness@CvPlayer@@QBEHXZ	; CvPlayer::GetExcessHappiness
	mov	DWORD PTR _iExcessHappiness$227054[ebp], eax

; 3330 : 
; 3331 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$227055[ebp], eax

; 3332 : 		int iThreshold = /*-3*/ pStrategy->GetWeightThreshold();

	mov	ecx, DWORD PTR _pStrategy$227055[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	mov	DWORD PTR _iThreshold$227056[ebp], eax

; 3333 : 
; 3334 : 		if(iExcessHappiness <= iThreshold)

	mov	eax, DWORD PTR _iExcessHappiness$227054[ebp]
	cmp	eax, DWORD PTR _iThreshold$227056[ebp]
	jg	SHORT $LN2@IsTestStra@11

; 3335 : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@IsTestStra@11
$LN2@IsTestStra@11:

; 3336 : 	}
; 3337 : 
; 3338 : 	return false;

	xor	al, al
$LN5@IsTestStra@11:

; 3339 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedHappinessCritical@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedHappinessCritical
_TEXT	ENDS
PUBLIC	??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@ ; `string'
EXTRN	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z:PROC ; CvCityStrategyAI::IsUsingCityStrategy
;	COMDAT ??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@
CONST	SEGMENT
??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@ DB 'AICITYSTRATEGY_N'
	DB	'EED_NAVAL_GROWTH', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iWeightThresholdModifier$227075 = -32			; size = 4
_iCurrentWeight$227077 = -28				; size = 4
_pStrategy$227074 = -24					; size = 4
_iWeightThreshold$227076 = -20				; size = 4
_eStrategyNeedNavalGrowth$ = -16			; size = 4
_pLoopCity$ = -12					; size = 4
_iNumCitiesNeedNavalGrowth$ = -8			; size = 4
_iLoop$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth, COMDAT

; 3343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3344 : 	int iNumCitiesNeedNavalGrowth = 0;

	mov	DWORD PTR _iNumCitiesNeedNavalGrowth$[ebp], 0

; 3345 : 
; 3346 : 	CvCity* pLoopCity;
; 3347 : 	int iLoop;
; 3348 : 
; 3349 : 	AICityStrategyTypes eStrategyNeedNavalGrowth = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_NAVAL_GROWTH");

	push	0
	push	OFFSET ??_C@_0CB@OGNJHFNH@AICITYSTRATEGY_NEED_NAVAL_GROWTH@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyNeedNavalGrowth$[ebp], eax

; 3350 : 
; 3351 : 	// CityStrategy doesn't exist in XML, so abort
; 3352 : 	if(eStrategyNeedNavalGrowth == NO_AICITYSTRATEGY)

	cmp	DWORD PTR _eStrategyNeedNavalGrowth$[ebp], -1
	jne	SHORT $LN7@IsTestStra@12

; 3353 : 	{
; 3354 : 		return false;

	xor	al, al
	jmp	$LN8@IsTestStra@12
$LN7@IsTestStra@12:

; 3355 : 	}
; 3356 : 
; 3357 : 	for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN6@IsTestStra@12
$LN5@IsTestStra@12:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN6@IsTestStra@12:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN4@IsTestStra@12

; 3358 : 	{
; 3359 : 		if(pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(eStrategyNeedNavalGrowth))

	mov	edx, DWORD PTR _eStrategyNeedNavalGrowth$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@IsTestStra@12

; 3360 : 		{
; 3361 : 			iNumCitiesNeedNavalGrowth++;

	mov	ecx, DWORD PTR _iNumCitiesNeedNavalGrowth$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumCitiesNeedNavalGrowth$[ebp], ecx
$LN3@IsTestStra@12:

; 3362 : 		}
; 3363 : 	}

	jmp	SHORT $LN5@IsTestStra@12
$LN4@IsTestStra@12:

; 3364 : 
; 3365 : 	if(iNumCitiesNeedNavalGrowth > 0)

	cmp	DWORD PTR _iNumCitiesNeedNavalGrowth$[ebp], 0
	jle	SHORT $LN2@IsTestStra@12

; 3366 : 	{
; 3367 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$227074[ebp], eax

; 3368 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);	// 1 Weight per NAVAL_GROWTH Flavor

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$227075[ebp], eax

; 3369 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 25

	mov	ecx, DWORD PTR _pStrategy$227074[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$227075[ebp]
	mov	DWORD PTR _iWeightThreshold$227076[ebp], eax

; 3370 : 
; 3371 : 		int iCurrentWeight = (pPlayer->getNumCities() - 1) * 10;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	sub	eax, 1
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _iCurrentWeight$227077[ebp], eax

; 3372 : 		iCurrentWeight /= iWeightThreshold;

	mov	eax, DWORD PTR _iCurrentWeight$227077[ebp]
	cdq
	idiv	DWORD PTR _iWeightThreshold$227076[ebp]
	mov	DWORD PTR _iCurrentWeight$227077[ebp], eax

; 3373 : 
; 3374 : 		// See CvStrategyAI::IsTestStrategy_CitiesNeedBorders for a couple examples on how the math here works
; 3375 : 
; 3376 : 		// Do enough of our Cities want NavalGrowth? [Average is 10/30; range is 10/25 to 10/35]
; 3377 : //		if (iNumCitiesNeedNavalGrowth > (GetPlayer()->getNumCities() - 1) / GC.getAI_STRATEGY_CITIES_NAVAL_GROWTH_DIVISOR())	// 3
; 3378 : 		if(iNumCitiesNeedNavalGrowth > iCurrentWeight)

	mov	edx, DWORD PTR _iNumCitiesNeedNavalGrowth$[ebp]
	cmp	edx, DWORD PTR _iCurrentWeight$227077[ebp]
	jle	SHORT $LN2@IsTestStra@12

; 3379 : 		{
; 3380 : 			return true;

	mov	al, 1
	jmp	SHORT $LN8@IsTestStra@12
$LN2@IsTestStra@12:

; 3381 : 		}
; 3382 : 	}
; 3383 : 
; 3384 : 	return false;

	xor	al, al
$LN8@IsTestStra@12:

; 3385 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_CitiesNeedNavalGrowth@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalGrowth
_TEXT	ENDS
PUBLIC	??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@ ; `string'
;	COMDAT ??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@
CONST	SEGMENT
??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@ DB 'AICITYSTRATEGY_N'
	DB	'EED_NAVAL_TILE_IMPROVEMENT', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iWeightThresholdModifier$227096 = -32			; size = 4
_iCurrentWeight$227098 = -28				; size = 4
_pStrategy$227095 = -24					; size = 4
_iWeightThreshold$227097 = -20				; size = 4
_eStrategyNeedNavalTileImprovement$ = -16		; size = 4
_pLoopCity$ = -12					; size = 4
_iNumCitiesNeedNavalTileImprovement$ = -8		; size = 4
_iLoop$ = -4						; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement, COMDAT

; 3389 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3390 : 	int iNumCitiesNeedNavalTileImprovement = 0;

	mov	DWORD PTR _iNumCitiesNeedNavalTileImprovement$[ebp], 0

; 3391 : 
; 3392 : 	CvCity* pLoopCity;
; 3393 : 	int iLoop;
; 3394 : 
; 3395 : 	AICityStrategyTypes eStrategyNeedNavalTileImprovement = (AICityStrategyTypes) GC.getInfoTypeForString("AICITYSTRATEGY_NEED_NAVAL_TILE_IMPROVEMENT");

	push	0
	push	OFFSET ??_C@_0CL@NDBKHKDA@AICITYSTRATEGY_NEED_NAVAL_TILE_I@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyNeedNavalTileImprovement$[ebp], eax

; 3396 : 
; 3397 : 	// CityStrategy doesn't exist in XML, so abort
; 3398 : 	if(eStrategyNeedNavalTileImprovement == NO_AICITYSTRATEGY)

	cmp	DWORD PTR _eStrategyNeedNavalTileImprovement$[ebp], -1
	jne	SHORT $LN7@IsTestStra@13

; 3399 : 	{
; 3400 : 		return false;

	xor	al, al
	jmp	$LN8@IsTestStra@13
$LN7@IsTestStra@13:

; 3401 : 	}
; 3402 : 
; 3403 : 	for(pLoopCity = pPlayer->firstCity(&iLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN6@IsTestStra@13
$LN5@IsTestStra@13:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN6@IsTestStra@13:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN4@IsTestStra@13

; 3404 : 	{
; 3405 : 		if(pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(eStrategyNeedNavalTileImprovement))

	mov	edx, DWORD PTR _eStrategyNeedNavalTileImprovement$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@IsTestStra@13

; 3406 : 		{
; 3407 : 			iNumCitiesNeedNavalTileImprovement++;

	mov	ecx, DWORD PTR _iNumCitiesNeedNavalTileImprovement$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumCitiesNeedNavalTileImprovement$[ebp], ecx
$LN3@IsTestStra@13:

; 3408 : 		}
; 3409 : 	}

	jmp	SHORT $LN5@IsTestStra@13
$LN4@IsTestStra@13:

; 3410 : 
; 3411 : 	if(iNumCitiesNeedNavalTileImprovement > 0)

	cmp	DWORD PTR _iNumCitiesNeedNavalTileImprovement$[ebp], 0
	jle	SHORT $LN2@IsTestStra@13

; 3412 : 	{
; 3413 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	edx, DWORD PTR _eStrategy$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$227095[ebp], eax

; 3414 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);	// 1 Weight per NAVAL_TILE_IMPROVEMENT Flavor

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$227096[ebp], eax

; 3415 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;	// 25

	mov	ecx, DWORD PTR _pStrategy$227095[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$227096[ebp]
	mov	DWORD PTR _iWeightThreshold$227097[ebp], eax

; 3416 : 
; 3417 : 		int iCurrentWeight = (pPlayer->getNumCities() - 1) * 10;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	sub	eax, 1
	imul	eax, 10					; 0000000aH
	mov	DWORD PTR _iCurrentWeight$227098[ebp], eax

; 3418 : 		iCurrentWeight /= iWeightThreshold;

	mov	eax, DWORD PTR _iCurrentWeight$227098[ebp]
	cdq
	idiv	DWORD PTR _iWeightThreshold$227097[ebp]
	mov	DWORD PTR _iCurrentWeight$227098[ebp], eax

; 3419 : 
; 3420 : 		// See CvStrategyAI::IsTestStrategy_CitiesNeedBorders for a couple examples on how the math here works
; 3421 : 
; 3422 : 		// Do enough of our Cities want NavalTileImprovement? [Average is 10/30; range is 10/25 to 10/35]
; 3423 : 		if(iNumCitiesNeedNavalTileImprovement > iCurrentWeight)

	mov	edx, DWORD PTR _iNumCitiesNeedNavalTileImprovement$[ebp]
	cmp	edx, DWORD PTR _iCurrentWeight$227098[ebp]
	jle	SHORT $LN2@IsTestStra@13

; 3424 : 		{
; 3425 : 			return true;

	mov	al, 1
	jmp	SHORT $LN8@IsTestStra@13
$LN2@IsTestStra@13:

; 3426 : 		}
; 3427 : 	}
; 3428 : 
; 3429 : 	return false;

	xor	al, al
$LN8@IsTestStra@13:

; 3430 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_CitiesNeedNavalTileImprovement@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_CitiesNeedNavalTileImprovement
_TEXT	ENDS
PUBLIC	??_C@_0CC@IAPDDPEG@Randomly?5choose?5an?5area?5to?5settl@ ; `string'
EXTRN	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z:PROC ; CvPlayer::addAIOperation
EXTRN	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z:PROC ; CvPlayer::GetBestSettlePlot
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
EXTRN	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ:PROC ; CvPlayer::GetPlayerTraits
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
;	COMDAT ??_C@_0CC@IAPDDPEG@Randomly?5choose?5an?5area?5to?5settl@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CC@IAPDDPEG@Randomly?5choose?5an?5area?5to?5settl@ DB 'Randomly ch'
	DB	'oose an area to settle', 00H		; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
tv176 = -92						; size = 4
$T237262 = -88						; size = 4
$T237258 = -81						; size = 1
$T237257 = -80						; size = 4
$T237253 = -76						; size = 4
$T237249 = -72						; size = 4
$T237240 = -68						; size = 4
$T237239 = -64						; size = 4
$T237235 = -60						; size = 4
$T237231 = -56						; size = 4
$T237227 = -52						; size = 4
_pPlot$227132 = -48					; size = 4
_iRandArea$227129 = -44					; size = 4
_bCanEmbark$227126 = -38				; size = 1
_bWantEscort$227127 = -37				; size = 1
_iArea$ = -36						; size = 4
_iLooseSettler$ = -32					; size = 4
_pFirstSettler$ = -28					; size = 4
_iFirstSettlerArea$ = -24				; size = 4
_pLoopUnit$ = -20					; size = 4
_iBestArea$ = -16					; size = 4
_iSecondBestArea$ = -12					; size = 4
_iNumAreas$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
___formal$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_FoundCity, COMDAT

; 3436 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 3437 : 	int iUnitLoop;
; 3438 : 	CvUnit* pLoopUnit;
; 3439 : 	CvUnit* pFirstSettler = 0;

	mov	DWORD PTR _pFirstSettler$[ebp], 0

; 3440 : 	int iLooseSettler = 0;

	mov	DWORD PTR _iLooseSettler$[ebp], 0

; 3441 : 	//int iStrategyWeight = 0;
; 3442 : 	int iFirstSettlerArea = -1;

	mov	DWORD PTR _iFirstSettlerArea$[ebp], -1

; 3443 : 	int iBestArea;
; 3444 : 	int iSecondBestArea;
; 3445 : 	int iNumAreas;
; 3446 : 	int iArea = -1;

	mov	DWORD PTR _iArea$[ebp], -1

; 3447 : 
; 3448 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3449 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN20@IsTestStra@14
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237227[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T237227[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN21@IsTestStra@14
$LN20@IsTestStra@14:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN22@IsTestStra@14
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237231[ebp], ecx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T237231[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN21@IsTestStra@14
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237235[ebp], eax
	push	OFFSET ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
	mov	ecx, DWORD PTR $T237235[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN22@IsTestStra@14
$LN21@IsTestStra@14:

; 3450 : #else
; 3451 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3452 : #endif
; 3453 : 	{
; 3454 : 		return false;

	xor	al, al
	jmp	$LN23@IsTestStra@14
$LN22@IsTestStra@14:

; 3455 : 	}
; 3456 : 
; 3457 : 	// Never run this strategy for a human player
; 3458 : 	if(!pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	edx, al
	test	edx, edx
	jne	$LN18@IsTestStra@14

; 3459 : 	{
; 3460 : 		// Look at map for loose settlers
; 3461 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN17@IsTestStra@14
$LN16@IsTestStra@14:
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN17@IsTestStra@14:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN15@IsTestStra@14

; 3462 : 		{
; 3463 : 			if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN14@IsTestStra@14

; 3464 : 			{
; 3465 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	jne	SHORT $LN14@IsTestStra@14

; 3466 : 				{
; 3467 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN14@IsTestStra@14

; 3468 : 					{
; 3469 : 						iLooseSettler++;

	mov	edx, DWORD PTR _iLooseSettler$[ebp]
	add	edx, 1
	mov	DWORD PTR _iLooseSettler$[ebp], edx

; 3470 : 						iFirstSettlerArea = pLoopUnit->getArea();

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	mov	DWORD PTR _iFirstSettlerArea$[ebp], eax

; 3471 : 						pFirstSettler = pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR _pFirstSettler$[ebp], eax

; 3472 : 						break;

	jmp	SHORT $LN15@IsTestStra@14
$LN14@IsTestStra@14:

; 3473 : 					}
; 3474 : 				}
; 3475 : 			}
; 3476 : 		}

	jmp	SHORT $LN16@IsTestStra@14
$LN15@IsTestStra@14:

; 3477 : 
; 3478 : 		// Don't run this strategy if have 0 cities, in that case we just want to drop down a city wherever we happen to be
; 3479 : 		if (iLooseSettler && pPlayer->getNumCities() >= 1)

	cmp	DWORD PTR _iLooseSettler$[ebp], 0
	je	$LN18@IsTestStra@14
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jl	$LN18@IsTestStra@14

; 3480 : 		{
; 3481 : 			iNumAreas = pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237239[ebp], eax
	mov	ecx, DWORD PTR $T237239[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR $T237240[ebp], edx
	lea	eax, DWORD PTR _iSecondBestArea$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iBestArea$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237240[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas
	mov	DWORD PTR _iNumAreas$[ebp], eax

; 3482 : 			if(iNumAreas == 0)

	cmp	DWORD PTR _iNumAreas$[ebp], 0
	jne	SHORT $LN37@IsTestStra@14

; 3483 : 			{
; 3484 : 				return false;

	xor	al, al
	jmp	$LN23@IsTestStra@14

; 3485 : 			}
; 3486 : 
; 3487 : 			bool bCanEmbark = GET_TEAM(pPlayer->getTeam()).canEmbark() || pPlayer->GetPlayerTraits()->IsEmbarkedAllWater();

$LN37@IsTestStra@14:
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237249[ebp], eax
	mov	edx, DWORD PTR $T237249[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237253[ebp], edx
	mov	ecx, DWORD PTR $T237253[ebp]
	call	?canEmbark@CvTeam@@QBE_NXZ		; CvTeam::canEmbark
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@IsTestStra@14
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerTraits@CvPlayer@@QBEPAVCvPlayerTraits@@XZ ; CvPlayer::GetPlayerTraits
	mov	DWORD PTR $T237257[ebp], eax
	mov	ecx, DWORD PTR $T237257[ebp]
	mov	dl, BYTE PTR [ecx+336]
	mov	BYTE PTR $T237258[ebp], dl
	movzx	eax, BYTE PTR $T237258[ebp]
	test	eax, eax
	jne	SHORT $LN25@IsTestStra@14
	mov	DWORD PTR tv176[ebp], 0
	jmp	SHORT $LN26@IsTestStra@14
$LN25@IsTestStra@14:
	mov	DWORD PTR tv176[ebp], 1
$LN26@IsTestStra@14:
	mov	cl, BYTE PTR tv176[ebp]
	mov	BYTE PTR _bCanEmbark$227126[ebp], cl

; 3488 : 			bool bWantEscort = false;

	mov	BYTE PTR _bWantEscort$227127[ebp], 0

; 3489 : 
; 3490 : 			// CASE 1: we can go offshore
; 3491 : 			if (bCanEmbark && (pPlayer->getNumCities() > 1))

	movzx	edx, BYTE PTR _bCanEmbark$227126[ebp]
	test	edx, edx
	je	$LN9@IsTestStra@14
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jle	$LN9@IsTestStra@14

; 3492 : 			{
; 3493 : 				int iRandArea = GC.getGame().getJonRandNum(6, "Randomly choose an area to settle");

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237262[ebp], eax
	push	OFFSET ??_C@_0CC@IAPDDPEG@Randomly?5choose?5an?5area?5to?5settl@
	push	6
	mov	ecx, DWORD PTR $T237262[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _iRandArea$227129[ebp], eax

; 3494 : 
; 3495 : 				if (iRandArea <= 1) // this is "pick best tile I know ignoring what area it is part of", in the early game this is usually the start landmass

	cmp	DWORD PTR _iRandArea$227129[ebp], 1
	jg	SHORT $LN8@IsTestStra@14

; 3496 : 				{
; 3497 : 					iArea = -1;

	mov	DWORD PTR _iArea$[ebp], -1

; 3498 : 					CvPlot* pPlot = pPlayer->GetBestSettlePlot(pFirstSettler, bWantEscort, -1);

	push	-1
	movzx	ecx, BYTE PTR _bWantEscort$227127[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFirstSettler$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
	mov	DWORD PTR _pPlot$227132[ebp], eax

; 3499 : 					if (!pPlot)

	cmp	DWORD PTR _pPlot$227132[ebp], 0
	jne	SHORT $LN7@IsTestStra@14

; 3500 : 					{
; 3501 : 						bWantEscort = true;

	mov	BYTE PTR _bWantEscort$227127[ebp], 1
$LN7@IsTestStra@14:

; 3502 : 					}
; 3503 : 				}

	jmp	SHORT $LN6@IsTestStra@14
$LN8@IsTestStra@14:

; 3504 : 				else if (iRandArea == 2) // least likely

	cmp	DWORD PTR _iRandArea$227129[ebp], 2
	jne	SHORT $LN5@IsTestStra@14

; 3505 : 				{
; 3506 : 					iArea = iSecondBestArea;

	mov	eax, DWORD PTR _iSecondBestArea$[ebp]
	mov	DWORD PTR _iArea$[ebp], eax

; 3507 : 					bWantEscort = IsAreaSafeForQuickColony(iArea, pPlayer);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iArea$[ebp]
	push	edx
	call	?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z ; EconomicAIHelpers::IsAreaSafeForQuickColony
	add	esp, 8
	mov	BYTE PTR _bWantEscort$227127[ebp], al

; 3508 : 				}
; 3509 : 				else // this is as likely as the other options combined

	jmp	SHORT $LN6@IsTestStra@14
$LN5@IsTestStra@14:

; 3510 : 				{
; 3511 : 					iArea = iBestArea;

	mov	eax, DWORD PTR _iBestArea$[ebp]
	mov	DWORD PTR _iArea$[ebp], eax

; 3512 : 					bWantEscort = IsAreaSafeForQuickColony(iArea, pPlayer);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iArea$[ebp]
	push	edx
	call	?IsAreaSafeForQuickColony@EconomicAIHelpers@@YA_NHPAVCvPlayer@@@Z ; EconomicAIHelpers::IsAreaSafeForQuickColony
	add	esp, 8
	mov	BYTE PTR _bWantEscort$227127[ebp], al
$LN6@IsTestStra@14:

; 3513 : 				}
; 3514 : 
; 3515 : 				if (bWantEscort)

	movzx	eax, BYTE PTR _bWantEscort$227127[ebp]
	test	eax, eax
	je	SHORT $LN3@IsTestStra@14

; 3516 : 				{
; 3517 : 					pPlayer->addAIOperation(AI_OPERATION_FOUND_CITY, NO_PLAYER, iArea);

	push	0
	push	0
	mov	ecx, DWORD PTR _iArea$[ebp]
	push	ecx
	push	-1
	push	4
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 3518 : 				}
; 3519 : 				else

	jmp	SHORT $LN2@IsTestStra@14
$LN3@IsTestStra@14:

; 3520 : 				{
; 3521 : 					pPlayer->addAIOperation(AI_OPERATION_QUICK_COLONIZE, NO_PLAYER, iArea);

	push	0
	push	0
	mov	edx, DWORD PTR _iArea$[ebp]
	push	edx
	push	-1
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation
$LN2@IsTestStra@14:

; 3522 : 				}
; 3523 : 
; 3524 : 				return true;

	mov	al, 1
	jmp	SHORT $LN23@IsTestStra@14

; 3525 : 			}
; 3526 : 			else // we can't embark yet

	jmp	SHORT $LN18@IsTestStra@14
$LN9@IsTestStra@14:

; 3527 : 			{
; 3528 : 				pPlayer->addAIOperation(AI_OPERATION_FOUND_CITY, NO_PLAYER, iBestArea);

	push	0
	push	0
	mov	eax, DWORD PTR _iBestArea$[ebp]
	push	eax
	push	-1
	push	4
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 3529 : 				return true;

	mov	al, 1
	jmp	SHORT $LN23@IsTestStra@14
$LN18@IsTestStra@14:

; 3530 : 			}
; 3531 : 		}
; 3532 : 	}
; 3533 : 
; 3534 : 	return false;

	xor	al, al
$LN23@IsTestStra@14:

; 3535 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_FoundCity@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_FoundCity
_TEXT	ENDS
EXTRN	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ:PROC ; CvUnit::GetGreatPeopleDirective
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iWeightThresholdModifier$227156 = -28			; size = 4
_pStrategy$227155 = -24					; size = 4
_iWeightThreshold$227157 = -20				; size = 4
_iLooseMerchant$ = -16					; size = 4
_iStrategyWeight$ = -12					; size = 4
_pLoopUnit$ = -8					; size = 4
_iUnitLoop$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState, COMDAT

; 3540 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3541 : 	int iUnitLoop;
; 3542 : 	CvUnit* pLoopUnit;
; 3543 : 	int iLooseMerchant = 0;

	mov	DWORD PTR _iLooseMerchant$[ebp], 0

; 3544 : 	int iStrategyWeight = 0;

	mov	DWORD PTR _iStrategyWeight$[ebp], 0

; 3545 : 
; 3546 : 	// Never run this strategy for a human player
; 3547 : 	if(!pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	$LN8@IsTestStra@15

; 3548 : 	{
; 3549 : 		// Look at map for loose merchants
; 3550 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN7@IsTestStra@15
$LN6@IsTestStra@15:
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN7@IsTestStra@15:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN5@IsTestStra@15

; 3551 : 		{
; 3552 : 			if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN4@IsTestStra@15

; 3553 : 			{
; 3554 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_MERCHANT && pLoopUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_USE_POWER)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 14					; 0000000eH
	jne	SHORT $LN4@IsTestStra@15
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	cmp	eax, 1
	jne	SHORT $LN4@IsTestStra@15

; 3555 : 				{
; 3556 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN4@IsTestStra@15

; 3557 : 					{
; 3558 : 						iLooseMerchant++;

	mov	eax, DWORD PTR _iLooseMerchant$[ebp]
	add	eax, 1
	mov	DWORD PTR _iLooseMerchant$[ebp], eax
$LN4@IsTestStra@15:

; 3559 : 					}
; 3560 : 				}
; 3561 : 			}
; 3562 : 		}

	jmp	SHORT $LN6@IsTestStra@15
$LN5@IsTestStra@15:

; 3563 : 
; 3564 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$227155[ebp], eax

; 3565 : 		iStrategyWeight = iLooseMerchant * 10;   // Just one merchant will trigger this

	mov	edx, DWORD PTR _iLooseMerchant$[ebp]
	imul	edx, 10					; 0000000aH
	mov	DWORD PTR _iStrategyWeight$[ebp], edx

; 3566 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$227156[ebp], eax

; 3567 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;

	mov	ecx, DWORD PTR _pStrategy$227155[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$227156[ebp]
	mov	DWORD PTR _iWeightThreshold$227157[ebp], eax

; 3568 : 
; 3569 : 		if(iStrategyWeight >= iWeightThreshold)

	mov	edx, DWORD PTR _iStrategyWeight$[ebp]
	cmp	edx, DWORD PTR _iWeightThreshold$227157[ebp]
	jl	SHORT $LN8@IsTestStra@15

; 3570 : 		{
; 3571 : 			// Launch an operation.
; 3572 : 			pPlayer->addAIOperation(AI_OPERATION_MERCHANT_DELEGATION);

	push	0
	push	0
	push	-1
	push	-1
	push	8
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 3573 : 
; 3574 : 			// Set this strategy active
; 3575 : 			return true;

	mov	al, 1
	jmp	SHORT $LN9@IsTestStra@15
$LN8@IsTestStra@15:

; 3576 : 		}
; 3577 : 	}
; 3578 : 
; 3579 : 	return false;

	xor	al, al
$LN9@IsTestStra@15:

; 3580 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_TradeWithCityState@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_TradeWithCityState
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_iWeightThresholdModifier$227175 = -28			; size = 4
_pStrategy$227174 = -24					; size = 4
_iWeightThreshold$227176 = -20				; size = 4
_iStrategyWeight$ = -16					; size = 4
_pLoopUnit$ = -12					; size = 4
_iUnitLoop$ = -8					; size = 4
_iLooseMusician$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ConcertTour, COMDAT

; 3584 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3585 : 	int iUnitLoop;
; 3586 : 	CvUnit* pLoopUnit;
; 3587 : 	int iLooseMusician = 0;

	mov	DWORD PTR _iLooseMusician$[ebp], 0

; 3588 : 	int iStrategyWeight = 0;

	mov	DWORD PTR _iStrategyWeight$[ebp], 0

; 3589 : 
; 3590 : 	// Never run this strategy for a human player
; 3591 : 	if(!pPlayer->isHuman())

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	$LN8@IsTestStra@16

; 3592 : 	{
; 3593 : 		// Look at map for loose merchants
; 3594 : 		for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN7@IsTestStra@16
$LN6@IsTestStra@16:
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN7@IsTestStra@16:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN5@IsTestStra@16

; 3595 : 		{
; 3596 : 			if(pLoopUnit != NULL)

	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN4@IsTestStra@16

; 3597 : 			{
; 3598 : 				if(pLoopUnit->AI_getUnitAIType() == UNITAI_MUSICIAN && pLoopUnit->GetGreatPeopleDirective() == GREAT_PEOPLE_DIRECTIVE_TOURISM_BLAST)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN4@IsTestStra@16
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?GetGreatPeopleDirective@CvUnit@@QBE?AW4GreatPeopleDirectiveTypes@@XZ ; CvUnit::GetGreatPeopleDirective
	cmp	eax, 5
	jne	SHORT $LN4@IsTestStra@16

; 3599 : 				{
; 3600 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	SHORT $LN4@IsTestStra@16

; 3601 : 					{
; 3602 : 						iLooseMusician++;

	mov	eax, DWORD PTR _iLooseMusician$[ebp]
	add	eax, 1
	mov	DWORD PTR _iLooseMusician$[ebp], eax
$LN4@IsTestStra@16:

; 3603 : 					}
; 3604 : 				}
; 3605 : 			}
; 3606 : 		}

	jmp	SHORT $LN6@IsTestStra@16
$LN5@IsTestStra@16:

; 3607 : 
; 3608 : 		CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$227174[ebp], eax

; 3609 : 		iStrategyWeight = iLooseMusician * 10;   // Just one musician will trigger this

	mov	edx, DWORD PTR _iLooseMusician$[ebp]
	imul	edx, 10					; 0000000aH
	mov	DWORD PTR _iStrategyWeight$[ebp], edx

; 3610 : 		int iWeightThresholdModifier = GetWeightThresholdModifier(eStrategy, pPlayer);

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eStrategy$[ebp]
	push	ecx
	call	?GetWeightThresholdModifier@EconomicAIHelpers@@YAHW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ; EconomicAIHelpers::GetWeightThresholdModifier
	add	esp, 8
	mov	DWORD PTR _iWeightThresholdModifier$227175[ebp], eax

; 3611 : 		int iWeightThreshold = pStrategy->GetWeightThreshold() + iWeightThresholdModifier;

	mov	ecx, DWORD PTR _pStrategy$227174[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	add	eax, DWORD PTR _iWeightThresholdModifier$227175[ebp]
	mov	DWORD PTR _iWeightThreshold$227176[ebp], eax

; 3612 : 
; 3613 : 		if(iStrategyWeight >= iWeightThreshold)

	mov	edx, DWORD PTR _iStrategyWeight$[ebp]
	cmp	edx, DWORD PTR _iWeightThreshold$227176[ebp]
	jl	SHORT $LN8@IsTestStra@16

; 3614 : 		{
; 3615 : 			// Launch an operation.
; 3616 : 			pPlayer->addAIOperation(AI_OPERATION_CONCERT_TOUR);

	push	0
	push	0
	push	-1
	push	-1
	push	19					; 00000013H
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?addAIOperation@CvPlayer@@QAEPAVCvAIOperation@@HW4PlayerTypes@@HPAVCvCity@@1@Z ; CvPlayer::addAIOperation

; 3617 : 
; 3618 : 			// Set this strategy active
; 3619 : 			return true;

	mov	al, 1
	jmp	SHORT $LN9@IsTestStra@16
$LN8@IsTestStra@16:

; 3620 : 		}
; 3621 : 	}
; 3622 : 
; 3623 : 	return false;

	xor	al, al
$LN9@IsTestStra@16:

; 3624 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_ConcertTour@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ConcertTour
_TEXT	ENDS
PUBLIC	??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@ ; `string'
PUBLIC	??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@ ; `string'
EXTRN	?GetYieldChange@CvImprovementEntry@@QBEHH@Z:PROC ; CvImprovementEntry::GetYieldChange
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
;	COMDAT ??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
CONST	SEGMENT
??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@ DB 'AICITYSTRATEGY_N'
	DB	'EED_IMPROVEMENT_PRODUCTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@
CONST	SEGMENT
??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@ DB 'AICITYSTRATEGY_N'
	DB	'EED_IMPROVEMENT_FOOD', 00H			; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z
_TEXT	SEGMENT
tv243 = -112						; size = 4
tv64 = -108						; size = 4
$T237314 = -104						; size = 4
$T237307 = -100						; size = 4
$T237300 = -96						; size = 4
$T237296 = -92						; size = 4
$T237289 = -88						; size = 4
$T237285 = -84						; size = 4
$T237281 = -80						; size = 4
$T237272 = -76						; size = 4
_pPlot$227235 = -72					; size = 4
_ui$227230 = -68					; size = 4
_aPlots$227228 = -64					; size = 4
_eImprovement$227225 = -60				; size = 4
_bCanBuild$227229 = -53					; size = 1
_pkBuildInfo$227220 = -52				; size = 4
_iCityLoop$ = -48					; size = 4
_pBuilder$ = -44					; size = 4
_eCityStrategy$ = -40					; size = 4
_iNumCities$ = -36					; size = 4
_iNumCitiesConcerned$ = -32				; size = 4
_eBuild$ = -28						; size = 4
_fWarningRatio$ = -24					; size = 8
_pLoopUnit$ = -16					; size = 4
_iUnitLoop$ = -12					; size = 4
_pLoopCity$ = -8					; size = 4
_iBuildIndex$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
_eYield$ = 12						; size = 4
?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedImprovement, COMDAT

; 3628 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H

; 3629 : 	// find the city strategy associated with this issue
; 3630 : 	AICityStrategyTypes eCityStrategy = NO_AICITYSTRATEGY;

	mov	DWORD PTR _eCityStrategy$[ebp], -1

; 3631 : 	switch(eYield)

	mov	eax, DWORD PTR _eYield$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN28@IsTestStra@17
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN27@IsTestStra@17
	jmp	SHORT $LN29@IsTestStra@17
$LN28@IsTestStra@17:

; 3632 : 	{
; 3633 : 	case YIELD_FOOD:
; 3634 : 		eCityStrategy = (AICityStrategyTypes)GC.getInfoTypeForString("AICITYSTRATEGY_NEED_IMPROVEMENT_FOOD");

	push	0
	push	OFFSET ??_C@_0CF@PCAHHCHO@AICITYSTRATEGY_NEED_IMPROVEMENT_@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eCityStrategy$[ebp], eax

; 3635 : 		break;

	jmp	SHORT $LN29@IsTestStra@17
$LN27@IsTestStra@17:

; 3636 : 	case YIELD_PRODUCTION:
; 3637 : 		eCityStrategy = (AICityStrategyTypes)GC.getInfoTypeForString("AICITYSTRATEGY_NEED_IMPROVEMENT_PRODUCTION");

	push	0
	push	OFFSET ??_C@_0CL@MLCMCMNB@AICITYSTRATEGY_NEED_IMPROVEMENT_@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eCityStrategy$[ebp], eax
$LN29@IsTestStra@17:

; 3638 : 		break;
; 3639 : 	}
; 3640 : 
; 3641 : 	FAssertMsg(eCityStrategy != NO_AICITYSTRATEGY, "No strategy found. What?");
; 3642 : 	if(eCityStrategy == NO_AICITYSTRATEGY)

	cmp	DWORD PTR _eCityStrategy$[ebp], -1
	jne	SHORT $LN26@IsTestStra@17

; 3643 : 	{
; 3644 : 		return false;

	xor	al, al
	jmp	$LN31@IsTestStra@17
$LN26@IsTestStra@17:

; 3645 : 	}
; 3646 : 
; 3647 : 	// if enough cities are worried about this problem
; 3648 : 	int iNumCities = pPlayer->getNumCities();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	mov	DWORD PTR _iNumCities$[ebp], eax

; 3649 : 	if(iNumCities == 0)

	cmp	DWORD PTR _iNumCities$[ebp], 0
	jne	SHORT $LN25@IsTestStra@17

; 3650 : 	{
; 3651 : 		return false; // no cities, no problem!

	xor	al, al
	jmp	$LN31@IsTestStra@17
$LN25@IsTestStra@17:

; 3652 : 	}
; 3653 : 
; 3654 : 	int iCityLoop = 0;

	mov	DWORD PTR _iCityLoop$[ebp], 0

; 3655 : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 3656 : 	int iNumCitiesConcerned = 0;

	mov	DWORD PTR _iNumCitiesConcerned$[ebp], 0

; 3657 : 	for(pLoopCity = pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN24@IsTestStra@17
$LN23@IsTestStra@17:
	push	0
	lea	edx, DWORD PTR _iCityLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN24@IsTestStra@17:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN22@IsTestStra@17

; 3658 : 	{
; 3659 : 		if(pLoopCity->GetCityStrategyAI()->IsUsingCityStrategy(eCityStrategy))

	mov	eax, DWORD PTR _eCityStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?GetCityStrategyAI@CvCity@@QBEPAVCvCityStrategyAI@@XZ ; CvCity::GetCityStrategyAI
	mov	ecx, eax
	call	?IsUsingCityStrategy@CvCityStrategyAI@@QAE_NW4AICityStrategyTypes@@@Z ; CvCityStrategyAI::IsUsingCityStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN21@IsTestStra@17

; 3660 : 		{
; 3661 : 			iNumCitiesConcerned++;

	mov	edx, DWORD PTR _iNumCitiesConcerned$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumCitiesConcerned$[ebp], edx
$LN21@IsTestStra@17:

; 3662 : 		}
; 3663 : 	}

	jmp	SHORT $LN23@IsTestStra@17
$LN22@IsTestStra@17:

; 3664 : 
; 3665 : 	double fWarningRatio = GC.getAI_STRATEGY_NEED_IMPROVEMENT_CITY_RATIO();

	movss	xmm0, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2016
	movss	DWORD PTR $T237272[ebp], xmm0
	cvtss2sd xmm0, DWORD PTR $T237272[ebp]
	movsd	QWORD PTR _fWarningRatio$[ebp], xmm0

; 3666 : 
; 3667 : 	// if not enough cities are upset
; 3668 : 	if((iNumCitiesConcerned / (double)iNumCities) < fWarningRatio)

	cvtsi2sd xmm0, DWORD PTR _iNumCitiesConcerned$[ebp]
	cvtsi2sd xmm1, DWORD PTR _iNumCities$[ebp]
	divsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR _fWarningRatio$[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN20@IsTestStra@17

; 3669 : 	{
; 3670 : 		return false;

	xor	al, al
	jmp	$LN31@IsTestStra@17
$LN20@IsTestStra@17:

; 3671 : 	}
; 3672 : 
; 3673 : 	// see if there's a builder
; 3674 : 	int iUnitLoop = 0;

	mov	DWORD PTR _iUnitLoop$[ebp], 0

; 3675 : 	CvUnit* pLoopUnit = NULL;

	mov	DWORD PTR _pLoopUnit$[ebp], 0

; 3676 : 	CvUnit* pBuilder = NULL;

	mov	DWORD PTR _pBuilder$[ebp], 0

; 3677 : 	for(pLoopUnit = pPlayer->firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = pPlayer->nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN19@IsTestStra@17
$LN18@IsTestStra@17:
	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN19@IsTestStra@17:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN17@IsTestStra@17

; 3678 : 	{
; 3679 : 		if(pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER)

	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	jne	SHORT $LN16@IsTestStra@17

; 3680 : 		{
; 3681 : 			pBuilder = pLoopUnit;

	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR _pBuilder$[ebp], edx

; 3682 : 			break;

	jmp	SHORT $LN17@IsTestStra@17
$LN16@IsTestStra@17:

; 3683 : 		}
; 3684 : 	}

	jmp	SHORT $LN18@IsTestStra@17
$LN17@IsTestStra@17:

; 3685 : 
; 3686 : 	// if no builder, ignore
; 3687 : 	// perhaps prompt a builder?
; 3688 : 	if(!pBuilder)

	cmp	DWORD PTR _pBuilder$[ebp], 0
	jne	SHORT $LN15@IsTestStra@17

; 3689 : 	{
; 3690 : 		return false;

	xor	al, al
	jmp	$LN31@IsTestStra@17
$LN15@IsTestStra@17:

; 3691 : 	}
; 3692 : 
; 3693 : 	// is there a build that I can create to improve the yield?
; 3694 : 
; 3695 : 	// loop through the build types to find one that we can use
; 3696 : 	BuildTypes eBuild;
; 3697 : #ifdef AUI_WARNING_FIXES
; 3698 : 	for (uint iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)
; 3699 : #else
; 3700 : 	int iBuildIndex;
; 3701 : 	for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	DWORD PTR _iBuildIndex$[ebp], 0
	jmp	SHORT $LN14@IsTestStra@17
$LN13@IsTestStra@17:
	mov	eax, DWORD PTR _iBuildIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _iBuildIndex$[ebp], eax
$LN14@IsTestStra@17:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	DWORD PTR _iBuildIndex$[ebp], eax
	jge	$LN12@IsTestStra@17

; 3702 : #endif
; 3703 : 	{
; 3704 : 		eBuild = (BuildTypes)iBuildIndex;

	mov	ecx, DWORD PTR _iBuildIndex$[ebp]
	mov	DWORD PTR _eBuild$[ebp], ecx

; 3705 : 		CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	DWORD PTR _pkBuildInfo$227220[ebp], eax

; 3706 : 		if(pkBuildInfo)

	cmp	DWORD PTR _pkBuildInfo$227220[ebp], 0
	je	$LN1@IsTestStra@17

; 3707 : 		{
; 3708 : 			if(pkBuildInfo->getTechPrereq() != NO_TECH)

	mov	ecx, DWORD PTR _pkBuildInfo$227220[ebp]
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	cmp	eax, -1
	je	SHORT $LN9@IsTestStra@17

; 3709 : 			{
; 3710 : 				if(!(GET_TEAM(pPlayer->getTeam()).GetTeamTechs()->HasTech((TechTypes)GC.getBuildInfo(eBuild)->getTechPrereq())))

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237281[ebp], eax
	mov	edx, DWORD PTR $T237281[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237285[ebp], edx
	mov	eax, DWORD PTR _eBuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq
	push	eax
	mov	ecx, DWORD PTR $T237285[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@IsTestStra@17

; 3711 : 				{
; 3712 : 					// don't have the tech needed for this build, so look at the next one
; 3713 : 					continue;

	jmp	$LN13@IsTestStra@17
$LN9@IsTestStra@17:

; 3714 : 				}
; 3715 : 			}
; 3716 : 
; 3717 : 			ImprovementTypes eImprovement = (ImprovementTypes)GC.getBuildInfo(eBuild)->getImprovement();

	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	mov	DWORD PTR _eImprovement$227225[ebp], eax

; 3718 : 			if(eImprovement == NO_IMPROVEMENT)

	cmp	DWORD PTR _eImprovement$227225[ebp], -1
	jne	SHORT $LN8@IsTestStra@17

; 3719 : 			{
; 3720 : 				continue;

	jmp	$LN13@IsTestStra@17
$LN8@IsTestStra@17:

; 3721 : 			}
; 3722 : 
; 3723 : 			CvPlotsVector& aPlots = pPlayer->GetPlots();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlots@CvPlayer@@QAEAAV?$FStaticVector@H$0DJAA@$00$0BCJ@$0A@@@XZ ; CvPlayer::GetPlots
	mov	DWORD PTR _aPlots$227228[ebp], eax

; 3724 : 			bool bCanBuild = false;

	mov	BYTE PTR _bCanBuild$227229[ebp], 0

; 3725 : 			for(uint ui = 0; ui < aPlots.size(); ui++)

	mov	DWORD PTR _ui$227230[ebp], 0
	jmp	SHORT $LN7@IsTestStra@17
$LN6@IsTestStra@17:
	mov	eax, DWORD PTR _ui$227230[ebp]
	add	eax, 1
	mov	DWORD PTR _ui$227230[ebp], eax
$LN7@IsTestStra@17:
	mov	ecx, DWORD PTR _aPlots$227228[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T237289[ebp], edx
	mov	eax, DWORD PTR _ui$227230[ebp]
	cmp	eax, DWORD PTR $T237289[ebp]
	jae	$LN5@IsTestStra@17

; 3726 : 			{
; 3727 : 				if(aPlots[ui] < 0)

	mov	ecx, DWORD PTR _aPlots$227228[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ui$227230[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jge	SHORT $LN4@IsTestStra@17

; 3728 : 				{
; 3729 : 					break;

	jmp	$LN5@IsTestStra@17
$LN4@IsTestStra@17:

; 3730 : 				}
; 3731 : 
; 3732 : 				CvPlot* pPlot = GC.getMap().plotByIndex(aPlots[ui]);

	mov	ecx, DWORD PTR _aPlots$227228[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ui$227230[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T237296[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237300[ebp], edx
	mov	eax, DWORD PTR $T237296[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237314[ebp], ecx
	cmp	DWORD PTR $T237314[ebp], 0
	jl	SHORT $LN51@IsTestStra@17
	mov	edx, DWORD PTR $T237300[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T237307[ebp], eax
	mov	ecx, DWORD PTR $T237314[ebp]
	cmp	ecx, DWORD PTR $T237307[ebp]
	jge	SHORT $LN51@IsTestStra@17
	mov	edx, DWORD PTR $T237314[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T237300[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv243[ebp], edx
	jmp	SHORT $LN52@IsTestStra@17
$LN51@IsTestStra@17:
	mov	DWORD PTR tv243[ebp], 0
$LN52@IsTestStra@17:
	mov	ecx, DWORD PTR tv243[ebp]
	mov	DWORD PTR _pPlot$227235[ebp], ecx

; 3733 : 				if(pPlayer->canBuild(pPlot, eBuild, false /*test era*/, false /*test visible*/, false /*test gold*/))

	push	1
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _eBuild$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlot$227235[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@IsTestStra@17

; 3734 : 				{
; 3735 : 					bCanBuild = true;

	mov	BYTE PTR _bCanBuild$227229[ebp], 1

; 3736 : 					break;

	jmp	SHORT $LN5@IsTestStra@17
$LN3@IsTestStra@17:

; 3737 : 				}
; 3738 : 			}

	jmp	$LN6@IsTestStra@17
$LN5@IsTestStra@17:

; 3739 : 
; 3740 : 			if(!bCanBuild)

	movzx	edx, BYTE PTR _bCanBuild$227229[ebp]
	test	edx, edx
	jne	SHORT $LN2@IsTestStra@17

; 3741 : 			{
; 3742 : 				continue;

	jmp	$LN13@IsTestStra@17
$LN2@IsTestStra@17:

; 3743 : 			}
; 3744 : 
; 3745 : 			// we can use an improvement that increases the yield
; 3746 : 			if(GC.getImprovementInfo(eImprovement)->GetYieldChange(eYield) > 0)

	mov	eax, DWORD PTR _eYield$[ebp]
	push	eax
	mov	ecx, DWORD PTR _eImprovement$227225[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetYieldChange@CvImprovementEntry@@QBEHH@Z ; CvImprovementEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN1@IsTestStra@17

; 3747 : 			{
; 3748 : 				return false;

	xor	al, al
	jmp	SHORT $LN31@IsTestStra@17
$LN1@IsTestStra@17:

; 3749 : 			}
; 3750 : 		}
; 3751 : 	}

	jmp	$LN13@IsTestStra@17
$LN12@IsTestStra@17:

; 3752 : 
; 3753 : 	return true;

	mov	al, 1
$LN31@IsTestStra@17:

; 3754 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedImprovement@EconomicAIHelpers@@YA_NPAVCvPlayer@@W4YieldTypes@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedImprovement
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_iCityLoop$ = -12					; size = 4
_pLoopCity$ = -8					; size = 4
_iNumCoastalCities$ = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities, COMDAT

; 3758 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3759 : 	int iCityLoop = 0;

	mov	DWORD PTR _iCityLoop$[ebp], 0

; 3760 : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 3761 : 	int iNumCoastalCities = 0;

	mov	DWORD PTR _iNumCoastalCities$[ebp], 0

; 3762 : 	for(pLoopCity = pPlayer->firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iCityLoop))

	push	0
	lea	eax, DWORD PTR _iCityLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN4@IsTestStra@18
$LN3@IsTestStra@18:
	push	0
	lea	ecx, DWORD PTR _iCityLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN4@IsTestStra@18:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN2@IsTestStra@18

; 3763 : 	{
; 3764 : 		if(pLoopCity->isCoastal())

	push	-1
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@IsTestStra@18

; 3765 : 		{
; 3766 : 			iNumCoastalCities++;

	mov	eax, DWORD PTR _iNumCoastalCities$[ebp]
	add	eax, 1
	mov	DWORD PTR _iNumCoastalCities$[ebp], eax
$LN1@IsTestStra@18:

; 3767 : 		}
; 3768 : 	}

	jmp	SHORT $LN3@IsTestStra@18
$LN2@IsTestStra@18:

; 3769 : 	return iNumCoastalCities <= 1;

	xor	eax, eax
	cmp	DWORD PTR _iNumCoastalCities$[ebp], 1
	setle	al

; 3770 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_OneOrFewerCoastalCities@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_OneOrFewerCoastalCities
_TEXT	ENDS
EXTRN	?AverageIncome@CvTreasury@@QAENH@Z:PROC		; CvTreasury::AverageIncome
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
tv87 = -28						; size = 4
tv134 = -24						; size = 4
tv139 = -20						; size = 8
$T237324 = -12						; size = 4
_iInterval$ = -8					; size = 4
_pStrategy$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_LosingMoney, COMDAT

; 3774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3775 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$[ebp], eax

; 3776 : 	int iInterval = pStrategy->GetMinimumNumTurnsExecuted();

	mov	ecx, DWORD PTR _pStrategy$[ebp]
	call	?GetMinimumNumTurnsExecuted@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetMinimumNumTurnsExecuted
	mov	DWORD PTR _iInterval$[ebp], eax

; 3777 : 
; 3778 : 	// Need a certain number of turns of history before we can turn this on
; 3779 : 	if(GC.getGame().getGameTurn() <= iInterval)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237324[ebp], ecx
	mov	ecx, DWORD PTR $T237324[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, DWORD PTR _iInterval$[ebp]
	jg	SHORT $LN1@IsTestStra@19

; 3780 : 	{
; 3781 : 		return false;

	xor	al, al
	jmp	SHORT $LN2@IsTestStra@19
$LN1@IsTestStra@19:

; 3782 : 	}
; 3783 : 
; 3784 : 	// Is average income below desired threshold over past X turns?
; 3785 : 	return (pPlayer->GetTreasury()->AverageIncome(iInterval) < (double)pStrategy->GetWeightThreshold() /* 2 */);

	mov	edx, DWORD PTR _iInterval$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetTreasury@CvPlayer@@QBEPAVCvTreasury@@XZ ; CvPlayer::GetTreasury
	mov	ecx, eax
	call	?AverageIncome@CvTreasury@@QAENH@Z	; CvTreasury::AverageIncome
	mov	ecx, DWORD PTR _pStrategy$[ebp]
	fstp	QWORD PTR tv139[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	mov	DWORD PTR tv134[ebp], eax
	fld	QWORD PTR tv139[ebp]
	fild	DWORD PTR tv134[ebp]
	fcomip	ST(1)
	fstp	ST(0)
	jbe	SHORT $LN4@IsTestStra@19
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN5@IsTestStra@19
$LN4@IsTestStra@19:
	mov	DWORD PTR tv87[ebp], 0
$LN5@IsTestStra@19:
	mov	al, BYTE PTR tv87[ebp]
$LN2@IsTestStra@19:

; 3786 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_LosingMoney@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_LosingMoney
_TEXT	ENDS
EXTRN	?GetYieldChange@CvBuildingEntry@@QBEHH@Z:PROC	; CvBuildingEntry::GetYieldChange
EXTRN	?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ:PROC ; CvBuildingClassInfo::getDefaultBuildingIndex
EXTRN	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z:PROC ; CvGlobals::getBuildingClassInfo
EXTRN	?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetFreeBuildingClass
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237330 = -32						; size = 4
_pkFreeBuildingInfo$227273 = -28			; size = 4
_eBuilding$227270 = -24					; size = 4
_pkBuildingClassInfo$227268 = -20			; size = 4
_eBuildingClass$227265 = -16				; size = 4
_pkBuildingInfo$227263 = -12				; size = 4
_pkGameBuildings$227262 = -8				; size = 4
_eNextDesiredWonder$ = -4				; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings, COMDAT

; 3790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3791 : 	BuildingTypes eNextDesiredWonder = pPlayer->GetCitySpecializationAI()->GetNextWonderDesired();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	DWORD PTR $T237330[ebp], eax
	mov	eax, DWORD PTR $T237330[ebp]
	mov	ecx, DWORD PTR [eax+196]
	mov	DWORD PTR _eNextDesiredWonder$[ebp], ecx

; 3792 : 
; 3793 : 	// Is average income below desired threshold over past X turns?
; 3794 : 	if(eNextDesiredWonder != NO_BUILDING)

	cmp	DWORD PTR _eNextDesiredWonder$[ebp], -1
	je	$LN7@IsTestStra@20

; 3795 : 	{
; 3796 : 		CvBuildingXMLEntries* pkGameBuildings = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings
	mov	DWORD PTR _pkGameBuildings$227262[ebp], eax

; 3797 : 		CvBuildingEntry* pkBuildingInfo = pkGameBuildings->GetEntry(eNextDesiredWonder);

	mov	edx, DWORD PTR _eNextDesiredWonder$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pkGameBuildings$227262[ebp]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkBuildingInfo$227263[ebp], eax

; 3798 : 		if(pkBuildingInfo)

	cmp	DWORD PTR _pkBuildingInfo$227263[ebp], 0
	je	SHORT $LN7@IsTestStra@20

; 3799 : 		{
; 3800 : 			BuildingClassTypes eBuildingClass = (BuildingClassTypes)pkBuildingInfo->GetFreeBuildingClass();

	mov	ecx, DWORD PTR _pkBuildingInfo$227263[ebp]
	call	?GetFreeBuildingClass@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetFreeBuildingClass
	mov	DWORD PTR _eBuildingClass$227265[ebp], eax

; 3801 : 			if(eBuildingClass != NO_BUILDINGCLASS)

	cmp	DWORD PTR _eBuildingClass$227265[ebp], -1
	je	SHORT $LN7@IsTestStra@20

; 3802 : 			{
; 3803 : 				CvBuildingClassInfo* pkBuildingClassInfo = GC.getBuildingClassInfo(eBuildingClass);

	mov	eax, DWORD PTR _eBuildingClass$227265[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingClassInfo@CvGlobals@@QAEPAVCvBuildingClassInfo@@W4BuildingClassTypes@@@Z ; CvGlobals::getBuildingClassInfo
	mov	DWORD PTR _pkBuildingClassInfo$227268[ebp], eax

; 3804 : 				{
; 3805 : 					if(pkBuildingClassInfo)

	cmp	DWORD PTR _pkBuildingClassInfo$227268[ebp], 0
	je	SHORT $LN7@IsTestStra@20

; 3806 : 					{
; 3807 : 						BuildingTypes eBuilding = (BuildingTypes)pkBuildingClassInfo->getDefaultBuildingIndex();

	mov	ecx, DWORD PTR _pkBuildingClassInfo$227268[ebp]
	call	?getDefaultBuildingIndex@CvBuildingClassInfo@@QBEHXZ ; CvBuildingClassInfo::getDefaultBuildingIndex
	mov	DWORD PTR _eBuilding$227270[ebp], eax

; 3808 : 						if(eBuilding != NO_BUILDING)

	cmp	DWORD PTR _eBuilding$227270[ebp], -1
	je	SHORT $LN7@IsTestStra@20

; 3809 : 						{
; 3810 : 							CvBuildingEntry* pkFreeBuildingInfo = pkGameBuildings->GetEntry(eBuilding);

	mov	ecx, DWORD PTR _eBuilding$227270[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pkGameBuildings$227262[ebp]
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	DWORD PTR _pkFreeBuildingInfo$227273[ebp], eax

; 3811 : 							if(pkFreeBuildingInfo)

	cmp	DWORD PTR _pkFreeBuildingInfo$227273[ebp], 0
	je	SHORT $LN7@IsTestStra@20

; 3812 : 							{
; 3813 : 								if(pkFreeBuildingInfo->GetYieldChange(YIELD_FOOD) > 0)

	push	0
	mov	ecx, DWORD PTR _pkFreeBuildingInfo$227273[ebp]
	call	?GetYieldChange@CvBuildingEntry@@QBEHH@Z ; CvBuildingEntry::GetYieldChange
	test	eax, eax
	jle	SHORT $LN7@IsTestStra@20

; 3814 : 								{
; 3815 : 									return true;

	mov	al, 1
	jmp	SHORT $LN8@IsTestStra@20
$LN7@IsTestStra@20:

; 3816 : 								}
; 3817 : 							}
; 3818 : 						}
; 3819 : 					}
; 3820 : 				}
; 3821 : 			}
; 3822 : 		}
; 3823 : 	}
; 3824 : 	return false;

	xor	al, al
$LN8@IsTestStra@20:

; 3825 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_HaltGrowthBuildings@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_HaltGrowthBuildings
_TEXT	ENDS
EXTRN	?GetUnitProductionMaintenanceMod@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetUnitProductionMaintenanceMod
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8						; size = 4
?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_TooManyUnits, COMDAT

; 3829 : {

	push	ebp
	mov	ebp, esp

; 3830 : 	return (pPlayer->GetUnitProductionMaintenanceMod()) != 0;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetUnitProductionMaintenanceMod@CvPlayer@@QBEHXZ ; CvPlayer::GetUnitProductionMaintenanceMod
	neg	eax
	sbb	eax, eax
	neg	eax

; 3831 : }

	pop	ebp
	ret	0
?IsTestStrategy_TooManyUnits@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_TooManyUnits
_TEXT	ENDS
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?getCanEmbarkCount@CvTeam@@QBEHXZ:PROC		; CvTeam::getCanEmbarkCount
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237401 = -72						; size = 4
$T237397 = -68						; size = 4
_uiOffset$237392 = -64					; size = 4
$T237383 = -60						; size = 4
$T237374 = -56						; size = 4
$T237367 = -52						; size = 4
$T237363 = -48						; size = 4
$T237359 = -44						; size = 4
$T237355 = -40						; size = 4
$T237351 = -36						; size = 4
$T237347 = -32						; size = 4
$T237338 = -28						; size = 4
_iI$227290 = -24					; size = 4
_iCoastalTiles$ = -20					; size = 4
_iRevealedCoastalTiles$ = -16				; size = 4
_pStrategy$ = -12					; size = 4
_pLoopPlot$ = -8					; size = 4
_iStartArea$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_IslandStart, COMDAT

; 3835 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	esi

; 3836 : 	int iStartArea;
; 3837 : 	CvPlot* pLoopPlot;
; 3838 : 	int iCoastalTiles = 0;

	mov	DWORD PTR _iCoastalTiles$[ebp], 0

; 3839 : 	int iRevealedCoastalTiles = 0;

	mov	DWORD PTR _iRevealedCoastalTiles$[ebp], 0

; 3840 : 
; 3841 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$[ebp], eax

; 3842 : 
; 3843 : 	// Only kick off this strategy in the first 25 turns of the game (though it will last 50 turns once selected)
; 3844 : 	if(GC.getGame().getGameTurn() < 25 && pPlayer->getStartingPlot())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237338[ebp], ecx
	mov	ecx, DWORD PTR $T237338[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 25					; 00000019H
	jge	$LN9@IsTestStra@21
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	test	eax, eax
	je	$LN9@IsTestStra@21

; 3845 : 	{
; 3846 : 		if(GET_TEAM(pPlayer->getTeam()).getCanEmbarkCount() < 1)

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237347[ebp], eax
	mov	ecx, DWORD PTR $T237347[ebp]
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237351[ebp], ecx
	mov	ecx, DWORD PTR $T237351[ebp]
	call	?getCanEmbarkCount@CvTeam@@QBEHXZ	; CvTeam::getCanEmbarkCount
	cmp	eax, 1
	jge	$LN9@IsTestStra@21

; 3847 : 		{
; 3848 : 			iStartArea = pPlayer->getStartingPlot()->getArea();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	DWORD PTR $T237355[ebp], eax
	mov	edx, DWORD PTR $T237355[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR _iStartArea$[ebp], eax

; 3849 : 
; 3850 : 			// Have we revealed a high enough percentage of the coast of our landmass?
; 3851 : #ifdef AUI_WARNING_FIXES
; 3852 : 			for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 3853 : #else
; 3854 : 			for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	DWORD PTR _iI$227290[ebp], 0
	jmp	SHORT $LN7@IsTestStra@21
$LN6@IsTestStra@21:
	mov	ecx, DWORD PTR _iI$227290[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$227290[ebp], ecx
$LN7@IsTestStra@21:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237359[ebp], edx
	mov	eax, DWORD PTR $T237359[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T237363[ebp], ecx
	mov	edx, DWORD PTR _iI$227290[ebp]
	cmp	edx, DWORD PTR $T237363[ebp]
	jge	$LN5@IsTestStra@21

; 3855 : #endif
; 3856 : 			{
; 3857 : 				pLoopPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237367[ebp], eax
	mov	ecx, DWORD PTR _iI$227290[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T237367[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], ecx

; 3858 : 				if(pLoopPlot->getArea() == iStartArea)

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T237374[ebp], ecx
	mov	edx, DWORD PTR $T237374[ebp]
	cmp	edx, DWORD PTR _iStartArea$[ebp]
	jne	SHORT $LN4@IsTestStra@21

; 3859 : 				{
; 3860 : 					if(pLoopPlot->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN34@IsTestStra@21

; 3861 : 					{
; 3862 : 						iCoastalTiles++;

	mov	ecx, DWORD PTR _iCoastalTiles$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCoastalTiles$[ebp], ecx

; 3863 : 					}
; 3864 : 					if(pLoopPlot->isRevealed(pPlayer->getTeam()))

$LN34@IsTestStra@21:
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237383[ebp], eax
	mov	ecx, DWORD PTR $T237383[ebp]
	shr	ecx, 5
	mov	DWORD PTR _uiOffset$237392[ebp], ecx
	mov	edx, DWORD PTR _uiOffset$237392[ebp]
	shl	edx, 5
	mov	ecx, DWORD PTR $T237383[ebp]
	sub	ecx, edx
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _uiOffset$237392[ebp]
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	and	eax, DWORD PTR [edx+ecx*4+8]
	setne	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@IsTestStra@21

; 3865 : 					{
; 3866 : 						iRevealedCoastalTiles++;

	mov	edx, DWORD PTR _iRevealedCoastalTiles$[ebp]
	add	edx, 1
	mov	DWORD PTR _iRevealedCoastalTiles$[ebp], edx
$LN4@IsTestStra@21:

; 3867 : 					}
; 3868 : 				}
; 3869 : 			}

	jmp	$LN6@IsTestStra@21
$LN5@IsTestStra@21:

; 3870 : 
; 3871 : 			if((iRevealedCoastalTiles * 100 / (iCoastalTiles + 1)) > GC.getAI_STRATEGY_ISLAND_START_COAST_REVEAL_PERCENT() &&
; 3872 : 			        GC.getMap().getArea(iStartArea)->getNumTiles() < pStrategy->GetWeightThreshold())

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2020
	mov	DWORD PTR $T237397[ebp], eax
	mov	eax, DWORD PTR _iRevealedCoastalTiles$[ebp]
	imul	eax, 100				; 00000064H
	mov	ecx, DWORD PTR _iCoastalTiles$[ebp]
	add	ecx, 1
	cdq
	idiv	ecx
	cmp	eax, DWORD PTR $T237397[ebp]
	jle	SHORT $LN9@IsTestStra@21
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237401[ebp], edx
	mov	eax, DWORD PTR _iStartArea$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237401[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	esi, eax
	mov	ecx, DWORD PTR _pStrategy$[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	cmp	esi, eax
	jge	SHORT $LN9@IsTestStra@21

; 3873 : 			{
; 3874 : 				return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestStra@21
$LN9@IsTestStra@21:

; 3875 : 			}
; 3876 : 		}
; 3877 : 	}
; 3878 : 
; 3879 : 	return false;

	xor	al, al
$LN10@IsTestStra@21:

; 3880 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_IslandStart@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_IslandStart
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237432 = -56						; size = 4
$T237428 = -52						; size = 4
$T237424 = -48						; size = 4
$T237423 = -44						; size = 4
$T237419 = -40						; size = 4
$T237415 = -36						; size = 4
$T237411 = -32						; size = 4
$T237407 = -28						; size = 4
_pArea$227318 = -24					; size = 4
_iBestArea$227319 = -20					; size = 4
_iSecondBestArea$227320 = -16				; size = 4
_eStrategyIslandStart$ = -12				; size = 4
_eEarlyExpansion$ = -8					; size = 4
_eStrategyAtWar$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents, COMDAT

; 3884 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 3885 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3886 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN12@IsTestStra@22
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237407[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T237407[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@IsTestStra@22
$LN12@IsTestStra@22:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@IsTestStra@22
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237411[ebp], ecx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T237411[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN13@IsTestStra@22
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237415[ebp], eax
	push	OFFSET ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
	mov	ecx, DWORD PTR $T237415[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@IsTestStra@22
$LN13@IsTestStra@22:

; 3887 : #else
; 3888 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3889 : #endif
; 3890 : 	{
; 3891 : 		return false;

	xor	al, al
	jmp	$LN15@IsTestStra@22
$LN14@IsTestStra@22:

; 3892 : 	}
; 3893 : 
; 3894 : 	// Never run this at the same time as island start
; 3895 : 	EconomicAIStrategyTypes eStrategyIslandStart = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_ISLAND_START");

	push	0
	push	OFFSET ??_C@_0CA@GADCJDII@ECONOMICAISTRATEGY_ISLAND_START?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyIslandStart$[ebp], eax

; 3896 : 	if(eStrategyIslandStart != NO_ECONOMICAISTRATEGY)

	cmp	DWORD PTR _eStrategyIslandStart$[ebp], -1
	je	SHORT $LN10@IsTestStra@22

; 3897 : 	{
; 3898 : 		if(pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyIslandStart))

	mov	edx, DWORD PTR _eStrategyIslandStart$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN10@IsTestStra@22

; 3899 : 		{
; 3900 : 			return false;

	xor	al, al
	jmp	$LN15@IsTestStra@22
$LN10@IsTestStra@22:

; 3901 : 		}
; 3902 : 	}
; 3903 : 
; 3904 : 	// we should settle our island first
; 3905 : 	EconomicAIStrategyTypes eEarlyExpansion = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EARLY_EXPANSION");

	push	0
	push	OFFSET ??_C@_0CD@CKIOFBEO@ECONOMICAISTRATEGY_EARLY_EXPANSI@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eEarlyExpansion$[ebp], eax

; 3906 : 	if(eEarlyExpansion != NO_ECONOMICAISTRATEGY)

	cmp	DWORD PTR _eEarlyExpansion$[ebp], -1
	je	SHORT $LN8@IsTestStra@22

; 3907 : 	{
; 3908 : 		if(pPlayer->GetEconomicAI()->IsUsingStrategy(eEarlyExpansion))

	mov	ecx, DWORD PTR _eEarlyExpansion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@IsTestStra@22

; 3909 : 		{
; 3910 : 			return false;

	xor	al, al
	jmp	$LN15@IsTestStra@22
$LN8@IsTestStra@22:

; 3911 : 		}
; 3912 : 	}
; 3913 : 
; 3914 : 	// Never desperate to settle distant lands if we are at war (unless we are doing okay at the war)
; 3915 : 	MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_LOSING_WARS");

	push	0
	push	OFFSET ??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$[ebp], eax

; 3916 : 	if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyAtWar$[ebp], -1
	je	SHORT $LN6@IsTestStra@22

; 3917 : 	{
; 3918 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	eax, DWORD PTR _eStrategyAtWar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN6@IsTestStra@22

; 3919 : 		{
; 3920 : 			return false;

	xor	al, al
	jmp	$LN15@IsTestStra@22
$LN6@IsTestStra@22:

; 3921 : 		}
; 3922 : 	}
; 3923 : 
; 3924 : 	if(pPlayer->getCapitalCity() != NULL)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN4@IsTestStra@22

; 3925 : 	{
; 3926 : 		CvArea* pArea = GC.getMap().getArea(pPlayer->getCapitalCity()->getArea());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237419[ebp], edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	push	eax
	mov	ecx, DWORD PTR $T237419[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	DWORD PTR _pArea$227318[ebp], eax

; 3927 : 
; 3928 : 		// Do we have another area to settle (either first or second choice)?
; 3929 : 		int iBestArea, iSecondBestArea;
; 3930 : 		pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237423[ebp], eax
	mov	eax, DWORD PTR $T237423[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR $T237424[ebp], ecx
	lea	edx, DWORD PTR _iSecondBestArea$227320[ebp]
	push	edx
	lea	eax, DWORD PTR _iBestArea$227319[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237424[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3931 : 
; 3932 : 		if((iBestArea != pArea->GetID() && iBestArea != -1) || (iSecondBestArea != pArea->GetID() && iSecondBestArea != -1))

	mov	edx, DWORD PTR _pArea$227318[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237428[ebp], eax
	mov	ecx, DWORD PTR _iBestArea$227319[ebp]
	cmp	ecx, DWORD PTR $T237428[ebp]
	je	SHORT $LN1@IsTestStra@22
	cmp	DWORD PTR _iBestArea$227319[ebp], -1
	jne	SHORT $LN2@IsTestStra@22
$LN1@IsTestStra@22:
	mov	edx, DWORD PTR _pArea$227318[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T237432[ebp], eax
	mov	ecx, DWORD PTR _iSecondBestArea$227320[ebp]
	cmp	ecx, DWORD PTR $T237432[ebp]
	je	SHORT $LN4@IsTestStra@22
	cmp	DWORD PTR _iSecondBestArea$227320[ebp], -1
	je	SHORT $LN4@IsTestStra@22
$LN2@IsTestStra@22:

; 3933 : 		{
; 3934 : 			return true;

	mov	al, 1
	jmp	SHORT $LN15@IsTestStra@22
$LN4@IsTestStra@22:

; 3935 : 		}
; 3936 : 	}
; 3937 : 
; 3938 : 	return false;

	xor	al, al
$LN15@IsTestStra@22:

; 3939 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_ExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ExpandToOtherContinents
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237455 = -52						; size = 4
$T237454 = -48						; size = 4
$T237450 = -44						; size = 4
$T237446 = -40						; size = 4
$T237442 = -36						; size = 4
$T237438 = -32						; size = 4
_iBestArea$227349 = -28					; size = 4
_iSecondBestArea$227350 = -24				; size = 4
_eStrategyAtWar$227340 = -20				; size = 4
_eStrategyExpandToOtherContinents$ = -16		; size = 4
_iFlavorExpansion$ = -12				; size = 4
_eStrategyLosingAtWar$ = -8				; size = 4
_iFlavorGrowth$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents, COMDAT

; 3944 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 3945 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 3946 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@IsTestStra@23
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237438[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T237438[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@IsTestStra@23
$LN11@IsTestStra@23:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@IsTestStra@23
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237442[ebp], ecx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T237442[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN12@IsTestStra@23
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237446[ebp], eax
	push	OFFSET ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
	mov	ecx, DWORD PTR $T237446[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@IsTestStra@23
$LN12@IsTestStra@23:

; 3947 : #else
; 3948 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 3949 : #endif
; 3950 : 	{
; 3951 : 		return false;

	xor	al, al
	jmp	$LN14@IsTestStra@23
$LN13@IsTestStra@23:

; 3952 : 	}
; 3953 : 
; 3954 : 	// Only run this if we are running "ExpandToOtherContinents"
; 3955 : 	EconomicAIStrategyTypes eStrategyExpandToOtherContinents = (EconomicAIStrategyTypes) GC.getInfoTypeForString("ECONOMICAISTRATEGY_EXPAND_TO_OTHER_CONTINENTS");

	push	0
	push	OFFSET ??_C@_0CO@KFILJFKH@ECONOMICAISTRATEGY_EXPAND_TO_OTH@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyExpandToOtherContinents$[ebp], eax

; 3956 : 	if(eStrategyExpandToOtherContinents != NO_ECONOMICAISTRATEGY)

	cmp	DWORD PTR _eStrategyExpandToOtherContinents$[ebp], -1
	je	SHORT $LN9@IsTestStra@23

; 3957 : 	{
; 3958 : 		if(!pPlayer->GetEconomicAI()->IsUsingStrategy(eStrategyExpandToOtherContinents))

	mov	edx, DWORD PTR _eStrategyExpandToOtherContinents$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvEconomicAI@@QAE_NW4EconomicAIStrategyTypes@@@Z ; CvEconomicAI::IsUsingStrategy
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN9@IsTestStra@23

; 3959 : 		{
; 3960 : 			return false;

	xor	al, al
	jmp	$LN14@IsTestStra@23
$LN9@IsTestStra@23:

; 3961 : 		}
; 3962 : 	}
; 3963 : 
; 3964 : 	MilitaryAIStrategyTypes eStrategyLosingAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_LOSING_WARS");

	push	0
	push	OFFSET ??_C@_0BP@OIAHMGFF@MILITARYAISTRATEGY_LOSING_WARS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyLosingAtWar$[ebp], eax

; 3965 : 	if(eStrategyLosingAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyLosingAtWar$[ebp], -1
	je	SHORT $LN7@IsTestStra@23

; 3966 : 	{
; 3967 : 		if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyLosingAtWar))

	mov	ecx, DWORD PTR _eStrategyLosingAtWar$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@IsTestStra@23

; 3968 : 		{
; 3969 : 			return false;

	xor	al, al
	jmp	$LN14@IsTestStra@23
$LN7@IsTestStra@23:

; 3970 : 		}
; 3971 : 	}
; 3972 : 
; 3973 : 	// if we are at war probably shouldn't (unless the map is an offshore expansion map)
; 3974 : 	if ((GC.getMap().GetAIMapHint() & 4) == 0)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237450[ebp], eax
	mov	ecx, DWORD PTR $T237450[ebp]
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	and	eax, 4
	jne	SHORT $LN5@IsTestStra@23

; 3975 : 	{
; 3976 : 		MilitaryAIStrategyTypes eStrategyAtWar = (MilitaryAIStrategyTypes) GC.getInfoTypeForString("MILITARYAISTRATEGY_AT_WAR");

	push	0
	push	OFFSET ??_C@_0BK@KDAIIFJ@MILITARYAISTRATEGY_AT_WAR?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eStrategyAtWar$227340[ebp], eax

; 3977 : 		if(eStrategyAtWar != NO_MILITARYAISTRATEGY)

	cmp	DWORD PTR _eStrategyAtWar$227340[ebp], -1
	je	SHORT $LN5@IsTestStra@23

; 3978 : 		{
; 3979 : 			if(pPlayer->GetMilitaryAI()->IsUsingStrategy(eStrategyAtWar))

	mov	ecx, DWORD PTR _eStrategyAtWar$227340[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?IsUsingStrategy@CvMilitaryAI@@QAE_NW4MilitaryAIStrategyTypes@@@Z ; CvMilitaryAI::IsUsingStrategy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@IsTestStra@23

; 3980 : 			{
; 3981 : 				return false;

	xor	al, al
	jmp	$LN14@IsTestStra@23
$LN5@IsTestStra@23:

; 3982 : 			}
; 3983 : 		}
; 3984 : 	}
; 3985 : 
; 3986 : 	int iFlavorGrowth = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GROWTH"));

	push	0
	push	OFFSET ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorGrowth$[ebp], eax

; 3987 : 	int iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));

	push	0
	push	OFFSET ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorExpansion$[ebp], eax

; 3988 : 
; 3989 : 	if (iFlavorGrowth < iFlavorExpansion && pPlayer->getCapitalCity() != NULL && !pPlayer->IsEmpireUnhappy())

	mov	eax, DWORD PTR _iFlavorGrowth$[ebp]
	cmp	eax, DWORD PTR _iFlavorExpansion$[ebp]
	jge	SHORT $LN2@IsTestStra@23
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	test	eax, eax
	je	SHORT $LN2@IsTestStra@23
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?IsEmpireUnhappy@CvPlayer@@QBE_NXZ	; CvPlayer::IsEmpireUnhappy
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@IsTestStra@23

; 3990 : 	{
; 3991 : 		// If the other area is clearly better
; 3992 : 		int iBestArea, iSecondBestArea;
; 3993 : 		pPlayer->GetBestSettleAreas(pPlayer->GetEconomicAI()->GetMinimumSettleFertility(), iBestArea, iSecondBestArea);

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237454[ebp], eax
	mov	edx, DWORD PTR $T237454[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR $T237455[ebp], eax
	lea	ecx, DWORD PTR _iSecondBestArea$227350[ebp]
	push	ecx
	lea	edx, DWORD PTR _iBestArea$227349[ebp]
	push	edx
	mov	eax, DWORD PTR $T237455[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetBestSettleAreas@CvPlayer@@QAEHHAAH0@Z ; CvPlayer::GetBestSettleAreas

; 3994 : 		if ((iBestArea != pPlayer->getCapitalCity()->getArea() && iBestArea != -1))

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity
	mov	ecx, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	DWORD PTR _iBestArea$227349[ebp], eax
	je	SHORT $LN2@IsTestStra@23
	cmp	DWORD PTR _iBestArea$227349[ebp], -1
	je	SHORT $LN2@IsTestStra@23

; 3995 : 		{
; 3996 : 			return true;

	mov	al, 1
	jmp	SHORT $LN14@IsTestStra@23
$LN2@IsTestStra@23:

; 3997 : 		}
; 3998 : 	}
; 3999 : 
; 4000 : 	return false;

	xor	al, al
$LN14@IsTestStra@23:

; 4001 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_ReallyExpandToOtherContinents@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ReallyExpandToOtherContinents
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv86 = -20						; size = 4
_iCoastalPop$ = -16					; size = 4
_iLoopCity$ = -12					; size = 4
_iInlandPop$ = -8					; size = 4
_pLoopCity$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast, COMDAT

; 4006 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 4007 : 	// total pop
; 4008 : 	int iInlandPop = 0;

	mov	DWORD PTR _iInlandPop$[ebp], 0

; 4009 : 	int iCoastalPop = 0;

	mov	DWORD PTR _iCoastalPop$[ebp], 0

; 4010 : 	int iLoopCity = 0;

	mov	DWORD PTR _iLoopCity$[ebp], 0

; 4011 : 	CvCity* pLoopCity = NULL;

	mov	DWORD PTR _pLoopCity$[ebp], 0

; 4012 : 	for(pLoopCity = pPlayer->firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = pPlayer->nextCity(&iLoopCity))

	push	0
	lea	eax, DWORD PTR _iLoopCity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN5@IsTestStra@24
$LN4@IsTestStra@24:
	push	0
	lea	ecx, DWORD PTR _iLoopCity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN5@IsTestStra@24:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	SHORT $LN3@IsTestStra@24

; 4013 : 	{
; 4014 : 		if(pLoopCity->isCoastal(100))  // don't run this for lakes or even small inland seas

	push	100					; 00000064H
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@IsTestStra@24

; 4015 : 		{
; 4016 : 			iCoastalPop += pLoopCity->getPopulation();

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	add	eax, DWORD PTR _iCoastalPop$[ebp]
	mov	DWORD PTR _iCoastalPop$[ebp], eax

; 4017 : 		}
; 4018 : 		else

	jmp	SHORT $LN1@IsTestStra@24
$LN2@IsTestStra@24:

; 4019 : 		{
; 4020 : 			iInlandPop += pLoopCity->getPopulation();

	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	add	eax, DWORD PTR _iInlandPop$[ebp]
	mov	DWORD PTR _iInlandPop$[ebp], eax
$LN1@IsTestStra@24:

; 4021 : 		}
; 4022 : 	}

	jmp	SHORT $LN4@IsTestStra@24
$LN3@IsTestStra@24:

; 4023 : 	return (iCoastalPop > 0 && iCoastalPop >= iInlandPop);

	cmp	DWORD PTR _iCoastalPop$[ebp], 0
	jle	SHORT $LN8@IsTestStra@24
	mov	eax, DWORD PTR _iCoastalPop$[ebp]
	cmp	eax, DWORD PTR _iInlandPop$[ebp]
	jl	SHORT $LN8@IsTestStra@24
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN9@IsTestStra@24
$LN8@IsTestStra@24:
	mov	DWORD PTR tv86[ebp], 0
$LN9@IsTestStra@24:
	mov	al, BYTE PTR tv86[ebp]

; 4024 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_MostlyOnTheCoast@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_MostlyOnTheCoast
_TEXT	ENDS
PUBLIC	??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@	; `string'
EXTRN	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ:PROC ; CvWorldInfo::GetNumCitiesPolicyCostMod
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ:PROC ; CvGrandStrategyAI::GetActiveGrandStrategy
;	COMDAT ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@ DB 'AIGRANDSTRATEGY_CULTU'
	DB	'RE', 00H					; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237477 = -28						; size = 4
$T237473 = -24						; size = 4
$T237469 = -20						; size = 4
$T237465 = -16						; size = 4
_eGrandStrategy$ = -12					; size = 4
_iFlavorExpansion$ = -8					; size = 4
_pStrategy$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy, COMDAT

; 4027 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 4028 : #ifdef NQM_AI_GIMP_NO_BUILDING_SETTLERS
; 4029 : 	if ((pPlayer->isHuman() && GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE)) || (!pPlayer->isHuman() && (GC.getGame().isOption("GAMEOPTION_AI_TWEAKS") || GC.getGame().isOption("GAMEOPTION_AI_GIMP_NO_BUILDING_SETTLERS"))))

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@IsTestStra@25
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237465[ebp], ecx
	push	5
	mov	ecx, DWORD PTR $T237465[ebp]
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@IsTestStra@25
$LN6@IsTestStra@25:
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@IsTestStra@25
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237469[ebp], ecx
	push	OFFSET ??_C@_0BF@FAPEFALO@GAMEOPTION_AI_TWEAKS?$AA@
	mov	ecx, DWORD PTR $T237469[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN7@IsTestStra@25
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237473[ebp], eax
	push	OFFSET ??_C@_0CI@FDGKAHKI@GAMEOPTION_AI_GIMP_NO_BUILDING_S@
	mov	ecx, DWORD PTR $T237473[ebp]
	call	?isOption@CvGame@@QBE_NPBD@Z		; CvGame::isOption
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@IsTestStra@25
$LN7@IsTestStra@25:

; 4030 : #else
; 4031 : 	if(GC.getGame().isOption(GAMEOPTION_ONE_CITY_CHALLENGE) && pPlayer->isHuman())
; 4032 : #endif
; 4033 : 	{
; 4034 : 		return false;

	xor	al, al
	jmp	$LN9@IsTestStra@25
$LN8@IsTestStra@25:

; 4035 : 	}
; 4036 : 
; 4037 : 	// Never run this if we are going for a cultural victory since it will derail that
; 4038 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eGrandStrategy$[ebp], eax

; 4039 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eGrandStrategy$[ebp], -1
	je	SHORT $LN4@IsTestStra@25

; 4040 : 	{
; 4041 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eGrandStrategy$[ebp]
	jne	SHORT $LN4@IsTestStra@25

; 4042 : 		{
; 4043 : 			// Does number of cities matter?
; 4044 : 			if(GC.getMap().getWorldInfo().GetNumCitiesPolicyCostMod() > 0)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237477[ebp], edx
	mov	ecx, DWORD PTR $T237477[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?GetNumCitiesPolicyCostMod@CvWorldInfo@@QBEHXZ ; CvWorldInfo::GetNumCitiesPolicyCostMod
	test	eax, eax
	jle	SHORT $LN4@IsTestStra@25

; 4045 : 			{
; 4046 : 				return false;

	xor	al, al
	jmp	SHORT $LN9@IsTestStra@25
$LN4@IsTestStra@25:

; 4047 : 			}
; 4048 : 		}
; 4049 : 	}
; 4050 : 
; 4051 : 	int iFlavorExpansion = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_EXPANSION"));

	push	0
	push	OFFSET ??_C@_0BB@PHIOLDJK@FLAVOR_EXPANSION?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorExpansion$[ebp], eax

; 4052 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$[ebp], eax

; 4053 : 	if(iFlavorExpansion >= pStrategy->GetWeightThreshold())

	mov	ecx, DWORD PTR _pStrategy$[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	cmp	DWORD PTR _iFlavorExpansion$[ebp], eax
	jl	SHORT $LN1@IsTestStra@25

; 4054 : 	{
; 4055 : 		return true;

	mov	al, 1
	jmp	SHORT $LN9@IsTestStra@25
$LN1@IsTestStra@25:

; 4056 : 	}
; 4057 : 
; 4058 : 	return false;

	xor	al, al
$LN9@IsTestStra@25:

; 4059 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_ExpandLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_ExpandLikeCrazy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z
_TEXT	SEGMENT
_pStrategy$ = -8					; size = 4
_iFlavorGrowth$ = -4					; size = 4
_eStrategy$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy, COMDAT

; 4062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4063 : 	int iFlavorGrowth = pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes)GC.getInfoTypeForString("FLAVOR_GROWTH"));

	push	0
	push	OFFSET ??_C@_0O@CLFAHDIJ@FLAVOR_GROWTH?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
	mov	DWORD PTR _iFlavorGrowth$[ebp], eax

; 4064 : 	CvEconomicAIStrategyXMLEntry* pStrategy = pPlayer->GetEconomicAI()->GetEconomicAIStrategies()->GetEntry(eStrategy);

	mov	eax, DWORD PTR _eStrategy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	ecx, eax
	call	?GetEconomicAIStrategies@CvEconomicAI@@QAEPAVCvEconomicAIStrategyXMLEntries@@XZ ; CvEconomicAI::GetEconomicAIStrategies
	mov	ecx, eax
	call	?GetEntry@CvEconomicAIStrategyXMLEntries@@QAEPAVCvEconomicAIStrategyXMLEntry@@H@Z ; CvEconomicAIStrategyXMLEntries::GetEntry
	mov	DWORD PTR _pStrategy$[ebp], eax

; 4065 : 	if(iFlavorGrowth >= pStrategy->GetWeightThreshold())

	mov	ecx, DWORD PTR _pStrategy$[ebp]
	call	?GetWeightThreshold@CvEconomicAIStrategyXMLEntry@@QBEHXZ ; CvEconomicAIStrategyXMLEntry::GetWeightThreshold
	cmp	DWORD PTR _iFlavorGrowth$[ebp], eax
	jl	SHORT $LN1@IsTestStra@26

; 4066 : 	{
; 4067 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@26
$LN1@IsTestStra@26:

; 4068 : 	}
; 4069 : 
; 4070 : 	return false;

	xor	al, al
$LN2@IsTestStra@26:

; 4071 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_GrowLikeCrazy@EconomicAIHelpers@@YA_NW4EconomicAIStrategyTypes@@PAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GrowLikeCrazy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_eGrandStrategy$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Culture, COMDAT

; 4078 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4079 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CULTURE");

	push	0
	push	OFFSET ??_C@_0BI@FNGLFDGI@AIGRANDSTRATEGY_CULTURE?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eGrandStrategy$[ebp], eax

; 4080 : 
; 4081 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eGrandStrategy$[ebp], -1
	je	SHORT $LN2@IsTestStra@27

; 4082 : 	{
; 4083 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eGrandStrategy$[ebp]
	jne	SHORT $LN2@IsTestStra@27

; 4084 : 		{
; 4085 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestStra@27
$LN2@IsTestStra@27:

; 4086 : 		}
; 4087 : 	}
; 4088 : 
; 4089 : 	return false;

	xor	al, al
$LN3@IsTestStra@27:

; 4090 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_GS_Culture@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Culture
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
CONST	SEGMENT
??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@ DB 'AIGRANDSTRATEGY_CONQ'
	DB	'UEST', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_eGrandStrategy$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Conquest, COMDAT

; 4094 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4095 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_CONQUEST");

	push	0
	push	OFFSET ??_C@_0BJ@GCKPAHPE@AIGRANDSTRATEGY_CONQUEST?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eGrandStrategy$[ebp], eax

; 4096 : 
; 4097 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eGrandStrategy$[ebp], -1
	je	SHORT $LN2@IsTestStra@28

; 4098 : 	{
; 4099 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eGrandStrategy$[ebp]
	jne	SHORT $LN2@IsTestStra@28

; 4100 : 		{
; 4101 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestStra@28
$LN2@IsTestStra@28:

; 4102 : 		}
; 4103 : 	}
; 4104 : 
; 4105 : 	return false;

	xor	al, al
$LN3@IsTestStra@28:

; 4106 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_GS_Conquest@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Conquest
_TEXT	ENDS
PUBLIC	??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ ; `string'
;	COMDAT ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
CONST	SEGMENT
??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@ DB 'AIGRANDSTRATEG'
	DB	'Y_UNITED_NATIONS', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_eGrandStrategy$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy, COMDAT

; 4110 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4111 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_UNITED_NATIONS");

	push	0
	push	OFFSET ??_C@_0BP@DOCBNDKB@AIGRANDSTRATEGY_UNITED_NATIONS?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eGrandStrategy$[ebp], eax

; 4112 : 
; 4113 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eGrandStrategy$[ebp], -1
	je	SHORT $LN2@IsTestStra@29

; 4114 : 	{
; 4115 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eGrandStrategy$[ebp]
	jne	SHORT $LN2@IsTestStra@29

; 4116 : 		{
; 4117 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestStra@29
$LN2@IsTestStra@29:

; 4118 : 		}
; 4119 : 	}
; 4120 : 
; 4121 : 	return false;

	xor	al, al
$LN3@IsTestStra@29:

; 4122 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_GS_Diplomacy@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Diplomacy
_TEXT	ENDS
PUBLIC	??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ ; `string'
;	COMDAT ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
CONST	SEGMENT
??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@ DB 'AIGRANDSTRATEGY_SPAC'
	DB	'ESHIP', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_eGrandStrategy$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship, COMDAT

; 4126 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4127 : 	AIGrandStrategyTypes eGrandStrategy = (AIGrandStrategyTypes) GC.getInfoTypeForString("AIGRANDSTRATEGY_SPACESHIP");

	push	0
	push	OFFSET ??_C@_0BK@CCPNHFB@AIGRANDSTRATEGY_SPACESHIP?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eGrandStrategy$[ebp], eax

; 4128 : 
; 4129 : 	if(eGrandStrategy != NO_AIGRANDSTRATEGY)

	cmp	DWORD PTR _eGrandStrategy$[ebp], -1
	je	SHORT $LN2@IsTestStra@30

; 4130 : 	{
; 4131 : 		if(pPlayer->GetGrandStrategyAI()->GetActiveGrandStrategy() == eGrandStrategy)

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetActiveGrandStrategy@CvGrandStrategyAI@@QBE?AW4AIGrandStrategyTypes@@XZ ; CvGrandStrategyAI::GetActiveGrandStrategy
	cmp	eax, DWORD PTR _eGrandStrategy$[ebp]
	jne	SHORT $LN2@IsTestStra@30

; 4132 : 		{
; 4133 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestStra@30
$LN2@IsTestStra@30:

; 4134 : 		}
; 4135 : 	}
; 4136 : 
; 4137 : 	return false;

	xor	al, al
$LN3@IsTestStra@30:

; 4138 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_GS_Spaceship@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_Spaceship
_TEXT	ENDS
PUBLIC	??_C@_0BH@HJPDENF@PROJECT_APOLLO_PROGRAM?$AA@	; `string'
EXTRN	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z:PROC ; CvTeam::getProjectCount
;	COMDAT ??_C@_0BH@HJPDENF@PROJECT_APOLLO_PROGRAM?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
CONST	SEGMENT
??_C@_0BH@HJPDENF@PROJECT_APOLLO_PROGRAM?$AA@ DB 'PROJECT_APOLLO_PROGRAM', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237502 = -12						; size = 4
$T237498 = -8						; size = 4
_eApolloProgram$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch, COMDAT

; 4142 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4143 : 	// if I already built the Apollo Program I should follow through
; 4144 : 	ProjectTypes eApolloProgram = (ProjectTypes) GC.getInfoTypeForString("PROJECT_APOLLO_PROGRAM", true);

	push	1
	push	OFFSET ??_C@_0BH@HJPDENF@PROJECT_APOLLO_PROGRAM?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eApolloProgram$[ebp], eax

; 4145 : 	if(eApolloProgram != NO_PROJECT)

	cmp	DWORD PTR _eApolloProgram$[ebp], -1
	je	SHORT $LN2@IsTestStra@31

; 4146 : 	{
; 4147 : 		if(GET_TEAM(pPlayer->getTeam()).getProjectCount(eApolloProgram) > 0)

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237498[ebp], eax
	mov	edx, DWORD PTR $T237498[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR $T237502[ebp], edx
	mov	eax, DWORD PTR _eApolloProgram$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237502[ebp]
	call	?getProjectCount@CvTeam@@QBEHW4ProjectTypes@@@Z ; CvTeam::getProjectCount
	test	eax, eax
	jle	SHORT $LN2@IsTestStra@31

; 4148 : 		{
; 4149 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestStra@31
$LN2@IsTestStra@31:

; 4150 : 		}
; 4151 : 	}
; 4152 : 
; 4153 : 	return false;

	xor	al, al
$LN3@IsTestStra@31:

; 4154 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_GS_SpaceshipHomestretch@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_GS_SpaceshipHomestretch
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237508 = -12						; size = 4
_iNumArchaeologists$ = -8				; size = 4
_iNumSites$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists, COMDAT

; 4158 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4159 : 	int iNumSites = pPlayer->GetEconomicAI()->GetVisibleAntiquitySites();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237508[ebp], eax
	mov	eax, DWORD PTR $T237508[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _iNumSites$[ebp], ecx

; 4160 : 	int iNumArchaeologists = pPlayer->GetNumUnitsWithUnitAI(UNITAI_ARCHAEOLOGIST, true);

	push	1
	push	1
	push	39					; 00000027H
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumArchaeologists$[ebp], eax

; 4161 : 
; 4162 : 	if (iNumSites > iNumArchaeologists)

	mov	edx, DWORD PTR _iNumSites$[ebp]
	cmp	edx, DWORD PTR _iNumArchaeologists$[ebp]
	jle	SHORT $LN1@IsTestStra@32

; 4163 : 	{
; 4164 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@32
$LN1@IsTestStra@32:

; 4165 : 	}
; 4166 : 
; 4167 : 	return false;

	xor	al, al
$LN2@IsTestStra@32:

; 4168 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedArchaeologists
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237518 = -28						; size = 4
$T237514 = -24						; size = 4
_eExpFinisher$ = -20					; size = 4
_iMaxRatio$ = -16					; size = 8
_iNumArchaeologists$ = -8				; size = 4
_iNumSites$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists, COMDAT

; 4172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 4173 : 	int iNumSites = GC.getGame().GetNumArchaeologySites();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237514[ebp], eax
	mov	ecx, DWORD PTR $T237514[ebp]
	call	?GetNumArchaeologySites@CvGame@@QBEHXZ	; CvGame::GetNumArchaeologySites
	mov	DWORD PTR _iNumSites$[ebp], eax

; 4174 : 	double iMaxRatio = .5; //Ratio of archaeologists to sites

	movsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _iMaxRatio$[ebp], xmm0

; 4175 : 	int iNumArchaeologists = pPlayer->GetNumUnitsWithUnitAI(UNITAI_ARCHAEOLOGIST, true);

	push	1
	push	1
	push	39					; 00000027H
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetNumUnitsWithUnitAI@CvPlayer@@QAEHW4UnitAITypes@@_N1@Z ; CvPlayer::GetNumUnitsWithUnitAI
	mov	DWORD PTR _iNumArchaeologists$[ebp], eax

; 4176 : 	PolicyTypes eExpFinisher = (PolicyTypes) GC.getInfoTypeForString("POLICY_EXPLORATION_FINISHER", true /*bHideAssert*/);

	push	1
	push	OFFSET ??_C@_0BM@PALJPMHC@POLICY_EXPLORATION_FINISHER?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eExpFinisher$[ebp], eax

; 4177 : 	
; 4178 : 	if (eExpFinisher != NO_POLICY)

	cmp	DWORD PTR _eExpFinisher$[ebp], -1
	je	SHORT $LN2@IsTestStra@33

; 4179 : 	{
; 4180 : 		if (pPlayer->GetPlayerPolicies()->HasPolicy(eExpFinisher))

	mov	ecx, DWORD PTR _eExpFinisher$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?HasPolicy@CvPlayerPolicies@@QBE_NW4PolicyTypes@@@Z ; CvPlayerPolicies::HasPolicy
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@IsTestStra@33

; 4181 : 		{
; 4182 : 			iNumSites += GC.getGame().GetNumHiddenArchaeologySites();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237518[ebp], eax
	mov	ecx, DWORD PTR $T237518[ebp]
	call	?GetNumHiddenArchaeologySites@CvGame@@QBEHXZ ; CvGame::GetNumHiddenArchaeologySites
	add	eax, DWORD PTR _iNumSites$[ebp]
	mov	DWORD PTR _iNumSites$[ebp], eax
$LN2@IsTestStra@33:

; 4183 : 		}
; 4184 : 	}
; 4185 : 		
; 4186 : 	if ((double)iNumSites * iMaxRatio + 1 < iNumArchaeologists)

	cvtsi2sd xmm0, DWORD PTR _iNumSites$[ebp]
	mulsd	xmm0, QWORD PTR _iMaxRatio$[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvtsi2sd xmm1, DWORD PTR _iNumArchaeologists$[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN1@IsTestStra@33

; 4187 : 	{
; 4188 : 		return true;

	mov	al, 1
	jmp	SHORT $LN4@IsTestStra@33
$LN1@IsTestStra@33:

; 4189 : 	}
; 4190 : 
; 4191 : 	return false;

	xor	al, al
$LN4@IsTestStra@33:

; 4192 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_EnoughArchaeologists@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_EnoughArchaeologists
_TEXT	ENDS
EXTRN	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z:PROC ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
EXTRN	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ:PROC ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
; Function compile flags: /Odtp
;	COMDAT ?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237524 = -16						; size = 4
_eArtArtifactSlot$ = -12				; size = 4
_iNumGreatWorkSlots$ = -8				; size = 4
_iNumSites$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedMuseums, COMDAT

; 4196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4197 : 	int iNumSites = pPlayer->GetEconomicAI()->GetVisibleAntiquitySites();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetEconomicAI@CvPlayer@@QBEPAVCvEconomicAI@@XZ ; CvPlayer::GetEconomicAI
	mov	DWORD PTR $T237524[ebp], eax
	mov	eax, DWORD PTR $T237524[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _iNumSites$[ebp], ecx

; 4198 : 	GreatWorkSlotType eArtArtifactSlot = CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT();

	call	?getGREAT_WORK_SLOT_ART_ARTIFACT@CvTypes@@YA?BW4GreatWorkSlotType@@XZ ; CvTypes::getGREAT_WORK_SLOT_ART_ARTIFACT
	mov	DWORD PTR _eArtArtifactSlot$[ebp], eax

; 4199 : 	int iNumGreatWorkSlots = pPlayer->GetCulture()->GetNumAvailableGreatWorkSlots(eArtArtifactSlot);

	mov	edx, DWORD PTR _eArtArtifactSlot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCulture@CvPlayer@@QBEPAVCvPlayerCulture@@XZ ; CvPlayer::GetCulture
	mov	ecx, eax
	call	?GetNumAvailableGreatWorkSlots@CvPlayerCulture@@QBEHW4GreatWorkSlotType@@@Z ; CvPlayerCulture::GetNumAvailableGreatWorkSlots
	mov	DWORD PTR _iNumGreatWorkSlots$[ebp], eax

; 4200 : 
; 4201 : 	if (iNumSites > iNumGreatWorkSlots)

	mov	eax, DWORD PTR _iNumSites$[ebp]
	cmp	eax, DWORD PTR _iNumGreatWorkSlots$[ebp]
	jle	SHORT $LN1@IsTestStra@34

; 4202 : 	{
; 4203 : 		return true;

	mov	al, 1
	jmp	SHORT $LN2@IsTestStra@34
$LN1@IsTestStra@34:

; 4204 : 	}
; 4205 : 
; 4206 : 	return false;

	xor	al, al
$LN2@IsTestStra@34:

; 4207 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedMuseums@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedMuseums
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IJMHMMBH@BUILDING_MUSICIANS_GUILD?$AA@ ; `string'
PUBLIC	??_C@_0BH@KLLIOJFG@BUILDING_ARTISTS_GUILD?$AA@	; `string'
PUBLIC	??_C@_0BH@JLLHHDHH@BUILDING_WRITERS_GUILD?$AA@	; `string'
EXTRN	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z:PROC ; CvPlayer::GetFirstCityWithBuildingClass
EXTRN	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ:PROC ; CvBuildingEntry::GetBuildingClassType
EXTRN	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetPrereqAndTech
EXTRN	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z:PROC ; CvGlobals::getBuildingInfo
;	COMDAT ??_C@_0BJ@IJMHMMBH@BUILDING_MUSICIANS_GUILD?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
CONST	SEGMENT
??_C@_0BJ@IJMHMMBH@BUILDING_MUSICIANS_GUILD?$AA@ DB 'BUILDING_MUSICIANS_G'
	DB	'UILD', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KLLIOJFG@BUILDING_ARTISTS_GUILD?$AA@
CONST	SEGMENT
??_C@_0BH@KLLIOJFG@BUILDING_ARTISTS_GUILD?$AA@ DB 'BUILDING_ARTISTS_GUILD'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JLLHHDHH@BUILDING_WRITERS_GUILD?$AA@
CONST	SEGMENT
??_C@_0BH@JLLHHDHH@BUILDING_WRITERS_GUILD?$AA@ DB 'BUILDING_WRITERS_GUILD'
	DB	00H						; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cveconomicai.cpp
CONST	ENDS
;	COMDAT ?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
$T237535 = -24						; size = 4
_eArtistsGuild$ = -20					; size = 4
_pkBuilding$ = -16					; size = 4
_eMusiciansGuild$ = -12					; size = 4
_kTeam$ = -8						; size = 4
_eWritersGuild$ = -4					; size = 4
_pPlayer$ = 8						; size = 4
?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_NeedGuilds, COMDAT

; 4211 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4212 : 	CvTeam &kTeam = GET_TEAM(pPlayer->getTeam());

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T237535[ebp], eax
	mov	edx, DWORD PTR $T237535[ebp]
	imul	edx, 2984				; 00000ba8H
	add	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	DWORD PTR _kTeam$[ebp], edx

; 4213 : 
; 4214 : 	BuildingTypes eWritersGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_WRITERS_GUILD", true);

	push	1
	push	OFFSET ??_C@_0BH@JLLHHDHH@BUILDING_WRITERS_GUILD?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eWritersGuild$[ebp], eax

; 4215 : 	BuildingTypes eArtistsGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_ARTISTS_GUILD", true);

	push	1
	push	OFFSET ??_C@_0BH@KLLIOJFG@BUILDING_ARTISTS_GUILD?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eArtistsGuild$[ebp], eax

; 4216 : 	BuildingTypes eMusiciansGuild = (BuildingTypes)GC.getInfoTypeForString("BUILDING_MUSICIANS_GUILD", true);

	push	1
	push	OFFSET ??_C@_0BJ@IJMHMMBH@BUILDING_MUSICIANS_GUILD?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eMusiciansGuild$[ebp], eax

; 4217 : 
; 4218 : 	CvBuildingEntry *pkBuilding;
; 4219 : 	pkBuilding = GC.getBuildingInfo(eWritersGuild);

	mov	eax, DWORD PTR _eWritersGuild$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuilding$[ebp], eax

; 4220 : 	if (pkBuilding)

	cmp	DWORD PTR _pkBuilding$[ebp], 0
	je	SHORT $LN9@IsTestStra@35

; 4221 : 	{
; 4222 : 		if (kTeam.GetTeamTechs()->HasTech((TechTypes)pkBuilding->GetPrereqAndTech()))

	mov	ecx, DWORD PTR _pkBuilding$[ebp]
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	push	eax
	mov	ecx, DWORD PTR _kTeam$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@IsTestStra@35

; 4223 : 		{
; 4224 : 			if (pPlayer->GetFirstCityWithBuildingClass((BuildingClassTypes)pkBuilding->GetBuildingClassType()) == NULL)

	mov	ecx, DWORD PTR _pkBuilding$[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	test	eax, eax
	jne	SHORT $LN9@IsTestStra@35

; 4225 : 			{
; 4226 : 				return true;

	mov	al, 1
	jmp	$LN10@IsTestStra@35
$LN9@IsTestStra@35:

; 4227 : 			}
; 4228 : 		}
; 4229 : 	}
; 4230 : 	pkBuilding = GC.getBuildingInfo(eArtistsGuild);

	mov	edx, DWORD PTR _eArtistsGuild$[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuilding$[ebp], eax

; 4231 : 	if (pkBuilding)

	cmp	DWORD PTR _pkBuilding$[ebp], 0
	je	SHORT $LN6@IsTestStra@35

; 4232 : 	{
; 4233 : 		if (kTeam.GetTeamTechs()->HasTech((TechTypes)pkBuilding->GetPrereqAndTech()))

	mov	ecx, DWORD PTR _pkBuilding$[ebp]
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	push	eax
	mov	ecx, DWORD PTR _kTeam$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@IsTestStra@35

; 4234 : 		{
; 4235 : 			if (pPlayer->GetFirstCityWithBuildingClass((BuildingClassTypes)pkBuilding->GetBuildingClassType()) == NULL)

	mov	ecx, DWORD PTR _pkBuilding$[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	test	eax, eax
	jne	SHORT $LN6@IsTestStra@35

; 4236 : 			{
; 4237 : 				return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestStra@35
$LN6@IsTestStra@35:

; 4238 : 			}
; 4239 : 		}
; 4240 : 	}
; 4241 : 	pkBuilding = GC.getBuildingInfo(eMusiciansGuild);

	mov	ecx, DWORD PTR _eMusiciansGuild$[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildingInfo@CvGlobals@@QAEPAVCvBuildingEntry@@W4BuildingTypes@@@Z ; CvGlobals::getBuildingInfo
	mov	DWORD PTR _pkBuilding$[ebp], eax

; 4242 : 	if (pkBuilding)

	cmp	DWORD PTR _pkBuilding$[ebp], 0
	je	SHORT $LN3@IsTestStra@35

; 4243 : 	{
; 4244 : 		if (kTeam.GetTeamTechs()->HasTech((TechTypes)pkBuilding->GetPrereqAndTech()))

	mov	ecx, DWORD PTR _pkBuilding$[ebp]
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech
	push	eax
	mov	ecx, DWORD PTR _kTeam$[ebp]
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::HasTech
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@IsTestStra@35

; 4245 : 		{
; 4246 : 			if (pPlayer->GetFirstCityWithBuildingClass((BuildingClassTypes)pkBuilding->GetBuildingClassType()) == NULL)

	mov	ecx, DWORD PTR _pkBuilding$[ebp]
	call	?GetBuildingClassType@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetBuildingClassType
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetFirstCityWithBuildingClass@CvPlayer@@QAEPAVCvCity@@W4BuildingClassTypes@@@Z ; CvPlayer::GetFirstCityWithBuildingClass
	test	eax, eax
	jne	SHORT $LN3@IsTestStra@35

; 4247 : 			{
; 4248 : 				return true;

	mov	al, 1
	jmp	SHORT $LN10@IsTestStra@35
$LN3@IsTestStra@35:

; 4249 : 			}
; 4250 : 		}
; 4251 : 	}
; 4252 : 
; 4253 : 	return false;

	xor	al, al
$LN10@IsTestStra@35:

; 4254 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_NeedGuilds@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_NeedGuilds
_TEXT	ENDS
PUBLIC	??_C@_0BE@JIHAKHOA@POLICY_BRANCH_PIETY?$AA@	; `string'
EXTRN	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z:PROC ; CvPlayerPolicies::IsPolicyBranchUnlocked
;	COMDAT ??_C@_0BE@JIHAKHOA@POLICY_BRANCH_PIETY?$AA@
CONST	SEGMENT
??_C@_0BE@JIHAKHOA@POLICY_BRANCH_PIETY?$AA@ DB 'POLICY_BRANCH_PIETY', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z
_TEXT	SEGMENT
_eBranch$ = -8						; size = 4
_bRtnValue$ = -1					; size = 1
_pPlayer$ = 8						; size = 4
?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z PROC ; EconomicAIHelpers::IsTestStrategy_StartedPiety, COMDAT

; 4258 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4259 : 	bool bRtnValue = false;

	mov	BYTE PTR _bRtnValue$[ebp], 0

; 4260 : 
; 4261 : 	PolicyBranchTypes eBranch = (PolicyBranchTypes)GC.getInfoTypeForString("POLICY_BRANCH_PIETY", true);

	push	1
	push	OFFSET ??_C@_0BE@JIHAKHOA@POLICY_BRANCH_PIETY?$AA@
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString
	mov	DWORD PTR _eBranch$[ebp], eax

; 4262 : 	if (eBranch != NO_POLICY_BRANCH_TYPE)

	cmp	DWORD PTR _eBranch$[ebp], -1
	je	SHORT $LN2@IsTestStra@36

; 4263 : 	{
; 4264 : 		if (pPlayer->GetPlayerPolicies()->IsPolicyBranchUnlocked(eBranch))

	mov	eax, DWORD PTR _eBranch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?IsPolicyBranchUnlocked@CvPlayerPolicies@@QBE_NW4PolicyBranchTypes@@@Z ; CvPlayerPolicies::IsPolicyBranchUnlocked
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@IsTestStra@36

; 4265 : 		{
; 4266 : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsTestStra@36
$LN2@IsTestStra@36:

; 4267 : 		}
; 4268 : 	}
; 4269 : 
; 4270 : 	return bRtnValue;

	mov	al, BYTE PTR _bRtnValue$[ebp]
$LN3@IsTestStra@36:

; 4271 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsTestStrategy_StartedPiety@EconomicAIHelpers@@YA_NPAVCvPlayer@@@Z ENDP ; EconomicAIHelpers::IsTestStrategy_StartedPiety
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
_TEXT	ENDS
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 146  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		if(m_target) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN2@FObjectHan:

; 150  : 		}
; 151  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
PUBLIC	?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z		; BaseVector<unsigned int,0>::Copy
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z$0
__ehfuncinfo$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T237619 = -24						; size = 4
$T237618 = -20						; size = 4
_pRet$237617 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_RHS$ = 8						; size = 4
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 296  : 	FFastVector(const THIS_TYPE& RHS)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 297  : 	{
; 298  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 299  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 300  : 		if( RHS.m_uiCurrMaxSize)

	mov	eax, DWORD PTR _RHS$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@FFastVecto

; 301  : 		{
; 302  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237618[ebp], edx
	cmp	DWORD PTR $T237618[ebp], 0
	jbe	SHORT $LN7@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T237618[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237617[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237618[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$237617[ebp]
	mov	DWORD PTR $T237619[ebp], eax
	jmp	SHORT $LN8@FFastVecto
$LN7@FFastVecto:
	mov	DWORD PTR $T237619[ebp], 0
$LN8@FFastVecto:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237619[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@FFastVecto:

; 303  : 		}
; 304  : #ifdef BREAK_ON_REPEATED_RESIZE
; 305  : 		m_nResizeTimes = 0;
; 306  : #endif
; 307  : 		Copy(RHS);

	mov	eax, DWORD PTR _RHS$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z	; BaseVector<unsigned int,0>::Copy

; 308  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@I$0A@@@QAE@XZ		; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
__ehhandler$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@ABV0@@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T237649 = -20						; size = 4
_pRet$237648 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto@2
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237648[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$237648[ebp]
	mov	DWORD PTR $T237649[ebp], eax
	jmp	SHORT $LN7@FFastVecto@2
$LN6@FFastVecto@2:
	mov	DWORD PTR $T237649[ebp], 0
$LN7@FFastVecto@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237649[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@I$0A@@@QAE@XZ		; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
__ehhandler$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@I@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T237684 = -24						; size = 4
$T237683 = -20						; size = 4
_i$237675 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237684[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237683[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN4@FFastVecto@3
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@FFastVecto@3
	mov	DWORD PTR _i$237675[ebp], 0
	jmp	SHORT $LN9@FFastVecto@3
$LN8@FFastVecto@3:
	mov	eax, DWORD PTR _i$237675[ebp]
	add	eax, 1
	mov	DWORD PTR _i$237675[ebp], eax
$LN9@FFastVecto@3:
	mov	ecx, DWORD PTR _i$237675[ebp]
	cmp	ecx, DWORD PTR $T237684[ebp]
	jae	SHORT $LN4@FFastVecto@3
	jmp	SHORT $LN8@FFastVecto@3
$LN4@FFastVecto@3:
	mov	edx, DWORD PTR $T237683[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@I$0A@@@QAE@XZ		; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
__ehhandler$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAE@XZ ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>
PUBLIC	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z
_TEXT	SEGMENT
tv139 = -56						; size = 4
tv130 = -52						; size = 4
_this$ = -48						; size = 4
$T237696 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T237696[ebp], eax
	cmp	DWORD PTR $T237696[ebp], 0
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR $T237696[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T237696[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN5@push_back
$LN4@push_back:
	mov	DWORD PTR tv130[ebp], 0
$LN5@push_back:

; 380  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv139[ebp]

; 381  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEIABI@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z
_TEXT	SEGMENT
tv128 = -56						; size = 4
_this$ = -52						; size = 4
$T237748 = -8						; size = 4
_i$227565 = -4						; size = 4
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		uiNum += m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNum$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _uiNum$[ebp], ecx

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN4@push_back_

; 411  : 			GrowSize(uiNum);

	mov	ecx, DWORD PTR _uiNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _i$227565[ebp], eax
	jmp	SHORT $LN3@push_back_
$LN2@push_back_:
	mov	ecx, DWORD PTR _i$227565[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227565[ebp], ecx
$LN3@push_back_:
	mov	edx, DWORD PTR _i$227565[ebp]
	cmp	edx, DWORD PTR _uiNum$[ebp]
	jae	SHORT $LN1@push_back_

; 413  : 			new( (void*)&m_pData[i] )T(element);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$227565[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T237748[ebp], eax
	cmp	DWORD PTR $T237748[ebp], 0
	je	SHORT $LN7@push_back_
	mov	ecx, DWORD PTR $T237748[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T237748[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN8@push_back_
$LN7@push_back_:
	mov	DWORD PTR tv128[ebp], 0
$LN8@push_back_:

; 414  : 		}

	jmp	SHORT $LN2@push_back_
$LN1@push_back_:

; 415  : 		m_uiCurrSize = uiNum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	mov	DWORD PTR [edx+4], eax

; 416  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?push_back_copy@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@QAEXABII@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::push_back_copy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T237814 = -20						; size = 4
_pRet$237813 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto@4
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237813[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$237813[ebp]
	mov	DWORD PTR $T237814[ebp], eax
	jmp	SHORT $LN7@FFastVecto@4
$LN6@FFastVecto@4:
	mov	DWORD PTR $T237814[ebp], 0
$LN7@FFastVecto@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237814[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$0A@@@QAE@XZ		; BaseVector<int,0>::~BaseVector<int,0>
__ehhandler$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@I@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T237849 = -24						; size = 4
$T237848 = -20						; size = 4
_i$237840 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T237849[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237848[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN4@FFastVecto@5
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@FFastVecto@5
	mov	DWORD PTR _i$237840[ebp], 0
	jmp	SHORT $LN9@FFastVecto@5
$LN8@FFastVecto@5:
	mov	eax, DWORD PTR _i$237840[ebp]
	add	eax, 1
	mov	DWORD PTR _i$237840[ebp], eax
$LN9@FFastVecto@5:
	mov	ecx, DWORD PTR _i$237840[ebp]
	cmp	ecx, DWORD PTR $T237849[ebp]
	jae	SHORT $LN4@FFastVecto@5
	jmp	SHORT $LN8@FFastVecto@5
$LN4@FFastVecto@5:
	mov	edx, DWORD PTR $T237848[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$0A@@@QAE@XZ		; BaseVector<int,0>::~BaseVector<int,0>
__ehhandler$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAE@XZ ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::~FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z
_TEXT	SEGMENT
tv139 = -56						; size = 4
tv130 = -52						; size = 4
_this$ = -48						; size = 4
$T237861 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back@2

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T237861[ebp], eax
	cmp	DWORD PTR $T237861[ebp], 0
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR $T237861[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T237861[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN5@push_back@2
$LN4@push_back@2:
	mov	DWORD PTR tv130[ebp], 0
$LN5@push_back@2:

; 380  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv139[ebp]

; 381  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEIABH@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z
_TEXT	SEGMENT
tv128 = -56						; size = 4
_this$ = -52						; size = 4
$T237913 = -8						; size = 4
_i$227593 = -4						; size = 4
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		uiNum += m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNum$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _uiNum$[ebp], ecx

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN4@push_back_@2

; 411  : 			GrowSize(uiNum);

	mov	ecx, DWORD PTR _uiNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_@2:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _i$227593[ebp], eax
	jmp	SHORT $LN3@push_back_@2
$LN2@push_back_@2:
	mov	ecx, DWORD PTR _i$227593[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227593[ebp], ecx
$LN3@push_back_@2:
	mov	edx, DWORD PTR _i$227593[ebp]
	cmp	edx, DWORD PTR _uiNum$[ebp]
	jae	SHORT $LN1@push_back_@2

; 413  : 			new( (void*)&m_pData[i] )T(element);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$227593[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T237913[ebp], eax
	cmp	DWORD PTR $T237913[ebp], 0
	je	SHORT $LN7@push_back_@2
	mov	ecx, DWORD PTR $T237913[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T237913[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN8@push_back_@2
$LN7@push_back_@2:
	mov	DWORD PTR tv128[ebp], 0
$LN8@push_back_@2:

; 414  : 		}

	jmp	SHORT $LN2@push_back_@2
$LN1@push_back_@2:

; 415  : 		m_uiCurrSize = uiNum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	mov	DWORD PTR [edx+4], eax

; 416  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?push_back_copy@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@QAEXABHI@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::push_back_copy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T237979 = -20						; size = 4
_pRet$237978 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto@6
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$237978[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$237978[ebp]
	mov	DWORD PTR $T237979[ebp], eax
	jmp	SHORT $LN7@FFastVecto@6
$LN6@FFastVecto@6:
	mov	DWORD PTR $T237979[ebp], 0
$LN7@FFastVecto@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T237979[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
__ehhandler$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T238014 = -24						; size = 4
$T238013 = -20						; size = 4
_i$238005 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238014[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238013[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN4@FFastVecto@7
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@FFastVecto@7
	mov	DWORD PTR _i$238005[ebp], 0
	jmp	SHORT $LN9@FFastVecto@7
$LN8@FFastVecto@7:
	mov	eax, DWORD PTR _i$238005[ebp]
	add	eax, 1
	mov	DWORD PTR _i$238005[ebp], eax
$LN9@FFastVecto@7:
	mov	ecx, DWORD PTR _i$238005[ebp]
	cmp	ecx, DWORD PTR $T238014[ebp]
	jae	SHORT $LN4@FFastVecto@7
	jmp	SHORT $LN8@FFastVecto@7
$LN4@FFastVecto@7:
	mov	edx, DWORD PTR $T238013[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
__ehhandler$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::~FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z
_TEXT	SEGMENT
tv140 = -56						; size = 4
tv131 = -52						; size = 4
_this$ = -48						; size = 4
$T238026 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back@3

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T238026[ebp], eax
	cmp	DWORD PTR $T238026[ebp], 0
	je	SHORT $LN4@push_back@3
	mov	ecx, DWORD PTR _element$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T238026[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T238026[ebp]
	mov	DWORD PTR tv131[ebp], edx
	jmp	SHORT $LN5@push_back@3
$LN4@push_back@3:
	mov	DWORD PTR tv131[ebp], 0
$LN5@push_back@3:

; 380  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv140[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv140[ebp]

; 381  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@QAEIABUGoodyHutUnitAssignment@CvEconomicAI@@@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ	; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T238088 = -20						; size = 4
_pRet$238085 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 6

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238088[ebp], edx
	cmp	DWORD PTR $T238088[ebp], 6
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T238088[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$238085[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T238088[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$238085[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 6
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$238085[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ ; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>
__ehhandler$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::FStaticVector<CvPurchaseRequest,6,1,297,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T238119 = -24						; size = 4
$T238118 = -20						; size = 4
_i$238111 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238119[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238118[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$238111[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$238111[ebp]
	add	eax, 1
	mov	DWORD PTR _i$238111[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$238111[ebp]
	cmp	ecx, DWORD PTR $T238119[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T238118[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T238118[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ ; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>
__ehhandler$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::~FStaticVector<CvPurchaseRequest,6,1,297,0>
PUBLIC	?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z ; BaseVector<CvPurchaseRequest,1>::Copy
; Function compile flags: /Odtp
;	COMDAT ??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
_i$238164 = -24						; size = 4
$T238159 = -20						; size = 4
_pRet$238156 = -16					; size = 4
$T238152 = -12						; size = 4
$T238151 = -8						; size = 4
_i$238144 = -4						; size = 4
_RHS$ = 8						; size = 4
??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=, COMDAT
; _this$ = ecx

; 620  : 	void operator = (const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		if( m_uiCurrMaxSize <= RHS.m_uiCurrSize){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	ja	$LN2@operator

; 622  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238152[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238151[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN6@operator
	xor	edx, edx
	je	SHORT $LN6@operator
	mov	DWORD PTR _i$238144[ebp], 0
	jmp	SHORT $LN11@operator
$LN10@operator:
	mov	eax, DWORD PTR _i$238144[ebp]
	add	eax, 1
	mov	DWORD PTR _i$238144[ebp], eax
$LN11@operator:
	mov	ecx, DWORD PTR _i$238144[ebp]
	cmp	ecx, DWORD PTR $T238152[ebp]
	jae	SHORT $LN6@operator
	jmp	SHORT $LN10@operator
$LN6@operator:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T238151[ebp], edx
	je	SHORT $LN7@operator
	mov	eax, DWORD PTR $T238151[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN7@operator:

; 623  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238159[ebp], edx
	cmp	DWORD PTR $T238159[ebp], 6
	jbe	SHORT $LN16@operator
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T238159[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$238156[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T238159[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN17@operator
$LN16@operator:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$238156[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 6
$LN17@operator:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$238156[ebp]
	mov	DWORD PTR [edx], eax

; 624  : 		}else{

	jmp	SHORT $LN1@operator
$LN2@operator:

; 625  : 			Destroy(m_pData, m_uiCurrSize);

	xor	ecx, ecx
	je	SHORT $LN1@operator
	mov	DWORD PTR _i$238164[ebp], 0
	jmp	SHORT $LN21@operator
$LN20@operator:
	mov	edx, DWORD PTR _i$238164[ebp]
	add	edx, 1
	mov	DWORD PTR _i$238164[ebp], edx
$LN21@operator:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$238164[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN1@operator
	jmp	SHORT $LN20@operator
$LN1@operator:

; 626  : 		}
; 627  : 		Copy(RHS);

	mov	edx, DWORD PTR _RHS$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z ; BaseVector<CvPurchaseRequest,1>::Copy

; 628  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEXABV0@@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::operator=
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
tv141 = -52						; size = 4
tv132 = -48						; size = 4
_this$ = -44						; size = 4
$T238177 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+84], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN35@push_back@4

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN35@push_back@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T238177[ebp], ecx
	je	SHORT $LN4@push_back@4
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR $T238177[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR $T238177[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	jmp	SHORT $LN5@push_back@4
$LN4@push_back@4:
	mov	DWORD PTR tv132[ebp], 0
$LN5@push_back@4:

; 681  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv141[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@QAEIABVCvPurchaseRequest@@@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z	; BaseVector<CvUnit *,0>::Copy
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z$0
__ehfuncinfo$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T238236 = -24						; size = 4
$T238235 = -20						; size = 4
_pRet$238234 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_RHS$ = 8						; size = 4
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 296  : 	FFastVector(const THIS_TYPE& RHS)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 297  : 	{
; 298  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 299  : 		m_uiCurrMaxSize = RHS.m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 300  : 		if( RHS.m_uiCurrMaxSize)

	mov	eax, DWORD PTR _RHS$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@FFastVecto@8

; 301  : 		{
; 302  : 			m_pData = Alloc(RHS.m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238235[ebp], edx
	cmp	DWORD PTR $T238235[ebp], 0
	jbe	SHORT $LN7@FFastVecto@8
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T238235[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$238234[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T238235[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$238234[ebp]
	mov	DWORD PTR $T238236[ebp], eax
	jmp	SHORT $LN8@FFastVecto@8
$LN7@FFastVecto@8:
	mov	DWORD PTR $T238236[ebp], 0
$LN8@FFastVecto@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T238236[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@FFastVecto@8:

; 303  : 		}
; 304  : #ifdef BREAK_ON_REPEATED_RESIZE
; 305  : 		m_nResizeTimes = 0;
; 306  : #endif
; 307  : 		Copy(RHS);

	mov	eax, DWORD PTR _RHS$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z ; BaseVector<CvUnit *,0>::Copy

; 308  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ	; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
__ehhandler$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@ABV0@@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T238266 = -20						; size = 4
_pRet$238265 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto@9
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$238265[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$238265[ebp]
	mov	DWORD PTR $T238266[ebp], eax
	jmp	SHORT $LN7@FFastVecto@9
$LN6@FFastVecto@9:
	mov	DWORD PTR $T238266[ebp], 0
$LN7@FFastVecto@9:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T238266[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ	; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
__ehhandler$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@I@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T238301 = -24						; size = 4
$T238300 = -20						; size = 4
_i$238291 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238301[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238300[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN4@FFastVecto@10
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN4@FFastVecto@10
	mov	DWORD PTR _i$238291[ebp], 0
	jmp	SHORT $LN9@FFastVecto@10
$LN8@FFastVecto@10:
	mov	eax, DWORD PTR _i$238291[ebp]
	add	eax, 1
	mov	DWORD PTR _i$238291[ebp], eax
$LN9@FFastVecto@10:
	mov	ecx, DWORD PTR _i$238291[ebp]
	cmp	ecx, DWORD PTR $T238301[ebp]
	jae	SHORT $LN4@FFastVecto@10
	jmp	SHORT $LN8@FFastVecto@10
$LN4@FFastVecto@10:
	mov	edx, DWORD PTR $T238300[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ	; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
__ehhandler$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAE@XZ ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::~FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>
PUBLIC	?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z
_TEXT	SEGMENT
tv139 = -56						; size = 4
tv130 = -52						; size = 4
_this$ = -48						; size = 4
$T238313 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back, COMDAT
; _this$ = ecx

; 376  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN39@push_back@5

; 378  : 			GrowSize(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize

; 379  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@5:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T238313[ebp], eax
	cmp	DWORD PTR $T238313[ebp], 0
	je	SHORT $LN4@push_back@5
	mov	ecx, DWORD PTR $T238313[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T238313[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	jmp	SHORT $LN5@push_back@5
$LN4@push_back@5:
	mov	DWORD PTR tv130[ebp], 0
$LN5@push_back@5:

; 380  : 		return m_uiCurrSize++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR tv139[ebp]

; 381  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@QAEIABQAVCvUnit@@@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::push_back
_TEXT	ENDS
PUBLIC	??1?$BaseVector@H$00@@QAE@XZ			; BaseVector<int,1>::~BaseVector<int,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z$0
__ehfuncinfo$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T238379 = -20						; size = 4
_pRet$238375 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	cmp	DWORD PTR _uiStartingMaxSize$[ebp], 0
	jbe	SHORT $LN6@FFastVecto@11
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiStartingMaxSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$238375[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiStartingMaxSize$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _pRet$238375[ebp]
	mov	DWORD PTR $T238379[ebp], eax
	jmp	SHORT $LN7@FFastVecto@11
$LN6@FFastVecto@11:
	mov	DWORD PTR $T238379[ebp], 0
$LN7@FFastVecto@11:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T238379[ebp]
	mov	DWORD PTR [ecx], edx

; 315  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@I@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ$0
__ehfuncinfo$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T238414 = -24						; size = 4
$T238413 = -20						; size = 4
_i$238407 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 316  : 	~FFastVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238414[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238413[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN4@FFastVecto@12
	xor	edx, edx
	je	SHORT $LN4@FFastVecto@12
	mov	DWORD PTR _i$238407[ebp], 0
	jmp	SHORT $LN9@FFastVecto@12
$LN8@FFastVecto@12:
	mov	eax, DWORD PTR _i$238407[ebp]
	add	eax, 1
	mov	DWORD PTR _i$238407[ebp], eax
$LN9@FFastVecto@12:
	mov	ecx, DWORD PTR _i$238407[ebp]
	cmp	ecx, DWORD PTR $T238414[ebp]
	jae	SHORT $LN4@FFastVecto@12
	jmp	SHORT $LN8@FFastVecto@12
$LN4@FFastVecto@12:
	mov	edx, DWORD PTR $T238413[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 318  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@H$00@@QAE@XZ		; BaseVector<int,1>::~BaseVector<int,1>
__ehhandler$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAE@XZ ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::~FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>
PUBLIC	?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z
_TEXT	SEGMENT
tv128 = -56						; size = 4
_this$ = -52						; size = 4
$T238426 = -8						; size = 4
_i$227680 = -4						; size = 4
_element$ = 8						; size = 4
_uiNum$ = 12						; size = 4
?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::push_back_copy, COMDAT
; _this$ = ecx

; 408  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		uiNum += m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNum$[ebp]
	add	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _uiNum$[ebp], ecx

; 410  : 		if( uiNum > m_uiCurrMaxSize )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN4@push_back_@3

; 411  : 			GrowSize(uiNum);

	mov	ecx, DWORD PTR _uiNum$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize
$LN4@push_back_@3:

; 412  : 		for(unsigned int i = m_uiCurrSize; i < uiNum; ++i){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _i$227680[ebp], eax
	jmp	SHORT $LN3@push_back_@3
$LN2@push_back_@3:
	mov	ecx, DWORD PTR _i$227680[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227680[ebp], ecx
$LN3@push_back_@3:
	mov	edx, DWORD PTR _i$227680[ebp]
	cmp	edx, DWORD PTR _uiNum$[ebp]
	jae	SHORT $LN1@push_back_@3

; 413  : 			new( (void*)&m_pData[i] )T(element);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$227680[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR $T238426[ebp], eax
	cmp	DWORD PTR $T238426[ebp], 0
	je	SHORT $LN7@push_back_@3
	mov	ecx, DWORD PTR $T238426[ebp]
	mov	edx, DWORD PTR _element$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T238426[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	jmp	SHORT $LN8@push_back_@3
$LN7@push_back_@3:
	mov	DWORD PTR tv128[ebp], 0
$LN8@push_back_@3:

; 414  : 		}

	jmp	SHORT $LN2@push_back_@3
$LN1@push_back_@3:

; 415  : 		m_uiCurrSize = uiNum;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNum$[ebp]
	mov	DWORD PTR [edx+4], eax

; 416  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?push_back_copy@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@QAEXABHI@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::push_back_copy
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
_TEXT	ENDS
;	COMDAT ??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ PROC	; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>, COMDAT
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 	};

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAE@XZ ENDP	; CvWeightedVector<CvUnit *,50,1>::~CvWeightedVector<CvUnit *,50,1>
_TEXT	ENDS
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
; Function compile flags: /Odtp
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ
_TEXT	SEGMENT
_this$ = -156						; size = 4
$T238515 = -8						; size = 4
$T238511 = -4						; size = 4
?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ PROC ; CvWeightedVector<CvUnit *,50,1>::SortItems, COMDAT
; _this$ = ecx

; 139  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T238511[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T238515[ebp], eax
	mov	ecx, DWORD PTR $T238511[ebp]
	sub	ecx, DWORD PTR $T238515[ebp]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR $T238511[ebp]
	push	edx
	mov	eax, DWORD PTR $T238515[ebp]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SortItems@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@QAEXXZ ENDP ; CvWeightedVector<CvUnit *,50,1>::SortItems
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::~_Vector_val<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@H$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@H$00@@QAE@XZ PROC			; BaseVector<int,1>::~BaseVector<int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@H$00@@QAE@XZ ENDP			; BaseVector<int,1>::~BaseVector<int,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@H$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@H$0A@@@QAE@XZ PROC			; BaseVector<int,0>::~BaseVector<int,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@H$0A@@@QAE@XZ ENDP			; BaseVector<int,0>::~BaseVector<int,0>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T238796 = -52						; size = 4
$T238785 = -48						; size = 4
$T238784 = -44						; size = 4
__Cat$238792 = -40					; size = 1
$T238789 = -39						; size = 1
__Ptr$227734 = -12					; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp]
	mov	DWORD PTR __First$[ebp], eax

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	ecx, DWORD PTR __Last_arg$[ebp]
	mov	DWORD PTR __Last$[ebp], ecx

; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Last$[ebp]
	sete	al
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$227734[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238796[ebp], edx
	mov	eax, DWORD PTR $T238796[ebp]
	mov	DWORD PTR $T238785[ebp], eax
	mov	ecx, DWORD PTR __Ptr$227734[ebp]
	mov	DWORD PTR $T238784[ebp], ecx
	mov	dl, BYTE PTR __Cat$238792[ebp]
	mov	BYTE PTR $T238789[ebp], dl

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$227734[ebp]
	mov	DWORD PTR [eax+8], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@2@0@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::erase
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>
PUBLIC	?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$238813 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$238813[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$238813[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$238813[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T238877 = -28						; size = 4
$T238876 = -24						; size = 4
$T238872 = -20						; size = 4
$T238871 = -16						; size = 4
$T238860 = -12						; size = 4
$T238859 = -8						; size = 4
__Cat$238867 = -2					; size = 1
$T238864 = -1						; size = 1
?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T238872[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T238871[ebp], ecx
	mov	edx, DWORD PTR $T238872[ebp]
	mov	DWORD PTR $T238860[ebp], edx
	mov	eax, DWORD PTR $T238871[ebp]
	mov	DWORD PTR $T238859[ebp], eax
	mov	cl, BYTE PTR __Cat$238867[ebp]
	mov	BYTE PTR $T238864[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T238877[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238876[ebp], eax
	mov	ecx, DWORD PTR $T238876[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Tidy
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@I$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@I$0A@@@QAE@XZ PROC			; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@I$0A@@@QAE@XZ ENDP			; BaseVector<unsigned int,0>::~BaseVector<unsigned int,0>
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
_this$ = -12						; size = 4
$T238882 = -8						; size = 4
_i$227777 = -4						; size = 4
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z PROC		; BaseVector<unsigned int,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 231  : 		if( bPODType ){

	xor	eax, eax
	je	SHORT $LN5@Copy

; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _RHS$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{

	jmp	SHORT $LN6@Copy
$LN5@Copy:

; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	mov	DWORD PTR _i$227777[ebp], 0
	jmp	SHORT $LN3@Copy
$LN2@Copy:
	mov	ecx, DWORD PTR _i$227777[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227777[ebp], ecx
$LN3@Copy:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$227777[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@Copy

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$227777[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T238882[ebp], ecx
	cmp	DWORD PTR $T238882[ebp], 0
	je	SHORT $LN8@Copy
	mov	edx, DWORD PTR _RHS$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T238882[ebp]
	mov	edx, DWORD PTR _i$227777[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T238882[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN9@Copy
$LN8@Copy:
	mov	DWORD PTR tv83[ebp], 0
$LN9@Copy:

; 236  : 			}

	jmp	SHORT $LN2@Copy
$LN6@Copy:

; 237  : 		}
; 238  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@?$BaseVector@I$0A@@@IAEXABV1@@Z ENDP		; BaseVector<unsigned int,0>::Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv184 = -48						; size = 4
_this$ = -44						; size = 4
$T238933 = -40						; size = 4
$T238932 = -36						; size = 4
_i$238924 = -32						; size = 4
$T238904 = -28						; size = 4
_pRet$238903 = -24					; size = 4
$T238891 = -20						; size = 4
_i$227800 = -16						; size = 4
_uiNewSize$227791 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$227791[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$227791[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize
$LN8@GrowSize:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227791[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize
$LN9@GrowSize:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T238904[ebp], eax
	cmp	DWORD PTR $T238904[ebp], 0
	jbe	SHORT $LN16@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T238904[ebp]
	shl	ecx, 2
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$238903[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T238904[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$238903[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize
$LN16@GrowSize:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize
$LN6@GrowSize:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227800[ebp], 0
	jmp	SHORT $LN4@GrowSize
$LN3@GrowSize:
	mov	edx, DWORD PTR _i$227800[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227800[ebp], edx
$LN4@GrowSize:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227800[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227800[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T238891[ebp], ecx
	cmp	DWORD PTR $T238891[ebp], 0
	je	SHORT $LN14@GrowSize
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T238891[ebp]
	mov	edx, DWORD PTR _i$227800[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T238891[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN15@GrowSize
$LN14@GrowSize:
	mov	DWORD PTR tv184[ebp], 0
$LN15@GrowSize:
	jmp	SHORT $LN3@GrowSize
$LN5@GrowSize:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238933[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T238932[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN23@GrowSize
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize
	mov	DWORD PTR _i$238924[ebp], 0
	jmp	SHORT $LN28@GrowSize
$LN27@GrowSize:
	mov	edx, DWORD PTR _i$238924[ebp]
	add	edx, 1
	mov	DWORD PTR _i$238924[ebp], edx
$LN28@GrowSize:
	mov	eax, DWORD PTR _i$238924[ebp]
	cmp	eax, DWORD PTR $T238933[ebp]
	jae	SHORT $LN23@GrowSize
	jmp	SHORT $LN27@GrowSize
$LN23@GrowSize:
	mov	ecx, DWORD PTR $T238932[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize
$LN7@GrowSize:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN12@GrowSize:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEXI@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pRet$227811 = -4					; size = 4
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z PROC ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 504  : 		if( uiSize > 0 ){

	cmp	DWORD PTR _uiSize$[ebp], 0
	jbe	SHORT $LN1@Alloc

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR _uiSize$[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$227811[ebp], eax

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 508  : 			return pRet;

	mov	eax, DWORD PTR _pRet$227811[ebp]
	jmp	SHORT $LN2@Alloc
$LN1@Alloc:

; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
$LN2@Alloc:

; 511  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Alloc@?$FFastVector@I$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$0A@@@@@IAEPAII@Z ENDP ; FFastVector<unsigned int,0,0,0,BaseVector<unsigned int,0>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv184 = -48						; size = 4
_this$ = -44						; size = 4
$T238983 = -40						; size = 4
$T238982 = -36						; size = 4
_i$238974 = -32						; size = 4
$T238954 = -28						; size = 4
_pRet$238953 = -24					; size = 4
$T238941 = -20						; size = 4
_i$227848 = -16						; size = 4
_uiNewSize$227839 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z PROC ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize@2:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize@2

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$227839[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$227839[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize@2

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize@2
$LN8@GrowSize@2:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227839[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize@2
$LN9@GrowSize@2:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T238954[ebp], eax
	cmp	DWORD PTR $T238954[ebp], 0
	jbe	SHORT $LN16@GrowSize@2
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T238954[ebp]
	shl	ecx, 2
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$238953[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T238954[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$238953[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize@2
$LN16@GrowSize@2:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize@2:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize@2

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize@2

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize@2
$LN6@GrowSize@2:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227848[ebp], 0
	jmp	SHORT $LN4@GrowSize@2
$LN3@GrowSize@2:
	mov	edx, DWORD PTR _i$227848[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227848[ebp], edx
$LN4@GrowSize@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227848[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize@2

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227848[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T238941[ebp], ecx
	cmp	DWORD PTR $T238941[ebp], 0
	je	SHORT $LN14@GrowSize@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T238941[ebp]
	mov	edx, DWORD PTR _i$227848[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T238941[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN15@GrowSize@2
$LN14@GrowSize@2:
	mov	DWORD PTR tv184[ebp], 0
$LN15@GrowSize@2:
	jmp	SHORT $LN3@GrowSize@2
$LN5@GrowSize@2:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T238983[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T238982[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN23@GrowSize@2
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize@2
	mov	DWORD PTR _i$238974[ebp], 0
	jmp	SHORT $LN28@GrowSize@2
$LN27@GrowSize@2:
	mov	edx, DWORD PTR _i$238974[ebp]
	add	edx, 1
	mov	DWORD PTR _i$238974[ebp], edx
$LN28@GrowSize@2:
	mov	eax, DWORD PTR _i$238974[ebp]
	cmp	eax, DWORD PTR $T238983[ebp]
	jae	SHORT $LN23@GrowSize@2
	jmp	SHORT $LN27@GrowSize@2
$LN23@GrowSize@2:
	mov	ecx, DWORD PTR $T238982[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize@2
$LN7@GrowSize@2:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN12@GrowSize@2:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@H$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$0A@@@@@IAEXI@Z ENDP ; FFastVector<int,0,0,0,BaseVector<int,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@QAE@XZ ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::~BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv185 = -48						; size = 4
_this$ = -44						; size = 4
$T239030 = -40						; size = 4
$T239029 = -36						; size = 4
_i$239021 = -32						; size = 4
$T239001 = -28						; size = 4
_pRet$239000 = -24					; size = 4
$T238988 = -20						; size = 4
_i$227900 = -16						; size = 4
_uiNewSize$227891 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize@3:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize@3

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$227891[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$227891[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize@3

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize@3
$LN8@GrowSize@3:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227891[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize@3
$LN9@GrowSize@3:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239001[ebp], eax
	cmp	DWORD PTR $T239001[ebp], 0
	jbe	SHORT $LN16@GrowSize@3
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T239001[ebp]
	shl	ecx, 3
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239000[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T239001[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$239000[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize@3
$LN16@GrowSize@3:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize@3:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize@3

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize@3

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize@3
$LN6@GrowSize@3:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227900[ebp], 0
	jmp	SHORT $LN4@GrowSize@3
$LN3@GrowSize@3:
	mov	edx, DWORD PTR _i$227900[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227900[ebp], edx
$LN4@GrowSize@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227900[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize@3

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227900[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T238988[ebp], ecx
	cmp	DWORD PTR $T238988[ebp], 0
	je	SHORT $LN14@GrowSize@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$227900[ebp]
	mov	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	ecx, DWORD PTR $T238988[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T238988[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $LN15@GrowSize@3
$LN14@GrowSize@3:
	mov	DWORD PTR tv185[ebp], 0
$LN15@GrowSize@3:
	jmp	SHORT $LN3@GrowSize@3
$LN5@GrowSize@3:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239030[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239029[ebp], eax
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize@3
	mov	edx, 1
	test	edx, edx
	je	SHORT $LN23@GrowSize@3
	mov	DWORD PTR _i$239021[ebp], 0
	jmp	SHORT $LN28@GrowSize@3
$LN27@GrowSize@3:
	mov	eax, DWORD PTR _i$239021[ebp]
	add	eax, 1
	mov	DWORD PTR _i$239021[ebp], eax
$LN28@GrowSize@3:
	mov	ecx, DWORD PTR _i$239021[ebp]
	cmp	ecx, DWORD PTR $T239030[ebp]
	jae	SHORT $LN23@GrowSize@3
	jmp	SHORT $LN27@GrowSize@3
$LN23@GrowSize@3:
	mov	edx, DWORD PTR $T239029[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize@3
$LN7@GrowSize@3:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN12@GrowSize@3:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvEconomicAI::GoodyHutUnitAssignment,0,0,0,BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv179 = -44						; size = 4
_this$ = -40						; size = 4
$T239067 = -36						; size = 4
$T239066 = -32						; size = 4
_i$239059 = -28						; size = 4
$T239042 = -24						; size = 4
_pRet$239039 = -20					; size = 4
$T239033 = -16						; size = 4
_i$227946 = -12						; size = 4
_uiNewSize$227938 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@4:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@4

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$227938[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$227938[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@4

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@4
$LN6@GrowSize@4:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$227938[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@4
$LN7@GrowSize@4:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T239042[ebp], ecx
	cmp	DWORD PTR $T239042[ebp], 6
	jbe	SHORT $LN15@GrowSize@4
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T239042[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239039[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T239042[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN16@GrowSize@4
$LN15@GrowSize@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$239039[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 6
$LN16@GrowSize@4:
	mov	ecx, DWORD PTR _pRet$239039[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@4

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@4
$LN5@GrowSize@4:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$227946[ebp], 0
	jmp	SHORT $LN3@GrowSize@4
$LN2@GrowSize@4:
	mov	edx, DWORD PTR _i$227946[ebp]
	add	edx, 1
	mov	DWORD PTR _i$227946[ebp], edx
$LN3@GrowSize@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$227946[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@4

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$227946[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR $T239033[ebp], edx
	je	SHORT $LN12@GrowSize@4
	mov	eax, DWORD PTR _i$227946[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR $T239033[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T239033[ebp]
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN13@GrowSize@4
$LN12@GrowSize@4:
	mov	DWORD PTR tv179[ebp], 0
$LN13@GrowSize@4:
	jmp	SHORT $LN2@GrowSize@4
$LN4@GrowSize@4:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T239067[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T239066[ebp], ecx
	xor	edx, edx
	je	SHORT $LN21@GrowSize@4
	xor	eax, eax
	je	SHORT $LN21@GrowSize@4
	mov	DWORD PTR _i$239059[ebp], 0
	jmp	SHORT $LN26@GrowSize@4
$LN25@GrowSize@4:
	mov	ecx, DWORD PTR _i$239059[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$239059[ebp], ecx
$LN26@GrowSize@4:
	mov	edx, DWORD PTR _i$239059[ebp]
	cmp	edx, DWORD PTR $T239067[ebp]
	jae	SHORT $LN21@GrowSize@4
	jmp	SHORT $LN25@GrowSize@4
$LN21@GrowSize@4:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	cmp	DWORD PTR $T239066[ebp], eax
	je	SHORT $LN22@GrowSize@4
	mov	ecx, DWORD PTR $T239066[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSize@4:

; 769  : 		m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+84], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@VCvPurchaseRequest@@$05$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvPurchaseRequest,6,1,297,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ PROC	; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@VCvPurchaseRequest@@$00@@QAE@XZ ENDP	; BaseVector<CvPurchaseRequest,1>::~BaseVector<CvPurchaseRequest,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z
_TEXT	SEGMENT
tv84 = -16						; size = 4
_this$ = -12						; size = 4
$T239072 = -8						; size = 4
_i$227986 = -4						; size = 4
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z PROC ; BaseVector<CvPurchaseRequest,1>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 231  : 		if( bPODType ){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Copy@2

; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _RHS$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{

	jmp	SHORT $LN6@Copy@2
$LN5@Copy@2:

; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	mov	DWORD PTR _i$227986[ebp], 0
	jmp	SHORT $LN3@Copy@2
$LN2@Copy@2:
	mov	ecx, DWORD PTR _i$227986[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$227986[ebp], ecx
$LN3@Copy@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$227986[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@Copy@2

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	ecx, DWORD PTR _i$227986[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR $T239072[ebp], ecx
	je	SHORT $LN8@Copy@2
	mov	eax, DWORD PTR _i$227986[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	mov	eax, DWORD PTR $T239072[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR $T239072[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN9@Copy@2
$LN8@Copy@2:
	mov	DWORD PTR tv84[ebp], 0
$LN9@Copy@2:

; 236  : 			}

	jmp	SHORT $LN2@Copy@2
$LN6@Copy@2:

; 237  : 		}
; 238  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@?$BaseVector@VCvPurchaseRequest@@$00@@IAEXABV1@@Z ENDP ; BaseVector<CvPurchaseRequest,1>::Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ PROC		; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvUnit@@$0A@@@QAE@XZ ENDP		; BaseVector<CvUnit *,0>::~BaseVector<CvUnit *,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$228000 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z PROC ; BaseVector<CvUnit *,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Destroy

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$228000[ebp], 0
	jmp	SHORT $LN3@Destroy
$LN2@Destroy:
	mov	ecx, DWORD PTR _i$228000[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$228000[ebp], ecx
$LN3@Destroy:
	mov	edx, DWORD PTR _i$228000[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy

; 223  : 				pVal[i].~T();
; 224  : 			}

	jmp	SHORT $LN2@Destroy
$LN5@Destroy:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXPAPAVCvUnit@@I@Z ENDP ; BaseVector<CvUnit *,0>::Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
_this$ = -12						; size = 4
$T239084 = -8						; size = 4
_i$228011 = -4						; size = 4
_RHS$ = 8						; size = 4
?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z PROC	; BaseVector<CvUnit *,0>::Copy, COMDAT
; _this$ = ecx

; 229  : 	void Copy(const THIS_TYPE& RHS){

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 230  : 		m_uiCurrSize = RHS.m_uiCurrSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 231  : 		if( bPODType ){

	xor	eax, eax
	je	SHORT $LN5@Copy@3

; 232  : 			memcpy( (void*)m_pData, (void*)RHS.m_pData, sizeof(T)*RHS.m_uiCurrSize);

	mov	ecx, DWORD PTR _RHS$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _RHS$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 233  : 		}else{

	jmp	SHORT $LN6@Copy@3
$LN5@Copy@3:

; 234  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i){

	mov	DWORD PTR _i$228011[ebp], 0
	jmp	SHORT $LN3@Copy@3
$LN2@Copy@3:
	mov	ecx, DWORD PTR _i$228011[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$228011[ebp], ecx
$LN3@Copy@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$228011[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jae	SHORT $LN6@Copy@3

; 235  : 				new( (void*)&m_pData[i] )T( RHS.m_pData[i] );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$228011[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T239084[ebp], ecx
	cmp	DWORD PTR $T239084[ebp], 0
	je	SHORT $LN8@Copy@3
	mov	edx, DWORD PTR _RHS$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T239084[ebp]
	mov	edx, DWORD PTR _i$228011[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T239084[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN9@Copy@3
$LN8@Copy@3:
	mov	DWORD PTR tv83[ebp], 0
$LN9@Copy@3:

; 236  : 			}

	jmp	SHORT $LN2@Copy@3
$LN6@Copy@3:

; 237  : 		}
; 238  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@?$BaseVector@PAVCvUnit@@$0A@@@IAEXABV1@@Z ENDP	; BaseVector<CvUnit *,0>::Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z
_TEXT	SEGMENT
tv184 = -48						; size = 4
_this$ = -44						; size = 4
$T239134 = -40						; size = 4
$T239133 = -36						; size = 4
_i$239125 = -32						; size = 4
$T239105 = -28						; size = 4
_pRet$239104 = -24					; size = 4
$T239092 = -20						; size = 4
_i$228034 = -16						; size = 4
_uiNewSize$228025 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z PROC ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize@5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize@5:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize@5

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$228025[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$228025[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize@5

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize@5
$LN8@GrowSize@5:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$228025[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize@5
$LN9@GrowSize@5:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239105[ebp], eax
	cmp	DWORD PTR $T239105[ebp], 0
	jbe	SHORT $LN16@GrowSize@5
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T239105[ebp]
	shl	ecx, 2
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239104[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T239105[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$239104[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize@5
$LN16@GrowSize@5:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize@5:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize@5

; 442  : 		{
; 443  : 			if( bPODType ){

	xor	edx, edx
	je	SHORT $LN6@GrowSize@5

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize@5
$LN6@GrowSize@5:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$228034[ebp], 0
	jmp	SHORT $LN4@GrowSize@5
$LN3@GrowSize@5:
	mov	edx, DWORD PTR _i$228034[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228034[ebp], edx
$LN4@GrowSize@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$228034[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize@5

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$228034[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T239092[ebp], ecx
	cmp	DWORD PTR $T239092[ebp], 0
	je	SHORT $LN14@GrowSize@5
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T239092[ebp]
	mov	edx, DWORD PTR _i$228034[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T239092[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN15@GrowSize@5
$LN14@GrowSize@5:
	mov	DWORD PTR tv184[ebp], 0
$LN15@GrowSize@5:
	jmp	SHORT $LN3@GrowSize@5
$LN5@GrowSize@5:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239134[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239133[ebp], edx
	mov	eax, 1
	test	eax, eax
	je	SHORT $LN23@GrowSize@5
	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN23@GrowSize@5
	mov	DWORD PTR _i$239125[ebp], 0
	jmp	SHORT $LN28@GrowSize@5
$LN27@GrowSize@5:
	mov	edx, DWORD PTR _i$239125[ebp]
	add	edx, 1
	mov	DWORD PTR _i$239125[ebp], edx
$LN28@GrowSize@5:
	mov	eax, DWORD PTR _i$239125[ebp]
	cmp	eax, DWORD PTR $T239134[ebp]
	jae	SHORT $LN23@GrowSize@5
	jmp	SHORT $LN27@GrowSize@5
$LN23@GrowSize@5:
	mov	ecx, DWORD PTR $T239133[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize@5
$LN7@GrowSize@5:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN12@GrowSize@5:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@PAVCvUnit@@$0A@$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@PAVCvUnit@@$0A@@@@@IAEXI@Z ENDP ; FFastVector<CvUnit *,0,0,0,BaseVector<CvUnit *,0>::FDefaultFastVectorAllocator>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z
_TEXT	SEGMENT
tv184 = -48						; size = 4
_this$ = -44						; size = 4
$T239179 = -40						; size = 4
$T239178 = -36						; size = 4
_i$239170 = -32						; size = 4
$T239150 = -28						; size = 4
_pRet$239149 = -24					; size = 4
$T239137 = -20						; size = 4
_i$228090 = -16						; size = 4
_uiNewSize$228081 = -12					; size = 4
_nOld$ = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z PROC ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _nOld$[ebp], ecx

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+8], 0
	jne	SHORT $LN10@GrowSize@6
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1
$LN10@GrowSize@6:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jb	SHORT $LN9@GrowSize@6

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 1
	mov	DWORD PTR _uiNewSize$228081[ebp], ecx

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiNewSize$228081[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@GrowSize@6

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 433  : 				break;

	jmp	SHORT $LN9@GrowSize@6
$LN8@GrowSize@6:

; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$228081[ebp]
	mov	DWORD PTR [eax+8], ecx

; 438  : 		}

	jmp	SHORT $LN10@GrowSize@6
$LN9@GrowSize@6:

; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T239150[ebp], eax
	cmp	DWORD PTR $T239150[ebp], 0
	jbe	SHORT $LN16@GrowSize@6
	push	85					; 00000055H
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	ecx, DWORD PTR $T239150[ebp]
	shl	ecx, 2
	push	ecx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239149[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T239150[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _pRet$239149[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx
	jmp	SHORT $LN17@GrowSize@6
$LN16@GrowSize@6:
	mov	DWORD PTR _pTemp$[ebp], 0
$LN17@GrowSize@6:

; 441  : 		if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	$LN7@GrowSize@6

; 442  : 		{
; 443  : 			if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN6@GrowSize@6

; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 445  : 			}else{

	jmp	SHORT $LN5@GrowSize@6
$LN6@GrowSize@6:

; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$228090[ebp], 0
	jmp	SHORT $LN4@GrowSize@6
$LN3@GrowSize@6:
	mov	edx, DWORD PTR _i$228090[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228090[ebp], edx
$LN4@GrowSize@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$228090[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN5@GrowSize@6

; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$228090[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR $T239137[ebp], ecx
	cmp	DWORD PTR $T239137[ebp], 0
	je	SHORT $LN14@GrowSize@6
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T239137[ebp]
	mov	edx, DWORD PTR _i$228090[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T239137[ebp]
	mov	DWORD PTR tv184[ebp], ecx
	jmp	SHORT $LN15@GrowSize@6
$LN14@GrowSize@6:
	mov	DWORD PTR tv184[ebp], 0
$LN15@GrowSize@6:
	jmp	SHORT $LN3@GrowSize@6
$LN5@GrowSize@6:

; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239179[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239178[ebp], edx
	xor	eax, eax
	je	SHORT $LN23@GrowSize@6
	xor	ecx, ecx
	je	SHORT $LN23@GrowSize@6
	mov	DWORD PTR _i$239170[ebp], 0
	jmp	SHORT $LN28@GrowSize@6
$LN27@GrowSize@6:
	mov	edx, DWORD PTR _i$239170[ebp]
	add	edx, 1
	mov	DWORD PTR _i$239170[ebp], edx
$LN28@GrowSize@6:
	mov	eax, DWORD PTR _i$239170[ebp]
	cmp	eax, DWORD PTR $T239179[ebp]
	jae	SHORT $LN23@GrowSize@6
	jmp	SHORT $LN27@GrowSize@6
$LN23@GrowSize@6:
	mov	ecx, DWORD PTR $T239178[ebp]
	push	ecx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 450  : 			m_pData = pTemp;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [edx], eax

; 451  : 		}
; 452  : 		else

	jmp	SHORT $LN12@GrowSize@6
$LN7@GrowSize@6:

; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nOld$[ebp]
	mov	DWORD PTR [ecx+8], edx
$LN12@GrowSize@6:

; 456  : 		}
; 457  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FFastVector@H$00$0A@$0A@UFDefaultFastVectorAllocator@?$BaseVector@H$00@@@@IAEXI@Z ENDP ; FFastVector<int,1,0,0,BaseVector<int,1>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T239192 = -20						; size = 4
_pRet$239189 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 50			; 00000032H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239192[ebp], edx
	cmp	DWORD PTR $T239192[ebp], 50		; 00000032H
	jbe	SHORT $LN7@FStaticVec@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T239192[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T239192[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec@3
$LN7@FStaticVec@3:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$239189[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 50			; 00000032H
$LN8@FStaticVec@3:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$239189[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
__ehhandler$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T239223 = -24						; size = 4
$T239222 = -20						; size = 4
_i$239215 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239223[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239222[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@4
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@4
	mov	DWORD PTR _i$239215[ebp], 0
	jmp	SHORT $LN10@FStaticVec@4
$LN9@FStaticVec@4:
	mov	eax, DWORD PTR _i$239215[ebp]
	add	eax, 1
	mov	DWORD PTR _i$239215[ebp], eax
$LN10@FStaticVec@4:
	mov	ecx, DWORD PTR _i$239215[ebp]
	cmp	ecx, DWORD PTR $T239223[ebp]
	jae	SHORT $LN5@FStaticVec@4
	jmp	SHORT $LN9@FStaticVec@4
$LN5@FStaticVec@4:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T239222[ebp], edx
	je	SHORT $LN1@FStaticVec@4
	mov	eax, DWORD PTR $T239222[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@4:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
__ehhandler$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::~FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z
_TEXT	SEGMENT
tv157 = -64						; size = 4
tv149 = -60						; size = 4
_this$ = -56						; size = 4
$T239236 = -8						; size = 4
$T239235 = -4						; size = 4
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 677  : 		m_bIsResized = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+412], 0

; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN39@push_back@6

; 679  : 			GrowSize(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

$LN39@push_back@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T239236[ebp], ecx
	cmp	DWORD PTR $T239236[ebp], 0
	je	SHORT $LN4@push_back@6
	mov	edx, DWORD PTR $T239236[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T239236[ebp]
	mov	eax, DWORD PTR _element$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR $T239236[ebp]
	mov	DWORD PTR tv149[ebp], edx
	jmp	SHORT $LN5@push_back@6
$LN4@push_back@6:
	mov	DWORD PTR tv149[ebp], 0
$LN5@push_back@6:
	mov	eax, DWORD PTR tv149[ebp]
	mov	DWORD PTR $T239235[ebp], eax

; 681  : 		return m_uiCurrSize++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv157[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR tv157[ebp]

; 682  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$228159 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z PROC		; BaseVector<int,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Destroy@2

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$228159[ebp], 0
	jmp	SHORT $LN3@Destroy@2
$LN2@Destroy@2:
	mov	ecx, DWORD PTR _i$228159[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$228159[ebp], ecx
$LN3@Destroy@2:
	mov	edx, DWORD PTR _i$228159[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy@2

; 223  : 				pVal[i].~T();
; 224  : 			}

	jmp	SHORT $LN2@Destroy@2
$LN5@Destroy@2:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@H$0A@@@IAEXPAHI@Z ENDP		; BaseVector<int,0>::Destroy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T239293 = -80						; size = 28
$T239292 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T239293[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T239292[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T239292[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T239293[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239292[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T239292[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T239292[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T239293[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T239293[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T239292[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvEconomicAIStrategyXMLEntry@@V?$allocator@PAVCvEconomicAIStrategyXMLEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvEconomicAIStrategyXMLEntry *,std::allocator<CvEconomicAIStrategyXMLEntry *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$228198 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z PROC ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@Destroy@3

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$228198[ebp], 0
	jmp	SHORT $LN3@Destroy@3
$LN2@Destroy@3:
	mov	ecx, DWORD PTR _i$228198[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$228198[ebp], ecx
$LN3@Destroy@3:
	mov	edx, DWORD PTR _i$228198[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy@3

; 223  : 				pVal[i].~T();
; 224  : 			}

	jmp	SHORT $LN2@Destroy@3
$LN5@Destroy@3:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@UGoodyHutUnitAssignment@CvEconomicAI@@$0A@@@IAEXPAUGoodyHutUnitAssignment@CvEconomicAI@@I@Z ENDP ; BaseVector<CvEconomicAI::GoodyHutUnitAssignment,0>::Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv186 = -52						; size = 4
_this$ = -48						; size = 4
$T239378 = -44						; size = 4
$T239377 = -40						; size = 4
_i$239370 = -36						; size = 4
$T239356 = -32						; size = 4
$T239349 = -28						; size = 4
_pRet$239346 = -24					; size = 4
$T239339 = -20						; size = 4
$T239338 = -16						; size = 4
_i$228218 = -12						; size = 4
_uiNewSize$228210 = -8					; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN8@GrowSize@7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1
$LN8@GrowSize@7:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jb	SHORT $LN7@GrowSize@7

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 1
	mov	DWORD PTR _uiNewSize$228210[ebp], edx

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiNewSize$228210[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN6@GrowSize@7

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 754  : 				break;

	jmp	SHORT $LN7@GrowSize@7
$LN6@GrowSize@7:

; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _uiNewSize$228210[ebp]
	mov	DWORD PTR [ecx+8], edx

; 759  : 		}

	jmp	SHORT $LN8@GrowSize@7
$LN7@GrowSize@7:

; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T239349[ebp], ecx
	cmp	DWORD PTR $T239349[ebp], 50		; 00000032H
	jbe	SHORT $LN16@GrowSize@7
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	edx, DWORD PTR $T239349[ebp]
	shl	edx, 3
	push	edx
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239346[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T239349[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN17@GrowSize@7
$LN16@GrowSize@7:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pRet$239346[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 50			; 00000032H
$LN17@GrowSize@7:
	mov	ecx, DWORD PTR _pRet$239346[ebp]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 762  : 		if( bPODType ){

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN5@GrowSize@7

; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 764  : 		}else{

	jmp	SHORT $LN4@GrowSize@7
$LN5@GrowSize@7:

; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$228218[ebp], 0
	jmp	SHORT $LN3@GrowSize@7
$LN2@GrowSize@7:
	mov	edx, DWORD PTR _i$228218[ebp]
	add	edx, 1
	mov	DWORD PTR _i$228218[ebp], edx
$LN3@GrowSize@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$228218[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN4@GrowSize@7

; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	edx, DWORD PTR _i$228218[ebp]
	mov	eax, DWORD PTR _pTemp$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T239339[ebp], ecx
	cmp	DWORD PTR $T239339[ebp], 0
	je	SHORT $LN12@GrowSize@7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$228218[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR $T239356[ebp], edx
	mov	eax, DWORD PTR $T239339[ebp]
	mov	ecx, DWORD PTR $T239356[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR $T239339[ebp]
	mov	ecx, DWORD PTR $T239356[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR $T239339[ebp]
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN13@GrowSize@7
$LN12@GrowSize@7:
	mov	DWORD PTR tv186[ebp], 0
$LN13@GrowSize@7:
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR $T239338[ebp], ecx
	jmp	SHORT $LN2@GrowSize@7
$LN4@GrowSize@7:

; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239378[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T239377[ebp], edx
	xor	eax, eax
	je	SHORT $LN24@GrowSize@7
	xor	ecx, ecx
	je	SHORT $LN24@GrowSize@7
	mov	DWORD PTR _i$239370[ebp], 0
	jmp	SHORT $LN29@GrowSize@7
$LN28@GrowSize@7:
	mov	edx, DWORD PTR _i$239370[ebp]
	add	edx, 1
	mov	DWORD PTR _i$239370[ebp], edx
$LN29@GrowSize@7:
	mov	eax, DWORD PTR _i$239370[ebp]
	cmp	eax, DWORD PTR $T239378[ebp]
	jae	SHORT $LN24@GrowSize@7
	jmp	SHORT $LN28@GrowSize@7
$LN24@GrowSize@7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	cmp	DWORD PTR $T239377[ebp], ecx
	je	SHORT $LN25@GrowSize@7
	mov	edx, DWORD PTR $T239377[ebp]
	push	edx
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN25@GrowSize@7:

; 769  : 		m_pData = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax], ecx

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+412], 1

; 772  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
tv158 = -48						; size = 4
_this$ = -44						; size = 4
$T239421 = -40						; size = 4
$T239420 = -36						; size = 4
_i$239413 = -32						; size = 4
$T239399 = -28						; size = 4
$T239392 = -24						; size = 4
_pRet$239389 = -20					; size = 4
$T239382 = -16						; size = 4
$T239381 = -12						; size = 4
_i$228237 = -8						; size = 4
_pTemp$ = -4						; size = 4
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _uiFit$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN6@GrowSizeTo

; 778  : 			return;

	jmp	$LN7@GrowSizeTo
$LN6@GrowSizeTo:

; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _uiFit$[ebp]
	mov	DWORD PTR [edx+8], eax

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T239392[ebp], edx
	cmp	DWORD PTR $T239392[ebp], 50		; 00000032H
	jbe	SHORT $LN13@GrowSizeTo
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T239392[ebp]
	shl	eax, 3
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$239389[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T239392[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN14@GrowSizeTo
$LN13@GrowSizeTo:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$239389[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 50			; 00000032H
$LN14@GrowSizeTo:
	mov	edx, DWORD PTR _pRet$239389[ebp]
	mov	DWORD PTR _pTemp$[ebp], edx

; 782  : 		if( bPODType ){

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@GrowSizeTo

; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 3
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pTemp$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 784  : 		}else{

	jmp	SHORT $LN4@GrowSizeTo
$LN5@GrowSizeTo:

; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)

	mov	DWORD PTR _i$228237[ebp], 0
	jmp	SHORT $LN3@GrowSizeTo
$LN2@GrowSizeTo:
	mov	eax, DWORD PTR _i$228237[ebp]
	add	eax, 1
	mov	DWORD PTR _i$228237[ebp], eax
$LN3@GrowSizeTo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$228237[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN4@GrowSizeTo

; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);

	mov	eax, DWORD PTR _i$228237[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR $T239382[ebp], edx
	cmp	DWORD PTR $T239382[ebp], 0
	je	SHORT $LN9@GrowSizeTo
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$228237[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR $T239399[ebp], eax
	mov	ecx, DWORD PTR $T239382[ebp]
	mov	edx, DWORD PTR $T239399[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T239382[ebp]
	mov	edx, DWORD PTR $T239399[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR $T239382[ebp]
	mov	DWORD PTR tv158[ebp], ecx
	jmp	SHORT $LN10@GrowSizeTo
$LN9@GrowSizeTo:
	mov	DWORD PTR tv158[ebp], 0
$LN10@GrowSizeTo:
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR $T239381[ebp], edx
	jmp	SHORT $LN2@GrowSizeTo
$LN4@GrowSizeTo:

; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T239421[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T239420[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN21@GrowSizeTo
	xor	edx, edx
	je	SHORT $LN21@GrowSizeTo
	mov	DWORD PTR _i$239413[ebp], 0
	jmp	SHORT $LN26@GrowSizeTo
$LN25@GrowSizeTo:
	mov	eax, DWORD PTR _i$239413[ebp]
	add	eax, 1
	mov	DWORD PTR _i$239413[ebp], eax
$LN26@GrowSizeTo:
	mov	ecx, DWORD PTR _i$239413[ebp]
	cmp	ecx, DWORD PTR $T239421[ebp]
	jae	SHORT $LN21@GrowSizeTo
	jmp	SHORT $LN25@GrowSizeTo
$LN21@GrowSizeTo:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T239420[ebp], edx
	je	SHORT $LN22@GrowSizeTo
	mov	eax, DWORD PTR $T239420[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN22@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [ecx], edx

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+412], 1
$LN7@GrowSizeTo:

; 792  : 	};

	mov	esp, ebp
	pop	ebp
	ret	4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$0DC@$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,50,1,0,0>::GrowSizeToFit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$228269 = -4						; size = 4
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 220  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 221  : 		if( !bPODType){

	xor	eax, eax
	je	SHORT $LN5@Destroy@4

; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){

	mov	DWORD PTR _i$228269[ebp], 0
	jmp	SHORT $LN3@Destroy@4
$LN2@Destroy@4:
	mov	ecx, DWORD PTR _i$228269[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$228269[ebp], ecx
$LN3@Destroy@4:
	mov	edx, DWORD PTR _i$228269[ebp]
	cmp	edx, DWORD PTR _uiNumElements$[ebp]
	jae	SHORT $LN5@Destroy@4

; 223  : 				pVal[i].~T();
; 224  : 			}

	jmp	SHORT $LN2@Destroy@4
$LN5@Destroy@4:

; 225  : 		}
; 226  : 	};

	mov	esp, ebp
	pop	ebp
	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvUnit *,50,1>::WeightedElement,1>::Destroy
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
_TEXT	ENDS
;	COMDAT ??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z PROC ; operator>><bool>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@2

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5_N@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@_N@@@Z ENDP ; operator>><bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@3

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@4:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@4

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@4
$LN1@operator@4:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ENDP ; operator<<<bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@5
$LN2@operator@5:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@5:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@5

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _values$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@5
$LN1@operator@5:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
$T239492 = -26						; size = 1
$T239491 = -25						; size = 1
$T239490 = -24						; size = 4
$T239489 = -20						; size = 4
__Off$239485 = -16					; size = 4
__Result$239486 = -12					; size = 4
__Cat$239477 = -4					; size = 1
$T239474 = -3						; size = 1
$T239473 = -2						; size = 1
$T239472 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T239472[ebp], al
	mov	cl, BYTE PTR __Cat$239477[ebp]
	mov	BYTE PTR $T239473[ebp], cl
	mov	dl, BYTE PTR $T239472[ebp]
	mov	BYTE PTR $T239492[ebp], dl
	mov	al, BYTE PTR $T239474[ebp]
	mov	BYTE PTR $T239491[ebp], al
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T239490[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239489[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T239489[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$239485[ebp], eax
	mov	ecx, DWORD PTR __Off$239485[ebp]
	mov	edx, DWORD PTR $T239490[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$239486[ebp], eax
	cmp	DWORD PTR __Off$239485[ebp], 0
	jle	SHORT $LN8@unchecked_
	mov	ecx, DWORD PTR __Off$239485[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR $T239489[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$239485[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR $T239490[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_:
	mov	eax, DWORD PTR __Result$239486[ebp]

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@@stdext@@YAPAPAVCvEconomicAIStrategyXMLEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvEconomicAIStrategyXMLEntry * *,CvEconomicAIStrategyXMLEntry * *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T239499 = -16						; size = 4
$T239495 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T239499[ebp], 0
	lea	eax, DWORD PTR $T239499[ebp]
	push	eax
	lea	ecx, DWORD PTR $T239495[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T239495[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T239495[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVCvEconomicAIStrategyXMLEntry@@@std@@YAPAPAVCvEconomicAIStrategyXMLEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvEconomicAIStrategyXMLEntry *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
PUBLIC	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
_TEXT	SEGMENT
$T239614 = -112						; size = 4
__Next$239617 = -108					; size = 4
$T239531 = -48						; size = 4
$T239527 = -44						; size = 4
__Tempbuf$ = -36					; size = 20
__Count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z PROC ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 3411 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 3412 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T239527[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T239527[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR $T239531[ebp], eax
	mov	DWORD PTR __Tempbuf$[ebp], 0
	mov	DWORD PTR __Tempbuf$[ebp+4], 0
	mov	DWORD PTR __Tempbuf$[ebp+8], 0
	mov	edx, DWORD PTR $T239531[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+12], edx
	lea	eax, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Tempbuf$[ebp+16], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H

; 3415 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Tempbuf$[ebp], 0
	je	SHORT $LN1@Stable_sor
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR __Next$239617[ebp], edx
	jmp	SHORT $LN62@Stable_sor
$LN61@Stable_sor:
	mov	eax, DWORD PTR __Next$239617[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$239617[ebp], eax
$LN62@Stable_sor:
	mov	ecx, DWORD PTR __Next$239617[ebp]
	cmp	ecx, DWORD PTR __Tempbuf$[ebp+8]
	je	SHORT $LN60@Stable_sor
	jmp	SHORT $LN61@Stable_sor
$LN60@Stable_sor:
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	DWORD PTR $T239614[ebp], edx
	mov	eax, DWORD PTR $T239614[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Stable_sor:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0PAH0@Z ENDP ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z
_TEXT	SEGMENT
$T239758 = -128						; size = 4
__Mid$228587 = -12					; size = 8
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
$LN7@Sort:

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Count$[ebp], eax
	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	$LN6@Sort
	cmp	DWORD PTR __Ideal$[ebp], 0
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR __Mid$228587[ebp]
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions

	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Ideal$[ebp], eax
	mov	eax, DWORD PTR __Ideal$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR __Ideal$[ebp]
	mov	DWORD PTR __Ideal$[ebp], eax

; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ecx, DWORD PTR __Mid$228587[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __Mid$228587[ebp+4]
	sar	edx, 3
	cmp	ecx, edx
	jge	SHORT $LN5@Sort

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	mov	eax, DWORD PTR __Ideal$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$228587[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3093 : 			_First = _Mid.second;

	mov	eax, DWORD PTR __Mid$228587[ebp+4]
	mov	DWORD PTR __First$[ebp], eax

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	mov	ecx, DWORD PTR __Ideal$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228587[ebp+4]
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3098 : 			_Last = _Mid.first;

	mov	ecx, DWORD PTR __Mid$228587[ebp]
	mov	DWORD PTR __Last$[ebp], ecx
$LN4@Sort:

; 3099 : 			}
; 3100 : 		}

	jmp	$LN7@Sort
$LN6@Sort:

; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN76@Sort
	push	0
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN76@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T239758[ebp], edx
	jmp	SHORT $LN92@Sort
$LN91@Sort:
	mov	eax, DWORD PTR $T239758[ebp]
	sub	eax, 8
	mov	DWORD PTR $T239758[ebp], eax
$LN92@Sort:
	mov	ecx, DWORD PTR $T239758[ebp]
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	cmp	ecx, 1
	jle	SHORT $LN88@Sort
	mov	edx, DWORD PTR $T239758[ebp]
	sub	edx, DWORD PTR __First$[ebp]
	sar	edx, 3
	cmp	edx, 1
	jle	SHORT $LN96@Sort
	push	0
	mov	eax, DWORD PTR $T239758[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN96@Sort:
	jmp	SHORT $LN91@Sort
$LN88@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	jmp	SHORT $LN8@Sort
$LN3@Sort:
	cmp	DWORD PTR __Count$[ebp], 1
	jle	SHORT $LN8@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN8@Sort:

; 3109 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T239836 = -8						; size = 4
__Next$228645 = -4					; size = 4
??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Next$228645[ebp], edx

; 549  : 				_Next != _Buf._Hiwater; ++_Next)

	jmp	SHORT $LN3@Temp_itera
$LN2@Temp_itera:
	mov	eax, DWORD PTR __Next$228645[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$228645[ebp], eax
$LN3@Temp_itera:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Next$228645[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN1@Temp_itera

; 550  : 				_Destroy(&*_Next);

	jmp	SHORT $LN2@Temp_itera
$LN1@Temp_itera:

; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T239836[ebp], ecx
	mov	edx, DWORD PTR $T239836[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN5@Temp_itera:

; 552  : 			}
; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
PUBLIC	??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
PUBLIC	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
__Count2$228704 = -8					; size = 4
__Mid$228705 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 332				; 0000014cH

; 3382 : 	if (_Count <= _ISORT_MAX)

	cmp	DWORD PTR __Count$[ebp], 32		; 00000020H
	jg	SHORT $LN4@Stable_sor@2

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
	add	esp, 12					; 0000000cH

; 3384 : 	else

	jmp	$LN5@Stable_sor@2
$LN4@Stable_sor@2:

; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$228704[ebp], eax

; 3387 : 		_BidIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$228705[ebp], edx

; 3388 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$228704[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Mid$228705[ebp]
	mov	DWORD PTR __Mid$228705[ebp], eax

; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	DWORD PTR __Count2$228704[ebp], eax
	jg	SHORT $LN2@Stable_sor@2

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count2$228704[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228705[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$228704[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$228705[ebp]
	push	edx
	call	??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN1@Stable_sor@2
$LN2@Stable_sor@2:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$228704[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$228705[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Count2$228704[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$228705[ebp]
	push	ecx
	call	??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 16					; 00000010H
$LN1@Stable_sor@2:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Count2$228704[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count2$228704[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$228705[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 24					; 00000018H
$LN5@Stable_sor@2:

; 3403 : 		}
; 3404 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Stable_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Stable_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z
_TEXT	SEGMENT
$T240325 = -124						; size = 4
__Tmp$240320 = -120					; size = 8
$T240305 = -112						; size = 4
$T240304 = -108						; size = 4
__Tmp$240299 = -104					; size = 8
$T240284 = -96						; size = 4
__Tmp$240279 = -92					; size = 8
$T240264 = -84						; size = 4
$T240263 = -80						; size = 4
__Tmp$240258 = -76					; size = 8
$T240243 = -68						; size = 4
$T240242 = -64						; size = 4
__Tmp$240237 = -60					; size = 8
$T240219 = -52						; size = 4
$T240218 = -48						; size = 4
__Tmp$240213 = -44					; size = 8
$T240192 = -36						; size = 4
__Tmp$240187 = -32					; size = 8
__Plast$ = -20						; size = 4
__Glast$ = -16						; size = 4
__Pfirst$ = -12						; size = 4
__Gfirst$ = -8						; size = 4
__Mid$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Mid$[ebp], edx

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Pfirst$[ebp], eax

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
$LN27@Unguarded_:

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Pfirst$[ebp]
	jae	SHORT $LN25@Unguarded_
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax-4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN25@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax-4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN25@Unguarded_

; 3033 : 		--_Pfirst;

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	jmp	SHORT $LN27@Unguarded_
$LN25@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	edx, DWORD PTR __Plast$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	SHORT $LN24@Unguarded_
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	jne	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx
	jmp	SHORT $LN25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR __Gfirst$[ebp], edx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR __Glast$[ebp], eax
$LN23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	jmp	SHORT $LN21@Unguarded_
$LN20@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN21@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	jae	$LN19@Unguarded_

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@Unguarded_
	jmp	SHORT $LN17@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

$LN44@Unguarded_:
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN16@Unguarded_

; 3048 : 				break;

	jmp	SHORT $LN19@Unguarded_

; 3049 : 			else

	jmp	SHORT $LN17@Unguarded_
$LN16@Unguarded_:

; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	ecx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T240192[ebp], ecx
	mov	edx, DWORD PTR __Plast$[ebp]
	add	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR $T240192[ebp]
	cmp	eax, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN17@Unguarded_
	mov	ecx, DWORD PTR $T240192[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$240187[ebp], edx
	mov	eax, DWORD PTR $T240192[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$240187[ebp+4], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T240192[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	ecx, DWORD PTR __Tmp$240187[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$240187[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN17@Unguarded_:
	jmp	$LN20@Unguarded_
$LN19@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	jmp	SHORT $LN14@Unguarded_
$LN13@Unguarded_:
	mov	eax, DWORD PTR __Glast$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Glast$[ebp], eax
$LN14@Unguarded_:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	jae	$LN12@Unguarded_

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	ecx, DWORD PTR [edx-4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN55@Unguarded_
	jmp	SHORT $LN10@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

$LN55@Unguarded_:
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN9@Unguarded_

; 3055 : 				break;

	jmp	SHORT $LN12@Unguarded_

; 3056 : 			else

	jmp	SHORT $LN10@Unguarded_
$LN9@Unguarded_:

; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	mov	eax, DWORD PTR __Pfirst$[ebp]
	sub	eax, 8
	mov	DWORD PTR __Pfirst$[ebp], eax
	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T240219[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T240218[ebp], edx
	mov	eax, DWORD PTR $T240218[ebp]
	cmp	eax, DWORD PTR $T240219[ebp]
	je	SHORT $LN10@Unguarded_
	mov	ecx, DWORD PTR $T240218[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$240213[ebp], edx
	mov	eax, DWORD PTR $T240218[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$240213[ebp+4], ecx
	mov	edx, DWORD PTR $T240219[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T240218[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T240219[ebp]
	mov	ecx, DWORD PTR __Tmp$240213[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$240213[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN10@Unguarded_:
	jmp	$LN13@Unguarded_
$LN12@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	SHORT $LN7@Unguarded_
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	jne	SHORT $LN7@Unguarded_

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN28@Unguarded_
$LN7@Unguarded_:

; 3060 : 
; 3061 : 		if (_Glast == _First)

	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	jne	$LN6@Unguarded_

; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	mov	ecx, DWORD PTR __Plast$[ebp]
	cmp	ecx, DWORD PTR __Gfirst$[ebp]
	je	SHORT $LN5@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T240243[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T240242[ebp], eax
	mov	ecx, DWORD PTR $T240242[ebp]
	cmp	ecx, DWORD PTR $T240243[ebp]
	je	SHORT $LN5@Unguarded_
	mov	edx, DWORD PTR $T240242[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$240237[ebp], eax
	mov	ecx, DWORD PTR $T240242[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$240237[ebp+4], edx
	mov	eax, DWORD PTR $T240243[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T240242[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T240243[ebp]
	mov	edx, DWORD PTR __Tmp$240237[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$240237[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN5@Unguarded_:

; 3065 : 			++_Plast;

	mov	ecx, DWORD PTR __Plast$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Plast$[ebp], ecx

; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T240264[ebp], edx
	mov	eax, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T240263[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pfirst$[ebp], ecx
	mov	edx, DWORD PTR __Gfirst$[ebp]
	add	edx, 8
	mov	DWORD PTR __Gfirst$[ebp], edx
	mov	eax, DWORD PTR $T240263[ebp]
	cmp	eax, DWORD PTR $T240264[ebp]
	je	SHORT $LN73@Unguarded_
	mov	ecx, DWORD PTR $T240263[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$240258[ebp], edx
	mov	eax, DWORD PTR $T240263[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$240258[ebp+4], ecx
	mov	edx, DWORD PTR $T240264[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T240263[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T240264[ebp]
	mov	ecx, DWORD PTR __Tmp$240258[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$240258[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN73@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)

	jmp	$LN4@Unguarded_
$LN6@Unguarded_:
	mov	eax, DWORD PTR __Gfirst$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	$LN3@Unguarded_

; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	mov	ecx, DWORD PTR __Glast$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Glast$[ebp], ecx
	mov	edx, DWORD PTR __Pfirst$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Pfirst$[ebp], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	cmp	eax, DWORD PTR __Pfirst$[ebp]
	je	SHORT $LN2@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T240284[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	cmp	edx, DWORD PTR $T240284[ebp]
	je	SHORT $LN2@Unguarded_
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$240279[ebp], ecx
	mov	edx, DWORD PTR __Glast$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$240279[ebp+4], eax
	mov	ecx, DWORD PTR $T240284[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T240284[ebp]
	mov	eax, DWORD PTR __Tmp$240279[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$240279[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN2@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	mov	edx, DWORD PTR __Plast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Plast$[ebp], edx
	mov	eax, DWORD PTR __Plast$[ebp]
	mov	DWORD PTR $T240305[ebp], eax
	mov	ecx, DWORD PTR __Pfirst$[ebp]
	mov	DWORD PTR $T240304[ebp], ecx
	mov	edx, DWORD PTR $T240304[ebp]
	cmp	edx, DWORD PTR $T240305[ebp]
	je	SHORT $LN87@Unguarded_
	mov	eax, DWORD PTR $T240304[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$240299[ebp], ecx
	mov	edx, DWORD PTR $T240304[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$240299[ebp+4], eax
	mov	ecx, DWORD PTR $T240305[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR $T240304[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T240305[ebp]
	mov	eax, DWORD PTR __Tmp$240299[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$240299[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN87@Unguarded_:

; 3073 : 			}
; 3074 : 		else

	jmp	SHORT $LN4@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	edx, DWORD PTR __Glast$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Glast$[ebp], edx
	mov	eax, DWORD PTR __Gfirst$[ebp]
	mov	DWORD PTR $T240325[ebp], eax
	mov	ecx, DWORD PTR $T240325[ebp]
	cmp	ecx, DWORD PTR __Glast$[ebp]
	je	SHORT $LN94@Unguarded_
	mov	edx, DWORD PTR $T240325[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$240320[ebp], eax
	mov	ecx, DWORD PTR $T240325[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$240320[ebp+4], edx
	mov	eax, DWORD PTR __Glast$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR $T240325[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Glast$[ebp]
	mov	edx, DWORD PTR __Tmp$240320[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$240320[ebp+4]
	mov	DWORD PTR [ecx+4], eax
$LN94@Unguarded_:
	mov	ecx, DWORD PTR __Gfirst$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Gfirst$[ebp], ecx
$LN4@Unguarded_:

; 3076 : 		}

	jmp	$LN23@Unguarded_
$LN28@Unguarded_:

; 3077 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z ; std::get_temporary_buffer<CvPurchaseRequest>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
__Pair$228873 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN1@Maxlen
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $LN1@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR __Pair$228873[ebp]
	push	ecx
	call	??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z ; std::get_temporary_buffer<CvPurchaseRequest>
	add	esp, 8

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228873[ebp]
	mov	DWORD PTR [eax], ecx

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228873[ebp]
	mov	DWORD PTR [eax+4], ecx

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228873[ebp]
	mov	DWORD PTR [eax+8], ecx

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Pair$228873[ebp+4]
	mov	DWORD PTR [eax+12], ecx
$LN1@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax+12]

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
PUBLIC	??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
tv139 = -224						; size = 4
$T240603 = -109						; size = 1
$T240441 = -108						; size = 4
$T240437 = -104						; size = 4
$T240400 = -80						; size = 4
$T240373 = -52						; size = 4
$T240339 = -20						; size = 4
__Chunk$228943 = -16					; size = 4
__Midend$228941 = -12					; size = 4
__Nleft$228937 = -8					; size = 4
__Mid$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 3355 : 	{	// sort using temp buffer for merges, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$[ebp], eax

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Nleft$228937[ebp], ecx
	jmp	SHORT $LN6@Buffered_m
$LN5@Buffered_m:
	mov	edx, DWORD PTR __Nleft$228937[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Nleft$228937[ebp], edx
$LN6@Buffered_m:
	cmp	DWORD PTR __Nleft$228937[ebp], 32	; 00000020H
	jl	SHORT $LN36@Buffered_m

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Midend$228941[ebp], eax

; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	mov	ecx, 32					; 00000020H
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Midend$228941[ebp]
	mov	DWORD PTR __Midend$228941[ebp], ecx

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	mov	edx, DWORD PTR __Midend$228941[ebp]
	mov	DWORD PTR $T240373[ebp], edx
	push	0
	mov	eax, DWORD PTR $T240373[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
	add	esp, 12					; 0000000cH

; 3363 : 		_Mid = _Midend;

	mov	edx, DWORD PTR __Midend$228941[ebp]
	mov	DWORD PTR __Mid$[ebp], edx

; 3364 : 		}

	jmp	SHORT $LN5@Buffered_m

; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

$LN36@Buffered_m:
	push	0
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
	add	esp, 12					; 0000000cH

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	DWORD PTR __Chunk$228943[ebp], 32	; 00000020H
	jmp	SHORT $LN3@Buffered_m
$LN2@Buffered_m:
	mov	edx, DWORD PTR __Chunk$228943[ebp]
	shl	edx, 1
	mov	DWORD PTR __Chunk$228943[ebp], edx
$LN3@Buffered_m:
	mov	eax, DWORD PTR __Chunk$228943[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jge	$LN7@Buffered_m

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$228943[ebp]
	push	edx
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T240339[ebp], esp
	mov	DWORD PTR $T240400[ebp], edx
	mov	eax, DWORD PTR $T240400[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T240400[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T240400[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T240400[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T240400[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T240400[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
	add	esp, 36					; 00000024H

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	ecx, DWORD PTR __Chunk$228943[ebp]
	shl	ecx, 1
	mov	DWORD PTR __Chunk$228943[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T240437[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T240441[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T240603[ebp], dl
	movzx	eax, BYTE PTR $T240603[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Chunk$228943[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240437[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240441[ebp]
	push	edx
	call	??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
	add	esp, 24					; 00000018H

; 3373 : 		}

	jmp	$LN2@Buffered_m
$LN7@Buffered_m:

; 3374 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge_sort@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@0HAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
PUBLIC	??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
PUBLIC	??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
PUBLIC	??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
PUBLIC	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
; Function compile flags: /Odtp
;	COMDAT ??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
tv221 = -300						; size = 4
tv220 = -296						; size = 4
tv217 = -292						; size = 4
tv216 = -288						; size = 4
$T240870 = -216						; size = 4
$T240852 = -208						; size = 4
$T240851 = -204						; size = 4
$T240786 = -172						; size = 4
$T240768 = -164						; size = 4
$T240767 = -160						; size = 4
$T240741 = -153						; size = 1
$T240736 = -152						; size = 4
$T240732 = -148						; size = 4
$T240717 = -144						; size = 4
__Next$240725 = -140					; size = 4
$T240709 = -136						; size = 4
$T240696 = -124						; size = 4
$T240695 = -120						; size = 4
$T240694 = -116						; size = 4
$T240689 = -110						; size = 1
$T240688 = -109						; size = 1
$T240679 = -108						; size = 4
$T240675 = -104						; size = 4
$T240660 = -100						; size = 4
__Next$240668 = -96					; size = 4
$T240652 = -92						; size = 4
__Tmp$240638 = -80					; size = 12
$T240620 = -68						; size = 20
$T240619 = -48						; size = 4
$T240618 = -44						; size = 20
$T240617 = -24						; size = 4
__Firstn$229013 = -20					; size = 4
__Count2n$229016 = -16					; size = 4
__Midn$229033 = -12					; size = 4
__Lastn$229014 = -8					; size = 4
__Count1n$229015 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[ebp]
	add	eax, DWORD PTR __Count2$[ebp]
	cmp	eax, 2
	jne	SHORT $LN9@Buffered_m@2

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+8]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN8@Buffered_m@2

; 2763 : 			std::iter_swap(_First, _Mid);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN8@Buffered_m@2
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$240638[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$240638[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$240638[ebp+8], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __Tmp$240638[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$240638[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Tmp$240638[ebp+8]
	mov	DWORD PTR [eax+8], ecx
$LN8@Buffered_m@2:

; 2764 : 		}

	jmp	$LN10@Buffered_m@2
$LN9@Buffered_m@2:

; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	edx, DWORD PTR __Count1$[ebp]
	cmp	edx, DWORD PTR __Count2$[ebp]
	jg	$LN6@Buffered_m@2
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN6@Buffered_m@2

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T240617[ebp], esp
	mov	DWORD PTR $T240652[ebp], edx
	mov	eax, DWORD PTR $T240652[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T240652[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T240652[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T240652[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T240652[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T240652[ebp]
	mov	DWORD PTR tv216[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T240618[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv217[ebp], eax
	cmp	DWORD PTR $T240618[ebp], 0
	je	SHORT $LN36@Buffered_m@2
	mov	edx, DWORD PTR $T240618[ebp]
	mov	DWORD PTR __Next$240668[ebp], edx
	jmp	SHORT $LN34@Buffered_m@2
$LN33@Buffered_m@2:
	mov	eax, DWORD PTR __Next$240668[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$240668[ebp], eax
$LN34@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$240668[ebp]
	cmp	ecx, DWORD PTR $T240618[ebp+8]
	je	SHORT $LN32@Buffered_m@2
	jmp	SHORT $LN33@Buffered_m@2
$LN32@Buffered_m@2:
	mov	edx, DWORD PTR $T240618[ebp]
	mov	DWORD PTR $T240660[ebp], edx
	mov	eax, DWORD PTR $T240660[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN36@Buffered_m@2:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240675[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240679[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240696[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T240695[ebp], edx
	mov	eax, DWORD PTR $T240679[ebp]
	mov	DWORD PTR $T240694[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240688[ebp], cl
	movzx	edx, BYTE PTR $T240688[ebp]
	push	edx
	movzx	eax, BYTE PTR $T240689[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240696[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240695[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240675[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240694[ebp]
	push	edx
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	jmp	$LN10@Buffered_m@2
$LN6@Buffered_m@2:
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN4@Buffered_m@2

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T240619[ebp], esp
	mov	DWORD PTR $T240709[ebp], edx
	mov	eax, DWORD PTR $T240709[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T240709[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T240709[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T240709[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T240709[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T240709[ebp]
	mov	DWORD PTR tv220[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T240620[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv221[ebp], eax
	cmp	DWORD PTR $T240620[ebp], 0
	je	SHORT $LN63@Buffered_m@2
	mov	edx, DWORD PTR $T240620[ebp]
	mov	DWORD PTR __Next$240725[ebp], edx
	jmp	SHORT $LN61@Buffered_m@2
$LN60@Buffered_m@2:
	mov	eax, DWORD PTR __Next$240725[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$240725[ebp], eax
$LN61@Buffered_m@2:
	mov	ecx, DWORD PTR __Next$240725[ebp]
	cmp	ecx, DWORD PTR $T240620[ebp+8]
	je	SHORT $LN59@Buffered_m@2
	jmp	SHORT $LN60@Buffered_m@2
$LN59@Buffered_m@2:
	mov	edx, DWORD PTR $T240620[ebp]
	mov	DWORD PTR $T240717[ebp], edx
	mov	eax, DWORD PTR $T240717[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN63@Buffered_m@2:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240732[ebp], eax
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T240736[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T240741[ebp], cl
	movzx	edx, BYTE PTR $T240741[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240732[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240736[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
	add	esp, 24					; 00000018H

; 2775 : 		}
; 2776 : 	else

	jmp	$LN10@Buffered_m@2
$LN4@Buffered_m@2:

; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	edx, DWORD PTR __Count2$[ebp]
	cmp	edx, DWORD PTR __Count1$[ebp]
	jge	$LN2@Buffered_m@2

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;

	mov	eax, DWORD PTR __Count1$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count1n$229015[ebp], eax
	mov	DWORD PTR __Count2n$229016[ebp], 0

; 2784 : 			_Firstn = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Firstn$229013[ebp], eax

; 2785 : 			std::advance(_Firstn, _Count1n);

	mov	ecx, DWORD PTR __Count1n$229015[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Firstn$229013[ebp]
	mov	DWORD PTR __Firstn$229013[ebp], ecx

; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	mov	edx, DWORD PTR __Firstn$229013[ebp]
	mov	DWORD PTR $T240768[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T240767[ebp], eax
	push	0
	mov	ecx, DWORD PTR $T240768[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T240767[ebp]
	push	eax
	call	??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T240767[ebp], eax
	mov	ecx, DWORD PTR $T240767[ebp]
	mov	DWORD PTR __Lastn$229014[ebp], ecx

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T240786[ebp], edx
	mov	eax, DWORD PTR __Lastn$229014[ebp]
	sub	eax, DWORD PTR $T240786[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count2n$229016[ebp]
	mov	DWORD PTR __Count2n$229016[ebp], eax

; 2788 : 			}
; 2789 : 		else

	jmp	$LN1@Buffered_m@2
$LN2@Buffered_m@2:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	DWORD PTR __Count1n$229015[ebp], 0
	mov	eax, DWORD PTR __Count2$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2n$229016[ebp], eax

; 2792 : 			_Lastn = _Mid;

	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR __Lastn$229014[ebp], edx

; 2793 : 			std::advance(_Lastn, _Count2n);

	mov	eax, DWORD PTR __Count2n$229016[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Lastn$229014[ebp]
	mov	DWORD PTR __Lastn$229014[ebp], eax

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	ecx, DWORD PTR __Lastn$229014[ebp]
	mov	DWORD PTR $T240852[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240851[ebp], edx
	push	0
	mov	eax, DWORD PTR $T240852[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240851[ebp]
	push	edx
	call	??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T240851[ebp], eax
	mov	eax, DWORD PTR $T240851[ebp]
	mov	DWORD PTR __Firstn$229013[ebp], eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T240870[ebp], ecx
	mov	eax, DWORD PTR __Firstn$229013[ebp]
	sub	eax, DWORD PTR $T240870[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count1n$229015[ebp]
	mov	DWORD PTR __Count1n$229015[ebp], eax
$LN1@Buffered_m@2:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$229016[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$229015[ebp]
	push	ecx
	mov	edx, DWORD PTR __Lastn$229014[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Firstn$229013[ebp]
	push	ecx
	call	??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 24					; 00000018H
	mov	DWORD PTR __Midn$229033[ebp], eax

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2n$229016[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1n$229015[ebp]
	push	ecx
	mov	edx, DWORD PTR __Midn$229033[ebp]
	push	edx
	mov	eax, DWORD PTR __Firstn$229013[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 24					; 00000018H

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count2$[ebp]
	sub	eax, DWORD PTR __Count2n$229016[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count1$[ebp]
	sub	ecx, DWORD PTR __Count1n$229015[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Lastn$229014[ebp]
	push	eax
	mov	ecx, DWORD PTR __Midn$229033[ebp]
	push	ecx
	call	??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 24					; 00000018H
$LN10@Buffered_m@2:

; 2804 : 		}
; 2805 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_merge@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Buffered_merge<CvPurchaseRequest *,int,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Odtp
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
__Step$229048 = -4					; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 3009 : 	{	// sort median element to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 3010 : 	if (40 < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	add	eax, 1
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR __Step$229048[ebp], eax

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	ecx, DWORD PTR __Step$229048[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Step$229048[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR __Step$229048[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$229048[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Mid$[ebp]
	sub	ecx, eax
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Step$229048[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Step$229048[ebp]
	shl	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, edx
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	ecx, DWORD PTR __Step$229048[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Last$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Step$229048[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3017 : 		}
; 3018 : 	else

	jmp	SHORT $LN3@Median
$LN2@Median:

; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
$LN3@Median:

; 3020 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Odtp
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z
_TEXT	SEGMENT
$T241231 = -20						; size = 4
$T241230 = -16						; size = 4
__Hole$229066 = -8					; size = 4
__Bottom$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	DWORD PTR __Bottom$[ebp], eax

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, DWORD PTR __Bottom$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Hole$229066[ebp], eax
$LN2@Make_heap:
	cmp	DWORD PTR __Hole$229066[ebp], 0
	jle	SHORT $LN3@Make_heap

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;

	mov	ecx, DWORD PTR __Hole$229066[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$229066[ebp], ecx

; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	edx, DWORD PTR __Hole$229066[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR $T241231[ebp], ecx
	sub	esp, 8
	mov	DWORD PTR $T241230[ebp], esp
	mov	edx, DWORD PTR $T241230[ebp]
	mov	eax, DWORD PTR $T241231[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T241230[ebp]
	mov	eax, DWORD PTR $T241231[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __Bottom$[ebp]
	push	edx
	mov	eax, DWORD PTR __Hole$229066[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2172 : 		}

	jmp	SHORT $LN2@Make_heap
$LN3@Make_heap:

; 2173 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
$T241301 = -52						; size = 4
$T241300 = -48						; size = 4
$T241284 = -42						; size = 1
$T241283 = -41						; size = 1
$T241282 = -40						; size = 4
$T241281 = -36						; size = 4
$T241280 = -32						; size = 4
__Cat$241291 = -24					; size = 1
$T241289 = -23						; size = 1
$T241288 = -22						; size = 1
$T241287 = -21						; size = 1
__First1$229107 = -20					; size = 4
__Val$229097 = -16					; size = 8
__Next1$229096 = -8					; size = 4
__Next$229092 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$229092[ebp], ecx
$LN7@Insertion_:
	mov	edx, DWORD PTR __Next$229092[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$229092[ebp], edx
	mov	eax, DWORD PTR __Next$229092[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$229092[ebp]
	mov	DWORD PTR __Next1$229096[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$229092[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$229097[ebp], eax
	mov	ecx, DWORD PTR __Next$229092[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Val$229097[ebp+4], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$229097[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$229096[ebp]
	add	ecx, 8
	mov	DWORD PTR __Next1$229096[ebp], ecx
	mov	edx, DWORD PTR __Next1$229096[ebp]
	mov	DWORD PTR $T241301[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T241300[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241287[ebp], cl
	mov	dl, BYTE PTR __Cat$241291[ebp]
	mov	BYTE PTR $T241288[ebp], dl
	mov	al, BYTE PTR $T241287[ebp]
	mov	BYTE PTR $T241284[ebp], al
	mov	cl, BYTE PTR $T241289[ebp]
	mov	BYTE PTR $T241283[ebp], cl
	mov	edx, DWORD PTR $T241301[ebp]
	mov	DWORD PTR $T241282[ebp], edx
	mov	eax, DWORD PTR __Next$229092[ebp]
	mov	DWORD PTR $T241281[ebp], eax
	mov	ecx, DWORD PTR $T241300[ebp]
	mov	DWORD PTR $T241280[ebp], ecx
$LN22@Insertion_:
	mov	edx, DWORD PTR $T241280[ebp]
	cmp	edx, DWORD PTR $T241281[ebp]
	je	SHORT $LN15@Insertion_
	mov	eax, DWORD PTR $T241281[ebp]
	sub	eax, 8
	mov	DWORD PTR $T241281[ebp], eax
	mov	ecx, DWORD PTR $T241282[ebp]
	sub	ecx, 8
	mov	DWORD PTR $T241282[ebp], ecx
	mov	edx, DWORD PTR $T241281[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T241282[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN22@Insertion_
$LN15@Insertion_:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$229097[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$229097[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	eax, DWORD PTR __Next1$229096[ebp]
	mov	DWORD PTR __First1$229107[ebp], eax

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_
$LN2@Insertion_:
	mov	ecx, DWORD PTR __First1$229107[ebp]
	mov	DWORD PTR __Next1$229096[ebp], ecx
$LN3@Insertion_:
	mov	edx, DWORD PTR __First1$229107[ebp]
	sub	edx, 8
	mov	DWORD PTR __First1$229107[ebp], edx
	mov	eax, DWORD PTR __First1$229107[ebp]
	mov	ecx, DWORD PTR __Val$229097[ebp+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN1@Insertion_

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ecx, DWORD PTR __First1$229107[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Next1$229096[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	jmp	SHORT $LN2@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	edx, DWORD PTR __Next1$229096[ebp]
	mov	eax, DWORD PTR __Val$229097[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Val$229097[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@Insertion_:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_
$LN9@Insertion_:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z
_TEXT	SEGMENT
$T241311 = -20						; size = 4
$T241307 = -16						; size = 12
__Pbuf$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z PROC ; std::get_temporary_buffer<CvPurchaseRequest>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN6@get_tempor
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN6@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T241311[ebp], 0
	lea	eax, DWORD PTR $T241311[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241307[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T241307[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T241307[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN6@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	mov	DWORD PTR __Pbuf$[ebp], 0
	jmp	SHORT $LN4@get_tempor
$LN3@get_tempor:
	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
$LN4@get_tempor:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN2@get_tempor

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	add	esp, 8
	mov	DWORD PTR __Pbuf$[ebp], eax
	cmp	DWORD PTR __Pbuf$[ebp], 0
	je	SHORT $LN1@get_tempor

; 30   : 			break;

	jmp	SHORT $LN2@get_tempor
$LN1@get_tempor:

; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	jmp	SHORT $LN3@get_tempor
$LN2@get_tempor:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Pbuf$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN9@get_tempor:

; 33   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$get_temporary_buffer@VCvPurchaseRequest@@@std@@YA?AU?$pair@PAVCvPurchaseRequest@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvPurchaseRequest>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z
_TEXT	SEGMENT
$T241358 = -56						; size = 4
$T241357 = -52						; size = 4
$T241341 = -46						; size = 1
$T241340 = -45						; size = 1
$T241339 = -44						; size = 4
$T241338 = -40						; size = 4
$T241337 = -36						; size = 4
__Cat$241348 = -28					; size = 1
$T241346 = -27						; size = 1
$T241345 = -26						; size = 1
$T241344 = -25						; size = 1
__First1$229160 = -24					; size = 4
__Val$229150 = -20					; size = 12
__Next1$229149 = -8					; size = 4
__Next$229145 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z PROC ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$229145[ebp], ecx
$LN7@Insertion_@2:
	mov	edx, DWORD PTR __Next$229145[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$229145[ebp], edx
	mov	eax, DWORD PTR __Next$229145[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	$LN9@Insertion_@2

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;

	mov	ecx, DWORD PTR __Next$229145[ebp]
	mov	DWORD PTR __Next1$229149[ebp], ecx

; 2972 : 			_Ty _Val = *_Next;

	mov	edx, DWORD PTR __Next$229145[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Val$229150[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Val$229150[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Val$229150[ebp+8], edx

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$229150[ebp+8]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+8]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	$LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	ecx, DWORD PTR __Next1$229149[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next1$229149[ebp], ecx
	mov	edx, DWORD PTR __Next1$229149[ebp]
	mov	DWORD PTR $T241358[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T241357[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241344[ebp], cl
	mov	dl, BYTE PTR __Cat$241348[ebp]
	mov	BYTE PTR $T241345[ebp], dl
	mov	al, BYTE PTR $T241344[ebp]
	mov	BYTE PTR $T241341[ebp], al
	mov	cl, BYTE PTR $T241346[ebp]
	mov	BYTE PTR $T241340[ebp], cl
	mov	edx, DWORD PTR $T241358[ebp]
	mov	DWORD PTR $T241339[ebp], edx
	mov	eax, DWORD PTR __Next$229145[ebp]
	mov	DWORD PTR $T241338[ebp], eax
	mov	ecx, DWORD PTR $T241357[ebp]
	mov	DWORD PTR $T241337[ebp], ecx
$LN20@Insertion_@2:
	mov	edx, DWORD PTR $T241337[ebp]
	cmp	edx, DWORD PTR $T241338[ebp]
	je	SHORT $LN13@Insertion_@2
	mov	eax, DWORD PTR $T241338[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T241338[ebp], eax
	mov	ecx, DWORD PTR $T241339[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T241339[ebp], ecx
	mov	edx, DWORD PTR $T241338[ebp]
	mov	eax, DWORD PTR $T241339[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN20@Insertion_@2
$LN13@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$229150[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Val$229150[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val$229150[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;

	mov	edx, DWORD PTR __Next1$229149[ebp]
	mov	DWORD PTR __First1$229160[ebp], edx

; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	jmp	SHORT $LN3@Insertion_@2
$LN2@Insertion_@2:
	mov	eax, DWORD PTR __First1$229160[ebp]
	mov	DWORD PTR __Next1$229149[ebp], eax
$LN3@Insertion_@2:
	mov	ecx, DWORD PTR __First1$229160[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __First1$229160[ebp], ecx
	mov	edx, DWORD PTR __First1$229160[ebp]
	mov	eax, DWORD PTR __Val$229150[ebp+8]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+8]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN1@Insertion_@2

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	eax, DWORD PTR __First1$229160[ebp]
	mov	ecx, DWORD PTR __Next1$229149[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN2@Insertion_@2
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, DWORD PTR __Next1$229149[ebp]
	mov	edx, DWORD PTR __Val$229150[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Val$229150[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Val$229150[ebp+8]
	mov	DWORD PTR [ecx+8], edx
$LN4@Insertion_@2:

; 2986 : 				}
; 2987 : 			}

	jmp	$LN7@Insertion_@2
$LN9@Insertion_@2:

; 2988 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAVCvPurchaseRequest@@V1@@std@@YAXPAVCvPurchaseRequest@@00@Z ENDP ; std::_Insertion_sort1<CvPurchaseRequest *,CvPurchaseRequest>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z$0
__ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z
_TEXT	SEGMENT
tv92 = -164						; size = 4
$T241518 = -160						; size = 4
__Next$241521 = -156					; size = 4
$T241376 = -24						; size = 4
$T241365 = -20						; size = 4
$T241364 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>, COMDAT

; 5252 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T241364[ebp], al
	movzx	ecx, BYTE PTR $T241364[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Chunk$[ebp]
	push	eax
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T241365[ebp], esp
	mov	DWORD PTR $T241376[ebp], ecx
	mov	edx, DWORD PTR $T241376[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T241376[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T241376[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T241376[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T241376[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T241376[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
	add	esp, 40					; 00000028H

; 5254 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN1@Unchecked_
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$241521[ebp], edx
	jmp	SHORT $LN77@Unchecked_
$LN76@Unchecked_:
	mov	eax, DWORD PTR __Next$241521[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$241521[ebp], eax
$LN77@Unchecked_:
	mov	ecx, DWORD PTR __Next$241521[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN75@Unchecked_
	jmp	SHORT $LN76@Unchecked_
$LN75@Unchecked_:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T241518[ebp], edx
	mov	eax, DWORD PTR $T241518[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Unchecked_:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-156]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked_chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@stdext@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
PUBLIC	??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z$0
__ehfuncinfo$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z
_TEXT	SEGMENT
tv135 = -48						; size = 4
tv134 = -44						; size = 4
$T241571 = -40						; size = 4
__Next$241574 = -36					; size = 4
$T241563 = -32						; size = 4
__Cat$241549 = -25					; size = 1
$T241545 = -24						; size = 4
$T241541 = -20						; size = 4
$T241540 = -15						; size = 1
$T241539 = -14						; size = 1
$T241538 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z PROC ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T241545[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T241538[ebp], al
	mov	cl, BYTE PTR __Cat$241549[ebp]
	mov	BYTE PTR $T241539[ebp], cl
	movzx	edx, BYTE PTR $T241538[ebp]
	push	edx
	movzx	eax, BYTE PTR $T241539[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T241540[ebp]
	push	ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T241541[ebp], esp
	mov	DWORD PTR $T241563[ebp], edx
	mov	eax, DWORD PTR $T241563[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T241563[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T241563[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T241563[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T241563[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T241563[ebp]
	mov	DWORD PTR tv134[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR $T241545[ebp]
	or	ecx, 1
	mov	DWORD PTR $T241545[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN19@unchecked_@2
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$241574[ebp], edx
	jmp	SHORT $LN17@unchecked_@2
$LN16@unchecked_@2:
	mov	eax, DWORD PTR __Next$241574[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$241574[ebp], eax
$LN17@unchecked_@2:
	mov	ecx, DWORD PTR __Next$241574[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN15@unchecked_@2
	jmp	SHORT $LN16@unchecked_@2
$LN15@unchecked_@2:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T241571[ebp], edx
	mov	eax, DWORD PTR $T241571[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@unchecked_@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3607 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ENDP ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
PUBLIC	??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z
_TEXT	SEGMENT
tv178 = -260						; size = 4
tv177 = -256						; size = 4
tv174 = -252						; size = 4
tv173 = -248						; size = 4
$T241871 = -240						; size = 4
$T241857 = -233						; size = 1
$T241856 = -232						; size = 4
$T241859 = -225						; size = 1
$T241836 = -224						; size = 4
$T241835 = -220						; size = 4
$T241818 = -214						; size = 1
$T241817 = -213						; size = 1
$T241816 = -212						; size = 4
$T241815 = -208						; size = 4
__Cat$241825 = -200					; size = 1
$T241822 = -199						; size = 1
$T241821 = -198						; size = 1
$T241820 = -197						; size = 1
$T241796 = -196						; size = 4
$T241792 = -192						; size = 4
$T241788 = -188						; size = 4
$T241787 = -184						; size = 4
$T241771 = -178						; size = 1
$T241770 = -177						; size = 1
$T241769 = -176						; size = 4
$T241768 = -172						; size = 4
$T241767 = -168						; size = 4
__Cat$241778 = -160					; size = 1
$T241775 = -159						; size = 1
$T241774 = -158						; size = 1
$T241773 = -157						; size = 1
$T241738 = -156						; size = 4
__Next$241746 = -152					; size = 4
$T241730 = -148						; size = 4
$T241717 = -136						; size = 4
$T241716 = -132						; size = 4
$T241700 = -126						; size = 1
$T241699 = -125						; size = 1
$T241698 = -124						; size = 4
$T241697 = -120						; size = 4
$T241696 = -116						; size = 4
__Cat$241707 = -108					; size = 1
$T241704 = -107						; size = 1
$T241703 = -106						; size = 1
$T241702 = -105						; size = 1
$T241678 = -104						; size = 4
$T241674 = -100						; size = 4
$T241670 = -96						; size = 4
$T241669 = -92						; size = 4
$T241652 = -86						; size = 1
$T241651 = -85						; size = 1
$T241650 = -84						; size = 4
$T241649 = -80						; size = 4
__Cat$241659 = -72					; size = 1
$T241657 = -71						; size = 1
$T241656 = -70						; size = 1
$T241655 = -69						; size = 1
$T241619 = -68						; size = 4
__Next$241622 = -64					; size = 4
$T241611 = -60						; size = 4
$T241594 = -48						; size = 20
$T241593 = -28						; size = 4
$T241592 = -24						; size = 20
$T241591 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z PROC ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	eax, DWORD PTR __Count1$[ebp]
	cmp	eax, DWORD PTR __Count2$[ebp]
	jg	$LN4@Buffered_r
	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	DWORD PTR __Count1$[ebp], eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T241591[ebp], esp
	mov	DWORD PTR $T241611[ebp], eax
	mov	ecx, DWORD PTR $T241611[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T241611[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T241611[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T241611[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T241611[ebp]
	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR $T241611[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T241592[ebp]
	push	edx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv174[ebp], eax
	cmp	DWORD PTR $T241592[ebp], 0
	je	SHORT $LN24@Buffered_r
	mov	eax, DWORD PTR $T241592[ebp]
	mov	DWORD PTR __Next$241622[ebp], eax
	jmp	SHORT $LN22@Buffered_r
$LN21@Buffered_r:
	mov	ecx, DWORD PTR __Next$241622[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next$241622[ebp], ecx
$LN22@Buffered_r:
	mov	edx, DWORD PTR __Next$241622[ebp]
	cmp	edx, DWORD PTR $T241592[ebp+8]
	je	SHORT $LN20@Buffered_r
	jmp	SHORT $LN21@Buffered_r
$LN20@Buffered_r:
	mov	eax, DWORD PTR $T241592[ebp]
	mov	DWORD PTR $T241619[ebp], eax
	mov	ecx, DWORD PTR $T241619[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T241670[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T241669[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241655[ebp], cl
	mov	dl, BYTE PTR __Cat$241659[ebp]
	mov	BYTE PTR $T241656[ebp], dl
	mov	al, BYTE PTR $T241655[ebp]
	mov	BYTE PTR $T241652[ebp], al
	mov	cl, BYTE PTR $T241657[ebp]
	mov	BYTE PTR $T241651[ebp], cl
	mov	edx, DWORD PTR $T241670[ebp]
	mov	DWORD PTR $T241650[ebp], edx
	mov	eax, DWORD PTR $T241669[ebp]
	mov	DWORD PTR $T241649[ebp], eax
	jmp	SHORT $LN38@Buffered_r
$LN37@Buffered_r:
	mov	ecx, DWORD PTR $T241650[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T241650[ebp], ecx
	mov	edx, DWORD PTR $T241649[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T241649[ebp], edx
$LN38@Buffered_r:
	mov	eax, DWORD PTR $T241649[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN30@Buffered_r
	mov	ecx, DWORD PTR $T241649[ebp]
	mov	edx, DWORD PTR $T241650[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN37@Buffered_r
$LN30@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241674[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241678[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T241717[ebp], edx
	mov	eax, DWORD PTR $T241678[ebp]
	mov	DWORD PTR $T241716[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241702[ebp], cl
	mov	dl, BYTE PTR __Cat$241707[ebp]
	mov	BYTE PTR $T241703[ebp], dl
	mov	al, BYTE PTR $T241702[ebp]
	mov	BYTE PTR $T241700[ebp], al
	mov	cl, BYTE PTR $T241704[ebp]
	mov	BYTE PTR $T241699[ebp], cl
	mov	edx, DWORD PTR $T241717[ebp]
	mov	DWORD PTR $T241698[ebp], edx
	mov	eax, DWORD PTR $T241674[ebp]
	mov	DWORD PTR $T241697[ebp], eax
	mov	ecx, DWORD PTR $T241716[ebp]
	mov	DWORD PTR $T241696[ebp], ecx
$LN52@Buffered_r:
	mov	edx, DWORD PTR $T241696[ebp]
	cmp	edx, DWORD PTR $T241697[ebp]
	je	SHORT $LN45@Buffered_r
	mov	eax, DWORD PTR $T241697[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T241697[ebp], eax
	mov	ecx, DWORD PTR $T241698[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T241698[ebp], ecx
	mov	edx, DWORD PTR $T241697[ebp]
	mov	eax, DWORD PTR $T241698[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN52@Buffered_r
$LN45@Buffered_r:
	mov	eax, DWORD PTR $T241698[ebp]
	jmp	$LN5@Buffered_r
	jmp	$LN5@Buffered_r
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, DWORD PTR __Tempbuf$[ebp]
	call	?_Maxlen@?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEHXZ ; std::_Temp_iterator<CvPurchaseRequest>::_Maxlen
	cmp	DWORD PTR __Count2$[ebp], eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR __Tempbuf$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T241593[ebp], esp
	mov	DWORD PTR $T241730[ebp], edx
	mov	eax, DWORD PTR $T241730[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T241730[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T241730[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T241730[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T241730[ebp]
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR $T241730[ebp]
	mov	DWORD PTR tv177[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241594[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv178[ebp], eax
	cmp	DWORD PTR $T241594[ebp], 0
	je	SHORT $LN68@Buffered_r
	mov	edx, DWORD PTR $T241594[ebp]
	mov	DWORD PTR __Next$241746[ebp], edx
	jmp	SHORT $LN66@Buffered_r
$LN65@Buffered_r:
	mov	eax, DWORD PTR __Next$241746[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$241746[ebp], eax
$LN66@Buffered_r:
	mov	ecx, DWORD PTR __Next$241746[ebp]
	cmp	ecx, DWORD PTR $T241594[ebp+8]
	je	SHORT $LN64@Buffered_r
	jmp	SHORT $LN65@Buffered_r
$LN64@Buffered_r:
	mov	edx, DWORD PTR $T241594[ebp]
	mov	DWORD PTR $T241738[ebp], edx
	mov	eax, DWORD PTR $T241738[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR $T241788[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T241787[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T241773[ebp], al
	mov	cl, BYTE PTR __Cat$241778[ebp]
	mov	BYTE PTR $T241774[ebp], cl
	mov	dl, BYTE PTR $T241773[ebp]
	mov	BYTE PTR $T241771[ebp], dl
	mov	al, BYTE PTR $T241775[ebp]
	mov	BYTE PTR $T241770[ebp], al
	mov	ecx, DWORD PTR $T241788[ebp]
	mov	DWORD PTR $T241769[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR $T241768[ebp], edx
	mov	eax, DWORD PTR $T241787[ebp]
	mov	DWORD PTR $T241767[ebp], eax
$LN81@Buffered_r:
	mov	ecx, DWORD PTR $T241767[ebp]
	cmp	ecx, DWORD PTR $T241768[ebp]
	je	SHORT $LN74@Buffered_r
	mov	edx, DWORD PTR $T241768[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T241768[ebp], edx
	mov	eax, DWORD PTR $T241769[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T241769[ebp], eax
	mov	ecx, DWORD PTR $T241768[ebp]
	mov	edx, DWORD PTR $T241769[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN81@Buffered_r
$LN74@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241792[ebp], ecx
	mov	edx, DWORD PTR __Tempbuf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T241796[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T241836[ebp], edx
	mov	eax, DWORD PTR $T241796[ebp]
	mov	DWORD PTR $T241835[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T241820[ebp], cl
	mov	dl, BYTE PTR __Cat$241825[ebp]
	mov	BYTE PTR $T241821[ebp], dl
	mov	al, BYTE PTR $T241820[ebp]
	mov	BYTE PTR $T241818[ebp], al
	mov	cl, BYTE PTR $T241822[ebp]
	mov	BYTE PTR $T241817[ebp], cl
	mov	edx, DWORD PTR $T241836[ebp]
	mov	DWORD PTR $T241816[ebp], edx
	mov	eax, DWORD PTR $T241835[ebp]
	mov	DWORD PTR $T241815[ebp], eax
	jmp	SHORT $LN96@Buffered_r
$LN95@Buffered_r:
	mov	ecx, DWORD PTR $T241816[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T241816[ebp], ecx
	mov	edx, DWORD PTR $T241815[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T241815[ebp], edx
$LN96@Buffered_r:
	mov	eax, DWORD PTR $T241815[ebp]
	cmp	eax, DWORD PTR $T241792[ebp]
	je	SHORT $LN88@Buffered_r
	mov	ecx, DWORD PTR $T241815[ebp]
	mov	edx, DWORD PTR $T241816[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN95@Buffered_r
$LN88@Buffered_r:
	mov	eax, DWORD PTR $T241816[ebp]
	jmp	SHORT $LN5@Buffered_r

; 2696 : 		}
; 2697 : 	else

	jmp	SHORT $LN5@Buffered_r
$LN2@Buffered_r:

; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T241871[ebp], edx
	mov	eax, DWORD PTR $T241871[ebp]
	cmp	eax, DWORD PTR __Mid$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	ecx, DWORD PTR __Mid$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN112@Buffered_r
	mov	dl, BYTE PTR $T241859[ebp]
	mov	BYTE PTR $T241857[ebp], dl
	mov	eax, DWORD PTR $T241871[ebp]
	mov	DWORD PTR $T241856[ebp], eax
	push	0
	push	0
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR $T241856[ebp]
	push	eax
	call	??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
	add	esp, 20					; 00000014H

; 2700 : 		std::advance(_First, _Count2);

$LN112@Buffered_r:
	mov	ecx, DWORD PTR __Count2$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 2701 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
$LN5@Buffered_r:

; 2702 : 		}
; 2703 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Buffered_rotate@PAVCvPurchaseRequest@@HV1@@std@@YAPAVCvPurchaseRequest@@PAV1@00HHAAV?$_Temp_iterator@VCvPurchaseRequest@@@0@@Z ENDP ; std::_Buffered_rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
__Tmp$241952 = -24					; size = 8
__Tmp$241930 = -16					; size = 8
__Tmp$241908 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>, COMDAT

; 2998 : 	{	// sort median of three elements to middle

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	mov	edx, DWORD PTR __Mid$[ebp]
	cmp	edx, DWORD PTR __First$[ebp]
	je	SHORT $LN15@Med3
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$241908[ebp], ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$241908[ebp+4], eax
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Tmp$241908[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Tmp$241908[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

$LN15@Med3:
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+4]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN24@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	mov	ecx, DWORD PTR __Last$[ebp]
	cmp	ecx, DWORD PTR __Mid$[ebp]
	je	SHORT $LN24@Med3
	mov	edx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$241930[ebp], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$241930[ebp+4], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __Tmp$241930[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$241930[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

$LN24@Med3:
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN4@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	mov	eax, DWORD PTR __Mid$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN4@Med3
	mov	ecx, DWORD PTR __Mid$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$241952[ebp], edx
	mov	eax, DWORD PTR __Mid$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$241952[ebp+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Mid$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Tmp$241952[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$241952[ebp+4]
	mov	DWORD PTR [eax+4], edx
$LN4@Med3:

; 3005 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvUnit *,50,1>::WeightedElement *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z
_TEXT	SEGMENT
$T241980 = -32						; size = 4
$T241979 = -28						; size = 8
__Idx$241975 = -20					; size = 4
$T241966 = -16						; size = 4
__Idx$ = -8						; size = 4
__Top$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2055 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2056 : 	_Diff _Top = _Hole;

	mov	eax, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR __Top$[ebp], eax

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	ecx, DWORD PTR __Hole$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	DWORD PTR __Idx$[ebp], edx

; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	jmp	SHORT $LN5@Adjust_hea
$LN4@Adjust_hea:
	mov	eax, DWORD PTR __Idx$[ebp]
	lea	ecx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __Idx$[ebp], ecx
$LN5@Adjust_hea:
	mov	edx, DWORD PTR __Idx$[ebp]
	cmp	edx, DWORD PTR __Bottom$[ebp]
	jge	SHORT $LN3@Adjust_hea

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	eax, DWORD PTR __Idx$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR __Idx$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+edx*8-4]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	mov	eax, DWORD PTR __Idx$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Idx$[ebp], eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ecx, DWORD PTR __Idx$[ebp]
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edx+ecx*8+4]
	mov	edx, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+edx*8], eax
	mov	DWORD PTR [esi+edx*8+4], ecx
	mov	eax, DWORD PTR __Idx$[ebp]
	mov	DWORD PTR __Hole$[ebp], eax

; 2064 : 		}

	jmp	SHORT $LN4@Adjust_hea
$LN3@Adjust_hea:

; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	mov	ecx, DWORD PTR __Idx$[ebp]
	cmp	ecx, DWORD PTR __Bottom$[ebp]
	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	edx, DWORD PTR __Bottom$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8-8]
	mov	edx, DWORD PTR [eax+edx*8-4]
	mov	eax, DWORD PTR __Hole$[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx

; 2069 : 		_Hole = _Bottom - 1;

	mov	ecx, DWORD PTR __Bottom$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Hole$[ebp], ecx
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	edx, DWORD PTR $T241979[ebp]
	mov	DWORD PTR $T241966[ebp], edx
	mov	eax, DWORD PTR $T241966[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T241966[ebp]
	mov	eax, DWORD PTR __Val$[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Hole$[ebp]
	mov	DWORD PTR $T241980[ebp], ecx
	mov	eax, DWORD PTR $T241980[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$241975[ebp], eax
	jmp	SHORT $LN14@Adjust_hea
$LN13@Adjust_hea:
	mov	eax, DWORD PTR $T241980[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Idx$241975[ebp], eax
$LN14@Adjust_hea:
	mov	edx, DWORD PTR __Top$[ebp]
	cmp	edx, DWORD PTR $T241980[ebp]
	jge	SHORT $LN12@Adjust_hea
	mov	eax, DWORD PTR __Idx$241975[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	xor	eax, eax
	cmp	edx, DWORD PTR $T241979[ebp+4]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN12@Adjust_hea
	mov	edx, DWORD PTR __Idx$241975[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [eax+edx*8+4]
	mov	eax, DWORD PTR $T241980[ebp]
	mov	esi, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi+eax*8], ecx
	mov	DWORD PTR [esi+eax*8+4], edx
	mov	ecx, DWORD PTR __Idx$241975[ebp]
	mov	DWORD PTR $T241980[ebp], ecx
	jmp	SHORT $LN13@Adjust_hea
$LN12@Adjust_hea:
	mov	edx, DWORD PTR $T241980[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR $T241979[ebp]
	mov	DWORD PTR [eax+edx*8], ecx
	mov	ecx, DWORD PTR $T241979[ebp+4]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 2072 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv183 = -180						; size = 4
tv182 = -176						; size = 4
tv179 = -172						; size = 4
tv178 = -168						; size = 4
tv174 = -164						; size = 4
tv173 = -160						; size = 4
$T242142 = -156						; size = 4
__Next$242145 = -152					; size = 4
$T242123 = -148						; size = 4
__Next$242126 = -144					; size = 4
$T242115 = -140						; size = 4
$T242078 = -132						; size = 4
__Next$242081 = -128					; size = 4
$T242070 = -124						; size = 4
$T242050 = -120						; size = 4
__Next$242053 = -116					; size = 4
$T242042 = -112						; size = 4
$T242038 = -108						; size = 4
$T241988 = -100						; size = 20
$T241987 = -80						; size = 4
$T241986 = -76						; size = 20
$T241985 = -56						; size = 4
$T241984 = -52						; size = 20
$T241983 = -32						; size = 4
__Mid$229678 = -28					; size = 4
__Mid2$229661 = -24					; size = 4
__Mid1$229660 = -20					; size = 4
__Chunk2$229656 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$229656[ebp], eax
	jmp	SHORT $LN5@Chunked_me
$LN4@Chunked_me:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$229656[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me:
	mov	edx, DWORD PTR __Chunk2$229656[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	$LN3@Chunked_me

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$229660[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Mid1$229660[ebp]
	mov	DWORD PTR __Mid1$229660[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$229660[ebp]
	mov	DWORD PTR __Mid2$229661[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Mid2$229661[ebp]
	mov	DWORD PTR __Mid2$229661[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	DWORD PTR $T241983[ebp], esp
	mov	DWORD PTR $T242038[ebp], ecx
	mov	edx, DWORD PTR $T242038[ebp]
	mov	DWORD PTR [edx], 0
	mov	eax, DWORD PTR $T242038[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR $T242038[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR $T242038[ebp]
	mov	DWORD PTR [edx+12], 0
	mov	eax, DWORD PTR $T242038[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR $T242038[ebp]
	mov	DWORD PTR tv173[ebp], edx
	mov	eax, DWORD PTR __Mid2$229661[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid1$229660[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mid1$229660[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241984[ebp]
	push	ecx
	call	??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv174[ebp], eax
	mov	edx, DWORD PTR tv174[ebp]
	mov	DWORD PTR $T242042[ebp], edx
	mov	eax, DWORD PTR $T242042[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[ebp+16], ecx
	cmp	DWORD PTR $T241984[ebp], 0
	je	SHORT $LN37@Chunked_me
	mov	edx, DWORD PTR $T241984[ebp]
	mov	DWORD PTR __Next$242053[ebp], edx
	jmp	SHORT $LN35@Chunked_me
$LN34@Chunked_me:
	mov	eax, DWORD PTR __Next$242053[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$242053[ebp], eax
$LN35@Chunked_me:
	mov	ecx, DWORD PTR __Next$242053[ebp]
	cmp	ecx, DWORD PTR $T241984[ebp+8]
	je	SHORT $LN33@Chunked_me
	jmp	SHORT $LN34@Chunked_me
$LN33@Chunked_me:
	mov	edx, DWORD PTR $T241984[ebp]
	mov	DWORD PTR $T242050[ebp], edx
	mov	eax, DWORD PTR $T242050[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@Chunked_me:

; 3297 : 		_First = _Mid2;

	mov	ecx, DWORD PTR __Mid2$229661[ebp]
	mov	DWORD PTR __First$[ebp], ecx

; 3298 : 		}

	jmp	$LN4@Chunked_me
$LN3@Chunked_me:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	edx, DWORD PTR __Chunk$[ebp]
	jg	$LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T241985[ebp], esp
	mov	DWORD PTR $T242070[ebp], eax
	mov	ecx, DWORD PTR $T242070[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T242070[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T242070[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T242070[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T242070[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T242070[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T241986[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv179[ebp], eax
	cmp	DWORD PTR $T241986[ebp], 0
	je	SHORT $LN51@Chunked_me
	mov	edx, DWORD PTR $T241986[ebp]
	mov	DWORD PTR __Next$242081[ebp], edx
	jmp	SHORT $LN49@Chunked_me
$LN48@Chunked_me:
	mov	eax, DWORD PTR __Next$242081[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$242081[ebp], eax
$LN49@Chunked_me:
	mov	ecx, DWORD PTR __Next$242081[ebp]
	cmp	ecx, DWORD PTR $T241986[ebp+8]
	je	SHORT $LN47@Chunked_me
	jmp	SHORT $LN48@Chunked_me
$LN47@Chunked_me:
	mov	edx, DWORD PTR $T241986[ebp]
	mov	DWORD PTR $T242078[ebp], edx
	mov	eax, DWORD PTR $T242078[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN51@Chunked_me:

; 3302 : 	else

	jmp	$LN1@Chunked_me
$LN2@Chunked_me:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$229678[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Mid$229678[ebp]
	mov	DWORD PTR __Mid$229678[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T241987[ebp], esp
	mov	DWORD PTR $T242115[ebp], eax
	mov	ecx, DWORD PTR $T242115[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T242115[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T242115[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T242115[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T242115[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T242115[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid$229678[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mid$229678[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T241988[ebp]
	push	eax
	call	??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 40					; 00000028H
	mov	DWORD PTR tv183[ebp], eax
	cmp	DWORD PTR $T241988[ebp], 0
	je	SHORT $LN1@Chunked_me
	mov	ecx, DWORD PTR $T241988[ebp]
	mov	DWORD PTR __Next$242126[ebp], ecx
	jmp	SHORT $LN69@Chunked_me
$LN68@Chunked_me:
	mov	edx, DWORD PTR __Next$242126[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$242126[ebp], edx
$LN69@Chunked_me:
	mov	eax, DWORD PTR __Next$242126[ebp]
	cmp	eax, DWORD PTR $T241988[ebp+8]
	je	SHORT $LN67@Chunked_me
	jmp	SHORT $LN68@Chunked_me
$LN67@Chunked_me:
	mov	ecx, DWORD PTR $T241988[ebp]
	mov	DWORD PTR $T242123[ebp], ecx
	mov	edx, DWORD PTR $T242123[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Chunked_me:

; 3308 : 		}
; 3309 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN6@Chunked_me
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$242145[ebp], eax
	jmp	SHORT $LN79@Chunked_me
$LN78@Chunked_me:
	mov	ecx, DWORD PTR __Next$242145[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next$242145[ebp], ecx
$LN79@Chunked_me:
	mov	edx, DWORD PTR __Next$242145[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN77@Chunked_me
	jmp	SHORT $LN78@Chunked_me
$LN77@Chunked_me:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242142[ebp], eax
	mov	ecx, DWORD PTR $T242142[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Chunked_me:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-172]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Chunked_merge@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@H@std@@YAXPAVCvPurchaseRequest@@0V?$_Temp_iterator@VCvPurchaseRequest@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,int>
; Function compile flags: /Odtp
;	COMDAT ??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T242427 = -176						; size = 4
$T242426 = -172						; size = 4
$T242425 = -168						; size = 4
$T242424 = -164						; size = 4
$T242419 = -104						; size = 1
$T242418 = -103						; size = 1
$T242308 = -100						; size = 4
$T242307 = -96						; size = 4
$T242290 = -90						; size = 1
$T242289 = -89						; size = 1
$T242288 = -88						; size = 4
$T242287 = -84						; size = 4
__Cat$242297 = -76					; size = 1
$T242295 = -75						; size = 1
$T242294 = -74						; size = 1
$T242293 = -73						; size = 1
$T242268 = -72						; size = 4
$T242267 = -68						; size = 4
$T242266 = -64						; size = 4
$T242265 = -60						; size = 4
$T242264 = -56						; size = 4
$T242259 = -22						; size = 1
$T242258 = -21						; size = 1
__Mid$229690 = -16					; size = 4
__Mid2$229687 = -12					; size = 4
__Mid1$229686 = -8					; size = 4
__Chunk2$229682 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[ebp]
	shl	eax, 1
	mov	DWORD PTR __Chunk2$229682[ebp], eax
	jmp	SHORT $LN5@Chunked_me@2
$LN4@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Chunk2$229682[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN5@Chunked_me@2:
	mov	edx, DWORD PTR __Chunk2$229682[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jg	SHORT $LN3@Chunked_me@2

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid1$229686[ebp], eax

; 3292 : 		std::advance(_Mid1, _Chunk);

	mov	ecx, DWORD PTR __Chunk$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR __Mid1$229686[ebp]
	mov	DWORD PTR __Mid1$229686[ebp], ecx

; 3293 : 		_BidIt _Mid2 = _Mid1;

	mov	edx, DWORD PTR __Mid1$229686[ebp]
	mov	DWORD PTR __Mid2$229687[ebp], edx

; 3294 : 		std::advance(_Mid2, _Chunk);

	mov	eax, DWORD PTR __Chunk$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Mid2$229687[ebp]
	mov	DWORD PTR __Mid2$229687[ebp], eax

; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242268[ebp], ecx
	mov	edx, DWORD PTR __Mid2$229687[ebp]
	mov	DWORD PTR $T242267[ebp], edx
	mov	eax, DWORD PTR __Mid1$229686[ebp]
	mov	DWORD PTR $T242266[ebp], eax
	mov	ecx, DWORD PTR __Mid1$229686[ebp]
	mov	DWORD PTR $T242265[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242264[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242258[ebp], al
	movzx	ecx, BYTE PTR $T242258[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T242259[ebp]
	push	edx
	mov	eax, DWORD PTR $T242268[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242267[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242266[ebp]
	push	edx
	mov	eax, DWORD PTR $T242265[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242264[ebp]
	push	ecx
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], eax

; 3297 : 		_First = _Mid2;

	mov	edx, DWORD PTR __Mid2$229687[ebp]
	mov	DWORD PTR __First$[ebp], edx

; 3298 : 		}

	jmp	$LN4@Chunked_me@2
$LN3@Chunked_me@2:

; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Chunk$[ebp]
	jg	SHORT $LN2@Chunked_me@2

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242308[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242307[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242293[ebp], al
	mov	cl, BYTE PTR __Cat$242297[ebp]
	mov	BYTE PTR $T242294[ebp], cl
	mov	dl, BYTE PTR $T242293[ebp]
	mov	BYTE PTR $T242290[ebp], dl
	mov	al, BYTE PTR $T242295[ebp]
	mov	BYTE PTR $T242289[ebp], al
	mov	ecx, DWORD PTR $T242308[ebp]
	mov	DWORD PTR $T242288[ebp], ecx
	mov	edx, DWORD PTR $T242307[ebp]
	mov	DWORD PTR $T242287[ebp], edx
	jmp	SHORT $LN53@Chunked_me@2
$LN52@Chunked_me@2:
	mov	eax, DWORD PTR $T242288[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T242288[ebp], eax
	mov	ecx, DWORD PTR $T242287[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T242287[ebp], ecx
$LN53@Chunked_me@2:
	mov	edx, DWORD PTR $T242287[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN45@Chunked_me@2
	mov	eax, DWORD PTR $T242287[ebp]
	mov	ecx, DWORD PTR $T242288[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN52@Chunked_me@2
$LN45@Chunked_me@2:

; 3302 : 	else

	jmp	SHORT $LN6@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;

	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$229690[ebp], ecx

; 3305 : 		std::advance(_Mid, _Chunk);

	mov	edx, DWORD PTR __Chunk$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Mid$229690[ebp]
	mov	DWORD PTR __Mid$229690[ebp], edx

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242427[ebp], eax
	mov	ecx, DWORD PTR __Mid$229690[ebp]
	mov	DWORD PTR $T242426[ebp], ecx
	mov	edx, DWORD PTR __Mid$229690[ebp]
	mov	DWORD PTR $T242425[ebp], edx
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242424[ebp], eax
	xor	ecx, ecx
	mov	BYTE PTR $T242418[ebp], cl
	movzx	edx, BYTE PTR $T242418[ebp]
	push	edx
	movzx	eax, BYTE PTR $T242419[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242427[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR $T242426[ebp]
	push	eax
	mov	ecx, DWORD PTR $T242425[ebp]
	push	ecx
	mov	edx, DWORD PTR $T242424[ebp]
	push	edx
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN6@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Chunked_merge@PAVCvPurchaseRequest@@PAV1@H@std@@YAXPAVCvPurchaseRequest@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvPurchaseRequest *,CvPurchaseRequest *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	ENDS
;	COMDAT ??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T242471 = -36						; size = 4
__Next$242474 = -32					; size = 4
$T242432 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T242432[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt
$LN9@Copy_opt:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Copy_opt:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
	jmp	SHORT $LN9@Copy_opt
$LN1@Copy_opt:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T242432[ebp]
	or	eax, 1
	mov	DWORD PTR $T242432[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN31@Copy_opt
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$242474[ebp], ecx
	jmp	SHORT $LN29@Copy_opt
$LN28@Copy_opt:
	mov	edx, DWORD PTR __Next$242474[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$242474[ebp], edx
$LN29@Copy_opt:
	mov	eax, DWORD PTR __Next$242474[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN27@Copy_opt
	jmp	SHORT $LN28@Copy_opt
$LN27@Copy_opt:
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242471[ebp], ecx
	mov	edx, DWORD PTR $T242471[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN31@Copy_opt:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_opt@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T242573 = -56						; size = 4
$T242572 = -52						; size = 4
$T242555 = -46						; size = 1
$T242554 = -45						; size = 1
$T242553 = -44						; size = 4
$T242552 = -40						; size = 4
__Cat$242562 = -32					; size = 1
$T242560 = -31						; size = 1
$T242559 = -30						; size = 1
$T242558 = -29						; size = 1
$T242533 = -28						; size = 4
$T242532 = -24						; size = 4
$T242515 = -18						; size = 1
$T242514 = -17						; size = 1
$T242513 = -16						; size = 4
$T242512 = -12						; size = 4
__Cat$242522 = -4					; size = 1
$T242520 = -3						; size = 1
$T242519 = -2						; size = 1
$T242518 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	jmp	SHORT $LN5@Merge
$LN4@Merge:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], eax
$LN5@Merge:
	mov	ecx, DWORD PTR __First1$[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge
	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR __First2$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR [eax+8]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+8]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR __First2$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __First2$[ebp], eax

; 2516 : 		else

	jmp	SHORT $LN1@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ecx, DWORD PTR __First1$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR __First1$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First1$[ebp], edx
$LN1@Merge:
	jmp	SHORT $LN4@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242533[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T242532[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T242518[ebp], dl
	mov	al, BYTE PTR __Cat$242522[ebp]
	mov	BYTE PTR $T242519[ebp], al
	mov	cl, BYTE PTR $T242518[ebp]
	mov	BYTE PTR $T242515[ebp], cl
	mov	dl, BYTE PTR $T242520[ebp]
	mov	BYTE PTR $T242514[ebp], dl
	mov	eax, DWORD PTR $T242533[ebp]
	mov	DWORD PTR $T242513[ebp], eax
	mov	ecx, DWORD PTR $T242532[ebp]
	mov	DWORD PTR $T242512[ebp], ecx
	jmp	SHORT $LN18@Merge
$LN17@Merge:
	mov	edx, DWORD PTR $T242513[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR $T242513[ebp], edx
	mov	eax, DWORD PTR $T242512[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T242512[ebp], eax
$LN18@Merge:
	mov	ecx, DWORD PTR $T242512[ebp]
	cmp	ecx, DWORD PTR __Last1$[ebp]
	je	SHORT $LN10@Merge
	mov	edx, DWORD PTR $T242512[ebp]
	mov	eax, DWORD PTR $T242513[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	jmp	SHORT $LN17@Merge
$LN10@Merge:
	mov	eax, DWORD PTR $T242513[ebp]
	mov	DWORD PTR __Dest$[ebp], eax

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242573[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T242572[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242558[ebp], al
	mov	cl, BYTE PTR __Cat$242562[ebp]
	mov	BYTE PTR $T242559[ebp], cl
	mov	dl, BYTE PTR $T242558[ebp]
	mov	BYTE PTR $T242555[ebp], dl
	mov	al, BYTE PTR $T242560[ebp]
	mov	BYTE PTR $T242554[ebp], al
	mov	ecx, DWORD PTR $T242573[ebp]
	mov	DWORD PTR $T242553[ebp], ecx
	mov	edx, DWORD PTR $T242572[ebp]
	mov	DWORD PTR $T242552[ebp], edx
	jmp	SHORT $LN29@Merge
$LN28@Merge:
	mov	eax, DWORD PTR $T242553[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR $T242553[ebp], eax
	mov	ecx, DWORD PTR $T242552[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR $T242552[ebp], ecx
$LN29@Merge:
	mov	edx, DWORD PTR $T242552[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN21@Merge
	mov	eax, DWORD PTR $T242552[ebp]
	mov	ecx, DWORD PTR $T242553[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN28@Merge
$LN21@Merge:
	mov	eax, DWORD PTR $T242553[ebp]

; 2521 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge@PAVCvPurchaseRequest@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvPurchaseRequest@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T242653 = -64						; size = 4
$T242652 = -60						; size = 4
$T242636 = -54						; size = 1
$T242635 = -53						; size = 1
$T242634 = -52						; size = 4
$T242633 = -48						; size = 4
$T242632 = -44						; size = 4
__Cat$242643 = -36					; size = 1
$T242641 = -35						; size = 1
$T242640 = -34						; size = 1
$T242639 = -33						; size = 1
$T242614 = -32						; size = 4
$T242613 = -28						; size = 4
$T242597 = -22						; size = 1
$T242596 = -21						; size = 1
$T242595 = -20						; size = 4
$T242594 = -16						; size = 4
$T242593 = -12						; size = 4
__Cat$242604 = -4					; size = 1
$T242602 = -3						; size = 1
$T242601 = -2						; size = 1
$T242600 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>, COMDAT

; 2710 : 	{	// merge backwards to _Dest, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
$LN8@Merge_back:

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	jne	SHORT $LN6@Merge_back

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242614[ebp], ecx
	mov	edx, DWORD PTR __First2$[ebp]
	mov	DWORD PTR $T242613[ebp], edx
	xor	eax, eax
	mov	BYTE PTR $T242600[ebp], al
	mov	cl, BYTE PTR __Cat$242604[ebp]
	mov	BYTE PTR $T242601[ebp], cl
	mov	dl, BYTE PTR $T242600[ebp]
	mov	BYTE PTR $T242597[ebp], dl
	mov	al, BYTE PTR $T242602[ebp]
	mov	BYTE PTR $T242596[ebp], al
	mov	ecx, DWORD PTR $T242614[ebp]
	mov	DWORD PTR $T242595[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	mov	DWORD PTR $T242594[ebp], edx
	mov	eax, DWORD PTR $T242613[ebp]
	mov	DWORD PTR $T242593[ebp], eax
$LN18@Merge_back:
	mov	ecx, DWORD PTR $T242593[ebp]
	cmp	ecx, DWORD PTR $T242594[ebp]
	je	SHORT $LN11@Merge_back
	mov	edx, DWORD PTR $T242594[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T242594[ebp], edx
	mov	eax, DWORD PTR $T242595[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR $T242595[ebp], eax
	mov	ecx, DWORD PTR $T242594[ebp]
	mov	edx, DWORD PTR $T242595[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	jmp	SHORT $LN18@Merge_back
$LN11@Merge_back:
	mov	eax, DWORD PTR $T242595[ebp]
	jmp	$LN9@Merge_back
	jmp	$LN5@Merge_back
$LN6@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	mov	edx, DWORD PTR __First2$[ebp]
	cmp	edx, DWORD PTR __Last2$[ebp]
	jne	SHORT $LN4@Merge_back

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242653[ebp], eax
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR $T242652[ebp], ecx
	xor	edx, edx
	mov	BYTE PTR $T242639[ebp], dl
	mov	al, BYTE PTR __Cat$242643[ebp]
	mov	BYTE PTR $T242640[ebp], al
	mov	cl, BYTE PTR $T242639[ebp]
	mov	BYTE PTR $T242636[ebp], cl
	mov	dl, BYTE PTR $T242641[ebp]
	mov	BYTE PTR $T242635[ebp], dl
	mov	eax, DWORD PTR $T242653[ebp]
	mov	DWORD PTR $T242634[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	DWORD PTR $T242633[ebp], ecx
	mov	edx, DWORD PTR $T242652[ebp]
	mov	DWORD PTR $T242632[ebp], edx
$LN28@Merge_back:
	mov	eax, DWORD PTR $T242632[ebp]
	cmp	eax, DWORD PTR $T242633[ebp]
	je	SHORT $LN21@Merge_back
	mov	ecx, DWORD PTR $T242633[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR $T242633[ebp], ecx
	mov	edx, DWORD PTR $T242634[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR $T242634[ebp], edx
	mov	eax, DWORD PTR $T242633[ebp]
	mov	ecx, DWORD PTR $T242634[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	jmp	SHORT $LN28@Merge_back
$LN21@Merge_back:
	mov	eax, DWORD PTR $T242634[ebp]
	jmp	$LN9@Merge_back
	jmp	SHORT $LN5@Merge_back
$LN4@Merge_back:

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ecx, DWORD PTR __Last1$[ebp]
	sub	ecx, 12					; 0000000cH
	mov	DWORD PTR __Last1$[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR __Last2$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR __Last1$[ebp]
	mov	edx, DWORD PTR [eax+8]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+8]
	setg	al
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Merge_back

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last1$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Last2$[ebp], ecx

; 2718 : 		else

	jmp	SHORT $LN5@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 12					; 0000000cH
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last2$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Last1$[ebp], ecx
$LN5@Merge_back:
	jmp	$LN8@Merge_back
$LN9@Merge_back:

; 2720 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Merge_backward@PAVCvPurchaseRequest@@PAV1@PAV1@@std@@YAPAVCvPurchaseRequest@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvPurchaseRequest *,CvPurchaseRequest *,CvPurchaseRequest *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T242676 = -20						; size = 4
__Count2$229740 = -12					; size = 4
__Mid$229741 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>, COMDAT

; 2252 : 	{	// find first element not before _Val, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2255 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242676[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T242676[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Lower_boun

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$229740[ebp], eax

; 2260 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$229741[ebp], edx

; 2261 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$229740[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Mid$229741[ebp]
	mov	DWORD PTR __Mid$229741[ebp], eax

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	mov	ecx, DWORD PTR __Mid$229741[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+8]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$229741[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Mid$229741[ebp], eax
	mov	ecx, DWORD PTR __Mid$229741[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$229740[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$229740[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Lower_boun:

; 2268 : 		}

	jmp	SHORT $LN4@Lower_boun
$LN3@Lower_boun:

; 2269 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2270 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lower_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
$T242716 = -20						; size = 4
__Count2$229749 = -12					; size = 4
__Mid$229750 = -8					; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>, COMDAT

; 2324 : 	{	// find first element that _Val is before, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;

	mov	DWORD PTR __Count$[ebp], 0

; 2327 : 	_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR $T242716[ebp], eax
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR $T242716[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	cmp	DWORD PTR __Count$[ebp], 0
	jle	SHORT $LN3@Upper_boun

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR __Count2$229749[ebp], eax

; 2331 : 		_FwdIt _Mid = _First;

	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Mid$229750[ebp], edx

; 2332 : 		std::advance(_Mid, _Count2);

	mov	eax, DWORD PTR __Count2$229749[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Mid$229750[ebp]
	mov	DWORD PTR __Mid$229750[ebp], eax

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR __Mid$229750[ebp]
	mov	eax, DWORD PTR [ecx+8]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+8]
	setg	cl
	movzx	edx, cl
	test	edx, edx
	jne	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	mov	eax, DWORD PTR __Mid$229750[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Mid$229750[ebp], eax
	mov	ecx, DWORD PTR __Mid$229750[ebp]
	mov	DWORD PTR __First$[ebp], ecx
	mov	edx, DWORD PTR __Count2$229749[ebp]
	add	edx, 1
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	mov	DWORD PTR __Count$[ebp], eax

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, DWORD PTR __Count2$229749[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$LN1@Upper_boun:

; 2339 : 		}

	jmp	SHORT $LN4@Upper_boun
$LN3@Upper_boun:

; 2340 : 	return (_First);

	mov	eax, DWORD PTR __First$[ebp]

; 2341 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Upper_bound@PAVCvPurchaseRequest@@V1@H@std@@YAPAVCvPurchaseRequest@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvPurchaseRequest *,CvPurchaseRequest,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z
_TEXT	SEGMENT
$T242782 = -60						; size = 8
$T242753 = -20						; size = 4
$T242747 = -12						; size = 4
$T242746 = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>, COMDAT

; 2087 : 	{	// pop *_First to *(_Last - 1) and reheap, using operator<

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 8
	mov	DWORD PTR $T242747[ebp], eax
	lea	ecx, DWORD PTR $T242782[ebp]
	mov	DWORD PTR $T242746[ebp], ecx
	mov	edx, DWORD PTR $T242746[ebp]
	mov	eax, DWORD PTR $T242747[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T242746[ebp]
	mov	eax, DWORD PTR $T242747[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [edx-8], eax
	mov	DWORD PTR [edx-4], ecx
	sub	esp, 8
	mov	DWORD PTR $T242753[ebp], esp
	mov	eax, DWORD PTR $T242753[ebp]
	mov	ecx, DWORD PTR $T242782[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T242753[ebp]
	mov	eax, DWORD PTR $T242782[ebp+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	sub	ecx, DWORD PTR __First$[ebp]
	sar	ecx, 3
	push	ecx
	push	0
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,int,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvUnit@@$0DC@$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvUnit *,50,1>::WeightedElement *,CvWeightedVector<CvUnit *,50,1>::WeightedElement>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z
_TEXT	SEGMENT
tv128 = -20						; size = 4
_this$ = -16						; size = 4
$T242793 = -12						; size = 4
__Vptr$242799 = -8					; size = 4
__Ptr$229840 = -4					; size = 4
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z PROC ; std::_Temp_iterator<CvPurchaseRequest>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@operator@6

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx

; 565  : 		else

	jmp	SHORT $LN1@operator@6
$LN2@operator@6:

; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Ptr$229840[ebp], ecx

; 569  : 			_Construct(_Ptr, _Val);

	mov	edx, DWORD PTR __Ptr$229840[ebp]
	mov	DWORD PTR __Vptr$242799[ebp], edx
	mov	eax, DWORD PTR __Vptr$242799[ebp]
	mov	DWORD PTR $T242793[ebp], eax
	cmp	DWORD PTR $T242793[ebp], 0
	je	SHORT $LN7@operator@6
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR $T242793[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR $T242793[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN5@operator@6
$LN7@operator@6:
	mov	DWORD PTR tv128[ebp], 0
$LN5@operator@6:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], eax
$LN1@operator@6:

; 571  : 			}
; 572  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 573  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ENDP ; std::_Temp_iterator<CvPurchaseRequest>::operator=
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z$0
__ehfuncinfo$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv132 = -44						; size = 4
$T242830 = -40						; size = 4
__Next$242838 = -36					; size = 4
$T242822 = -32						; size = 4
$T242808 = -24						; size = 4
$T242804 = -20						; size = 4
$T242803 = -14						; size = 1
$T242802 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z PROC ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T242808[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T242802[ebp], al
	movzx	ecx, BYTE PTR $T242802[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T242803[ebp]
	push	edx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T242804[ebp], esp
	mov	DWORD PTR $T242822[ebp], eax
	mov	ecx, DWORD PTR $T242822[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T242822[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T242822[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T242822[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T242822[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T242822[ebp]
	mov	DWORD PTR tv132[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
	add	esp, 48					; 00000030H
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR $T242808[ebp]
	or	ecx, 1
	mov	DWORD PTR $T242808[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN17@unchecked_@3
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$242838[ebp], edx
	jmp	SHORT $LN15@unchecked_@3
$LN14@unchecked_@3:
	mov	eax, DWORD PTR __Next$242838[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Next$242838[ebp], eax
$LN15@unchecked_@3:
	mov	ecx, DWORD PTR __Next$242838[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN13@unchecked_@3
	jmp	SHORT $LN14@unchecked_@3
$LN13@unchecked_@3:
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242830[ebp], edx
	mov	eax, DWORD PTR $T242830[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@unchecked_@3:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5117 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$unchecked_merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@000V12@@Z ENDP ; stdext::unchecked_merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__ehfuncinfo$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
tv164 = -112						; size = 4
tv163 = -108						; size = 4
tv159 = -104						; size = 4
tv158 = -100						; size = 4
$T242952 = -96						; size = 4
__Next$242960 = -92					; size = 4
$T242944 = -88						; size = 4
$T242924 = -84						; size = 4
__Next$242932 = -80					; size = 4
$T242916 = -76						; size = 4
$T242912 = -72						; size = 4
$T242858 = -44						; size = 4
$T242852 = -40						; size = 4
$T242851 = -36						; size = 20
$T242850 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T242858[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN5@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[ebp]
	cmp	eax, DWORD PTR __Last1$[ebp]
	je	SHORT $LN3@Merge@2
	mov	ecx, DWORD PTR __First2$[ebp]
	cmp	ecx, DWORD PTR __Last2$[ebp]
	je	SHORT $LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __First1$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	xor	edx, edx
	cmp	ecx, DWORD PTR [eax+8]
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN30@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
	mov	edx, DWORD PTR __First2$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __First2$[ebp], edx

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2

; 2517 : 			*_Dest = *_First1, ++_First1;

$LN30@Merge@2:
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??4?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAEAAV01@ABVCvPurchaseRequest@@@Z ; std::_Temp_iterator<CvPurchaseRequest>::operator=
	mov	ecx, DWORD PTR __First1$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __First1$[ebp], ecx
$LN1@Merge@2:
	jmp	SHORT $LN5@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR $T242850[ebp], esp
	mov	DWORD PTR $T242912[ebp], edx
	mov	eax, DWORD PTR $T242912[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR $T242912[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR $T242912[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR $T242912[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR $T242912[ebp]
	mov	edx, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T242912[ebp]
	mov	DWORD PTR tv158[ebp], eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T242851[ebp]
	push	eax
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR $T242916[ebp], ecx
	mov	edx, DWORD PTR $T242916[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Dest$[ebp+16], eax
	cmp	DWORD PTR $T242851[ebp], 0
	je	SHORT $LN52@Merge@2
	mov	ecx, DWORD PTR $T242851[ebp]
	mov	DWORD PTR __Next$242932[ebp], ecx
	jmp	SHORT $LN50@Merge@2
$LN49@Merge@2:
	mov	edx, DWORD PTR __Next$242932[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR __Next$242932[ebp], edx
$LN50@Merge@2:
	mov	eax, DWORD PTR __Next$242932[ebp]
	cmp	eax, DWORD PTR $T242851[ebp+8]
	je	SHORT $LN48@Merge@2
	jmp	SHORT $LN49@Merge@2
$LN48@Merge@2:
	mov	ecx, DWORD PTR $T242851[ebp]
	mov	DWORD PTR $T242924[ebp], ecx
	mov	edx, DWORD PTR $T242924[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN52@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T242852[ebp], esp
	mov	DWORD PTR $T242944[ebp], eax
	mov	ecx, DWORD PTR $T242944[ebp]
	mov	DWORD PTR [ecx], 0
	mov	edx, DWORD PTR $T242944[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR $T242944[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR $T242944[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR $T242944[ebp]
	mov	eax, DWORD PTR __Dest$[ebp+16]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR $T242944[ebp]
	mov	DWORD PTR tv163[ebp], ecx
	mov	edx, DWORD PTR __Last2$[ebp]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$unchecked_copy@PAVCvPurchaseRequest@@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@std@@PAVCvPurchaseRequest@@0V12@@Z ; stdext::unchecked_copy<CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv164[ebp], eax
	mov	edx, DWORD PTR $T242858[ebp]
	or	edx, 1
	mov	DWORD PTR $T242858[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	cmp	DWORD PTR __Dest$[ebp], 0
	je	SHORT $LN66@Merge@2
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$242960[ebp], eax
	jmp	SHORT $LN64@Merge@2
$LN63@Merge@2:
	mov	ecx, DWORD PTR __Next$242960[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __Next$242960[ebp], ecx
$LN64@Merge@2:
	mov	edx, DWORD PTR __Next$242960[ebp]
	cmp	edx, DWORD PTR __Dest$[ebp+8]
	je	SHORT $LN62@Merge@2
	jmp	SHORT $LN63@Merge@2
$LN62@Merge@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T242952[ebp], eax
	mov	ecx, DWORD PTR $T242952[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN66@Merge@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2521 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Dest$[ebp]
	jmp	??1?$_Temp_iterator@VCvPurchaseRequest@@@std@@QAE@XZ ; std::_Temp_iterator<CvPurchaseRequest>::~_Temp_iterator<CvPurchaseRequest>
__ehhandler$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Merge@PAVCvPurchaseRequest@@PAV1@V?$_Temp_iterator@VCvPurchaseRequest@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvPurchaseRequest@@@0@PAVCvPurchaseRequest@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvPurchaseRequest *,CvPurchaseRequest *,std::_Temp_iterator<CvPurchaseRequest>,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z
_TEXT	SEGMENT
tv128 = -48						; size = 4
tv83 = -44						; size = 4
__Hole$229963 = -40					; size = 4
__Holeval$229965 = -36					; size = 12
__Next1$229966 = -24					; size = 4
__Next$229964 = -20					; size = 4
__Tmp$229958 = -16					; size = 4
__Factor$229954 = -12					; size = 4
__Shift$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z PROC ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	eax, DWORD PTR __Mid$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Shift$[ebp], eax

; 1683 : 	_Diff _Count = _Last - _First;

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR __Count$[ebp], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	edx, DWORD PTR __Shift$[ebp]
	mov	DWORD PTR __Factor$229954[ebp], edx
$LN8@Rotate:
	cmp	DWORD PTR __Factor$229954[ebp], 0
	je	SHORT $LN7@Rotate

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	mov	eax, DWORD PTR __Count$[ebp]
	cdq
	idiv	DWORD PTR __Factor$229954[ebp]
	mov	DWORD PTR __Tmp$229958[ebp], edx

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, DWORD PTR __Factor$229954[ebp]
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __Tmp$229958[ebp]
	mov	DWORD PTR __Factor$229954[ebp], ecx

; 1689 : 		}

	jmp	SHORT $LN8@Rotate
$LN7@Rotate:

; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	DWORD PTR __Count$[ebp], eax
	jge	$LN9@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	jmp	SHORT $LN5@Rotate
$LN4@Rotate:
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$LN5@Rotate:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$LN9@Rotate

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Hole$229963[ebp], eax

; 1695 : 			_RanIt _Next = _Hole;

	mov	ecx, DWORD PTR __Hole$229963[ebp]
	mov	DWORD PTR __Next$229964[ebp], ecx

; 1696 : 			_Ty _Holeval = *_Hole;

	mov	edx, DWORD PTR __Hole$229963[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Holeval$229965[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Holeval$229965[ebp+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR __Holeval$229965[ebp+8], edx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	mov	eax, DWORD PTR __Shift$[ebp]
	imul	eax, 12					; 0000000cH
	add	eax, DWORD PTR __Next$229964[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	jne	SHORT $LN11@Rotate
	mov	ecx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN12@Rotate
$LN11@Rotate:
	mov	edx, DWORD PTR __Shift$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Next$229964[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN12@Rotate:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR __Next1$229966[ebp], eax
$LN2@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	mov	ecx, DWORD PTR __Next1$229966[ebp]
	cmp	ecx, DWORD PTR __Hole$229963[ebp]
	je	SHORT $LN1@Rotate

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR __Next1$229966[ebp]
	mov	eax, DWORD PTR __Next$229964[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 1701 : 				_Next = _Next1;

	mov	eax, DWORD PTR __Next1$229966[ebp]
	mov	DWORD PTR __Next$229964[ebp], eax

; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$229966[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	cmp	DWORD PTR __Shift$[ebp], eax
	jge	SHORT $LN13@Rotate
	mov	edx, DWORD PTR __Shift$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __Next1$229966[ebp]
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next1$229966[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	edx, DWORD PTR __Shift$[ebp]
	sub	edx, eax
	imul	edx, 12					; 0000000cH
	add	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR tv128[ebp], edx
$LN14@Rotate:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR __Next1$229966[ebp], eax

; 1704 : 				}

	jmp	SHORT $LN2@Rotate
$LN1@Rotate:

; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Next$229964[ebp]
	mov	edx, DWORD PTR __Holeval$229965[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Holeval$229965[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR __Holeval$229965[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 1706 : 			}

	jmp	$LN4@Rotate
$LN9@Rotate:

; 1707 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate@PAVCvPurchaseRequest@@HV1@@std@@YAXPAVCvPurchaseRequest@@00PAH0@Z ENDP ; std::_Rotate<CvPurchaseRequest *,int,CvPurchaseRequest>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);

	lea	eax, DWORD PTR _lpszFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T243006 = -2092					; size = 4
$T243005 = -2088					; size = 4
$T243004 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T243004[ebp], eax
	mov	ecx, DWORD PTR $T243004[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T243005[ebp], eax
	mov	eax, DWORD PTR $T243005[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T243006[ebp], eax
	mov	ecx, DWORD PTR $T243006[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T243017 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243017[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T243017[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T243023 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T243023[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T243023[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T243035 = -8						; size = 4
$T243031 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T243031[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T243031[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T243035[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T243035[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fautovector.h
;	COMDAT ??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z PROC ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[], COMDAT
; _this$ = ecx

; 328  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 	return m_value[index];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _index$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ENDP ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
