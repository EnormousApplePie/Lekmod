; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvRandom.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?reset@CvRandom@@QAEXK@Z			; CvRandom::reset
PUBLIC	??_7CvRandom@@6B@				; CvRandom::`vftable'
PUBLIC	??0CvRandom@@QAE@XZ				; CvRandom::CvRandom
EXTRN	??_ECvRandom@@UAEPAXI@Z:PROC			; CvRandom::`vector deleting destructor'
;	COMDAT ??_7CvRandom@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvrandom.cpp
CONST	SEGMENT
??_7CvRandom@@6B@ DD FLAT:??_ECvRandom@@UAEPAXI@Z	; CvRandom::`vftable'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvRandom@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvRandom@@QAE@XZ PROC				; CvRandom::CvRandom, COMDAT
; _this$ = ecx

; 48   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvRandom@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+16], 0

; 49   : 	reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvRandom@@QAEXK@Z		; CvRandom::reset

; 50   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvRandom@@QAE@XZ ENDP				; CvRandom::CvRandom
_TEXT	ENDS
PUBLIC	??1CvRandom@@UAE@XZ				; CvRandom::~CvRandom
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvRandom@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvRandom@@UAEPAXI@Z PROC				; CvRandom::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvRandom@@UAE@XZ			; CvRandom::~CvRandom
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvRandom@@UAEPAXI@Z ENDP				; CvRandom::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CvRandom@@QAE@_N@Z				; CvRandom::CvRandom
; Function compile flags: /Odtp
;	COMDAT ??0CvRandom@@QAE@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_extendedCallStackDebugging$ = 8			; size = 1
??0CvRandom@@QAE@_N@Z PROC				; CvRandom::CvRandom, COMDAT
; _this$ = ecx

; 63   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvRandom@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+16], 1

; 64   : 	extendedCallStackDebugging;
; 65   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CvRandom@@QAE@_N@Z ENDP				; CvRandom::CvRandom
_TEXT	ENDS
PUBLIC	??0CvRandom@@QAE@ABV0@@Z			; CvRandom::CvRandom
; Function compile flags: /Odtp
;	COMDAT ??0CvRandom@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
??0CvRandom@@QAE@ABV0@@Z PROC				; CvRandom::CvRandom, COMDAT
; _this$ = ecx

; 78   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvRandom@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _source$[ebp]
	mov	al, BYTE PTR [edx+16]
	mov	BYTE PTR [ecx+16], al

; 79   : #ifdef AUI_USE_SFMT_RNG
; 80   : 	m_MersenneTwister = source.m_MersenneTwister;
; 81   : #endif
; 82   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CvRandom@@QAE@ABV0@@Z ENDP				; CvRandom::CvRandom
_TEXT	ENDS
PUBLIC	??8CvRandom@@QBE_NABV0@@Z			; CvRandom::operator==
; Function compile flags: /Odtp
;	COMDAT ??8CvRandom@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
??8CvRandom@@QBE_NABV0@@Z PROC				; CvRandom::operator==, COMDAT
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : #ifdef AUI_USE_SFMT_RNG
; 87   : 	return (m_MersenneTwister == source.m_MersenneTwister);
; 88   : #else
; 89   : 	return(m_ulRandomSeed == source.m_ulRandomSeed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _source$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 90   : #endif
; 91   : }

	mov	esp, ebp
	pop	ebp
	ret	4
??8CvRandom@@QBE_NABV0@@Z ENDP				; CvRandom::operator==
_TEXT	ENDS
PUBLIC	??9CvRandom@@QBE_NABV0@@Z			; CvRandom::operator!=
; Function compile flags: /Odtp
;	COMDAT ??9CvRandom@@QBE_NABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_source$ = 8						; size = 4
??9CvRandom@@QBE_NABV0@@Z PROC				; CvRandom::operator!=, COMDAT
; _this$ = ecx

; 94   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 	return !(*this == source);

	mov	eax, DWORD PTR _source$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8CvRandom@@QBE_NABV0@@Z		; CvRandom::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	4
??9CvRandom@@QBE_NABV0@@Z ENDP				; CvRandom::operator!=
_TEXT	ENDS
PUBLIC	?uninit@CvRandom@@QAEXXZ			; CvRandom::uninit
; Function compile flags: /Odtp
;	COMDAT ??1CvRandom@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvRandom@@UAE@XZ PROC				; CvRandom::~CvRandom, COMDAT
; _this$ = ecx

; 110  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvRandom@@6B@

; 111  : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvRandom@@QAEXXZ		; CvRandom::uninit

; 112  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvRandom@@UAE@XZ ENDP				; CvRandom::~CvRandom
_TEXT	ENDS
PUBLIC	?init@CvRandom@@QAEXK@Z				; CvRandom::init
; Function compile flags: /Odtp
;	COMDAT ?init@CvRandom@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ulSeed$ = 8						; size = 4
?init@CvRandom@@QAEXK@Z PROC				; CvRandom::init, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	//--------------------------------
; 122  : 	// Init saved data
; 123  : 	reset(ulSeed);

	mov	eax, DWORD PTR _ulSeed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvRandom@@QAEXK@Z		; CvRandom::reset

; 124  : 
; 125  : 	//--------------------------------
; 126  : 	// Init non-saved data
; 127  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?init@CvRandom@@QAEXK@Z ENDP				; CvRandom::init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?uninit@CvRandom@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?uninit@CvRandom@@QAEXXZ PROC				; CvRandom::uninit, COMDAT
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?uninit@CvRandom@@QAEXXZ ENDP				; CvRandom::uninit
_TEXT	ENDS
PUBLIC	?recordCallStack@CvRandom@@IAEXXZ		; CvRandom::recordCallStack
; Function compile flags: /Odtp
;	COMDAT ?reset@CvRandom@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ulSeed$ = 8						; size = 4
?reset@CvRandom@@QAEXK@Z PROC				; CvRandom::reset, COMDAT
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 	//--------------------------------
; 144  : 	// Uninit class
; 145  : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvRandom@@QAEXXZ		; CvRandom::uninit

; 146  : 
; 147  : 	recordCallStack();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?recordCallStack@CvRandom@@IAEXXZ	; CvRandom::recordCallStack

; 148  : #ifdef AUI_USE_SFMT_RNG
; 149  : 	m_MersenneTwister.sfmt_init_gen_rand(uiSeed);
; 150  : 	m_ulCallCount = 0;
; 151  : 	m_ulRandomSeed = uiSeed;
; 152  : #else
; 153  : 	m_ulRandomSeed = ulSeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ulSeed$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 154  : #endif
; 155  : 	m_ulResetCount++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@CvRandom@@QAEXK@Z ENDP				; CvRandom::reset
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0EAA@@@YAHAAY0EAA@DPBDZZ		; sprintf_s<1024>
PUBLIC	??_C@_0CB@EDJHIBHJ@?$CFd?0?5?$CFd?0?5?$CFu?0?5?$CFu?0?5?$CFu?0?5?$CF8x?0?5?$CFs?0?5?$CFs?6@ ; `string'
PUBLIC	?getSeed@CvRandom@@QBEKXZ			; CvRandom::getSeed
PUBLIC	??_C@_05CJEJCJOE@async?$AA@			; `string'
PUBLIC	??_C@_04JNABKDKF@sync?$AA@			; `string'
PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	??_C@_0O@BKOLNEMA@RandCalls?4csv?$AA@		; `string'
PUBLIC	??_C@_0EF@DFMDGHCE@Game?5Turn?0?5Turn?5Slice?0?5Range?0?5Va@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?get@CvRandom@@QAEGGPBD@Z			; CvRandom::get
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getTurnSlice@CvGame@@QBEHXZ:PROC		; CvGame::getTurnSlice
EXTRN	?getRandLogging@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getRandLogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0CB@EDJHIBHJ@?$CFd?0?5?$CFd?0?5?$CFu?0?5?$CFu?0?5?$CFu?0?5?$CF8x?0?5?$CFs?0?5?$CFs?6@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CB@EDJHIBHJ@?$CFd?0?5?$CFd?0?5?$CFu?0?5?$CFu?0?5?$CFu?0?5?$CF8x?0?5?$CFs?0?5?$CFs?6@ DB '%'
	DB	'd, %d, %u, %u, %u, %8x, %s, %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CJEJCJOE@async?$AA@
CONST	SEGMENT
??_C@_05CJEJCJOE@async?$AA@ DB 'async', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNABKDKF@sync?$AA@
CONST	SEGMENT
??_C@_04JNABKDKF@sync?$AA@ DB 'sync', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BKOLNEMA@RandCalls?4csv?$AA@
CONST	SEGMENT
??_C@_0O@BKOLNEMA@RandCalls?4csv?$AA@ DB 'RandCalls.csv', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DFMDGHCE@Game?5Turn?0?5Turn?5Slice?0?5Range?0?5Va@
CONST	SEGMENT
??_C@_0EF@DFMDGHCE@Game?5Turn?0?5Turn?5Slice?0?5Range?0?5Va@ DB 'Game Tur'
	DB	'n, Turn Slice, Range, Value, Seed, Instance, Type, Location', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvrandom.cpp
CONST	ENDS
;	COMDAT ?get@CvRandom@@QAEGGPBD@Z
_TEXT	SEGMENT
tv149 = -1064						; size = 4
tv144 = -1060						; size = 4
tv131 = -1056						; size = 4
_this$ = -1052						; size = 4
_szOut$220202 = -1048					; size = 1024
__$ArrayPad$ = -24					; size = 4
_pLog$220198 = -20					; size = 4
_kGame$220195 = -16					; size = 4
_iRandLogging$220192 = -12				; size = 4
_us$ = -8						; size = 2
_ulNewSeed$ = -4					; size = 4
_usNum$ = 8						; size = 2
_pszLog$ = 12						; size = 4
?get@CvRandom@@QAEGGPBD@Z PROC				; CvRandom::get, COMDAT
; _this$ = ecx

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1064				; 00000428H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 164  : #ifdef AUI_USE_SFMT_RNG
; 165  : 	unsigned int uiRtnValue = 0;
; 166  : 	if (uiNum > 1)
; 167  : 	{
; 168  : 		recordCallStack();
; 169  : 		m_ulCallCount++;
; 170  : 		uiRtnValue = m_MersenneTwister.sfmt_genrand_uint32() % uiNum;
; 171  : 	}
; 172  : #else
; 173  : 	recordCallStack();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?recordCallStack@CvRandom@@IAEXXZ	; CvRandom::recordCallStack

; 174  : 	m_ulCallCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 175  : 
; 176  : 	unsigned long ulNewSeed = ((RANDOM_A * m_ulRandomSeed) + RANDOM_C);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 1103515245				; 41c64e6dH
	add	ecx, 12345				; 00003039H
	mov	DWORD PTR _ulNewSeed$[ebp], ecx

; 177  : #ifdef AUI_WARNING_FIXES
; 178  : 	unsigned short us = ((unsigned short)((((ulNewSeed >> RANDOM_SHIFT) & MAX_UNSIGNED_SHORT) * (uiNum)) / (MAX_UNSIGNED_SHORT + 1)));
; 179  : #else
; 180  : 	unsigned short us = ((unsigned short)((((ulNewSeed >> RANDOM_SHIFT) & MAX_UNSIGNED_SHORT) * ((unsigned long)usNum)) / (MAX_UNSIGNED_SHORT + 1)));

	mov	edx, DWORD PTR _ulNewSeed$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 65535				; 0000ffffH
	movzx	eax, WORD PTR _usNum$[ebp]
	imul	edx, eax
	shr	edx, 16					; 00000010H
	mov	WORD PTR _us$[ebp], dx

; 181  : #endif
; 182  : #endif
; 183  : 
; 184  : 	if(GC.getLogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@get

; 185  : 	{
; 186  : 		int iRandLogging = GC.getRandLogging();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRandLogging@CvGlobals@@QAEHXZ	; CvGlobals::getRandLogging
	mov	DWORD PTR _iRandLogging$220192[ebp], eax

; 187  : 		if(iRandLogging > 0 && (m_bSynchronous || (iRandLogging & RAND_LOGGING_ASYNCHRONOUS_FLAG) != 0))

	cmp	DWORD PTR _iRandLogging$220192[ebp], 0
	jle	$LN6@get
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+16]
	test	eax, eax
	jne	SHORT $LN4@get
	mov	ecx, DWORD PTR _iRandLogging$220192[ebp]
	and	ecx, 8
	je	$LN6@get
$LN4@get:

; 188  : 		{
; 189  : #if !defined(FINAL_RELEASE)
; 190  : 			if(!gDLL->IsGameCoreThread() && gDLL->IsGameCoreExecuting() && m_bSynchronous)
; 191  : 			{
; 192  : 				CvAssertMsg(0, "App side is accessing the synchronous random number generator while the game core is running.");
; 193  : 			}
; 194  : #endif
; 195  : 			CvGame& kGame = GC.getGame();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR _kGame$220195[ebp], edx

; 196  : 			if(kGame.getTurnSlice() > 0 || ((iRandLogging & RAND_LOGGING_PREGAME_FLAG) != 0))

	mov	ecx, DWORD PTR _kGame$220195[ebp]
	call	?getTurnSlice@CvGame@@QBEHXZ		; CvGame::getTurnSlice
	test	eax, eax
	jg	SHORT $LN2@get
	mov	eax, DWORD PTR _iRandLogging$220192[ebp]
	and	eax, 4
	je	$LN6@get
$LN2@get:

; 197  : 			{
; 198  : #ifdef AUI_USE_SFMT_RNG
; 199  : 				FILogFile* pLog = LOGFILEMGR.GetLog("RandCalls.csv", FILogFile::kDontTimeStamp, "Game Turn, Turn Slice, Range, Value, Initial Seed, Call Count, Instance, Type, Location\n");
; 200  : #else
; 201  : 				FILogFile* pLog = LOGFILEMGR.GetLog("RandCalls.csv", FILogFile::kDontTimeStamp, "Game Turn, Turn Slice, Range, Value, Seed, Instance, Type, Location\n");

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	DWORD PTR tv131[ebp], eax
	push	OFFSET ??_C@_0EF@DFMDGHCE@Game?5Turn?0?5Turn?5Slice?0?5Range?0?5Va@
	push	1
	push	OFFSET ??_C@_0O@BKOLNEMA@RandCalls?4csv?$AA@
	mov	ecx, DWORD PTR tv131[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv131[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pLog$220198[ebp], eax

; 202  : #endif
; 203  : 				if(pLog)

	cmp	DWORD PTR _pLog$220198[ebp], 0
	je	$LN6@get

; 204  : 				{
; 205  : 					char szOut[1024] = {0};

	mov	BYTE PTR _szOut$220202[ebp], 0
	push	1023					; 000003ffH
	push	0
	lea	ecx, DWORD PTR _szOut$220202[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 206  : #ifdef AUI_USE_SFMT_RNG
; 207  : 					sprintf_s(szOut, "%d, %d, %u, %u, %u, %u, %8x, %s, %s\n", kGame.getGameTurn(), kGame.getTurnSlice(), uiNum, uiRtnValue, m_ulRandomSeed, m_ulCallCount, (intptr_t)this, m_bSynchronous ? "sync" : "async", (pszLog != NULL) ? pszLog : "Unknown");
; 208  : #elif defined(AUI_WARNING_FIXES)
; 209  : 					sprintf_s(szOut, "%d, %d, %u, %u, %u, %8x, %s, %s\n", kGame.getGameTurn(), kGame.getTurnSlice(), uiNum, (uint)us, getSeed(), (intptr_t)this, m_bSynchronous ? "sync" : "async", (pszLog != NULL) ? pszLog : "Unknown");
; 210  : #else
; 211  : 					sprintf_s(szOut, "%d, %d, %u, %u, %u, %8x, %s, %s\n", kGame.getGameTurn(), kGame.getTurnSlice(), (uint)usNum, (uint)us, getSeed(), (uint)this, m_bSynchronous?"sync":"async", (pszLog != NULL)?pszLog:"Unknown");

	cmp	DWORD PTR _pszLog$[ebp], 0
	je	SHORT $LN9@get
	mov	edx, DWORD PTR _pszLog$[ebp]
	mov	DWORD PTR tv144[ebp], edx
	jmp	SHORT $LN10@get
$LN9@get:
	mov	DWORD PTR tv144[ebp], OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
$LN10@get:
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN11@get
	mov	DWORD PTR tv149[ebp], OFFSET ??_C@_04JNABKDKF@sync?$AA@
	jmp	SHORT $LN12@get
$LN11@get:
	mov	DWORD PTR tv149[ebp], OFFSET ??_C@_05CJEJCJOE@async?$AA@
$LN12@get:
	mov	edx, DWORD PTR tv144[ebp]
	push	edx
	mov	eax, DWORD PTR tv149[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSeed@CvRandom@@QBEKXZ		; CvRandom::getSeed
	push	eax
	movzx	edx, WORD PTR _us$[ebp]
	push	edx
	movzx	eax, WORD PTR _usNum$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kGame$220195[ebp]
	call	?getTurnSlice@CvGame@@QBEHXZ		; CvGame::getTurnSlice
	push	eax
	mov	ecx, DWORD PTR _kGame$220195[ebp]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	push	eax
	push	OFFSET ??_C@_0CB@EDJHIBHJ@?$CFd?0?5?$CFd?0?5?$CFu?0?5?$CFu?0?5?$CFu?0?5?$CF8x?0?5?$CFs?0?5?$CFs?6@
	lea	ecx, DWORD PTR _szOut$220202[ebp]
	push	ecx
	call	??$sprintf_s@$0EAA@@@YAHAAY0EAA@DPBDZZ	; sprintf_s<1024>
	add	esp, 40					; 00000028H

; 212  : #endif
; 213  : 					pLog->Msg(szOut);

	lea	edx, DWORD PTR _szOut$220202[ebp]
	push	edx
	mov	eax, DWORD PTR _pLog$220198[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pLog$220198[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx]
	call	eax
	add	esp, 8
$LN6@get:

; 214  : 
; 215  : #if !defined(FINAL_RELEASE)
; 216  : 					if((iRandLogging & RAND_LOGGING_CALLSTACK_FLAG) != 0)
; 217  : 					{
; 218  : #ifdef _DEBUG
; 219  : 						if(m_bExtendedCallStackDebugging)
; 220  : 						{
; 221  : 							// Use the callstack from the extended callstack debugging system
; 222  : 							const FCallStack& callStack = m_kCallStacks.back();
; 223  : 							std::string stackTrace = callStack.toString(true, 6);
; 224  : 							pLog->Msg(stackTrace.c_str());
; 225  : 						}
; 226  : 						else
; 227  : #endif
; 228  : 						{
; 229  : #ifdef WIN32
; 230  : 							// Get callstack directly
; 231  : 							FCallStack callStack;
; 232  : 							FDebugHelper::GetInstance().GetCallStack(&callStack, 0, 8);
; 233  : 							std::string stackTrace = callStack.toString(true, 6);
; 234  : 							pLog->Msg(stackTrace.c_str());
; 235  : #endif
; 236  : 						}
; 237  : 					}
; 238  : #endif
; 239  : 				}
; 240  : 			}
; 241  : 		}
; 242  : 	}
; 243  : 
; 244  : #ifdef AUI_USE_SFMT_RNG
; 245  : 	return uiRtnValue;
; 246  : #else
; 247  : 	m_ulRandomSeed = ulNewSeed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ulNewSeed$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 248  : #ifdef AUI_WARNING_FIXES
; 249  : 	return (uint)us;
; 250  : #else
; 251  : 	return us;

	mov	ax, WORD PTR _us$[ebp]

; 252  : #endif
; 253  : #endif
; 254  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?get@CvRandom@@QAEGGPBD@Z ENDP				; CvRandom::get
_TEXT	ENDS
PUBLIC	__real@477fff00
PUBLIC	?getFloat@CvRandom@@QAEMXZ			; CvRandom::getFloat
EXTRN	__fltused:DWORD
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?getFloat@CvRandom@@QAEMXZ
_TEXT	SEGMENT
tv74 = -8						; size = 4
_this$ = -4						; size = 4
?getFloat@CvRandom@@QAEMXZ PROC				; CvRandom::getFloat, COMDAT
; _this$ = ecx

; 355  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 356  : #ifdef AUI_USE_SFMT_RNG
; 357  : 	return 1.0f;
; 358  : #else
; 359  : 	return (((float)(get(MAX_UNSIGNED_SHORT))) / ((float)MAX_UNSIGNED_SHORT));

	push	0
	push	65535					; 0000ffffH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	eax, ax
	mov	DWORD PTR tv74[ebp], eax
	fild	DWORD PTR tv74[ebp]
	fdiv	DWORD PTR __real@477fff00

; 360  : #endif
; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getFloat@CvRandom@@QAEMXZ ENDP				; CvRandom::getFloat
_TEXT	ENDS
PUBLIC	?reseed@CvRandom@@QAEXK@Z			; CvRandom::reseed
; Function compile flags: /Odtp
;	COMDAT ?reseed@CvRandom@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ulNewValue$ = 8					; size = 4
?reseed@CvRandom@@QAEXK@Z PROC				; CvRandom::reseed, COMDAT
; _this$ = ecx

; 369  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 	recordCallStack();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?recordCallStack@CvRandom@@IAEXXZ	; CvRandom::recordCallStack

; 371  : 	m_ulResetCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 372  : #ifdef AUI_USE_SFMT_RNG
; 373  : 	m_ulCallCount = 0;
; 374  : 	m_MersenneTwister.sfmt_init_gen_rand(uiNewSeed);
; 375  : 	m_ulRandomSeed = uiNewSeed;
; 376  : #else
; 377  : 	m_ulRandomSeed = ulNewValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ulNewValue$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 378  : #endif
; 379  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?reseed@CvRandom@@QAEXK@Z ENDP				; CvRandom::reseed
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getSeed@CvRandom@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSeed@CvRandom@@QBEKXZ PROC				; CvRandom::getSeed, COMDAT
; _this$ = ecx

; 389  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 390  : 	return m_ulRandomSeed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 391  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSeed@CvRandom@@QBEKXZ ENDP				; CvRandom::getSeed
_TEXT	ENDS
PUBLIC	?getCallCount@CvRandom@@QBEKXZ			; CvRandom::getCallCount
; Function compile flags: /Odtp
;	COMDAT ?getCallCount@CvRandom@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCallCount@CvRandom@@QBEKXZ PROC			; CvRandom::getCallCount, COMDAT
; _this$ = ecx

; 395  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 	return m_ulCallCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 397  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getCallCount@CvRandom@@QBEKXZ ENDP			; CvRandom::getCallCount
_TEXT	ENDS
PUBLIC	?getResetCount@CvRandom@@QBEKXZ			; CvRandom::getResetCount
; Function compile flags: /Odtp
;	COMDAT ?getResetCount@CvRandom@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getResetCount@CvRandom@@QBEKXZ PROC			; CvRandom::getResetCount, COMDAT
; _this$ = ecx

; 400  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 401  : 	return m_ulResetCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getResetCount@CvRandom@@QBEKXZ ENDP			; CvRandom::getResetCount
_TEXT	ENDS
PUBLIC	?read@CvRandom@@QAEXAAVFDataStream@@@Z		; CvRandom::read
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAK@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?read@CvRandom@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uiVersion$ = -8					; size = 4
_b$ = -1						; size = 1
_kStream$ = 8						; size = 4
?read@CvRandom@@QAEXAAVFDataStream@@@Z PROC		; CvRandom::read, COMDAT
; _this$ = ecx

; 405  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 406  : 	reset();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvRandom@@QAEXK@Z		; CvRandom::reset

; 407  : 
; 408  : 	// Version number to maintain backwards compatibility
; 409  : 	uint uiVersion;
; 410  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 411  : 
; 412  : #ifdef AUI_USE_SFMT_RNG
; 413  : 	kStream >> m_MersenneTwister;
; 414  : #endif
; 415  : 	kStream >> m_ulRandomSeed;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 416  : 	kStream >> m_ulCallCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 417  : 	kStream >> m_ulResetCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 418  : #ifdef _DEBUG
; 419  : 	kStream >> m_bExtendedCallStackDebugging;
; 420  : 	if(m_bExtendedCallStackDebugging)
; 421  : 	{
; 422  : 		kStream >> m_seedHistory;
; 423  : 		kStream >> m_resolvedCallStacks;
; 424  : 	}
; 425  : #else
; 426  : 	bool b;
; 427  : 	kStream >> b;

	lea	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 428  : #endif//_DEBUG
; 429  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?read@CvRandom@@QAEXAAVFDataStream@@@Z ENDP		; CvRandom::read
_TEXT	ENDS
PUBLIC	?write@CvRandom@@QBEXAAVFDataStream@@@Z		; CvRandom::write
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABK@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?write@CvRandom@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T221313 = -5						; size = 1
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?write@CvRandom@@QBEXAAVFDataStream@@@Z PROC		; CvRandom::write, COMDAT
; _this$ = ecx

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 434  : 	// Current version number
; 435  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 436  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 437  : 
; 438  : #ifdef AUI_USE_SFMT_RNG
; 439  : 	kStream << m_MersenneTwister;
; 440  : #endif
; 441  : 	kStream << m_ulRandomSeed;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 442  : 	kStream << m_ulCallCount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 443  : 	kStream << m_ulResetCount;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 444  : #ifdef _DEBUG
; 445  : 	kStream << m_bExtendedCallStackDebugging;
; 446  : 	if(m_bExtendedCallStackDebugging)
; 447  : 	{
; 448  : 		resolveCallStacks();
; 449  : 		kStream << m_seedHistory;
; 450  : 		kStream << m_resolvedCallStacks;
; 451  : 	}
; 452  : #else
; 453  : 	kStream << false;

	mov	BYTE PTR $T221313[ebp], 0
	lea	ecx, DWORD PTR $T221313[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 454  : #endif
; 455  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write@CvRandom@@QBEXAAVFDataStream@@@Z ENDP		; CvRandom::write
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?recordCallStack@CvRandom@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?recordCallStack@CvRandom@@IAEXXZ PROC			; CvRandom::recordCallStack, COMDAT
; _this$ = ecx

; 458  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 459  : #ifdef _DEBUG
; 460  : 	if(m_bExtendedCallStackDebugging)
; 461  : 	{
; 462  : 		FDebugHelper& debugHelper = FDebugHelper::GetInstance();
; 463  : 		FCallStack callStack;
; 464  : 		debugHelper.GetCallStack(&callStack, 1, 8);
; 465  : 		m_kCallStacks.push_back(callStack);
; 466  : 		m_seedHistory.push_back(m_ulRandomSeed);
; 467  : 	}
; 468  : #endif//_DEBUG
; 469  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?recordCallStack@CvRandom@@IAEXXZ ENDP			; CvRandom::recordCallStack
_TEXT	ENDS
PUBLIC	?resolveCallStacks@CvRandom@@QBEXXZ		; CvRandom::resolveCallStacks
; Function compile flags: /Odtp
;	COMDAT ?resolveCallStacks@CvRandom@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?resolveCallStacks@CvRandom@@QBEXXZ PROC		; CvRandom::resolveCallStacks, COMDAT
; _this$ = ecx

; 472  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 473  : #ifdef _DEBUG
; 474  : 	std::vector<FCallStack>::const_iterator i;
; 475  : 	for(i = m_kCallStacks.begin() + m_resolvedCallStacks.size(); i != m_kCallStacks.end(); ++i)
; 476  : 	{
; 477  : 		const FCallStack callStack = *i;
; 478  : 		std::string stackTrace = callStack.toString(true);
; 479  : 		m_resolvedCallStacks.push_back(stackTrace);
; 480  : 	}
; 481  : #endif//_DEBUG
; 482  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?resolveCallStacks@CvRandom@@QBEXXZ ENDP		; CvRandom::resolveCallStacks
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
PUBLIC	?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; CvRandom::getResolvedCallStacks
EXTRN	_atexit:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__CxxThrowException@8:PROC
;	COMDAT ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_BSS	SEGMENT
?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A DB 010H DUP (?) ; `CvRandom::getResolvedCallStacks'::`2'::empty
_BSS	ENDS
;	COMDAT ?$S1@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4IA
_BSS	SEGMENT
?$S1@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4IA DD 01H DUP (?) ; `CvRandom::getResolvedCallStacks'::`2'::$S1
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$1
__ehfuncinfo$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvrandom.cpp
xdata$x	ENDS
;	COMDAT ?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
_TEXT	SEGMENT
tv95 = -132						; size = 4
tv152 = -128						; size = 4
_this$ = -124						; size = 4
$T221366 = -30						; size = 1
$T221353 = -29						; size = 1
$T221349 = -28						; size = 4
$T221342 = -20						; size = 4
__$EHRec$ = -12						; size = 12
?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ PROC ; CvRandom::getResolvedCallStacks, COMDAT
; _this$ = ecx

; 485  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 486  : #ifdef _DEBUG
; 487  : 	return m_resolvedCallStacks;
; 488  : #else
; 489  : 	static std::vector<std::string> empty;

	mov	eax, DWORD PTR ?$S1@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4IA
	and	eax, 1
	jne	SHORT $LN1@getResolve
	mov	ecx, DWORD PTR ?$S1@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T221366[ebp]
	mov	DWORD PTR $T221342[ebp], edx
	lea	eax, DWORD PTR $T221353[ebp]
	mov	DWORD PTR $T221349[ebp], eax
	mov	DWORD PTR tv152[ebp], OFFSET ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A
	mov	DWORD PTR tv95[ebp], OFFSET ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, OFFSET ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A
	call	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	push	OFFSET ??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ ; `CvRandom::getResolvedCallStacks'::`2'::`dynamic atexit destructor for 'empty''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@getResolve:

; 490  : 	return empty;

	mov	eax, OFFSET ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A

; 491  : #endif//_debug
; 492  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$0:
	mov	eax, DWORD PTR ?$S1@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4IA, eax
	ret	0
__unwindfunclet$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$1:
	mov	ecx, OFFSET ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A
	jmp	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
__ehhandler$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ENDP ; CvRandom::getResolvedCallStacks
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ$0
__ehfuncinfo$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ PROC ; `CvRandom::getResolvedCallStacks'::`2'::`dynamic atexit destructor for 'empty'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ$0:
	mov	ecx, OFFSET ?empty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@4V34@A
	jmp	??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
__ehhandler$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Fempty@?1??getResolvedCallStacks@CvRandom@@QBEABV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ@YAXXZ ENDP ; `CvRandom::getResolvedCallStacks'::`2'::`dynamic atexit destructor for 'empty''
PUBLIC	??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::~_Vector_val<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
PUBLIC	?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ ; CvRandom::getSeedHistory
;	COMDAT ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_BSS	SEGMENT
?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A DB 010H DUP (?) ; `CvRandom::getSeedHistory'::`2'::empty
_BSS	ENDS
;	COMDAT ?$S2@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4IA
_BSS	SEGMENT
?$S2@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4IA DD 01H DUP (?) ; `CvRandom::getSeedHistory'::`2'::$S2
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ$1
__ehfuncinfo$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvrandom.cpp
xdata$x	ENDS
;	COMDAT ?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ
_TEXT	SEGMENT
tv95 = -132						; size = 4
tv152 = -128						; size = 4
_this$ = -124						; size = 4
$T221579 = -30						; size = 1
$T221566 = -29						; size = 1
$T221562 = -28						; size = 4
$T221555 = -20						; size = 4
__$EHRec$ = -12						; size = 12
?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ PROC ; CvRandom::getSeedHistory, COMDAT
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 496  : #ifdef _DEBUG
; 497  : 	return m_seedHistory;
; 498  : #else
; 499  : 	static std::vector<unsigned long> empty;

	mov	eax, DWORD PTR ?$S2@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4IA
	and	eax, 1
	jne	SHORT $LN1@getSeedHis
	mov	ecx, DWORD PTR ?$S2@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S2@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T221579[ebp]
	mov	DWORD PTR $T221555[ebp], edx
	lea	eax, DWORD PTR $T221566[ebp]
	mov	DWORD PTR $T221562[ebp], eax
	mov	DWORD PTR tv152[ebp], OFFSET ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A
	mov	DWORD PTR tv95[ebp], OFFSET ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	0
	mov	ecx, OFFSET ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A
	call	?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	push	OFFSET ??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ ; `CvRandom::getSeedHistory'::`2'::`dynamic atexit destructor for 'empty''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@getSeedHis:

; 500  : 	return empty;

	mov	eax, OFFSET ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A

; 501  : #endif//_DEBUG
; 502  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ$0:
	mov	eax, DWORD PTR ?$S2@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S2@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4IA, eax
	ret	0
__unwindfunclet$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ$1:
	mov	ecx, OFFSET ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A
	jmp	??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
__ehhandler$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ ENDP ; CvRandom::getSeedHistory
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ$0
__ehfuncinfo$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ PROC ; `CvRandom::getSeedHistory'::`2'::`dynamic atexit destructor for 'empty'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A
	call	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ$0:
	mov	ecx, OFFSET ?empty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@4V34@A
	jmp	??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
__ehhandler$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Fempty@?1??getSeedHistory@CvRandom@@QBEABV?$vector@KV?$allocator@K@std@@@std@@XZ@YAXXZ ENDP ; `CvRandom::getSeedHistory'::`2'::`dynamic atexit destructor for 'empty''
PUBLIC	?callStackDebuggingEnabled@CvRandom@@QBE_NXZ	; CvRandom::callStackDebuggingEnabled
; Function compile flags: /Odtp
;	COMDAT ?callStackDebuggingEnabled@CvRandom@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?callStackDebuggingEnabled@CvRandom@@QBE_NXZ PROC	; CvRandom::callStackDebuggingEnabled, COMDAT
; _this$ = ecx

; 505  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 506  : #ifdef _DEBUG
; 507  : 	return m_bExtendedCallStackDebugging;
; 508  : #else
; 509  : 	return false;

	xor	al, al

; 510  : #endif//_DEBUG
; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?callStackDebuggingEnabled@CvRandom@@QBE_NXZ ENDP	; CvRandom::callStackDebuggingEnabled
_TEXT	ENDS
PUBLIC	?setCallStackDebuggingEnabled@CvRandom@@QAEX_N@Z ; CvRandom::setCallStackDebuggingEnabled
; Function compile flags: /Odtp
;	COMDAT ?setCallStackDebuggingEnabled@CvRandom@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_enabled$ = 8						; size = 1
?setCallStackDebuggingEnabled@CvRandom@@QAEX_N@Z PROC	; CvRandom::setCallStackDebuggingEnabled, COMDAT
; _this$ = ecx

; 514  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 515  : #ifdef _DEBUG
; 516  : 	m_bExtendedCallStackDebugging = enabled;
; 517  : #endif//_DEBUG
; 518  : 	enabled;
; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setCallStackDebuggingEnabled@CvRandom@@QAEX_N@Z ENDP	; CvRandom::setCallStackDebuggingEnabled
_TEXT	ENDS
PUBLIC	?clearCallstacks@CvRandom@@QAEXXZ		; CvRandom::clearCallstacks
; Function compile flags: /Odtp
;	COMDAT ?clearCallstacks@CvRandom@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clearCallstacks@CvRandom@@QAEXXZ PROC			; CvRandom::clearCallstacks, COMDAT
; _this$ = ecx

; 522  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 523  : #ifdef _DEBUG
; 524  : 	m_kCallStacks.clear();
; 525  : 	m_seedHistory.clear();
; 526  : 	m_resolvedCallStacks.clear();
; 527  : #endif//_DEBUG
; 528  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clearCallstacks@CvRandom@@QAEXXZ ENDP			; CvRandom::clearCallstacks
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvRandom@@@Z	; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvRandom@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvRandom@@@Z PROC		; operator<<, COMDAT

; 530  : {

	push	ebp
	mov	ebp, esp

; 531  : 	readFrom.write(saveTo);

	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?write@CvRandom@@QBEXAAVFDataStream@@@Z	; CvRandom::write

; 532  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 533  : }

	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvRandom@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvRandom@@@Z	; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvRandom@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvRandom@@@Z PROC		; operator>>, COMDAT

; 536  : {

	push	ebp
	mov	ebp, esp

; 537  : 	writeTo.read(loadFrom);

	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?read@CvRandom@@QAEXAAVFDataStream@@@Z	; CvRandom::read

; 538  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 539  : }

	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvRandom@@@Z ENDP		; operator>>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::~_Vector_val<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned long,std::allocator<unsigned long> >::~_Vector_val<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$221742 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$221742[ebp], 153391689 ; 09249249H
	cmp	DWORD PTR __Count$221742[ebp], 0
	jbe	SHORT $LN11@Buy
	mov	eax, DWORD PTR __Count$221742[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy
$LN11@Buy:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
_TEXT	ENDS
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T221856 = -36						; size = 4
$T221855 = -32						; size = 4
$T221851 = -28						; size = 4
$T221850 = -24						; size = 4
$T221829 = -20						; size = 4
$T221828 = -16						; size = 4
$T221809 = -12						; size = 4
$T221808 = -8						; size = 4
__Cat$221836 = -2					; size = 1
$T221833 = -1						; size = 1
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221851[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221850[ebp], ecx
	mov	edx, DWORD PTR $T221851[ebp]
	mov	DWORD PTR $T221829[ebp], edx
	mov	eax, DWORD PTR $T221850[ebp]
	mov	DWORD PTR $T221828[ebp], eax
	mov	cl, BYTE PTR __Cat$221836[ebp]
	mov	BYTE PTR $T221833[ebp], cl
	mov	edx, DWORD PTR $T221829[ebp]
	mov	DWORD PTR $T221809[ebp], edx
	mov	eax, DWORD PTR $T221828[ebp]
	mov	DWORD PTR $T221808[ebp], eax
	jmp	SHORT $LN12@Tidy
$LN11@Tidy:
	mov	ecx, DWORD PTR $T221808[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR $T221808[ebp], ecx
$LN12@Tidy:
	mov	edx, DWORD PTR $T221808[ebp]
	cmp	edx, DWORD PTR $T221809[ebp]
	je	SHORT $LN4@Tidy
	mov	ecx, DWORD PTR $T221808[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	eax, eax
	and	eax, 1
	je	SHORT $LN15@Tidy
	mov	ecx, DWORD PTR $T221808[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN15@Tidy:
	jmp	SHORT $LN11@Tidy
$LN4@Tidy:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR $T221856[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221855[ebp], eax
	mov	ecx, DWORD PTR $T221855[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Allocate@K@std@@YAPAKIPAK@Z			; std::_Allocate<unsigned long>
PUBLIC	?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
tv94 = -96						; size = 4
_this$ = -92						; size = 4
__Count$221871 = -4					; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	DWORD PTR __Count$221871[ebp], 1073741823 ; 3fffffffH
	cmp	DWORD PTR __Count$221871[ebp], 0
	jbe	SHORT $LN11@Buy@2
	mov	eax, DWORD PTR __Count$221871[ebp]
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN7@Buy@2
$LN11@Buy@2:
	mov	DWORD PTR tv94[ebp], 1
$LN7@Buy@2:
	mov	ecx, DWORD PTR tv94[ebp]
	cmp	ecx, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN23@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

$LN23@Buy@2:
	push	0
	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	call	??$_Allocate@K@std@@YAPAKIPAK@Z		; std::_Allocate<unsigned long>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@KV?$allocator@K@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T221937 = -28						; size = 4
$T221936 = -24						; size = 4
$T221932 = -20						; size = 4
$T221931 = -16						; size = 4
$T221920 = -12						; size = 4
$T221919 = -8						; size = 4
__Cat$221927 = -2					; size = 1
$T221924 = -1						; size = 1
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T221932[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T221931[ebp], ecx
	mov	edx, DWORD PTR $T221932[ebp]
	mov	DWORD PTR $T221920[ebp], edx
	mov	eax, DWORD PTR $T221931[ebp]
	mov	DWORD PTR $T221919[ebp], eax
	mov	cl, BYTE PTR __Cat$221927[ebp]
	mov	BYTE PTR $T221924[ebp], cl

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	mov	DWORD PTR $T221937[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T221936[ebp], eax
	mov	ecx, DWORD PTR $T221936[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T221941 = -80						; size = 28
$T221940 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221941[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T221940[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T221940[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T221941[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221940[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T221940[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221940[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T221941[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221941[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221940[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221963 = -80						; size = 28
$T221962 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221963[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T221962[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR $T221962[ebp], OFFSET ??_7logic_error@std@@6B@
	lea	eax, DWORD PTR $T221963[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221962[ebp+12]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T221962[ebp], OFFSET ??_7length_error@std@@6B@
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221962[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T221963[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221963[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221962[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@KV?$allocator@K@std@@@std@@KAXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlen
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$sprintf_s@$0EAA@@@YAHAAY0EAA@DPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0EAA@@@YAHAAY0EAA@DPBDZZ PROC		; sprintf_s<1024>, COMDAT

; 322  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, sprintf_s, vsprintf_s, char, _Dest, _In_z_ _Printf_format_string_ const char *, _Format)

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	1024					; 00000400H
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	mov	esp, ebp
	pop	ebp
	ret	0
??$sprintf_s@$0EAA@@@YAHAAY0EAA@DPBDZZ ENDP		; sprintf_s<1024>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_Ebad_alloc@std@@UAEPAXI@Z ; std::bad_alloc::`vftable'
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
CONST	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T221990 = -16						; size = 4
$T221986 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T221990[ebp], 0
	lea	eax, DWORD PTR $T221990[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221986[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T221986[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221986[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@K@std@@YAPAKIPAK@Z
_TEXT	SEGMENT
$T221997 = -16						; size = 4
$T221993 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@K@std@@YAPAKIPAK@Z PROC			; std::_Allocate<unsigned long>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	mov	DWORD PTR $T221997[ebp], 0
	lea	eax, DWORD PTR $T221997[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221993[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR $T221993[ebp], OFFSET ??_7bad_alloc@std@@6B@
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221993[ebp]
	push	ecx
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@K@std@@YAPAKIPAK@Z ENDP			; std::_Allocate<unsigned long>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	edx, DWORD PTR ___flags$[ebp]
	and	edx, 1
	je	SHORT $LN1@scalar@4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
END
