; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	D:\sources\Lekmod_git\checkout\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_sgCvMapInstanceCount DD 01H DUP (?)
_BSS	ENDS
PUBLIC	??_7CvLandmass@@6B@				; CvLandmass::`vftable'
PUBLIC	??0CvLandmass@@QAE@XZ				; CvLandmass::CvLandmass
PUBLIC	?read@CvLandmass@@UAEXAAVFDataStream@@@Z	; CvLandmass::read
PUBLIC	?write@CvLandmass@@UBEXAAVFDataStream@@@Z	; CvLandmass::write
EXTRN	??_ECvLandmass@@UAEPAXI@Z:PROC			; CvLandmass::`vector deleting destructor'
;	COMDAT ??_7CvLandmass@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
CONST	SEGMENT
??_7CvLandmass@@6B@ DD FLAT:??_ECvLandmass@@UAEPAXI@Z	; CvLandmass::`vftable'
	DD	FLAT:?read@CvLandmass@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?write@CvLandmass@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0CvLandmass@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CvLandmass@@QAE@XZ PROC				; CvLandmass::CvLandmass, COMDAT
; _this$ = ecx

; 39   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvLandmass@@6B@

; 40   : 	m_iID = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1

; 41   : 	m_iNumTiles = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 42   : 	m_bWater = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+13], 1

; 43   : 	m_cContinentType = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+12], 0

; 44   : 	m_iCentroidX = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 45   : 	m_iCentroidY = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 46   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CvLandmass@@QAE@XZ ENDP				; CvLandmass::CvLandmass
_TEXT	ENDS
PUBLIC	??1CvLandmass@@UAE@XZ				; CvLandmass::~CvLandmass
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GCvLandmass@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvLandmass@@UAEPAXI@Z PROC				; CvLandmass::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvLandmass@@UAE@XZ			; CvLandmass::~CvLandmass
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvLandmass@@UAEPAXI@Z ENDP				; CvLandmass::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CvLandmass@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvLandmass@@UAE@XZ PROC				; CvLandmass::~CvLandmass, COMDAT
; _this$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvLandmass@@6B@

; 51   : 
; 52   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CvLandmass@@UAE@XZ ENDP				; CvLandmass::~CvLandmass
_TEXT	ENDS
PUBLIC	?init@CvLandmass@@QAEXH_N@Z			; CvLandmass::init
; Function compile flags: /Odtp
;	COMDAT ?init@CvLandmass@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
_bWater$ = 12						; size = 1
?init@CvLandmass@@QAEXH_N@Z PROC			; CvLandmass::init, COMDAT
; _this$ = ecx

; 56   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 	m_iID = iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 58   : 	m_iNumTiles = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 59   : 	m_bWater = bWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bWater$[ebp]
	mov	BYTE PTR [eax+13], cl

; 60   : 	m_cContinentType = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], 0

; 61   : 	m_iCentroidX = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 62   : 	m_iCentroidY = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?init@CvLandmass@@QAEXH_N@Z ENDP			; CvLandmass::init
_TEXT	ENDS
PUBLIC	?GetID@CvLandmass@@QBEHXZ			; CvLandmass::GetID
; Function compile flags: /Odtp
;	COMDAT ?GetID@CvLandmass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetID@CvLandmass@@QBEHXZ PROC				; CvLandmass::GetID, COMDAT
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 	return m_iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 69   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetID@CvLandmass@@QBEHXZ ENDP				; CvLandmass::GetID
_TEXT	ENDS
PUBLIC	?SetID@CvLandmass@@QAEXH@Z			; CvLandmass::SetID
; Function compile flags: /Odtp
;	COMDAT ?SetID@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?SetID@CvLandmass@@QAEXH@Z PROC				; CvLandmass::SetID, COMDAT
; _this$ = ecx

; 73   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 	m_iID = iID;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iID$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 75   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetID@CvLandmass@@QAEXH@Z ENDP				; CvLandmass::SetID
_TEXT	ENDS
PUBLIC	?getNumTiles@CvLandmass@@QBEHXZ			; CvLandmass::getNumTiles
; Function compile flags: /Odtp
;	COMDAT ?getNumTiles@CvLandmass@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumTiles@CvLandmass@@QBEHXZ PROC			; CvLandmass::getNumTiles, COMDAT
; _this$ = ecx

; 79   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 	return m_iNumTiles;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumTiles@CvLandmass@@QBEHXZ ENDP			; CvLandmass::getNumTiles
_TEXT	ENDS
PUBLIC	?updateYield@CvMap@@QAEXXZ			; CvMap::updateYield
PUBLIC	?isLake@CvLandmass@@QBE_NXZ			; CvLandmass::isLake
PUBLIC	?changeNumTiles@CvLandmass@@QAEXH@Z		; CvLandmass::changeNumTiles
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Odtp
;	COMDAT ?changeNumTiles@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T236805 = -8						; size = 4
_bOldLake$234712 = -1					; size = 1
_iChange$ = 8						; size = 4
?changeNumTiles@CvLandmass@@QAEXH@Z PROC		; CvLandmass::changeNumTiles, COMDAT
; _this$ = ecx

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	if(iChange != 0)

	cmp	DWORD PTR _iChange$[ebp], 0
	je	SHORT $LN3@changeNumT

; 87   : 	{
; 88   : 		bool bOldLake = isLake();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLake@CvLandmass@@QBE_NXZ		; CvLandmass::isLake
	mov	BYTE PTR _bOldLake$234712[ebp], al

; 89   : 
; 90   : 		m_iNumTiles = (m_iNumTiles + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 91   : 		CvAssert(m_iNumTiles >= 0);
; 92   : 
; 93   : 		if(bOldLake != isLake())

	movzx	esi, BYTE PTR _bOldLake$234712[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLake@CvLandmass@@QBE_NXZ		; CvLandmass::isLake
	movzx	eax, al
	cmp	esi, eax
	je	SHORT $LN3@changeNumT

; 94   : 		{
; 95   : 			GC.getMap().updateYield();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T236805[ebp], ecx
	mov	ecx, DWORD PTR $T236805[ebp]
	call	?updateYield@CvMap@@QAEXXZ		; CvMap::updateYield
$LN3@changeNumT:

; 96   : 		}
; 97   : 	}
; 98   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?changeNumTiles@CvLandmass@@QAEXH@Z ENDP		; CvLandmass::changeNumTiles
_TEXT	ENDS
PUBLIC	?ChangeCentroidX@CvLandmass@@QAEXH@Z		; CvLandmass::ChangeCentroidX
; Function compile flags: /Odtp
;	COMDAT ?ChangeCentroidX@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeCentroidX@CvLandmass@@QAEXH@Z PROC		; CvLandmass::ChangeCentroidX, COMDAT
; _this$ = ecx

; 102  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	m_iCentroidX = (m_iCentroidX + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 104  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeCentroidX@CvLandmass@@QAEXH@Z ENDP		; CvLandmass::ChangeCentroidX
_TEXT	ENDS
PUBLIC	?ChangeCentroidY@CvLandmass@@QAEXH@Z		; CvLandmass::ChangeCentroidY
; Function compile flags: /Odtp
;	COMDAT ?ChangeCentroidY@CvLandmass@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeCentroidY@CvLandmass@@QAEXH@Z PROC		; CvLandmass::ChangeCentroidY, COMDAT
; _this$ = ecx

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	m_iCentroidY = (m_iCentroidY + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 110  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeCentroidY@CvLandmass@@QAEXH@Z ENDP		; CvLandmass::ChangeCentroidY
_TEXT	ENDS
PUBLIC	?isWater@CvLandmass@@QBE_NXZ			; CvLandmass::isWater
; Function compile flags: /Odtp
;	COMDAT ?isWater@CvLandmass@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isWater@CvLandmass@@QBE_NXZ PROC			; CvLandmass::isWater, COMDAT
; _this$ = ecx

; 114  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	return m_bWater;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+13]

; 116  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isWater@CvLandmass@@QBE_NXZ ENDP			; CvLandmass::isWater
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isLake@CvLandmass@@QBE_NXZ
_TEXT	SEGMENT
tv71 = -12						; size = 4
_this$ = -8						; size = 4
$T236819 = -4						; size = 4
?isLake@CvLandmass@@QBE_NXZ PROC			; CvLandmass::isLake, COMDAT
; _this$ = ecx

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 	return (m_bWater && (m_iNumTiles <= GC.getLAKE_MAX_AREA_SIZE()));

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+13]
	test	ecx, ecx
	je	SHORT $LN3@isLake
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6508
	mov	DWORD PTR $T236819[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR $T236819[ebp]
	jg	SHORT $LN3@isLake
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@isLake
$LN3@isLake:
	mov	DWORD PTR tv71[ebp], 0
$LN4@isLake:
	mov	al, BYTE PTR tv71[ebp]

; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isLake@CvLandmass@@QBE_NXZ ENDP			; CvLandmass::isLake
_TEXT	ENDS
PUBLIC	?GetContinentType@CvLandmass@@QBEDXZ		; CvLandmass::GetContinentType
; Function compile flags: /Odtp
;	COMDAT ?GetContinentType@CvLandmass@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetContinentType@CvLandmass@@QBEDXZ PROC		; CvLandmass::GetContinentType, COMDAT
; _this$ = ecx

; 131  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 	return m_cContinentType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+12]

; 133  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetContinentType@CvLandmass@@QBEDXZ ENDP		; CvLandmass::GetContinentType
_TEXT	ENDS
PUBLIC	?SetContinentType@CvLandmass@@QAEXD@Z		; CvLandmass::SetContinentType
; Function compile flags: /Odtp
;	COMDAT ?SetContinentType@CvLandmass@@QAEXD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cContinent$ = 8					; size = 1
?SetContinentType@CvLandmass@@QAEXD@Z PROC		; CvLandmass::SetContinentType, COMDAT
; _this$ = ecx

; 141  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 	m_cContinentType = cContinent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _cContinent$[ebp]
	mov	BYTE PTR [eax+12], cl

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetContinentType@CvLandmass@@QAEXD@Z ENDP		; CvLandmass::SetContinentType
_TEXT	ENDS
PUBLIC	?GetCentroidX@CvLandmass@@QAEHXZ		; CvLandmass::GetCentroidX
; Function compile flags: /Odtp
;	COMDAT ?GetCentroidX@CvLandmass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCentroidX@CvLandmass@@QAEHXZ PROC			; CvLandmass::GetCentroidX, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 	if(m_iNumTiles > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jle	SHORT $LN1@GetCentroi

; 149  : 	{
; 150  : 		return m_iCentroidX / m_iNumTiles;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	cdq
	idiv	DWORD PTR [esi+8]
	jmp	SHORT $LN2@GetCentroi
$LN1@GetCentroi:

; 151  : 
; 152  : 	}
; 153  : 	return -1;

	or	eax, -1
$LN2@GetCentroi:

; 154  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCentroidX@CvLandmass@@QAEHXZ ENDP			; CvLandmass::GetCentroidX
_TEXT	ENDS
PUBLIC	?GetCentroidY@CvLandmass@@QAEHXZ		; CvLandmass::GetCentroidY
; Function compile flags: /Odtp
;	COMDAT ?GetCentroidY@CvLandmass@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCentroidY@CvLandmass@@QAEHXZ PROC			; CvLandmass::GetCentroidY, COMDAT
; _this$ = ecx

; 158  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	if(m_iNumTiles > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jle	SHORT $LN1@GetCentroi@2

; 160  : 	{
; 161  : 		return m_iCentroidY / m_iNumTiles;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cdq
	idiv	DWORD PTR [esi+8]
	jmp	SHORT $LN2@GetCentroi@2
$LN1@GetCentroi@2:

; 162  : 
; 163  : 	}
; 164  : 	return -1;

	or	eax, -1
$LN2@GetCentroi@2:

; 165  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCentroidY@CvLandmass@@QAEHXZ ENDP			; CvLandmass::GetCentroidY
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAAD@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?read@CvLandmass@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?read@CvLandmass@@UAEXAAVFDataStream@@@Z PROC		; CvLandmass::read, COMDAT
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 	// Version number to maintain backwards compatibility
; 172  : 	uint uiVersion;
; 173  : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 174  : 
; 175  : 	kStream >> m_iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 176  : 	kStream >> m_iNumTiles;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 177  : 
; 178  : 	kStream >> m_iCentroidX;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 179  : 	kStream >> m_iCentroidY;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 180  : 
; 181  : 	kStream >> m_bWater;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 13					; 0000000dH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 182  : 
; 183  : 	kStream >> m_cContinentType;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAD@Z		; FDataStream::Read

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?read@CvLandmass@@UAEXAAVFDataStream@@@Z ENDP		; CvLandmass::read
_TEXT	ENDS
EXTRN	?Write@FDataStream@@IAEXABD@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?write@CvLandmass@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uiVersion$ = -4					; size = 4
_kStream$ = 8						; size = 4
?write@CvLandmass@@UBEXAAVFDataStream@@@Z PROC		; CvLandmass::write, COMDAT
; _this$ = ecx

; 188  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 	// Current version number
; 190  : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 191  : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 192  : 
; 193  : 	kStream << m_iID;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 194  : 	kStream << m_iNumTiles;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 195  : 
; 196  : 	kStream << m_iCentroidX;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 197  : 	kStream << m_iCentroidY;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 198  : 
; 199  : 	kStream << m_bWater;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 13					; 0000000dH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 200  : 
; 201  : 	kStream << m_cContinentType;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABD@Z		; FDataStream::Write

; 202  : 
; 203  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?write@CvLandmass@@UBEXAAVFDataStream@@@Z ENDP		; CvLandmass::write
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z	; operator<<
; Function compile flags: /Odtp
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z PROC	; operator<<, COMDAT

; 208  : {

	push	ebp
	mov	ebp, esp

; 209  : 	readFrom.write(saveTo);

	mov	eax, DWORD PTR _saveTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 210  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 211  : }

	pop	ebp
	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z	; operator>>
; Function compile flags: /Odtp
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z PROC	; operator>>, COMDAT

; 215  : {

	push	ebp
	mov	ebp, esp

; 216  : 	writeTo.read(loadFrom);

	mov	eax, DWORD PTR _loadFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 217  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 218  : }

	pop	ebp
	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ	; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
PUBLIC	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ	; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
PUBLIC	??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
PUBLIC	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z		; CvMap::reset
PUBLIC	??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ	; FFreeListTrashArray<CvLandmass>::FFreeListTrashArray<CvLandmass>
PUBLIC	??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ	; FFreeListTrashArray<CvArea>::FFreeListTrashArray<CvArea>
PUBLIC	??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::FStaticVector<CvPlot *,1000,1,297,1>
PUBLIC	??_7CvMap@@6B@					; CvMap::`vftable'
PUBLIC	??0CvMap@@QAE@XZ				; CvMap::CvMap
EXTRN	??1CvPlotManager@@QAE@XZ:PROC			; CvPlotManager::~CvPlotManager
EXTRN	??0CvPlotManager@@QAE@XZ:PROC			; CvPlotManager::CvPlotManager
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_ECvMap@@UAEPAXI@Z:PROC			; CvMap::`vector deleting destructor'
;	COMDAT ??_7CvMap@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
CONST	SEGMENT
??_7CvMap@@6B@ DD FLAT:??_ECvMap@@UAEPAXI@Z		; CvMap::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvMap@@QAE@XZ$3
__ehfuncinfo$??0CvMap@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ??0CvMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
_defaultMapData$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
??0CvMap@@QAE@XZ PROC					; CvMap::CvMap, COMDAT
; _this$ = ecx

; 227  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CvMap@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvMap@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::FStaticVector<CvPlot *,1000,1,297,1>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ ; FFreeListTrashArray<CvArea>::FFreeListTrashArray<CvArea>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ ; FFreeListTrashArray<CvLandmass>::FFreeListTrashArray<CvLandmass>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	call	??0CvPlotManager@@QAE@XZ		; CvPlotManager::CvPlotManager
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 228  : 	CvMapInitData defaultMapData;

	mov	DWORD PTR _defaultMapData$[ebp], 0
	mov	DWORD PTR _defaultMapData$[ebp+4], 0
	mov	DWORD PTR _defaultMapData$[ebp+8], 90	; 0000005aH
	mov	DWORD PTR _defaultMapData$[ebp+12], -90	; ffffffa6H
	mov	BYTE PTR _defaultMapData$[ebp+16], 1
	mov	BYTE PTR _defaultMapData$[ebp+17], 0

; 229  : 
; 230  : 	CvAssert(sgCvMapInstanceCount == 0);
; 231  : 	++sgCvMapInstanceCount;

	mov	ecx, DWORD PTR _sgCvMapInstanceCount
	add	ecx, 1
	mov	DWORD PTR _sgCvMapInstanceCount, ecx

; 232  : 
; 233  : 	m_paiNumResource = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4060], 0

; 234  : 	m_paiNumResourceOnLand = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4064], 0

; 235  : 
; 236  : 	m_pMapPlots = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4068], 0

; 237  : 
; 238  : 
; 239  : 	m_pYields = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4072], 0

; 240  : 	m_pFoundValue = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4076], 0

; 241  : 	m_pPlayerCityRadiusCount = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4080], 0

; 242  : 	m_pVisibilityCount = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4084], 0

; 243  : 	m_pRevealedOwner = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4088], 0

; 244  : 	m_pRevealed = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4092], 0

; 245  : 	m_pRevealedImprovementType = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4096], 0

; 246  : 	m_pRevealedRouteType = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4100], 0

; 247  : 	m_pNoSettling = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4104], 0

; 248  : 	m_pResourceForceReveal = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4108], 0

; 249  : 
; 250  : 	m_iAIMapHints = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4052], 0

; 251  : 
; 252  : 	reset(&defaultMapData);

	lea	ecx, DWORD PTR _defaultMapData$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::reset

; 253  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvMap@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
__unwindfunclet$??0CvMap@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	jmp	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
__unwindfunclet$??0CvMap@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	jmp	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
__unwindfunclet$??0CvMap@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	jmp	??1CvPlotManager@@QAE@XZ		; CvPlotManager::~CvPlotManager
__ehhandler$??0CvMap@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CvMap@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvMap@@QAE@XZ ENDP					; CvMap::CvMap
PUBLIC	??1CvMap@@UAE@XZ				; CvMap::~CvMap
; Function compile flags: /Odtp
;	COMDAT ??_GCvMap@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCvMap@@UAEPAXI@Z PROC				; CvMap::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvMap@@UAE@XZ			; CvMap::~CvMap
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCvMap@@UAEPAXI@Z ENDP				; CvMap::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?uninit@CvMap@@QAEXXZ				; CvMap::uninit
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvMap@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvMap@@UAE@XZ$3
__ehfuncinfo$??1CvMap@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvMap@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ??1CvMap@@UAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
__$EHRec$ = -12						; size = 12
??1CvMap@@UAE@XZ PROC					; CvMap::~CvMap, COMDAT
; _this$ = ecx

; 258  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CvMap@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7CvMap@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 259  : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvMap@@QAEXXZ			; CvMap::uninit

; 260  : 	--sgCvMapInstanceCount;

	mov	ecx, DWORD PTR _sgCvMapInstanceCount
	sub	ecx, 1
	mov	DWORD PTR _sgCvMapInstanceCount, ecx

; 261  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	call	??1CvPlotManager@@QAE@XZ		; CvPlotManager::~CvPlotManager
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvMap@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
__unwindfunclet$??1CvMap@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	jmp	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
__unwindfunclet$??1CvMap@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	jmp	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
__unwindfunclet$??1CvMap@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	jmp	??1CvPlotManager@@QAE@XZ		; CvPlotManager::~CvPlotManager
__ehhandler$??1CvMap@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1CvMap@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvMap@@UAE@XZ ENDP					; CvMap::~CvMap
PUBLIC	?InitPlots@CvMap@@IAEXXZ			; CvMap::InitPlots
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	?Init@CvPlotManager@@QAEXII@Z:PROC		; CvPlotManager::Init
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??0CvPlot@@QAE@XZ:PROC				; CvPlot::CvPlot
EXTRN	??1CvPlot@@QAE@XZ:PROC				; CvPlot::~CvPlot
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_memset:PROC
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
xdata$x	SEGMENT
__unwindtable$?InitPlots@CvMap@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitPlots@CvMap@@IAEXXZ$0
__ehfuncinfo$?InitPlots@CvMap@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InitPlots@CvMap@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ?InitPlots@CvMap@@IAEXXZ
_TEXT	SEGMENT
tv89 = -128						; size = 4
_this$ = -124						; size = 4
$T236983 = -120						; size = 4
$T236979 = -116						; size = 4
$T236972 = -112						; size = 4
$T236967 = -108						; size = 4
$T236966 = -104						; size = 4
$T236965 = -100						; size = 4
$T236964 = -96						; size = 4
$T236963 = -92						; size = 4
$T236962 = -88						; size = 4
$T236961 = -84						; size = 4
$T236960 = -80						; size = 4
$T236959 = -76						; size = 4
$T236958 = -72						; size = 4
$T236955 = -68						; size = 4
$T236954 = -64						; size = 4
$T236953 = -60						; size = 4
_i$234823 = -56						; size = 4
_pVisibilityCount$ = -52				; size = 4
_pRevealedImprovementType$ = -48			; size = 4
_pResourceForceReveal$ = -44				; size = 4
_pPlayerCityRadiusCount$ = -40				; size = 4
_pRevealedRouteType$ = -36				; size = 4
_iNumPlots$ = -32					; size = 4
_pYields$ = -28						; size = 4
_pRevealedOwner$ = -24					; size = 4
_pFoundValue$ = -20					; size = 4
_pNoSettling$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InitPlots@CvMap@@IAEXXZ PROC				; CvMap::InitPlots, COMDAT
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InitPlots@CvMap@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 	m_pMapPlots = FNEW(CvPlot[numPlots()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T236972[ebp], ecx
	mov	edx, DWORD PTR $T236972[ebp]
	mov	DWORD PTR $T236953[ebp], edx
	xor	ecx, ecx
	mov	eax, DWORD PTR $T236953[ebp]
	mov	edx, 484				; 000001e4H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236955[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T236955[ebp], 0
	je	SHORT $LN6@InitPlots
	mov	ecx, DWORD PTR $T236955[ebp]
	mov	edx, DWORD PTR $T236953[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET ??1CvPlot@@QAE@XZ		; CvPlot::~CvPlot
	push	OFFSET ??0CvPlot@@QAE@XZ		; CvPlot::CvPlot
	mov	eax, DWORD PTR $T236953[ebp]
	push	eax
	push	484					; 000001e4H
	mov	ecx, DWORD PTR $T236955[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T236955[ebp]
	add	edx, 4
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $LN7@InitPlots
$LN6@InitPlots:
	mov	DWORD PTR tv89[ebp], 0
$LN7@InitPlots:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR $T236954[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T236954[ebp]
	mov	DWORD PTR [ecx+4068], edx

; 267  : 	//allocate all the memory we need up front
; 268  : 
; 269  : 	int iNumPlots = numPlots();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iNumPlots$[ebp], ecx

; 270  : 
; 271  : #ifdef AUI_WARNING_FIXES
; 272  : 	m_pYields					= FNEW(int[NUM_YIELD_TYPES*iNumPlots], c_eCiv5GameplayDLL, 0);
; 273  : 	m_pFoundValue				= FNEW(int[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 274  : 	m_pPlayerCityRadiusCount	= FNEW(int[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 275  : 	m_pVisibilityCount			= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 276  : 	m_pRevealedOwner			= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 277  : 	m_pRevealed					= FNEW(bool[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 278  : 	m_pRevealedImprovementType	= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 279  : 	m_pRevealedRouteType		= FNEW(int[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);
; 280  : #else
; 281  : 	m_pYields					= FNEW(short[NUM_YIELD_TYPES*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _iNumPlots$[ebp]
	imul	eax, 6
	xor	ecx, ecx
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236958[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236958[ebp]
	mov	DWORD PTR [eax+4072], ecx

; 282  : 	m_pFoundValue				= FNEW(int[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _iNumPlots$[ebp]
	imul	eax, 80					; 00000050H
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236959[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236959[ebp]
	mov	DWORD PTR [eax+4076], ecx

; 283  : 	m_pPlayerCityRadiusCount	= FNEW(char[REALLY_MAX_PLAYERS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236960[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236960[ebp]
	mov	DWORD PTR [eax+4080], ecx

; 284  : 	m_pVisibilityCount			= FNEW(short[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _iNumPlots$[ebp]
	imul	eax, 80					; 00000050H
	xor	ecx, ecx
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236961[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236961[ebp]
	mov	DWORD PTR [eax+4084], ecx

; 285  : 	m_pRevealedOwner			= FNEW(char[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236962[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236962[ebp]
	mov	DWORD PTR [eax+4088], ecx

; 286  : 	m_pRevealed					= FNEW(bool[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236963[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236963[ebp]
	mov	DWORD PTR [eax+4092], ecx

; 287  : 	m_pRevealedImprovementType  = FNEW(short[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _iNumPlots$[ebp]
	imul	eax, 80					; 00000050H
	xor	ecx, ecx
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236964[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236964[ebp]
	mov	DWORD PTR [eax+4096], ecx

; 288  : 	m_pRevealedRouteType		= FNEW(short[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR _iNumPlots$[ebp]
	imul	eax, 80					; 00000050H
	xor	ecx, ecx
	mov	edx, 2
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236965[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236965[ebp]
	mov	DWORD PTR [eax+4100], ecx

; 289  : #endif
; 290  : 	m_pNoSettling				= FNEW(bool[MAX_MAJOR_CIVS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 22					; 00000016H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236966[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236966[ebp]
	mov	DWORD PTR [eax+4104], ecx

; 291  : 	m_pResourceForceReveal		= FNEW(bool[REALLY_MAX_TEAMS*iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T236967[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T236967[ebp]
	mov	DWORD PTR [eax+4108], ecx

; 292  : 
; 293  : 	memset(m_pYields, 0, NUM_YIELD_TYPES*iNumPlots*sizeof(short));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 6
	shl	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4072]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 294  : 	memset(m_pFoundValue, 0, REALLY_MAX_PLAYERS*iNumPlots*sizeof(int));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4076]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 295  : 	memset(m_pPlayerCityRadiusCount, 0, REALLY_MAX_PLAYERS*iNumPlots*sizeof(char));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4080]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 296  : 	memset(m_pVisibilityCount, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(short));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	shl	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4084]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 297  : 	memset(m_pRevealedOwner, -1 ,REALLY_MAX_TEAMS*iNumPlots *sizeof(char));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4088]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 298  : 	memset(m_pRevealed, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(bool));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4092]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 299  : 	memset(m_pRevealedImprovementType, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(short));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	shl	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4096]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 300  : 	memset(m_pRevealedRouteType, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(short));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	shl	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4100]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 301  : 	memset(m_pNoSettling, 0,MAX_MAJOR_CIVS*iNumPlots *sizeof(bool));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 22					; 00000016H
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4104]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 302  : 	memset(m_pResourceForceReveal, 0,REALLY_MAX_TEAMS*iNumPlots *sizeof(bool));

	mov	edx, DWORD PTR _iNumPlots$[ebp]
	imul	edx, 80					; 00000050H
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4108]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 303  : 
; 304  : 
; 305  : #ifdef AUI_WARNING_FIXES
; 306  : 	int* pYields					= m_pYields;
; 307  : 	int* pFoundValue				= m_pFoundValue;
; 308  : 	int* pPlayerCityRadiusCount		= m_pPlayerCityRadiusCount;
; 309  : 	int* pVisibilityCount			= m_pVisibilityCount;
; 310  : 	int* pRevealedOwner				= m_pRevealedOwner;
; 311  : 	int* pRevealedImprovementType	= m_pRevealedImprovementType;
; 312  : 	int* pRevealedRouteType			= m_pRevealedRouteType;
; 313  : #else
; 314  : 	short* pYields					= m_pYields;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4072]
	mov	DWORD PTR _pYields$[ebp], eax

; 315  : 	int*   pFoundValue				= m_pFoundValue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4076]
	mov	DWORD PTR _pFoundValue$[ebp], edx

; 316  : 	char*  pPlayerCityRadiusCount   = m_pPlayerCityRadiusCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4080]
	mov	DWORD PTR _pPlayerCityRadiusCount$[ebp], ecx

; 317  : 	short* pVisibilityCount			= m_pVisibilityCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4084]
	mov	DWORD PTR _pVisibilityCount$[ebp], eax

; 318  : 	char*  pRevealedOwner			= m_pRevealedOwner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4088]
	mov	DWORD PTR _pRevealedOwner$[ebp], edx

; 319  : 	short* pRevealedImprovementType = m_pRevealedImprovementType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4096]
	mov	DWORD PTR _pRevealedImprovementType$[ebp], ecx

; 320  : 	short* pRevealedRouteType		= m_pRevealedRouteType;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4100]
	mov	DWORD PTR _pRevealedRouteType$[ebp], eax

; 321  : #endif
; 322  : 	bool*  pNoSettling				= m_pNoSettling;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4104]
	mov	DWORD PTR _pNoSettling$[ebp], edx

; 323  : 	bool*  pResourceForceReveal		= m_pResourceForceReveal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4108]
	mov	DWORD PTR _pResourceForceReveal$[ebp], ecx

; 324  : 
; 325  : 	for(int i = 0; i < iNumPlots; i++)

	mov	DWORD PTR _i$234823[ebp], 0
	jmp	SHORT $LN3@InitPlots
$LN2@InitPlots:
	mov	edx, DWORD PTR _i$234823[ebp]
	add	edx, 1
	mov	DWORD PTR _i$234823[ebp], edx
$LN3@InitPlots:
	mov	eax, DWORD PTR _i$234823[ebp]
	cmp	eax, DWORD PTR _iNumPlots$[ebp]
	jge	$LN1@InitPlots

; 326  : 	{
; 327  : 		m_pMapPlots[i].m_aiYield				= pYields;

	mov	ecx, DWORD PTR _i$234823[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4068]
	mov	edx, DWORD PTR _pYields$[ebp]
	mov	DWORD PTR [eax+ecx+144], edx

; 328  : 		m_pMapPlots[i].m_aiFoundValue			= pFoundValue;

	mov	eax, DWORD PTR _i$234823[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4068]
	mov	ecx, DWORD PTR _pFoundValue$[ebp]
	mov	DWORD PTR [edx+eax+148], ecx

; 329  : 		m_pMapPlots[i].m_aiPlayerCityRadiusCount= pPlayerCityRadiusCount;

	mov	edx, DWORD PTR _i$234823[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4068]
	mov	eax, DWORD PTR _pPlayerCityRadiusCount$[ebp]
	mov	DWORD PTR [ecx+edx+152], eax

; 330  : 		m_pMapPlots[i].m_aiVisibilityCount		= pVisibilityCount;

	mov	ecx, DWORD PTR _i$234823[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4068]
	mov	edx, DWORD PTR _pVisibilityCount$[ebp]
	mov	DWORD PTR [eax+ecx+156], edx

; 331  : 		m_pMapPlots[i].m_aiRevealedOwner		= pRevealedOwner;

	mov	eax, DWORD PTR _i$234823[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4068]
	mov	ecx, DWORD PTR _pRevealedOwner$[ebp]
	mov	DWORD PTR [edx+eax+160], ecx

; 332  : 
; 333  : 		m_pMapPlots[i].m_aeRevealedImprovementType	= pRevealedImprovementType;

	mov	edx, DWORD PTR _i$234823[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4068]
	mov	eax, DWORD PTR _pRevealedImprovementType$[ebp]
	mov	DWORD PTR [ecx+edx+164], eax

; 334  : 		m_pMapPlots[i].m_aeRevealedRouteType		= pRevealedRouteType;

	mov	ecx, DWORD PTR _i$234823[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4068]
	mov	edx, DWORD PTR _pRevealedRouteType$[ebp]
	mov	DWORD PTR [eax+ecx+168], edx

; 335  : 		m_pMapPlots[i].m_abNoSettling				= pNoSettling;

	mov	eax, DWORD PTR _i$234823[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4068]
	mov	ecx, DWORD PTR _pNoSettling$[ebp]
	mov	DWORD PTR [edx+eax+172], ecx

; 336  : 
; 337  : 		m_pMapPlots[i].m_abResourceForceReveal		= pResourceForceReveal;

	mov	edx, DWORD PTR _i$234823[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4068]
	mov	eax, DWORD PTR _pResourceForceReveal$[ebp]
	mov	DWORD PTR [ecx+edx+176], eax

; 338  : 
; 339  : 
; 340  : 		pYields					+= NUM_YIELD_TYPES;

	mov	ecx, DWORD PTR _pYields$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _pYields$[ebp], ecx

; 341  : 		pFoundValue				+= REALLY_MAX_PLAYERS;

	mov	edx, DWORD PTR _pFoundValue$[ebp]
	add	edx, 320				; 00000140H
	mov	DWORD PTR _pFoundValue$[ebp], edx

; 342  : 		pPlayerCityRadiusCount  += REALLY_MAX_PLAYERS;

	mov	eax, DWORD PTR _pPlayerCityRadiusCount$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR _pPlayerCityRadiusCount$[ebp], eax

; 343  : 		pVisibilityCount		+= REALLY_MAX_TEAMS;

	mov	ecx, DWORD PTR _pVisibilityCount$[ebp]
	add	ecx, 160				; 000000a0H
	mov	DWORD PTR _pVisibilityCount$[ebp], ecx

; 344  : 		pRevealedOwner			+= REALLY_MAX_TEAMS;

	mov	edx, DWORD PTR _pRevealedOwner$[ebp]
	add	edx, 80					; 00000050H
	mov	DWORD PTR _pRevealedOwner$[ebp], edx

; 345  : 		pRevealedImprovementType+= REALLY_MAX_TEAMS;

	mov	eax, DWORD PTR _pRevealedImprovementType$[ebp]
	add	eax, 160				; 000000a0H
	mov	DWORD PTR _pRevealedImprovementType$[ebp], eax

; 346  : 		pRevealedRouteType		+= REALLY_MAX_TEAMS;

	mov	ecx, DWORD PTR _pRevealedRouteType$[ebp]
	add	ecx, 160				; 000000a0H
	mov	DWORD PTR _pRevealedRouteType$[ebp], ecx

; 347  : 		pNoSettling				+= MAX_MAJOR_CIVS;

	mov	edx, DWORD PTR _pNoSettling$[ebp]
	add	edx, 22					; 00000016H
	mov	DWORD PTR _pNoSettling$[ebp], edx

; 348  : 		pResourceForceReveal	+= REALLY_MAX_TEAMS;

	mov	eax, DWORD PTR _pResourceForceReveal$[ebp]
	add	eax, 80					; 00000050H
	mov	DWORD PTR _pResourceForceReveal$[ebp], eax

; 349  : 
; 350  : 	}

	jmp	$LN2@InitPlots
$LN1@InitPlots:

; 351  : 
; 352  : 	m_kPlotManager.Init(getGridWidth(), getGridHeight());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T236979[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T236983[ebp], ecx
	mov	edx, DWORD PTR $T236979[ebp]
	push	edx
	mov	eax, DWORD PTR $T236983[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	call	?Init@CvPlotManager@@QAEXII@Z		; CvPlotManager::Init

; 353  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitPlots@CvMap@@IAEXXZ$0:
	mov	eax, DWORD PTR $T236955[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?InitPlots@CvMap@@IAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-120]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?InitPlots@CvMap@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?InitPlots@CvMap@@IAEXXZ ENDP				; CvMap::InitPlots
PUBLIC	??_ECvPlot@@QAEPAXI@Z				; CvPlot::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_ECvPlot@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ECvPlot@@QAEPAXI@Z PROC				; CvPlot::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1CvPlot@@QAE@XZ		; CvPlot::~CvPlot
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	484					; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CvPlot@@QAE@XZ			; CvPlot::~CvPlot
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECvPlot@@QAEPAXI@Z ENDP				; CvPlot::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
PUBLIC	?setup@CvMap@@IAEXXZ				; CvMap::setup
PUBLIC	?format@CvString@@SA?AV1@PBDZZ			; CvString::format
PUBLIC	??_C@_0DL@CIJNMIHH@CvMap?3?3init?5begin?5?9?5world?5size?$DN?$CF@ ; `string'
PUBLIC	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ	; CvMap::getWorldInfo
PUBLIC	?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ	; CvMap::getClimateInfo
PUBLIC	?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ ; CvMap::getSeaLevelInfo
PUBLIC	__$ArrayPad$
PUBLIC	?init@CvMap@@QAEXPAUCvMapInitData@@@Z		; CvMap::init
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	?init@CvPlot@@QAEXHH@Z:PROC			; CvPlot::init
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
;	COMDAT ??_C@_0DL@CIJNMIHH@CvMap?3?3init?5begin?5?9?5world?5size?$DN?$CF@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0DL@CIJNMIHH@CvMap?3?3init?5begin?5?9?5world?5size?$DN?$CF@ DB 'CvM'
	DB	'ap::init begin - world size=%s, climate=%s, sealevel=%s', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?init@CvMap@@QAEXPAUCvMapInitData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?init@CvMap@@QAEXPAUCvMapInitData@@@Z$0
__ehfuncinfo$?init@CvMap@@QAEXPAUCvMapInitData@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?init@CvMap@@QAEXPAUCvMapInitData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
xdata$x	ENDS
;	COMDAT ?init@CvMap@@QAEXPAUCvMapInitData@@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T237023 = -88						; size = 4
$T237011 = -84						; size = 4
$T237010 = -80						; size = 4
$T237006 = -76						; size = 4
$T237005 = -72						; size = 4
$T237001 = -68						; size = 4
$T237000 = -64						; size = 4
_iH$ = -60						; size = 4
_iX$ = -56						; size = 4
_strMemState$ = -52					; size = 28
__$ArrayPad$ = -24					; size = 4
_iW$ = -20						; size = 4
_iY$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pInitInfo$ = 8						; size = 4
?init@CvMap@@QAEXPAUCvMapInitData@@@Z PROC		; CvMap::init, COMDAT
; _this$ = ecx

; 357  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?init@CvMap@@QAEXPAUCvMapInitData@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 358  : 	int iX, iY;
; 359  : 
; 360  : 	CvString strMemState = CvString::format("CvMap::init begin - world size=%s, climate=%s, sealevel=%s",
; 361  : 	                                        getWorldInfo().GetDescription(),
; 362  : 	                                        getClimateInfo().GetDescription(),
; 363  : 	                                        getSeaLevelInfo().GetDescription());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ ; CvMap::getSeaLevelInfo
	mov	DWORD PTR $T237000[ebp], eax
	mov	ecx, DWORD PTR $T237000[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237001[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ ; CvMap::getClimateInfo
	mov	DWORD PTR $T237005[ebp], eax
	mov	ecx, DWORD PTR $T237005[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237006[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	DWORD PTR $T237010[ebp], eax
	mov	ecx, DWORD PTR $T237010[ebp]
	add	ecx, 36					; 00000024H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR $T237011[ebp], eax
	mov	eax, DWORD PTR $T237001[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237006[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237011[ebp]
	push	edx
	push	OFFSET ??_C@_0DL@CIJNMIHH@CvMap?3?3init?5begin?5?9?5world?5size?$DN?$CF@
	lea	eax, DWORD PTR _strMemState$[ebp]
	push	eax
	call	?format@CvString@@SA?AV1@PBDZZ		; CvString::format
	add	esp, 20					; 00000014H
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 364  : 
; 365  : 
; 366  : 	//--------------------------------
; 367  : 	// Init saved data
; 368  : 	reset(pInitInfo);

	mov	ecx, DWORD PTR _pInitInfo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::reset

; 369  : 
; 370  : 	//--------------------------------
; 371  : 	// Init containers
; 372  : 	m_areas.Init();

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4112]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 373  : 	m_landmasses.Init();

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4140]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 374  : 
; 375  : #ifdef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 376  : 	//--------------------------------
; 377  : 	// Init plot data
; 378  : 	InitPlots();
; 379  : #endif
; 380  : 
; 381  : 	//--------------------------------
; 382  : 	// Init non-saved data
; 383  : 	setup();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setup@CvMap@@IAEXXZ			; CvMap::setup

; 384  : 
; 385  : #ifndef AUI_ASTAR_CACHE_PLOTS_AT_NODES
; 386  : 	//--------------------------------
; 387  : 	// Init other game data
; 388  : 	InitPlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitPlots@CvMap@@IAEXXZ		; CvMap::InitPlots

; 389  : #endif
; 390  : 
; 391  : 	int iW = getGridWidth();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR _iW$[ebp], edx

; 392  : 	int iH = getGridHeight();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR _iH$[ebp], ecx

; 393  : 
; 394  : 
; 395  : 	for(iX = 0; iX < iW; iX++)

	mov	DWORD PTR _iX$[ebp], 0
	jmp	SHORT $LN6@init
$LN5@init:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, 1
	mov	DWORD PTR _iX$[ebp], edx
$LN6@init:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR _iW$[ebp]
	jge	SHORT $LN4@init

; 396  : 	{
; 397  : 		for(iY = 0; iY < iH; iY++)

	mov	DWORD PTR _iY$[ebp], 0
	jmp	SHORT $LN3@init
$LN2@init:
	mov	ecx, DWORD PTR _iY$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iY$[ebp], ecx
$LN3@init:
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR _iH$[ebp]
	jge	SHORT $LN1@init

; 398  : 		{
; 399  : 			plotUnchecked(iX, iY)->init(iX, iY);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237023[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	imul	ecx, DWORD PTR $T237023[ebp]
	add	ecx, DWORD PTR _iX$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?init@CvPlot@@QAEXHH@Z			; CvPlot::init

; 400  : 		}

	jmp	SHORT $LN2@init
$LN1@init:

; 401  : 	}

	jmp	SHORT $LN5@init
$LN4@init:

; 402  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _strMemState$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?init@CvMap@@QAEXPAUCvMapInitData@@@Z$0:
	lea	ecx, DWORD PTR _strMemState$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?init@CvMap@@QAEXPAUCvMapInitData@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?init@CvMap@@QAEXPAUCvMapInitData@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?init@CvMap@@QAEXPAUCvMapInitData@@@Z ENDP		; CvMap::init
EXTRN	?Uninit@CvPlotManager@@QAEXXZ:PROC		; CvPlotManager::Uninit
; Function compile flags: /Odtp
;	COMDAT ?uninit@CvMap@@QAEXXZ
_TEXT	SEGMENT
tv152 = -116						; size = 4
_this$ = -112						; size = 4
$T237130 = -108						; size = 4
$T237129 = -104						; size = 4
$T237124 = -100						; size = 4
$T237122 = -96						; size = 4
$T237118 = -92						; size = 4
$T237116 = -88						; size = 4
$T237112 = -84						; size = 4
$T237110 = -80						; size = 4
$T237106 = -76						; size = 4
$T237104 = -72						; size = 4
$T237100 = -68						; size = 4
$T237098 = -64						; size = 4
$T237094 = -60						; size = 4
$T237092 = -56						; size = 4
$T237088 = -52						; size = 4
$T237086 = -48						; size = 4
$T237082 = -44						; size = 4
$T237080 = -40						; size = 4
$T237076 = -36						; size = 4
$T237074 = -32						; size = 4
$T237070 = -28						; size = 4
$T237066 = -24						; size = 4
$T237065 = -20						; size = 4
$T237057 = -16						; size = 4
$T237055 = -12						; size = 4
$T237051 = -8						; size = 4
$T237049 = -4						; size = 4
?uninit@CvMap@@QAEXXZ PROC				; CvMap::uninit, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	DWORD PTR _this$[ebp], ecx

; 407  : 	SAFE_DELETE_ARRAY(m_paiNumResource);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4060				; 00000fdcH
	mov	DWORD PTR $T237051[ebp], eax
	mov	ecx, DWORD PTR $T237051[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237049[ebp], edx
	mov	eax, DWORD PTR $T237049[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T237051[ebp]
	mov	DWORD PTR [ecx], 0

; 408  : 	SAFE_DELETE_ARRAY(m_paiNumResourceOnLand);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4064				; 00000fe0H
	mov	DWORD PTR $T237057[ebp], edx
	mov	eax, DWORD PTR $T237057[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237055[ebp], ecx
	mov	edx, DWORD PTR $T237055[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T237057[ebp]
	mov	DWORD PTR [eax], 0

; 409  : 
; 410  : 	SAFE_DELETE_ARRAY(m_pMapPlots);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4068				; 00000fe4H
	mov	DWORD PTR $T237070[ebp], ecx
	mov	edx, DWORD PTR $T237070[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237066[ebp], eax
	mov	ecx, DWORD PTR $T237066[ebp]
	mov	DWORD PTR $T237065[ebp], ecx
	cmp	DWORD PTR $T237065[ebp], 0
	je	SHORT $LN9@uninit
	push	3
	mov	ecx, DWORD PTR $T237065[ebp]
	call	??_ECvPlot@@QAEPAXI@Z
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN10@uninit
$LN9@uninit:
	mov	DWORD PTR tv152[ebp], 0
$LN10@uninit:
	mov	edx, DWORD PTR $T237070[ebp]
	mov	DWORD PTR [edx], 0

; 411  : 
; 412  : 
; 413  : 	SAFE_DELETE_ARRAY(m_pYields);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4072				; 00000fe8H
	mov	DWORD PTR $T237076[ebp], eax
	mov	ecx, DWORD PTR $T237076[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237074[ebp], edx
	mov	eax, DWORD PTR $T237074[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T237076[ebp]
	mov	DWORD PTR [ecx], 0

; 414  : 	SAFE_DELETE_ARRAY(m_pFoundValue);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4076				; 00000fecH
	mov	DWORD PTR $T237082[ebp], edx
	mov	eax, DWORD PTR $T237082[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237080[ebp], ecx
	mov	edx, DWORD PTR $T237080[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T237082[ebp]
	mov	DWORD PTR [eax], 0

; 415  : 	SAFE_DELETE_ARRAY(m_pPlayerCityRadiusCount);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4080				; 00000ff0H
	mov	DWORD PTR $T237088[ebp], ecx
	mov	edx, DWORD PTR $T237088[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237086[ebp], eax
	mov	ecx, DWORD PTR $T237086[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T237088[ebp]
	mov	DWORD PTR [edx], 0

; 416  : 	SAFE_DELETE_ARRAY(m_pVisibilityCount);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4084				; 00000ff4H
	mov	DWORD PTR $T237094[ebp], eax
	mov	ecx, DWORD PTR $T237094[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237092[ebp], edx
	mov	eax, DWORD PTR $T237092[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T237094[ebp]
	mov	DWORD PTR [ecx], 0

; 417  : 	SAFE_DELETE_ARRAY(m_pRevealedOwner);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4088				; 00000ff8H
	mov	DWORD PTR $T237100[ebp], edx
	mov	eax, DWORD PTR $T237100[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237098[ebp], ecx
	mov	edx, DWORD PTR $T237098[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T237100[ebp]
	mov	DWORD PTR [eax], 0

; 418  : 	SAFE_DELETE_ARRAY(m_pRevealed);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4092				; 00000ffcH
	mov	DWORD PTR $T237106[ebp], ecx
	mov	edx, DWORD PTR $T237106[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237104[ebp], eax
	mov	ecx, DWORD PTR $T237104[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T237106[ebp]
	mov	DWORD PTR [edx], 0

; 419  : 	SAFE_DELETE_ARRAY(m_pRevealedImprovementType);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4096				; 00001000H
	mov	DWORD PTR $T237112[ebp], eax
	mov	ecx, DWORD PTR $T237112[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237110[ebp], edx
	mov	eax, DWORD PTR $T237110[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T237112[ebp]
	mov	DWORD PTR [ecx], 0

; 420  : 	SAFE_DELETE_ARRAY(m_pRevealedRouteType);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4100				; 00001004H
	mov	DWORD PTR $T237118[ebp], edx
	mov	eax, DWORD PTR $T237118[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T237116[ebp], ecx
	mov	edx, DWORD PTR $T237116[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	eax, DWORD PTR $T237118[ebp]
	mov	DWORD PTR [eax], 0

; 421  : 	SAFE_DELETE_ARRAY(m_pNoSettling);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4104				; 00001008H
	mov	DWORD PTR $T237124[ebp], ecx
	mov	edx, DWORD PTR $T237124[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T237122[ebp], eax
	mov	ecx, DWORD PTR $T237122[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T237124[ebp]
	mov	DWORD PTR [edx], 0

; 422  : 	SAFE_DELETE_ARRAY(m_pResourceForceReveal);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4108				; 0000100cH
	mov	DWORD PTR $T237130[ebp], eax
	mov	ecx, DWORD PTR $T237130[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T237129[ebp], edx
	mov	eax, DWORD PTR $T237129[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	ecx, DWORD PTR $T237130[ebp]
	mov	DWORD PTR [ecx], 0

; 423  : 
; 424  : 	m_iGridWidth = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4020], 0

; 425  : 	m_iGridHeight = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4024], 0

; 426  : 	m_iGridSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4028], 0

; 427  : 	m_iLandPlots = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4032], 0

; 428  : 	m_iOwnedPlots = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4036], 0

; 429  : 	m_iNumNaturalWonders = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4048], 0

; 430  : 
; 431  : 	m_areas.Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4112]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 432  : 	m_landmasses.Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4140]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 433  : 	m_kPlotManager.Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4184				; 00001058H
	call	?Uninit@CvPlotManager@@QAEXXZ		; CvPlotManager::Uninit

; 434  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?uninit@CvMap@@QAEXXZ ENDP				; CvMap::uninit
_TEXT	ENDS
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	__imp__CoCreateGuid@4:PROC
EXTRN	?getGridHeight@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridHeight
EXTRN	?getGridWidth@CvWorldInfo@@QBEHXZ:PROC		; CvWorldInfo::getGridWidth
EXTRN	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ:PROC ; CvPreGame::worldSize
; Function compile flags: /Odtp
;	COMDAT ?reset@CvMap@@QAEXPAUCvMapInitData@@@Z
_TEXT	SEGMENT
tv217 = -112						; size = 4
tv144 = -108						; size = 4
tv139 = -104						; size = 4
tv134 = -100						; size = 4
tv224 = -96						; size = 4
tv81 = -92						; size = 4
tv73 = -88						; size = 4
_this$ = -84						; size = 4
$T237209 = -80						; size = 4
$T237205 = -76						; size = 4
$T237201 = -72						; size = 4
_i$237196 = -68						; size = 4
$T237182 = -64						; size = 4
$T237179 = -60						; size = 4
$T237172 = -56						; size = 4
$T237169 = -52						; size = 4
$T237162 = -48						; size = 4
$T237159 = -44						; size = 4
$T237152 = -40						; size = 4
$T237149 = -36						; size = 4
$T237142 = -32						; size = 4
$T237141 = -28						; size = 4
$T237140 = -24						; size = 4
$T237139 = -20						; size = 4
$T237138 = -16						; size = 4
$T237137 = -12						; size = 4
_iI$234896 = -8						; size = 4
_iNumResourceInfos$ = -4				; size = 4
_pInitInfo$ = 8						; size = 4
?reset@CvMap@@QAEXPAUCvMapInitData@@@Z PROC		; CvMap::reset, COMDAT
; _this$ = ecx

; 440  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	DWORD PTR _this$[ebp], ecx

; 441  : 	//--------------------------------
; 442  : 	// Uninit class
; 443  : 	uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?uninit@CvMap@@QAEXXZ			; CvMap::uninit

; 444  : 
; 445  : 	m_iAIMapHints = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4052], 0

; 446  : 	//
; 447  : 	// set grid size
; 448  : 	// initially set in terrain cell units
; 449  : 	//
; 450  : 	m_iGridWidth = (CvPreGame::worldSize() != NO_WORLDSIZE) ?  getWorldInfo().getGridWidth(): 0;	//todotw:tcells wide

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	cmp	eax, -1
	je	SHORT $LN10@reset
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getGridWidth@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridWidth
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN11@reset
$LN10@reset:
	mov	DWORD PTR tv73[ebp], 0
$LN11@reset:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR [ecx+4020], edx

; 451  : 	m_iGridHeight = (CvPreGame::worldSize() != NO_WORLDSIZE) ? getWorldInfo().getGridHeight(): 0;

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize
	cmp	eax, -1
	je	SHORT $LN12@reset
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getGridHeight@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getGridHeight
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@reset
$LN12@reset:
	mov	DWORD PTR tv81[ebp], 0
$LN13@reset:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv81[ebp]
	mov	DWORD PTR [eax+4024], ecx

; 452  : 
; 453  : 	// allow grid size override
; 454  : 	if(pInitInfo)

	cmp	DWORD PTR _pInitInfo$[ebp], 0
	je	SHORT $LN7@reset

; 455  : 	{
; 456  : 		m_iGridWidth	= pInitInfo->m_iGridW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pInitInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4020], ecx

; 457  : 		m_iGridHeight	= pInitInfo->m_iGridH;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pInitInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4024], ecx
$LN7@reset:

; 458  : 	}
; 459  : 
; 460  : 	m_iGridSize = m_iGridHeight * m_iGridWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4024]
	imul	ecx, DWORD PTR [eax+4020]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4028], ecx

; 461  : 	m_iLandPlots = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4032], 0

; 462  : 	m_iOwnedPlots = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4036], 0

; 463  : 	m_iNumNaturalWonders = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4048], 0

; 464  : 
; 465  : 	if(pInitInfo)

	cmp	DWORD PTR _pInitInfo$[ebp], 0
	je	SHORT $LN6@reset

; 466  : 	{
; 467  : 		m_iTopLatitude = pInitInfo->m_iTopLatitude;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pInitInfo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4040], edx

; 468  : 		m_iBottomLatitude = pInitInfo->m_iBottomLatitude;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pInitInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4044], edx
$LN6@reset:

; 469  : 	}
; 470  : 
; 471  : 	m_iTopLatitude = std::min(m_iTopLatitude, 90);

	mov	DWORD PTR $T237137[ebp], 90		; 0000005aH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4040				; 00000fc8H
	mov	DWORD PTR $T237152[ebp], eax
	mov	ecx, DWORD PTR $T237152[ebp]
	mov	edx, DWORD PTR $T237137[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN16@reset
	lea	eax, DWORD PTR $T237137[ebp]
	mov	DWORD PTR tv224[ebp], eax
	jmp	SHORT $LN17@reset
$LN16@reset:
	mov	ecx, DWORD PTR $T237152[ebp]
	mov	DWORD PTR tv224[ebp], ecx
$LN17@reset:
	mov	edx, DWORD PTR tv224[ebp]
	mov	DWORD PTR $T237149[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237149[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4040], edx

; 472  : 	m_iTopLatitude = std::max(m_iTopLatitude, -90);

	mov	DWORD PTR $T237138[ebp], -90		; ffffffa6H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4040				; 00000fc8H
	mov	DWORD PTR $T237162[ebp], eax
	mov	ecx, DWORD PTR $T237162[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR $T237138[ebp]
	jge	SHORT $LN20@reset
	lea	eax, DWORD PTR $T237138[ebp]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN21@reset
$LN20@reset:
	mov	ecx, DWORD PTR $T237162[ebp]
	mov	DWORD PTR tv134[ebp], ecx
$LN21@reset:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR $T237159[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237159[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4040], edx

; 473  : 	m_iBottomLatitude = std::min(m_iBottomLatitude, 90);

	mov	DWORD PTR $T237139[ebp], 90		; 0000005aH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4044				; 00000fccH
	mov	DWORD PTR $T237172[ebp], eax
	mov	ecx, DWORD PTR $T237172[ebp]
	mov	edx, DWORD PTR $T237139[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN24@reset
	lea	eax, DWORD PTR $T237139[ebp]
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN25@reset
$LN24@reset:
	mov	ecx, DWORD PTR $T237172[ebp]
	mov	DWORD PTR tv139[ebp], ecx
$LN25@reset:
	mov	edx, DWORD PTR tv139[ebp]
	mov	DWORD PTR $T237169[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237169[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4044], edx

; 474  : 	m_iBottomLatitude = std::max(m_iBottomLatitude, -90);

	mov	DWORD PTR $T237140[ebp], -90		; ffffffa6H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4044				; 00000fccH
	mov	DWORD PTR $T237182[ebp], eax
	mov	ecx, DWORD PTR $T237182[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR $T237140[ebp]
	jge	SHORT $LN28@reset
	lea	eax, DWORD PTR $T237140[ebp]
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN29@reset
$LN28@reset:
	mov	ecx, DWORD PTR $T237182[ebp]
	mov	DWORD PTR tv144[ebp], ecx
$LN29@reset:
	mov	edx, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T237179[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237179[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4044], edx

; 475  : 
; 476  : 	//
; 477  : 	// set wrapping
; 478  : 	//
; 479  : 	m_bWrapX = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4056], 1

; 480  : 	m_bWrapY = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4057], 0

; 481  : 
; 482  : 	CoCreateGuid(&m_guid);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4168				; 00001048H
	push	edx
	call	DWORD PTR __imp__CoCreateGuid@4

; 483  : 
; 484  : 	if(pInitInfo)

	cmp	DWORD PTR _pInitInfo$[ebp], 0
	je	SHORT $LN5@reset

; 485  : 	{
; 486  : 		m_bWrapX = pInitInfo->m_bWrapX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pInitInfo$[ebp]
	mov	dl, BYTE PTR [ecx+16]
	mov	BYTE PTR [eax+4056], dl

; 487  : 		m_bWrapY = pInitInfo->m_bWrapY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pInitInfo$[ebp]
	mov	dl, BYTE PTR [ecx+17]
	mov	BYTE PTR [eax+4057], dl
$LN5@reset:

; 488  : 	}
; 489  : 
; 490  : #ifdef AUI_MAP_FIX_CALCULATE_INFLUENCE_DISTANCE_REUSE_PATHFINDER
; 491  : 	m_pLastInfluenceSourcePlot = NULL;
; 492  : #endif
; 493  : 
; 494  : 	int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	DWORD PTR _iNumResourceInfos$[ebp], eax

; 495  : 	if(iNumResourceInfos)

	cmp	DWORD PTR _iNumResourceInfos$[ebp], 0
	je	$LN4@reset

; 496  : 	{
; 497  : 		CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvMap::reset");
; 498  : 		CvAssertMsg(m_paiNumResource==NULL, "mem leak m_paiNumResource");
; 499  : 		m_paiNumResource = FNEW(int[iNumResourceInfos], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumResourceInfos$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T237141[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237141[ebp]
	mov	DWORD PTR [eax+4060], ecx

; 500  : 		CvAssertMsg(m_paiNumResourceOnLand==NULL, "mem leak m_paiNumResourceOnLand");
; 501  : 		m_paiNumResourceOnLand = FNEW(int[iNumResourceInfos], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, DWORD PTR _iNumResourceInfos$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T237142[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T237142[ebp]
	mov	DWORD PTR [eax+4064], ecx

; 502  : 		for(int iI = 0; iI < iNumResourceInfos; iI++)

	mov	DWORD PTR _iI$234896[ebp], 0
	jmp	SHORT $LN3@reset
$LN2@reset:
	mov	edx, DWORD PTR _iI$234896[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$234896[ebp], edx
$LN3@reset:
	mov	eax, DWORD PTR _iI$234896[ebp]
	cmp	eax, DWORD PTR _iNumResourceInfos$[ebp]
	jge	SHORT $LN4@reset

; 503  : 		{
; 504  : 			m_paiNumResource[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4060]
	mov	eax, DWORD PTR _iI$234896[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 505  : 			m_paiNumResourceOnLand[iI] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4064]
	mov	eax, DWORD PTR _iI$234896[ebp]
	mov	DWORD PTR [edx+eax*4], 0

; 506  : 		}

	jmp	SHORT $LN2@reset
$LN4@reset:

; 507  : 	}
; 508  : 
; 509  : 	m_areas.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4112]
	mov	edx, DWORD PTR [eax+20]
	call	edx

; 510  : 	m_landmasses.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4140]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 511  : 
; 512  : 	m_vDeferredFogPlots.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T237201[ebp], ecx
	xor	edx, edx
	je	SHORT $LN36@reset
	mov	DWORD PTR _i$237196[ebp], 0
	jmp	SHORT $LN34@reset
$LN33@reset:
	mov	eax, DWORD PTR _i$237196[ebp]
	add	eax, 1
	mov	DWORD PTR _i$237196[ebp], eax
$LN34@reset:
	mov	ecx, DWORD PTR $T237201[ebp]
	mov	edx, DWORD PTR _i$237196[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN36@reset
	jmp	SHORT $LN33@reset
$LN36@reset:
	mov	eax, DWORD PTR $T237201[ebp]
	mov	DWORD PTR [eax+4], 0

; 513  : 
; 514  : 	gDLL->DoMapSetup(numPlots());

	mov	ecx, DWORD PTR $T237205[ebp]
	mov	DWORD PTR tv217[ebp], ecx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv217[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T237209[ebp], ecx
	mov	edx, DWORD PTR $T237209[ebp]
	push	edx
	mov	eax, DWORD PTR tv217[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv217[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 515  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?reset@CvMap@@QAEXPAUCvMapInitData@@@Z ENDP		; CvMap::reset
_TEXT	ENDS
EXTRN	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::GetTacticalAnalysisMapFinder
EXTRN	?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TacticalAnalysisMapPathValid
EXTRN	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteWaterFinder
EXTRN	?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteWaterPathCost
EXTRN	?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteWaterValid
EXTRN	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetInternationalTradeRouteLandFinder
EXTRN	?TradeRouteHeuristic@@YAHHHHH@Z:PROC		; TradeRouteHeuristic
EXTRN	?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteLandPathCost
EXTRN	?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; TradeRouteLandValid
EXTRN	?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z:PROC	; TradePathInitialize
EXTRN	?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z:PROC ; TradePathUninitialize
EXTRN	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetBuildRouteFinder
EXTRN	?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; BuildRouteCost
EXTRN	?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; BuildRouteValid
EXTRN	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getInfluenceFinder
EXTRN	?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC ; InfluenceDestValid
EXTRN	?InfluenceHeuristic@@YAHHHHH@Z:PROC		; InfluenceHeuristic
EXTRN	?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; InfluenceCost
EXTRN	?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; InfluenceValid
EXTRN	?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; InfluenceAdd
EXTRN	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getAreaFinder
EXTRN	?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; AreaValid
EXTRN	?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; JoinArea
EXTRN	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::GetWaterRouteFinder
EXTRN	?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; WaterRouteValid
EXTRN	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ:PROC ; CvGlobals::getRouteFinder
EXTRN	?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; RouteValid
EXTRN	?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z:PROC ; RouteGetNumExtraChildren
EXTRN	?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z:PROC ; RouteGetExtraChild
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC	; StepDestValid
EXTRN	?StepHeuristic@@YAHHHHH@Z:PROC			; StepHeuristic
EXTRN	?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepCost
EXTRN	?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepValid
EXTRN	?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepAdd
EXTRN	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z:PROC ; CvAStar::Initialize
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsDestValid
EXTRN	?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsCost
EXTRN	?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsValid
EXTRN	?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; IgnoreUnitsPathAdd
EXTRN	?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getInterfacePathFinder
EXTRN	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z:PROC ; CvTwoLayerPathFinder::Initialize
EXTRN	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ:PROC ; CvGlobals::getPathFinder
EXTRN	?PathDest@@YAHHHPBXPAVCvAStar@@@Z:PROC		; PathDest
EXTRN	?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC	; PathDestValid
EXTRN	?PathHeuristic@@YAHHHHH@Z:PROC			; PathHeuristic
EXTRN	?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathCost
EXTRN	?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathValid
EXTRN	?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathAdd
EXTRN	?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; PathNodeAdd
EXTRN	?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z:PROC	; UnitPathInitialize
EXTRN	?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z:PROC ; UnitPathUninitialize
; Function compile flags: /Odtp
;	COMDAT ?setup@CvMap@@IAEXXZ
_TEXT	SEGMENT
_this$ = -180						; size = 4
$T237423 = -176						; size = 4
_bOldState$237422 = -169				; size = 1
$T237418 = -168						; size = 4
$T237414 = -164						; size = 4
$T237410 = -158						; size = 1
$T237406 = -157						; size = 1
$T237402 = -156						; size = 4
$T237398 = -152						; size = 4
$T237394 = -146						; size = 1
$T237390 = -145						; size = 1
$T237386 = -144						; size = 4
$T237382 = -140						; size = 4
$T237378 = -134						; size = 1
$T237374 = -133						; size = 1
$T237370 = -132						; size = 4
$T237366 = -128						; size = 4
$T237362 = -122						; size = 1
$T237358 = -121						; size = 1
$T237354 = -120						; size = 4
$T237350 = -116						; size = 4
$T237346 = -110						; size = 1
$T237342 = -109						; size = 1
$T237338 = -108						; size = 4
$T237334 = -104						; size = 4
$T237330 = -98						; size = 1
$T237326 = -97						; size = 1
$T237322 = -96						; size = 4
$T237318 = -92						; size = 4
$T237314 = -86						; size = 1
$T237310 = -85						; size = 1
$T237306 = -84						; size = 4
$T237302 = -80						; size = 4
$T237298 = -74						; size = 1
$T237294 = -73						; size = 1
$T237290 = -72						; size = 4
$T237286 = -68						; size = 4
$T237282 = -62						; size = 1
$T237278 = -61						; size = 1
$T237274 = -60						; size = 4
_bOldState$237273 = -53					; size = 1
$T237269 = -52						; size = 4
$T237265 = -48						; size = 4
$T237261 = -42						; size = 1
$T237257 = -41						; size = 1
$T237253 = -40						; size = 4
_bOldState$237252 = -33					; size = 1
$T237248 = -32						; size = 4
$T237244 = -28						; size = 4
$T237240 = -22						; size = 1
$T237236 = -21						; size = 1
$T237232 = -20						; size = 4
_bOldState$237231 = -13					; size = 1
$T237227 = -12						; size = 4
$T237223 = -8						; size = 4
$T237219 = -2						; size = 1
$T237215 = -1						; size = 1
?setup@CvMap@@IAEXXZ PROC				; CvMap::setup, COMDAT
; _this$ = ecx

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	DWORD PTR _this$[ebp], ecx

; 523  : 	GC.getPathFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, PathDestValid, PathHeuristic, PathCost, PathValid, PathAdd, PathNodeAdd, UnitPathInitialize, UnitPathUninitialize, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237215[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237219[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237223[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237227[ebp], ecx
	push	0
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	OFFSET ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
	push	OFFSET ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	push	OFFSET ?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	push	OFFSET ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	push	OFFSET ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ; PathDestValid
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237215[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237219[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237223[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237227[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	ecx, eax
	call	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize

; 524  : 	GC.getPathFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getPathFinder
	mov	DWORD PTR $T237232[ebp], eax
	mov	eax, DWORD PTR $T237232[ebp]
	mov	cl, BYTE PTR [eax+80]
	mov	BYTE PTR _bOldState$237231[ebp], cl
	mov	edx, DWORD PTR $T237232[ebp]
	mov	BYTE PTR [edx+80], 1

; 525  : 	GC.getInterfacePathFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, PathDestValid, PathHeuristic, PathCost, PathValid, PathAdd, PathNodeAdd, UnitPathInitialize, UnitPathUninitialize, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237236[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237240[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237244[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237248[ebp], ecx
	push	0
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	OFFSET ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
	push	OFFSET ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	push	OFFSET ?PathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathValid
	push	OFFSET ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	push	OFFSET ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ; PathDestValid
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237236[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237240[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237244[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237248[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getInterfacePathFinder
	mov	ecx, eax
	call	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize

; 526  : 	GC.getInterfacePathFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInterfacePathFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::getInterfacePathFinder
	mov	DWORD PTR $T237253[ebp], eax
	mov	eax, DWORD PTR $T237253[ebp]
	mov	cl, BYTE PTR [eax+80]
	mov	BYTE PTR _bOldState$237252[ebp], cl
	mov	edx, DWORD PTR $T237253[ebp]
	mov	BYTE PTR [edx+80], 1

; 527  : 	GC.getIgnoreUnitsPathFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest,  IgnoreUnitsDestValid, PathHeuristic, IgnoreUnitsCost, IgnoreUnitsValid, IgnoreUnitsPathAdd, NULL, NULL, NULL, UnitPathInitialize, UnitPathUninitialize, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237257[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237261[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237265[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237269[ebp], ecx
	push	0
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	0
	push	0
	push	0
	push	OFFSET ?IgnoreUnitsPathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsPathAdd
	push	OFFSET ?IgnoreUnitsValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsValid
	push	OFFSET ?IgnoreUnitsCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; IgnoreUnitsCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	push	OFFSET ?IgnoreUnitsDestValid@@YAHHHPBXPAVCvAStar@@@Z ; IgnoreUnitsDestValid
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237257[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237261[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237265[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237269[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 528  : 	GC.getIgnoreUnitsPathFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	DWORD PTR $T237274[ebp], eax
	mov	eax, DWORD PTR $T237274[ebp]
	mov	cl, BYTE PTR [eax+80]
	mov	BYTE PTR _bOldState$237273[ebp], cl
	mov	edx, DWORD PTR $T237274[ebp]
	mov	BYTE PTR [edx+80], 1

; 529  : 	GC.getStepFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, StepDestValid, StepHeuristic, StepCost, StepValid, StepAdd, NULL, NULL, NULL, NULL, NULL, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237278[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237282[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237286[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237290[ebp], ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?StepAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepAdd
	push	OFFSET ?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValid
	push	OFFSET ?StepCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepCost
	push	OFFSET ?StepHeuristic@@YAHHHHH@Z	; StepHeuristic
	push	OFFSET ?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z ; StepDestValid
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237278[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237282[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237286[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237290[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 530  : 	GC.getRouteFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, NULL, RouteValid, NULL, NULL, RouteGetNumExtraChildren, RouteGetExtraChild, NULL, NULL, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237294[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237298[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237302[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237306[ebp], ecx
	push	0
	push	0
	push	0
	push	OFFSET ?RouteGetExtraChild@@YAHPAVCvAStarNode@@HAAH1PAVCvAStar@@@Z ; RouteGetExtraChild
	push	OFFSET ?RouteGetNumExtraChildren@@YAHPAVCvAStarNode@@PAVCvAStar@@@Z ; RouteGetNumExtraChildren
	push	0
	push	0
	push	OFFSET ?RouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; RouteValid
	push	0
	push	0
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237294[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237298[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237302[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237306[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getRouteFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 531  : 	GC.GetWaterRouteFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, NULL, WaterRouteValid, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237310[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237314[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237318[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237322[ebp], ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?WaterRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; WaterRouteValid
	push	0
	push	0
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237310[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237314[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237318[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237322[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetWaterRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetWaterRouteFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 532  : 	GC.getAreaFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, NULL, AreaValid, NULL, JoinArea, NULL, NULL, NULL, NULL, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237326[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237330[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237334[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237338[ebp], ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinArea
	push	0
	push	OFFSET ?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AreaValid
	push	0
	push	0
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237326[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237330[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237334[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237338[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getAreaFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 533  : 	GC.getInfluenceFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, InfluenceDestValid, InfluenceHeuristic, InfluenceCost, InfluenceValid, InfluenceAdd, NULL, NULL, NULL, NULL, NULL, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237342[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237346[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237350[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237354[ebp], ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?InfluenceAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceAdd
	push	OFFSET ?InfluenceValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceValid
	push	OFFSET ?InfluenceCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; InfluenceCost
	push	OFFSET ?InfluenceHeuristic@@YAHHHHH@Z	; InfluenceHeuristic
	push	OFFSET ?InfluenceDestValid@@YAHHHPBXPAVCvAStar@@@Z ; InfluenceDestValid
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237342[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237346[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237350[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237354[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 534  : 	GC.GetBuildRouteFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, NULL, BuildRouteCost, BuildRouteValid, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237358[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237362[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237366[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237370[ebp], ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?BuildRouteValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteValid
	push	OFFSET ?BuildRouteCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; BuildRouteCost
	push	0
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237358[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237362[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237366[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237370[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetBuildRouteFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetBuildRouteFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 535  : 	GC.GetInternationalTradeRouteLandFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL,	TradeRouteHeuristic, TradeRouteLandPathCost, TradeRouteLandValid, NULL, NULL, NULL, NULL, TradePathInitialize, TradePathUninitialize, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237374[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237378[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237382[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237386[ebp], ecx
	push	0
	push	OFFSET ?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathUninitialize
	push	OFFSET ?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathInitialize
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?TradeRouteLandValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandValid
	push	OFFSET ?TradeRouteLandPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteLandPathCost
	push	OFFSET ?TradeRouteHeuristic@@YAHHHHH@Z	; TradeRouteHeuristic
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237374[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237378[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237382[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237386[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteLandFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteLandFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 536  : 	GC.GetInternationalTradeRouteWaterFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, NULL, TradeRouteHeuristic, TradeRouteWaterPathCost, TradeRouteWaterValid, NULL, NULL, NULL, NULL, TradePathInitialize, TradePathUninitialize, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237390[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237394[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237398[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237402[ebp], ecx
	push	0
	push	OFFSET ?TradePathUninitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathUninitialize
	push	OFFSET ?TradePathInitialize@@YAXPBXPAVCvAStar@@@Z ; TradePathInitialize
	push	0
	push	0
	push	0
	push	0
	push	OFFSET ?TradeRouteWaterValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterValid
	push	OFFSET ?TradeRouteWaterPathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TradeRouteWaterPathCost
	push	OFFSET ?TradeRouteHeuristic@@YAHHHHH@Z	; TradeRouteHeuristic
	push	0
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237390[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237394[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237398[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237402[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetInternationalTradeRouteWaterFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::GetInternationalTradeRouteWaterFinder
	mov	ecx, eax
	call	?Initialize@CvAStar@@QAEXHH_N0P6AHHHPBXPAV1@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AH52@ZP6AH5HAAH82@ZP6AX12@ZP6AX12@Z1@Z ; CvAStar::Initialize

; 537  : 	GC.GetTacticalAnalysisMapFinder().Initialize(getGridWidth(), getGridHeight(), isWrapX(), isWrapY(), PathDest, PathDestValid, PathHeuristic, PathCost, TacticalAnalysisMapPathValid, PathAdd, PathNodeAdd, UnitPathInitialize, UnitPathUninitialize, NULL);

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T237406[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T237410[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237414[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237418[ebp], ecx
	push	0
	push	OFFSET ?UnitPathUninitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathUninitialize
	push	OFFSET ?UnitPathInitialize@@YAXPBXPAVCvAStar@@@Z ; UnitPathInitialize
	push	OFFSET ?PathNodeAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathNodeAdd
	push	OFFSET ?PathAdd@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathAdd
	push	OFFSET ?TacticalAnalysisMapPathValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; TacticalAnalysisMapPathValid
	push	OFFSET ?PathCost@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; PathCost
	push	OFFSET ?PathHeuristic@@YAHHHHH@Z	; PathHeuristic
	push	OFFSET ?PathDestValid@@YAHHHPBXPAVCvAStar@@@Z ; PathDestValid
	push	OFFSET ?PathDest@@YAHHHPBXPAVCvAStar@@@Z ; PathDest
	movzx	edx, BYTE PTR $T237406[ebp]
	push	edx
	movzx	eax, BYTE PTR $T237410[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237414[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237418[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	ecx, eax
	call	?Initialize@CvTwoLayerPathFinder@@QAEXHH_N0P6AHHHPBXPAVCvAStar@@@Z3P6AHHHHH@ZP6AHPAVCvAStarNode@@5H12@Z666P6AX12@Z71@Z ; CvTwoLayerPathFinder::Initialize

; 538  : 	GC.GetTacticalAnalysisMapFinder().SetDataChangeInvalidatesCache(true);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetTacticalAnalysisMapFinder@CvGlobals@@QAEAAVCvTwoLayerPathFinder@@XZ ; CvGlobals::GetTacticalAnalysisMapFinder
	mov	DWORD PTR $T237423[ebp], eax
	mov	eax, DWORD PTR $T237423[ebp]
	mov	cl, BYTE PTR [eax+80]
	mov	BYTE PTR _bOldState$237422[ebp], cl
	mov	edx, DWORD PTR $T237423[ebp]
	mov	BYTE PTR [edx+80], 1

; 539  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?setup@CvMap@@IAEXXZ ENDP				; CvMap::setup
_TEXT	ENDS
PUBLIC	?setupGraphical@CvMap@@QAEXXZ			; CvMap::setupGraphical
EXTRN	?setupGraphical@CvPlot@@QAEXXZ:PROC		; CvPlot::setupGraphical
EXTRN	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ:PROC	; CvGlobals::IsGraphicsInitialized
; Function compile flags: /Odtp
;	COMDAT ?setupGraphical@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237429 = -8						; size = 4
_iI$234908 = -4						; size = 4
?setupGraphical@CvMap@@QAEXXZ PROC			; CvMap::setupGraphical, COMDAT
; _this$ = ecx

; 546  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 547  : 	if(!GC.IsGraphicsInitialized())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?IsGraphicsInitialized@CvGlobals@@QBE_NXZ ; CvGlobals::IsGraphicsInitialized
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@setupGraph

; 548  : 		return;

	jmp	SHORT $LN6@setupGraph
$LN5@setupGraph:

; 549  : 
; 550  : 	if(m_pMapPlots != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4068], 0
	je	SHORT $LN6@setupGraph

; 551  : 	{
; 552  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 553  : #pragma omp parallel for
; 554  : 		for (int iI = 0; iI < (int)numPlots(); iI++)
; 555  : #elif defined(AUI_WARNING_FIXES)
; 556  : 		for (uint iI = 0; iI < numPlots(); iI++)
; 557  : #elif defined (AUI_USE_OPENMP)
; 558  : #pragma omp parallel for
; 559  : 		for (int iI = 0; iI < numPlots(); iI++)
; 560  : #else
; 561  : 		int iI;
; 562  : 		for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$234908[ebp], 0
	jmp	SHORT $LN3@setupGraph
$LN2@setupGraph:
	mov	edx, DWORD PTR _iI$234908[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$234908[ebp], edx
$LN3@setupGraph:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T237429[ebp], ecx
	mov	edx, DWORD PTR _iI$234908[ebp]
	cmp	edx, DWORD PTR $T237429[ebp]
	jge	SHORT $LN6@setupGraph

; 563  : #endif
; 564  : 		{
; 565  : 			plotByIndexUnchecked(iI)->setupGraphical();

	mov	ecx, DWORD PTR _iI$234908[ebp]
	imul	ecx, 484				; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4068]
	call	?setupGraphical@CvPlot@@QAEXXZ		; CvPlot::setupGraphical

; 566  : 		}

	jmp	SHORT $LN2@setupGraph
$LN6@setupGraph:

; 567  : 	}
; 568  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?setupGraphical@CvMap@@QAEXXZ ENDP			; CvMap::setupGraphical
_TEXT	ENDS
PUBLIC	?erasePlots@CvMap@@QAEXXZ			; CvMap::erasePlots
EXTRN	?erase@CvPlot@@QAEX_N@Z:PROC			; CvPlot::erase
; Function compile flags: /Odtp
;	COMDAT ?erasePlots@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237438 = -8						; size = 4
_iI$ = -4						; size = 4
?erasePlots@CvMap@@QAEXXZ PROC				; CvMap::erasePlots, COMDAT
; _this$ = ecx

; 573  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 574  : #ifdef AUI_WARNING_FIXES
; 575  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 576  : #else
; 577  : 	int iI;
; 578  : 
; 579  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@erasePlots
$LN2@erasePlots:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@erasePlots:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237438[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237438[ebp]
	jge	SHORT $LN4@erasePlots

; 580  : #endif
; 581  : 	{
; 582  : 		plotByIndexUnchecked(iI)->erase(true/*bEraseUnitsIfWater*/);

	push	1
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?erase@CvPlot@@QAEX_N@Z			; CvPlot::erase
	jmp	SHORT $LN2@erasePlots
$LN4@erasePlots:

; 583  : 	}
; 584  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?erasePlots@CvMap@@QAEXXZ ENDP				; CvMap::erasePlots
_TEXT	ENDS
PUBLIC	?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z	; CvMap::setRevealedPlots
EXTRN	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z:PROC ; CvPlot::setRevealed
; Function compile flags: /Odtp
;	COMDAT ?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237447 = -8						; size = 4
_iI$ = -4						; size = 4
_eTeam$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_bTerrainOnly$ = 16					; size = 1
?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z PROC	; CvMap::setRevealedPlots, COMDAT
; _this$ = ecx

; 589  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 590  : #ifdef AUI_WARNING_FIXES
; 591  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 592  : #else
; 593  : 	int iI;
; 594  : 
; 595  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@setReveale
$LN2@setReveale:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@setReveale:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237447[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237447[ebp]
	jge	SHORT $LN4@setReveale

; 596  : #endif
; 597  : 	{
; 598  : 		plotByIndexUnchecked(iI)->setRevealed(eTeam, bNewValue, bTerrainOnly);

	push	-1
	movzx	ecx, BYTE PTR _bTerrainOnly$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bNewValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _eTeam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?setRevealed@CvPlot@@QAE_NW4TeamTypes@@_N10@Z ; CvPlot::setRevealed
	jmp	SHORT $LN2@setReveale
$LN4@setReveale:

; 599  : 	}
; 600  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setRevealedPlots@CvMap@@QAEXW4TeamTypes@@_N1@Z ENDP	; CvMap::setRevealedPlots
_TEXT	ENDS
PUBLIC	?recalculateAreas@CvMap@@QAEXXZ			; CvMap::recalculateAreas
PUBLIC	?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z	; CvMap::setAllPlotTypes
EXTRN	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z:PROC ; CvPlot::setPlotType
; Function compile flags: /Odtp
;	COMDAT ?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237456 = -8						; size = 4
_i$234933 = -4						; size = 4
_ePlotType$ = 8						; size = 4
?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z PROC	; CvMap::setAllPlotTypes, COMDAT
; _this$ = ecx

; 605  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 
; 607  : #ifdef AUI_WARNING_FIXES
; 608  : 	for (uint i = 0; i < numPlots(); i++)
; 609  : #else
; 610  : 	for(int i=0; i<numPlots(); i++)

	mov	DWORD PTR _i$234933[ebp], 0
	jmp	SHORT $LN3@setAllPlot
$LN2@setAllPlot:
	mov	eax, DWORD PTR _i$234933[ebp]
	add	eax, 1
	mov	DWORD PTR _i$234933[ebp], eax
$LN3@setAllPlot:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237456[ebp], edx
	mov	eax, DWORD PTR _i$234933[ebp]
	cmp	eax, DWORD PTR $T237456[ebp]
	jge	SHORT $LN1@setAllPlot

; 611  : #endif
; 612  : 	{
; 613  : 		plotByIndexUnchecked(i)->setPlotType(ePlotType, false, false);

	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _ePlotType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _i$234933[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 614  : 	}

	jmp	SHORT $LN2@setAllPlot
$LN1@setAllPlot:

; 615  : 
; 616  : 	recalculateAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas

; 617  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setAllPlotTypes@CvMap@@QAEXW4PlotTypes@@@Z ENDP	; CvMap::setAllPlotTypes
_TEXT	ENDS
PUBLIC	?doTurn@CvMap@@QAEXXZ				; CvMap::doTurn
EXTRN	?doTurn@CvPlot@@QAEXXZ:PROC			; CvPlot::doTurn
; Function compile flags: /Odtp
;	COMDAT ?doTurn@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237465 = -8						; size = 4
_iI$ = -4						; size = 4
?doTurn@CvMap@@QAEXXZ PROC				; CvMap::doTurn, COMDAT
; _this$ = ecx

; 622  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 623  : #ifdef AUI_WARNING_FIXES
; 624  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 625  : #else
; 626  : 	int iI;
; 627  : 
; 628  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@doTurn
$LN2@doTurn:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@doTurn:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237465[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237465[ebp]
	jge	SHORT $LN4@doTurn

; 629  : #endif
; 630  : 	{
; 631  : 		plotByIndexUnchecked(iI)->doTurn();

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?doTurn@CvPlot@@QAEXXZ			; CvPlot::doTurn
	jmp	SHORT $LN2@doTurn
$LN4@doTurn:

; 632  : 	}
; 633  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?doTurn@CvMap@@QAEXXZ ENDP				; CvMap::doTurn
_TEXT	ENDS
PUBLIC	?updateFog@CvMap@@QAEXXZ			; CvMap::updateFog
EXTRN	?updateFog@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateFog
; Function compile flags: /Odtp
;	COMDAT ?updateFog@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237474 = -8						; size = 4
_iI$ = -4						; size = 4
?updateFog@CvMap@@QAEXXZ PROC				; CvMap::updateFog, COMDAT
; _this$ = ecx

; 638  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 639  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 640  : #pragma omp parallel for
; 641  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 642  : #elif defined(AUI_WARNING_FIXES)
; 643  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 644  : #elif defined(AUI_USE_OPENMP)
; 645  : #pragma omp parallel for
; 646  : 	for (int iI = 0; iI < numPlots(); iI++)
; 647  : #else
; 648  : 	int iI;
; 649  : 
; 650  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateFog
$LN2@updateFog:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateFog:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237474[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237474[ebp]
	jge	SHORT $LN4@updateFog

; 651  : #endif
; 652  : 	{
; 653  : 		plotByIndexUnchecked(iI)->updateFog();

	push	0
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog
	jmp	SHORT $LN2@updateFog
$LN4@updateFog:

; 654  : 	}
; 655  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateFog@CvMap@@QAEXXZ ENDP				; CvMap::updateFog
_TEXT	ENDS
PUBLIC	?updateDeferredFog@CvMap@@QAEXXZ		; CvMap::updateDeferredFog
; Function compile flags: /Odtp
;	COMDAT ?updateDeferredFog@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T237505 = -16						; size = 4
_i$237500 = -12						; size = 4
$T237483 = -8						; size = 4
_uiI$234954 = -4					; size = 4
?updateDeferredFog@CvMap@@QAEXXZ PROC			; CvMap::updateDeferredFog, COMDAT
; _this$ = ecx

; 660  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 	for(uint uiI=0; uiI < m_vDeferredFogPlots.size(); uiI++)

	mov	DWORD PTR _uiI$234954[ebp], 0
	jmp	SHORT $LN3@updateDefe
$LN2@updateDefe:
	mov	eax, DWORD PTR _uiI$234954[ebp]
	add	eax, 1
	mov	DWORD PTR _uiI$234954[ebp], eax
$LN3@updateDefe:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T237483[ebp], edx
	mov	eax, DWORD PTR _uiI$234954[ebp]
	cmp	eax, DWORD PTR $T237483[ebp]
	jae	SHORT $LN1@updateDefe

; 662  : 	{
; 663  : 		m_vDeferredFogPlots[uiI]->updateFog();

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _uiI$234954[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	call	?updateFog@CvPlot@@QAEX_N@Z		; CvPlot::updateFog

; 664  : 	}

	jmp	SHORT $LN2@updateDefe
$LN1@updateDefe:

; 665  : 	m_vDeferredFogPlots.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T237505[ebp], ecx
	xor	edx, edx
	je	SHORT $LN16@updateDefe
	mov	DWORD PTR _i$237500[ebp], 0
	jmp	SHORT $LN14@updateDefe
$LN13@updateDefe:
	mov	eax, DWORD PTR _i$237500[ebp]
	add	eax, 1
	mov	DWORD PTR _i$237500[ebp], eax
$LN14@updateDefe:
	mov	ecx, DWORD PTR $T237505[ebp]
	mov	edx, DWORD PTR _i$237500[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jae	SHORT $LN16@updateDefe
	jmp	SHORT $LN13@updateDefe
$LN16@updateDefe:
	mov	eax, DWORD PTR $T237505[ebp]
	mov	DWORD PTR [eax+4], 0

; 666  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateDeferredFog@CvMap@@QAEXXZ ENDP			; CvMap::updateDeferredFog
_TEXT	ENDS
PUBLIC	?updateVisibility@CvMap@@QAEXXZ			; CvMap::updateVisibility
EXTRN	?updateVisibility@CvPlot@@QAEXXZ:PROC		; CvPlot::updateVisibility
; Function compile flags: /Odtp
;	COMDAT ?updateVisibility@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237511 = -8						; size = 4
_iI$ = -4						; size = 4
?updateVisibility@CvMap@@QAEXXZ PROC			; CvMap::updateVisibility, COMDAT
; _this$ = ecx

; 671  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 672  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 673  : #pragma omp parallel for
; 674  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 675  : #elif defined(AUI_WARNING_FIXES)
; 676  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 677  : #elif defined(AUI_USE_OPENMP)
; 678  : #pragma omp parallel for
; 679  : 	for (int iI = 0; iI < numPlots(); iI++)
; 680  : #else
; 681  : 	int iI;
; 682  : 
; 683  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateVisi
$LN2@updateVisi:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateVisi:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237511[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237511[ebp]
	jge	SHORT $LN4@updateVisi

; 684  : #endif
; 685  : 	{
; 686  : 		plotByIndexUnchecked(iI)->updateVisibility();

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?updateVisibility@CvPlot@@QAEXXZ	; CvPlot::updateVisibility
	jmp	SHORT $LN2@updateVisi
$LN4@updateVisi:

; 687  : 	}
; 688  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateVisibility@CvMap@@QAEXXZ ENDP			; CvMap::updateVisibility
_TEXT	ENDS
PUBLIC	?updateLayout@CvMap@@QAEX_N@Z			; CvMap::updateLayout
EXTRN	?setLayoutDirty@CvPlot@@QAEX_N@Z:PROC		; CvPlot::setLayoutDirty
EXTRN	?updateLayout@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateLayout
EXTRN	?isLayoutDirty@CvPlot@@QBE_NXZ:PROC		; CvPlot::isLayoutDirty
; Function compile flags: /Odtp
;	COMDAT ?updateLayout@CvMap@@QAEX_N@Z
_TEXT	SEGMENT
tv87 = -24						; size = 4
_this$ = -20						; size = 4
$T237527 = -16						; size = 4
$T237520 = -12						; size = 4
_pThisPlot$234973 = -8					; size = 4
_iI$234969 = -4						; size = 4
_bDebug$ = 8						; size = 1
?updateLayout@CvMap@@QAEX_N@Z PROC			; CvMap::updateLayout, COMDAT
; _this$ = ecx

; 692  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 693  : #ifdef AUI_WARNING_FIXES
; 694  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 695  : #else
; 696  : 	for(int iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$234969[ebp], 0
	jmp	SHORT $LN4@updateLayo
$LN3@updateLayo:
	mov	eax, DWORD PTR _iI$234969[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$234969[ebp], eax
$LN4@updateLayo:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237520[ebp], edx
	mov	eax, DWORD PTR _iI$234969[ebp]
	cmp	eax, DWORD PTR $T237520[ebp]
	jge	SHORT $LN2@updateLayo

; 697  : #endif
; 698  : 	{
; 699  : 		CvPlot* pThisPlot = plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR _iI$234969[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pThisPlot$234973[ebp], ecx

; 700  : 		if(pThisPlot && pThisPlot->isLayoutDirty())

	je	SHORT $LN1@updateLayo
	mov	ecx, DWORD PTR _pThisPlot$234973[ebp]
	call	?isLayoutDirty@CvPlot@@QBE_NXZ		; CvPlot::isLayoutDirty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@updateLayo

; 701  : 		{
; 702  : 			pThisPlot->updateLayout(bDebug);

	movzx	ecx, BYTE PTR _bDebug$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pThisPlot$234973[ebp]
	call	?updateLayout@CvPlot@@QAEX_N@Z		; CvPlot::updateLayout

; 703  : 			pThisPlot->setLayoutDirty(false);

	push	0
	mov	ecx, DWORD PTR _pThisPlot$234973[ebp]
	call	?setLayoutDirty@CvPlot@@QAEX_N@Z	; CvPlot::setLayoutDirty
$LN1@updateLayo:

; 704  : 		}
; 705  : 	}

	jmp	SHORT $LN3@updateLayo
$LN2@updateLayo:

; 706  : 	DLLUI->setDirty(PlotData_DIRTY_BIT,false);

	mov	edx, DWORD PTR $T237527[ebp]
	mov	DWORD PTR tv87[ebp], edx
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	DWORD PTR tv87[ebp], eax
	push	0
	push	33					; 00000021H
	mov	ecx, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+260]
	call	eax

; 707  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateLayout@CvMap@@QAEX_N@Z ENDP			; CvMap::updateLayout
_TEXT	ENDS
PUBLIC	?updateSight@CvMap@@QAEX_N@Z			; CvMap::updateSight
EXTRN	?updateSight@CvPlot@@QAEX_N@Z:PROC		; CvPlot::updateSight
; Function compile flags: /Odtp
;	COMDAT ?updateSight@CvMap@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237533 = -8						; size = 4
_iI$ = -4						; size = 4
_bIncrement$ = 8					; size = 1
?updateSight@CvMap@@QAEX_N@Z PROC			; CvMap::updateSight, COMDAT
; _this$ = ecx

; 711  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 712  : #ifdef AUI_WARNING_FIXES
; 713  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 714  : #else
; 715  : 	int iI;
; 716  : 
; 717  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateSigh
$LN2@updateSigh:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateSigh:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237533[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237533[ebp]
	jge	SHORT $LN4@updateSigh

; 718  : #endif
; 719  : 	{
; 720  : 		plotByIndexUnchecked(iI)->updateSight(bIncrement);

	movzx	ecx, BYTE PTR _bIncrement$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?updateSight@CvPlot@@QAEX_N@Z		; CvPlot::updateSight
	jmp	SHORT $LN2@updateSigh
$LN4@updateSigh:

; 721  : 	}
; 722  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?updateSight@CvMap@@QAEX_N@Z ENDP			; CvMap::updateSight
_TEXT	ENDS
PUBLIC	?updateCenterUnit@CvMap@@QAEXXZ			; CvMap::updateCenterUnit
EXTRN	?updateCenterUnit@CvPlot@@QAEXXZ:PROC		; CvPlot::updateCenterUnit
; Function compile flags: /Odtp
;	COMDAT ?updateCenterUnit@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237542 = -8						; size = 4
_iI$ = -4						; size = 4
?updateCenterUnit@CvMap@@QAEXXZ PROC			; CvMap::updateCenterUnit, COMDAT
; _this$ = ecx

; 727  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 728  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 729  : #pragma omp parallel for
; 730  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 731  : #elif defined(AUI_WARNING_FIXES)
; 732  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 733  : #elif defined(AUI_USE_OPENMP)
; 734  : #pragma omp parallel for
; 735  : 	for (int iI = 0; iI < numPlots(); iI++)
; 736  : #else
; 737  : 	int iI;
; 738  : 
; 739  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateCent
$LN2@updateCent:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateCent:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237542[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237542[ebp]
	jge	SHORT $LN4@updateCent

; 740  : #endif
; 741  : 	{
; 742  : 		plotByIndexUnchecked(iI)->updateCenterUnit();

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?updateCenterUnit@CvPlot@@QAEXXZ	; CvPlot::updateCenterUnit
	jmp	SHORT $LN2@updateCent
$LN4@updateCent:

; 743  : 	}
; 744  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateCenterUnit@CvMap@@QAEXXZ ENDP			; CvMap::updateCenterUnit
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
PUBLIC	?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z	; CvMap::updateWorkingCity
EXTRN	?updateWorkingCity@CvPlot@@QAEXXZ:PROC		; CvPlot::updateWorkingCity
; Function compile flags: /Odtp
;	COMDAT ?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T237691 = -104						; size = 4
$T237555 = -24						; size = 4
$T237551 = -20						; size = 4
_iI$235007 = -16					; size = 4
_pLoopPlot$235004 = -12					; size = 4
_iY$235000 = -8						; size = 4
_iX$234996 = -4						; size = 4
_pPlot$ = 8						; size = 4
_iRange$ = 12						; size = 4
?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z PROC	; CvMap::updateWorkingCity, COMDAT
; _this$ = ecx

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	DWORD PTR _this$[ebp], ecx

; 750  : 	if(pPlot && iRange > 0)

	cmp	DWORD PTR _pPlot$[ebp], 0
	je	$LN12@updateWork
	cmp	DWORD PTR _iRange$[ebp], 0
	jle	SHORT $LN12@updateWork

; 751  : 	{
; 752  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 753  : 		int iMaxDX, iDX;
; 754  : 		CvPlot* pLoopPlot;
; 755  : 		for (int iDY = -iRange; iDY <= iRange; iDY++)
; 756  : 		{
; 757  : 			iMaxDX = iRange - MAX(0, iDY);
; 758  : 			for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 759  : 			{
; 760  : 				// No need for range check because loops are set up properly
; 761  : 				pLoopPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 762  : #else
; 763  : 		for(int iX = -iRange; iX <= iRange; iX++)

	mov	eax, DWORD PTR _iRange$[ebp]
	neg	eax
	mov	DWORD PTR _iX$234996[ebp], eax
	jmp	SHORT $LN11@updateWork
$LN10@updateWork:
	mov	ecx, DWORD PTR _iX$234996[ebp]
	add	ecx, 1
	mov	DWORD PTR _iX$234996[ebp], ecx
$LN11@updateWork:
	mov	edx, DWORD PTR _iX$234996[ebp]
	cmp	edx, DWORD PTR _iRange$[ebp]
	jg	SHORT $LN9@updateWork

; 764  : 		{
; 765  : 			for(int iY = -iRange; iY <= iRange; iY++)

	mov	eax, DWORD PTR _iRange$[ebp]
	neg	eax
	mov	DWORD PTR _iY$235000[ebp], eax
	jmp	SHORT $LN8@updateWork
$LN7@updateWork:
	mov	ecx, DWORD PTR _iY$235000[ebp]
	add	ecx, 1
	mov	DWORD PTR _iY$235000[ebp], ecx
$LN8@updateWork:
	mov	edx, DWORD PTR _iY$235000[ebp]
	cmp	edx, DWORD PTR _iRange$[ebp]
	jg	SHORT $LN6@updateWork

; 766  : 			{
; 767  : 				CvPlot* pLoopPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iX, iY, iRange);

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T237551[ebp], ecx
	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T237555[ebp], eax
	mov	ecx, DWORD PTR _iRange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iY$235000[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$234996[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237551[ebp]
	push	ecx
	mov	edx, DWORD PTR $T237555[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$235004[ebp], eax

; 768  : #endif
; 769  : 				if(pLoopPlot)

	cmp	DWORD PTR _pLoopPlot$235004[ebp], 0
	je	SHORT $LN5@updateWork

; 770  : 				{
; 771  : 					pLoopPlot->updateWorkingCity();

	mov	ecx, DWORD PTR _pLoopPlot$235004[ebp]
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity
$LN5@updateWork:

; 772  : 				}
; 773  : 			}

	jmp	SHORT $LN7@updateWork
$LN6@updateWork:

; 774  : 		}

	jmp	SHORT $LN10@updateWork
$LN9@updateWork:

; 775  : 	}
; 776  : 	else

	jmp	SHORT $LN13@updateWork
$LN12@updateWork:

; 777  : 	{
; 778  : #ifdef AUI_WARNING_FIXES
; 779  : 		for (uint iI = 0; iI < numPlots(); iI++)
; 780  : #else
; 781  : 		for(int iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$235007[ebp], 0
	jmp	SHORT $LN3@updateWork
$LN2@updateWork:
	mov	eax, DWORD PTR _iI$235007[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$235007[ebp], eax
$LN3@updateWork:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237691[ebp], edx
	mov	eax, DWORD PTR _iI$235007[ebp]
	cmp	eax, DWORD PTR $T237691[ebp]
	jge	SHORT $LN13@updateWork

; 782  : #endif
; 783  : 		{
; 784  : 			plotByIndexUnchecked(iI)->updateWorkingCity();

	mov	ecx, DWORD PTR _iI$235007[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?updateWorkingCity@CvPlot@@QAEXXZ	; CvPlot::updateWorkingCity

; 785  : 		}

	jmp	SHORT $LN2@updateWork
$LN13@updateWork:

; 786  : 	}
; 787  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?updateWorkingCity@CvMap@@QAEXPAVCvPlot@@H@Z ENDP	; CvMap::updateWorkingCity
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
tv83 = -96						; size = 4
tv81 = -92						; size = 4
tv78 = -88						; size = 4
tv74 = -84						; size = 4
tv71 = -80						; size = 4
_iAbsDY$216767 = -20					; size = 4
_iAbsDX$216766 = -16					; size = 4
_iAbsDY$216764 = -12					; size = 4
_iAbsDX$216763 = -8					; size = 4
_hexRange$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	xor	eax, eax
	cmp	DWORD PTR _iDX$[ebp], 0
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN3@plotXYWith

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN6@plotXYWith
	mov	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN7@plotXYWith
$LN6@plotXYWith:
	mov	eax, DWORD PTR _iDX$[ebp]
	neg	eax
	mov	DWORD PTR tv71[ebp], eax
$LN7@plotXYWith:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _iAbsDX$216763[ebp], ecx

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN8@plotXYWith
	mov	edx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN9@plotXYWith
$LN8@plotXYWith:
	mov	eax, DWORD PTR _iDY$[ebp]
	neg	eax
	mov	DWORD PTR tv74[ebp], eax
$LN9@plotXYWith:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _iAbsDY$216764[ebp], ecx

; 245  : 		hexRange = iAbsDX + iAbsDY;

	mov	edx, DWORD PTR _iAbsDX$216763[ebp]
	add	edx, DWORD PTR _iAbsDY$216764[ebp]
	mov	DWORD PTR _hexRange$[ebp], edx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN2@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	cmp	DWORD PTR _iDX$[ebp], 0
	jl	SHORT $LN10@plotXYWith
	mov	eax, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN11@plotXYWith
$LN10@plotXYWith:
	mov	ecx, DWORD PTR _iDX$[ebp]
	neg	ecx
	mov	DWORD PTR tv78[ebp], ecx
$LN11@plotXYWith:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _iAbsDX$216766[ebp], edx

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	cmp	DWORD PTR _iDY$[ebp], 0
	jl	SHORT $LN12@plotXYWith
	mov	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@plotXYWith
$LN12@plotXYWith:
	mov	ecx, DWORD PTR _iDY$[ebp]
	neg	ecx
	mov	DWORD PTR tv81[ebp], ecx
$LN13@plotXYWith:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _iAbsDY$216767[ebp], edx

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	mov	eax, DWORD PTR _iAbsDX$216766[ebp]
	cmp	eax, DWORD PTR _iAbsDY$216767[ebp]
	jl	SHORT $LN14@plotXYWith
	mov	ecx, DWORD PTR _iAbsDX$216766[ebp]
	mov	DWORD PTR tv83[ebp], ecx
	jmp	SHORT $LN15@plotXYWith
$LN14@plotXYWith:
	mov	edx, DWORD PTR _iAbsDY$216767[ebp]
	mov	DWORD PTR tv83[ebp], edx
$LN15@plotXYWith:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR _hexRange$[ebp], eax
$LN2@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	mov	ecx, DWORD PTR _hexRange$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN4@plotXYWith
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iX$[ebp]
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
$LN4@plotXYWith:

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
tv148 = -72						; size = 4
tv163 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
$T237949 = -56						; size = 4
$T237904 = -52						; size = 4
$T237891 = -48						; size = 4
$T237887 = -44						; size = 4
$T237873 = -40						; size = 4
$T237869 = -33						; size = 1
$T237858 = -32						; size = 4
$T237854 = -25						; size = 1
_iMapY$237948 = -24					; size = 4
_iMapX$237947 = -20					; size = 4
$T237847 = -16						; size = 4
_iPlotHexX$ = -12					; size = 4
_iPlotY$ = -8						; size = 4
_iStartHexX$ = -4					; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 213  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN5@plotXY
	mov	eax, DWORD PTR _iY$[ebp]
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN3@plotXY
$LN5@plotXY:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv82[ebp], eax
$LN3@plotXY:
	mov	ecx, DWORD PTR _iX$[ebp]
	sub	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _iStartHexX$[ebp], ecx

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	edx, DWORD PTR _iStartHexX$[ebp]
	add	edx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	js	SHORT $LN9@plotXY
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv86[ebp], ecx
	jmp	SHORT $LN7@plotXY
$LN9@plotXY:
	mov	eax, DWORD PTR _iPlotY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv86[ebp], eax
$LN7@plotXY:
	mov	edx, DWORD PTR _iPlotHexX$[ebp]
	add	edx, DWORD PTR tv86[ebp]
	mov	DWORD PTR _iPlotHexX$[ebp], edx

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T237847[ebp], eax
	cmp	DWORD PTR _iPlotHexX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN13@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN14@plotXY
$LN13@plotXY:
	mov	DWORD PTR $T237949[ebp], 0
	jmp	$LN15@plotXY
$LN14@plotXY:
	mov	ecx, DWORD PTR $T237847[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T237854[ebp], dl
	mov	eax, DWORD PTR $T237847[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237858[ebp], ecx
	movzx	edx, BYTE PTR $T237854[ebp]
	test	edx, edx
	je	SHORT $LN26@plotXY
	cmp	DWORD PTR _iPlotHexX$[ebp], 0
	jge	SHORT $LN25@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T237858[ebp]
	add	edx, DWORD PTR $T237858[ebp]
	mov	DWORD PTR _iMapX$237947[ebp], edx
	jmp	SHORT $LN27@plotXY
	jmp	SHORT $LN26@plotXY
$LN25@plotXY:
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cmp	eax, DWORD PTR $T237858[ebp]
	jl	SHORT $LN26@plotXY
	mov	eax, DWORD PTR _iPlotHexX$[ebp]
	cdq
	idiv	DWORD PTR $T237858[ebp]
	mov	DWORD PTR _iMapX$237947[ebp], edx
	jmp	SHORT $LN27@plotXY
$LN26@plotXY:
	mov	ecx, DWORD PTR _iPlotHexX$[ebp]
	mov	DWORD PTR _iMapX$237947[ebp], ecx
$LN27@plotXY:
	mov	edx, DWORD PTR $T237847[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T237869[ebp], al
	mov	ecx, DWORD PTR $T237847[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T237873[ebp], edx
	movzx	eax, BYTE PTR $T237869[ebp]
	test	eax, eax
	je	SHORT $LN36@plotXY
	cmp	DWORD PTR _iPlotY$[ebp], 0
	jge	SHORT $LN35@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T237873[ebp]
	add	edx, DWORD PTR $T237873[ebp]
	mov	DWORD PTR _iMapY$237948[ebp], edx
	jmp	SHORT $LN37@plotXY
	jmp	SHORT $LN36@plotXY
$LN35@plotXY:
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	cmp	ecx, DWORD PTR $T237873[ebp]
	jl	SHORT $LN36@plotXY
	mov	eax, DWORD PTR _iPlotY$[ebp]
	cdq
	idiv	DWORD PTR $T237873[ebp]
	mov	DWORD PTR _iMapY$237948[ebp], edx
	jmp	SHORT $LN37@plotXY
$LN36@plotXY:
	mov	edx, DWORD PTR _iPlotY$[ebp]
	mov	DWORD PTR _iMapY$237948[ebp], edx
$LN37@plotXY:
	cmp	DWORD PTR _iMapX$237947[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T237847[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237887[ebp], ecx
	mov	edx, DWORD PTR _iMapX$237947[ebp]
	cmp	edx, DWORD PTR $T237887[ebp]
	jge	SHORT $LN41@plotXY
	cmp	DWORD PTR _iMapY$237948[ebp], 0
	jl	SHORT $LN41@plotXY
	mov	eax, DWORD PTR $T237847[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T237891[ebp], ecx
	mov	edx, DWORD PTR _iMapY$237948[ebp]
	cmp	edx, DWORD PTR $T237891[ebp]
	jge	SHORT $LN41@plotXY
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN39@plotXY
$LN41@plotXY:
	mov	DWORD PTR tv163[ebp], 0
$LN39@plotXY:
	cmp	DWORD PTR tv163[ebp], 0
	je	SHORT $LN17@plotXY
	mov	eax, DWORD PTR $T237847[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T237904[ebp], ecx
	mov	edx, DWORD PTR _iMapY$237948[ebp]
	imul	edx, DWORD PTR $T237904[ebp]
	add	edx, DWORD PTR _iMapX$237947[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T237847[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv148[ebp], edx
	jmp	SHORT $LN18@plotXY
$LN17@plotXY:
	mov	DWORD PTR tv148[ebp], 0
$LN18@plotXY:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR $T237949[ebp], ecx
$LN15@plotXY:
	mov	eax, DWORD PTR $T237949[ebp]

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
EXTRN	?updateYield@CvPlot@@QAEXXZ:PROC		; CvPlot::updateYield
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
;	COMDAT ?updateYield@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237955 = -8						; size = 4
_iI$ = -4						; size = 4
?updateYield@CvMap@@QAEXXZ PROC				; CvMap::updateYield, COMDAT
; _this$ = ecx

; 792  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : #ifdef AUI_WARNING_FIXES
; 794  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 795  : #else
; 796  : 	int iI;
; 797  : 
; 798  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateYiel
$LN2@updateYiel:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateYiel:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237955[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237955[ebp]
	jge	SHORT $LN4@updateYiel

; 799  : #endif
; 800  : 	{
; 801  : 		plotByIndexUnchecked(iI)->updateYield();

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?updateYield@CvPlot@@QAEXXZ		; CvPlot::updateYield
	jmp	SHORT $LN2@updateYiel
$LN4@updateYiel:

; 802  : 	}
; 803  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateYield@CvMap@@QAEXXZ ENDP				; CvMap::updateYield
_TEXT	ENDS
PUBLIC	?updateAdjacency@CvMap@@QAEXXZ			; CvMap::updateAdjacency
EXTRN	?isAdjacentToLand@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentToLand
; Function compile flags: /Odtp
;	COMDAT ?updateAdjacency@CvMap@@QAEXXZ
_TEXT	SEGMENT
tv74 = -17						; size = 1
_this$ = -16						; size = 4
$T237964 = -12						; size = 4
_pPlot$235025 = -8					; size = 4
_iI$ = -4						; size = 4
?updateAdjacency@CvMap@@QAEXXZ PROC			; CvMap::updateAdjacency, COMDAT
; _this$ = ecx

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 809  : #if defined(AUI_WARNING_FIXES) && defined(AUI_USE_OPENMP)
; 810  : #pragma omp parallel for
; 811  : 	for (int iI = 0; iI < (int)numPlots(); iI++)
; 812  : #elif defined(AUI_WARNING_FIXES)
; 813  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 814  : #elif defined(AUI_USE_OPENMP)
; 815  : #pragma omp parallel for
; 816  : 	for (int iI = 0; iI < numPlots(); iI++)
; 817  : #else
; 818  : 	int iI;
; 819  : 
; 820  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@updateAdja
$LN2@updateAdja:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@updateAdja:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237964[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237964[ebp]
	jge	SHORT $LN4@updateAdja

; 821  : #endif
; 822  : 	{
; 823  : 		CvPlot* pPlot = plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pPlot$235025[ebp], ecx

; 824  : 		pPlot->m_bIsAdjacentToLand = pPlot->isAdjacentToLand();

	mov	ecx, DWORD PTR _pPlot$235025[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	mov	BYTE PTR tv74[ebp], al
	mov	al, BYTE PTR tv74[ebp]
	and	al, 1
	shl	al, 6
	mov	ecx, DWORD PTR _pPlot$235025[ebp]
	mov	dl, BYTE PTR [ecx+462]
	and	dl, 191					; 000000bfH
	or	dl, al
	mov	eax, DWORD PTR _pPlot$235025[ebp]
	mov	BYTE PTR [eax+462], dl
	jmp	SHORT $LN2@updateAdja
$LN4@updateAdja:

; 825  : 	}
; 826  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?updateAdjacency@CvMap@@QAEXXZ ENDP			; CvMap::updateAdjacency
_TEXT	ENDS
PUBLIC	?verifyUnitValidPlot@CvMap@@QAEXXZ		; CvMap::verifyUnitValidPlot
EXTRN	?verifyUnitValidPlot@CvPlot@@QAEXXZ:PROC	; CvPlot::verifyUnitValidPlot
; Function compile flags: /Odtp
;	COMDAT ?verifyUnitValidPlot@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T237973 = -8						; size = 4
_iI$ = -4						; size = 4
?verifyUnitValidPlot@CvMap@@QAEXXZ PROC			; CvMap::verifyUnitValidPlot, COMDAT
; _this$ = ecx

; 830  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 831  : #ifdef AUI_WARNING_FIXES
; 832  : 	for (uint iI = 0; iI < numPlots(); iI++)
; 833  : #else
; 834  : 	int iI;
; 835  : 
; 836  : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@verifyUnit
$LN2@verifyUnit:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN3@verifyUnit:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T237973[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T237973[ebp]
	jge	SHORT $LN4@verifyUnit

; 837  : #endif
; 838  : 	{
; 839  : 		plotByIndexUnchecked(iI)->verifyUnitValidPlot();

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?verifyUnitValidPlot@CvPlot@@QAEXXZ	; CvPlot::verifyUnitValidPlot
	jmp	SHORT $LN2@verifyUnit
$LN4@verifyUnit:

; 840  : 	}
; 841  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?verifyUnitValidPlot@CvMap@@QAEXXZ ENDP			; CvMap::verifyUnitValidPlot
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
PUBLIC	??_C@_0BA@COGMMLGC@Rand?5Plot?5Width?$AA@	; `string'
PUBLIC	??_C@_0BB@LEKJMANB@Rand?5Plot?5Height?$AA@	; `string'
PUBLIC	?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z	; CvMap::syncRandPlot
EXTRN	?isVisibleToCivTeam@CvPlot@@QBE_NXZ:PROC	; CvPlot::isVisibleToCivTeam
EXTRN	?isAdjacentOwned@CvPlot@@QBE_NXZ:PROC		; CvPlot::isAdjacentOwned
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?isUnit@CvPlot@@QBE_NXZ:PROC			; CvPlot::isUnit
EXTRN	?getJonRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getJonRandNum
;	COMDAT ??_C@_0BA@COGMMLGC@Rand?5Plot?5Width?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
CONST	SEGMENT
??_C@_0BA@COGMMLGC@Rand?5Plot?5Width?$AA@ DB 'Rand Plot Width', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LEKJMANB@Rand?5Plot?5Height?$AA@
CONST	SEGMENT
??_C@_0BB@LEKJMANB@Rand?5Plot?5Height?$AA@ DB 'Rand Plot Height', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
CONST	ENDS
;	COMDAT ?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_this$ = -144						; size = 4
$T238026 = -68						; size = 4
$T238022 = -64						; size = 4
$T238018 = -60						; size = 4
$T238014 = -56						; size = 4
$T238013 = -52						; size = 4
$T238000 = -48						; size = 4
$T237994 = -44						; size = 4
$T237990 = -40						; size = 4
$T237986 = -36						; size = 4
$T237982 = -32						; size = 4
_iCount$ = -28						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_pPlot$ = -16						; size = 4
_bValid$ = -9						; size = 1
_pTestPlot$ = -8					; size = 4
_pLoopPlot$ = -4					; size = 4
_iFlags$ = 8						; size = 4
_iArea$ = 12						; size = 4
_iMinUnitDistance$ = 16					; size = 4
_iTimeout$ = 20						; size = 4
?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z PROC		; CvMap::syncRandPlot, COMDAT
; _this$ = ecx

; 846  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	DWORD PTR _this$[ebp], ecx

; 847  : 	CvPlot* pPlot;
; 848  : 	CvPlot* pTestPlot;
; 849  : 	CvPlot* pLoopPlot;
; 850  : 	bool bValid;
; 851  : 	int iCount;
; 852  : 	int iDX, iDY;
; 853  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 854  : 	int iMaxDX;
; 855  : #endif
; 856  : 
; 857  : 	pPlot = NULL;

	mov	DWORD PTR _pPlot$[ebp], 0

; 858  : 
; 859  : 	iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0
$LN37@syncRandPl:

; 860  : 
; 861  : 	while(iCount < iTimeout)

	mov	eax, DWORD PTR _iCount$[ebp]
	cmp	eax, DWORD PTR _iTimeout$[ebp]
	jge	$LN36@syncRandPl

; 862  : 	{
; 863  : 		iCount++;

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iCount$[ebp], ecx

; 864  : 		pTestPlot = plotCheckInvalid(GC.getGame().getJonRandNum(getGridWidth(), "Rand Plot Width"), GC.getGame().getJonRandNum(getGridHeight(), "Rand Plot Height"));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T237982[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237986[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T237990[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T237994[ebp], ecx
	push	OFFSET ??_C@_0BB@LEKJMANB@Rand?5Plot?5Height?$AA@
	mov	edx, DWORD PTR $T237982[ebp]
	push	edx
	mov	ecx, DWORD PTR $T237986[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR $T238014[ebp], eax
	push	OFFSET ??_C@_0BA@COGMMLGC@Rand?5Plot?5Width?$AA@
	mov	eax, DWORD PTR $T237990[ebp]
	push	eax
	mov	ecx, DWORD PTR $T237994[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR $T238013[ebp], eax
	cmp	DWORD PTR $T238013[ebp], -2147483647	; 80000001H
	je	SHORT $LN48@syncRandPl
	cmp	DWORD PTR $T238014[ebp], -2147483647	; 80000001H
	jne	SHORT $LN49@syncRandPl
$LN48@syncRandPl:
	mov	DWORD PTR _pTestPlot$[ebp], 0
	jmp	SHORT $LN50@syncRandPl
$LN49@syncRandPl:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T238000[ebp], edx
	mov	eax, DWORD PTR $T238014[ebp]
	imul	eax, DWORD PTR $T238000[ebp]
	add	eax, DWORD PTR $T238013[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pTestPlot$[ebp], eax
$LN50@syncRandPl:

; 865  : 
; 866  : 		CvAssertMsg(pTestPlot != NULL, "TestPlot is not assigned a valid value");
; 867  : 
; 868  : 		if(!pTestPlot) continue;

	cmp	DWORD PTR _pTestPlot$[ebp], 0
	jne	SHORT $LN35@syncRandPl
	jmp	$LN37@syncRandPl
$LN35@syncRandPl:

; 869  : 
; 870  : 		if((iArea == -1) || (pTestPlot->getArea() == iArea))

	cmp	DWORD PTR _iArea$[ebp], -1
	je	SHORT $LN33@syncRandPl
	mov	edx, DWORD PTR _pTestPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T238018[ebp], eax
	mov	ecx, DWORD PTR $T238018[ebp]
	cmp	ecx, DWORD PTR _iArea$[ebp]
	jne	$LN34@syncRandPl
$LN33@syncRandPl:

; 871  : 		{
; 872  : 			bValid = true;

	mov	BYTE PTR _bValid$[ebp], 1

; 873  : 
; 874  : 			if(bValid)

	movzx	edx, BYTE PTR _bValid$[ebp]
	test	edx, edx
	je	$LN32@syncRandPl

; 875  : 			{
; 876  : 				if(iMinUnitDistance != -1)

	cmp	DWORD PTR _iMinUnitDistance$[ebp], -1
	je	$LN32@syncRandPl

; 877  : 				{
; 878  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 879  : 					for (iDY = -iMinUnitDistance; iDY <= iMinUnitDistance; iDY++)
; 880  : 					{
; 881  : 						iMaxDX = iMinUnitDistance - MAX(0, iDY);
; 882  : 						for (iDX = -iMinUnitDistance - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 883  : 						{
; 884  : 							// No need for range check because loops are set up properly
; 885  : 							pLoopPlot = plotXY(pTestPlot->getX(), pTestPlot->getY(), iDX, iDY);
; 886  : #else
; 887  : 					for(iDX = -(iMinUnitDistance); iDX <= iMinUnitDistance; iDX++)

	mov	eax, DWORD PTR _iMinUnitDistance$[ebp]
	neg	eax
	mov	DWORD PTR _iDX$[ebp], eax
	jmp	SHORT $LN30@syncRandPl
$LN29@syncRandPl:
	mov	ecx, DWORD PTR _iDX$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDX$[ebp], ecx
$LN30@syncRandPl:
	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iMinUnitDistance$[ebp]
	jg	SHORT $LN32@syncRandPl

; 888  : 					{
; 889  : 						for(iDY = -(iMinUnitDistance); iDY <= iMinUnitDistance; iDY++)

	mov	eax, DWORD PTR _iMinUnitDistance$[ebp]
	neg	eax
	mov	DWORD PTR _iDY$[ebp], eax
	jmp	SHORT $LN27@syncRandPl
$LN26@syncRandPl:
	mov	ecx, DWORD PTR _iDY$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iDY$[ebp], ecx
$LN27@syncRandPl:
	mov	edx, DWORD PTR _iDY$[ebp]
	cmp	edx, DWORD PTR _iMinUnitDistance$[ebp]
	jg	SHORT $LN25@syncRandPl

; 890  : 						{
; 891  : 							pLoopPlot	= plotXYWithRangeCheck(pTestPlot->getX(), pTestPlot->getY(), iDX, iDY, iMinUnitDistance);

	mov	eax, DWORD PTR _pTestPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T238022[ebp], ecx
	mov	edx, DWORD PTR _pTestPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T238026[ebp], eax
	mov	ecx, DWORD PTR _iMinUnitDistance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238022[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238026[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 892  : #endif
; 893  : 
; 894  : 							if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN24@syncRandPl

; 895  : 							{
; 896  : 								if(pLoopPlot->isUnit())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isUnit@CvPlot@@QBE_NXZ			; CvPlot::isUnit
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN24@syncRandPl

; 897  : 								{
; 898  : 									bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN24@syncRandPl:

; 899  : 								}
; 900  : 							}
; 901  : 						}

	jmp	SHORT $LN26@syncRandPl
$LN25@syncRandPl:

; 902  : 					}

	jmp	SHORT $LN29@syncRandPl
$LN32@syncRandPl:

; 903  : 				}
; 904  : 			}
; 905  : 
; 906  : 			if(bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN22@syncRandPl

; 907  : 			{
; 908  : 				if(iFlags & RANDPLOT_LAND)

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 1
	je	SHORT $LN22@syncRandPl

; 909  : 				{
; 910  : 					if(pTestPlot->isWater())

	mov	eax, DWORD PTR _pTestPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	xor	edx, edx
	cmp	ecx, 3
	sete	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN22@syncRandPl

; 911  : 					{
; 912  : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN22@syncRandPl:

; 913  : 					}
; 914  : 				}
; 915  : 			}
; 916  : 
; 917  : 			if(bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@syncRandPl

; 918  : 			{
; 919  : 				if(iFlags & RANDPLOT_UNOWNED)

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 2
	je	SHORT $LN19@syncRandPl

; 920  : 				{
; 921  : 					if(pTestPlot->isOwned())

	mov	ecx, DWORD PTR _pTestPlot$[ebp]
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@syncRandPl

; 922  : 					{
; 923  : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN19@syncRandPl:

; 924  : 					}
; 925  : 				}
; 926  : 			}
; 927  : 
; 928  : 			if(bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN16@syncRandPl

; 929  : 			{
; 930  : 				if(iFlags & RANDPLOT_ADJACENT_UNOWNED)

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 4
	je	SHORT $LN16@syncRandPl

; 931  : 				{
; 932  : 					if(pTestPlot->isAdjacentOwned())

	mov	ecx, DWORD PTR _pTestPlot$[ebp]
	call	?isAdjacentOwned@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentOwned
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN16@syncRandPl

; 933  : 					{
; 934  : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN16@syncRandPl:

; 935  : 					}
; 936  : 				}
; 937  : 			}
; 938  : 
; 939  : 			if(bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@syncRandPl

; 940  : 			{
; 941  : 				if(iFlags & RANDPLOT_ADJACENT_LAND)

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 8
	je	SHORT $LN13@syncRandPl

; 942  : 				{
; 943  : 					if(!(pTestPlot->isAdjacentToLand()))

	mov	ecx, DWORD PTR _pTestPlot$[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@syncRandPl

; 944  : 					{
; 945  : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN13@syncRandPl:

; 946  : 					}
; 947  : 				}
; 948  : 			}
; 949  : 
; 950  : 			if(bValid)

	movzx	ecx, BYTE PTR _bValid$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@syncRandPl

; 951  : 			{
; 952  : 				if(iFlags & RANDPLOT_PASSIBLE)

	mov	edx, DWORD PTR _iFlags$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN10@syncRandPl

; 953  : 				{
; 954  : 					if(pTestPlot->isImpassable())

	mov	eax, DWORD PTR _pTestPlot$[ebp]
	mov	cl, BYTE PTR [eax+462]
	shr	cl, 7
	and	cl, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN10@syncRandPl

; 955  : 					{
; 956  : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN10@syncRandPl:

; 957  : 					}
; 958  : 				}
; 959  : 			}
; 960  : 
; 961  : 			if(bValid)

	movzx	eax, BYTE PTR _bValid$[ebp]
	test	eax, eax
	je	SHORT $LN7@syncRandPl

; 962  : 			{
; 963  : 				if(iFlags & RANDPLOT_NOT_VISIBLE_TO_CIV)

	mov	ecx, DWORD PTR _iFlags$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN7@syncRandPl

; 964  : 				{
; 965  : 					if(pTestPlot->isVisibleToCivTeam())

	mov	ecx, DWORD PTR _pTestPlot$[ebp]
	call	?isVisibleToCivTeam@CvPlot@@QBE_NXZ	; CvPlot::isVisibleToCivTeam
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@syncRandPl

; 966  : 					{
; 967  : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN7@syncRandPl:

; 968  : 					}
; 969  : 				}
; 970  : 			}
; 971  : 
; 972  : 			if(bValid)

	movzx	eax, BYTE PTR _bValid$[ebp]
	test	eax, eax
	je	SHORT $LN4@syncRandPl

; 973  : 			{
; 974  : 				if(iFlags & RANDPLOT_NOT_CITY)

	mov	ecx, DWORD PTR _iFlags$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN4@syncRandPl

; 975  : 				{
; 976  : 					if(pTestPlot->isCity())

	mov	ecx, DWORD PTR _pTestPlot$[ebp]
	call	?isCity@CvPlot@@QBE_NXZ			; CvPlot::isCity
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@syncRandPl

; 977  : 					{
; 978  : 						bValid = false;

	mov	BYTE PTR _bValid$[ebp], 0
$LN4@syncRandPl:

; 979  : 					}
; 980  : 				}
; 981  : 			}
; 982  : 
; 983  : 			if(bValid)

	movzx	eax, BYTE PTR _bValid$[ebp]
	test	eax, eax
	je	SHORT $LN34@syncRandPl

; 984  : 			{
; 985  : 				pPlot = pTestPlot;

	mov	ecx, DWORD PTR _pTestPlot$[ebp]
	mov	DWORD PTR _pPlot$[ebp], ecx

; 986  : 				break;

	jmp	SHORT $LN36@syncRandPl
$LN34@syncRandPl:

; 987  : 			}
; 988  : 		}
; 989  : 	}

	jmp	$LN37@syncRandPl
$LN36@syncRandPl:

; 990  : 
; 991  : 	return pPlot;

	mov	eax, DWORD PTR _pPlot$[ebp]

; 992  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?syncRandPlot@CvMap@@QAEPAVCvPlot@@HHHH@Z ENDP		; CvMap::syncRandPlot
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
PUBLIC	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity
EXTRN	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z:PROC ; estimateDirection
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
EXTRN	?waterArea@CvCity@@QBEPAVCvArea@@XZ:PROC	; CvCity::waterArea
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?area@CvCity@@QBEPAVCvArea@@XZ:PROC		; CvCity::area
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Odtp
;	COMDAT ?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z
_TEXT	SEGMENT
tv214 = -204						; size = 4
_this$ = -200						; size = 4
$T238311 = -116						; size = 4
$T238302 = -112						; size = 4
$T238273 = -92						; size = 4
$T238244 = -72						; size = 4
$T238235 = -68						; size = 4
$T238218 = -61						; size = 1
$T238176 = -60						; size = 4
$T238171 = -56						; size = 4
$T238167 = -49						; size = 1
$T238156 = -48						; size = 4
$T238152 = -41						; size = 1
_iMapY$238206 = -40					; size = 4
_iMapX$238205 = -36					; size = 4
_thisPlayer$235113 = -32				; size = 4
_pCheckPlot$ = -28					; size = 4
_iBestValue$ = -24					; size = 4
_pBestCity$ = -20					; size = 4
_iI$ = -16						; size = 4
_iValue$ = -12						; size = 4
_pLoopCity$ = -8					; size = 4
_iLoop$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eOwner$ = 16						; size = 4
_eTeam$ = 20						; size = 4
_bSameArea$ = 24					; size = 1
_bCoastalOnly$ = 28					; size = 1
_eTeamAtWarWith$ = 32					; size = 4
_eDirection$ = 36					; size = 4
_pSkipCity$ = 40					; size = 4
?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z PROC ; CvMap::findCity, COMDAT
; _this$ = ecx

; 996  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 	CvCity* pLoopCity;
; 998  : 	CvCity* pBestCity;
; 999  : 	int iValue;
; 1000 : 	int iBestValue;
; 1001 : 	int iLoop;
; 1002 : 	int iI;
; 1003 : 	CvPlot* pCheckPlot = plot(iX, iY);

	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN26@findCity
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN27@findCity
$LN26@findCity:
	mov	DWORD PTR _pCheckPlot$[ebp], 0
	jmp	$LN28@findCity
$LN27@findCity:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T238152[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T238156[ebp], eax
	movzx	ecx, BYTE PTR $T238152[ebp]
	test	ecx, ecx
	je	SHORT $LN39@findCity
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN38@findCity
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T238156[ebp]
	add	edx, DWORD PTR $T238156[ebp]
	mov	DWORD PTR _iMapX$238205[ebp], edx
	jmp	SHORT $LN40@findCity
	jmp	SHORT $LN39@findCity
$LN38@findCity:
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T238156[ebp]
	jl	SHORT $LN39@findCity
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T238156[ebp]
	mov	DWORD PTR _iMapX$238205[ebp], edx
	jmp	SHORT $LN40@findCity
$LN39@findCity:
	mov	eax, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$238205[ebp], eax
$LN40@findCity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T238167[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T238171[ebp], ecx
	movzx	edx, BYTE PTR $T238167[ebp]
	push	edx
	mov	eax, DWORD PTR $T238171[ebp]
	push	eax
	mov	ecx, DWORD PTR _iY$[ebp]
	push	ecx
	call	?coordRange@@YAHHH_N@Z			; coordRange
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _iMapY$238206[ebp], eax
	mov	edx, DWORD PTR _iMapY$238206[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$238205[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN30@findCity
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T238176[ebp], edx
	mov	eax, DWORD PTR _iMapY$238206[ebp]
	imul	eax, DWORD PTR $T238176[ebp]
	add	eax, DWORD PTR _iMapX$238205[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN31@findCity
$LN30@findCity:
	mov	DWORD PTR tv214[ebp], 0
$LN31@findCity:
	mov	edx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _pCheckPlot$[ebp], edx
$LN28@findCity:

; 1004 : 
; 1005 : 	CvAssertMsg(pCheckPlot != NULL, "Passed in an invalid plot to findCity");
; 1006 : 	if (pCheckPlot == NULL)

	cmp	DWORD PTR _pCheckPlot$[ebp], 0
	jne	SHORT $LN23@findCity

; 1007 : 		return NULL;

	xor	eax, eax
	jmp	$LN24@findCity
$LN23@findCity:

; 1008 : 
; 1009 : 	// XXX look for barbarian cities???
; 1010 : 
; 1011 : 	iBestValue = MAXINT;

	mov	DWORD PTR _iBestValue$[ebp], 2147483647	; 7fffffffH

; 1012 : 	pBestCity = NULL;

	mov	DWORD PTR _pBestCity$[ebp], 0

; 1013 : 
; 1014 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN22@findCity
$LN21@findCity:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN22@findCity:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN20@findCity

; 1015 : 	{
; 1016 : 		CvPlayer& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$235113[ebp], ecx

; 1017 : 		if(thisPlayer.isAlive())

	mov	edx, DWORD PTR _thisPlayer$235113[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238218[ebp], al
	movzx	ecx, BYTE PTR $T238218[ebp]
	test	ecx, ecx
	je	$LN19@findCity

; 1018 : 		{
; 1019 : 			if((eOwner == NO_PLAYER) || (iI == eOwner))

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN17@findCity
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _eOwner$[ebp]
	jne	$LN19@findCity
$LN17@findCity:

; 1020 : 			{
; 1021 : 				if((eTeam == NO_TEAM) || (thisPlayer.getTeam() == eTeam))

	cmp	DWORD PTR _eTeam$[ebp], -1
	je	SHORT $LN15@findCity
	mov	eax, DWORD PTR _thisPlayer$235113[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	cmp	eax, DWORD PTR _eTeam$[ebp]
	jne	$LN19@findCity
$LN15@findCity:

; 1022 : 				{
; 1023 : 					for(pLoopCity = thisPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = thisPlayer.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisPlayer$235113[ebp]
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
	jmp	SHORT $LN14@findCity
$LN13@findCity:
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisPlayer$235113[ebp]
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$[ebp], eax
$LN14@findCity:
	cmp	DWORD PTR _pLoopCity$[ebp], 0
	je	$LN19@findCity

; 1024 : 					{
; 1025 : 						if(!bSameArea || (pLoopCity->area() == pCheckPlot->area()) || (bCoastalOnly && (pLoopCity->waterArea() == pCheckPlot->area())))

	movzx	ecx, BYTE PTR _bSameArea$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@findCity
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?area@CvCity@@QBEPAVCvArea@@XZ		; CvCity::area
	mov	esi, eax
	mov	ecx, DWORD PTR _pCheckPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	esi, eax
	je	SHORT $LN10@findCity
	movzx	edx, BYTE PTR _bCoastalOnly$[ebp]
	test	edx, edx
	je	$LN11@findCity
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?waterArea@CvCity@@QBEPAVCvArea@@XZ	; CvCity::waterArea
	mov	esi, eax
	mov	ecx, DWORD PTR _pCheckPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	cmp	esi, eax
	jne	$LN11@findCity
$LN10@findCity:

; 1026 : 						{
; 1027 : 							if(!bCoastalOnly || pLoopCity->isCoastal())

	movzx	eax, BYTE PTR _bCoastalOnly$[ebp]
	test	eax, eax
	je	SHORT $LN8@findCity
	push	-1
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	movzx	ecx, al
	test	ecx, ecx
	je	$LN11@findCity
$LN8@findCity:

; 1028 : 							{
; 1029 : 								if((eTeamAtWarWith == NO_TEAM) || atWar(thisPlayer.getTeam(), eTeamAtWarWith))

	cmp	DWORD PTR _eTeamAtWarWith$[ebp], -1
	je	SHORT $LN6@findCity
	mov	edx, DWORD PTR _thisPlayer$235113[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPreGame::teamType
	add	esp, 4
	mov	DWORD PTR $T238235[ebp], eax
	mov	ecx, DWORD PTR _eTeamAtWarWith$[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238235[ebp]
	push	edx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN11@findCity
$LN6@findCity:

; 1030 : 								{
; 1031 : 									if((eDirection == NO_DIRECTION) || (estimateDirection(dxWrap(pLoopCity->getX() - iX), dyWrap(pLoopCity->getY() - iY)) == eDirection))

	cmp	DWORD PTR _eDirection$[ebp], -1
	je	SHORT $LN4@findCity
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR $T238244[ebp], edx
	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR $T238273[ebp], ecx
	mov	edx, DWORD PTR $T238244[ebp]
	sub	edx, DWORD PTR _iY$[ebp]
	push	edx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR $T238273[ebp]
	sub	eax, DWORD PTR _iX$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	push	eax
	call	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z ; estimateDirection
	add	esp, 8
	cmp	eax, DWORD PTR _eDirection$[ebp]
	jne	SHORT $LN11@findCity
$LN4@findCity:

; 1032 : 									{
; 1033 : 										if((pSkipCity == NULL) || (pLoopCity != pSkipCity))

	cmp	DWORD PTR _pSkipCity$[ebp], 0
	je	SHORT $LN102@findCity
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	cmp	ecx, DWORD PTR _pSkipCity$[ebp]
	je	SHORT $LN11@findCity

; 1034 : 										{
; 1035 : 											iValue = plotDistance(iX, iY, pLoopCity->getX(), pLoopCity->getY());

$LN102@findCity:
	mov	edx, DWORD PTR _pLoopCity$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR $T238302[ebp], eax
	mov	ecx, DWORD PTR _pLoopCity$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR $T238311[ebp], edx
	mov	eax, DWORD PTR $T238302[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238311[ebp]
	push	ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iValue$[ebp], eax

; 1036 : 
; 1037 : 											if(iValue < iBestValue)

	mov	ecx, DWORD PTR _iValue$[ebp]
	cmp	ecx, DWORD PTR _iBestValue$[ebp]
	jge	SHORT $LN11@findCity

; 1038 : 											{
; 1039 : 												iBestValue = iValue;

	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], edx

; 1040 : 												pBestCity = pLoopCity;

	mov	eax, DWORD PTR _pLoopCity$[ebp]
	mov	DWORD PTR _pBestCity$[ebp], eax
$LN11@findCity:

; 1041 : 											}
; 1042 : 										}
; 1043 : 									}
; 1044 : 								}
; 1045 : 							}
; 1046 : 						}
; 1047 : 					}

	jmp	$LN13@findCity
$LN19@findCity:

; 1048 : 				}
; 1049 : 			}
; 1050 : 		}
; 1051 : 	}

	jmp	$LN21@findCity
$LN20@findCity:

; 1052 : 
; 1053 : 	return pBestCity;

	mov	eax, DWORD PTR _pBestCity$[ebp]
$LN24@findCity:

; 1054 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ENDP ; CvMap::findCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
$T238417 = -16						; size = 4
$T238409 = -12						; size = 4
$T238405 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T238405[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238409[ebp], ecx
	movzx	edx, BYTE PTR $T238405[ebp]
	test	edx, edx
	je	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR $T238409[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDX$[ebp], eax
	jle	SHORT $LN11@dxWrap
	mov	ecx, DWORD PTR _iDX$[ebp]
	sub	ecx, DWORD PTR $T238409[ebp]
	mov	DWORD PTR $T238417[ebp], ecx
	jmp	SHORT $LN13@dxWrap
	jmp	SHORT $LN12@dxWrap
$LN11@dxWrap:
	mov	edx, DWORD PTR $T238409[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDX$[ebp], edx
	jge	SHORT $LN12@dxWrap
	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR $T238409[ebp]
	mov	DWORD PTR $T238417[ebp], eax
	jmp	SHORT $LN13@dxWrap
$LN12@dxWrap:
	mov	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR $T238417[ebp], ecx
$LN13@dxWrap:
	mov	eax, DWORD PTR $T238417[ebp]

; 76   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
$T238438 = -16						; size = 4
$T238430 = -12						; size = 4
$T238426 = -5						; size = 1
_kMap$ = -4						; size = 4
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 79   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _kMap$[ebp], eax

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	ecx, DWORD PTR _kMap$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T238426[ebp], dl
	mov	eax, DWORD PTR _kMap$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T238430[ebp], ecx
	movzx	edx, BYTE PTR $T238426[ebp]
	test	edx, edx
	je	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR $T238430[ebp]
	shr	eax, 1
	cmp	DWORD PTR _iDY$[ebp], eax
	jle	SHORT $LN11@dyWrap
	mov	ecx, DWORD PTR _iDY$[ebp]
	sub	ecx, DWORD PTR $T238430[ebp]
	mov	DWORD PTR $T238438[ebp], ecx
	jmp	SHORT $LN13@dyWrap
	jmp	SHORT $LN12@dyWrap
$LN11@dyWrap:
	mov	edx, DWORD PTR $T238430[ebp]
	shr	edx, 1
	neg	edx
	cmp	DWORD PTR _iDY$[ebp], edx
	jge	SHORT $LN12@dyWrap
	mov	eax, DWORD PTR _iDY$[ebp]
	add	eax, DWORD PTR $T238430[ebp]
	mov	DWORD PTR $T238438[ebp], eax
	jmp	SHORT $LN13@dyWrap
$LN12@dyWrap:
	mov	ecx, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR $T238438[ebp], ecx
$LN13@dyWrap:
	mov	eax, DWORD PTR $T238438[ebp]

; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
tv157 = -92						; size = 4
tv138 = -88						; size = 4
tv135 = -84						; size = 4
$T238522 = -80						; size = 4
$T238495 = -60						; size = 4
_iDY$ = -24						; size = 4
_iDX$ = -20						; size = 4
_iWrappedDX$ = -16					; size = 4
_iHX1$ = -12						; size = 4
_iHX2$ = -8						; size = 4
_iWrappedDY$ = -4					; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[ebp]
	sub	eax, DWORD PTR _iX1$[ebp]
	push	eax
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDX$[ebp], eax

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ecx, DWORD PTR _iY2$[ebp]
	sub	ecx, DWORD PTR _iY1$[ebp]
	push	ecx
	call	?dyWrap@@YAHH@Z				; dyWrap
	add	esp, 4
	mov	DWORD PTR _iWrappedDY$[ebp], eax

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, DWORD PTR _iWrappedDY$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[ebp], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	cmp	DWORD PTR _iY1$[ebp], 0
	jl	SHORT $LN35@plotDistan
	mov	edx, DWORD PTR _iY1$[ebp]
	sar	edx, 1
	mov	DWORD PTR tv135[ebp], edx
	jmp	SHORT $LN33@plotDistan
$LN35@plotDistan:
	mov	eax, DWORD PTR _iY1$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv135[ebp], eax
$LN33@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	sub	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _iHX1$[ebp], eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	ecx, DWORD PTR _iY1$[ebp]
	add	ecx, DWORD PTR _iWrappedDY$[ebp]
	mov	DWORD PTR $T238495[ebp], ecx
	js	SHORT $LN39@plotDistan
	mov	edx, DWORD PTR $T238495[ebp]
	sar	edx, 1
	mov	DWORD PTR tv138[ebp], edx
	jmp	SHORT $LN37@plotDistan
$LN39@plotDistan:
	mov	eax, DWORD PTR $T238495[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv138[ebp], eax
$LN37@plotDistan:
	mov	eax, DWORD PTR _iX1$[ebp]
	add	eax, DWORD PTR _iWrappedDX$[ebp]
	sub	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR _iHX2$[ebp], eax

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	ecx, DWORD PTR _iHX2$[ebp]
	sub	ecx, DWORD PTR _iHX1$[ebp]
	push	ecx
	call	?dxWrap@@YAHH@Z				; dxWrap
	add	esp, 4
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDX$[ebp], eax

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iHX2$[ebp]
	sub	edx, DWORD PTR _iHX1$[ebp]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	cmp	DWORD PTR _iWrappedDY$[ebp], 0
	setge	cl
	cmp	eax, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	eax, DWORD PTR _iDX$[ebp]
	add	eax, DWORD PTR _iDY$[ebp]
	jmp	SHORT $LN3@plotDistan

; 163  : 	}
; 164  : 	else

	jmp	SHORT $LN3@plotDistan
$LN2@plotDistan:

; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	mov	edx, DWORD PTR _iDX$[ebp]
	cmp	edx, DWORD PTR _iDY$[ebp]
	jge	SHORT $LN57@plotDistan
	lea	eax, DWORD PTR _iDY$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN58@plotDistan
$LN57@plotDistan:
	lea	ecx, DWORD PTR _iDX$[ebp]
	mov	DWORD PTR tv157[ebp], ecx
$LN58@plotDistan:
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR $T238522[ebp], edx
	mov	eax, DWORD PTR $T238522[ebp]
	mov	eax, DWORD PTR [eax]
$LN3@plotDistan:

; 170  : #endif
; 171  : 	}
; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z ; CvMap::findUnit
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?ReadyToSelect@CvUnit@@QBE_NXZ:PROC		; CvUnit::ReadyToSelect
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
;	COMDAT ?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z
_TEXT	SEGMENT
_this$ = -124						; size = 4
$T238556 = -40						; size = 4
$T238547 = -36						; size = 4
$T238538 = -29						; size = 1
_thisPlayer$235151 = -28				; size = 4
_pBestUnit$ = -24					; size = 4
_iBestValue$ = -20					; size = 4
_pLoopUnit$ = -16					; size = 4
_iI$ = -12						; size = 4
_iValue$ = -8						; size = 4
_iLoop$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eOwner$ = 16						; size = 4
_bReadyToSelect$ = 20					; size = 1
_bWorkers$ = 24						; size = 1
?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z PROC ; CvMap::findUnit, COMDAT
; _this$ = ecx

; 1059 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 	CvUnit* pLoopUnit;
; 1061 : 	CvUnit* pBestUnit;
; 1062 : 	int iValue;
; 1063 : 	int iBestValue;
; 1064 : 	int iLoop;
; 1065 : 	int iI;
; 1066 : 
; 1067 : 	iBestValue = INT_MAX;

	mov	DWORD PTR _iBestValue$[ebp], 2147483647	; 7fffffffH

; 1068 : 	pBestUnit = NULL;

	mov	DWORD PTR _pBestUnit$[ebp], 0

; 1069 : 
; 1070 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN14@findUnit
$LN13@findUnit:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN14@findUnit:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN12@findUnit

; 1071 : 	{
; 1072 : 		CvPlayer& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$235151[ebp], ecx

; 1073 : 		if(thisPlayer.isAlive())

	mov	edx, DWORD PTR _thisPlayer$235151[ebp]
	mov	al, BYTE PTR [edx+2256]
	mov	BYTE PTR $T238538[ebp], al
	movzx	ecx, BYTE PTR $T238538[ebp]
	test	ecx, ecx
	je	$LN11@findUnit

; 1074 : 		{
; 1075 : 			if((eOwner == NO_PLAYER) || (iI == eOwner))

	cmp	DWORD PTR _eOwner$[ebp], -1
	je	SHORT $LN9@findUnit
	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _eOwner$[ebp]
	jne	$LN11@findUnit
$LN9@findUnit:

; 1076 : 			{
; 1077 : 				for(pLoopUnit = thisPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = thisPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _thisPlayer$235151[ebp]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
	jmp	SHORT $LN8@findUnit
$LN7@findUnit:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _thisPlayer$235151[ebp]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[ebp], eax
$LN8@findUnit:
	cmp	DWORD PTR _pLoopUnit$[ebp], 0
	je	SHORT $LN11@findUnit

; 1078 : 				{
; 1079 : 					if(!bReadyToSelect || pLoopUnit->ReadyToSelect())

	movzx	edx, BYTE PTR _bReadyToSelect$[ebp]
	test	edx, edx
	je	SHORT $LN4@findUnit
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?ReadyToSelect@CvUnit@@QBE_NXZ		; CvUnit::ReadyToSelect
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@findUnit
$LN4@findUnit:

; 1080 : 					{
; 1081 : 						if(!bWorkers || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER_SEA)

	movzx	ecx, BYTE PTR _bWorkers$[ebp]
	test	ecx, ecx
	je	SHORT $LN25@findUnit
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN25@findUnit
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 17					; 00000011H
	jne	SHORT $LN5@findUnit

; 1082 : 						{
; 1083 : 							iValue = plotDistance(iX, iY, pLoopUnit->getX(), pLoopUnit->getY());

$LN25@findUnit:
	mov	edx, DWORD PTR _pLoopUnit$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR $T238547[ebp], eax
	mov	ecx, DWORD PTR _pLoopUnit$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR $T238556[ebp], edx
	mov	eax, DWORD PTR $T238547[ebp]
	push	eax
	mov	ecx, DWORD PTR $T238556[ebp]
	push	ecx
	mov	edx, DWORD PTR _iY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iX$[ebp]
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iValue$[ebp], eax

; 1084 : 
; 1085 : 							if(iValue < iBestValue)

	mov	ecx, DWORD PTR _iValue$[ebp]
	cmp	ecx, DWORD PTR _iBestValue$[ebp]
	jge	SHORT $LN5@findUnit

; 1086 : 							{
; 1087 : 								iBestValue = iValue;

	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], edx

; 1088 : 								pBestUnit = pLoopUnit;

	mov	eax, DWORD PTR _pLoopUnit$[ebp]
	mov	DWORD PTR _pBestUnit$[ebp], eax
$LN5@findUnit:

; 1089 : 							}
; 1090 : 						}
; 1091 : 					}
; 1092 : 				}

	jmp	$LN7@findUnit
$LN11@findUnit:

; 1093 : 			}
; 1094 : 		}
; 1095 : 	}

	jmp	$LN13@findUnit
$LN12@findUnit:

; 1096 : 
; 1097 : 	return pBestUnit;

	mov	eax, DWORD PTR _pBestUnit$[ebp]

; 1098 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?findUnit@CvMap@@QAEPAVCvUnit@@HHW4PlayerTypes@@_N1@Z ENDP ; CvMap::findUnit
_TEXT	ENDS
PUBLIC	?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z ; CvMap::findNearestStartPlot
EXTRN	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ:PROC ; CvPlayer::getStartingPlot
; Function compile flags: /Odtp
;	COMDAT ?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T238663 = -36						; size = 4
$T238659 = -32						; size = 4
$T238655 = -25						; size = 1
_pStartPlot$235180 = -24				; size = 4
_thisPlayer$235177 = -20				; size = 4
_pBestStartPlot$ = -16					; size = 4
_iBestValue$ = -12					; size = 4
_iI$ = -8						; size = 4
_iValue$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eOwner$ = 16						; size = 4
?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z PROC ; CvMap::findNearestStartPlot, COMDAT
; _this$ = ecx

; 1103 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 	eOwner = NO_PLAYER;

	mov	eax, DWORD PTR _eOwner$[ebp]
	mov	DWORD PTR [eax], -1

; 1105 : 	int iValue;
; 1106 : 	int iBestValue;
; 1107 : 	int iI;
; 1108 : 	CvPlot* pBestStartPlot = 0;

	mov	DWORD PTR _pBestStartPlot$[ebp], 0

; 1109 : 
; 1110 : 	iBestValue = INT_MAX;

	mov	DWORD PTR _iBestValue$[ebp], 2147483647	; 7fffffffH

; 1111 : 
; 1112 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN6@findNeares
$LN5@findNeares:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN6@findNeares:
	cmp	DWORD PTR _iI$[ebp], 64			; 00000040H
	jge	$LN4@findNeares

; 1113 : 	{
; 1114 : 		CvPlayer& thisPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	edx, DWORD PTR _iI$[ebp]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$235177[ebp], edx

; 1115 : 		if(thisPlayer.isEverAlive())

	mov	eax, DWORD PTR _thisPlayer$235177[ebp]
	mov	cl, BYTE PTR [eax+2268]
	mov	BYTE PTR $T238655[ebp], cl
	movzx	edx, BYTE PTR $T238655[ebp]
	test	edx, edx
	je	SHORT $LN3@findNeares

; 1116 : 		{
; 1117 : 			CvPlot* pStartPlot = thisPlayer.getStartingPlot();

	mov	ecx, DWORD PTR _thisPlayer$235177[ebp]
	call	?getStartingPlot@CvPlayer@@QBEPAVCvPlot@@XZ ; CvPlayer::getStartingPlot
	mov	DWORD PTR _pStartPlot$235180[ebp], eax

; 1118 : 			if (pStartPlot)

	cmp	DWORD PTR _pStartPlot$235180[ebp], 0
	je	SHORT $LN3@findNeares

; 1119 : 			{
; 1120 : 				iValue = plotDistance(iX, iY, pStartPlot->getX(), pStartPlot->getY());

	mov	eax, DWORD PTR _pStartPlot$235180[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T238659[ebp], ecx
	mov	edx, DWORD PTR _pStartPlot$235180[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T238663[ebp], eax
	mov	ecx, DWORD PTR $T238659[ebp]
	push	ecx
	mov	edx, DWORD PTR $T238663[ebp]
	push	edx
	mov	eax, DWORD PTR _iY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iX$[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iValue$[ebp], eax

; 1121 : 				if(iValue < iBestValue)

	mov	edx, DWORD PTR _iValue$[ebp]
	cmp	edx, DWORD PTR _iBestValue$[ebp]
	jge	SHORT $LN3@findNeares

; 1122 : 				{
; 1123 : 					iBestValue = iValue;

	mov	eax, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], eax

; 1124 : 					pBestStartPlot = pStartPlot;

	mov	ecx, DWORD PTR _pStartPlot$235180[ebp]
	mov	DWORD PTR _pBestStartPlot$[ebp], ecx

; 1125 : 					eOwner = static_cast<PlayerTypes>(iI);

	mov	edx, DWORD PTR _eOwner$[ebp]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@findNeares:

; 1126 : 				}
; 1127 : 			}
; 1128 : 		}
; 1129 : 	}

	jmp	$LN5@findNeares
$LN4@findNeares:

; 1130 : 	return pBestStartPlot;

	mov	eax, DWORD PTR _pBestStartPlot$[ebp]

; 1131 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?findNearestStartPlot@CvMap@@QAEPAVCvPlot@@HHAAW4PlayerTypes@@@Z ENDP ; CvMap::findNearestStartPlot
_TEXT	ENDS
PUBLIC	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z		; CvMap::nextArea
PUBLIC	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z		; CvMap::firstArea
PUBLIC	?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z	; CvMap::findBiggestArea
EXTRN	?getNumTiles@CvArea@@QBEHXZ:PROC		; CvArea::getNumTiles
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
; Function compile flags: /Odtp
;	COMDAT ?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_pBestArea$ = -20					; size = 4
_pLoopArea$ = -16					; size = 4
_iBestValue$ = -12					; size = 4
_iValue$ = -8						; size = 4
_iLoop$ = -4						; size = 4
_bWater$ = 8						; size = 1
?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z PROC		; CvMap::findBiggestArea, COMDAT
; _this$ = ecx

; 1136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1137 : 	CvArea* pLoopArea;
; 1138 : 	CvArea* pBestArea;
; 1139 : 	int iValue;
; 1140 : 	int iBestValue;
; 1141 : 	int iLoop;
; 1142 : 
; 1143 : 	iBestValue = 0;

	mov	DWORD PTR _iBestValue$[ebp], 0

; 1144 : 	pBestArea = NULL;

	mov	DWORD PTR _pBestArea$[ebp], 0

; 1145 : 
; 1146 : 	for(pLoopArea = firstArea(&iLoop); pLoopArea != NULL; pLoopArea = nextArea(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
	jmp	SHORT $LN5@findBigges
$LN4@findBigges:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
$LN5@findBigges:
	cmp	DWORD PTR _pLoopArea$[ebp], 0
	je	SHORT $LN3@findBigges

; 1147 : 	{
; 1148 : 		if(pLoopArea->isWater() == bWater)

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	edx, al
	movzx	eax, BYTE PTR _bWater$[ebp]
	cmp	edx, eax
	jne	SHORT $LN2@findBigges

; 1149 : 		{
; 1150 : 			iValue = pLoopArea->getNumTiles();

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	mov	DWORD PTR _iValue$[ebp], eax

; 1151 : 
; 1152 : 			if(iValue > iBestValue)

	mov	ecx, DWORD PTR _iValue$[ebp]
	cmp	ecx, DWORD PTR _iBestValue$[ebp]
	jle	SHORT $LN2@findBigges

; 1153 : 			{
; 1154 : 				iBestValue = iValue;

	mov	edx, DWORD PTR _iValue$[ebp]
	mov	DWORD PTR _iBestValue$[ebp], edx

; 1155 : 				pBestArea = pLoopArea;

	mov	eax, DWORD PTR _pLoopArea$[ebp]
	mov	DWORD PTR _pBestArea$[ebp], eax
$LN2@findBigges:

; 1156 : 			}
; 1157 : 		}
; 1158 : 	}

	jmp	SHORT $LN4@findBigges
$LN3@findBigges:

; 1159 : 
; 1160 : 	return pBestArea;

	mov	eax, DWORD PTR _pBestArea$[ebp]

; 1161 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z ENDP		; CvMap::findBiggestArea
_TEXT	ENDS
PUBLIC	?getMapFractalFlags@CvMap@@QAEHXZ		; CvMap::getMapFractalFlags
; Function compile flags: /Odtp
;	COMDAT ?getMapFractalFlags@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T238760 = -10						; size = 1
$T238756 = -9						; size = 1
_wrapY$ = -8						; size = 4
_wrapX$ = -4						; size = 4
?getMapFractalFlags@CvMap@@QAEHXZ PROC			; CvMap::getMapFractalFlags, COMDAT
; _this$ = ecx

; 1166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 	int wrapX = 0;

	mov	DWORD PTR _wrapX$[ebp], 0

; 1168 : 	if(isWrapX())

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T238756[ebp], cl
	movzx	edx, BYTE PTR $T238756[ebp]
	test	edx, edx
	je	SHORT $LN2@getMapFrac

; 1169 : 	{
; 1170 : 		wrapX = (int)CvFractal::FRAC_WRAP_X;

	mov	DWORD PTR _wrapX$[ebp], 1
$LN2@getMapFrac:

; 1171 : 	}
; 1172 : 
; 1173 : 	int wrapY = 0;

	mov	DWORD PTR _wrapY$[ebp], 0

; 1174 : 	if(isWrapY())

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T238760[ebp], cl
	movzx	edx, BYTE PTR $T238760[ebp]
	test	edx, edx
	je	SHORT $LN1@getMapFrac

; 1175 : 	{
; 1176 : 		wrapY = (int)CvFractal::FRAC_WRAP_Y;

	mov	DWORD PTR _wrapY$[ebp], 2
$LN1@getMapFrac:

; 1177 : 	}
; 1178 : 
; 1179 : 	return (wrapX | wrapY);

	mov	eax, DWORD PTR _wrapX$[ebp]
	or	eax, DWORD PTR _wrapY$[ebp]

; 1180 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getMapFractalFlags@CvMap@@QAEHXZ ENDP			; CvMap::getMapFractalFlags
_TEXT	ENDS
PUBLIC	?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z		; CvMap::findWater
EXTRN	?isFreshWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isFreshWater
; Function compile flags: /Odtp
;	COMDAT ?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z
_TEXT	SEGMENT
_this$ = -100						; size = 4
_iDY$ = -20						; size = 4
_iDX$ = -16						; size = 4
_iPlotY$ = -12						; size = 4
_pLoopPlot$ = -8					; size = 4
_iPlotX$ = -4						; size = 4
_pPlot$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bFreshWater$ = 16					; size = 1
?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z PROC		; CvMap::findWater, COMDAT
; _this$ = ecx

; 1186 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	DWORD PTR _this$[ebp], ecx

; 1187 : 	CvPlot* pLoopPlot;
; 1188 : 	int iDX, iDY;
; 1189 : 	int iPlotX = pPlot->getX();

	mov	eax, DWORD PTR _pPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iPlotX$[ebp], ecx

; 1190 : 	int iPlotY = pPlot->getY();

	mov	edx, DWORD PTR _pPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iPlotY$[ebp], eax

; 1191 : 
; 1192 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1193 : 	int iMaxDX;
; 1194 : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 1195 : 	{
; 1196 : 		iMaxDX = iRange - MAX(0, iDY);
; 1197 : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1198 : 		{
; 1199 : 			// No need for range check because loops are set up properly
; 1200 : 			pLoopPlot = plotXY(iPlotX, iPlotY, iDX, iDY);
; 1201 : #else
; 1202 : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iDX$[ebp], ecx
	jmp	SHORT $LN11@findWater
$LN10@findWater:
	mov	edx, DWORD PTR _iDX$[ebp]
	add	edx, 1
	mov	DWORD PTR _iDX$[ebp], edx
$LN11@findWater:
	mov	eax, DWORD PTR _iDX$[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	SHORT $LN9@findWater

; 1203 : 	{
; 1204 : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	ecx, DWORD PTR _iRange$[ebp]
	neg	ecx
	mov	DWORD PTR _iDY$[ebp], ecx
	jmp	SHORT $LN8@findWater
$LN7@findWater:
	mov	edx, DWORD PTR _iDY$[ebp]
	add	edx, 1
	mov	DWORD PTR _iDY$[ebp], edx
$LN8@findWater:
	mov	eax, DWORD PTR _iDY$[ebp]
	cmp	eax, DWORD PTR _iRange$[ebp]
	jg	SHORT $LN6@findWater

; 1205 : 		{
; 1206 : 			pLoopPlot = plotXYWithRangeCheck(iPlotX, iPlotY, iDX, iDY, iRange);

	mov	ecx, DWORD PTR _iRange$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iDY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iDX$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotX$[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 1207 : #endif
; 1208 : 
; 1209 : 			if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN5@findWater

; 1210 : 			{
; 1211 : 				if(bFreshWater)

	movzx	eax, BYTE PTR _bFreshWater$[ebp]
	test	eax, eax
	je	SHORT $LN83@findWater

; 1212 : 				{
; 1213 : 					if(pLoopPlot->isFreshWater())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isFreshWater@CvPlot@@QBE_NXZ		; CvPlot::isFreshWater
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@findWater

; 1214 : 					{
; 1215 : 						return true;

	mov	al, 1
	jmp	SHORT $LN12@findWater
$LN3@findWater:

; 1216 : 					}
; 1217 : 				}
; 1218 : 				else

	jmp	SHORT $LN5@findWater

; 1219 : 				{
; 1220 : 					if(pLoopPlot->isWater())

$LN83@findWater:
	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN5@findWater

; 1221 : 					{
; 1222 : 						return true;

	mov	al, 1
	jmp	SHORT $LN12@findWater
$LN5@findWater:

; 1223 : 					}
; 1224 : 				}
; 1225 : 			}
; 1226 : 		}

	jmp	SHORT $LN7@findWater
$LN6@findWater:

; 1227 : 	}

	jmp	$LN10@findWater
$LN9@findWater:

; 1228 : 
; 1229 : 	return false;

	xor	al, al
$LN12@findWater:

; 1230 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z ENDP		; CvMap::findWater
_TEXT	ENDS
PUBLIC	?plotX@CvMap@@QBEHH@Z				; CvMap::plotX
; Function compile flags: /Odtp
;	COMDAT ?plotX@CvMap@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T238909 = -4						; size = 4
_iIndex$ = 8						; size = 4
?plotX@CvMap@@QBEHH@Z PROC				; CvMap::plotX, COMDAT
; _this$ = ecx

; 1234 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1235 : 	return (iIndex % getGridWidth());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238909[ebp], ecx
	mov	eax, DWORD PTR _iIndex$[ebp]
	cdq
	idiv	DWORD PTR $T238909[ebp]
	mov	eax, edx

; 1236 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?plotX@CvMap@@QBEHH@Z ENDP				; CvMap::plotX
_TEXT	ENDS
PUBLIC	?plotY@CvMap@@QBEHH@Z				; CvMap::plotY
; Function compile flags: /Odtp
;	COMDAT ?plotY@CvMap@@QBEHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T238915 = -4						; size = 4
_iIndex$ = 8						; size = 4
?plotY@CvMap@@QBEHH@Z PROC				; CvMap::plotY, COMDAT
; _this$ = ecx

; 1241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1242 : 	return (iIndex / getGridWidth());

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T238915[ebp], ecx
	mov	eax, DWORD PTR _iIndex$[ebp]
	cdq
	idiv	DWORD PTR $T238915[ebp]

; 1243 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?plotY@CvMap@@QBEHH@Z ENDP				; CvMap::plotY
_TEXT	ENDS
PUBLIC	?maxPlotDistance@CvMap@@QAEHXZ			; CvMap::maxPlotDistance
; Function compile flags: /Odtp
;	COMDAT ?maxPlotDistance@CvMap@@QAEHXZ
_TEXT	SEGMENT
tv187 = -128						; size = 4
tv88 = -124						; size = 4
tv76 = -120						; size = 4
_this$ = -116						; size = 4
$T239030 = -112						; size = 4
$T238947 = -32						; size = 4
$T238943 = -28						; size = 4
$T238939 = -21						; size = 1
$T238935 = -20						; size = 4
$T238931 = -16						; size = 4
$T238927 = -9						; size = 1
$T238923 = -8						; size = 4
$T238918 = -4						; size = 4
?maxPlotDistance@CvMap@@QAEHXZ PROC			; CvMap::maxPlotDistance, COMDAT
; _this$ = ecx

; 1248 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	DWORD PTR _this$[ebp], ecx

; 1249 : #ifdef NQM_FAST_COMP
; 1250 : 	return MAX(1, plotDistance(0, 0, ((isWrapX()) ? (getGridWidth() / 2) : (getGridWidth() - 1)), ((isWrapY()) ? (getGridHeight() / 2) : (getGridHeight() - 1))));
; 1251 : #else
; 1252 : 	return std::max(1, plotDistance(0, 0, ((isWrapX()) ? (getGridWidth() / 2) : (getGridWidth() - 1)), ((isWrapY()) ? (getGridHeight() / 2) : (getGridHeight() - 1))));

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T238927[ebp], cl
	movzx	edx, BYTE PTR $T238927[ebp]
	test	edx, edx
	je	SHORT $LN3@maxPlotDis
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T238931[ebp], ecx
	mov	eax, DWORD PTR $T238931[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@maxPlotDis
$LN3@maxPlotDis:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T238935[ebp], eax
	mov	ecx, DWORD PTR $T238935[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv76[ebp], ecx
$LN4@maxPlotDis:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T238939[ebp], al
	movzx	ecx, BYTE PTR $T238939[ebp]
	test	ecx, ecx
	je	SHORT $LN5@maxPlotDis
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T238943[ebp], eax
	mov	eax, DWORD PTR $T238943[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN6@maxPlotDis
$LN5@maxPlotDis:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T238947[ebp], edx
	mov	eax, DWORD PTR $T238947[ebp]
	sub	eax, 1
	mov	DWORD PTR tv88[ebp], eax
$LN6@maxPlotDis:
	mov	ecx, DWORD PTR tv76[ebp]
	push	ecx
	mov	edx, DWORD PTR tv88[ebp]
	push	edx
	push	0
	push	0
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T238918[ebp], eax
	mov	DWORD PTR $T238923[ebp], 1
	mov	eax, DWORD PTR $T238923[ebp]
	cmp	eax, DWORD PTR $T238918[ebp]
	jge	SHORT $LN73@maxPlotDis
	lea	ecx, DWORD PTR $T238918[ebp]
	mov	DWORD PTR tv187[ebp], ecx
	jmp	SHORT $LN74@maxPlotDis
$LN73@maxPlotDis:
	lea	edx, DWORD PTR $T238923[ebp]
	mov	DWORD PTR tv187[ebp], edx
$LN74@maxPlotDis:
	mov	eax, DWORD PTR tv187[ebp]
	mov	DWORD PTR $T239030[ebp], eax
	mov	ecx, DWORD PTR $T239030[ebp]
	mov	eax, DWORD PTR [ecx]

; 1253 : #endif
; 1254 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?maxPlotDistance@CvMap@@QAEHXZ ENDP			; CvMap::maxPlotDistance
_TEXT	ENDS
PUBLIC	?getLandPlots@CvMap@@QAEHXZ			; CvMap::getLandPlots
; Function compile flags: /Odtp
;	COMDAT ?getLandPlots@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getLandPlots@CvMap@@QAEHXZ PROC			; CvMap::getLandPlots, COMDAT
; _this$ = ecx

; 1262 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1263 : 	return m_iLandPlots;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4032]

; 1264 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getLandPlots@CvMap@@QAEHXZ ENDP			; CvMap::getLandPlots
_TEXT	ENDS
PUBLIC	?changeLandPlots@CvMap@@QAEXH@Z			; CvMap::changeLandPlots
; Function compile flags: /Odtp
;	COMDAT ?changeLandPlots@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeLandPlots@CvMap@@QAEXH@Z PROC			; CvMap::changeLandPlots, COMDAT
; _this$ = ecx

; 1269 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1270 : #ifdef AUI_WARNING_FIXES
; 1271 : 	if (iChange < 0)
; 1272 : 		m_iLandPlots = (m_iLandPlots - abs(iChange));
; 1273 : 	else
; 1274 : #endif
; 1275 : 	m_iLandPlots = (m_iLandPlots + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4032]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4032], ecx

; 1276 : 	CvAssert(getLandPlots() >= 0);
; 1277 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeLandPlots@CvMap@@QAEXH@Z ENDP			; CvMap::changeLandPlots
_TEXT	ENDS
PUBLIC	?getOwnedPlots@CvMap@@QAEHXZ			; CvMap::getOwnedPlots
; Function compile flags: /Odtp
;	COMDAT ?getOwnedPlots@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getOwnedPlots@CvMap@@QAEHXZ PROC			; CvMap::getOwnedPlots, COMDAT
; _this$ = ecx

; 1286 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1287 : 	return m_iOwnedPlots;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4036]

; 1288 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getOwnedPlots@CvMap@@QAEHXZ ENDP			; CvMap::getOwnedPlots
_TEXT	ENDS
PUBLIC	?changeOwnedPlots@CvMap@@QAEXH@Z		; CvMap::changeOwnedPlots
; Function compile flags: /Odtp
;	COMDAT ?changeOwnedPlots@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?changeOwnedPlots@CvMap@@QAEXH@Z PROC			; CvMap::changeOwnedPlots, COMDAT
; _this$ = ecx

; 1293 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1294 : #ifdef AUI_WARNING_FIXES
; 1295 : 	if (iChange < 0)
; 1296 : 		m_iOwnedPlots = (m_iOwnedPlots - abs(iChange));
; 1297 : 	else
; 1298 : #endif
; 1299 : 	m_iOwnedPlots = (m_iOwnedPlots + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4036]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4036], ecx

; 1300 : 	CvAssert(getOwnedPlots() >= 0);
; 1301 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?changeOwnedPlots@CvMap@@QAEXH@Z ENDP			; CvMap::changeOwnedPlots
_TEXT	ENDS
PUBLIC	?getTopLatitude@CvMap@@QAEHXZ			; CvMap::getTopLatitude
; Function compile flags: /Odtp
;	COMDAT ?getTopLatitude@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTopLatitude@CvMap@@QAEHXZ PROC			; CvMap::getTopLatitude, COMDAT
; _this$ = ecx

; 1306 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1307 : 	return m_iTopLatitude;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4040]

; 1308 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getTopLatitude@CvMap@@QAEHXZ ENDP			; CvMap::getTopLatitude
_TEXT	ENDS
PUBLIC	?getBottomLatitude@CvMap@@QAEHXZ		; CvMap::getBottomLatitude
; Function compile flags: /Odtp
;	COMDAT ?getBottomLatitude@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBottomLatitude@CvMap@@QAEHXZ PROC			; CvMap::getBottomLatitude, COMDAT
; _this$ = ecx

; 1313 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1314 : 	return m_iBottomLatitude;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4044]

; 1315 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getBottomLatitude@CvMap@@QAEHXZ ENDP			; CvMap::getBottomLatitude
_TEXT	ENDS
PUBLIC	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ	; CvMap::getWorldSize
; Function compile flags: /Odtp
;	COMDAT ?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ PROC	; CvMap::getWorldSize, COMDAT
; _this$ = ecx

; 1319 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 	return CvPreGame::worldSize();

	call	?worldSize@CvPreGame@@YA?AW4WorldSizeTypes@@XZ ; CvPreGame::worldSize

; 1321 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ENDP	; CvMap::getWorldSize
_TEXT	ENDS
EXTRN	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ:PROC	; CvPreGame::worldInfo
; Function compile flags: /Odtp
;	COMDAT ?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ PROC		; CvMap::getWorldInfo, COMDAT
; _this$ = ecx

; 1325 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1326 : 	return CvPreGame::worldInfo();

	call	?worldInfo@CvPreGame@@YAABVCvWorldInfo@@XZ ; CvPreGame::worldInfo

; 1327 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ENDP		; CvMap::getWorldInfo
_TEXT	ENDS
PUBLIC	?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ	; CvMap::getClimate
EXTRN	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ:PROC	; CvPreGame::climate
; Function compile flags: /Odtp
;	COMDAT ?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ PROC		; CvMap::getClimate, COMDAT
; _this$ = ecx

; 1331 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1332 : 	return CvPreGame::climate();

	call	?climate@CvPreGame@@YA?AW4ClimateTypes@@XZ ; CvPreGame::climate

; 1333 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ ENDP		; CvMap::getClimate
_TEXT	ENDS
EXTRN	?climateInfo@CvPreGame@@YAABVCvClimateInfo@@XZ:PROC ; CvPreGame::climateInfo
; Function compile flags: /Odtp
;	COMDAT ?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ PROC	; CvMap::getClimateInfo, COMDAT
; _this$ = ecx

; 1337 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1338 : 	return CvPreGame::climateInfo();

	call	?climateInfo@CvPreGame@@YAABVCvClimateInfo@@XZ ; CvPreGame::climateInfo

; 1339 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getClimateInfo@CvMap@@QBEABVCvClimateInfo@@XZ ENDP	; CvMap::getClimateInfo
_TEXT	ENDS
PUBLIC	?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ	; CvMap::getSeaLevel
EXTRN	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ:PROC ; CvPreGame::seaLevel
; Function compile flags: /Odtp
;	COMDAT ?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ PROC	; CvMap::getSeaLevel, COMDAT
; _this$ = ecx

; 1343 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1344 : 	return CvPreGame::seaLevel();

	call	?seaLevel@CvPreGame@@YA?AW4SeaLevelTypes@@XZ ; CvPreGame::seaLevel

; 1345 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ ENDP	; CvMap::getSeaLevel
_TEXT	ENDS
EXTRN	?seaLevelInfo@CvPreGame@@YAABVCvSeaLevelInfo@@XZ:PROC ; CvPreGame::seaLevelInfo
; Function compile flags: /Odtp
;	COMDAT ?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ PROC	; CvMap::getSeaLevelInfo, COMDAT
; _this$ = ecx

; 1349 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1350 : 	return CvPreGame::seaLevelInfo();

	call	?seaLevelInfo@CvPreGame@@YAABVCvSeaLevelInfo@@XZ ; CvPreGame::seaLevelInfo

; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getSeaLevelInfo@CvMap@@QBEABVCvSeaLevelInfo@@XZ ENDP	; CvMap::getSeaLevelInfo
_TEXT	ENDS
PUBLIC	??_C@_0CM@JKFLNAKA@Picking?5from?5random?5Resource?5Qua@ ; `string'
PUBLIC	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getRandomResourceQuantity
EXTRN	?getResourceQuantityType@CvResourceInfo@@QBEHH@Z:PROC ; CvResourceInfo::getResourceQuantityType
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
;	COMDAT ??_C@_0CM@JKFLNAKA@Picking?5from?5random?5Resource?5Qua@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0CM@JKFLNAKA@Picking?5from?5random?5Resource?5Qua@ DB 'Picking from'
	DB	' random Resource Quantity types', 00H	; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
CONST	ENDS
;	COMDAT ?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T239067 = -24						; size = 4
$T239063 = -20						; size = 4
_iLoop$235287 = -16					; size = 4
_iNumRands$ = -12					; size = 4
_iRand$ = -8						; size = 4
_thisResourceInfo$ = -4					; size = 4
_eIndex$ = 8						; size = 4
?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z PROC ; CvMap::getRandomResourceQuantity, COMDAT
; _this$ = ecx

; 1355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1356 : 	CvResourceInfo* thisResourceInfo = GC.getResourceInfo(eIndex);

	mov	eax, DWORD PTR _eIndex$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo
	mov	DWORD PTR _thisResourceInfo$[ebp], eax

; 1357 : 	if(thisResourceInfo == NULL)

	cmp	DWORD PTR _thisResourceInfo$[ebp], 0
	jne	SHORT $LN5@getRandomR

; 1358 : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN6@getRandomR
$LN5@getRandomR:

; 1359 : 
; 1360 : 	int iNumRands = 0;

	mov	DWORD PTR _iNumRands$[ebp], 0

; 1361 : 
; 1362 : 	// Find how many types of resources quantities there can be to pick from
; 1363 : 	for(int iLoop = 0; iLoop < GC.getNUM_RESOURCE_QUANTITY_TYPES(); iLoop++)

	mov	DWORD PTR _iLoop$235287[ebp], 0
	jmp	SHORT $LN4@getRandomR
$LN3@getRandomR:
	mov	ecx, DWORD PTR _iLoop$235287[ebp]
	add	ecx, 1
	mov	DWORD PTR _iLoop$235287[ebp], ecx
$LN4@getRandomR:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7016
	mov	DWORD PTR $T239063[ebp], edx
	mov	eax, DWORD PTR _iLoop$235287[ebp]
	cmp	eax, DWORD PTR $T239063[ebp]
	jge	SHORT $LN2@getRandomR

; 1364 : 	{
; 1365 : 		if(thisResourceInfo->getResourceQuantityType(iLoop) <= 0)

	mov	ecx, DWORD PTR _iLoop$235287[ebp]
	push	ecx
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?getResourceQuantityType@CvResourceInfo@@QBEHH@Z ; CvResourceInfo::getResourceQuantityType
	test	eax, eax
	jg	SHORT $LN1@getRandomR

; 1366 : 		{
; 1367 : 			break;

	jmp	SHORT $LN2@getRandomR
$LN1@getRandomR:

; 1368 : 		}
; 1369 : 
; 1370 : 		iNumRands++;

	mov	edx, DWORD PTR _iNumRands$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumRands$[ebp], edx

; 1371 : 	}

	jmp	SHORT $LN3@getRandomR
$LN2@getRandomR:

; 1372 : 
; 1373 : 	CvAssertMsg(iNumRands > 0, "Resource should have at least 1 Quantity type to choose from")
; 1374 : 
; 1375 : 	int iRand = GC.getGame().getJonRandNum(iNumRands, "Picking from random Resource Quantity types");

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239067[ebp], eax
	push	OFFSET ??_C@_0CM@JKFLNAKA@Picking?5from?5random?5Resource?5Qua@
	mov	ecx, DWORD PTR _iNumRands$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239067[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _iRand$[ebp], eax

; 1376 : 
; 1377 : 	return thisResourceInfo->getResourceQuantityType(iRand);

	mov	edx, DWORD PTR _iRand$[ebp]
	push	edx
	mov	ecx, DWORD PTR _thisResourceInfo$[ebp]
	call	?getResourceQuantityType@CvResourceInfo@@QBEHH@Z ; CvResourceInfo::getResourceQuantityType
$LN6@getRandomR:

; 1378 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ENDP ; CvMap::getRandomResourceQuantity
_TEXT	ENDS
PUBLIC	?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z	; CvMap::getNumResources
; Function compile flags: /Odtp
;	COMDAT ?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z PROC	; CvMap::getNumResources, COMDAT
; _this$ = ecx

; 1382 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1383 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1384 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1385 : 	return m_paiNumResource[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4060]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1386 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z ENDP	; CvMap::getNumResources
_TEXT	ENDS
PUBLIC	?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResources
; Function compile flags: /Odtp
;	COMDAT ?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z PROC ; CvMap::changeNumResources, COMDAT
; _this$ = ecx

; 1391 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1392 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1393 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1394 : 	m_paiNumResource[eIndex] = (m_paiNumResource[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4060]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4060]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1395 : 	CvAssert(getNumResources(eIndex) >= 0);
; 1396 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeNumResources@CvMap@@QAEXW4ResourceTypes@@H@Z ENDP ; CvMap::changeNumResources
_TEXT	ENDS
PUBLIC	?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getNumResourcesOnLand
; Function compile flags: /Odtp
;	COMDAT ?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z PROC ; CvMap::getNumResourcesOnLand, COMDAT
; _this$ = ecx

; 1401 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1402 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1403 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1404 : 	return m_paiNumResourceOnLand[eIndex];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4064]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 1405 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z ENDP ; CvMap::getNumResourcesOnLand
_TEXT	ENDS
PUBLIC	?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ; CvMap::changeNumResourcesOnLand
; Function compile flags: /Odtp
;	COMDAT ?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z PROC ; CvMap::changeNumResourcesOnLand, COMDAT
; _this$ = ecx

; 1410 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1411 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1412 : 	CvAssertMsg(eIndex < GC.getNumResourceInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1413 : 	m_paiNumResourceOnLand[eIndex] = (m_paiNumResourceOnLand[eIndex] + iChange);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4064]
	mov	edx, DWORD PTR _eIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _iChange$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4064]
	mov	ecx, DWORD PTR _eIndex$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1414 : 	CvAssert(getNumResourcesOnLand(eIndex) >= 0);
; 1415 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?changeNumResourcesOnLand@CvMap@@QAEXW4ResourceTypes@@H@Z ENDP ; CvMap::changeNumResourcesOnLand
_TEXT	ENDS
PUBLIC	?getIndexAfterLastArea@CvMap@@QAEHXZ		; CvMap::getIndexAfterLastArea
; Function compile flags: /Odtp
;	COMDAT ?getIndexAfterLastArea@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getIndexAfterLastArea@CvMap@@QAEHXZ PROC		; CvMap::getIndexAfterLastArea, COMDAT
; _this$ = ecx

; 1419 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1420 : 	return m_areas.GetIndexAfterLast();

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4124]
	add	eax, 1

; 1421 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getIndexAfterLastArea@CvMap@@QAEHXZ ENDP		; CvMap::getIndexAfterLastArea
_TEXT	ENDS
PUBLIC	?getNumAreas@CvMap@@QAEHXZ			; CvMap::getNumAreas
; Function compile flags: /Odtp
;	COMDAT ?getNumAreas@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T239086 = -4						; size = 4
?getNumAreas@CvMap@@QAEHXZ PROC				; CvMap::getNumAreas, COMDAT
; _this$ = ecx

; 1426 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1427 : 	return m_areas.GetCount();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4112				; 00001010H
	mov	DWORD PTR $T239086[ebp], eax
	mov	ecx, DWORD PTR $T239086[ebp]
	mov	edx, DWORD PTR $T239086[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	add	eax, 1

; 1428 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumAreas@CvMap@@QAEHXZ ENDP				; CvMap::getNumAreas
_TEXT	ENDS
PUBLIC	?getNumLandAreas@CvMap@@QAEHXZ			; CvMap::getNumLandAreas
; Function compile flags: /Odtp
;	COMDAT ?getNumLandAreas@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T239096 = -20						; size = 4
$T239092 = -16						; size = 4
_pLoopArea$ = -12					; size = 4
_iNumLandAreas$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?getNumLandAreas@CvMap@@QAEHXZ PROC			; CvMap::getNumLandAreas, COMDAT
; _this$ = ecx

; 1433 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1434 : 	CvArea* pLoopArea;
; 1435 : 	int iNumLandAreas;
; 1436 : 	int iLoop;
; 1437 : 
; 1438 : 	iNumLandAreas = 0;

	mov	DWORD PTR _iNumLandAreas$[ebp], 0

; 1439 : 
; 1440 : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T239092[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239092[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
	jmp	SHORT $LN4@getNumLand
$LN3@getNumLand:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T239096[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239096[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
$LN4@getNumLand:
	cmp	DWORD PTR _pLoopArea$[ebp], 0
	je	SHORT $LN2@getNumLand

; 1441 : 	{
; 1442 : 		if(!(pLoopArea->isWater()))

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@getNumLand

; 1443 : 		{
; 1444 : 			iNumLandAreas++;

	mov	edx, DWORD PTR _iNumLandAreas$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumLandAreas$[ebp], edx
$LN1@getNumLand:

; 1445 : 		}
; 1446 : 	}

	jmp	SHORT $LN3@getNumLand
$LN2@getNumLand:

; 1447 : 
; 1448 : 	return iNumLandAreas;

	mov	eax, DWORD PTR _iNumLandAreas$[ebp]

; 1449 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumLandAreas@CvMap@@QAEHXZ ENDP			; CvMap::getNumLandAreas
_TEXT	ENDS
PUBLIC	?getArea@CvMap@@QAEPAVCvArea@@H@Z		; CvMap::getArea
; Function compile flags: /Odtp
;	COMDAT ?getArea@CvMap@@QAEPAVCvArea@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?getArea@CvMap@@QAEPAVCvArea@@H@Z PROC			; CvMap::getArea, COMDAT
; _this$ = ecx

; 1454 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1455 : 	return m_areas.GetAt(iID);

	mov	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4112]
	mov	edx, DWORD PTR [eax+16]
	call	edx

; 1456 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getArea@CvMap@@QAEPAVCvArea@@H@Z ENDP			; CvMap::getArea
_TEXT	ENDS
PUBLIC	?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ ; FFreeListTrashArray<CvArea>::Add
PUBLIC	?addArea@CvMap@@QAEPAVCvArea@@XZ		; CvMap::addArea
; Function compile flags: /Odtp
;	COMDAT ?addArea@CvMap@@QAEPAVCvArea@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addArea@CvMap@@QAEPAVCvArea@@XZ PROC			; CvMap::addArea, COMDAT
; _this$ = ecx

; 1461 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1462 : 	return m_areas.Add();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ ; FFreeListTrashArray<CvArea>::Add

; 1463 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?addArea@CvMap@@QAEPAVCvArea@@XZ ENDP			; CvMap::addArea
_TEXT	ENDS
PUBLIC	?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z ; FFreeListTrashArray<CvArea>::RemoveAt
PUBLIC	?deleteArea@CvMap@@QAEXH@Z			; CvMap::deleteArea
; Function compile flags: /Odtp
;	COMDAT ?deleteArea@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?deleteArea@CvMap@@QAEXH@Z PROC				; CvMap::deleteArea, COMDAT
; _this$ = ecx

; 1468 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1469 : 	m_areas.RemoveAt(iID);

	mov	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z ; FFreeListTrashArray<CvArea>::RemoveAt

; 1470 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?deleteArea@CvMap@@QAEXH@Z ENDP				; CvMap::deleteArea
_TEXT	ENDS
PUBLIC	?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::EndIter
PUBLIC	?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::BeginIter
; Function compile flags: /Odtp
;	COMDAT ?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z PROC		; CvMap::firstArea, COMDAT
; _this$ = ecx

; 1475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1476 : 	return !bRev ? m_areas.BeginIter(pIterIdx) : m_areas.EndIter(pIterIdx);

	movzx	eax, BYTE PTR _bRev$[ebp]
	test	eax, eax
	jne	SHORT $LN3@firstArea
	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::BeginIter
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@firstArea
$LN3@firstArea:
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::EndIter
	mov	DWORD PTR tv82[ebp], eax
$LN4@firstArea:
	mov	eax, DWORD PTR tv82[ebp]

; 1477 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z ENDP		; CvMap::firstArea
_TEXT	ENDS
PUBLIC	?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::PrevIter
PUBLIC	?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::NextIter
; Function compile flags: /Odtp
;	COMDAT ?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z PROC		; CvMap::nextArea, COMDAT
; _this$ = ecx

; 1482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1483 : 	return !bRev ? m_areas.NextIter(pIterIdx) : m_areas.PrevIter(pIterIdx);

	movzx	eax, BYTE PTR _bRev$[ebp]
	test	eax, eax
	jne	SHORT $LN3@nextArea
	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::NextIter
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@nextArea
$LN3@nextArea:
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	call	?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::PrevIter
	mov	DWORD PTR tv82[ebp], eax
$LN4@nextArea:
	mov	eax, DWORD PTR tv82[ebp]

; 1484 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z ENDP		; CvMap::nextArea
_TEXT	ENDS
PUBLIC	?recalculateLandmasses@CvMap@@QAEXXZ		; CvMap::recalculateLandmasses
PUBLIC	?calculateAreas@CvMap@@QAEXXZ			; CvMap::calculateAreas
EXTRN	?setArea@CvPlot@@QAEXH@Z:PROC			; CvPlot::setArea
; Function compile flags: /Odtp
;	COMDAT ?recalculateAreas@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iI$ = -8						; size = 4
_iNumPlots$ = -4					; size = 4
?recalculateAreas@CvMap@@QAEXXZ PROC			; CvMap::recalculateAreas, COMDAT
; _this$ = ecx

; 1489 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1490 : 	int iI;
; 1491 : 
; 1492 : 	int iNumPlots = numPlots();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iNumPlots$[ebp], ecx

; 1493 : 	for(iI = 0; iI < iNumPlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@recalculat
$LN2@recalculat:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN3@recalculat:
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR _iNumPlots$[ebp]
	jge	SHORT $LN1@recalculat

; 1494 : 	{
; 1495 : 		plotByIndexUnchecked(iI)->setArea(FFreeList::INVALID_INDEX);

	push	-1
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea

; 1496 : 	}

	jmp	SHORT $LN2@recalculat
$LN1@recalculat:

; 1497 : 
; 1498 : 	m_areas.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4112]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 1499 : 
; 1500 : 	calculateAreas();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateAreas@CvMap@@QAEXXZ		; CvMap::calculateAreas

; 1501 : 
; 1502 : 	recalculateLandmasses();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?recalculateLandmasses@CvMap@@QAEXXZ	; CvMap::recalculateLandmasses

; 1503 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?recalculateAreas@CvMap@@QAEXXZ ENDP			; CvMap::recalculateAreas
_TEXT	ENDS
PUBLIC	?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z ; CvMap::calculateInfluenceDistance
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
; Function compile flags: /Odtp
;	COMDAT ?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T239145 = -28						; size = 4
$T239141 = -24						; size = 4
$T239137 = -20						; size = 4
$T239133 = -16						; size = 4
$T239129 = -12						; size = 4
$T239125 = -8						; size = 4
_pNode$ = -4						; size = 4
_pSource$ = 8						; size = 4
_pDest$ = 12						; size = 4
_iMaxRange$ = 16					; size = 4
_bCorrectButSlower$ = 20				; size = 1
?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z PROC ; CvMap::calculateInfluenceDistance, COMDAT
; _this$ = ecx

; 1508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1509 : 	CvAStarNode* pNode;
; 1510 : 
; 1511 : 	if(pSource == NULL || pDest == NULL)

	cmp	DWORD PTR _pSource$[ebp], 0
	je	SHORT $LN3@calculateI
	cmp	DWORD PTR _pDest$[ebp], 0
	jne	SHORT $LN4@calculateI
$LN3@calculateI:

; 1512 : 	{
; 1513 : 		return -1;

	or	eax, -1
	jmp	$LN5@calculateI
$LN4@calculateI:

; 1514 : 	}
; 1515 : 
; 1516 : #ifdef AUI_MAP_FIX_CALCULATE_INFLUENCE_DISTANCE_REUSE_PATHFINDER
; 1517 : 	bCorrectButSlower = false;
; 1518 : 	if (m_pLastInfluenceSourcePlot != pSource)
; 1519 : 	{
; 1520 : 		m_pLastInfluenceSourcePlot = pSource;
; 1521 : 		bCorrectButSlower = true;
; 1522 : 	}
; 1523 : #endif
; 1524 : 
; 1525 : 	GC.getInfluenceFinder().SetData(&iMaxRange);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	DWORD PTR $T239125[ebp], eax
	mov	eax, DWORD PTR $T239125[ebp]
	movzx	ecx, BYTE PTR [eax+80]
	test	ecx, ecx
	je	SHORT $LN7@calculateI
	mov	edx, DWORD PTR $T239125[ebp]
	mov	eax, DWORD PTR [edx+44]
	lea	ecx, DWORD PTR _iMaxRange$[ebp]
	cmp	eax, ecx
	je	SHORT $LN7@calculateI
	mov	edx, DWORD PTR $T239125[ebp]
	mov	BYTE PTR [edx+78], 1
$LN7@calculateI:
	mov	eax, DWORD PTR $T239125[ebp]
	lea	ecx, DWORD PTR _iMaxRange$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 1526 : 	if(GC.getInfluenceFinder().GeneratePath(pSource->getX(), pSource->getY(), pDest->getX(), pDest->getY(), 0, !bCorrectButSlower))

	mov	edx, DWORD PTR _pDest$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239129[ebp], eax
	mov	ecx, DWORD PTR _pDest$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239133[ebp], edx
	mov	eax, DWORD PTR _pSource$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239137[ebp], ecx
	mov	edx, DWORD PTR _pSource$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T239141[ebp], eax
	movzx	ecx, BYTE PTR _bCorrectButSlower$[ebp]
	test	ecx, ecx
	sete	dl
	movzx	eax, dl
	push	eax
	push	0
	mov	ecx, DWORD PTR $T239129[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239133[ebp]
	push	edx
	mov	eax, DWORD PTR $T239137[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239141[ebp]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@calculateI

; 1527 : 	{
; 1528 : 		pNode = GC.getInfluenceFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfluenceFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getInfluenceFinder
	mov	DWORD PTR $T239145[ebp], eax
	mov	eax, DWORD PTR $T239145[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR _pNode$[ebp], ecx

; 1529 : 
; 1530 : 		if(pNode != NULL)

	cmp	DWORD PTR _pNode$[ebp], 0
	je	SHORT $LN2@calculateI

; 1531 : 		{
; 1532 : 			return pNode->m_iKnownCost;

	mov	edx, DWORD PTR _pNode$[ebp]
	mov	eax, DWORD PTR [edx+4]
	jmp	SHORT $LN5@calculateI
$LN2@calculateI:

; 1533 : 		}
; 1534 : 	}
; 1535 : 
; 1536 : 	return -1; // no passable path exists

	or	eax, -1
$LN5@calculateI:

; 1537 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?calculateInfluenceDistance@CvMap@@QAEHPAVCvPlot@@0H_N@Z ENDP ; CvMap::calculateInfluenceDistance
_TEXT	ENDS
PUBLIC	??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator>><CvLandmass>
PUBLIC	??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator>><CvArea>
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
PUBLIC	??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z ; operator>><unsigned char>
PUBLIC	?Read@CvMap@@QAEXAAVFDataStream@@@Z		; CvMap::Read
EXTRN	?read@CvPlot@@QAEXAAVFDataStream@@@Z:PROC	; CvPlot::read
EXTRN	?Read@FDataStream@@IAEXAAG@Z:PROC		; FDataStream::Read
EXTRN	?Read@FDataStream@@IAEXAAK@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
;	COMDAT ?Read@CvMap@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
tv201 = -60						; size = 4
_this$ = -56						; size = 4
$T239211 = -52						; size = 4
$T239207 = -48						; size = 4
$T239200 = -44						; size = 4
$T239196 = -40						; size = 4
_iI$235421 = -36					; size = 4
_uiVersion$ = -32					; size = 4
_defaultMapData$ = -28					; size = 20
_wrapm_guid$ = -8					; size = 8
_kStream$ = 8						; size = 4
?Read@CvMap@@QAEXAAVFDataStream@@@Z PROC		; CvMap::Read, COMDAT
; _this$ = ecx

; 1547 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 1548 : 	CvMapInitData defaultMapData;

	mov	DWORD PTR _defaultMapData$[ebp], 0
	mov	DWORD PTR _defaultMapData$[ebp+4], 0
	mov	DWORD PTR _defaultMapData$[ebp+8], 90	; 0000005aH
	mov	DWORD PTR _defaultMapData$[ebp+12], -90	; ffffffa6H
	mov	BYTE PTR _defaultMapData$[ebp+16], 1
	mov	BYTE PTR _defaultMapData$[ebp+17], 0

; 1549 : 
; 1550 : 	// Init data before load
; 1551 : 	reset(&defaultMapData);

	lea	eax, DWORD PTR _defaultMapData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::reset

; 1552 : 
; 1553 : 	// Version number to maintain backwards compatibility
; 1554 : 	uint uiVersion;
; 1555 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1556 : 
; 1557 : 	kStream >> m_iGridWidth;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4020				; 00000fb4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1558 : 	kStream >> m_iGridHeight;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4024				; 00000fb8H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1559 : 	m_iGridSize = m_iGridHeight * m_iGridWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4024]
	imul	eax, DWORD PTR [edx+4020]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4028], eax

; 1560 : 	kStream >> m_iLandPlots;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4032				; 00000fc0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1561 : 	kStream >> m_iOwnedPlots;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4036				; 00000fc4H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1562 : 	kStream >> m_iNumNaturalWonders;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4048				; 00000fd0H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1563 : 	kStream >> m_iTopLatitude;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4040				; 00000fc8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1564 : 	kStream >> m_iBottomLatitude;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4044				; 00000fccH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1565 : 
; 1566 : 	kStream >> m_bWrapX;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4056				; 00000fd8H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 1567 : 	kStream >> m_bWrapY;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4057				; 00000fd9H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 1568 : 
; 1569 : 	kStream >> m_guid.Data1;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4168				; 00001048H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAK@Z		; FDataStream::Read

; 1570 : 	kStream >> m_guid.Data2;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4172				; 0000104cH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAG@Z		; FDataStream::Read

; 1571 : 	kStream >> m_guid.Data3;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4174				; 0000104eH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAG@Z		; FDataStream::Read

; 1572 : 	ArrayWrapper<unsigned char> wrapm_guid(8, m_guid.Data4);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4176				; 00001050H
	mov	DWORD PTR _wrapm_guid$[ebp], eax
	mov	DWORD PTR _wrapm_guid$[ebp+4], 8

; 1573 : 	kStream >> wrapm_guid;

	lea	ecx, DWORD PTR _wrapm_guid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z ; operator>><unsigned char>
	add	esp, 8

; 1574 : 
; 1575 : 	CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated");
; 1576 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiNumResource, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4060]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 1577 : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiNumResourceOnLand, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4064]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
	add	esp, 12					; 0000000cH

; 1578 : 
; 1579 : 	if(numPlots() > 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T239196[ebp], ecx
	cmp	DWORD PTR $T239196[ebp], 0
	jle	SHORT $LN4@Read

; 1580 : 	{
; 1581 : 		InitPlots();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitPlots@CvMap@@IAEXXZ		; CvMap::InitPlots

; 1582 : #ifdef AUI_WARNING_FIXES
; 1583 : 		for (uint iI = 0; iI < numPlots(); iI++)
; 1584 : #else
; 1585 : 		int iI;
; 1586 : 		for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$235421[ebp], 0
	jmp	SHORT $LN3@Read
$LN2@Read:
	mov	edx, DWORD PTR _iI$235421[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$235421[ebp], edx
$LN3@Read:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T239200[ebp], ecx
	mov	edx, DWORD PTR _iI$235421[ebp]
	cmp	edx, DWORD PTR $T239200[ebp]
	jge	SHORT $LN4@Read

; 1587 : #endif
; 1588 : 		{
; 1589 : 			m_pMapPlots[iI].read(kStream);

	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iI$235421[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?read@CvPlot@@QAEXAAVFDataStream@@@Z	; CvPlot::read

; 1590 : 		}

	jmp	SHORT $LN2@Read
$LN4@Read:

; 1591 : 	}
; 1592 : 
; 1593 : 	// call the read of the free list CvArea class allocations
; 1594 : 	kStream >> m_areas;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4112				; 00001010H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator>><CvArea>
	add	esp, 8

; 1595 : 
; 1596 : 	kStream >> m_landmasses;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4140				; 0000102cH
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator>><CvLandmass>
	add	esp, 8

; 1597 : 
; 1598 : 	m_iAIMapHints = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4052], 0

; 1599 : 	kStream >> m_iAIMapHints;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4052				; 00000fd4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1600 : 
; 1601 : 	setup();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setup@CvMap@@IAEXXZ			; CvMap::setup

; 1602 : 
; 1603 : 	updateAdjacency();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateAdjacency@CvMap@@QAEXXZ		; CvMap::updateAdjacency

; 1604 : 
; 1605 : 	gDLL->DoMapSetup(numPlots());

	mov	eax, DWORD PTR $T239207[ebp]
	mov	DWORD PTR tv201[ebp], eax
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8564
	mov	DWORD PTR tv201[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T239211[ebp], eax
	mov	ecx, DWORD PTR $T239211[ebp]
	push	ecx
	mov	edx, DWORD PTR tv201[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv201[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx

; 1606 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvMap@@QAEXAAVFDataStream@@@Z ENDP		; CvMap::Read
_TEXT	ENDS
PUBLIC	??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator<<<CvLandmass>
PUBLIC	??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator<<<CvArea>
PUBLIC	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
PUBLIC	??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z ; operator<<<unsigned char const >
PUBLIC	?Write@CvMap@@QBEXAAVFDataStream@@@Z		; CvMap::Write
EXTRN	?write@CvPlot@@QBEXAAVFDataStream@@@Z:PROC	; CvPlot::write
EXTRN	?Write@FDataStream@@IAEXABG@Z:PROC		; FDataStream::Write
EXTRN	?Write@FDataStream@@IAEXABK@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
;	COMDAT ?Write@CvMap@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T239260 = -20						; size = 4
$T239214 = -16						; size = 8
_uiVersion$ = -8					; size = 4
_iI$ = -4						; size = 4
_kStream$ = 8						; size = 4
?Write@CvMap@@QBEXAAVFDataStream@@@Z PROC		; CvMap::Write, COMDAT
; _this$ = ecx

; 1613 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1614 : 	// Current version number
; 1615 : 	uint uiVersion = 1;

	mov	DWORD PTR _uiVersion$[ebp], 1

; 1616 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1617 : 
; 1618 : 	kStream << m_iGridWidth;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4020				; 00000fb4H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1619 : 	kStream << m_iGridHeight;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4024				; 00000fb8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1620 : 	kStream << m_iLandPlots;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4032				; 00000fc0H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1621 : 	kStream << m_iOwnedPlots;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4036				; 00000fc4H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1622 : 	kStream << m_iNumNaturalWonders;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4048				; 00000fd0H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1623 : 	kStream << m_iTopLatitude;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4040				; 00000fc8H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1624 : 	kStream << m_iBottomLatitude;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4044				; 00000fccH
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1625 : 	kStream << m_bWrapX;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4056				; 00000fd8H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 1626 : 	kStream << m_bWrapY;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4057				; 00000fd9H
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 1627 : 
; 1628 : 	kStream << m_guid.Data1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4168				; 00001048H
	push	ecx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABK@Z		; FDataStream::Write

; 1629 : 	kStream << m_guid.Data2;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4172				; 0000104cH
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABG@Z		; FDataStream::Write

; 1630 : 	kStream << m_guid.Data3;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4174				; 0000104eH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABG@Z		; FDataStream::Write

; 1631 : 	kStream << ArrayWrapper<const unsigned char>(8, m_guid.Data4);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4176				; 00001050H
	mov	DWORD PTR $T239214[ebp], ecx
	mov	DWORD PTR $T239214[ebp+4], 8
	lea	edx, DWORD PTR $T239214[ebp]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z ; operator<<<unsigned char const >
	add	esp, 8

; 1632 : 
; 1633 : 	CvAssertMsg((0 < GC.getNumResourceInfos()), "GC.getNumResourceInfos() is not greater than zero but an array is being allocated");
; 1634 : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_paiNumResource, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4060]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
	add	esp, 12					; 0000000cH

; 1635 : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_paiNumResourceOnLand, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4064]
	push	edx
	mov	eax, DWORD PTR _kStream$[ebp]
	push	eax
	call	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
	add	esp, 12					; 0000000cH

; 1636 : 
; 1637 : #ifdef AUI_WARNING_FIXES
; 1638 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 1639 : #else
; 1640 : 	int iI;
; 1641 : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@Write
$LN2@Write:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN3@Write:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T239260[ebp], eax
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR $T239260[ebp]
	jge	SHORT $LN1@Write

; 1642 : #endif
; 1643 : 	{
; 1644 : 		m_pMapPlots[iI].write(kStream);

	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4068]
	call	?write@CvPlot@@QBEXAAVFDataStream@@@Z	; CvPlot::write

; 1645 : 	}

	jmp	SHORT $LN2@Write
$LN1@Write:

; 1646 : 
; 1647 : 	// call the read of the free list CvArea class allocations
; 1648 : 	kStream << m_areas;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4112				; 00001010H
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z ; operator<<<CvArea>
	add	esp, 8

; 1649 : 
; 1650 : 	kStream << m_landmasses;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4140				; 0000102cH
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z ; operator<<<CvLandmass>
	add	esp, 8

; 1651 : 
; 1652 : 	kStream << m_iAIMapHints;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4052				; 00000fd4H
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1653 : 
; 1654 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Write@CvMap@@QBEXAAVFDataStream@@@Z ENDP		; CvMap::Write
_TEXT	ENDS
PUBLIC	?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z ; CvMap::rebuild
EXTRN	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z:PROC ; CvPreGame::setSeaLevel
EXTRN	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z:PROC ; CvPreGame::setClimate
EXTRN	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z:PROC ; CvPreGame::setWorldSize
; Function compile flags: /Odtp
;	COMDAT ?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_initData$ = -20					; size = 20
_iGridW$ = 8						; size = 4
_iGridH$ = 12						; size = 4
_iTopLatitude$ = 16					; size = 4
_iBottomLatitude$ = 20					; size = 4
_bWrapX$ = 24						; size = 1
_bWrapY$ = 28						; size = 1
_eWorldSize$ = 32					; size = 4
_eClimate$ = 36						; size = 4
_eSeaLevel$ = 40					; size = 4
?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z PROC ; CvMap::rebuild, COMDAT
; _this$ = ecx

; 1662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1663 : 	CvMapInitData initData(iGridW, iGridH, iTopLatitude, iBottomLatitude, bWrapX, bWrapY);

	mov	eax, DWORD PTR _iGridW$[ebp]
	mov	DWORD PTR _initData$[ebp], eax
	mov	ecx, DWORD PTR _iGridH$[ebp]
	mov	DWORD PTR _initData$[ebp+4], ecx
	mov	edx, DWORD PTR _iTopLatitude$[ebp]
	mov	DWORD PTR _initData$[ebp+8], edx
	mov	eax, DWORD PTR _iBottomLatitude$[ebp]
	mov	DWORD PTR _initData$[ebp+12], eax
	mov	cl, BYTE PTR _bWrapX$[ebp]
	mov	BYTE PTR _initData$[ebp+16], cl
	mov	dl, BYTE PTR _bWrapY$[ebp]
	mov	BYTE PTR _initData$[ebp+17], dl

; 1664 : 
; 1665 : 	// Set init core data
; 1666 : 	CvPreGame::setWorldSize(eWorldSize, true);

	push	1
	mov	eax, DWORD PTR _eWorldSize$[ebp]
	push	eax
	call	?setWorldSize@CvPreGame@@YAXW4WorldSizeTypes@@_N@Z ; CvPreGame::setWorldSize
	add	esp, 8

; 1667 : 	CvPreGame::setClimate(eClimate);

	mov	ecx, DWORD PTR _eClimate$[ebp]
	push	ecx
	call	?setClimate@CvPreGame@@YAXW4ClimateTypes@@@Z ; CvPreGame::setClimate
	add	esp, 4

; 1668 : 	CvPreGame::setSeaLevel(eSeaLevel);

	mov	edx, DWORD PTR _eSeaLevel$[ebp]
	push	edx
	call	?setSeaLevel@CvPreGame@@YAXW4SeaLevelTypes@@@Z ; CvPreGame::setSeaLevel
	add	esp, 4

; 1669 : 
; 1670 : 	// Init map
; 1671 : 	init(&initData);

	lea	eax, DWORD PTR _initData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?init@CvMap@@QAEXPAUCvMapInitData@@@Z	; CvMap::init

; 1672 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?rebuild@CvMap@@QAEXHHHH_N0W4WorldSizeTypes@@W4ClimateTypes@@W4SeaLevelTypes@@@Z ENDP ; CvMap::rebuild
_TEXT	ENDS
EXTRN	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ:PROC ; CvArea::getAreaBoundaries
EXTRN	?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z:PROC ; CvArea::setAreaBoundaries
EXTRN	?SetMountains@CvArea@@QAEX_N@Z:PROC		; CvArea::SetMountains
EXTRN	?init@CvArea@@QAEXH_N@Z:PROC			; CvArea::init
; Function compile flags: /Odtp
;	COMDAT ?calculateAreas@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T239332 = -88						; size = 4
$T239322 = -84						; size = 4
$T239303 = -80						; size = 4
$T239299 = -76						; size = 4
$T239289 = -72						; size = 4
$T239285 = -65						; size = 1
$T239281 = -64						; size = 4
$T239274 = -60						; size = 4
_boundaries$235574 = -56				; size = 16
_iX$235572 = -40					; size = 4
_iY$235573 = -36					; size = 4
_boundaries$235570 = -32				; size = 16
_iArea$ = -16						; size = 4
_pArea$ = -12						; size = 4
_iI$ = -8						; size = 4
_pLoopPlot$ = -4					; size = 4
?calculateAreas@CvMap@@QAEXXZ PROC			; CvMap::calculateAreas, COMDAT
; _this$ = ecx

; 1680 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 1681 : 	CvPlot* pLoopPlot;
; 1682 : 	CvArea* pArea;
; 1683 : 	int iArea;
; 1684 : #ifdef AUI_WARNING_FIXES
; 1685 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 1686 : #else
; 1687 : 	int iI;
; 1688 : 
; 1689 : 	for(iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN13@calculateA
$LN12@calculateA:
	mov	eax, DWORD PTR _iI$[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$[ebp], eax
$LN13@calculateA:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T239274[ebp], edx
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR $T239274[ebp]
	jge	$LN14@calculateA

; 1690 : #endif
; 1691 : 	{
; 1692 : 		pLoopPlot = plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR _iI$[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], ecx

; 1693 : 		CvAssertMsg(pLoopPlot != NULL, "LoopPlot is not assigned a valid value");
; 1694 : 
; 1695 : 		if(!pLoopPlot) continue;

	jne	SHORT $LN10@calculateA
	jmp	SHORT $LN12@calculateA
$LN10@calculateA:

; 1696 : 
; 1697 : 		if(pLoopPlot->getArea() == FFreeList::INVALID_INDEX)

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T239281[ebp], ecx
	cmp	DWORD PTR $T239281[ebp], -1
	jne	$LN9@calculateA

; 1698 : 		{
; 1699 : 			pArea = addArea();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?addArea@CvMap@@QAEPAVCvArea@@XZ	; CvMap::addArea
	mov	DWORD PTR _pArea$[ebp], eax

; 1700 : 			pArea->init(pArea->GetID(), pLoopPlot->isWater());

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	mov	BYTE PTR $T239285[ebp], cl
	mov	edx, DWORD PTR _pArea$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T239289[ebp], eax
	movzx	ecx, BYTE PTR $T239285[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239289[ebp]
	push	edx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?init@CvArea@@QAEXH_N@Z			; CvArea::init

; 1701 : 
; 1702 : 			pArea->SetMountains(pLoopPlot->isMountain());

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?SetMountains@CvArea@@QAEX_N@Z		; CvArea::SetMountains

; 1703 : 
; 1704 : 			iArea = pArea->GetID();

	mov	edx, DWORD PTR _pArea$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iArea$[ebp], eax

; 1705 : 
; 1706 : 			pLoopPlot->setArea(iArea);

	mov	ecx, DWORD PTR _iArea$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setArea@CvPlot@@QAEXH@Z		; CvPlot::setArea

; 1707 : 
; 1708 : 			GC.getAreaFinder().GeneratePath(pLoopPlot->getX(), pLoopPlot->getY(), -1, -1, iArea);

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239299[ebp], eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239303[ebp], edx
	push	0
	mov	eax, DWORD PTR _iArea$[ebp]
	push	eax
	push	-1
	push	-1
	mov	ecx, DWORD PTR $T239299[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239303[ebp]
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getAreaFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 1709 : 
; 1710 : 			CvAreaBoundaries boundaries;

	mov	DWORD PTR _boundaries$235570[ebp], 0
	mov	DWORD PTR _boundaries$235570[ebp+4], 0
	mov	DWORD PTR _boundaries$235570[ebp+8], 0
	mov	DWORD PTR _boundaries$235570[ebp+12], 0

; 1711 : 			boundaries.m_iEastEdge = pLoopPlot->getX();

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _boundaries$235570[ebp+8], ecx

; 1712 : 			boundaries.m_iWestEdge = pLoopPlot->getX();

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR _boundaries$235570[ebp+12], eax

; 1713 : 			boundaries.m_iNorthEdge = pLoopPlot->getY();

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR _boundaries$235570[ebp], edx

; 1714 : 			boundaries.m_iSouthEdge = pLoopPlot->getY();

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR _boundaries$235570[ebp+4], ecx

; 1715 : 			pArea->setAreaBoundaries(boundaries);

	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _boundaries$235570[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _boundaries$235570[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _boundaries$235570[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _boundaries$235570[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR _pArea$[ebp]
	call	?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z ; CvArea::setAreaBoundaries

; 1716 : 		}
; 1717 : 
; 1718 : 		// Update area boundaries if they've grown
; 1719 : 		else

	jmp	$LN8@calculateA
$LN9@calculateA:

; 1720 : 		{
; 1721 : 			int iX, iY;
; 1722 : 			CvAreaBoundaries boundaries = getArea(pLoopPlot->getArea())->getAreaBoundaries();

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR $T239322[ebp], eax
	lea	ecx, DWORD PTR _boundaries$235574[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239322[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries

; 1723 : 			iX = pLoopPlot->getX();

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _iX$235572[ebp], ecx

; 1724 : 			iY = pLoopPlot->getY();

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR _iY$235573[ebp], eax

; 1725 : 
; 1726 : 			if(iX < boundaries.m_iWestEdge)

	mov	ecx, DWORD PTR _iX$235572[ebp]
	cmp	ecx, DWORD PTR _boundaries$235574[ebp+12]
	jge	SHORT $LN7@calculateA

; 1727 : 			{
; 1728 : 				boundaries.m_iWestEdge = iX;

	mov	edx, DWORD PTR _iX$235572[ebp]
	mov	DWORD PTR _boundaries$235574[ebp+12], edx
	jmp	SHORT $LN6@calculateA
$LN7@calculateA:

; 1729 : 			}
; 1730 : 			else if(iX > boundaries.m_iEastEdge)

	mov	eax, DWORD PTR _iX$235572[ebp]
	cmp	eax, DWORD PTR _boundaries$235574[ebp+8]
	jle	SHORT $LN5@calculateA

; 1731 : 			{
; 1732 : 				boundaries.m_iEastEdge = iX;

	mov	ecx, DWORD PTR _iX$235572[ebp]
	mov	DWORD PTR _boundaries$235574[ebp+8], ecx
	jmp	SHORT $LN6@calculateA
$LN5@calculateA:

; 1733 : 			}
; 1734 : 			else if(iY < boundaries.m_iSouthEdge)

	mov	edx, DWORD PTR _iY$235573[ebp]
	cmp	edx, DWORD PTR _boundaries$235574[ebp+4]
	jge	SHORT $LN3@calculateA

; 1735 : 			{
; 1736 : 				boundaries.m_iSouthEdge = iY;

	mov	eax, DWORD PTR _iY$235573[ebp]
	mov	DWORD PTR _boundaries$235574[ebp+4], eax
	jmp	SHORT $LN6@calculateA
$LN3@calculateA:

; 1737 : 			}
; 1738 : 			else if(iY > boundaries.m_iNorthEdge)

	mov	ecx, DWORD PTR _iY$235573[ebp]
	cmp	ecx, DWORD PTR _boundaries$235574[ebp]
	jle	SHORT $LN6@calculateA

; 1739 : 			{
; 1740 : 				boundaries.m_iNorthEdge = iY;

	mov	edx, DWORD PTR _iY$235573[ebp]
	mov	DWORD PTR _boundaries$235574[ebp], edx
$LN6@calculateA:

; 1741 : 			}
; 1742 : 			getArea(pLoopPlot->getArea())->setAreaBoundaries(boundaries);

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR $T239332[ebp], ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _boundaries$235574[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _boundaries$235574[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _boundaries$235574[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _boundaries$235574[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR $T239332[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z ; CvArea::setAreaBoundaries
$LN8@calculateA:

; 1743 : 		}

	jmp	$LN12@calculateA
$LN14@calculateA:

; 1744 : 	}
; 1745 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?calculateAreas@CvMap@@QAEXXZ ENDP			; CvMap::calculateAreas
_TEXT	ENDS
PUBLIC	?GetNumNaturalWonders@CvMap@@QBEHXZ		; CvMap::GetNumNaturalWonders
; Function compile flags: /Odtp
;	COMDAT ?GetNumNaturalWonders@CvMap@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNumNaturalWonders@CvMap@@QBEHXZ PROC		; CvMap::GetNumNaturalWonders, COMDAT
; _this$ = ecx

; 1751 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1752 : 	return m_iNumNaturalWonders;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4048]

; 1753 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetNumNaturalWonders@CvMap@@QBEHXZ ENDP		; CvMap::GetNumNaturalWonders
_TEXT	ENDS
PUBLIC	?ChangeNumNaturalWonders@CvMap@@QAEXH@Z		; CvMap::ChangeNumNaturalWonders
; Function compile flags: /Odtp
;	COMDAT ?ChangeNumNaturalWonders@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iChange$ = 8						; size = 4
?ChangeNumNaturalWonders@CvMap@@QAEXH@Z PROC		; CvMap::ChangeNumNaturalWonders, COMDAT
; _this$ = ecx

; 1758 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1759 : 	m_iNumNaturalWonders += iChange;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4048]
	add	ecx, DWORD PTR _iChange$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4048], ecx

; 1760 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeNumNaturalWonders@CvMap@@QAEXH@Z ENDP		; CvMap::ChangeNumNaturalWonders
_TEXT	ENDS
PUBLIC	??_C@_0P@NNBLFEFC@Natural?5Wonder?$AA@		; `string'
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
PUBLIC	??_C@_0CB@HNHFOPJK@Randomly?5Placing?5Natural?5Wonders@ ; `string'
PUBLIC	??_C@_0BA@LLKOHFJP@FEATURE_VOLCANO?$AA@		; `string'
PUBLIC	??_C@_0N@BIFMFEIE@FEATURE_REEF?$AA@		; `string'
PUBLIC	??_C@_0N@KNAGBNNC@FEATURE_MESA?$AA@		; `string'
PUBLIC	??_C@_0N@FBOBGJKL@FEATURE_FUJI?$AA@		; `string'
PUBLIC	??_C@_0BB@LPODDEHI@FEATURE_TITICACA?$AA@	; `string'
PUBLIC	??_C@_0P@BNNPDMIO@FEATURE_CRATER?$AA@		; `string'
PUBLIC	??_C@_0BA@PDPJBJFO@FEATURE_EVEREST?$AA@		; `string'
PUBLIC	?DoPlaceNaturalWonders@CvMap@@QAEXXZ		; CvMap::DoPlaceNaturalWonders
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
EXTRN	?getMapRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getMapRandNum
EXTRN	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z:PROC ; CvPlot::setTerrainType
EXTRN	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ:PROC	; CvPlot::isAdjacentToShallowWater
EXTRN	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z:PROC ; CvPlot::setFeatureType
EXTRN	?IsNaturalWonder@CvPlot@@QBE_NXZ:PROC		; CvPlot::IsNaturalWonder
EXTRN	?isLake@CvPlot@@QBE_NXZ:PROC			; CvPlot::isLake
EXTRN	?isStartingPlot@CvPlot@@QBE_NXZ:PROC		; CvPlot::isStartingPlot
EXTRN	?getLatitude@CvPlot@@QBEHXZ:PROC		; CvPlot::getLatitude
EXTRN	?GetNumNaturalWonders@CvArea@@QBEHXZ:PROC	; CvArea::GetNumNaturalWonders
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?GetAreaMinLatitude@CvArea@@QAEHXZ:PROC		; CvArea::GetAreaMinLatitude
EXTRN	?IsMountains@CvArea@@QBE_NXZ:PROC		; CvArea::IsMountains
EXTRN	?getNumNaturalWonders@CvWorldInfo@@QBEHXZ:PROC	; CvWorldInfo::getNumNaturalWonders
EXTRN	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ:PROC	; CvFeatureInfo::IsNaturalWonder
EXTRN	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z:PROC ; CvGlobals::getFeatureInfo
EXTRN	?getNumFeatureInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumFeatureInfos
;	COMDAT ??_C@_0P@NNBLFEFC@Natural?5Wonder?$AA@
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
CONST	SEGMENT
??_C@_0P@NNBLFEFC@Natural?5Wonder?$AA@ DB 'Natural Wonder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HNHFOPJK@Randomly?5Placing?5Natural?5Wonders@
CONST	SEGMENT
??_C@_0CB@HNHFOPJK@Randomly?5Placing?5Natural?5Wonders@ DB 'Randomly Plac'
	DB	'ing Natural Wonders', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLKOHFJP@FEATURE_VOLCANO?$AA@
CONST	SEGMENT
??_C@_0BA@LLKOHFJP@FEATURE_VOLCANO?$AA@ DB 'FEATURE_VOLCANO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIFMFEIE@FEATURE_REEF?$AA@
CONST	SEGMENT
??_C@_0N@BIFMFEIE@FEATURE_REEF?$AA@ DB 'FEATURE_REEF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KNAGBNNC@FEATURE_MESA?$AA@
CONST	SEGMENT
??_C@_0N@KNAGBNNC@FEATURE_MESA?$AA@ DB 'FEATURE_MESA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FBOBGJKL@FEATURE_FUJI?$AA@
CONST	SEGMENT
??_C@_0N@FBOBGJKL@FEATURE_FUJI?$AA@ DB 'FEATURE_FUJI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LPODDEHI@FEATURE_TITICACA?$AA@
CONST	SEGMENT
??_C@_0BB@LPODDEHI@FEATURE_TITICACA?$AA@ DB 'FEATURE_TITICACA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BNNPDMIO@FEATURE_CRATER?$AA@
CONST	SEGMENT
??_C@_0P@BNNPDMIO@FEATURE_CRATER?$AA@ DB 'FEATURE_CRATER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PDPJBJFO@FEATURE_EVEREST?$AA@
CONST	SEGMENT
??_C@_0BA@PDPJBJFO@FEATURE_EVEREST?$AA@ DB 'FEATURE_EVEREST', 00H ; `string'
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
CONST	ENDS
;	COMDAT ?DoPlaceNaturalWonders@CvMap@@QAEXXZ
_TEXT	SEGMENT
tv600 = -848						; size = 4
tv183 = -844						; size = 4
tv955 = -840						; size = 4
tv950 = -834						; size = 1
tv943 = -833						; size = 1
tv939 = -832						; size = 4
tv940 = -828						; size = 4
tv172 = -824						; size = 4
tv931 = -820						; size = 4
tv926 = -814						; size = 1
tv919 = -813						; size = 1
tv915 = -812						; size = 4
tv916 = -808						; size = 4
tv161 = -804						; size = 4
tv907 = -800						; size = 4
tv902 = -794						; size = 1
tv895 = -793						; size = 1
tv891 = -792						; size = 4
tv892 = -788						; size = 4
tv150 = -784						; size = 4
tv883 = -780						; size = 4
tv859 = -774						; size = 1
tv849 = -773						; size = 1
tv732 = -772						; size = 4
tv622 = -768						; size = 4
tv139 = -764						; size = 4
tv635 = -760						; size = 4
tv707 = -754						; size = 1
tv705 = -753						; size = 1
tv739 = -752						; size = 4
tv708 = -748						; size = 4
tv128 = -744						; size = 4
tv614 = -740						; size = 4
tv658 = -734						; size = 1
tv653 = -733						; size = 1
tv837 = -732						; size = 4
tv770 = -728						; size = 4
tv85 = -724						; size = 4
tv867 = -720						; size = 4
tv729 = -714						; size = 1
tv873 = -713						; size = 1
tv874 = -712						; size = 4
tv850 = -708						; size = 4
_this$ = -704						; size = 4
$T240428 = -700						; size = 4
$T240424 = -696						; size = 4
$T240214 = -612						; size = 4
$T240210 = -608						; size = 4
$T240206 = -604						; size = 4
$T240199 = -600						; size = 4
$T239988 = -508						; size = 4
$T239984 = -504						; size = 4
$T239797 = -420						; size = 4
$T239793 = -416						; size = 4
$T239603 = -332						; size = 4
$T239599 = -328						; size = 4
$T239500 = -256						; size = 4
$T239496 = -252						; size = 4
$T239397 = -180						; size = 4
$T239393 = -176						; size = 4
$T239389 = -172						; size = 4
$T239373 = -168						; size = 4
$T239366 = -164						; size = 4
_pAdjacentPlot$235729 = -160				; size = 4
_iI$235725 = -156					; size = 4
_pAdjacentPlot$235718 = -152				; size = 4
_iI$235714 = -148					; size = 4
_pAdjacentPlot$235709 = -144				; size = 4
_iI$235705 = -140					; size = 4
_iHillCount$235704 = -136				; size = 4
_pAdjacentPlot$235698 = -132				; size = 4
_iI$235694 = -128					; size = 4
_iDice$235736 = -124					; size = 4
_bValid$235666 = -117					; size = 1
_feature$235609 = -116					; size = 4
_iFeatureLoop$235604 = -112				; size = 4
_featureEverest$ = -108					; size = 4
_featureMesa$ = -104					; size = 4
_featureVolcano$ = -100					; size = 4
_nwCount$ = -96						; size = 4
_iCount$ = -92						; size = 4
_pRandPlot$ = -88					; size = 4
_iBottomLatitude$ = -84					; size = 4
_iNumValidAreas$ = -80					; size = 4
_iNumMapPlots$ = -76					; size = 4
_featureLake$ = -72					; size = 4
_iAnotherNWDistance$ = -68				; size = 4
_pLoopArea$ = -64					; size = 4
_iMaxLatitudeForNW$ = -60				; size = 4
_iPlotLoopX$ = -56					; size = 4
_featureCrater$ = -52					; size = 4
_iMaxNWsOneArea$ = -48					; size = 4
_iPlotRand$ = -44					; size = 4
_iPlotLoopY$ = -40					; size = 4
_featureReef$ = -36					; size = 4
_iNumFeatureInfos$ = -32				; size = 4
_pLoopPlot$ = -28					; size = 4
_eNWFeature$ = -24					; size = 4
_eFeature$ = -20					; size = 4
_iNumNaturalWondersToAdd$ = -16				; size = 4
_iCoastDistance$ = -12					; size = 4
_featureFuji$ = -8					; size = 4
_iLoop$ = -4						; size = 4
?DoPlaceNaturalWonders@CvMap@@QAEXXZ PROC		; CvMap::DoPlaceNaturalWonders, COMDAT
; _this$ = ecx

; 1765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 848				; 00000350H
	mov	DWORD PTR _this$[ebp], ecx

; 1766 : 	FeatureTypes eNWFeature = NO_FEATURE;

	mov	DWORD PTR _eNWFeature$[ebp], -1

; 1767 : 	FeatureTypes eFeature;
; 1768 : 
; 1769 : 	FeatureTypes featureFuji = NO_FEATURE;

	mov	DWORD PTR _featureFuji$[ebp], -1

; 1770 : 	FeatureTypes featureEverest = NO_FEATURE;

	mov	DWORD PTR _featureEverest$[ebp], -1

; 1771 : 	FeatureTypes featureReef = NO_FEATURE;

	mov	DWORD PTR _featureReef$[ebp], -1

; 1772 : 	FeatureTypes featureCrater = NO_FEATURE;

	mov	DWORD PTR _featureCrater$[ebp], -1

; 1773 : 	FeatureTypes featureLake = NO_FEATURE;

	mov	DWORD PTR _featureLake$[ebp], -1

; 1774 : 	FeatureTypes featureMesa = NO_FEATURE;

	mov	DWORD PTR _featureMesa$[ebp], -1

; 1775 : 	FeatureTypes featureVolcano = NO_FEATURE;

	mov	DWORD PTR _featureVolcano$[ebp], -1

; 1776 : 
; 1777 : #ifdef AUI_WARNING_FIXES
; 1778 : 	int nwCount = 0;
; 1779 : 	for (uint iFeatureLoop = 0; iFeatureLoop < GC.getNumFeatureInfos(); iFeatureLoop++)
; 1780 : #else
; 1781 : 	int iNumFeatureInfos = GC.getNumFeatureInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumFeatureInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumFeatureInfos
	mov	DWORD PTR _iNumFeatureInfos$[ebp], eax

; 1782 : 	int nwCount = 0;

	mov	DWORD PTR _nwCount$[ebp], 0

; 1783 : 	for(int iFeatureLoop = 0; iFeatureLoop < iNumFeatureInfos; iFeatureLoop++)

	mov	DWORD PTR _iFeatureLoop$235604[ebp], 0
	jmp	SHORT $LN94@DoPlaceNat
$LN93@DoPlaceNat:
	mov	eax, DWORD PTR _iFeatureLoop$235604[ebp]
	add	eax, 1
	mov	DWORD PTR _iFeatureLoop$235604[ebp], eax
$LN94@DoPlaceNat:
	mov	ecx, DWORD PTR _iFeatureLoop$235604[ebp]
	cmp	ecx, DWORD PTR _iNumFeatureInfos$[ebp]
	jge	$LN92@DoPlaceNat

; 1784 : #endif
; 1785 : 	{
; 1786 : 		eFeature = (FeatureTypes) iFeatureLoop;

	mov	edx, DWORD PTR _iFeatureLoop$235604[ebp]
	mov	DWORD PTR _eFeature$[ebp], edx

; 1787 : 		CvFeatureInfo* feature = GC.getFeatureInfo(eFeature);

	mov	eax, DWORD PTR _eFeature$[ebp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getFeatureInfo@CvGlobals@@QAEPAVCvFeatureInfo@@W4FeatureTypes@@@Z ; CvGlobals::getFeatureInfo
	mov	DWORD PTR _feature$235609[ebp], eax

; 1788 : 		if(feature && feature->IsNaturalWonder())

	cmp	DWORD PTR _feature$235609[ebp], 0
	je	$LN91@DoPlaceNat
	mov	ecx, DWORD PTR _feature$235609[ebp]
	call	?IsNaturalWonder@CvFeatureInfo@@QBE_NXZ	; CvFeatureInfo::IsNaturalWonder
	movzx	ecx, al
	test	ecx, ecx
	je	$LN91@DoPlaceNat

; 1789 : 		{
; 1790 : 			eNWFeature = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _eNWFeature$[ebp], edx

; 1791 : 
; 1792 : 			// hackery - this should be more data driven but the engine side isn't
; 1793 : 
; 1794 : 			if(strcmp(feature->GetType(), "FEATURE_EVEREST") == 0)

	mov	DWORD PTR tv850[ebp], OFFSET ??_C@_0BA@PDPJBJFO@FEATURE_EVEREST?$AA@
	mov	ecx, DWORD PTR _feature$235609[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv874[ebp], eax
$LL614@DoPlaceNat:
	mov	eax, DWORD PTR tv874[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv873[ebp], cl
	mov	edx, DWORD PTR tv850[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN615@DoPlaceNat
	cmp	BYTE PTR tv873[ebp], 0
	je	SHORT $LN616@DoPlaceNat
	mov	eax, DWORD PTR tv874[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv729[ebp], cl
	mov	edx, DWORD PTR tv850[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN615@DoPlaceNat
	add	DWORD PTR tv874[ebp], 2
	add	DWORD PTR tv850[ebp], 2
	cmp	BYTE PTR tv729[ebp], 0
	jne	SHORT $LL614@DoPlaceNat
$LN616@DoPlaceNat:
	mov	DWORD PTR tv867[ebp], 0
	jmp	SHORT $LN617@DoPlaceNat
$LN615@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv867[ebp], eax
$LN617@DoPlaceNat:
	mov	ecx, DWORD PTR tv867[ebp]
	mov	DWORD PTR tv85[ebp], ecx
	cmp	DWORD PTR tv85[ebp], 0
	jne	SHORT $LN99@DoPlaceNat

; 1795 : 			{
; 1796 : 				featureEverest = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _featureEverest$[ebp], edx
	jmp	$LN89@DoPlaceNat

; 1797 : 			}
; 1798 : 			else if(strcmp(feature->GetType(), "FEATURE_CRATER") == 0)

$LN99@DoPlaceNat:
	mov	DWORD PTR tv770[ebp], OFFSET ??_C@_0P@BNNPDMIO@FEATURE_CRATER?$AA@
	mov	ecx, DWORD PTR _feature$235609[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv837[ebp], eax
$LL618@DoPlaceNat:
	mov	eax, DWORD PTR tv837[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv653[ebp], cl
	mov	edx, DWORD PTR tv770[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN619@DoPlaceNat
	cmp	BYTE PTR tv653[ebp], 0
	je	SHORT $LN620@DoPlaceNat
	mov	eax, DWORD PTR tv837[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv658[ebp], cl
	mov	edx, DWORD PTR tv770[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN619@DoPlaceNat
	add	DWORD PTR tv837[ebp], 2
	add	DWORD PTR tv770[ebp], 2
	cmp	BYTE PTR tv658[ebp], 0
	jne	SHORT $LL618@DoPlaceNat
$LN620@DoPlaceNat:
	mov	DWORD PTR tv614[ebp], 0
	jmp	SHORT $LN621@DoPlaceNat
$LN619@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv614[ebp], eax
$LN621@DoPlaceNat:
	mov	ecx, DWORD PTR tv614[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	cmp	DWORD PTR tv128[ebp], 0
	jne	SHORT $LN101@DoPlaceNat

; 1799 : 			{
; 1800 : 				featureCrater = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _featureCrater$[ebp], edx
	jmp	$LN89@DoPlaceNat

; 1801 : 			}
; 1802 : 			else if(strcmp(feature->GetType(), "FEATURE_TITICACA") == 0)

$LN101@DoPlaceNat:
	mov	DWORD PTR tv708[ebp], OFFSET ??_C@_0BB@LPODDEHI@FEATURE_TITICACA?$AA@
	mov	ecx, DWORD PTR _feature$235609[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv739[ebp], eax
$LL622@DoPlaceNat:
	mov	eax, DWORD PTR tv739[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv705[ebp], cl
	mov	edx, DWORD PTR tv708[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN623@DoPlaceNat
	cmp	BYTE PTR tv705[ebp], 0
	je	SHORT $LN624@DoPlaceNat
	mov	eax, DWORD PTR tv739[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv707[ebp], cl
	mov	edx, DWORD PTR tv708[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN623@DoPlaceNat
	add	DWORD PTR tv739[ebp], 2
	add	DWORD PTR tv708[ebp], 2
	cmp	BYTE PTR tv707[ebp], 0
	jne	SHORT $LL622@DoPlaceNat
$LN624@DoPlaceNat:
	mov	DWORD PTR tv635[ebp], 0
	jmp	SHORT $LN625@DoPlaceNat
$LN623@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv635[ebp], eax
$LN625@DoPlaceNat:
	mov	ecx, DWORD PTR tv635[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	cmp	DWORD PTR tv139[ebp], 0
	jne	SHORT $LN103@DoPlaceNat

; 1803 : 			{
; 1804 : 				featureLake = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _featureLake$[ebp], edx
	jmp	$LN89@DoPlaceNat

; 1805 : 			}
; 1806 : 			else if(strcmp(feature->GetType(), "FEATURE_FUJI") == 0)

$LN103@DoPlaceNat:
	mov	DWORD PTR tv622[ebp], OFFSET ??_C@_0N@FBOBGJKL@FEATURE_FUJI?$AA@
	mov	ecx, DWORD PTR _feature$235609[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv732[ebp], eax
$LL626@DoPlaceNat:
	mov	eax, DWORD PTR tv732[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv849[ebp], cl
	mov	edx, DWORD PTR tv622[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN627@DoPlaceNat
	cmp	BYTE PTR tv849[ebp], 0
	je	SHORT $LN628@DoPlaceNat
	mov	eax, DWORD PTR tv732[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv859[ebp], cl
	mov	edx, DWORD PTR tv622[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN627@DoPlaceNat
	add	DWORD PTR tv732[ebp], 2
	add	DWORD PTR tv622[ebp], 2
	cmp	BYTE PTR tv859[ebp], 0
	jne	SHORT $LL626@DoPlaceNat
$LN628@DoPlaceNat:
	mov	DWORD PTR tv883[ebp], 0
	jmp	SHORT $LN629@DoPlaceNat
$LN627@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv883[ebp], eax
$LN629@DoPlaceNat:
	mov	ecx, DWORD PTR tv883[ebp]
	mov	DWORD PTR tv150[ebp], ecx
	cmp	DWORD PTR tv150[ebp], 0
	jne	SHORT $LN105@DoPlaceNat

; 1807 : 			{
; 1808 : 				featureFuji = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _featureFuji$[ebp], edx
	jmp	$LN89@DoPlaceNat

; 1809 : 			}
; 1810 : 			else if(strcmp(feature->GetType(), "FEATURE_MESA") == 0)

$LN105@DoPlaceNat:
	mov	DWORD PTR tv892[ebp], OFFSET ??_C@_0N@KNAGBNNC@FEATURE_MESA?$AA@
	mov	ecx, DWORD PTR _feature$235609[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv891[ebp], eax
$LL630@DoPlaceNat:
	mov	eax, DWORD PTR tv891[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv895[ebp], cl
	mov	edx, DWORD PTR tv892[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN631@DoPlaceNat
	cmp	BYTE PTR tv895[ebp], 0
	je	SHORT $LN632@DoPlaceNat
	mov	eax, DWORD PTR tv891[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv902[ebp], cl
	mov	edx, DWORD PTR tv892[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN631@DoPlaceNat
	add	DWORD PTR tv891[ebp], 2
	add	DWORD PTR tv892[ebp], 2
	cmp	BYTE PTR tv902[ebp], 0
	jne	SHORT $LL630@DoPlaceNat
$LN632@DoPlaceNat:
	mov	DWORD PTR tv907[ebp], 0
	jmp	SHORT $LN633@DoPlaceNat
$LN631@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv907[ebp], eax
$LN633@DoPlaceNat:
	mov	ecx, DWORD PTR tv907[ebp]
	mov	DWORD PTR tv161[ebp], ecx
	cmp	DWORD PTR tv161[ebp], 0
	jne	SHORT $LN107@DoPlaceNat

; 1811 : 			{
; 1812 : 				featureMesa = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _featureMesa$[ebp], edx
	jmp	$LN89@DoPlaceNat

; 1813 : 			}
; 1814 : 			else if(strcmp(feature->GetType(), "FEATURE_REEF") == 0)

$LN107@DoPlaceNat:
	mov	DWORD PTR tv916[ebp], OFFSET ??_C@_0N@BIFMFEIE@FEATURE_REEF?$AA@
	mov	ecx, DWORD PTR _feature$235609[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv915[ebp], eax
$LL634@DoPlaceNat:
	mov	eax, DWORD PTR tv915[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv919[ebp], cl
	mov	edx, DWORD PTR tv916[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN635@DoPlaceNat
	cmp	BYTE PTR tv919[ebp], 0
	je	SHORT $LN636@DoPlaceNat
	mov	eax, DWORD PTR tv915[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv926[ebp], cl
	mov	edx, DWORD PTR tv916[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN635@DoPlaceNat
	add	DWORD PTR tv915[ebp], 2
	add	DWORD PTR tv916[ebp], 2
	cmp	BYTE PTR tv926[ebp], 0
	jne	SHORT $LL634@DoPlaceNat
$LN636@DoPlaceNat:
	mov	DWORD PTR tv931[ebp], 0
	jmp	SHORT $LN637@DoPlaceNat
$LN635@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv931[ebp], eax
$LN637@DoPlaceNat:
	mov	ecx, DWORD PTR tv931[ebp]
	mov	DWORD PTR tv172[ebp], ecx
	cmp	DWORD PTR tv172[ebp], 0
	jne	SHORT $LN109@DoPlaceNat

; 1815 : 			{
; 1816 : 				featureReef = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _featureReef$[ebp], edx
	jmp	$LN89@DoPlaceNat

; 1817 : 			}
; 1818 : 			else if(strcmp(feature->GetType(), "FEATURE_VOLCANO") == 0)

$LN109@DoPlaceNat:
	mov	DWORD PTR tv940[ebp], OFFSET ??_C@_0BA@LLKOHFJP@FEATURE_VOLCANO?$AA@
	mov	ecx, DWORD PTR _feature$235609[ebp]
	add	ecx, 176				; 000000b0H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR tv939[ebp], eax
$LL638@DoPlaceNat:
	mov	eax, DWORD PTR tv939[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv943[ebp], cl
	mov	edx, DWORD PTR tv940[ebp]
	cmp	cl, BYTE PTR [edx]
	jne	SHORT $LN639@DoPlaceNat
	cmp	BYTE PTR tv943[ebp], 0
	je	SHORT $LN640@DoPlaceNat
	mov	eax, DWORD PTR tv939[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR tv950[ebp], cl
	mov	edx, DWORD PTR tv940[ebp]
	cmp	cl, BYTE PTR [edx+1]
	jne	SHORT $LN639@DoPlaceNat
	add	DWORD PTR tv939[ebp], 2
	add	DWORD PTR tv940[ebp], 2
	cmp	BYTE PTR tv950[ebp], 0
	jne	SHORT $LL638@DoPlaceNat
$LN640@DoPlaceNat:
	mov	DWORD PTR tv955[ebp], 0
	jmp	SHORT $LN641@DoPlaceNat
$LN639@DoPlaceNat:
	sbb	eax, eax
	sbb	eax, -1
	mov	DWORD PTR tv955[ebp], eax
$LN641@DoPlaceNat:
	mov	ecx, DWORD PTR tv955[ebp]
	mov	DWORD PTR tv183[ebp], ecx
	cmp	DWORD PTR tv183[ebp], 0
	jne	SHORT $LN89@DoPlaceNat

; 1819 : 			{
; 1820 : 				featureVolcano = eFeature;

	mov	edx, DWORD PTR _eFeature$[ebp]
	mov	DWORD PTR _featureVolcano$[ebp], edx
$LN89@DoPlaceNat:

; 1821 : 			}
; 1822 : 
; 1823 : 			nwCount++;

	mov	eax, DWORD PTR _nwCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _nwCount$[ebp], eax
$LN91@DoPlaceNat:

; 1824 : 		}
; 1825 : 	}

	jmp	$LN93@DoPlaceNat
$LN92@DoPlaceNat:

; 1826 : 
; 1827 : 	// No Natural Wonder Feature, abort!
; 1828 : 	if(eNWFeature == NO_FEATURE)

	cmp	DWORD PTR _eNWFeature$[ebp], -1
	jne	SHORT $LN77@DoPlaceNat

; 1829 : 	{
; 1830 : 		return;

	jmp	$LN95@DoPlaceNat
$LN77@DoPlaceNat:

; 1831 : 	}
; 1832 : 
; 1833 : 	int iNumNaturalWondersToAdd = getWorldInfo().getNumNaturalWonders();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getNumNaturalWonders@CvWorldInfo@@QBEHXZ ; CvWorldInfo::getNumNaturalWonders
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], eax

; 1834 : 
; 1835 : 	int iCoastDistance = -1;	// Should be in XML

	mov	DWORD PTR _iCoastDistance$[ebp], -1

; 1836 : 	int iAnotherNWDistance = 5;	// Should be in XML

	mov	DWORD PTR _iAnotherNWDistance$[ebp], 5

; 1837 : 
; 1838 : 	int iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0

; 1839 : 
; 1840 : 	int iPlotRand;
; 1841 : 	CvPlot* pRandPlot;
; 1842 : 
; 1843 : 	int iPlotLoopX;
; 1844 : 	int iPlotLoopY;
; 1845 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1846 : 	int iMaxDX;
; 1847 : #endif
; 1848 : 	CvPlot* pLoopPlot;
; 1849 : 
; 1850 : 	int iNumMapPlots = numPlots();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iNumMapPlots$[ebp], edx

; 1851 : 
; 1852 : 	// Determine the max number of NWs we can have in a single Area
; 1853 : 	CvArea* pLoopArea;
; 1854 : 	int iLoop;
; 1855 : 	int iNumValidAreas = 0;

	mov	DWORD PTR _iNumValidAreas$[ebp], 0

; 1856 : 
; 1857 : 	int iMaxLatitudeForNW = 65;

	mov	DWORD PTR _iMaxLatitudeForNW$[ebp], 65	; 00000041H

; 1858 : 
; 1859 : 	int iBottomLatitude;
; 1860 : 
; 1861 : 	for(pLoopArea = firstArea(&iLoop); pLoopArea != NULL; pLoopArea = nextArea(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
	jmp	SHORT $LN76@DoPlaceNat
$LN75@DoPlaceNat:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	DWORD PTR _pLoopArea$[ebp], eax
$LN76@DoPlaceNat:
	cmp	DWORD PTR _pLoopArea$[ebp], 0
	je	SHORT $LN74@DoPlaceNat

; 1862 : 	{
; 1863 : 		if(!pLoopArea->isWater())

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN73@DoPlaceNat

; 1864 : 		{
; 1865 : 			if(!pLoopArea->IsMountains())

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?IsMountains@CvArea@@QBE_NXZ		; CvArea::IsMountains
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN73@DoPlaceNat

; 1866 : 			{
; 1867 : 				iBottomLatitude = pLoopArea->GetAreaMinLatitude();

	mov	ecx, DWORD PTR _pLoopArea$[ebp]
	call	?GetAreaMinLatitude@CvArea@@QAEHXZ	; CvArea::GetAreaMinLatitude
	mov	DWORD PTR _iBottomLatitude$[ebp], eax

; 1868 : 
; 1869 : 				if(iBottomLatitude <= iMaxLatitudeForNW)

	mov	ecx, DWORD PTR _iBottomLatitude$[ebp]
	cmp	ecx, DWORD PTR _iMaxLatitudeForNW$[ebp]
	jg	SHORT $LN73@DoPlaceNat

; 1870 : 				{
; 1871 : 					iNumValidAreas++;

	mov	edx, DWORD PTR _iNumValidAreas$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumValidAreas$[ebp], edx
$LN73@DoPlaceNat:

; 1872 : 				}
; 1873 : 			}
; 1874 : 		}
; 1875 : 	}

	jmp	SHORT $LN75@DoPlaceNat
$LN74@DoPlaceNat:

; 1876 : 
; 1877 : 	int iMaxNWsOneArea = 2;

	mov	DWORD PTR _iMaxNWsOneArea$[ebp], 2

; 1878 : 
; 1879 : 	// If we have more Natural Wonders than we have Areas then we have to handle things differently - more can be placed in one Area than normal
; 1880 : 	if(iNumNaturalWondersToAdd > iNumValidAreas)

	mov	eax, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	cmp	eax, DWORD PTR _iNumValidAreas$[ebp]
	jle	SHORT $LN69@DoPlaceNat

; 1881 : 	{
; 1882 : 		iMaxNWsOneArea = iNumNaturalWondersToAdd - iNumValidAreas + 1;

	mov	ecx, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	ecx, DWORD PTR _iNumValidAreas$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iMaxNWsOneArea$[ebp], ecx
$LN69@DoPlaceNat:

; 1883 : 	}
; 1884 : 
; 1885 : 	while(iNumNaturalWondersToAdd > 0 && iCount < 10000)

	cmp	DWORD PTR _iNumNaturalWondersToAdd$[ebp], 0
	jle	$LN95@DoPlaceNat
	cmp	DWORD PTR _iCount$[ebp], 10000		; 00002710H
	jge	$LN95@DoPlaceNat

; 1886 : 	{
; 1887 : 		iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx

; 1888 : 
; 1889 : 		iPlotRand = GC.getGame().getJonRandNum(iNumMapPlots, "Randomly Placing Natural Wonders");

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T239366[ebp], eax
	push	OFFSET ??_C@_0CB@HNHFOPJK@Randomly?5Placing?5Natural?5Wonders@
	mov	ecx, DWORD PTR _iNumMapPlots$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T239366[ebp]
	call	?getJonRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getJonRandNum
	mov	DWORD PTR _iPlotRand$[ebp], eax

; 1890 : 
; 1891 : 		pRandPlot = plotByIndex(iPlotRand);

	cmp	DWORD PTR _iPlotRand$[ebp], 0
	jl	SHORT $LN117@DoPlaceNat
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T239373[ebp], eax
	mov	ecx, DWORD PTR _iPlotRand$[ebp]
	cmp	ecx, DWORD PTR $T239373[ebp]
	jge	SHORT $LN117@DoPlaceNat
	mov	edx, DWORD PTR _iPlotRand$[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv600[ebp], edx
	jmp	SHORT $LN115@DoPlaceNat
$LN117@DoPlaceNat:
	mov	DWORD PTR tv600[ebp], 0
$LN115@DoPlaceNat:
	mov	ecx, DWORD PTR tv600[ebp]
	mov	DWORD PTR _pRandPlot$[ebp], ecx

; 1892 : 
; 1893 : 		// No Water Tiles
; 1894 : 		if(pRandPlot->isWater())

	mov	edx, DWORD PTR _pRandPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN123@DoPlaceNat

; 1895 : 		{
; 1896 : 			continue;

	jmp	$LN69@DoPlaceNat

; 1897 : 		}
; 1898 : 
; 1899 : 		// No River Tiles either (don't want them carved up)
; 1900 : 		if(pRandPlot->isRiver())

$LN123@DoPlaceNat:
	mov	eax, DWORD PTR _pRandPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+457]
	xor	edx, edx
	test	ecx, ecx
	setg	dl
	movzx	eax, dl
	test	eax, eax
	je	SHORT $LN66@DoPlaceNat

; 1901 : 		{
; 1902 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN66@DoPlaceNat:

; 1903 : 		}
; 1904 : 
; 1905 : 		// No Tiles with Resources
; 1906 : 		if(pRandPlot->getResourceType() != NO_RESOURCE)

	push	-1
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN65@DoPlaceNat

; 1907 : 		{
; 1908 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN65@DoPlaceNat:

; 1909 : 		}
; 1910 : 
; 1911 : 		// No Tiles with Improvements (Goody Huts)
; 1912 : 		if(pRandPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN64@DoPlaceNat

; 1913 : 		{
; 1914 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN64@DoPlaceNat:

; 1915 : 		}
; 1916 : 
; 1917 : 		// Can't have too many NWs in one Area
; 1918 : 		if(getArea(pRandPlot->getArea())->GetNumNaturalWonders() >= iMaxNWsOneArea)

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	mov	edx, DWORD PTR [ecx+356]
	mov	DWORD PTR $T239389[ebp], edx
	mov	eax, DWORD PTR $T239389[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea
	mov	ecx, eax
	call	?GetNumNaturalWonders@CvArea@@QBEHXZ	; CvArea::GetNumNaturalWonders
	cmp	eax, DWORD PTR _iMaxNWsOneArea$[ebp]
	jl	SHORT $LN63@DoPlaceNat

; 1919 : 		{
; 1920 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN63@DoPlaceNat:

; 1921 : 		}
; 1922 : 
; 1923 : 		// Has to be in the central band of the map.  If the latitude is too extreme we might end up on a islelet surrounded by Ice or something
; 1924 : 		if(pRandPlot->getLatitude() > /*65*/ iMaxLatitudeForNW)

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?getLatitude@CvPlot@@QBEHXZ		; CvPlot::getLatitude
	cmp	eax, DWORD PTR _iMaxLatitudeForNW$[ebp]
	jle	SHORT $LN62@DoPlaceNat

; 1925 : 		{
; 1926 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN62@DoPlaceNat:

; 1927 : 		}
; 1928 : 
; 1929 : 		// Can't be a starting Plot for ANY player (including Minors)
; 1930 : 		if(pRandPlot->isStartingPlot())

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?isStartingPlot@CvPlot@@QBE_NXZ		; CvPlot::isStartingPlot
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN61@DoPlaceNat

; 1931 : 		{
; 1932 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN61@DoPlaceNat:

; 1933 : 		}
; 1934 : 
; 1935 : 		bool bValid;
; 1936 : 
; 1937 : 		// Does it have to be close to the coast?
; 1938 : 		if(iCoastDistance != -1)

	cmp	DWORD PTR _iCoastDistance$[ebp], -1
	je	$LN60@DoPlaceNat

; 1939 : 		{
; 1940 : 			bValid = false;

	mov	BYTE PTR _bValid$235666[ebp], 0

; 1941 : 
; 1942 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1943 : 			for (iPlotLoopY = -iCoastDistance; iPlotLoopY <= iCoastDistance; iPlotLoopY++)
; 1944 : 			{
; 1945 : 				iMaxDX = iCoastDistance - MAX(0, iPlotLoopY);
; 1946 : 				for (iPlotLoopX = -iCoastDistance - MIN(0, iPlotLoopY); iPlotLoopX <= iMaxDX; iPlotLoopX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1947 : 				{
; 1948 : 					// No need for range check because loops are set up properly
; 1949 : 					pLoopPlot = plotXY(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY);
; 1950 : #else
; 1951 : 			for(iPlotLoopX = -iCoastDistance; iPlotLoopX <= iCoastDistance; iPlotLoopX++)

	mov	edx, DWORD PTR _iCoastDistance$[ebp]
	neg	edx
	mov	DWORD PTR _iPlotLoopX$[ebp], edx
	jmp	SHORT $LN59@DoPlaceNat
$LN58@DoPlaceNat:
	mov	eax, DWORD PTR _iPlotLoopX$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlotLoopX$[ebp], eax
$LN59@DoPlaceNat:
	mov	ecx, DWORD PTR _iPlotLoopX$[ebp]
	cmp	ecx, DWORD PTR _iCoastDistance$[ebp]
	jg	$LN57@DoPlaceNat

; 1952 : 			{
; 1953 : 				for(iPlotLoopY = -iCoastDistance; iPlotLoopY <= iCoastDistance; iPlotLoopY++)

	mov	edx, DWORD PTR _iCoastDistance$[ebp]
	neg	edx
	mov	DWORD PTR _iPlotLoopY$[ebp], edx
	jmp	SHORT $LN56@DoPlaceNat
$LN55@DoPlaceNat:
	mov	eax, DWORD PTR _iPlotLoopY$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPlotLoopY$[ebp], eax
$LN56@DoPlaceNat:
	mov	ecx, DWORD PTR _iPlotLoopY$[ebp]
	cmp	ecx, DWORD PTR _iCoastDistance$[ebp]
	jg	SHORT $LN54@DoPlaceNat

; 1954 : 				{
; 1955 : 					pLoopPlot = plotXYWithRangeCheck(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY, iCoastDistance);

	mov	edx, DWORD PTR _pRandPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239393[ebp], eax
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239397[ebp], edx
	mov	eax, DWORD PTR _iCoastDistance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iPlotLoopY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotLoopX$[ebp]
	push	edx
	mov	eax, DWORD PTR $T239393[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239397[ebp]
	push	ecx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 1956 : #endif
; 1957 : 
; 1958 : 					if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN53@DoPlaceNat

; 1959 : 					{
; 1960 : 						if(pLoopPlot->isWater())

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	xor	ecx, ecx
	cmp	eax, 3
	sete	cl
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN53@DoPlaceNat

; 1961 : 						{
; 1962 : 							if(!pLoopPlot->isLake())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?isLake@CvPlot@@QBE_NXZ			; CvPlot::isLake
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN53@DoPlaceNat

; 1963 : 							{
; 1964 : 								// Found a Plot within 2 plots of "the Ocean"
; 1965 : 								bValid = true;

	mov	BYTE PTR _bValid$235666[ebp], 1

; 1966 : 								break;

	jmp	SHORT $LN54@DoPlaceNat
$LN53@DoPlaceNat:

; 1967 : 							}
; 1968 : 						}
; 1969 : 					}
; 1970 : 				}

	jmp	$LN55@DoPlaceNat
$LN54@DoPlaceNat:

; 1971 : 
; 1972 : 				if(bValid)

	movzx	ecx, BYTE PTR _bValid$235666[ebp]
	test	ecx, ecx
	je	SHORT $LN50@DoPlaceNat

; 1973 : 				{
; 1974 : 					break;

	jmp	SHORT $LN57@DoPlaceNat
$LN50@DoPlaceNat:

; 1975 : 				}
; 1976 : 			}

	jmp	$LN58@DoPlaceNat
$LN57@DoPlaceNat:

; 1977 : 
; 1978 : 			// Plot not within 2 of Ocean
; 1979 : 			if(!bValid)

	movzx	edx, BYTE PTR _bValid$235666[ebp]
	test	edx, edx
	jne	SHORT $LN60@DoPlaceNat

; 1980 : 			{
; 1981 : 				continue;

	jmp	$LN69@DoPlaceNat
$LN60@DoPlaceNat:

; 1982 : 			}
; 1983 : 		}
; 1984 : 
; 1985 : 		bValid = true;

	mov	BYTE PTR _bValid$235666[ebp], 1

; 1986 : 
; 1987 : 		// Can't be too close to another Natural Wonder
; 1988 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 1989 : 		for (iPlotLoopY = -iAnotherNWDistance; iPlotLoopY <= iAnotherNWDistance; iPlotLoopY++)
; 1990 : 		{
; 1991 : 			iMaxDX = iAnotherNWDistance - MAX(0, iPlotLoopY);
; 1992 : 			for (iPlotLoopX = -iAnotherNWDistance - MIN(0, iPlotLoopY); iPlotLoopX <= iMaxDX; iPlotLoopX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 1993 : 			{
; 1994 : 				// No need for range check because loops are set up properly
; 1995 : 				pLoopPlot = plotXY(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY);
; 1996 : #else
; 1997 : 		for(iPlotLoopX = -iAnotherNWDistance; iPlotLoopX <= iAnotherNWDistance; iPlotLoopX++)

	mov	eax, DWORD PTR _iAnotherNWDistance$[ebp]
	neg	eax
	mov	DWORD PTR _iPlotLoopX$[ebp], eax
	jmp	SHORT $LN48@DoPlaceNat
$LN47@DoPlaceNat:
	mov	ecx, DWORD PTR _iPlotLoopX$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlotLoopX$[ebp], ecx
$LN48@DoPlaceNat:
	mov	edx, DWORD PTR _iPlotLoopX$[ebp]
	cmp	edx, DWORD PTR _iAnotherNWDistance$[ebp]
	jg	$LN46@DoPlaceNat

; 1998 : 		{
; 1999 : 			for(iPlotLoopY = -iAnotherNWDistance; iPlotLoopY <= iAnotherNWDistance; iPlotLoopY++)

	mov	eax, DWORD PTR _iAnotherNWDistance$[ebp]
	neg	eax
	mov	DWORD PTR _iPlotLoopY$[ebp], eax
	jmp	SHORT $LN45@DoPlaceNat
$LN44@DoPlaceNat:
	mov	ecx, DWORD PTR _iPlotLoopY$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPlotLoopY$[ebp], ecx
$LN45@DoPlaceNat:
	mov	edx, DWORD PTR _iPlotLoopY$[ebp]
	cmp	edx, DWORD PTR _iAnotherNWDistance$[ebp]
	jg	SHORT $LN43@DoPlaceNat

; 2000 : 			{
; 2001 : 				pLoopPlot = plotXYWithRangeCheck(pRandPlot->getX(), pRandPlot->getY(), iPlotLoopX, iPlotLoopY, iAnotherNWDistance);

	mov	eax, DWORD PTR _pRandPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239496[ebp], ecx
	mov	edx, DWORD PTR _pRandPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T239500[ebp], eax
	mov	ecx, DWORD PTR _iAnotherNWDistance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iPlotLoopY$[ebp]
	push	edx
	mov	eax, DWORD PTR _iPlotLoopX$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239496[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239500[ebp]
	push	edx
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 2002 : #endif
; 2003 : 
; 2004 : 				if(pLoopPlot != NULL)

	cmp	DWORD PTR _pLoopPlot$[ebp], 0
	je	SHORT $LN42@DoPlaceNat

; 2005 : 				{
; 2006 : 					if(pLoopPlot->IsNaturalWonder())

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?IsNaturalWonder@CvPlot@@QBE_NXZ	; CvPlot::IsNaturalWonder
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN42@DoPlaceNat

; 2007 : 					{
; 2008 : 						// Found a NW too close
; 2009 : 						bValid = false;

	mov	BYTE PTR _bValid$235666[ebp], 0

; 2010 : 						break;

	jmp	SHORT $LN43@DoPlaceNat
$LN42@DoPlaceNat:

; 2011 : 					}
; 2012 : 				}
; 2013 : 			}

	jmp	SHORT $LN44@DoPlaceNat
$LN43@DoPlaceNat:

; 2014 : 
; 2015 : 			if(!bValid)

	movzx	ecx, BYTE PTR _bValid$235666[ebp]
	test	ecx, ecx
	jne	SHORT $LN40@DoPlaceNat

; 2016 : 			{
; 2017 : 				break;

	jmp	SHORT $LN46@DoPlaceNat
$LN40@DoPlaceNat:

; 2018 : 			}
; 2019 : 		}

	jmp	$LN47@DoPlaceNat
$LN46@DoPlaceNat:

; 2020 : 
; 2021 : 		// Natural Wonder too close
; 2022 : 		if(!bValid)

	movzx	edx, BYTE PTR _bValid$235666[ebp]
	test	edx, edx
	jne	SHORT $LN39@DoPlaceNat

; 2023 : 		{
; 2024 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN39@DoPlaceNat:

; 2025 : 		}
; 2026 : 
; 2027 : 		// see if we can add the volcano
; 2028 : 		if(featureVolcano != NO_FEATURE)

	cmp	DWORD PTR _featureVolcano$[ebp], -1
	je	SHORT $LN38@DoPlaceNat

; 2029 : 		{
; 2030 : 			if(!pRandPlot->isAdjacentToLand())

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?isAdjacentToLand@CvPlot@@QBE_NXZ	; CvPlot::isAdjacentToLand
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN38@DoPlaceNat

; 2031 : 			{
; 2032 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2033 : 				pRandPlot->setFeatureType(featureVolcano);

	push	-1
	mov	ecx, DWORD PTR _featureVolcano$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2034 : 				iNumNaturalWondersToAdd--;

	mov	edx, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	edx, 1
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], edx

; 2035 : 				featureVolcano = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureVolcano$[ebp], -1

; 2036 : 				continue;

	jmp	$LN69@DoPlaceNat
$LN38@DoPlaceNat:

; 2037 : 			}
; 2038 : 		}
; 2039 : 
; 2040 : 		// see if we can add the reef
; 2041 : 		if(featureReef != NO_FEATURE)

	cmp	DWORD PTR _featureReef$[ebp], -1
	je	$LN36@DoPlaceNat

; 2042 : 		{
; 2043 : 			if(!pRandPlot->isMountain() && pRandPlot->isAdjacentToShallowWater())

	mov	eax, DWORD PTR _pRandPlot$[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	jne	$LN36@DoPlaceNat
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?isAdjacentToShallowWater@CvPlot@@QBE_NXZ ; CvPlot::isAdjacentToShallowWater
	movzx	eax, al
	test	eax, eax
	je	$LN36@DoPlaceNat

; 2044 : 			{
; 2045 : 				if(pRandPlot->area()->getNumTiles() == 2)

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area
	mov	ecx, eax
	call	?getNumTiles@CvArea@@QBEHXZ		; CvArea::getNumTiles
	cmp	eax, 2
	jne	$LN36@DoPlaceNat

; 2046 : 				{
; 2047 : 					pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2048 : 					pRandPlot->setFeatureType(featureReef);

	push	-1
	mov	ecx, DWORD PTR _featureReef$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2049 : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$235694[ebp], 0
	jmp	SHORT $LN33@DoPlaceNat
$LN32@DoPlaceNat:
	mov	edx, DWORD PTR _iI$235694[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$235694[ebp], edx
$LN33@DoPlaceNat:
	cmp	DWORD PTR _iI$235694[ebp], 6
	jge	$LN31@DoPlaceNat

; 2050 : 					{
; 2051 : 						CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _pRandPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T239599[ebp], ecx
	mov	edx, DWORD PTR _pRandPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T239603[ebp], eax
	mov	ecx, DWORD PTR _iI$235694[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239599[ebp]
	push	edx
	mov	eax, DWORD PTR $T239603[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$235698[ebp], eax

; 2052 : 						if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$235698[ebp], 0
	je	SHORT $LN30@DoPlaceNat

; 2053 : 						{
; 2054 : 							if(!(pAdjacentPlot->isWater()))

	mov	ecx, DWORD PTR _pAdjacentPlot$235698[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN30@DoPlaceNat

; 2055 : 							{
; 2056 : 								pAdjacentPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pAdjacentPlot$235698[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2057 : 								pAdjacentPlot->setFeatureType(featureReef);

	push	-1
	mov	edx, DWORD PTR _featureReef$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pAdjacentPlot$235698[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2058 : 								break;

	jmp	SHORT $LN31@DoPlaceNat
$LN30@DoPlaceNat:

; 2059 : 							}
; 2060 : 						}
; 2061 : 					}

	jmp	$LN32@DoPlaceNat
$LN31@DoPlaceNat:

; 2062 : 					iNumNaturalWondersToAdd--;

	mov	eax, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], eax

; 2063 : 					featureReef = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureReef$[ebp], -1

; 2064 : 					continue;

	jmp	$LN69@DoPlaceNat
$LN36@DoPlaceNat:

; 2065 : 				}
; 2066 : 			}
; 2067 : 		}
; 2068 : 
; 2069 : 		// see if we can add the lake
; 2070 : 		if(featureLake != NO_FEATURE)

	cmp	DWORD PTR _featureLake$[ebp], -1
	je	$LN28@DoPlaceNat

; 2071 : 		{
; 2072 : 			if(pRandPlot->isHills())

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	sub	edx, 1
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN28@DoPlaceNat

; 2073 : 			{
; 2074 : 				int iHillCount = 0;

	mov	DWORD PTR _iHillCount$235704[ebp], 0

; 2075 : 				// if we have a couple of hills nearby already
; 2076 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$235705[ebp], 0
	jmp	SHORT $LN26@DoPlaceNat
$LN25@DoPlaceNat:
	mov	ecx, DWORD PTR _iI$235705[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$235705[ebp], ecx
$LN26@DoPlaceNat:
	cmp	DWORD PTR _iI$235705[ebp], 6
	jge	SHORT $LN24@DoPlaceNat

; 2077 : 				{
; 2078 : 					CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _pRandPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239793[ebp], eax
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239797[ebp], edx
	mov	eax, DWORD PTR _iI$235705[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239793[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239797[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$235709[ebp], eax

; 2079 : 					if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$235709[ebp], 0
	je	SHORT $LN23@DoPlaceNat

; 2080 : 					{
; 2081 : 						if((pAdjacentPlot->isHills()))

	mov	eax, DWORD PTR _pAdjacentPlot$235709[ebp]
	movsx	ecx, BYTE PTR [eax+5]
	sub	ecx, 1
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	movzx	edx, cl
	test	edx, edx
	je	SHORT $LN23@DoPlaceNat

; 2082 : 						{
; 2083 : 							iHillCount++;

	mov	eax, DWORD PTR _iHillCount$235704[ebp]
	add	eax, 1
	mov	DWORD PTR _iHillCount$235704[ebp], eax
$LN23@DoPlaceNat:

; 2084 : 						}
; 2085 : 					}
; 2086 : 				}

	jmp	$LN25@DoPlaceNat
$LN24@DoPlaceNat:

; 2087 : 				if(iHillCount > 2)

	cmp	DWORD PTR _iHillCount$235704[ebp], 2
	jle	$LN28@DoPlaceNat

; 2088 : 				{
; 2089 : 					// we are stamping the terrain
; 2090 : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$235714[ebp], 0
	jmp	SHORT $LN20@DoPlaceNat
$LN19@DoPlaceNat:
	mov	ecx, DWORD PTR _iI$235714[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$235714[ebp], ecx
$LN20@DoPlaceNat:
	cmp	DWORD PTR _iI$235714[ebp], 6
	jge	SHORT $LN18@DoPlaceNat

; 2091 : 					{
; 2092 : 						CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	mov	edx, DWORD PTR _pRandPlot$[ebp]
	movsx	eax, WORD PTR [edx+2]
	mov	DWORD PTR $T239984[ebp], eax
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	DWORD PTR $T239988[ebp], edx
	mov	eax, DWORD PTR _iI$235714[ebp]
	push	eax
	mov	ecx, DWORD PTR $T239984[ebp]
	push	ecx
	mov	edx, DWORD PTR $T239988[ebp]
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$235718[ebp], eax

; 2093 : 						if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$235718[ebp], 0
	je	SHORT $LN17@DoPlaceNat

; 2094 : 						{
; 2095 : 							pAdjacentPlot->setPlotType(PLOT_HILLS);

	push	1
	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _pAdjacentPlot$235718[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2096 : 							pAdjacentPlot->setTerrainType((TerrainTypes)(GC.getLAND_TERRAIN()));

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8388
	mov	DWORD PTR $T240199[ebp], eax
	push	1
	push	1
	mov	ecx, DWORD PTR $T240199[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pAdjacentPlot$235718[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN17@DoPlaceNat:

; 2097 : 						}
; 2098 : 					}

	jmp	$LN19@DoPlaceNat
$LN18@DoPlaceNat:

; 2099 : 					pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2100 : 					pRandPlot->setFeatureType(featureLake);

	push	-1
	mov	edx, DWORD PTR _featureLake$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2101 : 					iNumNaturalWondersToAdd--;

	mov	eax, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], eax

; 2102 : 					featureLake = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureLake$[ebp], -1

; 2103 : 					continue;

	jmp	$LN69@DoPlaceNat
$LN28@DoPlaceNat:

; 2104 : 				}
; 2105 : 			}
; 2106 : 		}
; 2107 : 
; 2108 : 		// see if we can add Everest
; 2109 : 		if(featureEverest != NO_FEATURE)

	cmp	DWORD PTR _featureEverest$[ebp], -1
	je	$LN16@DoPlaceNat

; 2110 : 		{
; 2111 : 			if(pRandPlot->isMountain() && GC.getGame().getMapRandNum(100, "Natural Wonder") > 75)

	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	neg	edx
	sbb	edx, edx
	add	edx, 1
	movzx	eax, dl
	test	eax, eax
	je	$LN16@DoPlaceNat
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240206[ebp], ecx
	push	OFFSET ??_C@_0P@NNBLFEFC@Natural?5Wonder?$AA@
	push	100					; 00000064H
	mov	ecx, DWORD PTR $T240206[ebp]
	call	?getMapRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getMapRandNum
	cmp	eax, 75					; 0000004bH
	jle	$LN16@DoPlaceNat

; 2112 : 			{
; 2113 : 				// we are stamping the terrain
; 2114 : 				for(int iI = 0; iI < NUM_DIRECTION_TYPES; ++iI)

	mov	DWORD PTR _iI$235725[ebp], 0
	jmp	SHORT $LN14@DoPlaceNat
$LN13@DoPlaceNat:
	mov	edx, DWORD PTR _iI$235725[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$235725[ebp], edx
$LN14@DoPlaceNat:
	cmp	DWORD PTR _iI$235725[ebp], 6
	jge	$LN12@DoPlaceNat

; 2115 : 				{
; 2116 : 					CvPlot* pAdjacentPlot = plotDirection(pRandPlot->getX(), pRandPlot->getY(), ((DirectionTypes)iI));

	mov	eax, DWORD PTR _pRandPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T240210[ebp], ecx
	mov	edx, DWORD PTR _pRandPlot$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	DWORD PTR $T240214[ebp], eax
	mov	ecx, DWORD PTR _iI$235725[ebp]
	push	ecx
	mov	edx, DWORD PTR $T240210[ebp]
	push	edx
	mov	eax, DWORD PTR $T240214[ebp]
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pAdjacentPlot$235729[ebp], eax

; 2117 : 					if(pAdjacentPlot != NULL)

	cmp	DWORD PTR _pAdjacentPlot$235729[ebp], 0
	je	SHORT $LN11@DoPlaceNat

; 2118 : 					{
; 2119 : 						if(iI & 1)

	mov	ecx, DWORD PTR _iI$235725[ebp]
	and	ecx, 1
	je	SHORT $LN10@DoPlaceNat

; 2120 : 						{
; 2121 : 							pAdjacentPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pAdjacentPlot$235729[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2122 : 						}
; 2123 : 						else

	jmp	SHORT $LN11@DoPlaceNat
$LN10@DoPlaceNat:

; 2124 : 						{
; 2125 : 							pAdjacentPlot->setPlotType(PLOT_HILLS);

	push	1
	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _pAdjacentPlot$235729[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2126 : 							pAdjacentPlot->setTerrainType((TerrainTypes)(GC.getLAND_TERRAIN()));

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8388
	mov	DWORD PTR $T240424[ebp], edx
	push	1
	push	1
	mov	eax, DWORD PTR $T240424[ebp]
	push	eax
	mov	ecx, DWORD PTR _pAdjacentPlot$235729[ebp]
	call	?setTerrainType@CvPlot@@QAEXW4TerrainTypes@@_N1@Z ; CvPlot::setTerrainType
$LN11@DoPlaceNat:

; 2127 : 						}
; 2128 : 					}
; 2129 : 				}

	jmp	$LN13@DoPlaceNat
$LN12@DoPlaceNat:

; 2130 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2131 : 				pRandPlot->setFeatureType(featureEverest);

	push	-1
	mov	ecx, DWORD PTR _featureEverest$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2132 : 				iNumNaturalWondersToAdd--;

	mov	edx, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	edx, 1
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], edx

; 2133 : 				featureEverest = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureEverest$[ebp], -1

; 2134 : 				continue;

	jmp	$LN69@DoPlaceNat
$LN16@DoPlaceNat:

; 2135 : 			}
; 2136 : 		}
; 2137 : 
; 2138 : 		// randomly pick one of the other three - but not if this is a coastal plot, because they look terrible there
; 2139 : 		if(pRandPlot->isCoastalLand())

	push	-1
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@DoPlaceNat

; 2140 : 		{
; 2141 : 			continue;

	jmp	$LN69@DoPlaceNat
$LN8@DoPlaceNat:

; 2142 : 		}
; 2143 : 
; 2144 : 		int iDice = GC.getGame().getMapRandNum(100, "Natural Wonder");

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240428[ebp], ecx
	push	OFFSET ??_C@_0P@NNBLFEFC@Natural?5Wonder?$AA@
	push	100					; 00000064H
	mov	ecx, DWORD PTR $T240428[ebp]
	call	?getMapRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getMapRandNum
	mov	DWORD PTR _iDice$235736[ebp], eax

; 2145 : 		if(iDice > 66)

	cmp	DWORD PTR _iDice$235736[ebp], 66	; 00000042H
	jle	SHORT $LN7@DoPlaceNat

; 2146 : 		{
; 2147 : 			if(featureCrater != NO_FEATURE)

	cmp	DWORD PTR _featureCrater$[ebp], -1
	je	SHORT $LN6@DoPlaceNat

; 2148 : 			{
; 2149 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2150 : 				pRandPlot->setFeatureType(featureCrater);

	push	-1
	mov	edx, DWORD PTR _featureCrater$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2151 : 				iNumNaturalWondersToAdd--;

	mov	eax, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], eax

; 2152 : 				featureCrater = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureCrater$[ebp], -1

; 2153 : 				continue;

	jmp	$LN69@DoPlaceNat
$LN6@DoPlaceNat:

; 2154 : 			}
; 2155 : 		}

	jmp	SHORT $LN5@DoPlaceNat
$LN7@DoPlaceNat:

; 2156 : 		else if(iDice > 25)

	cmp	DWORD PTR _iDice$235736[ebp], 25	; 00000019H
	jle	SHORT $LN4@DoPlaceNat

; 2157 : 		{
; 2158 : 			if(featureFuji != NO_FEATURE)

	cmp	DWORD PTR _featureFuji$[ebp], -1
	je	SHORT $LN3@DoPlaceNat

; 2159 : 			{
; 2160 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2161 : 				pRandPlot->setFeatureType(featureFuji);

	push	-1
	mov	ecx, DWORD PTR _featureFuji$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2162 : 				iNumNaturalWondersToAdd--;

	mov	edx, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	edx, 1
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], edx

; 2163 : 				featureFuji = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureFuji$[ebp], -1

; 2164 : 				continue;

	jmp	$LN69@DoPlaceNat
$LN3@DoPlaceNat:

; 2165 : 			}
; 2166 : 		}
; 2167 : 		else

	jmp	SHORT $LN5@DoPlaceNat
$LN4@DoPlaceNat:

; 2168 : 		{
; 2169 : 			if(featureMesa != NO_FEATURE)

	cmp	DWORD PTR _featureMesa$[ebp], -1
	je	SHORT $LN5@DoPlaceNat

; 2170 : 			{
; 2171 : 				pRandPlot->setPlotType(PLOT_MOUNTAIN);

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setPlotType@CvPlot@@QAEXW4PlotTypes@@_N11@Z ; CvPlot::setPlotType

; 2172 : 				pRandPlot->setFeatureType(featureMesa);

	push	-1
	mov	eax, DWORD PTR _featureMesa$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pRandPlot$[ebp]
	call	?setFeatureType@CvPlot@@QAEXW4FeatureTypes@@H@Z ; CvPlot::setFeatureType

; 2173 : 				iNumNaturalWondersToAdd--;

	mov	ecx, DWORD PTR _iNumNaturalWondersToAdd$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iNumNaturalWondersToAdd$[ebp], ecx

; 2174 : 				featureMesa = NO_FEATURE;	// Prevent this one from being placed again

	mov	DWORD PTR _featureMesa$[ebp], -1

; 2175 : 				continue;

	jmp	$LN69@DoPlaceNat
$LN5@DoPlaceNat:

; 2176 : 			}
; 2177 : 		}

	jmp	$LN69@DoPlaceNat
$LN95@DoPlaceNat:

; 2178 : 	}
; 2179 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DoPlaceNaturalWonders@CvMap@@QAEXXZ ENDP		; CvMap::DoPlaceNaturalWonders
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
_TEXT	ENDS
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
tv198 = -100						; size = 4
tv213 = -96						; size = 4
tv168 = -92						; size = 4
tv151 = -88						; size = 4
tv155 = -84						; size = 4
$T240680 = -80						; size = 4
$T240635 = -76						; size = 4
$T240622 = -72						; size = 4
$T240618 = -68						; size = 4
$T240604 = -64						; size = 4
$T240600 = -57						; size = 1
$T240589 = -56						; size = 4
$T240585 = -49						; size = 1
_iMapY$240644 = -48					; size = 4
_iMapX$240643 = -44					; size = 4
$T240578 = -40						; size = 4
$T240554 = -36						; size = 4
$T240517 = -32						; size = 4
$T240505 = -28						; size = 4
$T240501 = -21						; size = 1
$T240490 = -20						; size = 4
$T240486 = -13						; size = 1
_iMapY$240526 = -12					; size = 4
_iMapX$240525 = -8					; size = 4
$T240479 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 194  : 	if(eDirection == NO_DIRECTION)

	cmp	DWORD PTR _eDirection$[ebp], -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240479[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN7@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN8@plotDirect
$LN7@plotDirect:
	mov	DWORD PTR $T240554[ebp], 0
	jmp	$LN9@plotDirect
$LN8@plotDirect:
	mov	ecx, DWORD PTR $T240479[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T240486[ebp], dl
	mov	eax, DWORD PTR $T240479[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240490[ebp], ecx
	movzx	edx, BYTE PTR $T240486[ebp]
	test	edx, edx
	je	SHORT $LN20@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN19@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T240490[ebp]
	add	edx, DWORD PTR $T240490[ebp]
	mov	DWORD PTR _iMapX$240525[ebp], edx
	jmp	SHORT $LN21@plotDirect
	jmp	SHORT $LN20@plotDirect
$LN19@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T240490[ebp]
	jl	SHORT $LN20@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T240490[ebp]
	mov	DWORD PTR _iMapX$240525[ebp], edx
	jmp	SHORT $LN21@plotDirect
$LN20@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$240525[ebp], ecx
$LN21@plotDirect:
	mov	edx, DWORD PTR $T240479[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T240501[ebp], al
	mov	ecx, DWORD PTR $T240479[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T240505[ebp], edx
	movzx	eax, BYTE PTR $T240501[ebp]
	test	eax, eax
	je	SHORT $LN30@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN29@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240505[ebp]
	add	edx, DWORD PTR $T240505[ebp]
	mov	DWORD PTR _iMapY$240526[ebp], edx
	jmp	SHORT $LN31@plotDirect
	jmp	SHORT $LN30@plotDirect
$LN29@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T240505[ebp]
	jl	SHORT $LN30@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240505[ebp]
	mov	DWORD PTR _iMapY$240526[ebp], edx
	jmp	SHORT $LN31@plotDirect
$LN30@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$240526[ebp], edx
$LN31@plotDirect:
	mov	eax, DWORD PTR _iMapY$240526[ebp]
	push	eax
	mov	ecx, DWORD PTR _iMapX$240525[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T240479[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN11@plotDirect
	mov	edx, DWORD PTR $T240479[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T240517[ebp], eax
	mov	ecx, DWORD PTR _iMapY$240526[ebp]
	imul	ecx, DWORD PTR $T240517[ebp]
	add	ecx, DWORD PTR _iMapX$240525[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR $T240479[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR tv155[ebp], ecx
	jmp	SHORT $LN12@plotDirect
$LN11@plotDirect:
	mov	DWORD PTR tv155[ebp], 0
$LN12@plotDirect:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR $T240554[ebp], eax
$LN9@plotDirect:
	mov	eax, DWORD PTR $T240554[ebp]
	jmp	$LN3@plotDirect

; 197  : 	}
; 198  : 	else

	jmp	$LN3@plotDirect
$LN2@plotDirect:

; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN39@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv151[ebp], ecx
	jmp	SHORT $LN37@plotDirect
$LN39@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv151[ebp], eax
$LN37@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	sub	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	eax, DWORD PTR _eDirection$[ebp]
	mov	ecx, DWORD PTR _iX$[ebp]
	add	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[eax*4+112]
	mov	DWORD PTR _iX$[ebp], ecx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	mov	edx, DWORD PTR _eDirection$[ebp]
	mov	eax, DWORD PTR _iY$[ebp]
	add	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A[edx*4+136]
	mov	DWORD PTR _iY$[ebp], eax

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN47@plotDirect
	mov	ecx, DWORD PTR _iY$[ebp]
	sar	ecx, 1
	mov	DWORD PTR tv168[ebp], ecx
	jmp	SHORT $LN45@plotDirect
$LN47@plotDirect:
	mov	eax, DWORD PTR _iY$[ebp]
	sub	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR tv168[ebp], eax
$LN45@plotDirect:
	mov	edx, DWORD PTR _iX$[ebp]
	add	edx, DWORD PTR tv168[ebp]
	mov	DWORD PTR _iX$[ebp], edx

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240578[ebp], eax
	cmp	DWORD PTR _iX$[ebp], -2147483647	; 80000001H
	je	SHORT $LN51@plotDirect
	cmp	DWORD PTR _iY$[ebp], -2147483647	; 80000001H
	jne	SHORT $LN52@plotDirect
$LN51@plotDirect:
	mov	DWORD PTR $T240680[ebp], 0
	jmp	$LN53@plotDirect
$LN52@plotDirect:
	mov	ecx, DWORD PTR $T240578[ebp]
	mov	dl, BYTE PTR [ecx+4056]
	mov	BYTE PTR $T240585[ebp], dl
	mov	eax, DWORD PTR $T240578[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240589[ebp], ecx
	movzx	edx, BYTE PTR $T240585[ebp]
	test	edx, edx
	je	SHORT $LN64@plotDirect
	cmp	DWORD PTR _iX$[ebp], 0
	jge	SHORT $LN63@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T240589[ebp]
	add	edx, DWORD PTR $T240589[ebp]
	mov	DWORD PTR _iMapX$240643[ebp], edx
	jmp	SHORT $LN65@plotDirect
	jmp	SHORT $LN64@plotDirect
$LN63@plotDirect:
	mov	eax, DWORD PTR _iX$[ebp]
	cmp	eax, DWORD PTR $T240589[ebp]
	jl	SHORT $LN64@plotDirect
	mov	eax, DWORD PTR _iX$[ebp]
	cdq
	idiv	DWORD PTR $T240589[ebp]
	mov	DWORD PTR _iMapX$240643[ebp], edx
	jmp	SHORT $LN65@plotDirect
$LN64@plotDirect:
	mov	ecx, DWORD PTR _iX$[ebp]
	mov	DWORD PTR _iMapX$240643[ebp], ecx
$LN65@plotDirect:
	mov	edx, DWORD PTR $T240578[ebp]
	mov	al, BYTE PTR [edx+4057]
	mov	BYTE PTR $T240600[ebp], al
	mov	ecx, DWORD PTR $T240578[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T240604[ebp], edx
	movzx	eax, BYTE PTR $T240600[ebp]
	test	eax, eax
	je	SHORT $LN74@plotDirect
	cmp	DWORD PTR _iY$[ebp], 0
	jge	SHORT $LN73@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240604[ebp]
	add	edx, DWORD PTR $T240604[ebp]
	mov	DWORD PTR _iMapY$240644[ebp], edx
	jmp	SHORT $LN75@plotDirect
	jmp	SHORT $LN74@plotDirect
$LN73@plotDirect:
	mov	ecx, DWORD PTR _iY$[ebp]
	cmp	ecx, DWORD PTR $T240604[ebp]
	jl	SHORT $LN74@plotDirect
	mov	eax, DWORD PTR _iY$[ebp]
	cdq
	idiv	DWORD PTR $T240604[ebp]
	mov	DWORD PTR _iMapY$240644[ebp], edx
	jmp	SHORT $LN75@plotDirect
$LN74@plotDirect:
	mov	edx, DWORD PTR _iY$[ebp]
	mov	DWORD PTR _iMapY$240644[ebp], edx
$LN75@plotDirect:
	cmp	DWORD PTR _iMapX$240643[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T240578[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240618[ebp], ecx
	mov	edx, DWORD PTR _iMapX$240643[ebp]
	cmp	edx, DWORD PTR $T240618[ebp]
	jge	SHORT $LN79@plotDirect
	cmp	DWORD PTR _iMapY$240644[ebp], 0
	jl	SHORT $LN79@plotDirect
	mov	eax, DWORD PTR $T240578[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T240622[ebp], ecx
	mov	edx, DWORD PTR _iMapY$240644[ebp]
	cmp	edx, DWORD PTR $T240622[ebp]
	jge	SHORT $LN79@plotDirect
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN77@plotDirect
$LN79@plotDirect:
	mov	DWORD PTR tv213[ebp], 0
$LN77@plotDirect:
	cmp	DWORD PTR tv213[ebp], 0
	je	SHORT $LN55@plotDirect
	mov	eax, DWORD PTR $T240578[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T240635[ebp], ecx
	mov	edx, DWORD PTR _iMapY$240644[ebp]
	imul	edx, DWORD PTR $T240635[ebp]
	add	edx, DWORD PTR _iMapX$240643[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR $T240578[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR tv198[ebp], edx
	jmp	SHORT $LN56@plotDirect
$LN55@plotDirect:
	mov	DWORD PTR tv198[ebp], 0
$LN56@plotDirect:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR $T240680[ebp], ecx
$LN53@plotDirect:
	mov	eax, DWORD PTR $T240680[ebp]
$LN3@plotDirect:

; 209  : 	}
; 210  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z	; CvMap::getLandmass
PUBLIC	?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z	; CvMap::nextLandmass
PUBLIC	?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z	; CvMap::firstLandmass
PUBLIC	?DefaultContinentStamper@CvMap@@QAEXXZ		; CvMap::DefaultContinentStamper
EXTRN	?SetContinentType@CvPlot@@QAEXD@Z:PROC		; CvPlot::SetContinentType
EXTRN	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z:PROC	; shuffleArray
EXTRN	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ:PROC	; CvGame::getMapRand
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.cpp
;	COMDAT ?DefaultContinentStamper@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -248						; size = 4
$T240766 = -244						; size = 4
$T240759 = -240						; size = 4
$T240686 = -164						; size = 4
_pLoopPlot$235803 = -160				; size = 4
_pLandmass$235804 = -156				; size = 4
_iI$235799 = -152					; size = 4
_iPlotDistance$235797 = -148				; size = 4
_i$235793 = -144					; size = 4
_iBestPlotDistance$235792 = -140			; size = 4
_iX$235788 = -136					; size = 4
_iY$235789 = -132					; size = 4
_pLandmass$235784 = -128				; size = 4
_i$235780 = -124					; size = 4
_i$235775 = -120					; size = 4
_i$235771 = -116					; size = 4
_iloop$235767 = -112					; size = 4
_iNumTiles$235762 = -108				; size = 4
_iBestContinent$235761 = -104				; size = 4
_iNumLargeContinents$ = -100				; size = 4
_iLargeContinentsX$ = -96				; size = 16
_iLargeContinentsSize$ = -80				; size = 16
_iMinimumThresholdToBeAContinentIMHO$ = -64		; size = 4
_pLoopMass$ = -60					; size = 4
_iLargeContinentsY$ = -56				; size = 16
_iNumContinentTypes$ = -40				; size = 4
_iLargeContinentsID$ = -36				; size = 16
_iLargeContinentsArtStyle$ = -20			; size = 16
_iLoop$ = -4						; size = 4
?DefaultContinentStamper@CvMap@@QAEXXZ PROC		; CvMap::DefaultContinentStamper, COMDAT
; _this$ = ecx

; 2183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	DWORD PTR _this$[ebp], ecx

; 2184 : 	const int iNumContinentTypes = 4;

	mov	DWORD PTR _iNumContinentTypes$[ebp], 4

; 2185 : 	const int iMinimumThresholdToBeAContinentIMHO = 10;

	mov	DWORD PTR _iMinimumThresholdToBeAContinentIMHO$[ebp], 10 ; 0000000aH

; 2186 : 
; 2187 : 	int iNumLargeContinents = 0;

	mov	DWORD PTR _iNumLargeContinents$[ebp], 0

; 2188 : 	int iLargeContinentsID[iNumContinentTypes] = {-1,-1,-1,-1};

	mov	DWORD PTR _iLargeContinentsID$[ebp], -1
	mov	DWORD PTR _iLargeContinentsID$[ebp+4], -1
	mov	DWORD PTR _iLargeContinentsID$[ebp+8], -1
	mov	DWORD PTR _iLargeContinentsID$[ebp+12], -1

; 2189 : 	int iLargeContinentsSize[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsSize$[ebp], 0
	mov	DWORD PTR _iLargeContinentsSize$[ebp+4], 0
	mov	DWORD PTR _iLargeContinentsSize$[ebp+8], 0
	mov	DWORD PTR _iLargeContinentsSize$[ebp+12], 0

; 2190 : 	int iLargeContinentsArtStyle[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsArtStyle$[ebp], 0
	mov	DWORD PTR _iLargeContinentsArtStyle$[ebp+4], 0
	mov	DWORD PTR _iLargeContinentsArtStyle$[ebp+8], 0
	mov	DWORD PTR _iLargeContinentsArtStyle$[ebp+12], 0

; 2191 : 	int iLargeContinentsX[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsX$[ebp], 0
	mov	DWORD PTR _iLargeContinentsX$[ebp+4], 0
	mov	DWORD PTR _iLargeContinentsX$[ebp+8], 0
	mov	DWORD PTR _iLargeContinentsX$[ebp+12], 0

; 2192 : 	int iLargeContinentsY[iNumContinentTypes] = {0,0,0,0};

	mov	DWORD PTR _iLargeContinentsY$[ebp], 0
	mov	DWORD PTR _iLargeContinentsY$[ebp+4], 0
	mov	DWORD PTR _iLargeContinentsY$[ebp+8], 0
	mov	DWORD PTR _iLargeContinentsY$[ebp+12], 0

; 2193 : 
; 2194 : 	recalculateLandmasses();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?recalculateLandmasses@CvMap@@QAEXXZ	; CvMap::recalculateLandmasses

; 2195 : 
; 2196 : 	CvLandmass* pLoopMass;
; 2197 : 	int iLoop;
; 2198 : 
; 2199 : 	// find the 4 (because that is how many art styles we have) biggest continents - if there aren't 4, oh well
; 2200 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ; CvMap::firstLandmass
	mov	DWORD PTR _pLoopMass$[ebp], eax
	jmp	SHORT $LN34@DefaultCon
$LN33@DefaultCon:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ; CvMap::nextLandmass
	mov	DWORD PTR _pLoopMass$[ebp], eax
$LN34@DefaultCon:
	cmp	DWORD PTR _pLoopMass$[ebp], 0
	je	$LN32@DefaultCon

; 2201 : 	{
; 2202 : 		if(!pLoopMass->isWater())

	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?isWater@CvLandmass@@QBE_NXZ		; CvLandmass::isWater
	movzx	edx, al
	test	edx, edx
	jne	$LN31@DefaultCon

; 2203 : 		{
; 2204 : 			int iBestContinent;
; 2205 : 			int iNumTiles = pLoopMass->getNumTiles();

	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?getNumTiles@CvLandmass@@QBEHXZ		; CvLandmass::getNumTiles
	mov	DWORD PTR _iNumTiles$235762[ebp], eax

; 2206 : 			for(iBestContinent=0; iBestContinent<iNumContinentTypes; iBestContinent++)

	mov	DWORD PTR _iBestContinent$235761[ebp], 0
	jmp	SHORT $LN30@DefaultCon
$LN29@DefaultCon:
	mov	eax, DWORD PTR _iBestContinent$235761[ebp]
	add	eax, 1
	mov	DWORD PTR _iBestContinent$235761[ebp], eax
$LN30@DefaultCon:
	cmp	DWORD PTR _iBestContinent$235761[ebp], 4
	jge	SHORT $LN31@DefaultCon

; 2207 : 			{
; 2208 : 				if(iNumTiles >= iMinimumThresholdToBeAContinentIMHO && iNumTiles > iLargeContinentsSize[iBestContinent])

	cmp	DWORD PTR _iNumTiles$235762[ebp], 10	; 0000000aH
	jl	SHORT $LN27@DefaultCon
	mov	ecx, DWORD PTR _iBestContinent$235761[ebp]
	mov	edx, DWORD PTR _iNumTiles$235762[ebp]
	cmp	edx, DWORD PTR _iLargeContinentsSize$[ebp+ecx*4]
	jle	SHORT $LN27@DefaultCon

; 2209 : 				{
; 2210 : 					// push the rest of the tiles down one and store this
; 2211 : 					for(int iloop=iNumContinentTypes-1; iloop>iBestContinent; iloop--)

	mov	DWORD PTR _iloop$235767[ebp], 3
	jmp	SHORT $LN26@DefaultCon
$LN25@DefaultCon:
	mov	eax, DWORD PTR _iloop$235767[ebp]
	sub	eax, 1
	mov	DWORD PTR _iloop$235767[ebp], eax
$LN26@DefaultCon:
	mov	ecx, DWORD PTR _iloop$235767[ebp]
	cmp	ecx, DWORD PTR _iBestContinent$235761[ebp]
	jle	SHORT $LN24@DefaultCon

; 2212 : 					{
; 2213 : 						iLargeContinentsID[iloop] = iLargeContinentsID[iloop-1];

	mov	edx, DWORD PTR _iloop$235767[ebp]
	mov	eax, DWORD PTR _iloop$235767[ebp]
	mov	ecx, DWORD PTR _iLargeContinentsID$[ebp+eax*4-4]
	mov	DWORD PTR _iLargeContinentsID$[ebp+edx*4], ecx

; 2214 : 						iLargeContinentsSize[iloop] = iLargeContinentsSize[iloop-1];

	mov	edx, DWORD PTR _iloop$235767[ebp]
	mov	eax, DWORD PTR _iloop$235767[ebp]
	mov	ecx, DWORD PTR _iLargeContinentsSize$[ebp+eax*4-4]
	mov	DWORD PTR _iLargeContinentsSize$[ebp+edx*4], ecx

; 2215 : 					}

	jmp	SHORT $LN25@DefaultCon
$LN24@DefaultCon:

; 2216 : 					iLargeContinentsID[iBestContinent] = pLoopMass->GetID();

	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?GetID@CvLandmass@@QBEHXZ		; CvLandmass::GetID
	mov	edx, DWORD PTR _iBestContinent$235761[ebp]
	mov	DWORD PTR _iLargeContinentsID$[ebp+edx*4], eax

; 2217 : 					iLargeContinentsSize[iBestContinent] = iNumTiles;

	mov	eax, DWORD PTR _iBestContinent$235761[ebp]
	mov	ecx, DWORD PTR _iNumTiles$235762[ebp]
	mov	DWORD PTR _iLargeContinentsSize$[ebp+eax*4], ecx

; 2218 : 					break;

	jmp	SHORT $LN31@DefaultCon
$LN27@DefaultCon:

; 2219 : 				}
; 2220 : 			}

	jmp	SHORT $LN29@DefaultCon
$LN31@DefaultCon:

; 2221 : 		}
; 2222 : 	}

	jmp	$LN33@DefaultCon
$LN32@DefaultCon:

; 2223 : 
; 2224 : 	// for each of these large continents give them unique art style (randomly)
; 2225 : 	shuffleArray(iLargeContinentsArtStyle, 4, GC.getGame().getMapRand());

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240686[ebp], edx
	mov	ecx, DWORD PTR $T240686[ebp]
	call	?getMapRand@CvGame@@QAEAAVCvRandom@@XZ	; CvGame::getMapRand
	push	eax
	push	4
	lea	eax, DWORD PTR _iLargeContinentsArtStyle$[ebp]
	push	eax
	call	?shuffleArray@@YAXPAHHAAVCvRandom@@@Z	; shuffleArray
	add	esp, 12					; 0000000cH

; 2226 : 	for(int i=0; i < iNumContinentTypes; i++)

	mov	DWORD PTR _i$235771[ebp], 0
	jmp	SHORT $LN23@DefaultCon
$LN22@DefaultCon:
	mov	ecx, DWORD PTR _i$235771[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$235771[ebp], ecx
$LN23@DefaultCon:
	cmp	DWORD PTR _i$235771[ebp], 4
	jge	SHORT $LN21@DefaultCon

; 2227 : 	{
; 2228 : 		iLargeContinentsArtStyle[i]++;

	mov	edx, DWORD PTR _i$235771[ebp]
	mov	eax, DWORD PTR _iLargeContinentsArtStyle$[ebp+edx*4]
	add	eax, 1
	mov	ecx, DWORD PTR _i$235771[ebp]
	mov	DWORD PTR _iLargeContinentsArtStyle$[ebp+ecx*4], eax

; 2229 : 	}

	jmp	SHORT $LN22@DefaultCon
$LN21@DefaultCon:

; 2230 : 
; 2231 : 	for(int i=0; i < iNumContinentTypes; i++)

	mov	DWORD PTR _i$235775[ebp], 0
	jmp	SHORT $LN20@DefaultCon
$LN19@DefaultCon:
	mov	edx, DWORD PTR _i$235775[ebp]
	add	edx, 1
	mov	DWORD PTR _i$235775[ebp], edx
$LN20@DefaultCon:
	cmp	DWORD PTR _i$235775[ebp], 4
	jge	SHORT $LN18@DefaultCon

; 2232 : 	{
; 2233 : 		if(iLargeContinentsID[i] != -1)

	mov	eax, DWORD PTR _i$235775[ebp]
	cmp	DWORD PTR _iLargeContinentsID$[ebp+eax*4], -1
	je	SHORT $LN17@DefaultCon

; 2234 : 			iNumLargeContinents++;

	mov	ecx, DWORD PTR _iNumLargeContinents$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iNumLargeContinents$[ebp], ecx
$LN17@DefaultCon:

; 2235 : 	}

	jmp	SHORT $LN19@DefaultCon
$LN18@DefaultCon:

; 2236 : 
; 2237 : 	for(int i=0; i < iNumLargeContinents; i++)

	mov	DWORD PTR _i$235780[ebp], 0
	jmp	SHORT $LN16@DefaultCon
$LN15@DefaultCon:
	mov	edx, DWORD PTR _i$235780[ebp]
	add	edx, 1
	mov	DWORD PTR _i$235780[ebp], edx
$LN16@DefaultCon:
	mov	eax, DWORD PTR _i$235780[ebp]
	cmp	eax, DWORD PTR _iNumLargeContinents$[ebp]
	jge	SHORT $LN14@DefaultCon

; 2238 : 	{
; 2239 : 		CvLandmass* pLandmass = getLandmass(iLargeContinentsID[i]);

	mov	ecx, DWORD PTR _i$235780[ebp]
	mov	edx, DWORD PTR _iLargeContinentsID$[ebp+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	DWORD PTR _pLandmass$235784[ebp], eax

; 2240 : 		iLargeContinentsX[i] = pLandmass->GetCentroidX();

	mov	ecx, DWORD PTR _pLandmass$235784[ebp]
	call	?GetCentroidX@CvLandmass@@QAEHXZ	; CvLandmass::GetCentroidX
	mov	ecx, DWORD PTR _i$235780[ebp]
	mov	DWORD PTR _iLargeContinentsX$[ebp+ecx*4], eax

; 2241 : 		iLargeContinentsY[i] = pLandmass->GetCentroidY();

	mov	ecx, DWORD PTR _pLandmass$235784[ebp]
	call	?GetCentroidY@CvLandmass@@QAEHXZ	; CvLandmass::GetCentroidY
	mov	edx, DWORD PTR _i$235780[ebp]
	mov	DWORD PTR _iLargeContinentsY$[ebp+edx*4], eax

; 2242 : 	}

	jmp	SHORT $LN15@DefaultCon
$LN14@DefaultCon:

; 2243 : 
; 2244 : 	// for all landmasses in the game
; 2245 : 	for(pLoopMass = firstLandmass(&iLoop); pLoopMass != NULL; pLoopMass = nextLandmass(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ; CvMap::firstLandmass
	mov	DWORD PTR _pLoopMass$[ebp], eax
	jmp	SHORT $LN13@DefaultCon
$LN12@DefaultCon:
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ; CvMap::nextLandmass
	mov	DWORD PTR _pLoopMass$[ebp], eax
$LN13@DefaultCon:
	cmp	DWORD PTR _pLoopMass$[ebp], 0
	je	$LN11@DefaultCon

; 2246 : 	{
; 2247 : 		int iX = pLoopMass->GetCentroidX();

	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?GetCentroidX@CvLandmass@@QAEHXZ	; CvLandmass::GetCentroidX
	mov	DWORD PTR _iX$235788[ebp], eax

; 2248 : 		int iY = pLoopMass->GetCentroidY();

	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?GetCentroidY@CvLandmass@@QAEHXZ	; CvLandmass::GetCentroidY
	mov	DWORD PTR _iY$235789[ebp], eax

; 2249 : 		// if water continent type = 0
; 2250 : 		if(pLoopMass->isWater())

	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?isWater@CvLandmass@@QBE_NXZ		; CvLandmass::isWater
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@DefaultCon

; 2251 : 		{
; 2252 : 			pLoopMass->SetContinentType(0);

	push	0
	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?SetContinentType@CvLandmass@@QAEXD@Z	; CvLandmass::SetContinentType

; 2253 : 		}
; 2254 : 		else // if land

	jmp	$LN9@DefaultCon
$LN10@DefaultCon:

; 2255 : 		{
; 2256 : 			// continent type = continent type of the closest of the "big four"
; 2257 : 			int iBestPlotDistance = 999999;

	mov	DWORD PTR _iBestPlotDistance$235792[ebp], 999999 ; 000f423fH

; 2258 : 			for(int i=0; i < iNumLargeContinents; i++)

	mov	DWORD PTR _i$235793[ebp], 0
	jmp	SHORT $LN8@DefaultCon
$LN7@DefaultCon:
	mov	eax, DWORD PTR _i$235793[ebp]
	add	eax, 1
	mov	DWORD PTR _i$235793[ebp], eax
$LN8@DefaultCon:
	mov	ecx, DWORD PTR _i$235793[ebp]
	cmp	ecx, DWORD PTR _iNumLargeContinents$[ebp]
	jge	SHORT $LN9@DefaultCon

; 2259 : 			{
; 2260 : 				int iPlotDistance = plotDistance(iX, iY, iLargeContinentsX[i], iLargeContinentsY[i]);

	mov	edx, DWORD PTR _i$235793[ebp]
	mov	eax, DWORD PTR _iLargeContinentsY$[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _i$235793[ebp]
	mov	edx, DWORD PTR _iLargeContinentsX$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _iY$235789[ebp]
	push	eax
	mov	ecx, DWORD PTR _iX$235788[ebp]
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iPlotDistance$235797[ebp], eax

; 2261 : 				if(iPlotDistance < iBestPlotDistance)

	mov	edx, DWORD PTR _iPlotDistance$235797[ebp]
	cmp	edx, DWORD PTR _iBestPlotDistance$235792[ebp]
	jge	SHORT $LN5@DefaultCon

; 2262 : 				{
; 2263 : 					iBestPlotDistance = iPlotDistance;

	mov	eax, DWORD PTR _iPlotDistance$235797[ebp]
	mov	DWORD PTR _iBestPlotDistance$235792[ebp], eax

; 2264 : 					pLoopMass->SetContinentType(iLargeContinentsArtStyle[i]);

	mov	ecx, DWORD PTR _i$235793[ebp]
	movzx	edx, BYTE PTR _iLargeContinentsArtStyle$[ebp+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _pLoopMass$[ebp]
	call	?SetContinentType@CvLandmass@@QAEXD@Z	; CvLandmass::SetContinentType
$LN5@DefaultCon:

; 2265 : 				}
; 2266 : 			}

	jmp	SHORT $LN7@DefaultCon
$LN9@DefaultCon:

; 2267 : 		}
; 2268 : 	}

	jmp	$LN12@DefaultCon
$LN11@DefaultCon:

; 2269 : 
; 2270 : 	// now stamp all plots with the relevant data
; 2271 : #ifdef AUI_WARNING_FIXES
; 2272 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2273 : #else
; 2274 : 	for(int iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$235799[ebp], 0
	jmp	SHORT $LN4@DefaultCon
$LN3@DefaultCon:
	mov	eax, DWORD PTR _iI$235799[ebp]
	add	eax, 1
	mov	DWORD PTR _iI$235799[ebp], eax
$LN4@DefaultCon:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4028]
	mov	DWORD PTR $T240759[ebp], edx
	mov	eax, DWORD PTR _iI$235799[ebp]
	cmp	eax, DWORD PTR $T240759[ebp]
	jge	SHORT $LN35@DefaultCon

; 2275 : #endif
; 2276 : 	{
; 2277 : 		CvPlot* pLoopPlot = plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR _iI$235799[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	mov	DWORD PTR _pLoopPlot$235803[ebp], ecx

; 2278 : 		CvLandmass* pLandmass = getLandmass(pLoopPlot->getLandmass());

	mov	eax, DWORD PTR _pLoopPlot$235803[ebp]
	mov	ecx, DWORD PTR [eax+360]
	mov	DWORD PTR $T240766[ebp], ecx
	mov	edx, DWORD PTR $T240766[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ; CvMap::getLandmass
	mov	DWORD PTR _pLandmass$235804[ebp], eax

; 2279 : 		if(pLandmass != NULL)

	cmp	DWORD PTR _pLandmass$235804[ebp], 0
	je	SHORT $LN1@DefaultCon

; 2280 : 		{
; 2281 : 			pLoopPlot->SetContinentType(pLandmass->GetContinentType());

	mov	ecx, DWORD PTR _pLandmass$235804[ebp]
	call	?GetContinentType@CvLandmass@@QBEDXZ	; CvLandmass::GetContinentType
	movzx	eax, al
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$235803[ebp]
	call	?SetContinentType@CvPlot@@QAEXD@Z	; CvPlot::SetContinentType
$LN1@DefaultCon:

; 2282 : 		}

	jmp	$LN3@DefaultCon
$LN35@DefaultCon:

; 2283 : 	}
; 2284 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DefaultContinentStamper@CvMap@@QAEXXZ ENDP		; CvMap::DefaultContinentStamper
_TEXT	ENDS
PUBLIC	?getIndexAfterLastLandmass@CvMap@@QAEHXZ	; CvMap::getIndexAfterLastLandmass
; Function compile flags: /Odtp
;	COMDAT ?getIndexAfterLastLandmass@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getIndexAfterLastLandmass@CvMap@@QAEHXZ PROC		; CvMap::getIndexAfterLastLandmass, COMDAT
; _this$ = ecx

; 2288 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2289 : 	return m_landmasses.GetIndexAfterLast();

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4152]
	add	eax, 1

; 2290 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getIndexAfterLastLandmass@CvMap@@QAEHXZ ENDP		; CvMap::getIndexAfterLastLandmass
_TEXT	ENDS
PUBLIC	?getNumLandmasses@CvMap@@QAEHXZ			; CvMap::getNumLandmasses
; Function compile flags: /Odtp
;	COMDAT ?getNumLandmasses@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T240777 = -4						; size = 4
?getNumLandmasses@CvMap@@QAEHXZ PROC			; CvMap::getNumLandmasses, COMDAT
; _this$ = ecx

; 2295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2296 : 	return m_landmasses.GetCount();

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4140				; 0000102cH
	mov	DWORD PTR $T240777[ebp], eax
	mov	ecx, DWORD PTR $T240777[ebp]
	mov	edx, DWORD PTR $T240777[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	add	eax, 1

; 2297 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumLandmasses@CvMap@@QAEHXZ ENDP			; CvMap::getNumLandmasses
_TEXT	ENDS
PUBLIC	?getNumLandLandmasses@CvMap@@QAEHXZ		; CvMap::getNumLandLandmasses
; Function compile flags: /Odtp
;	COMDAT ?getNumLandLandmasses@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T240787 = -20						; size = 4
$T240783 = -16						; size = 4
_pLoopLandmass$ = -12					; size = 4
_iNumLandLandmasses$ = -8				; size = 4
_iLoop$ = -4						; size = 4
?getNumLandLandmasses@CvMap@@QAEHXZ PROC		; CvMap::getNumLandLandmasses, COMDAT
; _this$ = ecx

; 2302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 2303 : 	CvLandmass* pLoopLandmass;
; 2304 : 	int iNumLandLandmasses;
; 2305 : 	int iLoop;
; 2306 : 
; 2307 : 	iNumLandLandmasses = 0;

	mov	DWORD PTR _iNumLandLandmasses$[ebp], 0

; 2308 : 
; 2309 : 	for(pLoopLandmass = GC.getMap().firstLandmass(&iLoop); pLoopLandmass != NULL; pLoopLandmass = GC.getMap().nextLandmass(&iLoop))

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240783[ebp], eax
	push	0
	lea	ecx, DWORD PTR _iLoop$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T240783[ebp]
	call	?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ; CvMap::firstLandmass
	mov	DWORD PTR _pLoopLandmass$[ebp], eax
	jmp	SHORT $LN4@getNumLand@2
$LN3@getNumLand@2:
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR $T240787[ebp], edx
	push	0
	lea	eax, DWORD PTR _iLoop$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T240787[ebp]
	call	?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ; CvMap::nextLandmass
	mov	DWORD PTR _pLoopLandmass$[ebp], eax
$LN4@getNumLand@2:
	cmp	DWORD PTR _pLoopLandmass$[ebp], 0
	je	SHORT $LN2@getNumLand@2

; 2310 : 	{
; 2311 : 		if(!(pLoopLandmass->isWater()))

	mov	ecx, DWORD PTR _pLoopLandmass$[ebp]
	call	?isWater@CvLandmass@@QBE_NXZ		; CvLandmass::isWater
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN1@getNumLand@2

; 2312 : 		{
; 2313 : 			iNumLandLandmasses++;

	mov	edx, DWORD PTR _iNumLandLandmasses$[ebp]
	add	edx, 1
	mov	DWORD PTR _iNumLandLandmasses$[ebp], edx
$LN1@getNumLand@2:

; 2314 : 		}
; 2315 : 	}

	jmp	SHORT $LN3@getNumLand@2
$LN2@getNumLand@2:

; 2316 : 
; 2317 : 	return iNumLandLandmasses;

	mov	eax, DWORD PTR _iNumLandLandmasses$[ebp]

; 2318 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumLandLandmasses@CvMap@@QAEHXZ ENDP		; CvMap::getNumLandLandmasses
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z PROC		; CvMap::getLandmass, COMDAT
; _this$ = ecx

; 2323 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2324 : 	return m_landmasses.GetAt(iID);

	mov	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4140]
	mov	edx, DWORD PTR [eax+16]
	call	edx

; 2325 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getLandmass@CvMap@@QAEPAVCvLandmass@@H@Z ENDP		; CvMap::getLandmass
_TEXT	ENDS
PUBLIC	?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ ; FFreeListTrashArray<CvLandmass>::Add
PUBLIC	?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ	; CvMap::addLandmass
; Function compile flags: /Odtp
;	COMDAT ?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ PROC		; CvMap::addLandmass, COMDAT
; _this$ = ecx

; 2330 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2331 : 	return m_landmasses.Add();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ ; FFreeListTrashArray<CvLandmass>::Add

; 2332 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ ENDP		; CvMap::addLandmass
_TEXT	ENDS
PUBLIC	?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z ; FFreeListTrashArray<CvLandmass>::RemoveAt
PUBLIC	?deleteLandmass@CvMap@@QAEXH@Z			; CvMap::deleteLandmass
; Function compile flags: /Odtp
;	COMDAT ?deleteLandmass@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iID$ = 8						; size = 4
?deleteLandmass@CvMap@@QAEXH@Z PROC			; CvMap::deleteLandmass, COMDAT
; _this$ = ecx

; 2337 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2338 : 	m_landmasses.RemoveAt(iID);

	mov	eax, DWORD PTR _iID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z ; FFreeListTrashArray<CvLandmass>::RemoveAt

; 2339 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?deleteLandmass@CvMap@@QAEXH@Z ENDP			; CvMap::deleteLandmass
_TEXT	ENDS
PUBLIC	?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::EndIter
PUBLIC	?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::BeginIter
; Function compile flags: /Odtp
;	COMDAT ?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z PROC	; CvMap::firstLandmass, COMDAT
; _this$ = ecx

; 2344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2345 : 	return !bRev ? m_landmasses.BeginIter(pIterIdx) : m_landmasses.EndIter(pIterIdx);

	movzx	eax, BYTE PTR _bRev$[ebp]
	test	eax, eax
	jne	SHORT $LN3@firstLandm
	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::BeginIter
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@firstLandm
$LN3@firstLandm:
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::EndIter
	mov	DWORD PTR tv82[ebp], eax
$LN4@firstLandm:
	mov	eax, DWORD PTR tv82[ebp]

; 2346 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?firstLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ENDP	; CvMap::firstLandmass
_TEXT	ENDS
PUBLIC	?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::PrevIter
PUBLIC	?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::NextIter
; Function compile flags: /Odtp
;	COMDAT ?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z
_TEXT	SEGMENT
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
_bRev$ = 12						; size = 1
?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z PROC	; CvMap::nextLandmass, COMDAT
; _this$ = ecx

; 2351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 2352 : 	return !bRev ? m_landmasses.NextIter(pIterIdx) : m_landmasses.PrevIter(pIterIdx);

	movzx	eax, BYTE PTR _bRev$[ebp]
	test	eax, eax
	jne	SHORT $LN3@nextLandma
	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::NextIter
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN4@nextLandma
$LN3@nextLandma:
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	call	?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::PrevIter
	mov	DWORD PTR tv82[ebp], eax
$LN4@nextLandma:
	mov	eax, DWORD PTR tv82[ebp]

; 2353 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?nextLandmass@CvMap@@QAEPAVCvLandmass@@PAH_N@Z ENDP	; CvMap::nextLandmass
_TEXT	ENDS
PUBLIC	?calculateLandmasses@CvMap@@QAEXXZ		; CvMap::calculateLandmasses
EXTRN	?setLandmass@CvPlot@@QAEXH@Z:PROC		; CvPlot::setLandmass
; Function compile flags: /Odtp
;	COMDAT ?recalculateLandmasses@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_iI$235847 = -8						; size = 4
_iNumPlots$ = -4					; size = 4
?recalculateLandmasses@CvMap@@QAEXXZ PROC		; CvMap::recalculateLandmasses, COMDAT
; _this$ = ecx

; 2357 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 2358 : #ifdef AUI_WARNING_FIXES
; 2359 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2360 : #else
; 2361 : 	int iNumPlots = numPlots();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iNumPlots$[ebp], ecx

; 2362 : 	for(int iI = 0; iI < iNumPlots; iI++)

	mov	DWORD PTR _iI$235847[ebp], 0
	jmp	SHORT $LN3@recalculat@2
$LN2@recalculat@2:
	mov	edx, DWORD PTR _iI$235847[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$235847[ebp], edx
$LN3@recalculat@2:
	mov	eax, DWORD PTR _iI$235847[ebp]
	cmp	eax, DWORD PTR _iNumPlots$[ebp]
	jge	SHORT $LN1@recalculat@2

; 2363 : #endif
; 2364 : 	{
; 2365 : 		plotByIndexUnchecked(iI)->setLandmass(FFreeList::INVALID_INDEX);

	push	-1
	mov	ecx, DWORD PTR _iI$235847[ebp]
	imul	ecx, 484				; 000001e4H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4068]
	call	?setLandmass@CvPlot@@QAEXH@Z		; CvPlot::setLandmass

; 2366 : 	}

	jmp	SHORT $LN2@recalculat@2
$LN1@recalculat@2:

; 2367 : 
; 2368 : 	m_landmasses.RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4140				; 0000102cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4140]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 2369 : 
; 2370 : 	calculateLandmasses();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?calculateLandmasses@CvMap@@QAEXXZ	; CvMap::calculateLandmasses

; 2371 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?recalculateLandmasses@CvMap@@QAEXXZ ENDP		; CvMap::recalculateLandmasses
_TEXT	ENDS
EXTRN	?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; JoinLandmass
EXTRN	?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; LandmassValid
; Function compile flags: /Odtp
;	COMDAT ?calculateLandmasses@CvMap@@QAEXXZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T240836 = -36						; size = 4
$T240832 = -29						; size = 1
$T240828 = -28						; size = 4
$T240821 = -24						; size = 4
_iI$235858 = -20					; size = 4
_thePathfinder$ = -16					; size = 4
_pLoopPlot$ = -12					; size = 4
_pLandmass$ = -8					; size = 4
_iLandmassID$ = -4					; size = 4
?calculateLandmasses@CvMap@@QAEXXZ PROC			; CvMap::calculateLandmasses, COMDAT
; _this$ = ecx

; 2375 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 2376 : 	CvPlot* pLoopPlot;
; 2377 : 	CvLandmass* pLandmass;
; 2378 : 	int iLandmassID;
; 2379 : 
; 2380 : 	CvAStar& thePathfinder = GC.getAreaFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAreaFinder@CvGlobals@@QAEAAVCvAStar@@XZ ; CvGlobals::getAreaFinder
	mov	DWORD PTR _thePathfinder$[ebp], eax

; 2381 : 
; 2382 : 	// change the area pathfinder to use these funcs instead
; 2383 : 	thePathfinder.SetValidFunc(LandmassValid);

	mov	eax, DWORD PTR _thePathfinder$[ebp]
	mov	DWORD PTR [eax+16], OFFSET ?LandmassValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; LandmassValid

; 2384 : 	thePathfinder.SetNotifyListFunc(JoinLandmass);

	mov	ecx, DWORD PTR _thePathfinder$[ebp]
	mov	DWORD PTR [ecx+24], OFFSET ?JoinLandmass@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinLandmass

; 2385 : 
; 2386 : #ifdef AUI_WARNING_FIXES
; 2387 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2388 : #else
; 2389 : 	for(int iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$235858[ebp], 0
	jmp	SHORT $LN4@calculateL
$LN3@calculateL:
	mov	edx, DWORD PTR _iI$235858[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$235858[ebp], edx
$LN4@calculateL:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR $T240821[ebp], ecx
	mov	edx, DWORD PTR _iI$235858[ebp]
	cmp	edx, DWORD PTR $T240821[ebp]
	jge	$LN2@calculateL

; 2390 : #endif
; 2391 : 	{
; 2392 : 		pLoopPlot = plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR _iI$235858[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR _pLoopPlot$[ebp], eax

; 2393 : 		if(pLoopPlot->getLandmass() == FFreeList::INVALID_INDEX)

	mov	edx, DWORD PTR _pLoopPlot$[ebp]
	mov	eax, DWORD PTR [edx+360]
	mov	DWORD PTR $T240828[ebp], eax
	cmp	DWORD PTR $T240828[ebp], -1
	jne	SHORT $LN1@calculateL

; 2394 : 		{
; 2395 : 			pLandmass = addLandmass();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?addLandmass@CvMap@@QAEPAVCvLandmass@@XZ ; CvMap::addLandmass
	mov	DWORD PTR _pLandmass$[ebp], eax

; 2396 : 			pLandmass->init(pLandmass->GetID(), pLoopPlot->isWater());

	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, BYTE PTR [ecx+5]
	xor	eax, eax
	cmp	edx, 3
	sete	al
	mov	BYTE PTR $T240832[ebp], al
	movzx	ecx, BYTE PTR $T240832[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLandmass$[ebp]
	call	?GetID@CvLandmass@@QBEHXZ		; CvLandmass::GetID
	push	eax
	mov	ecx, DWORD PTR _pLandmass$[ebp]
	call	?init@CvLandmass@@QAEXH_N@Z		; CvLandmass::init

; 2397 : 
; 2398 : 			iLandmassID = pLandmass->GetID();

	mov	ecx, DWORD PTR _pLandmass$[ebp]
	call	?GetID@CvLandmass@@QBEHXZ		; CvLandmass::GetID
	mov	DWORD PTR _iLandmassID$[ebp], eax

; 2399 : 
; 2400 : 			pLoopPlot->setLandmass(iLandmassID);

	mov	edx, DWORD PTR _iLandmassID$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	call	?setLandmass@CvPlot@@QAEXH@Z		; CvPlot::setLandmass

; 2401 : 
; 2402 : 			thePathfinder.GeneratePath(pLoopPlot->getX(), pLoopPlot->getY(), -1, -1, iLandmassID);

	mov	eax, DWORD PTR _pLoopPlot$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR $T240836[ebp], ecx
	push	0
	mov	edx, DWORD PTR _iLandmassID$[ebp]
	push	edx
	push	-1
	push	-1
	mov	eax, DWORD PTR $T240836[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLoopPlot$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _thePathfinder$[ebp]
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
$LN1@calculateL:

; 2403 : 		}
; 2404 : 	}

	jmp	$LN3@calculateL
$LN2@calculateL:

; 2405 : 	thePathfinder.SetValidFunc(AreaValid);

	mov	eax, DWORD PTR _thePathfinder$[ebp]
	mov	DWORD PTR [eax+16], OFFSET ?AreaValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; AreaValid

; 2406 : 	thePathfinder.SetNotifyListFunc(JoinArea);

	mov	ecx, DWORD PTR _thePathfinder$[ebp]
	mov	DWORD PTR [ecx+24], OFFSET ?JoinArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; JoinArea

; 2407 : 
; 2408 : 	// KWG: Rebuild the yields here.  Yes, this is called during the landmass rebuild process if the landmass' 'lake' field changes, but
; 2409 : 	//      there is a problem with that. The yield bonus for a lake is dependent on the proximity to a plot that is a lake, and not the general landmass
; 2410 : 	//		'lake' flag.  During recalculation, a neighboring plot's 'lake' flag may not be set yet because it is in a landmass that has yet to be calculated
; 2411 : 	//		resulting in the wrong yield being applied to a plot.
; 2412 : 	updateYield();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?updateYield@CvMap@@QAEXXZ		; CvMap::updateYield

; 2413 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?calculateLandmasses@CvMap@@QAEXXZ ENDP			; CvMap::calculateLandmasses
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
PUBLIC	?Validate@CvMap@@QAEHXZ				; CvMap::Validate
EXTRN	?Validate@CvPlot@@QAEHAAVCvMap@@@Z:PROC		; CvPlot::Validate
EXTRN	?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z:PROC ; CvGameTrade::ClearAllCityTradeRoutes
EXTRN	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ:PROC ; CvGame::GetGameTrade
; Function compile flags: /Odtp
;	COMDAT ?Validate@CvMap@@QAEHXZ
_TEXT	SEGMENT
tv225 = -148						; size = 4
tv240 = -144						; size = 4
tv182 = -140						; size = 4
_this$ = -136						; size = 4
$T241051 = -132						; size = 4
$T241042 = -124						; size = 4
$T241041 = -120						; size = 4
$T240996 = -116						; size = 4
$T240983 = -112						; size = 4
$T240979 = -108						; size = 4
$T240965 = -104						; size = 4
$T240961 = -97						; size = 1
$T240950 = -96						; size = 4
$T240946 = -89						; size = 1
_iMapY$241040 = -88					; size = 4
_iMapX$241039 = -84					; size = 4
$T240934 = -76						; size = 4
$T240933 = -72						; size = 4
$T240896 = -68						; size = 4
$T240884 = -64						; size = 4
$T240880 = -57						; size = 1
$T240869 = -56						; size = 4
$T240865 = -49						; size = 1
_iMapY$240932 = -48					; size = 4
_iMapX$240931 = -44					; size = 4
$T240855 = -40						; size = 4
$T240851 = -36						; size = 4
_pLoopPlot$235885 = -32					; size = 4
_iI$235881 = -28					; size = 4
_pOriginPlot$235874 = -24				; size = 4
_pDestPlot$235877 = -20					; size = 4
_connection$235872 = -16				; size = 4
_ui$235868 = -12					; size = 4
_iErrors$ = -8						; size = 4
_pGameTrade$ = -4					; size = 4
?Validate@CvMap@@QAEHXZ PROC				; CvMap::Validate, COMDAT
; _this$ = ecx

; 2417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	DWORD PTR _this$[ebp], ecx

; 2418 : 	//SS: Patch Trade Connections.
; 2419 : 	//Just after the BNW Launch trade connection data could be corrupted due to razing cities.
; 2420 : 	//This function is used because it's called immediately after serialization.
; 2421 : 	//Iterate through all trade connections.
; 2422 : 	//Clear the connection if the source or dest city does not exist.
; 2423 : 	CvGameTrade* pGameTrade = GC.getGame().GetGameTrade();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	DWORD PTR $T240851[ebp], eax
	mov	ecx, DWORD PTR $T240851[ebp]
	call	?GetGameTrade@CvGame@@QAEPAVCvGameTrade@@XZ ; CvGame::GetGameTrade
	mov	DWORD PTR _pGameTrade$[ebp], eax

; 2424 : 	if(pGameTrade)

	cmp	DWORD PTR _pGameTrade$[ebp], 0
	je	$LN12@Validate

; 2425 : 	{
; 2426 : 		for (uint ui = 0; ui < pGameTrade->m_aTradeConnections.size(); ui++)

	mov	DWORD PTR _ui$235868[ebp], 0
	jmp	SHORT $LN11@Validate
$LN10@Validate:
	mov	ecx, DWORD PTR _ui$235868[ebp]
	add	ecx, 1
	mov	DWORD PTR _ui$235868[ebp], ecx
$LN11@Validate:
	mov	edx, DWORD PTR _pGameTrade$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T240855[ebp], eax
	mov	ecx, DWORD PTR _ui$235868[ebp]
	cmp	ecx, DWORD PTR $T240855[ebp]
	jae	$LN12@Validate

; 2427 : 		{
; 2428 : 			TradeConnection& connection = pGameTrade->m_aTradeConnections[ui];

	mov	edx, DWORD PTR _ui$235868[ebp]
	imul	edx, 444				; 000001bcH
	mov	eax, DWORD PTR _pGameTrade$[ebp]
	add	edx, DWORD PTR [eax]
	mov	DWORD PTR _connection$235872[ebp], edx

; 2429 : 			if(connection.m_iID > -1)

	mov	ecx, DWORD PTR _connection$235872[ebp]
	cmp	DWORD PTR [ecx], -1
	jle	$LN8@Validate

; 2430 : 			{
; 2431 : 				CvPlot* pOriginPlot = plot(connection.m_iOriginX, connection.m_iOriginY);

	mov	edx, DWORD PTR _connection$235872[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR $T240934[ebp], eax
	mov	ecx, DWORD PTR _connection$235872[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T240933[ebp], edx
	cmp	DWORD PTR $T240933[ebp], -2147483647	; 80000001H
	je	SHORT $LN21@Validate
	cmp	DWORD PTR $T240934[ebp], -2147483647	; 80000001H
	jne	SHORT $LN22@Validate
$LN21@Validate:
	mov	DWORD PTR _pOriginPlot$235874[ebp], 0
	jmp	$LN23@Validate
$LN22@Validate:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4056]
	mov	BYTE PTR $T240865[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4020]
	mov	DWORD PTR $T240869[ebp], eax
	movzx	ecx, BYTE PTR $T240865[ebp]
	test	ecx, ecx
	je	SHORT $LN34@Validate
	cmp	DWORD PTR $T240933[ebp], 0
	jge	SHORT $LN33@Validate
	mov	eax, DWORD PTR $T240933[ebp]
	cdq
	idiv	DWORD PTR $T240869[ebp]
	add	edx, DWORD PTR $T240869[ebp]
	mov	DWORD PTR _iMapX$240931[ebp], edx
	jmp	SHORT $LN35@Validate
	jmp	SHORT $LN34@Validate
$LN33@Validate:
	mov	edx, DWORD PTR $T240933[ebp]
	cmp	edx, DWORD PTR $T240869[ebp]
	jl	SHORT $LN34@Validate
	mov	eax, DWORD PTR $T240933[ebp]
	cdq
	idiv	DWORD PTR $T240869[ebp]
	mov	DWORD PTR _iMapX$240931[ebp], edx
	jmp	SHORT $LN35@Validate
$LN34@Validate:
	mov	eax, DWORD PTR $T240933[ebp]
	mov	DWORD PTR _iMapX$240931[ebp], eax
$LN35@Validate:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR [ecx+4057]
	mov	BYTE PTR $T240880[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T240884[ebp], ecx
	movzx	edx, BYTE PTR $T240880[ebp]
	test	edx, edx
	je	SHORT $LN44@Validate
	cmp	DWORD PTR $T240934[ebp], 0
	jge	SHORT $LN43@Validate
	mov	eax, DWORD PTR $T240934[ebp]
	cdq
	idiv	DWORD PTR $T240884[ebp]
	add	edx, DWORD PTR $T240884[ebp]
	mov	DWORD PTR _iMapY$240932[ebp], edx
	jmp	SHORT $LN45@Validate
	jmp	SHORT $LN44@Validate
$LN43@Validate:
	mov	eax, DWORD PTR $T240934[ebp]
	cmp	eax, DWORD PTR $T240884[ebp]
	jl	SHORT $LN44@Validate
	mov	eax, DWORD PTR $T240934[ebp]
	cdq
	idiv	DWORD PTR $T240884[ebp]
	mov	DWORD PTR _iMapY$240932[ebp], edx
	jmp	SHORT $LN45@Validate
$LN44@Validate:
	mov	ecx, DWORD PTR $T240934[ebp]
	mov	DWORD PTR _iMapY$240932[ebp], ecx
$LN45@Validate:
	mov	edx, DWORD PTR _iMapY$240932[ebp]
	push	edx
	mov	eax, DWORD PTR _iMapX$240931[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isPlot@CvMap@@QBEHHH@Z			; CvMap::isPlot
	test	eax, eax
	je	SHORT $LN25@Validate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240896[ebp], edx
	mov	eax, DWORD PTR _iMapY$240932[ebp]
	imul	eax, DWORD PTR $T240896[ebp]
	add	eax, DWORD PTR _iMapX$240931[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN26@Validate
$LN25@Validate:
	mov	DWORD PTR tv182[ebp], 0
$LN26@Validate:
	mov	edx, DWORD PTR tv182[ebp]
	mov	DWORD PTR _pOriginPlot$235874[ebp], edx
$LN23@Validate:

; 2432 : 				if(pOriginPlot)

	cmp	DWORD PTR _pOriginPlot$235874[ebp], 0
	je	SHORT $LN7@Validate

; 2433 : 				{
; 2434 : 					if(pOriginPlot->getPlotCity() == NULL)

	mov	ecx, DWORD PTR _pOriginPlot$235874[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	jne	SHORT $LN7@Validate

; 2435 : 					{
; 2436 : 						pGameTrade->ClearAllCityTradeRoutes(pOriginPlot);

	mov	eax, DWORD PTR _pOriginPlot$235874[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGameTrade$[ebp]
	call	?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z ; CvGameTrade::ClearAllCityTradeRoutes

; 2437 : 						continue;

	jmp	$LN10@Validate
$LN7@Validate:

; 2438 : 					}
; 2439 : 				}
; 2440 : 
; 2441 : 				CvPlot* pDestPlot = plot(connection.m_iDestX, connection.m_iDestY);

	mov	ecx, DWORD PTR _connection$235872[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T241042[ebp], edx
	mov	eax, DWORD PTR _connection$235872[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR $T241041[ebp], ecx
	cmp	DWORD PTR $T241041[ebp], -2147483647	; 80000001H
	je	SHORT $LN56@Validate
	cmp	DWORD PTR $T241042[ebp], -2147483647	; 80000001H
	jne	SHORT $LN57@Validate
$LN56@Validate:
	mov	DWORD PTR _pDestPlot$235877[ebp], 0
	jmp	$LN58@Validate
$LN57@Validate:
	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx+4056]
	mov	BYTE PTR $T240946[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240950[ebp], edx
	movzx	eax, BYTE PTR $T240946[ebp]
	test	eax, eax
	je	SHORT $LN69@Validate
	cmp	DWORD PTR $T241041[ebp], 0
	jge	SHORT $LN68@Validate
	mov	eax, DWORD PTR $T241041[ebp]
	cdq
	idiv	DWORD PTR $T240950[ebp]
	add	edx, DWORD PTR $T240950[ebp]
	mov	DWORD PTR _iMapX$241039[ebp], edx
	jmp	SHORT $LN70@Validate
	jmp	SHORT $LN69@Validate
$LN68@Validate:
	mov	ecx, DWORD PTR $T241041[ebp]
	cmp	ecx, DWORD PTR $T240950[ebp]
	jl	SHORT $LN69@Validate
	mov	eax, DWORD PTR $T241041[ebp]
	cdq
	idiv	DWORD PTR $T240950[ebp]
	mov	DWORD PTR _iMapX$241039[ebp], edx
	jmp	SHORT $LN70@Validate
$LN69@Validate:
	mov	edx, DWORD PTR $T241041[ebp]
	mov	DWORD PTR _iMapX$241039[ebp], edx
$LN70@Validate:
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR [eax+4057]
	mov	BYTE PTR $T240961[ebp], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4024]
	mov	DWORD PTR $T240965[ebp], eax
	movzx	ecx, BYTE PTR $T240961[ebp]
	test	ecx, ecx
	je	SHORT $LN79@Validate
	cmp	DWORD PTR $T241042[ebp], 0
	jge	SHORT $LN78@Validate
	mov	eax, DWORD PTR $T241042[ebp]
	cdq
	idiv	DWORD PTR $T240965[ebp]
	add	edx, DWORD PTR $T240965[ebp]
	mov	DWORD PTR _iMapY$241040[ebp], edx
	jmp	SHORT $LN80@Validate
	jmp	SHORT $LN79@Validate
$LN78@Validate:
	mov	edx, DWORD PTR $T241042[ebp]
	cmp	edx, DWORD PTR $T240965[ebp]
	jl	SHORT $LN79@Validate
	mov	eax, DWORD PTR $T241042[ebp]
	cdq
	idiv	DWORD PTR $T240965[ebp]
	mov	DWORD PTR _iMapY$241040[ebp], edx
	jmp	SHORT $LN80@Validate
$LN79@Validate:
	mov	eax, DWORD PTR $T241042[ebp]
	mov	DWORD PTR _iMapY$241040[ebp], eax
$LN80@Validate:
	cmp	DWORD PTR _iMapX$241039[ebp], 0
	jl	SHORT $LN84@Validate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240979[ebp], edx
	mov	eax, DWORD PTR _iMapX$241039[ebp]
	cmp	eax, DWORD PTR $T240979[ebp]
	jge	SHORT $LN84@Validate
	cmp	DWORD PTR _iMapY$241040[ebp], 0
	jl	SHORT $LN84@Validate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4024]
	mov	DWORD PTR $T240983[ebp], edx
	mov	eax, DWORD PTR _iMapY$241040[ebp]
	cmp	eax, DWORD PTR $T240983[ebp]
	jge	SHORT $LN84@Validate
	mov	DWORD PTR tv240[ebp], 1
	jmp	SHORT $LN82@Validate
$LN84@Validate:
	mov	DWORD PTR tv240[ebp], 0
$LN82@Validate:
	cmp	DWORD PTR tv240[ebp], 0
	je	SHORT $LN60@Validate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4020]
	mov	DWORD PTR $T240996[ebp], edx
	mov	eax, DWORD PTR _iMapY$241040[ebp]
	imul	eax, DWORD PTR $T240996[ebp]
	add	eax, DWORD PTR _iMapX$241039[ebp]
	imul	eax, 484				; 000001e4H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4068]
	mov	DWORD PTR tv225[ebp], eax
	jmp	SHORT $LN61@Validate
$LN60@Validate:
	mov	DWORD PTR tv225[ebp], 0
$LN61@Validate:
	mov	edx, DWORD PTR tv225[ebp]
	mov	DWORD PTR _pDestPlot$235877[ebp], edx
$LN58@Validate:

; 2442 : 				if(pDestPlot)

	cmp	DWORD PTR _pDestPlot$235877[ebp], 0
	je	SHORT $LN8@Validate

; 2443 : 				{
; 2444 : 					if(pDestPlot->getPlotCity() == NULL)

	mov	ecx, DWORD PTR _pDestPlot$235877[ebp]
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity
	test	eax, eax
	jne	SHORT $LN8@Validate

; 2445 : 					{
; 2446 : 						pGameTrade->ClearAllCityTradeRoutes(pDestPlot);

	mov	eax, DWORD PTR _pDestPlot$235877[ebp]
	push	eax
	mov	ecx, DWORD PTR _pGameTrade$[ebp]
	call	?ClearAllCityTradeRoutes@CvGameTrade@@QAEXPAVCvPlot@@@Z ; CvGameTrade::ClearAllCityTradeRoutes

; 2447 : 						continue;

	jmp	$LN10@Validate
$LN8@Validate:

; 2448 : 					}
; 2449 : 				}
; 2450 : 			}
; 2451 : 		}

	jmp	$LN10@Validate
$LN12@Validate:

; 2452 : 	}
; 2453 : 
; 2454 : 
; 2455 : 
; 2456 : 	int iErrors = 0;

	mov	DWORD PTR _iErrors$[ebp], 0

; 2457 : #ifdef AUI_WARNING_FIXES
; 2458 : 	for (uint iI = 0; iI < numPlots(); iI++)
; 2459 : #else
; 2460 : 	for(int iI = 0; iI < numPlots(); iI++)

	mov	DWORD PTR _iI$235881[ebp], 0
	jmp	SHORT $LN3@Validate
$LN2@Validate:
	mov	ecx, DWORD PTR _iI$235881[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$235881[ebp], ecx
$LN3@Validate:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR $T241051[ebp], eax
	mov	ecx, DWORD PTR _iI$235881[ebp]
	cmp	ecx, DWORD PTR $T241051[ebp]
	jge	SHORT $LN1@Validate

; 2461 : #endif
; 2462 : 	{
; 2463 : 		CvPlot* pLoopPlot = plotByIndexUnchecked(iI);

	mov	edx, DWORD PTR _iI$235881[ebp]
	imul	edx, 484				; 000001e4H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4068]
	mov	DWORD PTR _pLoopPlot$235885[ebp], edx

; 2464 : 		iErrors |= pLoopPlot->Validate(*this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pLoopPlot$235885[ebp]
	call	?Validate@CvPlot@@QAEHAAVCvMap@@@Z	; CvPlot::Validate
	or	eax, DWORD PTR _iErrors$[ebp]
	mov	DWORD PTR _iErrors$[ebp], eax

; 2465 : 	}

	jmp	SHORT $LN2@Validate
$LN1@Validate:

; 2466 : 
; 2467 : 	return iErrors;

	mov	eax, DWORD PTR _iErrors$[ebp]

; 2468 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Validate@CvMap@@QAEHXZ ENDP				; CvMap::Validate
_TEXT	ENDS
PUBLIC	?ChangeAIMapHint@CvMap@@QAEXH@Z			; CvMap::ChangeAIMapHint
; Function compile flags: /Odtp
;	COMDAT ?ChangeAIMapHint@CvMap@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iMapHint$ = 8						; size = 4
?ChangeAIMapHint@CvMap@@QAEXH@Z PROC			; CvMap::ChangeAIMapHint, COMDAT
; _this$ = ecx

; 2472 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2473 : 	m_iAIMapHints |= iMapHint;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4052]
	or	ecx, DWORD PTR _iMapHint$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4052], ecx

; 2474 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChangeAIMapHint@CvMap@@QAEXH@Z ENDP			; CvMap::ChangeAIMapHint
_TEXT	ENDS
PUBLIC	?GetAIMapHint@CvMap@@QAEHXZ			; CvMap::GetAIMapHint
; Function compile flags: /Odtp
;	COMDAT ?GetAIMapHint@CvMap@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAIMapHint@CvMap@@QAEHXZ PROC			; CvMap::GetAIMapHint, COMDAT
; _this$ = ecx

; 2478 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2479 : 	return m_iAIMapHints;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4052]

; 2480 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetAIMapHint@CvMap@@QAEHXZ ENDP			; CvMap::GetAIMapHint
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ		; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>
PUBLIC	??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ ; `string'
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@ DB 'd:\sources\'
	DB	'lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\FF'
	DB	'astVector.h', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ$0
__ehfuncinfo$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T241071 = -20						; size = 4
_pRet$241067 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ PROC ; FStaticVector<CvPlot *,1000,1,297,1>::FStaticVector<CvPlot *,1000,1,297,1>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 1000			; 000003e8H

; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR $T241071[ebp], edx
	cmp	DWORD PTR $T241071[ebp], 1000		; 000003e8H
	jbe	SHORT $LN7@FStaticVec
	push	798					; 0000031eH
	push	OFFSET ??_C@_0FE@GLGBBJMA@d?3?2sources?2lekmod_git?2checkout?2l@
	push	4
	mov	eax, DWORD PTR $T241071[ebp]
	shl	eax, 2
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pRet$241067[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T241071[ebp]
	mov	DWORD PTR [ecx+8], edx
	jmp	SHORT $LN8@FStaticVec
$LN7@FStaticVec:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _pRet$241067[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1000			; 000003e8H
$LN8@FStaticVec:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pRet$241067[ebp]
	mov	DWORD PTR [edx], eax

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ	; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>
__ehhandler$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::FStaticVector<CvPlot *,1000,1,297,1>
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ$0
__ehfuncinfo$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T241102 = -24						; size = 4
$T241101 = -20						; size = 4
_i$241096 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ PROC ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>, COMDAT
; _this$ = ecx

; 617  : 	~FStaticVector(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T241102[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241101[ebp], eax
	xor	ecx, ecx
	je	SHORT $LN5@FStaticVec@2
	xor	edx, edx
	je	SHORT $LN5@FStaticVec@2
	mov	DWORD PTR _i$241096[ebp], 0
	jmp	SHORT $LN10@FStaticVec@2
$LN9@FStaticVec@2:
	mov	eax, DWORD PTR _i$241096[ebp]
	add	eax, 1
	mov	DWORD PTR _i$241096[ebp], eax
$LN10@FStaticVec@2:
	mov	ecx, DWORD PTR _i$241096[ebp]
	cmp	ecx, DWORD PTR $T241102[ebp]
	jae	SHORT $LN5@FStaticVec@2
	jmp	SHORT $LN9@FStaticVec@2
$LN5@FStaticVec@2:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	cmp	DWORD PTR $T241101[ebp], edx
	je	SHORT $LN1@FStaticVec@2
	mov	eax, DWORD PTR $T241101[ebp]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN1@FStaticVec@2:

; 619  : 	};

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ	; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>
__ehhandler$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FStaticVector@PAVCvPlot@@$0DOI@$00$0BCJ@$00@@QAE@XZ ENDP ; FStaticVector<CvPlot *,1000,1,297,1>::~FStaticVector<CvPlot *,1000,1,297,1>
; Function compile flags: /Odtp
;	COMDAT ??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ PROC		; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$BaseVector@PAVCvPlot@@$00@@QAE@XZ ENDP		; BaseVector<CvPlot *,1>::~BaseVector<CvPlot *,1>
_TEXT	ENDS
PUBLIC	??_7?$FFreeListTrashArray@VCvArea@@@@6B@	; FFreeListTrashArray<CvArea>::`vftable'
PUBLIC	??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ	; FFreeListArrayBase<CvArea>::FFreeListArrayBase<CvArea>
PUBLIC	?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z	; FFreeListTrashArray<CvArea>::Init
PUBLIC	?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ	; FFreeListTrashArray<CvArea>::Uninit
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z ; FFreeListTrashArray<CvArea>::GetAt
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z ; FFreeListTrashArray<CvArea>::GetAt
PUBLIC	?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ ; FFreeListTrashArray<CvArea>::RemoveAll
PUBLIC	?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ ; FFreeListTrashArray<CvArea>::GrowArray
EXTRN	??_E?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z:PROC ; FFreeListTrashArray<CvArea>::`vector deleting destructor'
;	COMDAT ??_7?$FFreeListTrashArray@VCvArea@@@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
CONST	SEGMENT
??_7?$FFreeListTrashArray@VCvArea@@@@6B@ DD FLAT:??_E?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z ; FFreeListTrashArray<CvArea>::`vftable'
	DD	FLAT:?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z
	DD	FLAT:?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z
	DD	FLAT:?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
	DD	FLAT:?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ PROC		; FFreeListTrashArray<CvArea>::FFreeListTrashArray<CvArea>, COMDAT
; _this$ = ecx

; 132  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ ; FFreeListArrayBase<CvArea>::FFreeListArrayBase<CvArea>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListTrashArray@VCvArea@@@@6B@

; 133  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 8192		; 00002000H

; 134  : 	m_pArray = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 135  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$FFreeListTrashArray@VCvArea@@@@QAE@XZ ENDP		; FFreeListTrashArray<CvArea>::FFreeListTrashArray<CvArea>
_TEXT	ENDS
EXTRN	?SetID@CvArea@@QAEXH@Z:PROC			; CvArea::SetID
EXTRN	??0CvArea@@QAE@XZ:PROC				; CvArea::CvArea
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ$0
__ehfuncinfo$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
_TEXT	SEGMENT
tv194 = -32						; size = 4
_this$ = -28						; size = 4
$T241120 = -24						; size = 4
$T241119 = -20						; size = 4
_iIndex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ PROC ; FFreeListTrashArray<CvArea>::Add, COMDAT
; _this$ = ecx

; 204  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 205  : 	int iIndex;
; 206  : 
; 207  : 	if (m_pArray == NULL) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@Add

; 208  : 	{
; 209  : 		Init();

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN5@Add:

; 210  : 	}
; 211  : 
; 212  : 	if ((this->m_iLastIndex == this->m_iNumSlots - 1) &&
; 213  : 		(this->m_iFreeListCount == 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jne	SHORT $LN4@Add
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN4@Add

; 214  : 	{
; 215  : 		if ((this->m_iNumSlots * FLTA_GROWTH_FACTOR) > FLTA_MAX_BUCKETS)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 1
	cmp	eax, 8192				; 00002000H
	jle	SHORT $LN3@Add

; 216  : 		{
; 217  : 			return NULL;

	xor	eax, eax
	jmp	$LN6@Add
$LN3@Add:

; 218  : 		}
; 219  : 
; 220  : 		GrowArray();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN4@Add:

; 221  : 	}
; 222  : 
; 223  : 	if (this->m_iFreeListCount > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN2@Add

; 224  : 	{
; 225  : 		iIndex = this->m_iFreeListHead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iIndex$[ebp], eax

; 226  : 		this->m_iFreeListHead = m_pArray[this->m_iFreeListHead].iNextFreeIndex;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR [eax+4], ecx

; 227  : 		this->m_iFreeListCount--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 228  : 	}
; 229  : 	else

	jmp	SHORT $LN1@Add
$LN2@Add:

; 230  : 	{
; 231  : 		this->m_iLastIndex++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 232  : 		iIndex = this->m_iLastIndex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _iIndex$[ebp], eax
$LN1@Add:

; 233  : 	}
; 234  : 
; 235  : 	m_pArray[iIndex].pData = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	4232					; 00001088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T241120[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T241120[ebp], 0
	je	SHORT $LN8@Add
	mov	ecx, DWORD PTR $T241120[ebp]
	call	??0CvArea@@QAE@XZ			; CvArea::CvArea
	mov	DWORD PTR tv194[ebp], eax
	jmp	SHORT $LN9@Add
$LN8@Add:
	mov	DWORD PTR tv194[ebp], 0
$LN9@Add:
	mov	ecx, DWORD PTR tv194[ebp]
	mov	DWORD PTR $T241119[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	edx, DWORD PTR $T241119[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 236  : 	m_pArray[iIndex].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [ecx+edx*8], -1

; 237  : 
; 238  : 	m_pArray[iIndex].pData->SetID(m_iCurrentID + iIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _iIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
	call	?SetID@CvArea@@QAEXH@Z			; CvArea::SetID

; 239  : 	m_iCurrentID += FLTA_MAX_BUCKETS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 240  : 
; 241  : 	return m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR [eax+ecx*8+4]
$LN6@Add:

; 242  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ$0:
	mov	eax, DWORD PTR $T241120[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Add@?$FFreeListTrashArray@VCvArea@@@@QAEPAVCvArea@@XZ ENDP ; FFreeListTrashArray<CvArea>::Add
EXTRN	??1CvArea@@QAE@XZ:PROC				; CvArea::~CvArea
; Function compile flags: /Odtp
;	COMDAT ?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z
_TEXT	SEGMENT
tv128 = -24						; size = 4
_this$ = -20						; size = 4
$T241139 = -16						; size = 4
$T241133 = -12						; size = 4
$T241132 = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z PROC ; FFreeListTrashArray<CvArea>::RemoveAt, COMDAT
; _this$ = ecx

; 321  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 322  : 	int iIndex;
; 323  : 
; 324  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	cmp	DWORD PTR _iID$[ebp], -1
	je	SHORT $LN5@RemoveAt
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN6@RemoveAt
$LN5@RemoveAt:

; 325  : 	{
; 326  : 		return false;

	xor	al, al
	jmp	$LN7@RemoveAt
$LN6@RemoveAt:

; 327  : 	}
; 328  : 
; 329  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], ecx

; 330  : 
; 331  : 	assert(iIndex >= 0);
; 332  : 
; 333  : 	if ((iIndex <= this->m_iLastIndex) && 
; 334  : 		(m_pArray[iIndex].pData != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jg	$LN4@RemoveAt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	$LN4@RemoveAt

; 335  : 	{
; 336  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, -8192				; ffffe000H
	je	SHORT $LN2@RemoveAt
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241139[ebp], eax
	mov	ecx, DWORD PTR $T241139[ebp]
	cmp	ecx, DWORD PTR _iID$[ebp]
	jne	$LN4@RemoveAt
$LN2@RemoveAt:

; 337  : 		{
; 338  : 			delete m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR $T241133[ebp], edx
	mov	eax, DWORD PTR $T241133[ebp]
	mov	DWORD PTR $T241132[ebp], eax
	cmp	DWORD PTR $T241132[ebp], 0
	je	SHORT $LN9@RemoveAt
	mov	ecx, DWORD PTR $T241132[ebp]
	call	??1CvArea@@QAE@XZ			; CvArea::~CvArea
	mov	ecx, 1
	and	ecx, 1
	je	SHORT $LN14@RemoveAt
	mov	edx, DWORD PTR $T241132[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN14@RemoveAt:
	mov	eax, DWORD PTR $T241132[ebp]
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN10@RemoveAt
$LN9@RemoveAt:
	mov	DWORD PTR tv128[ebp], 0
$LN10@RemoveAt:

; 339  : 			m_pArray[iIndex].pData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [edx+eax*8+4], 0

; 340  : 
; 341  : 			m_pArray[iIndex].iNextFreeIndex = this->m_iFreeListHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax*8], ecx

; 342  : 			this->m_iFreeListHead = iIndex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [edx+4], eax

; 343  : 			this->m_iFreeListCount++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 344  : 
; 345  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@RemoveAt
$LN4@RemoveAt:

; 346  : 		}
; 347  : 		else
; 348  : 		{
; 349  : 			assert(false);
; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : 	return false;

	xor	al, al
$LN7@RemoveAt:

; 354  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAt@?$FFreeListTrashArray@VCvArea@@@@QAE_NH@Z ENDP ; FFreeListTrashArray<CvArea>::RemoveAt
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
_TEXT	ENDS
;	COMDAT ?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::BeginIter, COMDAT
; _this$ = ecx

; 119  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 	*pIterIdx = 0;

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [eax], 0

; 121  : 	return NextIter(pIterIdx);

	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::NextIter

; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BeginIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::BeginIter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pObj$235997 = -4					; size = 4
_pIterIdx$ = 8						; size = 4
?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::NextIter, COMDAT
; _this$ = ecx

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 	for( ; (*pIterIdx)<GetIndexAfterLast(); (*pIterIdx)++)

	jmp	SHORT $LN7@NextIter
$LN3@NextIter:
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@NextIter:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	cmp	DWORD PTR [edx], ecx
	jge	SHORT $LN2@NextIter

; 129  : 	{
; 130  : 		T* pObj = GetAt((*pIterIdx));

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pObj$235997[ebp], eax

; 131  : 		if (pObj)

	cmp	DWORD PTR _pObj$235997[ebp], 0
	je	SHORT $LN1@NextIter

; 132  : 		{
; 133  : 			(*pIterIdx)++;	// prime for next call

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx

; 134  : 			return pObj;

	mov	eax, DWORD PTR _pObj$235997[ebp]
	jmp	SHORT $LN5@NextIter
$LN1@NextIter:

; 135  : 		}
; 136  : 	}

	jmp	SHORT $LN3@NextIter
$LN2@NextIter:

; 137  : 	return NULL;

	xor	eax, eax
$LN5@NextIter:

; 138  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NextIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::NextIter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::EndIter, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 	*pIterIdx = GetIndexAfterLast()-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx

; 145  : 	return PrevIter(pIterIdx);

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ; FFreeListArrayBase<CvArea>::PrevIter

; 146  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EndIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::EndIter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pObj$236014 = -4					; size = 4
_pIterIdx$ = 8						; size = 4
?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z PROC ; FFreeListArrayBase<CvArea>::PrevIter, COMDAT
; _this$ = ecx

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 	for( ; (*pIterIdx)>=0; (*pIterIdx)--)

	jmp	SHORT $LN4@PrevIter
$LN3@PrevIter:
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@PrevIter:
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN2@PrevIter

; 153  : 	{
; 154  : 		T* pObj = GetAt((*pIterIdx));

	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pObj$236014[ebp], eax

; 155  : 		if (pObj)

	cmp	DWORD PTR _pObj$236014[ebp], 0
	je	SHORT $LN1@PrevIter

; 156  : 		{
; 157  : 			(*pIterIdx)--;	// prime for next call

	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [eax], edx

; 158  : 			return pObj;

	mov	eax, DWORD PTR _pObj$236014[ebp]
	jmp	SHORT $LN5@PrevIter
$LN1@PrevIter:

; 159  : 		}
; 160  : 	}

	jmp	SHORT $LN3@PrevIter
$LN2@PrevIter:

; 161  : 	return NULL;

	xor	eax, eax
$LN5@PrevIter:

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PrevIter@?$FFreeListArrayBase@VCvArea@@@@QAEPAVCvArea@@PAH@Z ENDP ; FFreeListArrayBase<CvArea>::PrevIter
_TEXT	ENDS
PUBLIC	??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@	; FFreeListTrashArray<CvLandmass>::`vftable'
PUBLIC	??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ	; FFreeListArrayBase<CvLandmass>::FFreeListArrayBase<CvLandmass>
PUBLIC	?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z ; FFreeListTrashArray<CvLandmass>::Init
PUBLIC	?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ; FFreeListTrashArray<CvLandmass>::Uninit
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z ; FFreeListTrashArray<CvLandmass>::GetAt
PUBLIC	?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z ; FFreeListTrashArray<CvLandmass>::GetAt
PUBLIC	?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ; FFreeListTrashArray<CvLandmass>::RemoveAll
PUBLIC	?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ ; FFreeListTrashArray<CvLandmass>::GrowArray
EXTRN	??_E?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z:PROC ; FFreeListTrashArray<CvLandmass>::`vector deleting destructor'
;	COMDAT ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
CONST	SEGMENT
??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@ DD FLAT:??_E?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z ; FFreeListTrashArray<CvLandmass>::`vftable'
	DD	FLAT:?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z
	DD	FLAT:?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z
	DD	FLAT:?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z
	DD	FLAT:?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
	DD	FLAT:?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ PROC	; FFreeListTrashArray<CvLandmass>::FFreeListTrashArray<CvLandmass>, COMDAT
; _this$ = ecx

; 132  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ ; FFreeListArrayBase<CvLandmass>::FFreeListArrayBase<CvLandmass>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@

; 133  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 8192		; 00002000H

; 134  : 	m_pArray = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 135  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$FFreeListTrashArray@VCvLandmass@@@@QAE@XZ ENDP	; FFreeListTrashArray<CvLandmass>::FFreeListTrashArray<CvLandmass>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ$0
__ehfuncinfo$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ
_TEXT	SEGMENT
tv194 = -32						; size = 4
_this$ = -28						; size = 4
$T241164 = -24						; size = 4
$T241163 = -20						; size = 4
_iIndex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ PROC ; FFreeListTrashArray<CvLandmass>::Add, COMDAT
; _this$ = ecx

; 204  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 205  : 	int iIndex;
; 206  : 
; 207  : 	if (m_pArray == NULL) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@Add@2

; 208  : 	{
; 209  : 		Init();

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN5@Add@2:

; 210  : 	}
; 211  : 
; 212  : 	if ((this->m_iLastIndex == this->m_iNumSlots - 1) &&
; 213  : 		(this->m_iFreeListCount == 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], edx
	jne	SHORT $LN4@Add@2
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN4@Add@2

; 214  : 	{
; 215  : 		if ((this->m_iNumSlots * FLTA_GROWTH_FACTOR) > FLTA_MAX_BUCKETS)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 1
	cmp	eax, 8192				; 00002000H
	jle	SHORT $LN3@Add@2

; 216  : 		{
; 217  : 			return NULL;

	xor	eax, eax
	jmp	$LN6@Add@2
$LN3@Add@2:

; 218  : 		}
; 219  : 
; 220  : 		GrowArray();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN4@Add@2:

; 221  : 	}
; 222  : 
; 223  : 	if (this->m_iFreeListCount > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN2@Add@2

; 224  : 	{
; 225  : 		iIndex = this->m_iFreeListHead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _iIndex$[ebp], eax

; 226  : 		this->m_iFreeListHead = m_pArray[this->m_iFreeListHead].iNextFreeIndex;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR [eax+4], ecx

; 227  : 		this->m_iFreeListCount--;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 228  : 	}
; 229  : 	else

	jmp	SHORT $LN1@Add@2
$LN2@Add@2:

; 230  : 	{
; 231  : 		this->m_iLastIndex++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 232  : 		iIndex = this->m_iLastIndex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _iIndex$[ebp], eax
$LN1@Add@2:

; 233  : 	}
; 234  : 
; 235  : 	m_pArray[iIndex].pData = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T241164[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T241164[ebp], 0
	je	SHORT $LN8@Add@2
	mov	ecx, DWORD PTR $T241164[ebp]
	call	??0CvLandmass@@QAE@XZ			; CvLandmass::CvLandmass
	mov	DWORD PTR tv194[ebp], eax
	jmp	SHORT $LN9@Add@2
$LN8@Add@2:
	mov	DWORD PTR tv194[ebp], 0
$LN9@Add@2:
	mov	ecx, DWORD PTR tv194[ebp]
	mov	DWORD PTR $T241163[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	edx, DWORD PTR $T241163[ebp]
	mov	DWORD PTR [eax+ecx*8+4], edx

; 236  : 	m_pArray[iIndex].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [ecx+edx*8], -1

; 237  : 
; 238  : 	m_pArray[iIndex].pData->SetID(m_iCurrentID + iIndex);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _iIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
	call	?SetID@CvLandmass@@QAEXH@Z		; CvLandmass::SetID

; 239  : 	m_iCurrentID += FLTA_MAX_BUCKETS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 240  : 
; 241  : 	return m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR [eax+ecx*8+4]
$LN6@Add@2:

; 242  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ$0:
	mov	eax, DWORD PTR $T241164[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Add@?$FFreeListTrashArray@VCvLandmass@@@@QAEPAVCvLandmass@@XZ ENDP ; FFreeListTrashArray<CvLandmass>::Add
; Function compile flags: /Odtp
;	COMDAT ?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z
_TEXT	SEGMENT
tv130 = -20						; size = 4
_this$ = -16						; size = 4
$T241177 = -12						; size = 4
$T241176 = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z PROC ; FFreeListTrashArray<CvLandmass>::RemoveAt, COMDAT
; _this$ = ecx

; 321  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 322  : 	int iIndex;
; 323  : 
; 324  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	cmp	DWORD PTR _iID$[ebp], -1
	je	SHORT $LN5@RemoveAt@2
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN6@RemoveAt@2
$LN5@RemoveAt@2:

; 325  : 	{
; 326  : 		return false;

	xor	al, al
	jmp	$LN7@RemoveAt@2
$LN6@RemoveAt@2:

; 327  : 	}
; 328  : 
; 329  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], ecx

; 330  : 
; 331  : 	assert(iIndex >= 0);
; 332  : 
; 333  : 	if ((iIndex <= this->m_iLastIndex) && 
; 334  : 		(m_pArray[iIndex].pData != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jg	$LN4@RemoveAt@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	$LN4@RemoveAt@2

; 335  : 	{
; 336  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, -8192				; ffffe000H
	je	SHORT $LN2@RemoveAt@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
	call	?GetID@CvLandmass@@QBEHXZ		; CvLandmass::GetID
	cmp	eax, DWORD PTR _iID$[ebp]
	jne	SHORT $LN4@RemoveAt@2
$LN2@RemoveAt@2:

; 337  : 		{
; 338  : 			delete m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR $T241177[ebp], edx
	mov	eax, DWORD PTR $T241177[ebp]
	mov	DWORD PTR $T241176[ebp], eax
	cmp	DWORD PTR $T241176[ebp], 0
	je	SHORT $LN9@RemoveAt@2
	push	1
	mov	ecx, DWORD PTR $T241176[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T241176[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN10@RemoveAt@2
$LN9@RemoveAt@2:
	mov	DWORD PTR tv130[ebp], 0
$LN10@RemoveAt@2:

; 339  : 			m_pArray[iIndex].pData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [edx+eax*8+4], 0

; 340  : 
; 341  : 			m_pArray[iIndex].iNextFreeIndex = this->m_iFreeListHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+eax*8], ecx

; 342  : 			this->m_iFreeListHead = iIndex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	DWORD PTR [edx+4], eax

; 343  : 			this->m_iFreeListCount++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 344  : 
; 345  : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@RemoveAt@2
$LN4@RemoveAt@2:

; 346  : 		}
; 347  : 		else
; 348  : 		{
; 349  : 			assert(false);
; 350  : 		}
; 351  : 	}
; 352  : 
; 353  : 	return false;

	xor	al, al
$LN7@RemoveAt@2:

; 354  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveAt@?$FFreeListTrashArray@VCvLandmass@@@@QAE_NH@Z ENDP ; FFreeListTrashArray<CvLandmass>::RemoveAt
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
_TEXT	ENDS
;	COMDAT ?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::BeginIter, COMDAT
; _this$ = ecx

; 119  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 	*pIterIdx = 0;

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [eax], 0

; 121  : 	return NextIter(pIterIdx);

	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::NextIter

; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BeginIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::BeginIter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pObj$236068 = -4					; size = 4
_pIterIdx$ = 8						; size = 4
?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::NextIter, COMDAT
; _this$ = ecx

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 	for( ; (*pIterIdx)<GetIndexAfterLast(); (*pIterIdx)++)

	jmp	SHORT $LN7@NextIter@2
$LN3@NextIter@2:
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx
$LN7@NextIter@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	cmp	DWORD PTR [edx], ecx
	jge	SHORT $LN2@NextIter@2

; 129  : 	{
; 130  : 		T* pObj = GetAt((*pIterIdx));

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx
	mov	DWORD PTR _pObj$236068[ebp], eax

; 131  : 		if (pObj)

	cmp	DWORD PTR _pObj$236068[ebp], 0
	je	SHORT $LN1@NextIter@2

; 132  : 		{
; 133  : 			(*pIterIdx)++;	// prime for next call

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx

; 134  : 			return pObj;

	mov	eax, DWORD PTR _pObj$236068[ebp]
	jmp	SHORT $LN5@NextIter@2
$LN1@NextIter@2:

; 135  : 		}
; 136  : 	}

	jmp	SHORT $LN3@NextIter@2
$LN2@NextIter@2:

; 137  : 	return NULL;

	xor	eax, eax
$LN5@NextIter@2:

; 138  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?NextIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::NextIter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pIterIdx$ = 8						; size = 4
?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::EndIter, COMDAT
; _this$ = ecx

; 143  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 	*pIterIdx = GetIndexAfterLast()-1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx

; 145  : 	return PrevIter(pIterIdx);

	mov	eax, DWORD PTR _pIterIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ; FFreeListArrayBase<CvLandmass>::PrevIter

; 146  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?EndIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::EndIter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pObj$236085 = -4					; size = 4
_pIterIdx$ = 8						; size = 4
?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z PROC ; FFreeListArrayBase<CvLandmass>::PrevIter, COMDAT
; _this$ = ecx

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 	for( ; (*pIterIdx)>=0; (*pIterIdx)--)

	jmp	SHORT $LN4@PrevIter@2
$LN3@PrevIter@2:
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [edx], ecx
$LN4@PrevIter@2:
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	cmp	DWORD PTR [eax], 0
	jl	SHORT $LN2@PrevIter@2

; 153  : 	{
; 154  : 		T* pObj = GetAt((*pIterIdx));

	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _pObj$236085[ebp], eax

; 155  : 		if (pObj)

	cmp	DWORD PTR _pObj$236085[ebp], 0
	je	SHORT $LN1@PrevIter@2

; 156  : 		{
; 157  : 			(*pIterIdx)--;	// prime for next call

	mov	ecx, DWORD PTR _pIterIdx$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _pIterIdx$[ebp]
	mov	DWORD PTR [eax], edx

; 158  : 			return pObj;

	mov	eax, DWORD PTR _pObj$236085[ebp]
	jmp	SHORT $LN5@PrevIter@2
$LN1@PrevIter@2:

; 159  : 		}
; 160  : 	}

	jmp	SHORT $LN3@PrevIter@2
$LN2@PrevIter@2:

; 161  : 	return NULL;

	xor	eax, eax
$LN5@PrevIter@2:

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?PrevIter@?$FFreeListArrayBase@VCvLandmass@@@@QAEPAVCvLandmass@@PAH@Z ENDP ; FFreeListArrayBase<CvLandmass>::PrevIter
_TEXT	ENDS
EXTRN	?Read@FDataStream@@IAEXAAE@Z:PROC		; FDataStream::Read
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z PROC ; operator>><unsigned char>, COMDAT

; 515  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 516  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 518  : 	ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 519  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator
$LN2@operator:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _loadFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAE@Z		; FDataStream::Read

; 522  : 	}

	jmp	SHORT $LN2@operator
$LN1@operator:

; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[ebp]

; 524  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?5E@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@E@@@Z ENDP ; operator>><unsigned char>
_TEXT	ENDS
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_tValue$236132 = -24					; size = 4
_tValue$236127 = -20					; size = 4
_iType$236125 = -16					; size = 4
_bValid$236124 = -9					; size = 1
_iI$236120 = -8						; size = 4
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	lea	eax, DWORD PTR _uiNumEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	mov	DWORD PTR _iI$236120[ebp], 0
	jmp	SHORT $LN7@ReadHashed
$LN6@ReadHashed:
	mov	ecx, DWORD PTR _iI$236120[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$236120[ebp], ecx
$LN7@ReadHashed:
	mov	edx, DWORD PTR _iI$236120[ebp]
	cmp	edx, DWORD PTR _uiNumEntries$[ebp]
	jae	SHORT $LN8@ReadHashed

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	eax, DWORD PTR _bValid$236124[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	push	ecx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8
	mov	DWORD PTR _iType$236125[ebp], eax

; 257  : 		if(iType != -1)

	cmp	DWORD PTR _iType$236125[ebp], -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$236127[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	mov	eax, DWORD PTR _iType$236125[ebp]
	cmp	eax, DWORD PTR _iArraySize$[ebp]
	jge	SHORT $LN3@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	ecx, DWORD PTR _iType$236125[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	mov	eax, DWORD PTR _tValue$236127[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN3@ReadHashed:

; 263  : 		}

	jmp	SHORT $LN2@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	movzx	ecx, BYTE PTR _bValid$236124[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$236132[ebp]
	push	edx
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN2@ReadHashed:

; 268  : 		}
; 269  : 	}

	jmp	SHORT $LN6@ReadHashed
$LN8@ReadHashed:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z ; FFreeListTrashArray<CvArea>::Load
EXTRN	??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z:PROC	; operator>>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z$0
__ehfuncinfo$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	ENDS
;	COMDAT ??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
_TEXT	SEGMENT
tv142 = -68						; size = 4
$T241272 = -64						; size = 4
$T241265 = -60						; size = 4
$T241257 = -56						; size = 4
$T241253 = -52						; size = 4
$T241246 = -48						; size = 4
$T241239 = -44						; size = 4
$T241232 = -40						; size = 4
$T241219 = -36						; size = 4
$T241218 = -32						; size = 4
_pData$236143 = -28					; size = 4
_iCount$ = -24						; size = 4
_i$ = -20						; size = 4
_iTemp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_readFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z PROC ; operator>><CvArea>, COMDAT

; 602  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 603  : 	int iTemp;
; 604  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 605  : 	writeTo.Init( iTemp );

	mov	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 606  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 607  : 	writeTo.SetLastIndex(iTemp);

	mov	ecx, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241232[ebp], ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR $T241232[ebp]
	mov	DWORD PTR [edx+12], eax

; 608  : 	readFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 609  : 	writeTo.SetFreeListHead(iTemp);

	mov	edx, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241239[ebp], edx
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR $T241239[ebp]
	mov	DWORD PTR [eax+4], ecx

; 610  : 	readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 611  : 	writeTo.SetFreeListCount(iTemp);

	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241246[ebp], eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR $T241246[ebp]
	mov	DWORD PTR [ecx+8], edx

; 612  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 613  : 	writeTo.SetCurrentID(iTemp);

	mov	ecx, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241253[ebp], ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR $T241253[ebp]
	mov	DWORD PTR [edx+20], eax

; 614  : 
; 615  : 	int i;
; 616  : 
; 617  : 	for ( i = 0; i < writeTo.GetNumSlots(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@operator@2
$LN5@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@operator@2:
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T241257[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR $T241257[ebp]
	jge	SHORT $LN4@operator@2

; 618  : 	{
; 619  : 		readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 620  : 		writeTo.SetNextFreeIndex(i, iTemp);

	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241272[ebp], eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T241265[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR $T241265[ebp]
	jge	SHORT $LN34@operator@2
	mov	ecx, DWORD PTR _writeTo$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN35@operator@2
$LN34@operator@2:
	jmp	SHORT $LN36@operator@2
$LN35@operator@2:
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR $T241272[ebp]
	mov	DWORD PTR [eax+ecx*8], edx
$LN36@operator@2:

; 621  : 	}

	jmp	SHORT $LN5@operator@2
$LN4@operator@2:

; 622  : 
; 623  : 	int iCount;
; 624  : 	readFrom >> iCount;

	lea	eax, DWORD PTR _iCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 625  : 
; 626  : 	for ( i = 0; i < iCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@2
$LN2@operator@2:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@2:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _iCount$[ebp]
	jge	SHORT $LN1@operator@2

; 627  : 	{
; 628  : 		T* pData = new T;

	push	4232					; 00001088H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T241219[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T241219[ebp], 0
	je	SHORT $LN9@operator@2
	mov	ecx, DWORD PTR $T241219[ebp]
	call	??0CvArea@@QAE@XZ			; CvArea::CvArea
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN10@operator@2
$LN9@operator@2:
	mov	DWORD PTR tv142[ebp], 0
$LN10@operator@2:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T241218[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T241218[ebp]
	mov	DWORD PTR _pData$236143[ebp], ecx

; 629  : 		readFrom >> *pData;

	mov	edx, DWORD PTR _pData$236143[ebp]
	push	edx
	mov	eax, DWORD PTR _readFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z ; operator>>
	add	esp, 8

; 630  : 		writeTo.Load(pData);

	mov	ecx, DWORD PTR _pData$236143[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z ; FFreeListTrashArray<CvArea>::Load

; 631  : 	}

	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 632  : 	return readFrom;

	mov	eax, DWORD PTR _readFrom$[ebp]

; 633  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z$0:
	mov	eax, DWORD PTR $T241219[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?5VCvArea@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvArea@@@@@Z ENDP ; operator>><CvArea>
PUBLIC	?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z ; FFreeListTrashArray<CvLandmass>::Load
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
xdata$x	SEGMENT
__unwindtable$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z$0
__ehfuncinfo$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	ENDS
;	COMDAT ??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z
_TEXT	SEGMENT
tv142 = -68						; size = 4
$T241338 = -64						; size = 4
$T241331 = -60						; size = 4
$T241323 = -56						; size = 4
$T241319 = -52						; size = 4
$T241312 = -48						; size = 4
$T241305 = -44						; size = 4
$T241298 = -40						; size = 4
$T241285 = -36						; size = 4
$T241284 = -32						; size = 4
_pData$236161 = -28					; size = 4
_iCount$ = -24						; size = 4
_i$ = -20						; size = 4
_iTemp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_readFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z PROC ; operator>><CvLandmass>, COMDAT

; 602  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 603  : 	int iTemp;
; 604  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 605  : 	writeTo.Init( iTemp );

	mov	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx

; 606  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 607  : 	writeTo.SetLastIndex(iTemp);

	mov	ecx, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241298[ebp], ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR $T241298[ebp]
	mov	DWORD PTR [edx+12], eax

; 608  : 	readFrom >> iTemp;

	lea	ecx, DWORD PTR _iTemp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 609  : 	writeTo.SetFreeListHead(iTemp);

	mov	edx, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241305[ebp], edx
	mov	eax, DWORD PTR _writeTo$[ebp]
	mov	ecx, DWORD PTR $T241305[ebp]
	mov	DWORD PTR [eax+4], ecx

; 610  : 	readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 611  : 	writeTo.SetFreeListCount(iTemp);

	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241312[ebp], eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR $T241312[ebp]
	mov	DWORD PTR [ecx+8], edx

; 612  : 	readFrom >> iTemp;

	lea	eax, DWORD PTR _iTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 613  : 	writeTo.SetCurrentID(iTemp);

	mov	ecx, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241319[ebp], ecx
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR $T241319[ebp]
	mov	DWORD PTR [edx+20], eax

; 614  : 
; 615  : 	int i;
; 616  : 
; 617  : 	for ( i = 0; i < writeTo.GetNumSlots(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@operator@3
$LN5@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN6@operator@3:
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR $T241323[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR $T241323[ebp]
	jge	SHORT $LN4@operator@3

; 618  : 	{
; 619  : 		readFrom >> iTemp;

	lea	edx, DWORD PTR _iTemp$[ebp]
	push	edx
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 620  : 		writeTo.SetNextFreeIndex(i, iTemp);

	mov	eax, DWORD PTR _iTemp$[ebp]
	mov	DWORD PTR $T241338[ebp], eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T241331[ebp], edx
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR $T241331[ebp]
	jge	SHORT $LN34@operator@3
	mov	ecx, DWORD PTR _writeTo$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN35@operator@3
$LN34@operator@3:
	jmp	SHORT $LN36@operator@3
$LN35@operator@3:
	mov	edx, DWORD PTR _writeTo$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR $T241338[ebp]
	mov	DWORD PTR [eax+ecx*8], edx
$LN36@operator@3:

; 621  : 	}

	jmp	SHORT $LN5@operator@3
$LN4@operator@3:

; 622  : 
; 623  : 	int iCount;
; 624  : 	readFrom >> iCount;

	lea	eax, DWORD PTR _iCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _readFrom$[ebp]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 625  : 
; 626  : 	for ( i = 0; i < iCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@3
$LN2@operator@3:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@3:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _iCount$[ebp]
	jge	SHORT $LN1@operator@3

; 627  : 	{
; 628  : 		T* pData = new T;

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T241285[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T241285[ebp], 0
	je	SHORT $LN9@operator@3
	mov	ecx, DWORD PTR $T241285[ebp]
	call	??0CvLandmass@@QAE@XZ			; CvLandmass::CvLandmass
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN10@operator@3
$LN9@operator@3:
	mov	DWORD PTR tv142[ebp], 0
$LN10@operator@3:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T241284[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T241284[ebp]
	mov	DWORD PTR _pData$236161[ebp], ecx

; 629  : 		readFrom >> *pData;

	mov	edx, DWORD PTR _pData$236161[ebp]
	push	edx
	mov	eax, DWORD PTR _readFrom$[ebp]
	push	eax
	call	??5@YAAAVFDataStream@@AAV0@AAVCvLandmass@@@Z ; operator>>
	add	esp, 8

; 630  : 		writeTo.Load(pData);

	mov	ecx, DWORD PTR _pData$236161[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z ; FFreeListTrashArray<CvLandmass>::Load

; 631  : 	}

	jmp	SHORT $LN2@operator@3
$LN1@operator@3:

; 632  : 	return readFrom;

	mov	eax, DWORD PTR _readFrom$[ebp]

; 633  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z$0:
	mov	eax, DWORD PTR $T241285[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?5VCvLandmass@@@@YAAAVFDataStream@@AAV0@AAV?$FFreeListTrashArray@VCvLandmass@@@@@Z ENDP ; operator>><CvLandmass>
EXTRN	?Write@FDataStream@@IAEXABE@Z:PROC		; FDataStream::Write
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z
_TEXT	SEGMENT
_i$ = -12						; size = 4
_values$ = -8						; size = 4
_count$ = -4						; size = 4
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z PROC ; operator<<<unsigned char const >, COMDAT

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 503  : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _count$[ebp], ecx

; 505  : 	const ValueType * values = v.getArray();

	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _values$[ebp], eax

; 506  : 	for(i = 0; i < count; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@operator@4
$LN2@operator@4:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN3@operator@4:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _count$[ebp]
	jge	SHORT $LN1@operator@4

; 507  : 	{
; 508  : 		saveTo << values[i];

	mov	eax, DWORD PTR _values$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _saveTo$[ebp]
	call	?Write@FDataStream@@IAEXABE@Z		; FDataStream::Write

; 509  : 	}

	jmp	SHORT $LN2@operator@4
$LN1@operator@4:

; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[ebp]

; 511  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6$$CBE@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@$$CBE@@@Z ENDP ; operator<<<unsigned char const >
_TEXT	ENDS
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_eType$236193 = -8					; size = 4
_iI$236189 = -4						; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 560  : 	kStream << uiArraySize;

	lea	eax, DWORD PTR _uiArraySize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	mov	DWORD PTR _iI$236189[ebp], 0
	jmp	SHORT $LN4@WriteHashe
$LN3@WriteHashe:
	mov	ecx, DWORD PTR _iI$236189[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$236189[ebp], ecx
$LN4@WriteHashe:
	mov	edx, DWORD PTR _iI$236189[ebp]
	cmp	edx, DWORD PTR _uiArraySize$[ebp]
	jae	SHORT $LN5@WriteHashe

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);

	mov	eax, DWORD PTR _iI$236189[ebp]
	mov	DWORD PTR _eType$236193[ebp], eax

; 565  : 		if(WriteHashed(kStream, eType))

	mov	ecx, DWORD PTR _eType$236193[ebp]
	push	ecx
	mov	edx, DWORD PTR _kStream$[ebp]
	push	edx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	mov	ecx, DWORD PTR _iI$236189[ebp]
	mov	edx, DWORD PTR _paArray$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _kStream$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN1@WriteHashe:

; 568  : 		}
; 569  : 	}

	jmp	SHORT $LN3@WriteHashe
$LN5@WriteHashe:

; 570  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
_TEXT	ENDS
EXTRN	??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z:PROC	; operator<<
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
;	COMDAT ??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z
_TEXT	SEGMENT
$T241426 = -68						; size = 4
$T241419 = -64						; size = 4
$T241414 = -60						; size = 4
$T241407 = -56						; size = 4
$T241400 = -52						; size = 4
$T241393 = -48						; size = 4
$T241386 = -44						; size = 4
$T241379 = -40						; size = 4
$T241375 = -36						; size = 4
$T241374 = -32						; size = 4
$T241373 = -28						; size = 4
$T241372 = -24						; size = 4
$T241371 = -20						; size = 4
$T241370 = -16						; size = 4
$T241369 = -12						; size = 4
_entry$236212 = -8					; size = 4
_i$ = -4						; size = 4
_writeTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z PROC ; operator<<<CvArea>, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 574  : 	writeTo << readFrom.GetNumSlots();

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T241379[ebp], ecx
	mov	edx, DWORD PTR $T241379[ebp]
	mov	DWORD PTR $T241369[ebp], edx
	lea	eax, DWORD PTR $T241369[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 575  : 	writeTo << readFrom.GetLastIndex();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T241386[ebp], edx
	mov	eax, DWORD PTR $T241386[ebp]
	mov	DWORD PTR $T241370[ebp], eax
	lea	ecx, DWORD PTR $T241370[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 576  : 	writeTo << readFrom.GetFreeListHead();

	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241393[ebp], eax
	mov	ecx, DWORD PTR $T241393[ebp]
	mov	DWORD PTR $T241371[ebp], ecx
	lea	edx, DWORD PTR $T241371[ebp]
	push	edx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 577  : 	writeTo << readFrom.GetFreeListCount();

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241400[ebp], ecx
	mov	edx, DWORD PTR $T241400[ebp]
	mov	DWORD PTR $T241372[ebp], edx
	lea	eax, DWORD PTR $T241372[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 578  : 	writeTo << readFrom.GetCurrentID();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T241407[ebp], edx
	mov	eax, DWORD PTR $T241407[ebp]
	mov	DWORD PTR $T241373[ebp], eax
	lea	ecx, DWORD PTR $T241373[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 579  : 
; 580  : 	int i;
; 581  : 
; 582  : 	for ( i = 0; i < readFrom.GetNumSlots(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@operator@5
$LN6@operator@5:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@operator@5:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T241414[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR $T241414[ebp]
	jge	SHORT $LN40@operator@5

; 583  : 	{
; 584  : 		writeTo << readFrom.GetNextFreeIndex( i );

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T241419[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR $T241419[ebp]
	jge	SHORT $LN32@operator@5
	mov	eax, DWORD PTR _readFrom$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN33@operator@5
$LN32@operator@5:
	mov	DWORD PTR $T241426[ebp], -1
	jmp	SHORT $LN34@operator@5
$LN33@operator@5:
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T241426[ebp], ecx
$LN34@operator@5:
	mov	edx, DWORD PTR $T241426[ebp]
	mov	DWORD PTR $T241374[ebp], edx
	lea	eax, DWORD PTR $T241374[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 585  : 	}

	jmp	SHORT $LN6@operator@5

; 586  : 
; 587  : 	writeTo << readFrom.GetCount();

$LN40@operator@5:
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	DWORD PTR $T241375[ebp], eax
	lea	ecx, DWORD PTR $T241375[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 588  : 
; 589  : 	for ( i = 0; i < readFrom.GetIndexAfterLast(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN44@operator@5
$LN3@operator@5:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN44@operator@5:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN2@operator@5

; 590  : 	{
; 591  : 		if ( readFrom[ i ] )

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	test	eax, eax
	je	SHORT $LN1@operator@5

; 592  : 		{
; 593  : 			const T & entry = *(readFrom[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _entry$236212[ebp], eax

; 594  : 			writeTo << entry;

	mov	eax, DWORD PTR _entry$236212[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z ; operator<<
	add	esp, 8
$LN1@operator@5:

; 595  : 		}
; 596  : 	}

	jmp	SHORT $LN3@operator@5
$LN2@operator@5:

; 597  : 	return writeTo;

	mov	eax, DWORD PTR _writeTo$[ebp]

; 598  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6VCvArea@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvArea@@@@@Z ENDP ; operator<<<CvArea>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z
_TEXT	SEGMENT
$T241504 = -68						; size = 4
$T241497 = -64						; size = 4
$T241492 = -60						; size = 4
$T241485 = -56						; size = 4
$T241478 = -52						; size = 4
$T241471 = -48						; size = 4
$T241464 = -44						; size = 4
$T241457 = -40						; size = 4
$T241453 = -36						; size = 4
$T241452 = -32						; size = 4
$T241451 = -28						; size = 4
$T241450 = -24						; size = 4
$T241449 = -20						; size = 4
$T241448 = -16						; size = 4
$T241447 = -12						; size = 4
_entry$236237 = -8					; size = 4
_i$ = -4						; size = 4
_writeTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z PROC ; operator<<<CvLandmass>, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 574  : 	writeTo << readFrom.GetNumSlots();

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T241457[ebp], ecx
	mov	edx, DWORD PTR $T241457[ebp]
	mov	DWORD PTR $T241447[ebp], edx
	lea	eax, DWORD PTR $T241447[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 575  : 	writeTo << readFrom.GetLastIndex();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR $T241464[ebp], edx
	mov	eax, DWORD PTR $T241464[ebp]
	mov	DWORD PTR $T241448[ebp], eax
	lea	ecx, DWORD PTR $T241448[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 576  : 	writeTo << readFrom.GetFreeListHead();

	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241471[ebp], eax
	mov	ecx, DWORD PTR $T241471[ebp]
	mov	DWORD PTR $T241449[ebp], ecx
	lea	edx, DWORD PTR $T241449[ebp]
	push	edx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 577  : 	writeTo << readFrom.GetFreeListCount();

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T241478[ebp], ecx
	mov	edx, DWORD PTR $T241478[ebp]
	mov	DWORD PTR $T241450[ebp], edx
	lea	eax, DWORD PTR $T241450[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 578  : 	writeTo << readFrom.GetCurrentID();

	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR $T241485[ebp], edx
	mov	eax, DWORD PTR $T241485[ebp]
	mov	DWORD PTR $T241451[ebp], eax
	lea	ecx, DWORD PTR $T241451[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 579  : 
; 580  : 	int i;
; 581  : 
; 582  : 	for ( i = 0; i < readFrom.GetNumSlots(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@operator@6
$LN6@operator@6:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN7@operator@6:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T241492[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR $T241492[ebp]
	jge	SHORT $LN40@operator@6

; 583  : 	{
; 584  : 		writeTo << readFrom.GetNextFreeIndex( i );

	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR $T241497[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR $T241497[ebp]
	jge	SHORT $LN32@operator@6
	mov	eax, DWORD PTR _readFrom$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN33@operator@6
$LN32@operator@6:
	mov	DWORD PTR $T241504[ebp], -1
	jmp	SHORT $LN34@operator@6
$LN33@operator@6:
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8]
	mov	DWORD PTR $T241504[ebp], ecx
$LN34@operator@6:
	mov	edx, DWORD PTR $T241504[ebp]
	mov	DWORD PTR $T241452[ebp], edx
	lea	eax, DWORD PTR $T241452[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 585  : 	}

	jmp	SHORT $LN6@operator@6

; 586  : 
; 587  : 	writeTo << readFrom.GetCount();

$LN40@operator@6:
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	DWORD PTR $T241453[ebp], eax
	lea	ecx, DWORD PTR $T241453[ebp]
	push	ecx
	mov	ecx, DWORD PTR _writeTo$[ebp]
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 588  : 
; 589  : 	for ( i = 0; i < readFrom.GetIndexAfterLast(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN44@operator@6
$LN3@operator@6:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN44@operator@6:
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 1
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN2@operator@6

; 590  : 	{
; 591  : 		if ( readFrom[ i ] )

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	test	eax, eax
	je	SHORT $LN1@operator@6

; 592  : 		{
; 593  : 			const T & entry = *(readFrom[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _readFrom$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _readFrom$[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR _entry$236237[ebp], eax

; 594  : 			writeTo << entry;

	mov	eax, DWORD PTR _entry$236237[ebp]
	push	eax
	mov	ecx, DWORD PTR _writeTo$[ebp]
	push	ecx
	call	??6@YAAAVFDataStream@@AAV0@ABVCvLandmass@@@Z ; operator<<
	add	esp, 8
$LN1@operator@6:

; 595  : 		}
; 596  : 	}

	jmp	SHORT $LN3@operator@6
$LN2@operator@6:

; 597  : 	return writeTo;

	mov	eax, DWORD PTR _writeTo$[ebp]

; 598  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6VCvLandmass@@@@YAAAVFDataStream@@AAV0@ABV?$FFreeListTrashArray@VCvLandmass@@@@@Z ENDP ; operator<<<CvLandmass>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T241528 = -8						; size = 4
_iIndex$ = -4						; size = 4
_pData$ = 8						; size = 4
?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z PROC ; FFreeListTrashArray<CvArea>::Load, COMDAT
; _this$ = ecx

; 385  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 	assert(pData != NULL);
; 387  : 	assert(m_pArray != NULL);
; 388  : 	if (!pData || !m_pArray) return;

	cmp	DWORD PTR _pData$[ebp], 0
	je	SHORT $LN1@Load
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN2@Load
$LN1@Load:
	jmp	SHORT $LN3@Load
$LN2@Load:

; 389  : 
; 390  : 	assert((pData->GetID() & FLTA_ID_MASK) < m_iCurrentID);
; 391  : 
; 392  : 	int iIndex = (pData->GetID() & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T241528[ebp], edx
	mov	eax, DWORD PTR $T241528[ebp]
	and	eax, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], eax

; 393  : 
; 394  : 	assert(iIndex < FLTA_MAX_BUCKETS);
; 395  : 	assert(iIndex <= this->m_iLastIndex);
; 396  : 	assert(m_pArray[iIndex].pData == NULL);
; 397  : 	assert(m_pArray[iIndex].iNextFreeIndex == FFreeList::INVALID_INDEX);
; 398  : 
; 399  : 	m_pArray[iIndex].pData = pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR [edx+eax*8+4], ecx
$LN3@Load:

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Load@?$FFreeListTrashArray@VCvArea@@@@QAEXPAVCvArea@@@Z ENDP ; FFreeListTrashArray<CvArea>::Load
_TEXT	ENDS
PUBLIC	??_7?$FFreeListArrayBase@VCvArea@@@@6B@		; FFreeListArrayBase<CvArea>::`vftable'
EXTRN	??_E?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z:PROC ; FFreeListArrayBase<CvArea>::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
CONST	SEGMENT
??_7?$FFreeListArrayBase@VCvArea@@@@6B@ DD FLAT:??_E?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z ; FFreeListArrayBase<CvArea>::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ PROC		; FFreeListArrayBase<CvArea>::FFreeListArrayBase<CvArea>, COMDAT
; _this$ = ecx

; 88   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@

; 89   : 	m_iFreeListHead = FFreeList::FREE_LIST_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -2			; fffffffeH

; 90   : 	m_iFreeListCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 91   : 	m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -1

; 92   : 	m_iNumSlots = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 93   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$FFreeListArrayBase@VCvArea@@@@QAE@XZ ENDP		; FFreeListArrayBase<CvArea>::FFreeListArrayBase<CvArea>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
_TEXT	ENDS
;	COMDAT ?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iIndex$ = -4						; size = 4
_pData$ = 8						; size = 4
?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z PROC ; FFreeListTrashArray<CvLandmass>::Load, COMDAT
; _this$ = ecx

; 385  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 	assert(pData != NULL);
; 387  : 	assert(m_pArray != NULL);
; 388  : 	if (!pData || !m_pArray) return;

	cmp	DWORD PTR _pData$[ebp], 0
	je	SHORT $LN1@Load@2
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN2@Load@2
$LN1@Load@2:
	jmp	SHORT $LN3@Load@2
$LN2@Load@2:

; 389  : 
; 390  : 	assert((pData->GetID() & FLTA_ID_MASK) < m_iCurrentID);
; 391  : 
; 392  : 	int iIndex = (pData->GetID() & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _pData$[ebp]
	call	?GetID@CvLandmass@@QBEHXZ		; CvLandmass::GetID
	and	eax, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], eax

; 393  : 
; 394  : 	assert(iIndex < FLTA_MAX_BUCKETS);
; 395  : 	assert(iIndex <= this->m_iLastIndex);
; 396  : 	assert(m_pArray[iIndex].pData == NULL);
; 397  : 	assert(m_pArray[iIndex].iNextFreeIndex == FFreeList::INVALID_INDEX);
; 398  : 
; 399  : 	m_pArray[iIndex].pData = pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR [edx+eax*8+4], ecx
$LN3@Load@2:

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Load@?$FFreeListTrashArray@VCvLandmass@@@@QAEXPAVCvLandmass@@@Z ENDP ; FFreeListTrashArray<CvLandmass>::Load
_TEXT	ENDS
PUBLIC	??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@	; FFreeListArrayBase<CvLandmass>::`vftable'
EXTRN	??_E?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z:PROC ; FFreeListArrayBase<CvLandmass>::`vector deleting destructor'
;	COMDAT ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
CONST	SEGMENT
??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@ DD FLAT:??_E?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z ; FFreeListArrayBase<CvLandmass>::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ PROC	; FFreeListArrayBase<CvLandmass>::FFreeListArrayBase<CvLandmass>, COMDAT
; _this$ = ecx

; 88   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@

; 89   : 	m_iFreeListHead = FFreeList::FREE_LIST_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -2			; fffffffeH

; 90   : 	m_iFreeListCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 91   : 	m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -1

; 92   : 	m_iNumSlots = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 93   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$FFreeListArrayBase@VCvLandmass@@@@QAE@XZ ENDP	; FFreeListArrayBase<CvLandmass>::FFreeListArrayBase<CvLandmass>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredllutil\include\cvstring.h
_TEXT	ENDS
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
PUBLIC	__$ArrayPad$
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?format@CvString@@SA?AV1@PBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0
__ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?format@CvString@@SA?AV1@PBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?format@CvString@@SA?AV1@PBDZZ
_TEXT	SEGMENT
$T241543 = -52						; size = 4
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_args$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_fmt$ = 12						; size = 4
?format@CvString@@SA?AV1@PBDZZ PROC			; CvString::format, COMDAT

; 243  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?format@CvString@@SA?AV1@PBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2128				; 00000850H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T241543[ebp], 0

; 244  : 	std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 245  : 	va_list args;
; 246  : 	va_start(args,fmt);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 247  : 	formatv(result,fmt,args);

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 248  : 	va_end(args);

	mov	DWORD PTR _args$[ebp], 0

; 249  : 	return CvString(result);

	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T241543[ebp]
	or	edx, 1
	mov	DWORD PTR $T241543[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?format@CvString@@SA?AV1@PBDZZ$1:
	mov	eax, DWORD PTR $T241543[ebp]
	and	eax, 1
	je	$LN5@format
	and	DWORD PTR $T241543[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@format:
	ret	0
__ehhandler$?format@CvString@@SA?AV1@PBDZZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?format@CvString@@SA?AV1@PBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?format@CvString@@SA?AV1@PBDZZ ENDP			; CvString::format
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
tv74 = -2096						; size = 4
$T241569 = -2092					; size = 4
$T241568 = -2088					; size = 4
$T241567 = -2084					; size = 4
_maxlen$95294 = -2080					; size = 4
_kMaxAttempts$ = -2076					; size = 4
_buf$ = -2072						; size = 2048
__$ArrayPad$ = -20					; size = 4
_len$ = -16						; size = 4
_attempts$ = -12					; size = 4
_success$ = -5						; size = 1
_pbuf$ = -4						; size = 4
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	lea	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax

; 194  : 	int len = 0;

	mov	DWORD PTR _len$[ebp], 0

; 195  : 	int attempts = 0;

	mov	DWORD PTR _attempts$[ebp], 0

; 196  : 	bool success = false;

	mov	BYTE PTR _success$[ebp], 0

; 197  : 	const int kMaxAttempts = 40;

	mov	DWORD PTR _kMaxAttempts$[ebp], 40	; 00000028H
$LN10@formatv:

; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;

	mov	ecx, DWORD PTR _attempts$[ebp]
	shl	ecx, 11					; 0000000bH
	add	ecx, 2047				; 000007ffH
	mov	DWORD PTR _maxlen$95294[ebp], ecx

; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxlen$95294[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _len$[ebp], eax

; 203  : 		attempts++;

	mov	eax, DWORD PTR _attempts$[ebp]
	add	eax, 1
	mov	DWORD PTR _attempts$[ebp], eax

; 204  : 		success = (len>=0 && len<=maxlen);

	cmp	DWORD PTR _len$[ebp], 0
	jl	SHORT $LN13@formatv
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR _maxlen$95294[ebp]
	jg	SHORT $LN13@formatv
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN14@formatv
$LN13@formatv:
	mov	DWORD PTR tv74[ebp], 0
$LN14@formatv:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _success$[ebp], dl

; 205  : 		if (!success)

	movzx	eax, BYTE PTR _success$[ebp]
	test	eax, eax
	jne	SHORT $LN9@formatv

; 206  : 		{
; 207  : 			if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T241567[ebp], eax
	mov	ecx, DWORD PTR $T241567[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	mov	edx, DWORD PTR _attempts$[ebp]
	shl	edx, 11					; 0000000bH
	add	edx, 2048				; 00000800H
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T241568[ebp], eax
	mov	eax, DWORD PTR $T241568[ebp]
	mov	DWORD PTR _pbuf$[ebp], eax
$LN9@formatv:

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	movzx	ecx, BYTE PTR _success$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@formatv
	cmp	DWORD PTR _attempts$[ebp], 40		; 00000028H
	jl	$LN10@formatv
$LN4@formatv:

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)

	movzx	edx, BYTE PTR _success$[ebp]
	test	edx, edx
	je	SHORT $LN3@formatv

; 220  : 		out = pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 221  : 	else

	jmp	SHORT $LN2@formatv
$LN3@formatv:

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _out$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@formatv:

; 223  : 
; 224  : 	if (pbuf!=buf)

	mov	ecx, DWORD PTR _pbuf$[ebp]
	lea	edx, DWORD PTR _buf$[ebp]
	cmp	ecx, edx
	je	SHORT $LN1@formatv

; 225  : 		delete [] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T241569[ebp], eax
	mov	ecx, DWORD PTR $T241569[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@formatv:

; 226  : 
; 227  : 	return success;

	mov	al, BYTE PTR _success$[ebp]

; 228  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT

; 298  : {

	push	ebp
	mov	ebp, esp

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	DWORD PTR _p$[ebp], 0
	jl	SHORT $LN1@teamType
	cmp	DWORD PTR _p$[ebp], 64			; 00000040H
	jge	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN2@teamType
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1
$LN2@teamType:

; 302  : }

	pop	ebp
	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T241580 = -4						; size = 4
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 244  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@isCity
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241580[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T241580[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN2@isCity
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al
$LN2@isCity:

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T241586 = -4						; size = 4
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 532  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	jl	SHORT $LN1@getPlotCit
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 64			; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR $T241586[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	ecx, DWORD PTR $T241586[ebp]
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN2@getPlotCit
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax
$LN2@getPlotCit:

; 537  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
_TEXT	ENDS
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 87   : {

	push	ebp
	mov	ebp, esp

; 88   : 	if(bWrap)

	movzx	eax, BYTE PTR _bWrap$[ebp]
	test	eax, eax
	je	SHORT $LN4@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)

	cmp	DWORD PTR _iCoord$[ebp], 0
	jge	SHORT $LN3@coordRange

; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	add	edx, DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
	jmp	SHORT $LN4@coordRange
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	mov	ecx, DWORD PTR _iCoord$[ebp]
	cmp	ecx, DWORD PTR _iRange$[ebp]
	jl	SHORT $LN4@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	mov	eax, DWORD PTR _iCoord$[ebp]
	cdq
	idiv	DWORD PTR _iRange$[ebp]
	mov	eax, edx
	jmp	SHORT $LN5@coordRange
$LN4@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;

	mov	eax, DWORD PTR _iCoord$[ebp]
$LN5@coordRange:

; 101  : }

	pop	ebp
	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
_this$ = -12						; size = 4
$T241600 = -8						; size = 4
$T241596 = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 156  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	cmp	DWORD PTR _iX$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4020]
	mov	DWORD PTR $T241596[ebp], ecx
	mov	edx, DWORD PTR _iX$[ebp]
	cmp	edx, DWORD PTR $T241596[ebp]
	jge	SHORT $LN3@isPlot
	cmp	DWORD PTR _iY$[ebp], 0
	jl	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4024]
	mov	DWORD PTR $T241600[ebp], ecx
	mov	edx, DWORD PTR _iY$[ebp]
	cmp	edx, DWORD PTR $T241600[ebp]
	jge	SHORT $LN3@isPlot
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@isPlot
$LN3@isPlot:
	mov	DWORD PTR tv72[ebp], 0
$LN4@isPlot:
	mov	eax, DWORD PTR tv72[ebp]

; 161  : #endif
; 162  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_G?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z PROC	; FFreeListArrayBase<CvArea>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$FFreeListArrayBase@VCvArea@@@@UAEPAXI@Z ENDP	; FFreeListArrayBase<CvArea>::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_G?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z PROC	; FFreeListArrayBase<CvLandmass>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN1@scalar@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$FFreeListArrayBase@VCvLandmass@@@@UAEPAXI@Z ENDP	; FFreeListArrayBase<CvLandmass>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ	; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
xdata$x	SEGMENT
__unwindtable$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ$0
__ehfuncinfo$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	ENDS
;	COMDAT ??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ PROC		; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>, COMDAT
; _this$ = ecx

; 140  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListTrashArray@VCvArea@@@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 141  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ ; FFreeListTrashArray<CvArea>::Uninit

; 142  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ ; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>
__ehhandler$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ENDP		; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ PROC		; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>, COMDAT
; _this$ = ecx

; 34   : 	virtual ~FFreeListArrayBase() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvArea@@@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FFreeListArrayBase@VCvArea@@@@UAE@XZ ENDP		; FFreeListArrayBase<CvArea>::~FFreeListArrayBase<CvArea>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
_TEXT	ENDS
;	COMDAT ?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T241627 = -12						; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_iNumSlots$ = 8						; size = 4
?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z PROC	; FFreeListTrashArray<CvArea>::Init, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 	int iCount;
; 149  : 	int iI;
; 150  : 
; 151  : 	assert(iNumSlots >= 0);
; 152  : 
; 153  : 	// make sure it's binary...
; 154  : 	if ((iNumSlots > 0) && ((iNumSlots - 1) & iNumSlots) != 0)

	cmp	DWORD PTR _iNumSlots$[ebp], 0
	jle	SHORT $LN7@Init
	mov	eax, DWORD PTR _iNumSlots$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _iNumSlots$[ebp]
	je	SHORT $LN7@Init

; 155  : 	{
; 156  : 		// find high bit
; 157  : 		iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0
$LN6@Init:

; 158  : 		while (iNumSlots != 1)

	cmp	DWORD PTR _iNumSlots$[ebp], 1
	je	SHORT $LN5@Init

; 159  : 		{
; 160  : 			iNumSlots >>= 1;

	mov	ecx, DWORD PTR _iNumSlots$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _iNumSlots$[ebp], ecx

; 161  : 			iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx

; 162  : 		}

	jmp	SHORT $LN6@Init
$LN5@Init:

; 163  : 		iNumSlots = (1 << (iCount + 1));

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _iNumSlots$[ebp], eax
$LN7@Init:

; 164  : 	}
; 165  : 
; 166  : 	assert(((iNumSlots - 1) & iNumSlots) == 0);
; 167  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::init() size too large");
; 168  : 
; 169  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 170  : 
; 171  : 	this->m_iNumSlots = iNumSlots;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iNumSlots$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 172  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -1

; 173  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1

; 174  : 	this->m_iFreeListCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 175  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 8192		; 00002000H

; 176  : 
; 177  : 	if (this->m_iNumSlots > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jle	SHORT $LN8@Init

; 178  : 	{
; 179  : 		m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T241627[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T241627[ebp]
	mov	DWORD PTR [eax+24], ecx

; 180  : 
; 181  : 		for (iI = 0; iI < this->m_iNumSlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@Init
$LN2@Init:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN3@Init:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN8@Init

; 182  : 		{
; 183  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8], -1

; 184  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], 0

; 185  : 		}

	jmp	SHORT $LN2@Init
$LN8@Init:

; 186  : 	}
; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@?$FFreeListTrashArray@VCvArea@@@@UAEXH@Z ENDP	; FFreeListTrashArray<CvArea>::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T241635 = -8						; size = 4
$T241634 = -4						; size = 4
?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ PROC	; FFreeListTrashArray<CvArea>::Uninit, COMDAT
; _this$ = ecx

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 	if (m_pArray != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN2@Uninit

; 194  : 	{
; 195  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 196  : 
; 197  : 		SAFE_DELETE_ARRAY(m_pArray);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T241635[ebp], ecx
	mov	edx, DWORD PTR $T241635[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241634[ebp], eax
	mov	ecx, DWORD PTR $T241634[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T241635[ebp]
	mov	DWORD PTR [edx], 0
$LN2@Uninit:

; 198  : 	}
; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ ENDP	; FFreeListTrashArray<CvArea>::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T241641 = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z PROC ; FFreeListTrashArray<CvArea>::GetAt, COMDAT
; _this$ = ecx

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	int iIndex;
; 275  : 
; 276  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	cmp	DWORD PTR _iID$[ebp], -1
	je	SHORT $LN4@GetAt
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@GetAt
$LN4@GetAt:

; 277  : 	{
; 278  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN6@GetAt
$LN5@GetAt:

; 279  : 	}
; 280  : 
; 281  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], ecx

; 282  : 
; 283  : 	assert(iIndex >= 0);
; 284  : 
; 285  : 	if ((iIndex <= this->m_iLastIndex) && 
; 286  : 		(m_pArray[iIndex].pData != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jg	SHORT $LN3@GetAt
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	SHORT $LN3@GetAt

; 287  : 	{
; 288  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, -8192				; ffffe000H
	je	SHORT $LN1@GetAt
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241641[ebp], eax
	mov	ecx, DWORD PTR $T241641[ebp]
	cmp	ecx, DWORD PTR _iID$[ebp]
	jne	SHORT $LN3@GetAt
$LN1@GetAt:

; 289  : 		{
; 290  : 			return m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	jmp	SHORT $LN6@GetAt
$LN3@GetAt:

; 291  : 		}
; 292  : 	}
; 293  : 
; 294  : 	return NULL;

	xor	eax, eax
$LN6@GetAt:

; 295  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UBEPBVCvArea@@H@Z ENDP ; FFreeListTrashArray<CvArea>::GetAt
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T241647 = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z PROC ; FFreeListTrashArray<CvArea>::GetAt, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 248  : 	int iIndex;
; 249  : 
; 250  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	cmp	DWORD PTR _iID$[ebp], -1
	je	SHORT $LN4@GetAt@2
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@GetAt@2
$LN4@GetAt@2:

; 251  : 	{
; 252  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN6@GetAt@2
$LN5@GetAt@2:

; 253  : 	}
; 254  : 
; 255  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], ecx

; 256  : 
; 257  : 	assert(iIndex >= 0);
; 258  : 
; 259  : 	if ((iIndex <= this->m_iLastIndex) && 
; 260  : 		(m_pArray[iIndex].pData != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jg	SHORT $LN3@GetAt@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	SHORT $LN3@GetAt@2

; 261  : 	{
; 262  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, -8192				; ffffe000H
	je	SHORT $LN1@GetAt@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR $T241647[ebp], eax
	mov	ecx, DWORD PTR $T241647[ebp]
	cmp	ecx, DWORD PTR _iID$[ebp]
	jne	SHORT $LN3@GetAt@2
$LN1@GetAt@2:

; 263  : 		{
; 264  : 			return m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	jmp	SHORT $LN6@GetAt@2
$LN3@GetAt@2:

; 265  : 		}
; 266  : 	}
; 267  : 
; 268  : 	return NULL;

	xor	eax, eax
$LN6@GetAt@2:

; 269  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$FFreeListTrashArray@VCvArea@@@@UAEPAVCvArea@@H@Z ENDP ; FFreeListTrashArray<CvArea>::GetAt
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ
_TEXT	SEGMENT
tv136 = -20						; size = 4
_this$ = -16						; size = 4
$T241651 = -12						; size = 4
$T241650 = -8						; size = 4
_iI$ = -4						; size = 4
?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ PROC	; FFreeListTrashArray<CvArea>::RemoveAll, COMDAT
; _this$ = ecx

; 359  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 	int iI;
; 361  : 
; 362  : 	if (m_pArray == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@RemoveAll

; 363  : 	{
; 364  : 		return;

	jmp	$LN6@RemoveAll
$LN5@RemoveAll:

; 365  : 	}
; 366  : 
; 367  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], -1

; 368  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], -1

; 369  : 	this->m_iFreeListCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 370  : 
; 371  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@RemoveAll
$LN3@RemoveAll:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN4@RemoveAll:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jge	SHORT $LN6@RemoveAll

; 372  : 	{
; 373  : 		m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx+eax*8], -1

; 374  : 		if (m_pArray[iI].pData != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	SHORT $LN1@RemoveAll

; 375  : 		{
; 376  : 			delete m_pArray[iI].pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR $T241651[ebp], ecx
	mov	edx, DWORD PTR $T241651[ebp]
	mov	DWORD PTR $T241650[ebp], edx
	cmp	DWORD PTR $T241650[ebp], 0
	je	SHORT $LN8@RemoveAll
	mov	ecx, DWORD PTR $T241650[ebp]
	call	??1CvArea@@QAE@XZ			; CvArea::~CvArea
	mov	eax, 1
	and	eax, 1
	je	SHORT $LN11@RemoveAll
	mov	ecx, DWORD PTR $T241650[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@RemoveAll:
	mov	edx, DWORD PTR $T241650[ebp]
	mov	DWORD PTR tv136[ebp], edx
	jmp	SHORT $LN1@RemoveAll
$LN8@RemoveAll:
	mov	DWORD PTR tv136[ebp], 0
$LN1@RemoveAll:

; 377  : 		}
; 378  : 		m_pArray[iI].pData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [ecx+edx*8+4], 0

; 379  : 	}

	jmp	$LN3@RemoveAll
$LN6@RemoveAll:

; 380  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$FFreeListTrashArray@VCvArea@@@@UAEXXZ ENDP	; FFreeListTrashArray<CvArea>::RemoveAll
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T241661 = -20						; size = 4
$T241660 = -16						; size = 4
_pOldArray$ = -12					; size = 4
_iI$ = -8						; size = 4
_iOldNumSlots$ = -4					; size = 4
?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ PROC	; FFreeListTrashArray<CvArea>::GrowArray, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 407  : 	FFreeListTrashArrayNode* pOldArray;
; 408  : 	int iOldNumSlots;
; 409  : 	int iI;
; 410  : 
; 411  : 	assert(m_pArray != NULL);
; 412  : 	
; 413  : 	if(!m_pArray) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN6@GrowArray
	jmp	$LN7@GrowArray
$LN6@GrowArray:

; 414  : 
; 415  : 	pOldArray = m_pArray;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _pOldArray$[ebp], edx

; 416  : 	iOldNumSlots = this->m_iNumSlots;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _iOldNumSlots$[ebp], ecx

; 417  : 
; 418  : 	this->m_iNumSlots *= FLTA_GROWTH_FACTOR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 419  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::growArray() size too large");
; 420  : 	m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T241660[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T241660[ebp]
	mov	DWORD PTR [eax+24], ecx

; 421  : 
; 422  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@GrowArray
$LN4@GrowArray:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN5@GrowArray:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN3@GrowArray

; 423  : 	{
; 424  : 		if (iI < iOldNumSlots)

	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iOldNumSlots$[ebp]
	jge	SHORT $LN2@GrowArray

; 425  : 		{
; 426  : 			m_pArray[iI] = pOldArray[iI];

	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR _pOldArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	esi, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [ecx+esi*8], edx
	mov	DWORD PTR [ecx+esi*8+4], eax

; 427  : 		}
; 428  : 		else

	jmp	SHORT $LN1@GrowArray
$LN2@GrowArray:

; 429  : 		{
; 430  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8], -1

; 431  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], 0
$LN1@GrowArray:

; 432  : 		}
; 433  : 	}

	jmp	SHORT $LN4@GrowArray
$LN3@GrowArray:

; 434  : 
; 435  : 	delete [] pOldArray;

	mov	edx, DWORD PTR _pOldArray$[ebp]
	mov	DWORD PTR $T241661[ebp], edx
	mov	eax, DWORD PTR $T241661[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@GrowArray:

; 436  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GrowArray@?$FFreeListTrashArray@VCvArea@@@@MAEXXZ ENDP	; FFreeListTrashArray<CvArea>::GrowArray
_TEXT	ENDS
PUBLIC	??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ	; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>
;	COMDAT xdata$x
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
xdata$x	SEGMENT
__unwindtable$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ$0
__ehfuncinfo$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
xdata$x	ENDS
;	COMDAT ??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ PROC	; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>, COMDAT
; _this$ = ecx

; 140  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListTrashArray@VCvLandmass@@@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 141  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ; FFreeListTrashArray<CvLandmass>::Uninit

; 142  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ ; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>
__ehhandler$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ENDP	; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelistarraybase.h
;	COMDAT ??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ PROC	; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>, COMDAT
; _this$ = ecx

; 34   : 	virtual ~FFreeListArrayBase() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7?$FFreeListArrayBase@VCvLandmass@@@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$FFreeListArrayBase@VCvLandmass@@@@UAE@XZ ENDP	; FFreeListArrayBase<CvLandmass>::~FFreeListArrayBase<CvLandmass>
; Function compile flags: /Odtp
; File d:\sources\lekmod_git\checkout\lekmod_dll\fireplace\include\fireworks\ffreelisttrasharray.h
_TEXT	ENDS
;	COMDAT ?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T241678 = -12						; size = 4
_iCount$ = -8						; size = 4
_iI$ = -4						; size = 4
_iNumSlots$ = 8						; size = 4
?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z PROC	; FFreeListTrashArray<CvLandmass>::Init, COMDAT
; _this$ = ecx

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 	int iCount;
; 149  : 	int iI;
; 150  : 
; 151  : 	assert(iNumSlots >= 0);
; 152  : 
; 153  : 	// make sure it's binary...
; 154  : 	if ((iNumSlots > 0) && ((iNumSlots - 1) & iNumSlots) != 0)

	cmp	DWORD PTR _iNumSlots$[ebp], 0
	jle	SHORT $LN7@Init@2
	mov	eax, DWORD PTR _iNumSlots$[ebp]
	sub	eax, 1
	and	eax, DWORD PTR _iNumSlots$[ebp]
	je	SHORT $LN7@Init@2

; 155  : 	{
; 156  : 		// find high bit
; 157  : 		iCount = 0;

	mov	DWORD PTR _iCount$[ebp], 0
$LN6@Init@2:

; 158  : 		while (iNumSlots != 1)

	cmp	DWORD PTR _iNumSlots$[ebp], 1
	je	SHORT $LN5@Init@2

; 159  : 		{
; 160  : 			iNumSlots >>= 1;

	mov	ecx, DWORD PTR _iNumSlots$[ebp]
	sar	ecx, 1
	mov	DWORD PTR _iNumSlots$[ebp], ecx

; 161  : 			iCount++;

	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx

; 162  : 		}

	jmp	SHORT $LN6@Init@2
$LN5@Init@2:

; 163  : 		iNumSlots = (1 << (iCount + 1));

	mov	ecx, DWORD PTR _iCount$[ebp]
	add	ecx, 1
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR _iNumSlots$[ebp], eax
$LN7@Init@2:

; 164  : 	}
; 165  : 
; 166  : 	assert(((iNumSlots - 1) & iNumSlots) == 0);
; 167  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::init() size too large");
; 168  : 
; 169  : 	Uninit();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 170  : 
; 171  : 	this->m_iNumSlots = iNumSlots;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iNumSlots$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 172  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -1

; 173  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1

; 174  : 	this->m_iFreeListCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 175  : 	m_iCurrentID = FLTA_MAX_BUCKETS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 8192		; 00002000H

; 176  : 
; 177  : 	if (this->m_iNumSlots > 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jle	SHORT $LN8@Init@2

; 178  : 	{
; 179  : 		m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T241678[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T241678[ebp]
	mov	DWORD PTR [eax+24], ecx

; 180  : 
; 181  : 		for (iI = 0; iI < this->m_iNumSlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN3@Init@2
$LN2@Init@2:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN3@Init@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN8@Init@2

; 182  : 		{
; 183  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8], -1

; 184  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], 0

; 185  : 		}

	jmp	SHORT $LN2@Init@2
$LN8@Init@2:

; 186  : 	}
; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Init@?$FFreeListTrashArray@VCvLandmass@@@@UAEXH@Z ENDP	; FFreeListTrashArray<CvLandmass>::Init
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T241686 = -8						; size = 4
$T241685 = -4						; size = 4
?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ PROC ; FFreeListTrashArray<CvLandmass>::Uninit, COMDAT
; _this$ = ecx

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 	if (m_pArray != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN2@Uninit@2

; 194  : 	{
; 195  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 196  : 
; 197  : 		SAFE_DELETE_ARRAY(m_pArray);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR $T241686[ebp], ecx
	mov	edx, DWORD PTR $T241686[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T241685[ebp], eax
	mov	ecx, DWORD PTR $T241685[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	edx, DWORD PTR $T241686[ebp]
	mov	DWORD PTR [edx], 0
$LN2@Uninit@2:

; 198  : 	}
; 199  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Uninit@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ENDP ; FFreeListTrashArray<CvLandmass>::Uninit
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z PROC ; FFreeListTrashArray<CvLandmass>::GetAt, COMDAT
; _this$ = ecx

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	int iIndex;
; 275  : 
; 276  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	cmp	DWORD PTR _iID$[ebp], -1
	je	SHORT $LN4@GetAt@3
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@GetAt@3
$LN4@GetAt@3:

; 277  : 	{
; 278  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN6@GetAt@3
$LN5@GetAt@3:

; 279  : 	}
; 280  : 
; 281  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], ecx

; 282  : 
; 283  : 	assert(iIndex >= 0);
; 284  : 
; 285  : 	if ((iIndex <= this->m_iLastIndex) && 
; 286  : 		(m_pArray[iIndex].pData != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jg	SHORT $LN3@GetAt@3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	SHORT $LN3@GetAt@3

; 287  : 	{
; 288  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, -8192				; ffffe000H
	je	SHORT $LN1@GetAt@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
	call	?GetID@CvLandmass@@QBEHXZ		; CvLandmass::GetID
	cmp	eax, DWORD PTR _iID$[ebp]
	jne	SHORT $LN3@GetAt@3
$LN1@GetAt@3:

; 289  : 		{
; 290  : 			return m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	jmp	SHORT $LN6@GetAt@3
$LN3@GetAt@3:

; 291  : 		}
; 292  : 	}
; 293  : 
; 294  : 	return NULL;

	xor	eax, eax
$LN6@GetAt@3:

; 295  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UBEPBVCvLandmass@@H@Z ENDP ; FFreeListTrashArray<CvLandmass>::GetAt
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_iIndex$ = -4						; size = 4
_iID$ = 8						; size = 4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z PROC ; FFreeListTrashArray<CvLandmass>::GetAt, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 248  : 	int iIndex;
; 249  : 
; 250  : 	if ((iID == FFreeList::INVALID_INDEX) || (m_pArray == NULL))

	cmp	DWORD PTR _iID$[ebp], -1
	je	SHORT $LN4@GetAt@4
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@GetAt@4
$LN4@GetAt@4:

; 251  : 	{
; 252  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN6@GetAt@4
$LN5@GetAt@4:

; 253  : 	}
; 254  : 
; 255  : 	iIndex = (iID & FLTA_INDEX_MASK);

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, 8191				; 00001fffH
	mov	DWORD PTR _iIndex$[ebp], ecx

; 256  : 
; 257  : 	assert(iIndex >= 0);
; 258  : 
; 259  : 	if ((iIndex <= this->m_iLastIndex) && 
; 260  : 		(m_pArray[iIndex].pData != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jg	SHORT $LN3@GetAt@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iIndex$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	SHORT $LN3@GetAt@4

; 261  : 	{
; 262  : 		if (((iID & FLTA_ID_MASK) == 0) || (m_pArray[iIndex].pData->GetID() == iID))

	mov	ecx, DWORD PTR _iID$[ebp]
	and	ecx, -8192				; ffffe000H
	je	SHORT $LN1@GetAt@4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*8+4]
	call	?GetID@CvLandmass@@QBEHXZ		; CvLandmass::GetID
	cmp	eax, DWORD PTR _iID$[ebp]
	jne	SHORT $LN3@GetAt@4
$LN1@GetAt@4:

; 263  : 		{
; 264  : 			return m_pArray[iIndex].pData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iIndex$[ebp]
	mov	eax, DWORD PTR [eax+ecx*8+4]
	jmp	SHORT $LN6@GetAt@4
$LN3@GetAt@4:

; 265  : 		}
; 266  : 	}
; 267  : 
; 268  : 	return NULL;

	xor	eax, eax
$LN6@GetAt@4:

; 269  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetAt@?$FFreeListTrashArray@VCvLandmass@@@@UAEPAVCvLandmass@@H@Z ENDP ; FFreeListTrashArray<CvLandmass>::GetAt
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ
_TEXT	SEGMENT
tv138 = -20						; size = 4
_this$ = -16						; size = 4
$T241694 = -12						; size = 4
$T241693 = -8						; size = 4
_iI$ = -4						; size = 4
?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ PROC ; FFreeListTrashArray<CvLandmass>::RemoveAll, COMDAT
; _this$ = ecx

; 359  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 	int iI;
; 361  : 
; 362  : 	if (m_pArray == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@RemoveAll@2

; 363  : 	{
; 364  : 		return;

	jmp	$LN6@RemoveAll@2
$LN5@RemoveAll@2:

; 365  : 	}
; 366  : 
; 367  : 	this->m_iLastIndex = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], -1

; 368  : 	this->m_iFreeListHead = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], -1

; 369  : 	this->m_iFreeListCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 370  : 
; 371  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN4@RemoveAll@2
$LN3@RemoveAll@2:
	mov	ecx, DWORD PTR _iI$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iI$[ebp], ecx
$LN4@RemoveAll@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jge	SHORT $LN6@RemoveAll@2

; 372  : 	{
; 373  : 		m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx+eax*8], -1

; 374  : 		if (m_pArray[iI].pData != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	cmp	DWORD PTR [edx+eax*8+4], 0
	je	SHORT $LN1@RemoveAll@2

; 375  : 		{
; 376  : 			delete m_pArray[iI].pData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR [edx+eax*8+4]
	mov	DWORD PTR $T241694[ebp], ecx
	mov	edx, DWORD PTR $T241694[ebp]
	mov	DWORD PTR $T241693[ebp], edx
	cmp	DWORD PTR $T241693[ebp], 0
	je	SHORT $LN8@RemoveAll@2
	push	1
	mov	eax, DWORD PTR $T241693[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T241693[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN1@RemoveAll@2
$LN8@RemoveAll@2:
	mov	DWORD PTR tv138[ebp], 0
$LN1@RemoveAll@2:

; 377  : 		}
; 378  : 		m_pArray[iI].pData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [edx+eax*8+4], 0

; 379  : 	}

	jmp	SHORT $LN3@RemoveAll@2
$LN6@RemoveAll@2:

; 380  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$FFreeListTrashArray@VCvLandmass@@@@UAEXXZ ENDP ; FFreeListTrashArray<CvLandmass>::RemoveAll
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T241700 = -20						; size = 4
$T241699 = -16						; size = 4
_pOldArray$ = -12					; size = 4
_iI$ = -8						; size = 4
_iOldNumSlots$ = -4					; size = 4
?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ PROC ; FFreeListTrashArray<CvLandmass>::GrowArray, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 407  : 	FFreeListTrashArrayNode* pOldArray;
; 408  : 	int iOldNumSlots;
; 409  : 	int iI;
; 410  : 
; 411  : 	assert(m_pArray != NULL);
; 412  : 	
; 413  : 	if(!m_pArray) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN6@GrowArray@2
	jmp	$LN7@GrowArray@2
$LN6@GrowArray@2:

; 414  : 
; 415  : 	pOldArray = m_pArray;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _pOldArray$[ebp], edx

; 416  : 	iOldNumSlots = this->m_iNumSlots;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _iOldNumSlots$[ebp], ecx

; 417  : 
; 418  : 	this->m_iNumSlots *= FLTA_GROWTH_FACTOR;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	shl	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 419  : 	assert((this->m_iNumSlots <= FLTA_MAX_BUCKETS) && "FFreeListTrashArray<T>::growArray() size too large");
; 420  : 	m_pArray = FNEW( FFreeListTrashArrayNode[this->m_iNumSlots], c_eMPoolTypeContainer, 0 );

	xor	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T241699[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T241699[ebp]
	mov	DWORD PTR [eax+24], ecx

; 421  : 
; 422  : 	for (iI = 0; iI < this->m_iNumSlots; iI++)

	mov	DWORD PTR _iI$[ebp], 0
	jmp	SHORT $LN5@GrowArray@2
$LN4@GrowArray@2:
	mov	edx, DWORD PTR _iI$[ebp]
	add	edx, 1
	mov	DWORD PTR _iI$[ebp], edx
$LN5@GrowArray@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iI$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jge	SHORT $LN3@GrowArray@2

; 423  : 	{
; 424  : 		if (iI < iOldNumSlots)

	mov	edx, DWORD PTR _iI$[ebp]
	cmp	edx, DWORD PTR _iOldNumSlots$[ebp]
	jge	SHORT $LN2@GrowArray@2

; 425  : 		{
; 426  : 			m_pArray[iI] = pOldArray[iI];

	mov	eax, DWORD PTR _iI$[ebp]
	mov	ecx, DWORD PTR _pOldArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+24]
	mov	esi, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [ecx+esi*8], edx
	mov	DWORD PTR [ecx+esi*8+4], eax

; 427  : 		}
; 428  : 		else

	jmp	SHORT $LN1@GrowArray@2
$LN2@GrowArray@2:

; 429  : 		{
; 430  : 			m_pArray[iI].iNextFreeIndex = FFreeList::INVALID_INDEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8], -1

; 431  : 			m_pArray[iI].pData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _iI$[ebp]
	mov	DWORD PTR [eax+ecx*8+4], 0
$LN1@GrowArray@2:

; 432  : 		}
; 433  : 	}

	jmp	SHORT $LN4@GrowArray@2
$LN3@GrowArray@2:

; 434  : 
; 435  : 	delete [] pOldArray;

	mov	edx, DWORD PTR _pOldArray$[ebp]
	mov	DWORD PTR $T241700[ebp], edx
	mov	eax, DWORD PTR $T241700[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@GrowArray@2:

; 436  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?GrowArray@?$FFreeListTrashArray@VCvLandmass@@@@MAEXXZ ENDP ; FFreeListTrashArray<CvLandmass>::GrowArray
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_G?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z PROC	; FFreeListTrashArray<CvArea>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FFreeListTrashArray@VCvArea@@@@UAE@XZ ; FFreeListTrashArray<CvArea>::~FFreeListTrashArray<CvArea>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$FFreeListTrashArray@VCvArea@@@@UAEPAXI@Z ENDP	; FFreeListTrashArray<CvArea>::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_G?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z PROC	; FFreeListTrashArray<CvLandmass>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$FFreeListTrashArray@VCvLandmass@@@@UAE@XZ ; FFreeListTrashArray<CvLandmass>::~FFreeListTrashArray<CvLandmass>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$FFreeListTrashArray@VCvLandmass@@@@UAEPAXI@Z ENDP	; FFreeListTrashArray<CvLandmass>::`scalar deleting destructor'
_TEXT	ENDS
END
